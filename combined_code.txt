
//====================================
// FILE: ./discovery.h
//====================================

#ifndef DISCOVERY_H
#define DISCOVERY_H

#include "peer.h"

// Function declarations
int init_discovery(app_state_t *state);
void *discovery_thread(void *arg);
int broadcast_discovery(app_state_t *state);
int handle_discovery_message(app_state_t *state, const char *buffer, 
                            const char *sender_ip, socklen_t addr_len,
                            struct sockaddr_in *sender_addr);

#endif // DISCOVERY_H



//====================================
// FILE: ./peer.h
//====================================

#ifndef PEER_H
#define PEER_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <net/if.h>
#include <ifaddrs.h>
#include <netdb.h>
#include <signal.h>
#include <pthread.h>
#include <errno.h>
#include <time.h>
#include <fcntl.h>
#include <sys/select.h>

#define PORT_TCP 8080
#define PORT_UDP 8081
#define BUFFER_SIZE 1024
#define MAX_PEERS 10
#define DISCOVERY_INTERVAL 10 // seconds
#define PEER_TIMEOUT 30 // seconds

// Message types
#define MSG_DISCOVERY "DISCOVERY"
#define MSG_DISCOVERY_RESPONSE "DISCOVERY_RESPONSE"
#define MSG_TEXT "TEXT"
#define MSG_QUIT "QUIT"

// Peer structure
typedef struct {
    char ip[INET_ADDRSTRLEN];
    char username[32];
    time_t last_seen;
    int active;
} peer_t;

// Global state
typedef struct app_state_t {
    volatile sig_atomic_t running;  // Flag indicating if the application is running; volatile ensures visibility across threads
                                    // and sig_atomic_t guarantees atomic access from signal handlers
    
    peer_t peers[MAX_PEERS];        // Array of peer structures containing information about connected peers
                                    // Limited to MAX_PEERS entries to prevent unbounded memory usage
    
    int tcp_socket;                 // File descriptor for the TCP socket used for reliable message exchange
                                    // Negative value indicates an uninitialized or closed socket
    
    int udp_socket;                 // File descriptor for the UDP socket used for peer discovery broadcasts
                                    // Negative value indicates an uninitialized or closed socket
    
    char username[32];              // User's chosen display name, limited to 31 characters plus null terminator
                                    // Used to identify this peer in messages to others
    
    pthread_mutex_t peers_mutex;    // Mutex to protect concurrent access to the peers array
                                    // Ensures thread safety when multiple threads read/write peer information
                                    // Basically means r/w to this var can not be interrupted. Threads call for to
                                    // hold the lock on this var and will be blocked until the lock is released by another
} app_state_t;

// Function declarations

// Main components
void init_app_state(app_state_t *state, const char *username);
void cleanup_app_state(app_state_t *state);

// Network functions
int init_listener(app_state_t *state);
int init_discovery(app_state_t *state);
void *listener_thread(void *arg);
void *discovery_thread(void *arg);
void *user_input_thread(void *arg);
int send_message(const char *ip, const char *message, const char *msg_type);
int broadcast_discovery(app_state_t *state);

// Protocol functions
int parse_message(const char *buffer, char *sender_ip, char *sender_username, char *msg_type, char *content);
int format_message(char *buffer, int buffer_size, const char *msg_type, 
                  const char *sender, const char *content);

// Utility functions
void handle_signal(int sig);
void log_message(const char *format, ...);
int add_peer(app_state_t *state, const char *ip, const char *username);
void set_socket_timeout(int socket, int seconds);
int get_local_ip(char *buffer, size_t size);

// Global state for signal handler
extern app_state_t *g_state;

#endif // PEER_H



//====================================
// FILE: ./ui_terminal.h
//====================================

#ifndef UI_TERMINAL_H
#define UI_TERMINAL_H

struct app_state_t;
typedef struct app_state_t app_state_t;

// Function declarations
void print_help_message(void);
void *user_input_thread(void *arg);
void print_peers(app_state_t *state);
int handle_command(app_state_t *state, const char *input);

#endif // UI_TERMINAL_H



//====================================
// FILE: ./discovery.c
//====================================

#include "discovery.h"
#include <unistd.h>

int init_discovery(app_state_t *state) {
    struct sockaddr_in address;
    int opt = 1;
    
    // Create UDP socket for discovery
    if ((state->udp_socket = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("UDP socket creation failed");
        return -1;
    }
    
    // Set socket options
    if (setsockopt(state->udp_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("UDP setsockopt failed");
        close(state->udp_socket);
        state->udp_socket = -1;
        return -1;
    }
    
    // Enable broadcast
    if (setsockopt(state->udp_socket, SOL_SOCKET, SO_BROADCAST, &opt, sizeof(opt))) {
        perror("UDP broadcast setsockopt failed");
        close(state->udp_socket);
        state->udp_socket = -1;
        return -1;
    }
    
    // Configure address
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT_UDP);
    
    // Bind socket
    if (bind(state->udp_socket, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("UDP bind failed");
        close(state->udp_socket);
        state->udp_socket = -1;
        return -1;
    }
    
    // Set timeout for UDP socket
    set_socket_timeout(state->udp_socket, 1);
    
    log_message("UDP discovery initialized on port %d", PORT_UDP);
    return 0;
}

int broadcast_discovery(app_state_t *state) {
    struct sockaddr_in broadcast_addr;
    char buffer[BUFFER_SIZE];
    
    // Format discovery message
    format_message(buffer, BUFFER_SIZE, MSG_DISCOVERY, state->username, "");
    
    // Set up broadcast address
    memset(&broadcast_addr, 0, sizeof(broadcast_addr));
    broadcast_addr.sin_family = AF_INET;
    broadcast_addr.sin_port = htons(PORT_UDP);
    broadcast_addr.sin_addr.s_addr = htonl(INADDR_BROADCAST);
    
    // Send broadcast
    if (sendto(state->udp_socket, buffer, strlen(buffer), 0,
              (struct sockaddr *)&broadcast_addr, sizeof(broadcast_addr)) < 0) {
        perror("Discovery broadcast failed");
        return -1;
    }
    
    return 0;
}

int handle_discovery_message(app_state_t *state, const char *buffer, 
                            const char *sender_ip, socklen_t addr_len,
                            struct sockaddr_in *sender_addr) {
    char sender_username[32];
    char msg_type[32];
    char content[BUFFER_SIZE];
    
    // Parse message
    if (parse_message(buffer, sender_ip, sender_username, msg_type, content) == 0) {
        if (strcmp(msg_type, MSG_DISCOVERY) == 0) {
            // Respond to discovery
            char response[BUFFER_SIZE];
            format_message(response, BUFFER_SIZE, MSG_DISCOVERY_RESPONSE, state->username, "");
            
            sendto(state->udp_socket, response, strlen(response), 0,
                  (struct sockaddr *)sender_addr, addr_len);
            
            // Add peer to list
            if (add_peer(state, sender_ip, sender_username) > 0) {
                log_message("New peer discovered: %s@%s", sender_username, sender_ip);
                return 1; // New peer
            }
            return 0; // Existing peer
        }
        else if (strcmp(msg_type, MSG_DISCOVERY_RESPONSE) == 0) {
            // Add peer to list
            if (add_peer(state, sender_ip, sender_username) > 0) {
                log_message("New peer discovered: %s@%s", sender_username, sender_ip);
                return 1; // New peer
            }
            return 0; // Existing peer
        }
    }
    return -1; // Not a discovery message
}

/*
 * This function runs in a separate thread and is responsible for:
 * 1. Periodically broadcasting discovery messages to find other peers
 * 2. Listening for discovery messages from other peers
 * 3. Responding to discovery messages with discovery response messages
 * 4. Adding discovered peers to the application's peer list
 * */
void *discovery_thread(void *arg) {
    app_state_t *state = (app_state_t *)arg;
    struct sockaddr_in sender_addr;
    socklen_t addr_len = sizeof(sender_addr);
    char buffer[BUFFER_SIZE];
    char sender_ip[INET_ADDRSTRLEN];
    char local_ip[INET_ADDRSTRLEN];
    time_t last_broadcast = 0;
    
    // Get local IP address
    if (get_local_ip(local_ip, INET_ADDRSTRLEN) < 0) {
        log_message("Failed to get local IP address");
        strcpy(local_ip, "127.0.0.1");
    }
    
    log_message("Discovery thread started (local IP: %s)", local_ip);
    
    // Initial discovery broadcast
    broadcast_discovery(state);
    last_broadcast = time(NULL);
    
    while (state->running) {
        // Periodically broadcast discovery message
        if (time(NULL) - last_broadcast >= DISCOVERY_INTERVAL) {
            broadcast_discovery(state);
            last_broadcast = time(NULL);
        }
        
        // Check for incoming discovery messages
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_read = recvfrom(state->udp_socket, buffer, BUFFER_SIZE, 0,
                                 (struct sockaddr *)&sender_addr, &addr_len);
        
        if (bytes_read > 0) {
            // Get sender IP
            inet_ntop(AF_INET, &sender_addr.sin_addr, sender_ip, INET_ADDRSTRLEN);
            
            // Skip messages from self
            if (strcmp(sender_ip, local_ip) == 0) {
                continue;
            }
            
            // Handle the discovery message
            handle_discovery_message(state, buffer, sender_ip, addr_len, &sender_addr);
        }
        
        // Small delay to prevent CPU hogging
        usleep(100000); // 100ms
    }
    
    log_message("Discovery thread stopped");
    return NULL;
}



//====================================
// FILE: ./ui_terminal.c
//====================================

/**
 * @file ui_terminal.c
 * @brief Terminal user interface implementation for the P2P messaging application
 *
 * This file contains functions for handling user input, displaying information
 * to the user, and processing commands in the terminal interface.
 */

 #include "ui_terminal.h"
 #include "peer.h"
 #include <stdio.h>
 #include <string.h>
 
 /**
  * @brief Displays the help message with available commands
  *
  * Prints a formatted list of all available commands and their descriptions
  * to the standard output.
  */
 void print_help_message(void) {
     printf("\nCommands:\n");
     printf("  /list - List all active peers\n");
     printf("  /send <peer_number> <message> - Send message to specific peer\n");
     printf("  /broadcast <message> - Send message to all peers\n");
     printf("  /quit - Exit the application\n");
     printf("  /help - Show this help message\n\n");
 }
 
 /**
  * @brief Displays a list of all active peers
  *
  * Acquires a lock on the peers list, iterates through all peers,
  * checks for timeouts, and displays active peers with their information.
  * Releases the lock when done.
  *
  * @param state Pointer to the application state
  */
 void print_peers(app_state_t *state) {
     // Lock the peers list whilst we use it
     pthread_mutex_lock(&state->peers_mutex);
     
     time_t now = time(NULL);
     int active_count = 0;
     
     printf("\n--- Active Peers ---\n");
     for (int i = 0; i < MAX_PEERS; i++) {
         if (state->peers[i].active) {
             // Check if peer has timed out
             if (now - state->peers[i].last_seen > PEER_TIMEOUT) {
                 state->peers[i].active = 0;
                 continue;
             }
             
             printf("%d. %s@%s (last seen %ld seconds ago)\n", 
                    ++active_count,
                    state->peers[i].username,
                    state->peers[i].ip, 
                    now - state->peers[i].last_seen);
         }
     }
     
     if (active_count == 0) {
         printf("No active peers found\n");
     }
     printf("------------------\n");
     
     pthread_mutex_unlock(&state->peers_mutex);
 }
 
 /**
  * @brief Processes user commands
  *
  * Parses and executes commands entered by the user. Supported commands:
  * - /list: List all active peers
  * - /help: Display help message
  * - /send <peer_number> <message>: Send a message to a specific peer
  * - /broadcast <message>: Send a message to all peers
  * - /quit: Exit the application
  *
  * @param state Pointer to the application state
  * @param input The command string entered by the user
  * @return int 0 to continue execution, 1 to exit the application
  */
 int handle_command(app_state_t *state, const char *input) {
     if (strcmp(input, "/list") == 0) {
         print_peers(state);
         return 0;
     } 
     else if (strcmp(input, "/help") == 0) {
         print_help_message();
         return 0;
     }
     else if (strncmp(input, "/send ", 6) == 0) {
         int peer_num;
         char *msg_start = strchr(input + 6, ' ');
         
         if (msg_start == NULL) {
             printf("Usage: /send <peer_number> <message>\n");
             return 0;
         }
         
         *msg_start = '\0';
         peer_num = atoi(input + 6);
         msg_start++;
         
         pthread_mutex_lock(&state->peers_mutex);
         
         int count = 0;
         int found = 0;
         char target_ip[INET_ADDRSTRLEN];
         
         for (int i = 0; i < MAX_PEERS; i++) {
             if (state->peers[i].active) {
                 count++;
                 if (count == peer_num) {
                     strcpy(target_ip, state->peers[i].ip);
                     found = 1;
                     break;
                 }
             }
         }
         
         pthread_mutex_unlock(&state->peers_mutex);
         
         if (found) {
             if (send_message(target_ip, msg_start, MSG_TEXT) < 0) {
                 log_message("Failed to send message to %s", target_ip);
             } else {
                 log_message("Message sent to %s", target_ip);
             }
         } else {
             log_message("Invalid peer number");
         }
         return 0;
     }
     else if (strncmp(input, "/broadcast ", 11) == 0) {
         pthread_mutex_lock(&state->peers_mutex);
         
         for (int i = 0; i < MAX_PEERS; i++) {
             if (state->peers[i].active) {
                 if (send_message(state->peers[i].ip, input + 11, MSG_TEXT) < 0) {
                     log_message("Failed to send message to %s", state->peers[i].ip);
                 }
             }
         }
         
         pthread_mutex_unlock(&state->peers_mutex);
         log_message("Broadcast message sent");
         return 0;
     }
     else if (strcmp(input, "/quit") == 0) {
         // Send quit message to all peers before exiting
         pthread_mutex_lock(&state->peers_mutex);
         
         for (int i = 0; i < MAX_PEERS; i++) {
             if (state->peers[i].active) {
                 // Send quit notification to each peer
                 if (send_message(state->peers[i].ip, "", MSG_QUIT) < 0) {
                     log_message("Failed to send quit notification to %s", state->peers[i].ip);
                 }
             }
         }
         
         pthread_mutex_unlock(&state->peers_mutex);
         log_message("Quit notifications sent to all peers");
         
         // Set running flag to false to exit the application
         state->running = 0;
         return 1; // Signal to exit
     }
     else {
         log_message("Unknown command. Type /help for available commands");
         return 0;
     }
 }
 
 /**
  * @brief Thread function that handles user input
  *
  * Continuously reads user input from stdin, processes commands,
  * and takes appropriate actions. Runs until the application is terminated
  * or an error occurs.
  *
  * @param arg Pointer to the application state (cast to app_state_t*)
  * @return void* NULL (thread return value, not used)
  */
 void *user_input_thread(void *arg) {
     app_state_t *state = (app_state_t *)arg;
     char input[BUFFER_SIZE];
     
     print_help_message();
     
     while (state->running) {
         printf("> ");
         fflush(stdout);
         
         if (fgets(input, BUFFER_SIZE, stdin) == NULL) {
             if (state->running) {
                 log_message("Error reading input");
             }
             break;
         }
         
         // Remove newline
         input[strcspn(input, "\n")] = 0;
         
         if (strlen(input) == 0) {
             continue;
         }
         
         if (handle_command(state, input)) {
             break; // Exit command was processed
         }
     }
     
     return NULL;
 }



//====================================
// FILE: ./network.c
//====================================

#include "peer.h"
#include <netdb.h>

int get_local_ip(char *buffer, size_t size) {
    struct ifaddrs *ifaddr, *ifa;
    int family;
    
    if (getifaddrs(&ifaddr) == -1) {
        perror("getifaddrs");
        return -1;
    }
    
    // Walk through linked list, finding the first non-loopback IPv4 address
    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == NULL)
            continue;
            
        family = ifa->ifa_addr->sa_family;
        
        // Check it is IPv4
        if (family == AF_INET) {
            // Convert IP to string to check if it's loopback
            char ip_str[INET_ADDRSTRLEN];
            struct sockaddr_in *ipv4 = (struct sockaddr_in *)ifa->ifa_addr;
            inet_ntop(AF_INET, &(ipv4->sin_addr), ip_str, INET_ADDRSTRLEN);
            
            // Skip loopback addresses (127.x.x.x)
            if (strncmp(ip_str, "127.", 4) == 0) {
                continue;
            }
            
            // Copy the IP address to the output buffer
            strncpy(buffer, ip_str, size);
            buffer[size-1] = '\0';
            
            freeifaddrs(ifaddr);
            return 0;
        }
    }
    
    freeifaddrs(ifaddr);
    return -1;
}

void set_socket_timeout(int socket, int seconds) {
    struct timeval tv;
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    setsockopt(socket, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
}

int init_listener(app_state_t *state) {
    struct sockaddr_in address;
    int opt = 1;
    
    // Create TCP socket for incoming messages
    if ((state->tcp_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("TCP socket creation failed");
        return -1;
    }
    
    // Set socket options
    if (setsockopt(state->tcp_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("TCP setsockopt failed");
        close(state->tcp_socket);
        state->tcp_socket = -1;
        return -1;
    }
    
    // Configure address
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT_TCP);
    
    // Bind socket
    if (bind(state->tcp_socket, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("TCP bind failed");
        close(state->tcp_socket);
        state->tcp_socket = -1;
        return -1;
    }
    
    // Listen for connections
    if (listen(state->tcp_socket, 10) < 0) {
        perror("TCP listen failed");
        close(state->tcp_socket);
        state->tcp_socket = -1;
        return -1;
    }
    
    log_message("TCP listener initialized on port %d", PORT_TCP);
    return 0;
}

int send_message(const char *ip, const char *message, const char *msg_type) {
    int sock;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE];
    app_state_t *state = g_state;
    
    // Create socket
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("Socket creation failed");
        return -1;
    }
    
    // Set timeout
    set_socket_timeout(sock, 5);
    
    // Configure server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT_TCP);
    
    // Convert IP address
    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {
        perror("Invalid address");
        close(sock);
        return -1;
    }
    
    // Connect to server
    if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("Connection failed");
        close(sock);
        return -1;
    }
    
    // Format message
    format_message(buffer, BUFFER_SIZE, msg_type, state->username, message);
    
    // Send message
    if (send(sock, buffer, strlen(buffer), 0) < 0) {
        perror("Send failed");
        close(sock);
        return -1;
    }
    
    // Close socket
    close(sock);
    return 0;
}

/*
 * This function runs in a separate thread and is responsible for:
 * 1. Listening for incoming TCP connections from other peers
 * 2. Accepting connections and reading message data
 * 3. Parsing received messages and handling them based on message type
 * 4. Adding new peers to the application's peer list when messages are received
 * 5. Processing text messages and displaying them to the user
 * 6. Handling quit notifications from peers leaving the network
 * */
void *listener_thread(void *arg) {
    app_state_t *state = (app_state_t *)arg;
    struct sockaddr_in client_addr;
    int addrlen = sizeof(client_addr);
    int client_sock;
    char buffer[BUFFER_SIZE];
    char sender_ip[INET_ADDRSTRLEN];
    char sender_username[32];
    char msg_type[32];
    char content[BUFFER_SIZE];
    fd_set readfds;
    struct timeval timeout;
    
    log_message("Listener thread started");
    
    while (state->running) {
        // Set up select to make accept non-blocking
        FD_ZERO(&readfds);
        FD_SET(state->tcp_socket, &readfds);
        
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;
        
        int activity = select(state->tcp_socket + 1, &readfds, NULL, NULL, &timeout);
        
        if (activity < 0 && errno != EINTR) {
            perror("Select error");
            break;
        }
        
        // Check if we should continue running
        if (!state->running) {
            break;
        }
        
        // If timeout or error, continue
        if (activity <= 0) {
            continue;
        }
        
        // Accept incoming connection
        if ((client_sock = accept(state->tcp_socket, (struct sockaddr *)&client_addr, 
                                 (socklen_t*)&addrlen)) < 0) {
            if (errno != EINTR) {
                perror("Accept failed");
            }
            continue;
        }
        
        // Get client IP
        inet_ntop(AF_INET, &client_addr.sin_addr, sender_ip, INET_ADDRSTRLEN);
        
        // Read message
        memset(buffer, 0, BUFFER_SIZE);
        if (read(client_sock, buffer, BUFFER_SIZE) > 0) {
            // Parse message
            if (parse_message(buffer, sender_ip, sender_username, msg_type, content) == 0) {
                // Add peer to list
                if (add_peer(state, sender_ip, sender_username) > 0) {
                    log_message("New peer discovered: %s@%s", sender_username, sender_ip);
                }
                
                // Handle message based on type
                if (strcmp(msg_type, MSG_TEXT) == 0) {
                    log_message("Message from %s@%s: %s", sender_username, sender_ip, content);
                }
                else if (strcmp(msg_type, MSG_QUIT) == 0) {
                    log_message("Peer %s@%s has left the network", sender_username, sender_ip);
                    
                    // Remove peer
                    pthread_mutex_lock(&state->peers_mutex);
                    for (int i = 0; i < MAX_PEERS; i++) {
                        if (state->peers[i].active && strcmp(state->peers[i].ip, sender_ip) == 0) {
                            state->peers[i].active = 0;
                            break;
                        }
                    }
                    pthread_mutex_unlock(&state->peers_mutex);
                }
            }
        }
        
        // Close client socket
        close(client_sock);
    }
    
    log_message("Listener thread stopped");
    return NULL;
}




//====================================
// FILE: ./peer.c
//====================================

#include "peer.h"
#include "discovery.h"
#include "ui_terminal.h"
#include <stdarg.h>
#include <signal.h>
#include <unistd.h>

// Global state pointer for signal handler (see peer.h for definition of app_state_t struct
// which holds information about the peer that is running)
app_state_t *g_state = NULL;

// Used to catch SIGINT and SIGTERM signals and perform graceful shutdown via g_state used in a loop
void handle_signal(int sig) {
    if (g_state) {
        g_state->running = 0;
    }
    log_message("Received signal %d. Shutting down...", sig);
}

// Initialise application state
void init_app_state(app_state_t *state, const char *username) {
    // Init the struct to hold state with zeros
    memset(state, 0, sizeof(app_state_t));
    // Set initial states
    state->running = 1;
    state->tcp_socket = -1;
    state->udp_socket = -1;
    // Using strncpy to ensure the copy operation doesn't overflow the destination
    // strncopy will fill any remaining bytes in the destination with null char \0
    // and if the username is too big then 3rd param of sizeof state->username - 1 will limit
    // the user name to 1 char less that the destination with a null \0 at the end to denote end of string
    strncpy(state->username, username, sizeof(state->username) - 1);
    // Initialise a mutal exclusion object what will protect the peer list from concurrent access by multiple threads
    // so adding/removing peers is thread safe
    pthread_mutex_init(&state->peers_mutex, NULL);
    
    // Set global pointer for signal handler
    g_state = state;
    
    // Set up signal handlers
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = handle_signal; // method defined above
    sigaction(SIGINT, &sa, NULL); // Register a Ctrl+C
    sigaction(SIGTERM, &sa, NULL); // Register a kill command
}

// Called when something goes wrong or the application quits
// makes sure both sockets are closed properly if open
void cleanup_app_state(app_state_t *state) {
    if (state->tcp_socket >= 0) {
        close(state->tcp_socket);
        state->tcp_socket = -1;
    }
    
    if (state->udp_socket >= 0) {
        close(state->udp_socket);
        state->udp_socket = -1;
    }
    
    // Destroy the mutex that was used to protect the peer list from concurrent access.
    // This releases system resources associated with the mutex.
    // IMPORTANT: This should only be called after all threads that might use this mutex
    // have terminated, otherwise undefined behavior may occur if a thread attempts to
    // use the mutex after it's destroyed.
    pthread_mutex_destroy(&state->peers_mutex);
    log_message("Cleanup complete");
}

/*
 * This function creates a timestamped log entry and outputs it to the console.
 * It works similar to printf() but automatically adds a timestamp prefix in the
 * format [HH:MM:SS] and a newline character at the end of each message.
 * The function also ensures immediate output by flushing stdout.
*/
void log_message(const char *format, ...) {
    time_t now = time(NULL);
    char time_str[20];
    strftime(time_str, sizeof(time_str), "%H:%M:%S", localtime(&now));
    
    printf("[%s] ", time_str);
    
    va_list args;
    va_start(args, format);
    // print out the args using the format string, like printf
    vprintf(format, args);
    va_end(args);
    
    printf("\n");
    fflush(stdout);
}

/*
 * This function manages the application's peer list by either adding a new peer
 * or updating the "last seen" timestamp of an existing peer. It uses mutex locking
 * to ensure thread safety when multiple threads access the peer list concurrently.
 *
*/
int add_peer(app_state_t *state, const char *ip, const char *username) {
    // lock the peer list because it can be added to from both the listener and 
    // discovery threadsin network.c
    pthread_mutex_lock(&state->peers_mutex);
    
    // Check if peer already exists
    for (int i = 0; i < MAX_PEERS; i++) {
        if (state->peers[i].active && strcmp(state->peers[i].ip, ip) == 0) {
            // Update last seen time
            state->peers[i].last_seen = time(NULL);
            // Update username if provided
            if (username && username[0] != '\0') {
                strncpy(state->peers[i].username, username, sizeof(state->peers[i].username) - 1);
                state->peers[i].username[sizeof(state->peers[i].username) - 1] = '\0';
            }
            pthread_mutex_unlock(&state->peers_mutex);
            return 0; // Peer already exists
        }
    }
    
    // Find an empty slot
    for (int i = 0; i < MAX_PEERS; i++) {
        if (!state->peers[i].active) {
            strncpy(state->peers[i].ip, ip, INET_ADDRSTRLEN);
            state->peers[i].last_seen = time(NULL);
            state->peers[i].active = 1;

            // Set username if provided
            if (username && username[0] != '\0') {
                strncpy(state->peers[i].username, username, sizeof(state->peers[i].username) - 1);
                state->peers[i].username[sizeof(state->peers[i].username) - 1] = '\0';
            }

            pthread_mutex_unlock(&state->peers_mutex);
            return 1; // New peer added
        }
    }
    
    // We'r edone with the peer list so unlock
    pthread_mutex_unlock(&state->peers_mutex);
    return -1; // No space for new peer
}

int main(int argc, char *argv[]) {
    app_state_t state;
    pthread_t listener_tid, discovery_tid, input_tid;
    char username[32] = "anonymous";
    
    // Get username if provided
    if (argc > 1) {
        strncpy(username, argv[1], sizeof(username) - 1);
    }
    
    // Initialize application state
    init_app_state(&state, username);
    
    log_message("Starting P2P messaging application as '%s'", username);
    
    // Initialize network components
    if (init_listener(&state) < 0 || init_discovery(&state) < 0) {
        log_message("Failed to initialize network components");
        cleanup_app_state(&state);
        return EXIT_FAILURE;
    }
    
    // Start threads
    if (pthread_create(&listener_tid, NULL, listener_thread, &state) != 0 ||
        pthread_create(&discovery_tid, NULL, discovery_thread, &state) != 0 ||
        pthread_create(&input_tid, NULL, user_input_thread, &state) != 0) {
        
        log_message("Failed to create threads");
        state.running = 0;

        // Since some threads may have been started and I'm not tracking return values from pthread_create() 
        // give any open threads a moment to notice the running flag change before the mutext
        // is destroyed by cleanup_app_state()
        usleep(100000);  // 100ms

        cleanup_app_state(&state);
        return EXIT_FAILURE;
    }
    
    // Wait for user input thread to finish (when user quits)
    pthread_join(input_tid, NULL);
    
    // Signal other threads to stop
    state.running = 0;
    
    // Wait for threads to finish
    pthread_join(listener_tid, NULL);
    pthread_join(discovery_tid, NULL);
    
    // Close sockets to unblock threads, must be called after all threads re-join main
    cleanup_app_state(&state);

    log_message("Application terminated");
    return EXIT_SUCCESS;
}



//====================================
// FILE: ./protocol.c
//====================================

#include "peer.h"

// Message format: TYPE|SENDER|CONTENT
// Example: TEXT|username@192.168.1.5|Hello, world!

int format_message(char *buffer, int buffer_size, const char *msg_type, 
                  const char *sender, const char *content) {
    char sender_with_ip[BUFFER_SIZE];
    char local_ip[INET_ADDRSTRLEN];
    
    // Get local IP address
    if (get_local_ip(local_ip, INET_ADDRSTRLEN) < 0) {
        strcpy(local_ip, "unknown");
    }
    
    // Format sender with IP
    snprintf(sender_with_ip, BUFFER_SIZE, "%s@%s", sender, local_ip);
    
    // Format complete message
    int result = snprintf(buffer, buffer_size, "%s|%s|%s", 
                         msg_type, sender_with_ip, content);
    
    if (result >= buffer_size) {
        return -1; // Buffer too small
    }
    
    return 0;
}

/*
 * This function breaks down a message string into its component parts according to the
 * messaging protocol. It extracts the message type, sender information
 * (username and IP address), and the message content.
 * It performs basic format validation but does not verify the
 * authenticity or integrity of the message. It assumes all output buffers
 * are large enough to hold their respective components.
*/
int parse_message(const char *buffer, char *sender_ip, char *sender_username, char *msg_type, char *content) {
    char *token;
    char *rest;
    char temp[BUFFER_SIZE];
    char sender_with_ip[BUFFER_SIZE];
    
    // Make a copy of the buffer since strtok_r modifies it
    strncpy(temp, buffer, BUFFER_SIZE - 1);
    temp[BUFFER_SIZE - 1] = '\0';
    
    // Parse message type
    token = strtok_r(temp, "|", &rest);
    if (token == NULL) {
        return -1;
    }
    strncpy(msg_type, token, 31);
    msg_type[31] = '\0';
    
    // Parse sender with IP
    token = strtok_r(NULL, "|", &rest);
    if (token == NULL) {
        return -1;
    }
    strncpy(sender_with_ip, token, BUFFER_SIZE - 1);
    
    // Extract IP from sender
    char *at_sign = strchr(sender_with_ip, '@');
    if (at_sign != NULL) {

        // Extract username
        int username_len = at_sign - sender_with_ip;
        strncpy(sender_username, sender_with_ip, username_len);
        sender_username[username_len] = '\0';

        // Extract IP
        strncpy(sender_ip, at_sign + 1, INET_ADDRSTRLEN - 1);
        sender_ip[INET_ADDRSTRLEN - 1] = '\0';
    }
    
    // Parse content
    token = strtok_r(NULL, "", &rest);
    if (token == NULL) {
        content[0] = '\0';
    } else {
        strncpy(content, token, BUFFER_SIZE - 1);
        content[BUFFER_SIZE - 1] = '\0';
    }
    
    return 0;
}


