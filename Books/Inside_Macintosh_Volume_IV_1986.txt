LA
We ®

Apple’ Inside Macintosh
Supplements Inside
Macintosh, volumes
I through III, with
information about
the Macintosh® Plus
and Macintosh 512K
Enhanced computers

Volume

IV

Hanscey

Inside Macintosh,

é.

Volume IV

vv

Addison-Wesley Publishing Company, Inc.
Reading, Massachusetts
Menlo Park, California New York Don Mills, Ontario
Wokingham, England
Amsterdam
Bonn
Sydney
Singapore
Tokyo
Madrid

San Juan

¢ APPLE COMPUTER, INC.
Copyright © 1986 by Apple Computer, Inc.

All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or
transmitted, in any form or by any means, electronic, mechanical, photocopying, recording, or
otherwise, without prior written permission of Apple Computer, Inc. Printed in the United States
of America.
Apple, the Apple logo, AppleTalk, HyperCard, LaserWriter, Lisa, Macintosh, MacWorks, and
SANE are registered trademarks of Apple Computer, Inc.
APDA and Finder are trademarks of Apple Computer, Inc.

MacDraw, MacPaint, and MacWrite are registered trademarks of Claris Corporation.
Simultaneously published in the United States and Canada.
This book was produced using the Apple Macintosh computer and the LaserWriter printer.

ISBN 0-201-05409-4
FGHIJ-MU-898

Sixth Printing, August

1988

Inside Macintosh
Volume IV

WARRANTY INFORMATION
ALL IMPLIED WARRANTIES ON THIS MANUAL, INCLUDING IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE, ARE LIMITED IN DURATION TO NINETY (90) DAYS FROM THE
DATE OF THE ORIGINAL RETAIL PURCHASE OF THIS PRODUCT.
Even though Apple has reviewed this manual, APPLE MAKES NO WARRANTY OR
REPRESENTATION, EITHER EXPRESS OR IMPLIED, WITH RESPECT TO
THIS MANUAL, ITS QUALITY, ACCURACY, MERCHANTABILITY, OR
FITNESS FOR A PARTICULAR PURPOSE. AS A RESULT, THIS MANUAL IS
SOLD “AS IS,” AND YOU, THE PURCHASER, ARE ASSUMING THE ENTIRE
RISK AS TO ITS QUALITY AND ACCURACY.

IN NO EVENT WILL APPLE BE LIABLE FOR DIRECT, INDIRECT, SPECIAL,
INCIDENTAL, OR CONSEQUENTIAL DAMAGES RESULTING FROM ANY

DEFECT OR INACCURACY IN THIS MANUAL, even if advised of the possibility of
such damages.
THE WARRANTY AND REMEDIES SET FORTH ABOVE ARE EXCLUSIVE AND
IN LIEU OF ALL OTHERS, ORAL OR WRITTEN, EXPRESS OR IMPLIED. No
Apple dealer, agent, or employee is authorized to make any modification, extension, or addition to
this warranty.

Some states do no allow the exclusion or limitation of implied warranties or liability for incidental or

consequential damages, so the above limitation or exclusion may not apply to you. This warranty
gives you specific legal rights, and you may also have other rights which vary from state to state.

Contents
Preface
About Inside Macintosh Volume IV

1 The Macintosh User Interface Guidelines
About This Chapter
Arrow Keys
Reserved Command Key Combinations
Window Zooming
Standard Close Dialog
2 Using Assembly Language
The Trap Dispatch Table
Format of the Trap Words
3 The Resource Manager
Resource Manager Routines
Resource Types
Checking For Errors
ROM Resources
Summary of the Resource Manager
4 QuickDraw
QuickDraw Routines
Summary of QuickDraw
5 The Font Manager
About the Font Manager
Fonts and Their Families
Font Manager Routines
Communication Between QuickDraw and the Font Manager
Font Manager Data Structures
Font and Font Family Resources
Summary of the Font Manager
6 The Window Manager
Window Manager Routines
Summary of the Window Manager

7

The Control Manager

Control Manager Routines
The Control Definition Function
Summary of the Control Manager

8 The Menu Manager
Menu Manager Routines
The Menu Definition Procedure
Summary of the Menu Manager

Contents IV-v

Inside Macintosh

57
57
58

9 TextEdit
TextEdit Routines
Default Click Loop Routine

59
59

10 The Dialog Manager
Dialog Manager Routines

61

11

The Scrap Manager

12

Toolbox Utilities

58

60

63

Summary of TextEdit

Summary of the Dialog Manager

63
66

Toolbox Utility Routines
Summary of the Toolbox Utilities

67
68

13 The Package Manager
Summary of the Package Manager

69

14

The

15

The Standard File Package

71

Binary-Decimal

Conversion

73

Using the Standard File Package

76

Summary of the Standard File Package

74

Package

Creating Your Own Dialog Box

77
77
80
81

16 The Memory Manager
Memory Manager Routines
Error Reporting
Summary of the Memory Manager

83

17

The Segment Loader

18

The Operating System Event Manager

85

85

Summary of the Operating System Event Manager

87
89
89

19 The File Manager
About This Chapter
About the File Manager

106

High-Level File Manager Routines

96
104

115.

159

174
182
183.

213

Using the File Manager
Information Used by the Finder

Low-Level File Manager Routines

Data Organization on Volumes

Data Structures in Memory
Using an External File System
Summary of the File Manager

20

The Device Manager

215
216
222

About the Device Manager
The Chooser
Summary of the Device Manager

IV-vi

Contents

Contents

223
223
224

21

The Disk Driver

22

The Serial Driver

Advanced Control Calls
Summary of the Disk Driver

225
226
227

Advanced Control Calls

229

23

The AppleTalk Manager

231

24

The System Error Handler

233
233
236

25 The Operating System Utilities
Operating System Utility Routines

239
241

26 The Disk Initialization Package
Summary of the Disk Initialization Package

243
243

The Desktop File

245

Summary of the Serial Driver

Summary of the Operating System Utilities

27

The

Finder

Interface

28 The Macintosh Plus
Overview of the Hardware
The Video Interface
The Sound Generator
The SCC

Hardware

The Keyboard

The Floppy Disk Interface
The Real-Time Clock
The SCSI Interface

Summary

29

The System

Resource

Initialization Resources

File

30 The List Manager Package
About This Chapter
About the List Manager Package
List Records
Cell Selection Algorithm
Using the List Manager Package
List Manager Package Routines

Defining Your Own Lists
Summary of the List Manager Package

Contents IV-vii

Inside Macintosh

283
285
285
286
289
292
294

31 The SCSI Manager
About This Chapter
About the SCSI Manager

Using the SCSI Manager
SCSI Manager Routines
|
Writing a Driver for an SCSI Block Device
Summary of the SCSI Manager
32

The Time Manager

About This Chapter

About the Time Manager
Using the Time Manager

Time Manager Routines

Summary of the Time Manager

Appendix A:

Routines That May Move or Purge Memory

Appendix B:

System Traps

Appendix C:

Global Variables

Glossary
Index

IV-viii Contents

PREFACE
xi

X1

Xl
XXii
XXil

About Inside Macintosh Volume IV

The Language -

Version Numbers
Compatibility
Conventions

Preface IV-ix

Inside Macintosh

Preface

ABOUT INSIDE MACINTOSH VOLUME IV
The first three volumes of Inside Macintosh provide information you’ll need to write
software for any of the Apple® Macintosh® family. This volume, Volume IV, is a

companion to the first three volumes that gives specific information on writing software to

take advantage of the features of the Macintosh Plus and the Macintosh 512 enhanced. A
familiarity with the material presented in the first three volumes is assumed, since most of

the information presented in Volume IV consists of changes and additions to that original
material.

Practically every chapter in the first three volumes has a corresponding chapter in Volume

IV that describes new routines, modified data structures, additional error codes, and so on.

Most of these chapters are “delta” documents that present only the new information. In the
case of the File Manager chapter, the changes are so extensive that the chapter has been
completely rewritten. Finally, four additional chapters—“The System Resource File”,
“The List Manager”, “The SCSI Manager’, and “The Time Manager’—introduce entirely

new material.

The Language
The routines you’ll need to call are written in assembly language, but (with a few
exceptions) they’re also accessible from high-level languages, such as Pascal on the Lisa
- Workshop development system. Inside Macintosh documents the Lisa Pascal interfaces to
the routines and the symbolic names defined for assembly-language programmers using the
Lisa Workshop; if you’re using a different development system, its documentation should
tell you how to apply the information presented here to that system.
Inside Macintosh is intended to serve the needs of both high-level language and assemblylanguage programmers. Every routine is shown in its Pascal form (if it has one), but
assembly-language programmers are told how they can access the routines. Information of

interest only to assembly-language programmers is set apart and labeled so that other

programmers can conveniently skip it.

Familiarity with Lisa Pascal (or a similar high-level language) is recommended for all

readers, since it’s used for most examples. Lisa Pascal is described in the documentation
for the Lisa Pascal Workshop.
Version Numbers
This edition of Inside Macintosh Volume IV describes the following
software:

versions of the

m version 117 ($75) of the ROM in the Macintosh Plus and Macintosh 512K enhanced
w version 2.0 of the Lisa Pascal interfaces and the assembly-language definitions

About Inside Macintosh Volume IV xi

Inside Macintosh

Some of the RAM-based software is read from the file named System (usually kept in the
System Folder). This manual describes the software in the System file version 3.2 whose

creation date is June 4, 1986.

In certain cases, a feature can be found in earlier versions of

the System file; these cases are noted as they come up.

Compatibility
Version 117 ($75) of the ROM, also known as the 128K ROM, is provided on the
Macintosh 512K enhanced and Macintosh Plus.

Note: A partially upgraded Macintosh 512K is identical to the Macintosh 512K
enhanced, while a completely upgraded Macintosh 512K includes all the features of
the Macintosh Plus.
Version 105 ($69) of the ROM (the version described in the first three volumes of Inside
Macintosh), also known as the 64K ROM, 1s provided on the Macintosh 128K and 512K.
Most applications written for the 64K ROM run without modification on machines
equipped with the 128K ROM. Applications that use the routines and data structures found
in the 128K ROM, however, may not function on machines equipped with the 64K ROM.
Programmers may wish to determine which version of the ROM is installed in order to take
advantage of the features of the 128K ROM whenever possible. You can do this by
checking the ROM version number returned by the Operating System Utility procedure
Environs; if the version number is greater than or equal to 117 ($75), it’s safe to use the
routines and data structures described in this volume.
Assembly-language note: A faster way of determining whether the 128K ROM
is present is to examine the global variable Rom85 (a word); it’s positive (that is, the
high-order bit is 0) if the 128K ROM is installed.

Conventions
The following notations are used in Volume IV to draw your attention to particular items of
information:
64K ROM note:

A note, found only in chapter 19 of this volume, that points out

some difference between the 64K ROM and 128K ROM.

Note:

A note that may be interesting or useful.

Warning:

A point you need to be cautious about.

Assembly-language note: A note of interest to assembly-language programmers
only.

xii About

Inside Macintosh Volume IV

Preface
[Not in ROM]
Routines marked with this notation are not part of the Macintosh ROM. Depending
on how the interfaces have been set up on the development system you’re using,

these routines may or may not be available. They’re available to users of Lisa Pascal;
other users should check the documentation for their development system for more
information. (For related information of interest to assembly-language programmers,
see chapter 4 of Volume I and chapter 2 of this volume.)

About Inside Macintosh Volume IV xiii

="
nN

(ao)

Law |

1_

THE MACINTOSH USER INTERFACE GUIDELINES

ee |

~

~-

om
=t

pt pe
WW
PW
COOwrAITAAMAA

=

11

pa
a)
fa)

About This Chapter
Arrow Keys

Appropriate Uses for the Arrow Keys

Moving the Insertion Point With Arrow Keys

Moving the Insertion Point in Empty Documents
Modifier Keys With Arrow Keys

Making a Selection With Arrow Keys

Extending or Shrinking a Selection
Collapsing a Selection

—

Reserved Command Key Combinations

Window Zooming

Effects of Dragging and Sizing

Standard Close Dialog
Close Box Specifications

Contents IV-1

The Macintosh User Interface Guidelines

—
N

fae]
=
—
>}

ABOUT THIS CHAPTER

~~

fae)

Lae |
Lamar)

This chapter describes the following new features of the Macintosh user interface:
a the Macintosh Plus arrow keys
= an updated list of reserved Command key combinations
m the new window zooming feature

m anew standard Close dialog box

ARROW KEYS
The Macintosh Plus keyboard includes four arrow keys: Up Arrow, Down Arrow, Left
Arrow, and Right Arrow.

Figure 1.

Macintosh Plus Arrow Keys

Appropriate Uses for the Arrow Keys
The arrow keys do not replace the mouse.

They can be used in addition to the mouse as a

shortcut for moving the insertion point and (under some circumstances) for making
selections. The following rules are the minimum guidelines for the use of arrow keys,

leaving application programmers relatively free to expand on them where things are left
undefined. Extensions necessary for a particular application should be done in the spirit of

the Macintosh user interface.

It’s up to you to decide whether it’s worth the effort to create arrow key shortcuts for
mouse functions. Many users find that remembering a key combination on the order of
Command-Shift—Left Arrow is more trouble than it’s worth and would rather use a mouse
anyway. In other situations, it’s more convenient to use the keyboard. Some people have
difficulty using a mouse and appreciate being able to use the keyboard instead.

Arrow Keys IV-3

po)
a]
a]

Inside Macintosh

You should make use of the arrow keys only where it’s appropriate to the application.
Applications that deal with text or arrays (word processors, spreadsheets, and data bases,
for example) have an insertion point. This insertion point can always be moved by the

mouse and, with the new keyboard, with the arrow keys as well.

As a general rule, arrow keys are used to move the insertion point and to expand or shrink
selections. Arrow keys are never used to duplicate the function of the scroll bars or to
move the pointer. In a graphics application, the arrow keys should not be used to move a
selected object.

Moving the Insertion Point With Arrow Keys
The Left Arrow and Right Arrow keys move the insertion point one character left and right,
respectively .
Up Arrow and Down Arrow move the insertion point up and down one line, respectively.
The horizontal screen position should be maintained in terms of screen pixels but not

necessarily in terms of characters, because the insertion point moves to the nearest character

boundary on the new line. (Character boundaries seldom line up vertically when
proportional fonts are used.) During successive movements up or down, you should keep

track of the original horizontal screen position; otherwise, accumulated round-off errors

might cause the insertion point to move a significant distance from the original horizontal
position as it moves from line to line.

Moving the Insertion Point in Empty Documents
Various text-editing programs treat empty documents in different ways. Some assume that
an empty document contains no characters, in which case clicking at the bottom of a blank
screen Causes the insertion point to appear at the top. In this situation, Down Arrow cannot
move the insertion point into the blank space (because there are no characters there).
Other applications treat an empty document as a page of space characters, in which case
clicking at the bottom of a blank screen puts the insertion point where the user clicked and
lets the user type characters there, overwriting the spaces. Down Arrow moves the
insertion point straight down through the spaces.
Whichever paradigm you choose for your application, be consistent.

Modifier Keys With Arrow Keys
Holding down the Command key while pressing an arrow key should move the insertion
point to the appropriate edge of the window. If the insertion point is already at the edge of

the window, the document should be scrolled one windowful in the appropriate direction
and the insertion point should move to the same edge of the new windowful.

Command-—Up Arrow moves to the top of the window, Command—Down Arrow to the

bottom, Command—Left Arrow to the left edge, and Command-Right Arrow to the right
edge.

IV-4 Arrow Keys

The Macintosh User Interface Guidelines

The Option key is reserved as a “semantic modifier” key. The application determines what

the semantic units are. For example, in a word processor, where the basic semantic unit is
the character and the next larger unit is the word, Option—Left Arrow and Option—Right

Arrow might move the insertion point to the beginning and end, respectively, of a word.

(Movement of the insertion point by word boundaries should use the same definition of
“word” that the application uses for double clicking.) The next larger semantic unit could
be defined as the sentence, in which case Option—Left Arrow and Option—Right Arrow
would move the insertion point to the beginning or end of a sentence. In a programming
language editor, where the basic semantic unit is the token and the next larger one might be
the line, Option—Left Arrow and Option—Right Arrow might move the insertion point left
and right to the beginning and end of the line, respectively.
In an application (such as a spreadsheet) that represents itself as an array, the basic
semantic unit would be the cell. Option—Left Arrow would designate the cell to the left of
the currently active cell as the new active cell, and so on. Using modifier keys with arrow
keys doesn’t do anything to the data; Option—Left Arrow just moves the selection to the

next cell to the left.

Though the use of multiple modifier key combinations (such as Command—Option—Left
Arrow) is discouraged, it’s fine to use the Shift key with any one of the other modifier keys
for making a selection (see “Making a Selection With Arrow Keys” below). Keep in mind
that if multiple keys must be pressed simultaneously, they should be fairly close
together—otherwise many people won’t be able to use that combination.

Makinga Selection With Arrow Keys
To use arrow keys to make a selection, the user holds down Shift while pressing an arrow
key. Application programs that depend (as TextEdit does) on the numeric keypad should
not use these Shift—arrow key combinations because the ASCII codes for the four
Shift—arrow key combinations are the same as those for the keypad’s +, *, /, and = keys.
If the use of Shift—arrow for making selections is more important to your application than

the numeric keypad, the following paragraphs describe how it should work.

After a Shift—arrow key combination has been pressed, the insertion point moves and the

range over which it moves becomes selected. If both the Shift key and another modifier
key are held down, the insertion point moves (as defined for the particular modifier key)

and the range over which the insertion point moves becomes selected. For example,
Shift—Left Arrow selects the character to the left of the insertion point, Command-Shift—

Left Arrow selects from the insertion point to the left edge of the window, and Option—

Shift—Left Arrow selects the whole word that contains the character to the left of the
insertion point (just like double clicking on a word).

A selection made using the mouse is no different from one made using arrow keys. A
selection started with the mouse can be extended using Shift and Left Arrow or Right
Arrow.

The two ends of a selected range have different characteristics and different names. The

place where the insertion point was when selection was started is called the anchor point.

The place to which the insertion point moves to complete the selection is called the active

end. Once selection begins, the anchor point cannot be moved except by beginning a new
selection. To extend or shrink a selection, the user moves the active end as specified here.
As the active end moves, it can cross over the anchor point.
Arrow Keys IV-5

—"
Si
fae)

baw

|

San!

—|

-

ae)
=

=~

©
io)
fae]

Inside Macintosh

In a text application, pressing Shift and either Left Arrow or Right Arrow selects a single
character. Assuming that Left Arrow key was used, the anchor point of the selection is on
the right side of the selection, the active end on the left. Each subsequent Shift-Left Arrow
adds another character to the left side of the selection. A Shift-Right Arrow at this point
shrinks the selection. Figure 2 summarizes these actions.

1. Insertion point is within a word:

word

2. Shift- is pressed:

werd

3. another Shift- @:

Bird

4.

werd

Shift-™:

5. three more times Shift-™:
Figure 2.

wolgs]

Selecting With Shift-Arrow Keys

In a text application, pressing Option—Shift and either Left Arrow or Right Arrow selects

the entire word containing the character to the left of the insertion point. Assuming
Left Arrow was used, the anchor point is at the right end of the word, the active end at the
left. Each subsequent Option—Shift—Left Arrow adds another word to the left end of the
selection, as shown in Figure 3.

1. Insertion point is within a word:

another word

2. Option-Shift- @ is pressed:

another Bieaes

3. another Option-Shift-@:
Figure 3.

Selecting With Option—Shift-Arrow Keys

Pressing Command-—Shift—Left Arrow selects the area from the insertion point to the left
edge of the window. The anchor point is at the right end of the selection, the active end is
at the left. Each subsequent Command-Shift—Left Arrow moves the document one
windowful left and extends the selection to the left edge of the new window.

Extending or Shrinking a Selection
To use arrow keys to extend or shrink a selection, the user holds down the Shift key (plus

any defined modifiers) while pressing an arrow key. The arrow key moves the insertion
point at the active end of the selection.

Collapsing a Selection
When a block of text is selected, pressing either Left Arrow or Right Arrow deselects the
range. If Left Arrow is pressed, the insertion point is left at the beginning of the previous
selection; 1f Right Arrow, at the end of the previous selection.

IV-6 Arrow Keys

The Macintosh User Interface Guidelines

—y
i? 2)

om
=
|
=|

RESERVED COMMAND KEY COMBINATIONS

-=

fae)
~

=,

There are several menu items, particularly in the File and Edit menus, that commonly have

keyboard equivalents. For consistency, several of those keyboard equivalents should be

used only for the commands listed below and should never be used for any other purpose.

Desk accessories, which are accessible from all applications, assume that these Commandkey combinations have the meanings listed here.
File

Menu

Command-N (New)
Command-O (Open)
Command-S (Save)
Command-Q (Quit)
Edit Menu

Command-Z
Command-X
Command-C
Command-V

(Undo)
(Cut)
(Copy)
(Paste)

The keyboard equivalents in the Style menu (listed below) are less strictly reserved.

Applications that have Style menus shouldn’t use these keyboard equivalents for any other

purpose, but applications that have no Style menus can use them for other purposes if
needed. Remember that you risk confusing users if a given key combination means
different things in different applications.
Style Menu
Command-P (Plain)
Command-B (Bold)
Command-I (Italic)
Command-U (Underline)

WINDOW ZOOMING
The more open documents on a desktop, the more difficult it is for the user to locate, select,
and resize the one to be worked on. The 128K ROM includes a feature, known as window
zooming, that allows users—with a single mouse click—to toggle the active window
between its standard size and location and a predefined size and location.
The initial size and placement of a window is known as its standard state. The application
program can supply values for the standard state; otherwise the full screen (minus a few
border pixels) is assumed (see Figure 4). The standard state should be the most useful size
and location for normal operations within the program—usually it’s the full screen.

Window Zooming

IV-7

f&
QO
oe

Inside Macintosh

File

Edit

Search

Format

SSS]

Font

Style

Document
zoom

Window

box

Size box

Edit
CRO

eee

ORO

R ORO

RCE

OR

ORE

ET

OSE

ORE

RO

OREO

Search
OOOO

REE

E REO

OR

EEO

ESOP

Format
REM

RENTTE

ROO

EEO

ESSE

EEE

EERO

Font
HORDE

RAED

EHO

ROC

Style
ET

OTERO

RR

ETOH

EOE

RC

REED

HAH

E EERE

DROME

ODOM

EEE

EUS

CERES

FERED

ESL

eseeETTES

Document

Zoom Window

being clicked

box

iH

cue

Figure 4. Window in Standard State
The user cannot change the standard state, but the application can change it within context.
For example, a word processor might define a size that’s wide enough to display a
document whose width is as specified in Page Setup. If the user invokes Page Setup to
specify a wider or narrower document, the application might then change the standard state
to reflect that change.
Your application can also supply initial values for the second window state, known as the
user state. If you don’t supply initial values, the user state is identical to the standard state
until the user moves or resizes the window. When the standard state and user state are
different (Figure 5 shows a hypothetical user state), clicking in the zoom-window box acts
as a toggle between the two states.
IV-8

Window Zooming

The Macintosh User Interface Guidelines

p—_
iF 2)

a

6File

Edit

Search

Format
es

Font

ao)
a
—
=|

Style

~

fen)

Lene |
Le)

poe)
on)
Cas)

SS

Figure 5.

Doc

Window in User State

Application developers are encouraged to take advantage of the zoom-window feature;
details on using this feature are provided in chapter 6 of this volume. You should not
change the shape of the zoom-window box or change the interpretation of clicking on the

the zoom-window box (shown in Figure 6). You should add no other elements to the title
bar. Except in the zoom-window box and in the close box, clicking within the title bar
should have no effect.
tt ett
pT dt del
|_|
|
|
|
|
|
wi
|
|
|
a
|
|
|
a
|| | { ft ft fl
a
|
|
|
|

fr} ttt pt ttt
|_|
|
|_|
a
|
| a
|
|_|
ZH
|
|
Tt ttf
Lf tot
a
|
|
HH
|
EH
|_|
im
|

rt

fii}

|

i

|

tt

tp

Ld

Before
being
clicked
Figure 6.

|

df

|

tT] }

|

tt

fy ft ft

||

Being clicked

Zoom-Window Box Details

Window Zooming

IV-9

Inside Macintosh

Effects of Dragging
and Sizing
Explicit dragging or resizing of the window is handled in the normal way (see “Changing
the Size of a Window” in chapter 2 of Volume J), regardless of the presence or absence of
the zoom-window feature. The effect of dragging or resizing depends on the state of the
window and the degree of movement. A change, either in position or size, of seven pixels
or less is insignificant. A change of more than seven pixels is a “significant change”.

If dragging or resizing occur when the window is in the standard state, a small change in
the size or location of the window does not change the state, nor does it change the
application-defined values for the size and location of the standard state. It does, of course,
change the size or location of the window. A significant change in the size or location of
the window switches the window to the user state and sets the values for the size and
location of that state to those of the window.
If dragging or resizing occur when the window is in the user state, a change in size or
location that leaves the window within seven pixels of the size and location specified as the
standard state changes the state to the standard state, leaving the size and Jocation of the

user state unchanged. Any other change in size or location in the user state leaves the
window in the user state and sets the values for the size and location of that state to those of
the window.

STANDARD CLOSE DIALOG
When a user chooses Close or Quit from the File menu, and the active document has been

changed, the Close dialog box appears, asking “Save changes before closing?’”’ A great
deal of work can be lost if a user mistakenly clicks the “No” button instead of “Cancel”.
This is especially important to Switcher users, who often move from one application to

another and become less aware of subtle differences between applications. To avoid

confusion, all applications should use the same standard Close dialog. As shown in Figure

7, dialogs can have multiple lines of text.

Save changes to "Memo
Elizabeth"?

to

[ Cancel }
Figure 7. A Standard Close Dialog

IV-10 Standard Close Dialog

The Macintosh User Interface Guidelines

pad,

=

nN

cae]

Close Box Specifications

-

—_
=
“+

“Yes” and “No”, the two direct responses to the question “Save changes before closing?”

are placed together on the left side of the box. “Yes”, the default button, is boldly outlined.
“Cancel”, which cancels the close command, is to the right, separate from “Yes” and
“No”

After the user selects Close from the File menu, the text of the questionin the Close box is

generally “Save changes before closing?” However, if the user sees this dialog after
choosing “Quit’’, the text would instead be “Save changes before quitting?” If the
application supports multiple windows, the text could be “Save changes to [document
name] before closing window?’ The box should always look the same and appear in the
same place on the screen.

The box itself is 120 pixels high by 238 pixels wide. Its standard location is
(100,120)(220,358) but other locations may be appropriate.

Here are the other coordinates for the standard close box (assuming standard location):
the text
the word “yes”
the word “no”
the word “cancel”

(12,20)(45,223)
(58,25)(76,99)
(86,25)(104,99)
(86,141)(104,215)

If you must devise a close box different from the one described here, maintain the general
arrangement of the buttons and remember that the user’s safest choice should be the default
button and that the most dangerous choice should be the most difficult to make happen.

Standard Close Dialog IV-11

fae)

Lae |
=

oe)

a)
ae)

2

USING ASSEMBLY LANGUAGE

In the 128K ROM, Toolbox and Operating System traps have separate trap dispatch tables.
It’s possible for a Toolbox trap and an Operating System trap to have the same trap
number.

to

>

i? 2)

Nn
fas)

=:

=

te

-

THE TRAP DISPATCH TABLE

po)

In the 64K ROM, references to both Toolbox and Operating System routines are made
through a single trap dispatch table. For compactness, entries in that table are encoded into
one word each. The high-order bit of each entry tells whether the routine resides in ROM

(0) or RAM (1). The remaining 15 bits give the offset of the routine relative to a base

address. For routines in ROM, this base address is the beginning of the ROM; for routines
in RAM, it’s the beginning of the system heap. The two base addresses are kept in a pair

of global variables named ROMBase and RAMBase. Using 15-bit unsigned word offsets,
the range of locations that the trap dispatch table can address is limited to 64K bytes. Also,
the interleaving of Operating System and Toolbox trap numbers limits the total number of
traps to 512 and means that no two traps can be represented by the same number.
In the 128K ROM, the Toolbox and Operating System traps have separate dispatch tables.
Instead of a packed format, entries in these dispatch tables are stored as full long-word

addresses so the dispatcher makes no distinction between ROM and RAM addresses. The
Operating System dispatch table consists of 256 long words, from address $400 through

$7FF; this replaces the old dispatch table of 512 words. The Toolbox table consists of 512
long words, from address $CO0 through $13FF.
Warning:

The format of the trap dispatch tables may be different in future versions

of Macintosh system software. If it’s absolutely necessary that you manipulate the

trap dispatch tables, use the Operating System Utility routines

NGetTrapAddress and

NSetTrapAddress (or with the 64K ROM, GetTrapAddress and SetTrapAddress);

they’re described in chapter 25 of this volume.

FORMAT OF TRAP WORDS
As described in chapter 4 of Volume I, a trap word begins with the hexadecimal digit $A
(binary 1010); the rest of the word identifies the routine you’re calling, along with
additional information pertaining to the call.

Figure 1 shows the format of Toolbox and Operating System trap words. Bit 11 of the trap
word determines how the remainder of the word will be interpreted; usually it’s 0 for
Operating System calls and 1 for Toolbox calls, though there are certain exceptions.

Format of Trap Words IV-13

=|
v2
=
pee)
3
fee]

Inside Macintosh

Toolbox Trap Word (Bit 11=1)
15

1413

12

17;

O0;71]0]

1110

9

8

0

1

trap number
Z

reserved for future use

auto-pop bit
Operating System Trap Word (Bit 11 =0)
15

1413

121110

1;0;/1]0)]

0]

9

8

7

flags

0
trap number

|

set if trap dispatcher
doesn't preserve AO

(routine passes it back)

Figure 1. Toolbox and Operating System Trap Words
In the 64K ROM, an Operating System trap and a Toolbox trap cannot have the same trap
number; the GetTrapAddress and SetTrapAddress routines do not distinguish between
Toolbox and Operating System traps.
Since each group has its own dispatch table in the 128K ROM, there can be a Toolbox trap
and an Operating System trap with the same trap number. Two new routines—

NGetTrapAddress and NSetTrapAddress—have been added; they use bits 9 and 10 of their

trap word for specifying the group to which a routine belongs.

IV-14 Format of Trap Words

3

THE RESOURCE MANAGER

The speed and efficiency of the Resource Manager have been significantly enhanced in the
128K ROM. Nine routines have been added; seven are functional counterparts of 64K
ROM routines but search only the current resource file, and two routines are new.

Additional standard resource types have been defined, two new result codes have been

added, and the reporting of error conditions has been improved.

RESOURCE MANAGER ROUTINES
Crd

FUNCTION CountlTypes : INTEGER;
Count1Types is the same as CountTypes except that it returns the number of resource types
in the current resource file only.
PROCEDURE

GetlindType

(VAR

theType:

ResType;

index:

INTEGER);

Assembly-language note: The macro you invoke to call GetlIndType from
assembly language is named _GetIlIxType.

GetlIndType is the same as GetIndType except that it searches the current resource file
only. Given an index ranging from 1 to Count1Types (above), GetlIndType returns a
resource type in theType. Called repeatedly over the entire range for the index, it returns all
the resource types in the current resource file. If the given index isn’t in the range from 1
to Count1 Types, GetlIndType returns four NUL characters (ASCII code 0).
FUNCTION

CountlResources

(theType:

ResType)

:

INTEGER;

Count1Resources is the same as CountResources except that it returns the total number of
resources of the given type in the current resource file only.
FUNCTION

GetilIndResource

Handle;

(theType:

ResType;

index:

INTEGER)

Assembly-language note: The macro you invoke to call GetlIndResource from
assembly language is named _Get1IxResource.
Get1IndResource is the same as GetIndResource except that it searches the current resource
file only. Given an index ranging from 1 to CountlResources(theType), Get1 IndResource
returns a handle to a resource of the given type (see Count1 Resources, above). Called

Resource Manager Routines IV-15

Ww
o
w
©
=
m=
°
@
re)
~
re)
v2
oO
=

Inside Macintosh

repeatedly over the entire range for the index, it returns handles to all resources of the given
type in the current resource file.
FUNCTION

GetlResource

(theType:

ResType;

theID:

INTEGER)

: Handle;

Get1Resource is the same as GetResource except that it searches the current resource file
only.
FUNCTION

GetlNamedResource
Handle;

(theType:

ResType;

name:

Str255)

Get1NamedResource is the same as GetNamedResource except that it searches the current
resource file only.
FUNCTION

UniquelID

(theType:

ResType)

:

INTEGER;

UniquelID is the same as UniqueID except that the ID number it returns is unique only
with respect to resources in the current resource file.
FUNCTION

MaxSizeRsrce

(theResource:

Handle)

:

LONGINT;

MaxSizeRsrc is similar to SizeResource except that it does not cause the disk to be read;
instead it determines the size (in bytes) of the resource from the offsets found in the
resource map.
Since MaxSizeRsrc does not read from the disk, it returns only the maximum size of the

resource. In other words, you can count on the resource not being larger than the number
of bytes reported by MaxSizeRsrc; it’s possible, however, that the resource is actually

smaller than the resource map indicates (because the file has not yet been compacted).
called after UpdateResFile, MaxSizeRsrc will return the correct size of the resource.

If

Advanced Routines
FUNCTION

RsrcMapEntry

RsrcMapEntry

(theResource:

Handle)

:

LONGINT;

provides a way to access the resource references in the resource map.

Given a handle to a resource, RsrcMapEntry returns the offset of the resource’s reference
from the beginning of the resource map.

(For more information on resource references and

the structure of a resource map, see the section “Format of a Resource File” in the Resource

Manager chapter.) If it doesn’t find the resource, RsrcMapEntry returns NIL and the
ResError function will return the result code resNotFound. If you pass it a NIL handle,
RsrcMapEntry will return garbage but ResError will return the result code noErr.
Warning: Since routines are provided for opening, accessing, and changing
resources, there’s really no reason to access resources directly. To avoid damaging
the resource file, you should be extremely careful if you use RsrcMapEntry.

IV-16 Resource Manager Routines

The Resource Manager
FUNCTION

OpenRFPerm

(fileName:

permission:

Byte)

:

Str255;

INTEGER;

vRefNum:

INTEGER;

OpenRFPerm is similar to OpenResFile except that it allows you to specify the read/write
permission of the resource file the first time it is opened; OpenRFPerm also lets you specify

in vVRefNum the directory or volume on which the file is located (see chapter 19 of this
volume for more details on directories). Permission can have any of the values that you
would pass to the File Manager; these values are given in “Low-Level File Manager
Routines” in chapter 19 of this volume.

OpenRFPerm, like OpenResFile, will not open the specified file twice; it simply returns the

reference number already assigned to the file. In other words, OpenRFPerm cannot be
used to open a second access path to a resource file nor can it be used to change the

permission of an already open file. Since OpenRFPerm gives no indication of whether the

file was already open, there’s no way to tell whether the file’s open permission is what you
specified or what was specified by an earlier call.
|

ad

nw
©
wv

Note: The shared read/write permission described in chapter 19 of this volume has

©
7

no effect with OpenRFPerm since the Resource Manager is unable to deal with a
portion of a resource file.

Lew

O
oe

pot)

A

RESOURCE TYPES
The following standard resource types have been defined (System file version 3.0 or later):
Resource
'‘CACH'
‘'FMTR'
‘FOND'
'NFNT'
‘PRER'
‘PRES'
'PTCH'
"RDEV'
"ROvr'
'ROv#'
‘bmap'
‘ctab'
‘Insc’

type

Meaning
RAM cache code
3 1/2-inch disk formatting code
Font family record
128K ROM font
Device type for Chooser
Device type for Chooser
ROM patch code
Device type for Chooser
Code for overriding ROM resources
List of ROM resources to override
Bit maps used by the Control Panel
Used by the Control Panel
Installer script

Uppercase and lowercase letters are distinguished in resource types. You can use any fourcharacter sequence, except those listed above, those already reserved in chapter 5 of

Volume 1, and those sequences consisting entirely of lowercase letters (reserved by

Apple), for resource types specific to your application. There’s no need to register your
resource types with Apple since they’ll only be used by your application.

Resource Types I[V-17

—
pa)

©
=

|

Inside Macintosh

CHECKING FOR ERRORS
In the 64K ROM, some error conditions resulting from certain Resource Manager routines
are not reported by the ResError function. Two additional result codes are defined in the
~ 128K ROM version of the Resource Manager:
CONST

resAttrErr

mapReadErr

198;
199;

In the 128K ROM, the following

{attribute does not permit operation}
{map does not permit operation}

error conditions are reported by ResError:

a The OpenResFile function checks to see that the information in the resource map is
internally consistent; if it isn’t, ResError returns mapReadError.
= The CloseResFile procedure calls UpdateResFile. If UpdateResFile returns a nonzero
result code, that result code will be returned by CloseResFile.

u If you provide an index to GetIndResource (or GetlIndResource) that’s either 0 or
negative, the ResError function will return the result code resNotFound.

= If you call DetachResource to detach a resource whose resChanged attribute has been
set, ResError will return the result code resAttrErr.
= If you call SetResInfo but the resProtected attribute is set, ResError will return the
result code resAttrErr.

= If you call ChangedResource but the resProtected attribute for the modified resource is
set, the ResError function will return the result code resAttrErr.

a If you call UpdateResFile but the mapReadOnly attribute for the resource file is set
(described in the “Advanced Routines” section of the Resource Manager chapter),
ResError will return the result code mapReadErr.
Warning: If you call the GetResource and Get1 Resource functions with a resource
type that isn’t in any open resource file, they return NIL but the ResError function
will return the result code noErr.

returned is nonzero.

With these calls, you must check that the handle

ROM RESOURCES
The information presented in this section is useful only to assembly-language
programmers.
With the 64K ROM, many of the system resources are stored in the system resource file.
With the 128K ROM, the following system resources are stored in ROM:

IV-18

ROM Resources

The Resource Manager
Type

ID

Description

'CURS'
'CURS'
'CURS'

1
2
3

[BeamCursor
CrossCursor
PlusCursor

‘DRVR'

2

‘CURS'

'DRVR'
‘'DRVR'
‘DRVR'
‘DRVR'
‘FONT’
‘FONT’
'MDEF'

‘PACK'

‘PACK’

'PACK'

‘'SERD’
'WDEF

4

WatchCursor

3
4
9
A

Sound Driver (.Sound)
Disk Driver (.Sony)
AppleTalk driver (.MPP)
AppleTalk driver (.ATP)

0O
C
0

4
5

7

0
0

|

Printer Driver shell (.Print)

Name of system font
System font
Default menu definition procedure

Floating-Point Arithmetic Package

ad

Binary-Decimal Conversion Package

~
©
n

Transcendental Functions Package

©
=

Serial Driver
Default window definition function

Leae §

om
a

Note: The Sound Driver, Disk Driver, and Serial Driver are in the 64K ROM, but
are not stored as resources.

When the Macintosh is turned on, a call is made to the InitResources function. The

Resource Manager creates a special heap zone within the system heap, and builds a
resource map that points to the ROM resources.
In order to use the ROM resources in your calls to the Resource Manager, the ROM map
must be inserted in front of the map for the system resource file prior to making the call.

The global variable RomMapInsert is used for this purpose; it tells the Resource Manager to
insert the ROM map for the next call only. An adjacent global variable, TmpResLoad, is

also useful; when RomMapInsert is TRUE, TmpResLoad determines whether the value of
the global variable ResLoad is taken to be TRUE or FALSE (overriding the actual value of
ResLoad) for the next call only. Figure 1 shows these two variables.

RomMepinsert (byte) | TmpResLoed (byte)
Figure 1. RomMapInsert and TmpResLoad

|
BS

Two global constants, each a word in length, are provided for setting these variables in
tandem: mapTrue inserts the ROM map with SetResLoad(TRUE) and mapFalse inserts the
ROM map with SetResLoad(FALSE). As noted, both RomMapInsert and TmpResLoad
are Cleared after each Resource Manager call.

Note: There is no real resource file associated with the ROM resources; the ROM

map has a path reference number of 1 (an illegal path reference number). There are
two ways to determine if a handle references a ROM resource. First, you can set up
TmpResLoad and RomMapInsert and call HomeResFile; if 1 is returned, the handle
is toa ROM resource. Second, you can dereference the handle and see if the master
pointer points into the ROM space by comparing it to the global variable ROMBase.

ROM Resources IV-19

i
~~
i)
F2
o
“

Inside Macintosh

Overriding ROM Resources
This section explains how to override ROM resources.
Warning: As with intercepting system traps using the SetTrapAddress procedure,
you should override ROM resources only if it’s absolutely necessary and you
understand the situation completely.
You can override some of the ROM resources, such as 'CURS' resources, simply by
putting the substitute resource in your application’s resource fork. Other ROM resources

however, such 'DRVR' and 'PACK' resources, cannot be overridden in this way because

they are already referenced and in use when your application is launched.

Whenever InitResource is called, the ROM map is rebuilt. (Do not use InitResources to
rebuild the ROM map.) Each time the ROM map is rebuilt, the Resource Manager looks in
the system resource file for a 'ROvr' resource 0. If it finds such a resource, it loads it into
memory and jumps to this resource via a JSR instruction. The code in the ‘ROvr' resource
looks in the system resource file for all resources of type '"ROv#' whose version word
matches the version word of the ROM (see Figure 2). For example, to override a resource
in the 128K ROM, the version must be $75.
version number of ROM (word)
number of resources - 1 (word)
resource type (4 bytes)
resource ID (word)

resource type (4 bytes)

4

resource ID (word)

4

Figure 2. Structure of an 'ROv#' Resource
To override ROM resources in this way, you’ll first need a copy of an 'ROvr' resource;
you can obtain one by writing to:

Developer Technical Support
Mail Stop 3-T
Apple Computer, Inc.

20525 Mariani Avenue

Cupertino, CA 95014

You'll then need to create an 'ROv#' resource listing the resources you want to override.

IV-20 ROM Resources

The Resource Manager

SUMMARY OF THE RESOURCE MANAGER
Constants
CONST

{

Resource

resAttrErr
mapReadErr

Manager
=
=

result

-198;
-199;

codes

}

{attribute inconsistent with operation}
{map inconsistent with operation}

Routines
Cod

FUNCTION

CountlTypes

FUNCTION

Count1Resources

FUNCTION

Getl1Resource

FUNCTION
FUNCTION
FUNCTION
FUNCTION

GetlNamedResource
Uniquel1ID
MaxSizeRsrc
RsrcMapEntry

(theType: ResType;
index:
INTEGER)
Handle;
(theType: ResType; theID:
INTEGER)
Handle;
(theType: ResType; name: Str255)
:
(theType: ResType)
: INTEGER;
(theResource: Handle)
: LONGINT;
(theResource:
Handle)
: LONGINT;

FUNCTION

OpenRFPerm

(fileName:

PROCEDURE

:

GetliIndType

FUNCTION

INTEGER;

(VAR

theType:

(theType:

GetlIndResource

ResType;

ResType)

permission:

Str255;

Byte)

index:

: INTEGER;

vRefNum:

:

INTEGER;

INTEGER) ;

Handle;

INTEGER;

Assembly-Language Information
Constants
,

Resource

Manager

result

resAttrErr
mapReadErr

-EQU
-EQU

-198
-199

setting

RomMapInsert

;

Values

for

mapTrue
mapFalse

. EQU
. EQU

SFFFF
SFFQOQ

codes
;attribute inconsistent with operation
;map inconsistent with operation

;insert
;insert

and

TmpResLoad

ROM
ROM

map
map

with
with

TmpResLoad
TmpResLoad

set
set

to
to

TRUE
FALSE

Special Macro Names
Pascal

name

GetlIndType

GetlIndResource

Macro

name

_GetlIxType

_GetlIxResource

Summary of the Resource Manager IV-21

ia
Ss

5

©
=
=
re
es

Inside Macintosh
Variables

RomMapInsert
TmpResLoad

Flag for whether to insert map to the ROM resources (byte)
Temporary SetResLoad state for calls using RomMapInsert (byte)

IV-22 Summary of the Resource Manager

4

QUICKDRAW

The performance of QuickDraw in the 128K ROM has been enhanced considerably.

New

capabilities have been added, and a number of bugs in the 64K ROM version have been
fixed. In conjunction with the Font Manager, QuickDraw supports font families, fractional
character widths, and the disabling of font scaling; these features are described in chapter 5

of this volume.

:

The 128K ROM version of QuickDraw supports all eight transfer modes for text drawing,
instead of just srcOr, srcBic, and scrXor.
The size of a picture is a long word with a range of over four gigabytes. To get the size of
a picture, use GetHandleSize instead of looking at the picSize field, which for compatibility
contains the low 16 bits of the real size. Old code will work fine for pictures up to 32767

bytes. To check whether you have run out of memory during picture creation, test

EmptyRect(picFrame); it returns TRUE if you have.
The following bugs have been fixed:

= RectiInRgn used to return TRUE occasionally when the rectangle intersected the
region’s enclosing rectangle but not the actual region.
= SectRgn, DiffRgn, UnionRgn, XorRgn, and FrameRgn used to cause a stack
overflow for regions with more than 25 rectangles in one scan line. Since this is no
longer true, the warning on page I-186 regarding undefined results no longer applies.
m PtToAngle didn’t work correctly when the angle was 90 and the aspect ratio was a
power of two.
w In some cases where the CopyBits source bitmap overlapped its destination, the

transfer would destroy the source bitmap before it was used.

a If you tried to draw a long piece of shadowed text with a tall font, QuickDraw would
cause a stack overflow if there wasn’t enough stack space for the required off-screen
buffer. Now it detects the potential stack overflow and recurses on the left and right
halves of the text.

= DrawText did not work correctly in pictures if the character count was greater

than 255.

QUICKDRAW ROUTINES
The SeedFill and CalcMask procedures operate on a portion of a bitmap.

In both routines,

srcPtr and dstPtr point to the beginning of the data to be filled or calculated, not to the

beginning of the bitmap; both parameters must point to word boundaries in memory.
SrcRow and dstRow specify the row width in bytes (in other words, the rowBytes field of
the BitMap record) of the source and destination bitmaps respectively. Height and words

QuickDraw Routines IV-23

a
(=)

E.
°
=
0

~
=

lem

§

Inside Macintosh

determine the number of bits to be filled or calculated; words is the width of the rectangle in
words and height is the height of the rectangle in pixels. Figure 1 illustrates the use of
these parameters.
¢

srcPtr

srcRow

—>)

words

—

¢

dstRow

>

—>

height
|

g

dstPtr

> —

words —

|

height

source bitmap

destination bitmap

Figure 1. Parameters Used by SeedFill and CalcMask
PROCEDURE

SeedFill
(srcPtr,dstPtr:
Ptr;
words, seedH, seedV:
INTEGER) ;

srcRow,dstRow,height,

Given a source bit image, SeedFill computes a destination bit image with 1’s only in the
pixels where paint can leak from the starting seed point, like the MacPaint paint-bucket
tool. SeedH and seedV specify horizontal and vertical offsets, in pixels, from the
beginning of the data pointed to by dstPtr, determining how far into the destination bit
image filling should begin. Calls to SeedFill are not clipped to the current port and are not
stored into QuickDraw pictures.
PROCEDURE

CalcMask
(srcPtr,dstPtr:
words:
INTEGER) ;

Ptr;

srcRow,dstRow,height,

Given a source bit image, CalcMask computes a destination bit image with 1’s only in the
pixels where paint could not leak from any of the outer edges, like the MacPaint lasso tool.
Calls to CalcMask are not clipped to the current port and are not stored into QuickDraw
pictures.
PROCEDURE

CopyMask
(srcBits,maskBits,dstBits:
maskRect,dstRect:
Rect);

BitMap;

srcRect,

CopyMask is a new version of the CopyBits procedure; it transfers a bit image from the
source bitmap to the destination bitmap only where the corresponding bit of the mask
rectangle is a1. (Note that the mask is specified as a rectangle instead of as a handle to a
region.) It can be used along with CalcMask to implement the lasso copy as in MacPaint;
it’s also useful for drawing icons. CopyMask doesn’t check for overlap between the
source and destination bitmaps, doesn’t stretch the bit image, and doesn’t store into

QuickDraw pictures. CopyMask does, however, respect the current port’s visRgn and
clipRgn if dstBits is the portBits of the current grafPort.
IV-24 QuickDraw Routines

QuickDraw
PROCEDURE

MeasureText

(count:

INTEGER;

textAddr,charLocs:

Ptr);

This procedure is designed to improve performance in specialized applications such as
word processors by providing an array version of the TextWidth function; it’s like calling
TextWidth repeatedly for a given set of characters. TextAddr points to an arbitrary piece of
text in memory, and count specifies how many characters are to be measured.
MeasureText moves along the string and, for each character, computes the distance from
TextAddr to the right edge of the character. CharLocs should point to an array of count + 1
integers.

Upon return, the first element in the array will always contain 0; the other

elements will contain pixel positions on the screen for all of the specified characters.
Note: MeasureText only works with text displayed on the screen; since it doesn’t go
through the QuickDraw procedure StdText, it can’t be used to measure text to be
printed.
Advanced Routine

The function GetMaskTable, accessible only from assembly language, returns in register
AO a pointer to a ROM table containing the following useful masks:
.WORD

$0000,58000,$C000,
SE000

.WORD

SFFOO0, SFF80, SFFCO,

-WORD

SF000,5F800,
S$FC00, SFE00

SFFFO, $FFF8,SFFFC,
$SFFFE

-WORD
.WORD

SFFFF,S7FFF, $3FFF,$S1FFF
SOFFF,SO7FF,S03FF,S0O1FF

-WORD

SOOOF,$0007,$0003,
$0001

-WORD
-WORD
-WORD
~WORD

of

16

right

masks

-

O
i,
a
~
=
=

;Table

of

16

left

masks

;Table

of

16

bit

masks

SOOFF,S007F,S003F,$001F

$8000,$4000,$2000,$1000
$0800,$0400,$0200,$0100
$0080,$0040,$0020,
$0010
$0008,$0004,$0002,$0001

b
(2)

SFFEO

.WORD

.WORD

;Table

QuickDraw Routines IV-25

Inside Macintosh

SUMMARY OF QUICKDRAW
Routines
PROCEDURE

SeedFill

(srcPtr,dstPtr:

PROCEDURE

CalcMask

(srcPtr,dstPtr:

seedH,

seedV:

Ptr;

srcRow,

dstRow, height,

Ptr;

srcRow,

dstRow,

INTEGER) ;

height, words:

INTEGER) ;

PROCEDURE

CopyMask

(srcBits,maskBits,dstBits:

PROCEDURE

MeasureText

(count:

maskRect,dstRect:
INTEGER;

Rect);

BitMap;

textAddr,charLocs:

srcRect,
Ptr);

Assembly-Language Information

Routine
Trap macro

On entry

_GetMaskTable

IV-26 Summary of QuickDraw

words,

On exit

AO: ptr to mask table in ROM

5 THE FONT MANAGER
About the Font Manager
Fonts and Their Families

About Names and Numbers

Font Manager Routines
Comrhunication Between QuickDraw and the Font Manager
Font Scaling

Fractional Character Widths
Font Manager Data Structures
Font Records
Family Records

Global Width Tables

Font and Font Family Resources
Family Record Format

Restrictions on the "FONT" Type
Summary of the Font Manager

un
oy
©
om
-_-

4

boat

pee)
~
poh)
tro
ae)
be

Contents IV-27

|

Inside Macintosh

IV-28

The Font Manager

ABOUT THE FONT MANAGER
The Font Manager has been significantly improved by the addition of new data structures,
most notably the family record. Containing additional typographic information about a

font, the family record allows more fonts, fractional character widths (that is, character
widths expressed as fixed-point numbers rather than simple integers) for greater precision
on high-resolution devices such as the LaserWriter, and the option of disabling font scaling
for improved speed and legibility.
The addition of the family record and its related data structures is transparent to most
existing applications and is of interest only to advanced programmers designing specialized
fonts for the LaserWriter or writing their own font editors.
Most programmers will simply want to take advantage of the new features. Two routines,
SetFractEnable and SetFScaleDisable, are provided for this purpose; they’re described in

“Font Manager Routines” below.

FONTS AND THEIR FAMILIES
In the 64K ROM version of the Font Manager, font is defined as the complete set of

characters of one typeface; it doesn’t include the size of the characters, and usually doesn’t
include any stylistic variations. In other words, fonts are defined in the plain style and
stylistic variations, such as bold and italic, are applied to them. For example, Times plain
(or roman) defines the font, while Times italic is a stylistic variation applied to that font.
In the 128K ROM version, the definition of a font is broadened to include stylistic
variations. That is, a separate font can be defined for certain stylistic variations of a

typeface. The set of available fonts for a given typeface is known as a font family.

This allows QuickDraw to use an actual font instead of modifying a plain font, thereby
improving speed and readability. For example, suppose the user of a word processor

selects a phrase in 12-point Times Roman and chooses the italic style from a menu.
QuickDraw asks for an italic Times and, assuming that the proper resources are available,

the Font Manager returns a 12-point Times Italic font. QuickDraw could then draw the

phrase from an actual italic font rather than having to slant the plain font.

Note: The standard stylistic variations will still be performed by QuickDraw when
they’re not available as actual fonts.
Information about fonts and their families is stored as resources in resource files; the Font
Manager calls the Resource Manager to read them into memory. Fonts are stored as
resources of type "FONT" or 'NFNT’. Fonts known to the system are stored in the system
resource file; you may also define your own fonts and include them in your application’s
resource file or even in the resource file for a document. The information about a font
family is stored as a resource of type 'FOND'; this includes the resource IDs of all the fonts
in the family, as shown in Figure 1.

Fonts and Their Families IV-29

mn
log]
©
=
-

pe)

=|

je)

wT

(ae)
=

Inside Macintosh

resource

resource

resource

ID

NENT

resource

ID

resource

resource

ID
NENT
resource

Figure 1. Font Manager Resources
The 'NFNT' resource is new to the 128K ROM version of the Font Manager; it has the

same format as the "FONT" resource and allows for many more fonts. An 'NFNT"

resource type can also be used to mask all but plain fonts from appearing in a font menu.
In this way, the system resource file can contain Times, Times Italic, Times Bold, and

Times Bold Italic, yet only Times will appear on the Font Menu.
choose Italic from the Style menu.)

(The user would need to

The 64K ROM can only handle 'FONT' resources; it ignores resources of type 'NFNT'
and 'FOND".

Warning: If you’re creating a font, be sure to read the section “Restrictions on the
‘FONT’ type” below for information on maintaining compatibility with the 64K
ROMs.
It’s crucial that all new fonts have a corresponding 'FOND' resource. A minimal 'FOND'
resource can be made for a font by using the Font/DA Mover (version 3.0 or later) to copy
the font into a different file that has no font with the same name.

Note: A 'FOND' resource created this way does not contain any optional tables, but

it does contain the font association table (described below) that maps family numbers
and font sizes into resource IDs.
Warning: Be aware that when a 'FOND' is present, the Font Manager uses it
exclusively to determine which fonts are available. Fonts should be added to or
deleted from the System file with a tool like the Font/DA Mover, which correctly
updates the 'FOND' as well as the "FONT".

The Font Manager uses these resources to build two data structures in the application heap.
The font record contains information about a font and the family record contains
information about a font family.
About Names and Numbers
In the 64K ROM version of the Font Manager, a font is identified by its font number,
which is always between 0 and 255. Each font also has a name that’s used to identify it in
menus. Font families are identified by a family number and a family name. Since existing
routines rely on passing and returning the font number in Font Manager routines, the
IV-30 Fonts and Their Families

The Font Manager
family number must be the same as the font number, and the family name must be the same
as the font name. Family numbers 0 through 127 are reserved for use by Apple; numbers
128 through 255 are assigned by Apple for fonts created by software developers.
Assembly-language note:

You can determine the system family number and size

by reading the global variables SysFontFam and SysFontSiz, respectively. This is
highly recommended, especially if your application is intended to run on Macintoshes
that are localized for non-English-speaking countries, as the localization process may

change the system font.

You can get the family number of the application font from the global variable

ApFontID. You can substitute a different family number in this variable but the

application font is reset to its default value (it’s stored in parameter RAM) whenever a
new application is launched.

Since font numbers only range from 0 to 255, only font families with family numbers in

this range are recognized by the 64K ROM version of the Font Manager. All fonts with
family numbers from 0 through 255 are stored as resources of type "FONT", so that the
64K ROM’s version of the Font Manager can recognize them.
It’s very important that all new fonts and font families be registered with Apple to avoid
conflict. To register the name of a font family, write to:
Developer Technical Support
Mail Stop 3-T
Apple Computer, Inc.
20525 Mariani Avenue

mn

Cupertino, CA 95014

When there’s a conflict, font families may be renumbered by the Font/DA Mover. For
instance, when the Font/DA Mover moves a font or font family into a file in which there’s
already a font (or font family) with that number (but with a different name), the new font
(or font family) is renumbered. For this reason, you should always call GetFNum to
verify the number of a font you want to access.

FONT MANAGER

ROUTINES

To improve the speed and readability of text display in your application, use the
SetFractEnable and SetFScaleDisable procedures to enable fractional character widths and
disable font scaling. Certain applications do not work properly when fractional character

widths are used and font scaling is disabled, so these features are turned off by default.

The FontMetrics function is much like QuickDraw’s GetFontInfo function except that it

returns fixed-point values, letting you draw characters in more precise locations on the
screen.

Font Manager Routines IV-31

=|
&
|
fs

©

~~

po)

itge)

@®

law

|

Inside Macintosh

If there’s a 'FOND' resource associated with the most recently drawn font, making the font

resource purgeable or unpurgeable with the SetFontLock procedure will make the ‘FOND'
resource resource purgeable or unpurgeable as well.
PROCEDURE

FontMetrics

(VAR

theMetrics:

FMetricRec) ;

FontMetrics is similar to the QuickDraw procedure GetFontInfo except that it returns fixedpoint values for greater accuracy in high-resolution printing.
The FMetricRec data structure is defined as follows:
TYPE

FMetricRec

=

RECORD

ascent:
descent:

Fixed;
Fixed;

widMax:

Fixed;

leading:

wTabHandle:

Fixed;

Handle;

{ascent }
{descent }

{leading}
{maximum

{handle

character

to

global

width}

width

table}

END;

Ascent, descent, leading, and widMax are identical in function to their counterparts in
GetFontInfo. WTabHandle is a handle to the global width table (described below).
PROCEDURE

SetFractEnable

(fractEnable:

BOOLEAN)

[Notin

ROM]

SetFractEnable lets you enable or disable fractional character widths. If fractEnable is
TRUE, fractional character widths are enabled; if it’s FALSE, the Font Manager uses
integer widths. To ensure compatibility with existing applications, fractional character

widths are disabled by default.

Assembly-language note: From assembly language, you can change the value of
the global variable FractEnable.

PROCEDURE

SetFScaleDisable

(fontScaleDisable:

BOOLEAN) ;

SetFScaleDisable lets you disable or enable font scaling. If fontScaleDisable is TRUE,
font scaling is disabled and the Font Manager returns an unscaled font with more space
around the characters; if it’s FALSE, the Font Manager scales fonts. To ensure
compatibility with existing applications, the Font Manager defaults to scaling fonts.
Assembly-language note: All programmers should use the SetFScaleDisable
procedure to disable and enable font scaling. In particular, setting the global variable
FScaleDisable is insufficient.

IV-32 Font Manager Routines

The Font Manager

COMMUNICATION BETWEEN QUICKDRAW
AND THE FONT MANAGER
The basic structure of the font input and output records passed between QuickDraw and the
Font Manager is unchanged.

Note: Advanced programmers who use the FMSwapFont function should be aware
that the Font Manager may attach optional tables to the font output record it returns.
The information QuickDraw passes to the Font Manager includes the font or family

number, the font size, and the scaling factors QuickDraw wants to use; the search for an

appropriate font is as follows.

The Font Manager first looks for a '"FOND' resource matching the ID of the requested font

or font family.

If it finds one, it searches the family record’s font association table (detailed

possible, giving

priority first to italic, then to bold. Quickdraw must then add any needed

below) for a an 'NFNT' or 'FONT' resource matching the requested style and size. If it
can match the size but not the style, it returns a font that matches as many properties as

stylistic variations (using the information passed in the bold, italic, ulOffset, ulShadow,
ulThick, and shadow fields of the font output record).

If the Font Manager can’t find a 'FOND' resource, it looks for a 'FONT' resource with the
requested font number and size. (It doesn’t look for a 'NFNT' resource since these occur
only in conjunction with 'FOND' resources.)
If the Font Manager cannot find a font for a particular style, the Font Manager and
QuickDraw derive a font (as in the 64K ROM version).

FA]

xj
©
~
-

Font Scaling

po]

=

If the Font Manager can’t find a font of the requested size and font scaling is enabled, it
follows the standard scaling algorithm (described in chapter 7 of Volume J) with one
exception:

If it can’t find a font that’s double or half the requested size, it looks for the font

that’s closest to the request size, either larger or smaller.

If it can’t find a font of the requested size and font scaling is disabled, the Font Manager

looks for a smaller font closest to the requested size and returns with it with the widths for

the requested size. Thus, QuickDraw draws the smaller font with the spacing of the larger,
requested font. This is generally preferable to font scaling since it’s faster and more
readable. Also, it accurately mirrors the word spacing and line breaks that the document
will have when printed, especially if fractional character widths are used.

Fractional Character Widths
The use of fractional character widths allows more accurate character placement on highresolution output devices such as the LaserWriter. It also enables character placement on
the screen to match more closely that on the LaserWriter (although QuickDraw cannot
actually draw a letter 3.5 pixels wide, for instance). The Font Manager will, however,
Communication Between QuickDraw and the Font Manager IV-33

jo)

v2

fae)

Lae §

Inside Macintosh
store the locations of characters more accurately than any particular screen can display.

Given exact widths for characters, words, and lines, the LaserWriter can print faster and

give better spacing. A price must be paid, however; since screen characters are made up of

whole pixels, spacing between characters and words will be uneven as the fractional parts

are rounded off. The extent of the distortion depends on the font size relative to the screen
resolution.
The Font Manager communicates fractional character widths QuickDraw via the global
width table, a data structure allocated in the system heap. The Font Manager gathers the
width data for this table from one of three data structures.

Warning: You should always obtain character widths from the global width table

since you can’t really know where the Font Manager obtained the width information
from. A handle to the global width table is returned by the FontMetrics procedure.

First, it looks for a font character-width table in the font record. In this table, the actual
widths of each character in the font are stored in a 16-bit fixed-point format with an integer
part in the high-order byte and a fractional part in the low-order byte.
If itj doesn’t find this table, it looks in the family record for a family character-width table.

For each font in the family, this table contains the fractional widths for every character as if
a hypothetical one-point font; the actual values for the characters are calculated by

multiplying these widths by the font size. The widths in this table are stored in a 16-bit
fixed-point format with an integer part in the high-order 4 bits and a fractional part in the
low-order 12 bits.

If no family character-width table is found, the global character widths are derived from the

integer widths contained in the offset/width table in the font record (described in chapter 7
of Volume I).
To use fractional character widths effectively, an application must get accurate widths for

the characters, either by using the QuickDraw function TextWidth or by looking
global widih table.

in the

Warning: Applications that derive their own character widths may not function
properly when fractional widths are enabled.

FONT MANAGER DATA STRUCTURES
This section describes the data structures that define fonts and font families; you need to
read it only if you’re going to define your own fonts or write your own font editor. Most
of the information in this section is useful only to assembly-language programmers.
Figure 2 shows some of the relationships between the various data structures used by the

Font Manager. Handles are shown as dotted lines; the one pointer is shown by a solid line.

IV-34 Font Manager Data Structures

The Font Manager

font record
-¥

width table
width table
|
~¥

vs

font record

font record
FMOutRec
fontHandle

width table

1

width list

FMInRec

key

(up to 12 handles)

family record

—anPr

| 4

|

|

family recor

widthTabHandle
lastFOND

family record

low memory

application heap

widthListHand
system heap

;

Figure 2. Font Manager Data Structures

Font records and family records, the structures from which global width tables are derived,
are kept in the application heap. Global width tables, which are used constantly, are kept in
the system heap.
_

Fa]
=
7)
|
=

Font Records

i
=
ot)
2

To maintain compatibility with existing applications, the order of the fields in the font
record remains unchanged; two variable-length arrays are added at the end of the record,
however, to implement fractional character widths.
Additional constants have been defined for use in the fontType field; it can now contain any
of the following values:
CONST

propFont
prpFntH
prpFntw
prpFntHw

=
=
=
=

$9000;
$9001;
$9002;
$9003;

{proportional font}
{ with height table}
{ with width table}
{ with height & width

tables}

fixedFont
fxdFntH
fxdFntw
fxdFntHWw

=
=
=
=

$B000;
$B001;
$B002;
$B003;

{fixed-width font}
{ with height table}
{ with width table}
{ with height & width

tables}

fontWid

= SACBO;

{font

ROM

width

data:

64K

only}

Font Manager Data Structures IV-35

@
ae |

Inside Macintosh

The low-order two bits of the fontT ype field tell whether the two optional tables are

present. If bit 0 is set, there’s an image-height table; if bit 1 is set, there’s a character width
table.
The optional character-width table immediately follows the offset/width table; it’s a

variable-length array specifying the fixed-point character widths for each character in the

font. Each entry is a word in length. For compactness, a special 16-bit fixed-point format
is used with an unsigned integer part in the high-order byte and a fractional part in the loworder byte.
The optional image-height table, which speeds the drawing of characters, may also be
appended after the character-width table; it’s a variable-length array specifying the image
height of each character in the font. Each entry is a word in length; the high-order byte is
the offset of the first non-white row in the character; the low-order byte is the number of
rows that must be drawn. The image height is the height of the character image and 1s less
than or equal to the font height; it’s used in conjunction with QuickDraw for improved
character plotting. Most font resources don’t contain this table; it’s typically generated by
the Font Manager when the font is swapped in.
Note: The 64K ROM version of the Resource Manager limits the total space
occupied by the bit image, location table, offset/width table, and character-width and
image-height tables to 32K bytes. For this reason, the practical limit on the font size
of a full font is about 40 points.

Family Records
A family record defines a font family; the information is loaded from the 'FOND' resource.
Assembly-language note: The global variable LastFOND is a handle to the last
family record used. You can read the contents of the family record by using this handle.
You should not alter the contents of this record.
The data type for a family record is as follows:
TYPE

FamRec
RECORD

=

ffFlags:
ffFamID:
ffFirstChar:
ffLastChar:
ffAscent:
ffDescent:
ffLeading:
f£WidMax:
ffwWlaboff:
ffKernOff:

INTEGER;
INTEGER;
INTEGER;
INTEGER;
INTEGER;
INTEGER;
INTEGER;
INTEGER;
LONGINT;
LONGINT;

IV-36 Font Manager Data Structures

{flags for family}
{family ID number}
{ASCII code of the first character}
{ASCII code of the last character}
{maximum ascent for 1-pt.font}
{maximum descent for 1-pt.font}
{maximum leading for l1-pt.font}
{maximum width for l-pt.font}
{offset to width table}
{offset to kerning table}

The Font Manager

{

{
{

{

fFEStyloff:
ffProperty:

LONGINT;
ARRAY[(1..9]

OF

ffIntl1:

ARRAY[1..2]

OF

ffVersion:
ffAssoc:

INTEGER;
FontAssoc;

}

{version number}
{font association

KernTable;

}

{kerning

ffWidthTab:
f£StyTab:
ff£KernTab:

WidTable; }
StyleTable;}

{offset to style-mapping table}
INTEGER;
{style property info}
INTEGER;

{reserved}

{width table}
{style-mapping

table}

table}

table}

END;

Note: The variable-length arrays appear as comments because they’re not valid
Pascal syntax; they’re used only as conceptual aids.
The ffFlags field defines general characteristics of the font family, as follows:
Bit

Meaning

0
1

Set if there’s an image-height table
Set if there’s a character-width table

2-11
12
13
14

15

Reserved (should be zero)
Set to ignore FractEnable when deciding whether to use fixed-point values for
stylistic variations (see bit 13), clear to treat FractEnable as usual
Set to use integer extra width for stylistic variations, clear to compute fixedpoint extra width from the family style-mapping table when FractEnable is
TRUE
Set if family fractional-width table is not used, clear if table is used
Set for fixed-width font, clear for proportional font

The values in the ffAscent, ffDescent, ffLeading, and ffWidMax describe the maximum

dimensions of the family as they would be for a hypothetical one-point font to be scaled up.

They use a special 16-bit fixed-point format with an integer part in the high-order 4 bits and
a fractional part in the low-order 12 bits. The FontMetrics procedure calculates the true
values by multiplying this number by the actual point size.

wm

les
-)
peo
-

pe]

The ffWTabOff, ffKernOff, and ffStylOff fields are offsets from the top of the record to

the start of the width table, kerning table, and style-mapping table, respectively; if any of

these fields is zero, the corresponding table does not exist.

Font Manager Data Structures IV-37

=}

pe)

2

fas)
a |

Inside Macintosh

The ffProperty field is the family style-property table, shown in Figure 3.

extra width for Plain text -set to 0 (word)
extra width for Bold text (word)
extra width for Italic text (word)
extra width for Underline text (word)
extra width for Outline text (word)
extra width for Shadow text (word)
extra width for Condensed text (word)
extra width for Extended text (word)
not used - set to 0 (word)

Figure 3. Family Style-Property Table
Each entry is a 16-bit fixed-point number with a signed integer part in the high-order 4 bits
and a fractional part in the low-order 12 bits. These numbers are used to calculate the
amount of extra width for special stylistic variations; each of these values is multiplied by
the point size of the font actually being used. If the font already exists for a given style, the
value in its field is ignored.
The ffAssoc field contains the font association table.

This table, shown in Figure 4, is

used to match a given font size and style combination with the resource ID of an actual
font.
number of entries - 1 (word)
first FONT entry (6 bytes)

Z

second FONT entry (6 bytes)

Z

Figure 4. Font Association Table
Note: In order to reduce search time, the Font Manager requires that the entries be
sorted according to the fontSize field, with the smallest sizes first. If multiple fonts

from the same family, the plain (roman) fonts come first. The Font Manager is
optimized to look first for '"NFNT" resources, then 'FONT' resources.

Each entry in the font association table has the format shown in Figure 5.

IV-38 Font Manager Data Structures

The Font Manager

font size (word)
font style (word)
resource ID of associated
FONT resource (word)

Figure 5. Font Association Table Entry
The font association table is followed by the family character-width table. As shown in
Figure 6, this table is actually a number of width tables (since a font family may include
numerous styles).
number of width tables - 1 (word)
style code (word)
first width table
style code (word)
second width table

with an unsigned integer part in the high-order 4 bits and a fractional part in the low-order
12 bits.

L_

-—_—.

1 for Bold style selected

1 for Italic style selected
1 for Underline style selected
| for Outline style selected
1 for Shadow style selected
1 for Condensed style selected
1 for Extended style selected

* reserved for use by the Font Manager

Figure 7. Style Codes
Font Manager Data Structures IV-39

JISVUBIAI IUOY

Each character-width table is preceded by a style code; the low-order byte of this word
specifies stylistic variations (see Figure 7). The widths in each table are for a hypothetical
one-point font; the actual values for the characters are calculated by multiplying these
widths by the font size. The widths in this table are stored in a 16-bit fixed-point format

S

Figure 6. Family Character-Width Table

Inside Macintosh

The style-mapping table and its associated tables are used by the LaserWriter driver and are
described in /nside LaserWriter.
The kerning table, like the family character-width table, is actually a number of kerning
tables (see Figure 8).

number of kerning tables -1 (word)
first kerning table
second kerning table

A

4
Figure 8. Kerning Table

Each kerning table is preceded by a style code; stored in the low-order byte of the word,
this style information has the same format shown in Figure 7 above. The number of entries
in the table follows the style word (see Figure 9).
style code (word)

number of entries (word)
first kerning pair entry (4 bytes)

Z

second kerning pair entry (4 bytes)

Z

Figure 9. Structure of a Kerning Table
The entries in each kerning table (shown in Figure 10) consist of a pair of characters

followed by a kerning offset for a hypothetical one-point font. This value, represented by
an integer part in the high-order 4 bits and a fractional part in the low-order 12 bits, is
multiplied by the size of the font to obtain the actual offset.
first character of kerning pair (byte)
second character of kerning pair (byte)

kerning offset (word)
Figure 10. Kerning Table Entry

IV-40 Font Manager Data Structures

The Font Manager

Global Width Tables
The Font Manager communicates fractional character widths to QuickDraw via a global
width table, a data structure allocated in the system heap. A handle to the global width

table is returned by the FontMetrics procedure. The format of the global width table is
follows:

TYPE

WidthTable=
RECORD
tabData:

tabFont:

sExtra:
style:
fID:

Handle;

LONGINT;
LONGINT;

OF

Fixed; {

{font

record

character

used

{extra

due

to

family

ID}

Point;

{denominators

of

fHand:

handle;

{family

houtput:

INTEGER;

INTEGER;
INTEGER;
INTEGER;
Point;

aFID:

INTEGER;

usedFam:
aFace:
vOutput:

BOOLEAN;
Byte;
INTEGER;

factors}

{actual

for

font

ID

used

to

factors}

table}

build

table}

{used fixed-point family widths}
{actual face produced}
{vertical factor for expanding }
{

characters}

{horizontal

for

expanding

{horizontal
{ character

factor for
widths}

increasing

{total

of

INTEGER;

INTEGER;

aSize:

INTEGER;

{actual

INTEGER

scaling

family

record

hFactor:
tabSize:

table}

{font size request}
{style
(face)
request}
{device requested}
{numerators of scaling

{ characters}
{not used}

vFactor:

widths}

build

style}

{font

fSize:
face:
device:
inNumer:

to

{space extra used for table}

INTEGER;

inDenom:

END;

ARRAY[(1..256]

size

size

factor

of

actual

table}

font

}

used}

}
Fa

=
io)
~
-

TabData is an array containing a character width for each of the 255 possible characters in a

font, plus one long word for the font’s missing symbol. The widths are stored in the
standard 32-bit fixed-point format. If a character is missing, its entry contains the width of
the missing symbol.: (For efficiency, the Font Manager will store up to 12 recently used
global width tables.) InNumer and inDenom contain the vertical and horizontal scaling

factors copied from the font input record.

Scaling is effected in two ways: by expanding characters of the chosen font and by
artificially increasing the widths of the chosen font in the width table. HOutput and
vOutput give the factors by which characters are to be expanded horizontally and vertically.
HFactor is the factor by which the widths of the chosen font, after stylistic variations, have
been increased. (VFactor is not used.) Thus, multiplying hOutput and vOutput by hFactor
and vFactor gives the true font scaling; the product of hOutput and an entry in the width
table is that character’s true scaled width. HOutput,vOutput, hFactor, and vFactor are all
16-bit fixed-point numbers, with an integer part in the high-order byte and a fractional part
in the low-order byte. -

Font Manager Data Structures IV-41

o

|

po)
TS
fae)

Lene §

Inside Macintosh
If font scaling has been enabled, hFactor and vFactor both have a value of 1. In any case,
hOutput, vOutput, hFactor, and vFactor are adj usted so that the values of hFactor and

vFactor lie between 1 and 2, including 1.

Assembly-language note: A handle to the global width table is contained in the
global variable WidthTabHandle. A pointer to the table is contained in the global

variable WidthPtr; it’s reliable immediately after a call to FMSwapFont but, like all
pointers, may become invalid after a call to the Memory Manager.

The global variable WidthListHand is a handle to a list of handles to up to 12 recentlyused width tables. You can scan this list, looking for width tables that match the family
number, size, and style of the font you wish to measure. If you reach a width handle
that’s equal to —1, that width table is invalid, and you must make an FMSwapFont call

to get a valid one. When you reach a handle that’s zero, you’ve reached the end of the
list.

You should not use the global width table when special international interface software
is being used to accommodate non-Roman alphabets. You can recognize such software

by looking at the global variable IntlSpec; if it’s greater than 0, special international
software is installed. If your application uses non-Roman alphabets, write to
Developer Technical Support

Mail Stop 3-T
Apple Computer, Inc.
20525 Mariani Avenue
Cupertino, CA 95014

for the latest version of the International Utilities Package, which will be extended to
handle non-Roman alphabets.

FONT AND FONT FAMILY RESOURCES
The various sizes of a font are each stored as separate resources. The resource type for a

font is either 'FONT! or 'NFNT'; the two have identical formats:
Number of bytes

Contents

2 bytes
2 bytes
2 bytes
2 bytes

FontType field of font record
FirstChar field of font record
LastChar field of font record
WidMax field of font record

2 bytes

FRectWidth field of font record

2 bytes
2 bytes

2 bytes
2 bytes
2 bytes
2 bytes

KernMax field of font record
NDescent field of font record

FRectHeight field of font record
OWT Loc field of font record
Ascent field of font record
Descent field of font record

IV-42 Font and Font Family Resources

The Font Manager

Number of bytes

Contents

2 bytes

Leading field of font record

m bytes

Offset/width table of font
m = 2 * (lastChar—firstChar+3)

2 bytes
n bytes
|
m bytes

m bytes
m bytes

RowWords field of font record
Bit image of font
n = 2 * rowWords * fRectHeight
Location table of font
|
m = 2 * (lastChar—firstChar+3)
Optional character-width table of font
m=2* (lastChar—firstChar+3)
Optional image-height table of font
= 2 * (lastChar—firstChar+3)

The resource type 'FRSV' is reserved by the Font Manager; it identifies fonts used by the
system. Fonts whose resource IDs are contained in a 'FRSV' resource 1 will not be

removed from the system resource file by the Font/DA Mover. The format of a 'FRSV'
resource is as follows:

Number of bytes

2 bytes —

n * 2 bytes

Contents

Number of font resource IDs
n font resource IDs

Family Record Format
A font family is stored as a resource of type ‘FOND’; it consists of the following:
Number of bytes

2 bytes
2 bytes
2 bytes

2 bytes
2 bytes
2 bytes
2 bytes
2 bytes

4 bytes

4 bytes
4 bytes
24 bytes
6 bytes
m bytes
n bytes
p bytes
q bytes

Wr

es

Contents

=

FONDFilags field of family record
FONDFamID field of family record
FONDFirst field of family record

=
1
=

FOND Last field of family record
FONDAscent fieldof family record
FONDDescent field of family record

FONDLeading field of family record
FONDWidMax field of family record

FONDWTabOff of family record

FONDKernOff of family record
FONDStylOff of family record
FONPProperty field of family record
FONDIntl field of family recotd
FONDAssoc field of family record (variable length)
FONDWidTable field of family record (variable length)
FONDStyI!Tab field of family record (variable length)
FONDKerntab field of family record (variable length)

Font and Font Family Resources IV-43

=

Inside Macintosh

Restrictions on the 'FONT' Type
For backward compatibility, all 'FONT' resources that are part of a 'FOND' have certain

restrictions:

1. The font name and family name must be identical.
2.

The font number and family number must be identical since the Font Manager

3.

The resource ID of the font must be the same number that would be produced
by concatenating the font number and the font size (as described in chapter 7 of
Volume J).

interprets a family number as a font number.

These restrictions ensure that both the 64K ROM and 128K ROM versions of the Font
Manager will associate the family number and point size with the proper corresponding font
resource ID, whether or not there’s a family resource. 'NFNT' resources are not bound by

these restrictions (but neither will they be found by the 64K ROM version of the Font

Manager).

IV-44 Font and Font Family Resources

The Font Manager

SUMMARY OF THE FONT MANAGER
Constants

CONST

{

Font

types

}

propFont
prpFntH
prpFntw
prpFntHw

=
=
=
=

$9000;
$9001;
$9002;
$9003;

{proportional font}
{ with height table}
{ with width table}
{ with height & width

fixedFont
fxdFntH

=
=

$B000;
$B001;

{fixed-width font}
{ with height table}

fxdFntHw

=

$B003;

{

=

SACBO;

fxdFntw

fontwWid

=

$B002;

{

with

with

{font

width

table}

height
width

tables}

&

width

data:

tables}

64K

ROM

only}

Data Types
FMetricRec

=

RECORD

ascent:
descent:
leading:

Fixed;
Fixed;
Fixed;

{ascent}
{descent }
{leading}

wlabHandle:

Handle

{handle

widMax:

END;
FamRec

font

width}

width

table}

{flags for
{family ID

ffAscent:
ffDescent:
ffLeading:
ffWidMax:

INTEGER;
INTEGER;
INTEGER;
INTEGER;

{maximum
{maximum
{maximum
{maximum

ffProperty:

INTEGER;
INTEGER;

LONGINT;
LONGINT;
LONGINT;

ARRAY[1..9]

FEFInt1l:

ARRAY[1..2]

£fAssoc:

FontAssoc;

ffVersion:
£f£WidthTab:
f££StyTab:
f£fKernTab:

wn

a

=
Ks
=

INTEGER;
INTEGER;

fEWTabOff:
ffKernOff:
fEStyloff:

{

character

to

ffFlags:
ffFamID:

ffFirstChar:
ffLastChar:

{
{

{maximum

=

RECORD

{

Fixed;

INTEGER;

OF
OF
}

WidTable; }
StyleTable;}
KernTable; }

{ASCII
{ASCII

code
code

{offset
{offset
{offset

to
to
to

INTEGER;

INTEGER;

{version
{font

&

family}
number}
of
of

c

the
the

first
character}
last character}

ascent for l1-pt.font}
descent for 1l-pt.font}
leading for i-pt.font}
width for 1-pt.font}

width table}
kerning table}
style-mapping
table}

{style

property

{reserved}

number}

association

{width table}
{style-mapping
{kerning

table}

info}

table}

table}

END;

Summary of the

Font Manager IV-45

Inside Macintosh
WidthTable

=

RECORD

tabData:
tabFont:

ARRAY[1..256]
Handle;

SExtra:

LONGINT;

style:
£ID:
fSize:
face:
device:
inNumer:
inDenom:

LONGINT;

INTEGER;

Point;
Point;
INTEGER;

houtput:

BOOLEAN;
INTEGER;

aSize:
tabSize:

INTEGER;
INTEGER

used

{ characters}
{horizontal factor

INTEGER;
INTEGER;
INTEGER;

character

to

widths}

build

{ characters}
{not used}

for

{horizontal factor for increasing
{ character widths}
{size of actual font used}
{total size of table}

PROCEDURE
PROCEDURE

FontMetrics
(VAR theMetrics:
FMetricRec) ;
SetFScaleDisable (fontScaleDisable:
BOOLEAN) ;

PROCEDURE

SetFractEnable

(fractEnable:

BOOLEAN);

[Not in ROM]

Assembly-Language Information
Constants
Font

types

propFont
prpFntH
prpFntw
prpFntHWw

- EQU
. BQU
- EQU
. EQU

$9000
$9001
$9002
$9003

;proportional
; with height

fixedFont

.EQU

SB000

;fixed-width

fxdFntH
fxdFntw
fxdFntHw

fontWid

. EQU
. EQU
. EQU

.EQU

SB001
SB002
$B003
SACBO

IV-46 Summary of the Font Manager

}

expanding

Routines

,

table}

table}

{actual
face produced}
{vertical
factor
for expanding

Byte;

hFactor:

vFactor:

END;

INTEGER;

handle;

record

{font size request}
{style
(face)
request}
{device requested}
{numerators of scaling factors}
{denominators of scaling factors}
{actual font family ID for table}
{family record used to build table}
{used fixed-point family widths}

INTEGER;

fHand:
usedFam:
aFace:
vOutput:

Fixed; {

{space extra used for
{extra due to style}
{font
family
ID}

INTEGER;

aFID:

OF

{font

.

‘

;

;

e

s

;

with

with

width

height

with

height

with

height

with

;font

width

width

font
table

table

&

width

tables

font

table

table

&

data

width

tables

}
}

The Font Manager
Font Metric Record Data Structure
ascent
descent
leading
widMax
wTabHandle

Ascent (word)
Descent (word)
Leading (word)
Maximum character width (word)
Handle to global width table (long)

Font Record (‘FONT ' or 'NFNT') Data Structure
fFontType
fFirstChar
fLastChar
fWidMax

Font type (word)
ASCII code of first character (word)
ASCII code of last character (word)
Maximum character width (word)

fNDescent
fFRectWidth
fFRectHeight

Negative of descent (word)
Width of font rectangle (word)
Height of font rectangle (word)

fAscent
fDescent
fLeading
fRowWords

Ascent (word)
Descent (word)
Leading (word)
Row width of bit image / 2 (word)

fKernMax

fOWTLoc

Negative of maximum character kern (word)

Offset to offset/width table (word)

Family Record (‘FOND"') Data Structure
fondFlags

Flags for family (word)

Ww

ASCII code of first character (word)
ASCII code of last character (word)
Maximum ascent expressed for 1 pt. font (word)
Maximum descent expressed for 1 pt. font (word)

a
z
=
he

fondFamID

Family ID number (word)

fondLeading

Maximum leading expressed for 1 pt. font (word)

fondFirst
fondLast
fondAscent
fondDescent

fondWidMax
fondWTabOff
fondKermOff
fondStylOff
fondProperty
fondIntl
fondAssoc
fondWidTab
fondStylTab
fondKerntab

Maximum widMax expressed for 1 pt. font (word)
Offset to width table (long)
Offset to kerning table (long)
Offset to style-mapping table (long)
Style property info (12 words)
Reserved (3 words)
Font association Table (variable length)
Optional character-width table (variable length)
Style-mapping table (variable length)
Kerning table (variable length)

Summary of the Font Manager IV-47

=

a

Inside Macintosh

Global Width Table Data Structure
widTabData
widTabFont
widthSExtra
widthStyle
widthFID
widthFSize
widthFace

widthDevice

inNumer
inDenom
widthAFID
widthFHand
widthUsedFam
widthA Face
widthVOutput
widthHOutput
widthV Factor
widthHFactor
widthASize
widTabSize

Character widths (1024 bytes)
Font handle used to build table (long)
Space extra used for table (long)
Extra due to style (long)
Font family ID (word)
Font size request (word)
Style (face) request (word)

Device requested (word)

Numerators of scaling factors (long)
Denominators of scaling factors (long)
Actual font family ID for table (word)
Font family handle for table (long)
_ Used fixed point family widths? (boolean)
Actual face produced (byte)
Not used (word)
Horizontal factor for increasing character widths (word)
Vertical scale output value (word)
Horizontal scale output value (word)
Actual size of actual font used (word)
Total size of table (word)

Global Variables
ApFont ID
FractEnable
IntlSpec
WidthListHand
WidthPtr
WidthTabHandle
SysFontFam

SysFontSiz
LastFOND

Font nuniber of application font (word)
Nonzero to enable fractional widths (byte)
International software installed if greater than 0 (long)
Handle to a list of handles to recently-used width tables
Pointer to global width table —
Handle to global width table
If nonzero, the font number to use for system font (byte)

If nonzero, the size of the system font (byte)
Handle to last family record used

IV-48 Summary of the Font Manager

6

THE WINDOW MANAGER

A new variation of the window definition function implements a feature known as window
zooming; a description of window zooming is found in chapter 1 of this volume.
If you’re using the standard document window, you can implement a zoom-window box
by specifying a window definition function with a resource ID of 0 and a variation code of
8 when you call either the NewWindow or GetNewWindow functions. Two fields in the
window record, dataHandle and spareFlag, are used only when variation code 8 is
specified (otherwise they’re not used).
DataHandle contains a handle to two rectangles that specify the standard and user states of
the window:
TYPE

WStateData =

RECORD;
userState:
Rect;
stdState: Rect
END;

If you wish, your application can access both states. You might want to provide initial
values for the user state. Or you might want to save and restore all windows to the same
State the next time your application is launched. To do this, you would save the two states
and determine which of the two is current. The next time the application is launched, you

would then create the window using the saved current state, and set the user and standard
states to their previous values, after the GetNewWindow or NewWindow call.

SpareFlag is TRUE if zooming has been requested (that is, if a variation code of 8 has been
specified).
If you create a custom window, you can give your window definition function any
variation code you wish. If you want to implement zooming in the custom window, you
must supply values for WStateData.
When there’s a mouse-down event in the zoom-window box and your application calls the
FindWindow function, the integer returned will be one of the following predefined

constants:
CONST

inZoomIn
inZoomOut

7;

{in

zoom

box

for

zooming

in}

8;

{in

zoom

box

for

zooming

out}

InZoomlIn and inZoomOut both indicate that the mouse button was pressed in the zoom-

window box of the window. FindWindow returns inZoomIn when the window is in the

standard state (and will be zoomed in), and inZoomOut when it’s in the user state (and will
be zoomed out).
If either of these constants are returned by FindWindow, call the TrackBox function

(described below) to handle the highlighting of the zoom-window box and to determine
whether the mouse is inside the box when the button is released. If TrackBox returns
TRUE, call the ZoomWindow procedure (described below) to resize the window
appropriately.

The Window Manager IV-49

AN

=

i}
Ou.
©

=

po)
=
ao)
ithe)

om .

Lame §

Inside Macintosh

Advanced programmers: Two additional constants have been defined for your window
definition function to return in response to a wHit message:.
CONST

wiInZoomIn
wInZoomOut

=
=

5;
6;

{in
{in

zoom
zoom

box
box

for
for

zooming
zooming

TrackBox (theWindow: WindowPtr;
INTEGER)
: BOOLEAN;

thePt:

in}
out}

WINDOW MANAGER ROUTINES
FUNCTION

Point;

partCode:

When there’s a mouse-down event in the zoom-window box of the Window,

the application

should call TrackBox with thePt equal to the point where the mouse button was pressed (in

global coordinates, as stored in the where field of the event record). The partCode
parameter contains the constant (either inZoomIn or inZoomOut) returned by FindWindow.
TrackBox keeps control until the mouse button is released; it highlights the zoom-window
box ini the same way as a window’s close box is highlighted. When the mouse button is
released, TrackBox unhighlights the zoom-window box and returns TRUE if the mouse is
inside the zoom-window box or FALSE if it’s outside the box (in which case the
application should do nothing).
PROCEDURE

ZoomWindow
(theWindow:
front: BOOLEAN) ;

WindowPtr;

partCode:

Call ZoomWindow after a call to TrackBox that returns TRUE.

INTEGER;

The partCode parameter

contairis the constant (either inZoomln or inZoomOut) returned by FindWindow. The
window will be zoomed either out or in, depending on the state of the window specified by
partCode. If the window is already in the state specified by partCode, ZoomWindow does
nothing. If the front parameter is TRUE, the window will be brought to the front;
otherwise, the window is left where it is. (This means a window can be zoomed without

necessarily becoming the active window.)

For best results, call the QuickDraw Htocedhiré EraseRect with the portRect field of
theWindow’s grafPort before calling ZoomWindow.
Warning:

Using the QuickDraw procedure SetPort, set thePort to the window’s

port before calling ZoomWindow.

Note: ZoomWindow is in no way tied to the TrackBox function and could just as
easily be called in response to a selection from a menu.

IV-50 Window Manager Routines

The Window Manager

SUMMARY OF THE WINDOW MANAGER
Constants
CONST

{

Additional

values

73
8;

inZoomin
inZoomOut

{

Values

returned

winZoomIn

returned

{in
{in

zoom
zoom

by

window

by

box
box

FindWindow

for
for

zooming
zooming

definition

}

in}
out}

function’s

=

5;

{in

zoom

box

for

zooming

in}

winZoomOut =

6;

{in

zoom

box

for

zooming

out}

hit

routine

}

Data Types
TYPE

WStateData

=

RECORD;
userState:
stdState:

Rect;
Rect

{user state}
{standard state}

END;

Routines
FUNCTION
PROCEDURE

TrackBox

(theWindow:

WindowPtr;

thePt:

ZoomWindow

INTEGER)
:
(theWindow:

BOOLEAN;
WindowPtr;

partCode:

BOOLEAN) ;

Point;

partCode:

INTEGER;

front:

Assembly-Lang uage Information

A

Constants
; Additional
inZoomiIn

inZoomoOut

values
. EQU

returned
7

-EQU

8

| 2
S

by FindWindow
jin

z;in

zoom

zoom

box

box

for
for

2

zooming
zooming

in

out

=

7

Law |

;

Values

wInZoomin

wInZoomOut

returned
.EQU

. EQU

by

window
5

6

definition
;in

sin

zoom

zoom

box

box

function’s
for

for

hit

zooming

zooming

routine
in

out

Summary of the Window Manager IV-51

Inside Macintosh

Window Record Data Structure
windowPort
windowKind
wVisible
wHilited

wGoAway
wZoom

structRgn
contRgn
updateRgn
windowDef

wDataHandle
wTitleHandle
wTitleWidth
wControlList
nextWindow
windowPic
wRefCon
windowSize

Window’s grafPort (portRec bytes)
Window class (word)
Nonzero if window is visible (byte)
Nonzero if window is highlighted (byte)
Nonzero if window has go-away region (byte)
Nonzero if window has a zoom-window box (byte)
Handle to structure region of window
Handle to content region of window
Handle to update region of window

Handle to window definition function

Handle to standard and user window states
Handle to window’s title (preceded by length)
Width of title in pixels (word)
Handle to window’s control list
Pointer to next window in window list
Picture handle for drawing window
Window’s reference value (long)
Size in bytes of window record

Window State Data Structure
userState
stdState

Window’s user state (rectangle; 8 bytes)
Window’s standard state (rectangle; 8 bytes)

IV-52 Summary of the Window Manager

7

THE CONTROL MANAGER

Two new routines, UpdtControl and Draw1Control, have been added to the Control
Manager. In addition, there’s a new control definition function that supports multiple lines
of text in controls.

CONTROL MANAGER ROUTINES
PROCEDURE

UpdtControl

(theWindow:

WindowPtr;

updateRgn:

RgnHandle);

UpdtControl is a faster version of the DrawControls procedure. Instead of drawing all of
the controls in theWindow, UpdtControl draws only the controls that are in the specified
update region. UpdtControl is called in response to an update event, and is usually
bracketed by calls to the Window Manager procedures BeginUpdate and EndUpdate.
UpdateRgn should be set to the visRgn of theWindow’s port (for more details, see the

BeginUpdate procedure in the Window Manager chapter).

Note: In general, controls are in a dialog box and are automatically drawn by the
DrawDialog procedure.
PROCEDURE

DrawlControl

(theControl:

ControlHandle) ;

Draw1Control draws the specified control if it’s visible within the window.

THE CONTROL DEFINITION FUNCTION
A new version of the control definition function (version 4 or greater) in the 128K ROM

allows buttons, check boxes, and radio buttons to have multiple lines of text in their titles.

When specifying the title with either NewControl or SetCTitle, simply separate the lines
with the ASCII character code $0D (carriage return). You can also use a version of the

Resource Editor that supports the 128K ROM to specify multiline titles.
Note:

This feature will work with the 64K ROM if the new version of the control

definition function is in the system resource file.

If the control is a button, each line is horizontally centered and separated from the
neighboring lines by the font’s leading. (Since the height of each line is equal to the ascent
plus descent plus leading of the font used, be sure to make the total height of the enclosing
rectangle greater than the number of lines times this height.)
If the control is a check box or a radio button, the text is left-justified and the check box or
button is vertically centered within the enclosing rectangle, cntrlRect.

The Control Definition Function IV-53

~]

2)
)
=}

*
ar}

©.
=)
|
&

re)

fas)
=

Inside Macintosh

SUMMARY OF THE CONTROL MANAGER
Routine
PROCEDURE
PROCEDURE

UpdtControl
DrawlControl

(theWindow:
WindowPtr;
updateRgn:
(theControl:
ControlHandle) ;

IV-54 Summary of the Control Manager

RgnHandle) ;

8

THE MENU MANAGER

The AddResMenu and InsertResMenu procedures have been modified to work with the
font family resource type (‘FOND’).

If you call either routine for a resource of type

‘FONT’, they first add all instances of type '"FOND' and then all instances of type ‘FONT’.

The Menu Manager ignores resources of type 'NFNT'. Both routines, before adding a
new item to the menu, first check to see that an item with the same name is not already in
the menu. If an item with the same name is already there, the new item is not added. This
prevents duplication and gives items of type 'FOND' precedence over items of type
‘FONT’.

AddResMenu and InsertResMenu both sort the items alphabetically as they’re placed in the
menu; the order of items already in the menu, however, is unaffected. Neither routine
enables the items.
Note: If the name of your desk accessory appears not to have been sorted and is
inserted at the end of the Apple menu, the name is missing the leading null character.
Two new routines, InsMenultem and DelMenultem, let you insert and delete individual

items from an existing menu.

Use of these routines is discouraged except in certain

situations where the user expects a menu to change (such as list of open windows).

Warning: Menu resources should never be marked as purgeable. If a Menu
Manager routine tries to access a menu that’s been purged, a system error (ID 84)
will occur.
Note:

In the 64K ROM version of the Menu Manager, if the user attempted to pull

down an empty menu (one with no items), an unsightly empty menu of arbitrary size
was displayed. In the 128K ROM version, the menu title is highlighted but the menu
is not pulled down at all.

MENU MANAGER ROUTINES
PROCEDURE

InsMenuItem
afterItem:

(theMenu:

INTEGER) ;

MenuHandle;

itemString:

Str255;

InsMenultem inserts an item or items into the given menu where specified by the afterItem

parameter. If afterItem is 0, the items are inserted before the first menu item; if it’s the item
number of an item in the menu, they’re inserted after that item; if it’s equal to or greater

than the last item number, they’re appended to the menu.

The contents of itemString

are parsed as in the AppendMenu procedure. Multiple items are

inserted in the reverse of their order in itemString.

OO

xcm
|
9

Menu Manager Routines IV-55

<oe)
|

m

To

fae)

lame |

Inside Macintosh
PROCEDURE

DelMenulItem

(theMenu:

MenuHandle;

item:

INTEGER)

;

DelMenultem deletes the specified item from the given menu.
Note: DelMenultem is intended for maintaining dynamic menus (such as a list of
open windows). It should not be used for disabling items; you should use
DisableItem instead.

THE MENU DEFINITION PROCEDURE
This section describes changes to the default menu definition procedure (MDEF'
resource Q); some of the information presented in this section is accessible only through
assembly language.
Note:

These features will work with the 64K ROM if the new menu definition

procedure is in the system resource file.
Variable Size Fonts

Menus are displayed in the system font. Since the system font and font size can now be

changed, the menu definition procedure calls the QuickDraw procedure GetFontInfo for the
system font to determine the height of menu items

scrolling Menus
The default menu definition procedure allows longer menus by implementing automatic
scrolling. If the entire menu cannot be drawn on screen, dragging the cursor below the last

displayed item will cause the items in the menu to scroll up. Similarly, if items have been
scrolled past the top of the menu, dragging the cursor into the highlighted portion of the
_ menu bar will cause the menu to scroll back down. The maximum number of items that
can be drawn on the standard Macintosh screen with this new menu definition function
is 19 (instead of 20).
Warning:

You should not disable any menu items in a menu containing more

than 31 items because the enableFlags field of the MenulnfoRec can only

handle 31 items.

SUMMARY OF THE MENU MANAGER
Routines
PROCEDURE

InsMenuItem

PROCEDURE

DelMenuItem

(theMenu:
MenuHandle;
afterItem:
INTEGER);
(theMenu:
MenuHandle;

IV-56 Summary of the Menu Manager

itemString:
item:

Str255;

INTEGER);

©

=

fas)

*

-

io

co.

=>

9

TEXTEDIT

Automatic scrolling of text (when the user is making a selection and drags the cursor out of
the view rectangle) is now supported by TextEdit.

To enable and disable automatic scrolling, call the procedure TEAutoView. TESelView

will, if automatic scrolling is enabled, automatically scroll the selection range into view.

TEPinScroll scrolls text within the view rectangle but stops when the last line comes into
view.
Note:

When enabled, automatic scrolling can occur in response to TESel View,

TEKey, TEPaste, TEDelete, and TESetSelect.

When used with the System file version 3.0 or later, TextEdit also automatically supports
the movement of the insertion point with the Macintosh Plus arrow keys; this is described
in chapter 1 of this volume.

Warning:

Command—arrow key combinations are not supported by TextEdit and

must be handled by your application.
your application.

Selection expansion must also be handled by

TEXTEDIT ROUTINES
PROCEDURE

TESelView

(hTE:

TEHandle) ;

If automatic scrolling has been enabled (by a call to TEAutoView, described below),
TESelView makes sure that the selection range is visible, scrolling it into the view rectangle
if necessary. If automatic scrolling is disabled, TESel View does nothing.
Note: The top left of the insertion is scrolled into view; if text is being displayed in a
rectangle that’s not tall enough, automatic scrolling could cause the text to jump up
and down at times.

PROCEDURE

TEPinScroll

(dh,dv:

INTEGER;

hTE:

TEHandle);

TEPinScroll is similar to TEScroll except that it stops scrolling when the last line scrolls
into the view rectangle.

PROCEDURE

TEAutoView

(auto:

BOOLEAN;

hTE:

TEHandle);

TEAutoView enables and disables automatic scrolling of text in the edit record specified by
hTe. If the auto parameter is FALSE, automatic scrolling is disabled and calling
TESelView has no effect.

TextEdit Routines

IV-57

Inside Macintosh

DEFAULT CLICK LOOP ROUTINE
TextEdit now installs a default click loop routine in the edit record that supports automatic
scrolling; you still need, however, to update the scroll bars. If automatic scrolling is
enabled, this routine checks to see if the mouse has been dragged out of the view rectangle;
if it has, the routine scrolls the text using TEPinScroll. The amount by which the text is

scrolled, whether horizontally or vertically, is determined by the lineHeight field of the edit

record.

SUMMARY

OF TEXTEDIT

Routines
PROCEDURE

TESelView

(hTE:

PROCEDURE
PROCEDURE

TEPinScroll
TEAutoView

(dh,dv:
INTEGER;
hTE:
TEHandle);
(auto:
BOOLEAN;
hTE:
TEHandle) ;

IV-58

Summary of TextEdit

TEHandle)>;

10

—"
S

THE DIALOG MANAGER

=)

—_

i>)
Tt

Four routines—HideDItem, ShowDItem, FindDItem, and UpdtDialog—have been added

to the Dialog Manager.

|

Advanced programmers: The standard filterProc function called by ModalDialog now
returns 1 in itemHit and a function result of TRUE only if the first item is enabled.
Automatic scrolling is supported in editText items.

DIALOG MANAGER ROUTINES
PROCEDURE

HideDItem

(theDialog:

DialogPtr;

itemNo:

INTEGER) ;

HideDItem hides the item numbered itemNo in the given dialog’s item list by giving the
item a display rectangle that’s off the screen. (Specifically, if the left coordinate of the
item’s display rectangle is less than 8192, ShowDItem adds 16384 to both the left and right
coordinates the rectangle.) If the item is already hidden (that is, if the left coordinate is

greater than 8192), HideDItem does nothing,

HideDItem calls the EraseRect procedure on the item’s enclosing rectangle and adds the
rectangle that contained the item (not necessarily the item’s display rectangle) to the update
region. If the specified item is an active editText item, the item is first deactivated (by
calling TEDeactivate).
Note:

If you have items that are close to each other, be aware that the Dialog

Manager draws outside of the enclosing rectangle by 3 pixels for editText items and

by 4 pixels for a default button.

An item that’s been hidden by HideDItem can be redisplayed by the ShowDItem procedure.
Note: To create a hidden item in a dialog item list, simply add 16384 to the left and
right coordinates of the display rectangle.
PROCEDURE

ShowDiItem

pa)

(theDialog:

DialogPtr;

itemNo:

INTEGER) ;

ShowDItem redisplays the item numbered itemNo, previously hidden by HideDItem, by
giving the item the display rectangle it had prior to the HideDItem call. (Specifically, if the
left coordinate of the item’s display rectangle is greater than 8192, ShowDItem subtracts
16384 from both the left and right coordinates the rectangle.) If the item is already visible

(that is, if the left coordinate is less than 8192), ShowDItem does nothing.

ShowDItem adds the rectangle that contained the item (not necessarily the item’s

display

rectangle) to the update region so that it will be drawn. If the item becomes the only
editText item, ShowDItem activates it (by calling TEActivate).

Dialog Manager Routines IV-59

po)
15]
fae)
ae |

Inside Macintosh
FUNCTION

FindDItem

(theDialog:

DialogPtr;

thePt:

Point)

:

INTEGER;

FindDItem returns the item number of the item containing the point specified, in local

coordinates, by thePt. If the point doesn’t lie within the item’s rectangle, FindDItem
returns —1. If there are overlapping items, it returns the item number of the first item in the
list containing the point. FindDItem is useful for changing the cursor when it’s over a
particular item.
Note:

FindDItem will return the item number of disabled items as well.

PROCEDURE

UpdtDialog
(theDialog:
RgnHandle) ;

DialogPtr;

updateRgn:

UpdtDialog is a faster version of the DrawDialog procedure. Instead of drawing the entire
contents of the given dialog box, UpdtDialog draws only the items that are in a specified
update region. UpdtDialog is called in response to an update event, and is usually
bracketed by calls to the Window Manager procedures BeginUpdate and EndUpdate.
UpdateRgn should be set to the visRgn of theWindow’s port.

BeginUpdate procedure in chapter 9 of Volume I.)

(For more details, see the

SUMMARY OF THE DIALOG MANAGER
Routines
PROCEDURE

HideDItem

(theDialog:

DialogPtr;

itemNo:

FUNCTION
PROCEDURE

FindDItem
UpdtDialog

(theDialog:
(theDialog:

DialogPtr;
DialogPtr;

thePt: Point)
: INTEGER;
updateRgn:
RgnHandle) ;

PROCEDURE

ShowDItem

(theDialog:

IV-60 Summary of the Dialog Manager

DialogPtr;

itemNo:

INTEGER);

INTEGER) ;

11.

THE SCRAP MANAGER

The desk scrap is now written on the system startup volume (that is, the volume that
contains the currently open System file) rather than the default volume. With hierarchical
volumes, the scrap file is placed in the folder containing the currently open System file and
Finder.
In addition, the GetScrap and PutScrap functions will never return the result code

noScrapErr; if the scrap has not been initialized, the ZeroScrap function will be called. The
InfoScrap function also calls ZeroScrap if the scrap is uninitialized.

pom
poms

Fp)

(a=)

oe |
poe)

=)

poe
=}
poe)
fe
fae)
—

The Scrap Manager IV-61

Inside Macintosh

1V-62

12

TOOLBOX UTILITIES

A new fixed-point type, Fract, has been defined.

Useful in graphics software, the Fract

type allows accurate representation of small numbers (between —2 and 2). Like the type

Fixed, a Fract number is a 32-bit quantity, but its implicit binary point is to the right of bit
30 of the number; that is, a Fract number has 2 integer bits and 30 fraction bits. As with
the type Fixed, a number is negated by taking its two’s complement.

Thus Fract values

range between —2 and 2-(2-°°), inclusive. Figure 1 shows the weight of each binary place
of a Fract number.
15

2

|

1]5

a4

2

-12|

2

,-13|

0

2

,-14

high-order word

S
x

S

15
9718

716

ol

,

7°28

7729

0

=

2730

*

low-order word

Figure 1. A Fract Number
In the 128K ROM, ail fixed-point functions (that is, functions with Fixed or Fract
arguments or results) handle boundary cases uniformly. Results are rounded by adding
half a unit in magnitude in the last place of the stored precision and then chopping toward
zero. Overflows are set to the maximum representable value with the correct sign (typically

$80000000 for negative results and $7FFFFFFF for positive results). Division by zero in
any of the four divide routines results in $80000000 if the numerator is negative and

$7FFFFFFF otherwise; thus the special case 0/0 yields $7 FFFFFFF.

Warning: Some applications may depend on spurious values returned by the 64K
ROM: FixRatio and FixMul overflowed unpredictably, FixRatio returned $80000001
when a negative number was divided by 0, and FixRound malfunctioned with negative
arguments.

TOOLBOX UTILITY ROUTINES
The 128K ROM version of the Toolbox Utilities supports fifteen new fixed-point

functions. Pascal typing will allow any of the operand combinations suggested here
without redefinition of the function.

Toolbox Utility Routines IV-63

Inside Macintosh

Arithmetic Operations
FUNCTION

FracMul

(x,y:

Fract)

>:

Fract;

FracMul returns x * y. Note that FracMul effects “type * Fract —>
Fract
LONGINT

Fract

'

Fract
Fract

—>
—>

Fract
LONGINT

*
7

Fract
Fixed

—>
—>

Fixed
Fixed

*

Fixed
Fract

FUNCTION

*
*

FixDiv

LONGINT

(x,y:

Fixed)

—>

:

LONGINT

Fixed;

FixDiv returns x / y. Note that FixDiv effects “type / type —>

“type / Fixed —>

type”:

Fixed
LONGINT
Fract
LONGINT
Fract

/
/
/
/
/

FUNCTION

FracDiv

Fixed
LONGINT
Fract
Fixed
Fixed
(x,y:

Fract)

—>
—>
—>
—>
—>
:

FUNCTION

/
/
/
/
/

FracSqrt

Fract
LONGINT
Fixed
Fract
Fract
(x:

Fract)

:

Fixed” and

Fixed
Fixed
Fixed
LONGINT
Fract

Fract;

FracDiv returns x / y. Note that FracDiv effects “type / type —>
“type /Fract —> type”:
Fract
LONGINT
Fixed
LONGINT
Fixed

type”:

—>
—>
—>
—>
—>

Fract” and

Fract
Fract
Fract
LONGINT
Fixed

Fract;

FracSqrt returns the square root of x, with x interpreted as unsigned in the range 0 through
42-30), inclusive:

That is, bit 15 in Figure 1 has weight 2 rather than —2.

is unsigned in the range 0 through 2, inclusive.
FUNCTION

FUNCTION

FracCos

FracSin

(x:

(x:

Fixed)

Fixed)

:
>:

The result, too,

Fract;
Fract;

FracCos and FracSin return the cosine and sine of their radian arguments, respectively.
The hexadecimal value 0.C910 (which is FixATan2(1,1)) is the approximation to 1/4 used
for argument reduction. Thus, FracCos and FracSin are nearly periodic, but with period
2*P instead of 2*7, where P=3.1416015625

IV-64

Toolbox Utilities Routines

and 7, of course, is 3.14159265....

Toolbox Utilities

FUNCTION

FixATan2

(x,y:

LONGINT)

:

Fixed;

FixATan2 returns the arctangent of y / x in radians. Note that FixATan2 effects
“arctan(type / type) —> Fixed”:
arctan(LONGINT / LONGINT)

—>

arctan(Fixed / Fixed)
arctan(Fract/ Fract)

—>

—_—>

Fixed
Fixed
Fixed

Conversion Functions
FUNCTION

FUNCTION
FUNCTION
FUNCTION

Long2Fix

Fix2Long
Fix2Frac
Frac2Fix

(x:

LONGINT)

(x:
(x:
(x:

Fixed)
Fixed)
Fract)

:
:

: Fixed;
LONGINT ;
Fract;
Fixed;
—

bn

Long2Fix, Fix2Long, Fix2Frac, and Frac2Fix convert between fixed-point types.

—

>)

FUNCTION
FUNCTION
FUNCTION
FUNCTION

Fix2X
X2Fix
Frac2X
X2Frac

(x:
(x:
(x:
(x:

=

Fixed)
: Extended;
Extended)
Fixed;
Fract)
>; Extended;
Extended)
: Fract;

oo

om)
*

o-_=

Fix2X, X2Fix, Frac2X, and X2Frac convert between Fixed and Fract and the Extended

floating-point type. These functions do not set floating-point exception flags.

Examples
Examples of the use of these fixed-point functions are provided below; all numbers are
decimal unless otherwise noted.

Result

Comment

FixDiv
FracDiv
FracMul
FracSgqrt
FracSin
FracCos

(X2Fix(1.95),
X2Fix(1.30))
(X2Frac(1.95),
X2Frac(1.30))
(X2Frac(1.50),
X2Frac(1.30))
(X2Frac(1.96))
(X2Fix(3.1416015625) )
(X2Fix(3.1416015625) )

$00018000
$60000000
$7CCCCCCD
$5999999A
$00000000
$C0000000

Fix2Long
Fix2Frac

(X2Fix(1.75))
(X2Fix(1.75))

$00000002
$70000000

FixATan2

(X2Fix(1.00),

X2Fix(1.00) )

$0000C910

(X2Fix(-1.95),

X2Fix(1.30))

SFFFE8000

Frac2Fix
FixDiv

FracDiv

FracMul
FracSin
FracCos

Fix2Long

(X2Frac(1.75))

(X2Frac(-1.95),

(X2Frac(-1.50),
X2Frac(1.30))
(X2Fix(-3.1416015625) )
(X2Fix(-3.1416015625) )
(X2Fix(-1.75))

Fix2Frac

(X2Fix(-1.75))

FixATan2

(X2Fix(-1.00),

Frac2Fix

X2Frac(1.30))

(X2Frac(-1.75))

$0001C000

$A0000000

$83333333
$00000000
$c0000000

SFFFFFFFE

$90000000

X2Fix(-1.00))

SFFFE4000

SFFFDA4DO

OrPPPEH

Function

01.10 bin
ae)
01.10 bin
pe)
9 5 rounded
4 rounded

-1
2
1.75

01.11

bin

1.75
01.11 bin
0.C910
hex =
X2Fix
(1/4)
-1.5
-1.5
-1.95
rounded
0
-1
-2
-1.75
-1.75
-3*X2Fix(m/4)
=
3*0.C910
hex

Toolbox Utility Routines IV-65

fe*)

1? 2)

Inside Macintosh

SUMMARY OF THE TOOLBOX UTILITIES
Routines
Arithmetic Operations
FUNCTION

FracMul

(x,y

FracDiv

(x,y:

FracCos
FracSin

(x:
(x:

FUNCTION

FixDiv

FUNCTION

FracSqrt

FUNCTION

FUNCTION
FUNCTION

FUNCTION

FixATan2

(x,y:
(x:

(x,y:

:

Fract)

:

Fixed)
Fract)

Fract)

Fixed)
Fixed)

Fract;

: Fixed;
:

Fract;

: Fract;

: Fract;
: Fract;

LONGINT)

: Fixed;

Conversion Functions
FUNCTION

Long2Fix

(x:

FUNCTION
FUNCTION
FUNCTION

Fix2Long
Fix2Frac
Frac2Fix

(x:
(x:
(x:

FUNCTION
FUNCTION
FUNCTION

X2Fix
Frac2xX
X2Frac

(x:
(x:
(x:

FUNCTION

Fix2X

(x:

LONGINT)

Fixed)
Fixed)
Fract)

Fixed)

:
:
:

:

:

Fixed;

LONGINT;
Fract;
Fixed;

Extended;

Extended)
: Fixed;
Fract)
: Extended;
Extended)
: Fract;

IV-66 Summary of the Toolbox Utilities

13.

THE PACKAGE MANAGER

The following Macintosh packages, previously stored only in the system resource file, are
now also found in the 128K ROM:

= The Binary-Decimal Conversion Package, for converting integers to decimal strings
and vice versa.
= The Floating-Point Arithmetic Package, which supports extended-precision arithmetic
according to IEEE Standard 754.
u The Transcendental Functions Package, which contains trigonometric, logarithmic,
exponential, and financial functions, as well as a random number generator.
For compatibility with the 64K ROM, the above resources are still stored in the system
resource file. The system resource file contains the following additional packages as well:
a The List Manager Package, for creating, displaying, and manipulating lists.

u The Standard File Package, for presenting the standard user interface when a file is to
be saved or opened.

a The Disk Initialization Package, for initializing and naming new disks.
—

a The International Utilities Package, for accessing country-dependent information such
as the formats for numbers, currency, dates, and times.

Packages have the resource type 'PACK’ and the following resource IDs:
|

CONST

listMgr

=

stdFile

=

dskInit

f1lPoint
trFunct
intUtil
bdConv

0;

{List

3;

{Standard

=

2;

=
=
=
=

4;
5;
6;
7;

{Disk

Manager}

4
c.

poe)

ys

=

=

Initialization}

2

File}

{Floating-Point Arithmetic}
{Transcendental Functions}
{International Utilities}
{Binary-Decimal Conversion}

The Package Manager has been extended to allow for eight additional packages. All

packages are reserved for use by Apple.

The Package Manager IV-67

-

Inside Macintosh

SUMMARY OF THE PACKAGE MANAGER
Constants
CONST

{

Resource

IDs
©

listMgr

for

~e

Me

Me

Re

Ve

WN
UB
WTA

dskInit
stdFile
£f1Point
trFunct
intUtil
bdConv

packages
{List
{Disk

}

Manager}
Initialization}

{Standard

File}

{Floating-Point Arithmetic}
{Transcendental Functions}
{International Utilities}
{Binary-Decimal Conversion}

Assembly-Language Information
Constants

listMgr
dskInit
stdFile
flPoint
trFunct
intutil

bdConv

IDs

for

packages

. EQU
- EQU
- EQU
- EQU
- EQU
. EQU
- EQU

©

Resource

WD
UP
Ion

;

;List
;Disk

Manager
Initialization

;Standard

File

;Floating-Point

;Transcendental

Arithmetic
Functions

;International Utilities
;Binary-Decimal Conversion

Trap Macros for Packages
List Manager

Disk Initialization

Standard File
Floating-Point Arithmetic

Transcendental Functions
International Utilities

Binary-Decimal Conversion

_Pack0O

_Pack2
_Pack3
_Pack4

_Pack5

_Pack6
_Pack7

IV-68 Summary of the Package Manager

(synonym:

(synonym:

_FP68K)

_Elems68K)

14

THE BINARY-DECIMAL CONVERSION PACKAGE

Three new routines have been added to the Binary-Decimal Conversion Package.

These

routines supplement the Floating-Point Arithmetic and Transcendental Functions Packages
in providing the the Standard Apple Numeric Environment (SANE) for the Macintosh.
Detailed documentation for these new routines is included with the rest of the SANE
documentation in the Apple Numerics Manual—in particular, see the chapter

“Conversions” in Part I and the three chapters “Conversions”, “Numeric Scanner and
Formatter”’, and “Examples” in Part III.

The new routines, two numeric scanners and a numeric formatter, are intended for
programmers with special needs beyond what their development language provides. For
example, developers of programming languages can use these routines to implement the
floating-point I/O routines—such as read and write for Pascal or scanf and printf for
C—that are appropriate for their particular languages. The scanners can be used for
scanning numbers embedded in text and for numbers received character by character. The
scanners differ only in that one accepts a pointer to a Pascal strings (with an initial length
byte) as input, while the other accepts a pointer to the first character of a character stream.

The scanners convert ASCII string representations of numbers into SANE decimal records.
The formatter converts SANE decimal records into ASCII string representations. The
Floating-Point Arithmetic Package converts between this decimal record format and the
SANE binary data formats.
The three routines handle the usual number representations, like —1.234 and 5e—7,

throughout the range and precision of the extended data format. They also handle the

special NaN, infinity, and signed-zero representations specified by the IEEE Floating-Point

Standard.

="
i

i
=}
poe)
~

‘<

o

ae)

©.

=
—-

The Binary-Decimal Conversion Package IV-69

Inside Macintosh

IV-70

15

THE STANDARD FILE PACKAGE

The Standard File Package has been modified to work with the hierarchical file system.

(This chapter assumes some familiarity with the new material presented in chapter 19 of
this volume.) Since a volume’s files are no longer necessarily contained in a single flat

directory, the Standard File Package must provide some way for the user to select a file

that’s contained in a folder (or subdirectory). It must also provide the user with a way of

indicating the directory into which a particular file should be saved.

The dialog box displayed in response to the SFGetFile procedure shows the names of
folders (if any) as well as files. Files and folders are distinguished by miniature icons
preceding their names. Notice that there are two types of mini-icons for files—one for
applications and another for documents. Figure 1 shows the files and folders contained on
a sample desktop.

<—

(

the

disk

apps

D checklist

© im

O) romance —
(C) serious things
L

|

=<

the disk

L

fject
the

|

(_

Open

h |

(

special
status

C System Folder

2 utilities

S

(_ Cancel}

Figure 1. Open Dialog (at the Desktop Level)
To view the files and folders contained in a particular folder, the user must open the folder
by clicking it and then clicking the Open button, or by double-clicking on the folder name;
this causes the contents of the folder to be displayed. Figure 2 shows the contents of the
sample folder special.

poe,
in
N
>
peu)
=}
Q.
pou)
~~

o.

=

oO

\

The Standard File Package IV-71

Inside Macintosh

a

special

=the

D glossy
D leftovers

ed

disk

(Eject)

D threat

a

(

tive]

(

Open

hk}

«6 L_ Cancel)

Figure 2. Open Dialog (at a Folder Level)
A current directory button above the list shows the name of the directory whose files and
folders are displayed in the list below. If the contents of the desktop (or root directory) are
being displayed, the button will show the name of the volume next to either a 3 1/2-inch
disk mini-icon or a hard disk mini-icon (as in Figure 1). If the contents of a particular
folder (or subdirectory) are being displayed, the button will show the name of that folder
next to an open folder mini-icon (as in Figure 2 for instance).

Assembly-language note: The global variable SFSaveDisk always contains the
negative of the volume reference number (never a working directory reference
number) of the volume to use. If the hierarchical version of the File Manager is
running, the global variable CurDirStore contains the directory ID of whatever
directory (including the root) was last opened (regardless of whether a document was
actually opened or saved). With the 64K ROM version of the File Manager,
CurDirStore is not needed and is set to 0.
The current directory button provides a way of moving back up through the hierarchical
directory structure of a volume. If the user is at the level of a particular folder (or
subdirectory), clicking on the button causes a list to pop down. This list gives the path
from the current directory back up to the root directory. The rules for displaying and
selecting items from this “pop down” list are identical to those for items ina menu. To
change levels, select the desired folder and the files and folders at that level will be
displayed.
When the user chooses Save As, or Save when the document is untitled, the SFPutFile

dialog box contains a list of files and folders similar to the list displayed in response to the
Open command. This allows the user to specify the directory into which the file should be
placed. A current directory button above the list lets the user move about in the hierarchical
structure. File names in the list are dimmed (but displayed, so that the user can see what
other files are in the directory). Figure 3 shows an example.

IV-72

The Standard File Package

The Standard File Package

<— the disk
@—

(1 apps

eS cheeks?

the disk

[ Eject |

( im
PS preface
(7 romance

(

tive

|

( serious things

Save document as:

(| Save h}

(Cancel }

Figure 3. Save Dialog Box (at the Desktop Level)
In both dialog boxes, the Drive, Eject, and Open/Save buttons function as they always
have, although their positions have changed. The Save button is always dimmed if the
current volume is locked.
Note: No new buttons have been added, so programmers need not worry about
interference with controls they’ve added. The new dialog boxes, however, are larger
than the old boxes; the Standard File Package does its best to position nonstandard

dialogs in a visible and pleasing position. (Additional details are provided below in
the section “Creating Your Own Dialog Box”’.)

When the user dismisses the dialog, whether by Cancel or Save or Open, the directory
currently displayed is set to be the working directory (in other words, a call is made to the
File Manager function OpenWD).

USING THE STANDARD FILE PACKAGE
No new routines have been added to the Standard File Package. Applications that use the
Standard File Package properly need no modification to operate on machines equipped with
the 128K ROM. The specification of a directory in the SFGetFile and SFPutFile

procedures is transparent, due to the fact that working directory reference numbers can

always be used in place of volume reference numbers. (The relationship between volume
reference numbers and working directory reference numbers is described in detail in the
File Manager chapter.) If the user specifies that a given file be opened from or saved to a
particular subdirectory, the vVRefNum field of the reply record you pass with these routines
will be filled with a working directory reference number instead of a volume reference
number.
Warning: Programmers who have written their own “standard file” routines or who
rely on SFReply.vRefNum being a volume reference number may find that their
applications are not compatible with the 128K ROM version of the File Manager.

Using the Standard File Package IV-73

p—_

ur-

N
-

pee)

|
Q.
pe)
=

joe

=
o

Inside Macintosh

Using the Keyboard
The Standard File Package lets you use a variety of keyboard keys to respond to its
dialogs. The following special keys (or key sequences) are defined:
Key

Sequence

Action

Up Arrow

Scrolls up (backward) through displayed list

Command—Up Arrow
Command—Down Arrow
Command-Shift—1
Command-Shift—2
Tab
Return
Enter

Closes the current directory
ens the selected directory
Ejects disk in internal drive
Ejects disk in external drive
Equivalent to Drive button
Equivalent to either Open or Save button
Same as Return

Down Arrow

Scrolls down (forward) through displayed list

Note: The Up Arrow and Down Arrow keys are available on the standard
Macintosh Plus keyboard, and on the optional numeric keypad for the Macintosh

128K and 512K, as well as on the Macintosh XL keypad. (See chapter 1 of this

volume for details on using the arrow keys.) In addition, with the SFGetFile dialog
the user can type characters to locate files in the list; each time a character is typed,

the list selects and displays the first file whose initial character matches the typed
character.

CREATING YOUR OWN DIALOG BOX
This section is for advanced programmers who want to create their own dialog boxes rather
than use the standard SFPutFile and SFGetFile dialogs.
Warning:
dialogs.

Future compatibility is not guaranteed if you don’t use the standard

The addition of the file name list to the SFPutFile dialog, as well as the addition of current
directory buttons to both SFPutFile and SFGetFile, requires that the dialog boxes for each
call be made larger and the items in the box moved down. Although new dialog templates

and item lists are provided, the Standard File Package also needs an algorithm for

transforming old or nonstandard dialog templates and item lists.

To maintain compatibility with existing applications, the Standard File Package uses only
the existing dialog items. In SFPutFile, a userltem for the new file name list replaces the
dotted line in item number 8. In SFGetFile, the scroll bar userltem in item number 8 is no
longer used.

For both SFPutFile and SFGetFile, the information for the current directory

button and the scroll bars is maintained internally.

The Standard File Package determines if a dialog needs to be transformed by looking at the
width of item number 8 (the dotted line or scroll bar) as specified in the item’s rectangle. If
the width of item number 8 specifies either a dotted line (a width of 1) or a scroll bar (a
width of 16), the dialog will be transformed.

IV-74 Creating Your Own Dialog Box

The Standard File Package
Note: If a dialog needs to be transformed, the box is enlarged to make room for
both the scrolling list and the current directory button. All of the items are moved
down to their original position relative to the bottom of the box, and the scrolling list
and current directory button are added. The dialog is then centered on the screen. If
it overlaps the menu bar, it’s moved down. If it extends below or to the right of the

screen, it’s repositioned to make the entire dialog visible. In the case of certain

unusual dialogs, the bottom of the dialog may not be visible.

To create nonstandard dialogs that will not be transformed (in other words, ones in which
you leave room for the list and current directory button), simply set item number 8 to the
desired size and location of your file name list, including scroll bars (for SFPutFile), and
set item number 8 to have a width other than 16 (for SFGetFile). The scroll bar is placed
within the specified file name list’s rectangle.

The DigHook Function
In the old Standard File Package, a dlgHook routine could not accurately monitor what file
was being opened, since it could not detect a double-click.

In the new Standard File

Package, double-clicks on files are interpreted as clicks on the Open button (item
number 1), allowing the dlgHook to intercept files to be opened.

With folders, however,

both clicks on the Open button and double-clicks are passed to the hook as “fake” item
number 103.
A new fake item number 102 is generated by a click in the current directory button; it

causes the file list to be pulled down and tracked.

To redisplay the file list in GetFile (which you might do if your dialog box contains radio
buttons that let you choose different file types to be displayed), change item number 100 (a
null event) into item number 101 (which means redisplay the list) from within the dialog

hook.

Note: Disk-inserted events are handled internally; they are not (and never have
been) returned as “fake” item number 100. Item number 100 is returned only when

no event has taken place.

Before the dlgHook routine is called, information for the selected file or folder is stuffed in

the reply record (which can be examined on null events). If no file or folder is selected,
fName and fType are both NIL. If a file is selected, {Name will not be NIL and will
contain the file name.

If a folder is selected, [Type will not be NIL and will contain the

dirID. This is done before the dialog hook is called, regardless of which event is being
returned.

—_"

wa.

MN
~~

peu]

=}
jae
pee)
=

ou

az,

oD

Creating Your Own Dialog Box IV-75

Inside Macintosh

Three of the new Standard File Package alerts display an OK button instead of a Cancel
button:
Alert

Resource

Disk not found

—3994

Locked disk

—3997

System error

ID

—3995

Also, the text of the alert number —3994 (previously “Can’t find that disk.”’) has been
changed to “Bad character in name, or can’t find that disk.” This reflects the fact that this
alert is generated if there’s a colon in the name.
With nonhierarchical volumes, SFGetFile passes the fileFilter function the file information
it gets by calling the File Manager function GetFileInfo. With hierarchical volumes, it gets
this information from the GetCatInfo function. SFPutFile does not support a fileFilter
function.

SUMMARY OF THE STANDARD FILE PACKAGE
Variables

CurDirStore

SFSaveDisk

Directory ID of directory last opened (long)

Negative of volume reference number (word)

IV-76 Summary of the Standard File Package

16

THE MEMORY MANAGER

Many existing Memory Manager routines have been improved; most of these improvements
are transparent to the programmer.

SetHandleSize is smarter about finding free space below, as well as above, the relocatable
block.
Routines have been provided for the setting and clearing of handle flags.

MEMORY MANAGER

ROUTINES

Two Memory Manager routines—MaxApplZone and MoveHHi—that were not in the 64K
ROM (but were available in the Lisa Pascal interfaces) have been added to the 128K ROM.
Assembly-language note:
MoveHH1 is as follows:

The calling information for MaxApplZone and

Trap macro

_MaxApplZone

On exit

DO: result code (word)

Trap macro

_MoveHHi

On entry

AO: h (handle)

On exit

DO:

FUNCTION

MaxBlock

result code (word)

:

LONGINT;

Trap macro

_MaxBlock
_MaxBlock ,SYS

On exit

DO:

(applies to system heap)

function result (word)

MaxBlock returns the maximum contiguous space in bytes that could be obtained by
compacting the current zone (without actually doing the compaction).
—"
ON

=

ae)

=

i)
=
et

<

Memory Manager Routines [V-77

&
~
po)
v2
fae)
Law

|

Inside Macintosh
PROCEDURE

PurgeSpace

Trap macro
On exit

(VAR

total,contig:

_PurgeSpace
__PurgeSpace SYS

LONGINT) ;

(applies to system heap)

AO: contig (long word)

DO: total (long word)

PurgeSpace returns in total the total amount of space in bytes that could be obtained by a
general purge (without actually doing the purge); this amount includes space that is already
free. The maximum contiguous space in bytes (including already free space) that could be
obtained by a purge is returned in contig.
FUNCTION

StackSpace

: LONGINT;

Trap macro

_StackSpace

On exit

DO: function result (word)

StackSpace returns the current amount of stack space between the current stack pointer and
the application heap (at the instant of return from the trap).
Advanced Routine
FUNCTION

NewEmptyHandle

:

Handle;

Trap macro

_NewEmptyHandle

On exit

AO: function result (handle)
DO: result code (word)

_NewEmptyHandle ,SYS

(applies to system heap)

NewEmptyHandle is similar in function to NewHandle except that it does not allocate any
space; the handle returned is empty (in other words, it points to a NIL master pointer).
NewEmptyHandle is used extensively by the Resource Manager; you may not need to use
it.

Properties of Relocatable Blocks
The master pointer associated with each handle contains flags for use by the Memory
Manager. Routines are provided for setting and clearing each of these flags, as well as for
saving and restoring the entire byte.

IV-78 Memory Manager Routines

The Memory Manager
Warning:

Failure to use these routines virtually guarantees incompatibility with

future versions of the Macintosh.

You should not set and clear these flags directly.

The HLock and HUnlock procedures lock and unlock a given relocatable block by setting

and clearing the lock flag. The HPurge and HNoPurge mark a given relocatable block as

purgeable or unpurgeable by setting and clearing the purge flag.

A third flag, the resource flag, is used internally by the Resource Manager. The HSetRBit
and HClrRBit procedures set and clear this flag.

The HSetState and HGetState routines let you save and restore the state of the flags byte.
PROCEDURE

HSetRBit

(h:

Handle);

Trap macro

_HSetRBit

On entry

AO: h (handle)

On exit

DO: result code (word)

HSetRBit sets the resource flag of a relocatable block’s master pointer.
PROCEDURE

HClrRBit

(h:

Handle);

Trap macro

_HCIrRBit

On entry

AO: h (handle)

On exit

DO: result code (word)

HClIrRBit clears the resource flag of a relocatable block’s master pointer.
FUNCTION

HGetState

(h:

Handle)

Trap macro

_HGetState

On entry

AO: h (handle)

On exit

DO: flags (byte)

:

SignedByte;

HGetState returns the byte that contains the flags of the master pointer for the given handle;
it’s used in conjunction with HSetState to save and restore the state of the flags contained in
this byte. You can save this byte, change the state of any of the flags (using the routines

described above), and then restore their original state by passing the byte back to the

HSetState procedure (described below).

—
om

<

as)

=|

©

=
tet

=

pew)

Memory Manager Routines IV-79

|

f

Tv?

fas)

Lene §

Inside Macintosh
PROCEDURE

HSetState

(h:

Handle;

Trap macro

_HSetState

On entry

AO: h (handle)
DO: flags (byte)

On exit

DO: result code (word)

flags:

SignedByte) ;

HSetState is used in conjunction with HGetState; it sets the byte that contains the flags of
the master pointer for the given handle to the byte specified by flags.

ERROR REPORTING
All Memory Manager routines (including the RecoverHandle function) return a result code
that you can examine by calling the MemError function.
Assembly-language note:
in register DO.

The trap _RecoverHandle doesn’t return a result code

The result code of the most recent call, however, is always stored in

the global variable MemErr.

IV-80 Error Reporting

The Memory Manager

SUMMARY OF THE MEMORY MANAGER
Constants
CONST

{

Result

codes

}

memROZErr

=

-99;

{operation

on

a

read-only

zone}

Routines
FUNCTION

MaxBlock

PROCEDURE

HSetRBit

PROCEDURE
FUNCTION
FUNCTION

:

PurgeSpace
StackSpace
:
NewEmptyHandle

PROCEDURE
FUNCTION
PROCEDURE

HClrRBit
HGetState
HSetState

LONGINT;

:

(VAR total,contig:
LONGINT;
Handle;
(h:

(h:
(h:
(h:

LONGINT);

Handle);

Handle) ;
Handle)
: SignedByte;
Handle;
flags:
SignedByte) ;

Assembly-Language Information
Constants
;

Result

codes

memROZErr

-EQU

-99

j;operation on a read-only

zone

Routines
Trap macro

On entry

_MaxApplZone
_MoveHHi

On exit
DO: result code (word)

AO: h (handle)

DO: result code (word)

_MaxBlock

DO:

function result (word)

_PurgeSpace

AO: contig (long)
DO: total (long)

_StackSpace

DO:

_NewEmptyHandle

AO: function result (word)

function result (word)
—_"
ON

<

fae)

=|

©
baer
Catt

<

Summary of the Memory Manager IV-&1

po)
=}
pe)
vo
ae]

Lew §

Inside Macintosh

Trap macro

On entry

On exit

_HSetRBit

AO: h (handle)

DO: result code (word)

_HCIRBit

AO: h (handle)

DO: result code (word)

_HGetState

AO: h (handle)

DO: function result (byte)

_HSetState

AO: h (handle)
DO: flags (byte)

DO: result code (word)

Variables
MemErr

Current value of MemError (word)

IV-82 Summary of the Memory Manager

—_
~~]

N

fae)
v2

=

fas)

|

-

17

=

THE SEGMENT LOADER

c

pa)

2.
Cc
=

Advanced programmers: The LoadSeg procedure has been modified to help reduce heap
fragmentation. If the code segment to be loaded is unlocked (that is, if it’s not in memory

and its resLocked attribute is clear, or if it is in memory and is unlocked), LoadSeg calls the

Memory Manager procedure MoveHHi to move the segment toward the top of the current
eap zone.

To maintain compatibility with the 64K ROM, your code segments should be locked in the

resource file. They will, however, be unlocked when they’re unloaded and may float up in

the heap; subsequent loading may then cause heap fragmentation.

If your application will never run on a 64K ROM machine, all segments except the main
segment (‘CODE ' resource 1) can be unlocked in the resource file. Your application’s
initialization routine must call the Memory Manager procedure MaxApplZone, however;
otherwise the heap zone will grow incrementally and calls to MoveHHi may leave your
segments scattered throughout the heap.

The Segment Loader IV-83

18

THE OPERATING SYSTEM EVENT MANAGER

—"
eo)

A new routine, PPostEvent, posts application-defined events into the event queue and
returns a pointer to the created queue element.
FUNCTION

PPostEvent
EvQE1)
:

(eventCode:
OSErr);

INTEGER;

Trap macro

_PPostEvent

On entry

AO: eventCode (word)
DO: eventMsg (long word)

On exit

AO: pointer to event queue entry

eventMsg:

LONGINT;

VAR

©

Fp)

es

qEl:

PPostEvent is identical to PostEvent except that it returns a pointer to the created queue

entry.

SUMMARY OF THE OPERATING SYSTEM EVENT MANAGER
Routines
FUNCTION

PPostEvent

(eventCode:
INTEGER;
EVQE1)
: OSErr);

eventMsg:

LONGINT;

VAR

qEl:

Assembly-Language Information
Routines
Trap macro

On entry

On exit

_PPostEvent

AO: eventCode (word)
DO: eventMsg (long)

AO: ptr to event queue entry

The Operating System Event Manager IV-85

<“
fae)
=}
=

THE FILE MANAGER
About This Chapter
About the File Manager

Volumes and the File Directory

115
116
120
122
123
123
125
127
127
127
128
128
135
145
148
155
158
159
160
161
162
163

About Names
About Directories
About Volumes
About Files
Using the File Manager
Hierarchical Routines
Working Directories
Pathnames
Specifying Volumes, Directories, and Files
Indexing
Accessing Files
Accessing Volumes
Advanced Routines
Information Used by the Finder
Flat Volumes
Hierarchical Volumes
High-Level File Manager Routines
Accessing Volumes
Accessing Files
Creating and Deleting Files
Changing Information About Files
Low-Level File Manager Routines
Parameter Blocks
IOParam Variant (ParamBlockRec and HParamBlockRec)
FileParam Variant (ParamBlockRec and HParamBlockRec)
VolumeParam Variant (ParamBlockRec)
VolumeParam Variant (HParamBlockRec)
CInfoPBRec
CMovePBRec
WDPBRec
Routine Descriptions
Initializing the File I/O Queue
Accessing Volumes
Accessing Files
Creating and Deleting Files and Directories
Changing Information About Files and Directories
Hierarchical Directory Routines
Working Directory Routines
Data Organization on Volumes
Flat Directory Volumes
Volume Information
Volume Allocation Block Map
Flat File Directory

poh
We)

es)

o
oe)
~
2
TS
fae)
baw

Contents IV-§7

§

Inside Macintosh

164
166
167

168
170

171
174
175
176
178
181
182
183

IV-88

Hierarchical Directory Volumes
Volume Information
Volume Bit Map

B*-Trees
Extents Tree File

Catalog Tree File
Data Structures in Memory
The File I/O Queue
Volume Control Blocks
File Control Blocks
The Drive Queue
Using an External File System
Summary of the File Manager

Contents

The File Manager

ABOUT THIS CHAPTER
This chapter describes the File Manager, the part of the Operating System that controls the
exchange of information between a Macintosh application and files. The File Manager
allows you to create and access any number of files containing whatever information you
choose.
The changes to the File Manager are so extensive that the chapter has been completely
rewritten. For most programmers, the changes are transparent and require no modification
of code. All operations on the 64K ROM version of the File Manager are supported.

—"
‘©

=

o
po)
a
jo)
v2
fee]

Lome §

ABOUT THE FILE MANAGER
The File Manager is the part of the Operating System that handles communication between
an application and files on block devices such as disk drives. (Block devices are discussed
in the Device Manager chapter.) Files are a principal means by which data is stored and
transmitted on the Macintosh. A file is a named, ordered sequence of bytes. The File
Manager contains routines used to read from and write to files.

Volumes and the File Directory
A volume is a piece of storage medium, such as a disk, formatted to contain files.

A

volume can be an entire disk or only part of a disk. A 3 1/2-inch Macintosh disk is one
volume. Specialized memory devices, such as hard disks and file servers, can contain
many volumes. The size of a volume also varies from one type of device to another.
Macintosh volumes are formatted into chunks known as logical blocks, each able to
contain up to 512 bytes. Files are stored in allocation blocks, which are multiples of
logical blocks.
Each volume has a file directory containing information about the files on the volume.
With small volumes (containing only a few dozen files), a “flat” file directory organized as
a simple, unsorted list of file names is sufficient. Volumes initialized by the 64K ROM
have such a flat file directory.
64K ROM note: The 128K ROM version of the File Manager supports all
operations on flat file directories.
With the introduction of larger storage devices (several megabytes per volume) containing a
large number of files (thousands per volume), the flat file directory proves inadequate,
since an exhaustive, linear search of all the files is so time-consuming. A major feature of
the 128K ROM version of the File Manager is the implementation of a hierarchical file
directory (sometimes referred to as the file catalog), that significantly speeds up access to
large volumes.
The hierarchical file directory allows a volume to be divided into smaller units known as
directories.

Directories can contain files as well as other directories.

contained within directories are also known as subdirectories.

Directories

About the File Manager IV-&9

Inside Macintosh

The hierarchical directory structure is equivalent to the user’s perceived desktop hierarchy,
where folders contain files or additional folders. In the 64K ROM version of the File
Manager, however, this desktop hierarchy was essentially an illusion maintained
completely by the Finder (at considerable expense). The introduction of an actual
hierarchical directory containing subdirectories greatly enhances the performance of the
Finder by relieving it of this task.
Figure 1 illustrates these two ways of organizing the files on a volume.
flat file directory

hierarchical file directory

LO)

Figure 1. Flat and Hierarchical Directories
About Names
Volumes, directories, and files all have names. A volume name consists of any sequence
of 1 to 27 printing characters, excluding colons (:). File names and directory names consist
of any sequence of 1 to 31 printing characters, excluding colons. You can use uppercase
and lowercase letters when naming things, but the File Manager ignores case when

comparing names (it doesn’t ignore diacritical marks).

64K ROM note: The 64K ROM version of the File Manager allows file names of

up to 255 characters. File names should be constrained to 31 characters, however, to
maintain compatibility with the 128K ROM version of the File Manager. The 64K

ROM version of the File Manager also allows the specification of a version number
to distinguish between different files with the same name. Version numbers are
generally set to 0, though, because the Resource Manager, Segment Loader, and

Standard File Package won’t operate on files with nonzero version numbers, and the

Finder ignores version numbers.

IV-90 About the File Manager

The File Manager
About Directories

A few terms are needed to describe the relationships between directories on a hierarchical

volume.
volume.

Figure 2 shows what looks to be an upside-down tree; it’s a sample hierarchical

root directory

a

aan

<

z
=

/ MyDisk

a

-

pou)

11

21

GN

26

System Folder

Correspondence

§ MacWrite

| Empty Folder

Finder

27

System

Family

Template

29

Letters

Dad

Geri
Figure 2. A Hierarchical Volume

All of the volume’s files stem from the directory labeled MyDisk; this is the root

directory and is none other than the volume itself. The name of the root directory of a
volume is the same as the volume name.
Note:

The volume name, constrained to 27 characters, is the sole exception to the

rule that directory names can be up to 31 characters long.

Each directory, including the root directory, is a distinct, addressable entity.

Each directory

has its own set of offspring (possibly an empty set), which is those files or directories

contained in it. For instance, the directory Letters has the files Dad and Geri as offspring,

while the root directory contains the file MacWrite and the directories System Folder and
Empty Folder. Borrowing a term from physics, the number of offspring is known as the
directory’s valence; for instance, the valence of the directory Correspondence is 2.
Similarly, for a given file or directory, the directory immediately above it is known as its _
parent. The root directory is the only directory that doesn’t have a parent.

About the File Manager IV-91

Inside Macintosh

When created, every directory is given a directory ID that’s unique (and assigned
sequentially) for any given volume. The root directory always has a directory ID of 2. In
Figure 2, for instance, the directory Empty Folder has a directory ID of 26. The directory
ID of a given offspring’s parent is known as its parent ID; for example, the parent ID of
the file Template is 21.

About Volumes
A volume can be mounted or unmounted. When a volume is mounted, the File Manager
reads descriptive information about the volume into memory. For each mounted volume,
part of this information is placed in a data structure known as a volume control block
(described in detail in the section “Data Structures in Memory’’).
Ejectable volumes (such as the 3 1/2-inch disks) are mounted when they’re inserted into a
disk drive; nonejectable volumes (such as those on hard disks) are always mounted. Only
mounted volumes are known to the File Manager, and an application can access
information on mounted volumes only.

When a volume is unmounted, the File Manager

releases the information stored in the volume control block.

A mounted volume can be on-line or off-line. A mounted volume is on-line as long as the
volume buffer and all the descriptive information read from the volume when it was

mounted remain in memory (about 1K to 1.5K bytes); it becomes off-line when all but

the volume control block is released. You can access information on on-line volumes
immediately, but off-line volumes must be placed on-line before their information can be
accessed. When an application ejects a 3 1/2-inch disk from a drive, the File Manager
automatically places the volume off-line. Whenever the File Manager needs to access a
mounted volume that’s been placed off-line and ejected, the dialog box shown in Figure 3
is displayed, and the File Manager waits until the user inserts the disk named volName into
a drive.

5

Please insert the disk:
voiIName

Figure 3. Disk-Switch Dialog
Note: This dialog is actually a system error alert, as described in the System Error
Handler chapter.
Mounted volumes share a common set of volume buffers, which is temporary storage
space in the heap used when reading or writing information on the volume. The number of
volumes that may be mounted at any time is limited only by the number of drives attached
and available memory.

IV-92 About the File Manager

The File Manager

64K ROM note: In the 64K ROM version of the File Manager, each mounted

volume was assigned its own volume buffer.

To prevent unauthorized writing to a volume, volumes can be locked. Locking a volume
involves either setting a software flag on the volume or changing some part of the volume

physically (for example, sliding a tab from one position to another on a 3 1/2-inch disk).
Locking a volume ensures that none of the data on the volume can be changed.

Each volume has a name that you can use to identify it. On-line volumes in disk drives can
also be accessed via the drive number of the drive on which the volume is mounted; the
internal drive is number 1, the external drive is number 2, and any additional drives
connected to the Macintosh will have larger numbers. In most routines, however, you'll
identify a volume by its volume reference number, which is assigned to a volume

when it’s mounted. When accessing an on-line volume, you should always use the volume
reference number or the volume name rather than a drive number, because the volume may

have been ejected or placed off-line. Whenever possible, use the volume reference number
(to avoid confusion between volumes with the same name).

Note: In the case of specialized storage devices (such as hard disks) containing
several volumes, only the first on-line volume can be accessed using
number of the device.

the drive

About Files
A file is a finite sequence of numbered bytes. Any byte or group of bytes in the sequence
can be accessed individually. A byte within a file is identified by its position within the
ordered sequence.
There are two parts, or forks, to a file: the data fork and the resource fork. Normally
the resource fork of an application file contains the resources used by the application, such
as menus, fonts, and icons, and also the application code itself. The data fork can contain
anything an application wants to store there. Information stored in resource forks should

always be accessed via the Resource Manager. Information in data forks can only be

accessed via the File Manager.
this chapter.

For simplicity, “file” will be used instead of “data fork” in

The size of a file is limited only by the size of the volume it’s on. Space is allocated to a

file in allocation blocks (multiples of 512 bytes). Two numbers are used to describe the
size of a file. The physical end-of-file is the number of bytes currently allocated to the
file; it’s 1 greater than the number of the last byte in its last allocation block (since the first
byte is byte number 0). The logical end-of-file is the number of those allocated bytes
that currently contain data; it’s 1 greater than the number of the last byte in the file that
contains data.

For example, given an allocation block size of two logical blocks (that is,

1024 bytes), a file with 50 bytes of data has a logical end-of-file of 50 and a physical endof-file of 1024 (see Figure 4).

About the File Manager IV-93

ped,
\O

i

o

pole
~~
SS
To
ae)
ae |

Inside Macintosh

logical
end-of-file

i
CER
DEP ERD ERED
tT
~
N
TY
byte 0
byte 50

physical
end-of-file

INCL

|
7
byte 1024

Figure 4. Logical and Physical End-of-File
The File Manager maintains a current position marker, called the mark, to keep track of

where it is in the file during a read or write operation. The mark is the number of the next
byte that will be read or written; each time a byte is read or written, the mark is moved.

When, during a write operation, the mark reaches the number of the last byte currently
allocated to the file, another allocation block 1s added to the file.

You can read bytes from and write bytes to a file either singly or in sequences of unlimited
length. You can specify where each read or write operation should begin by setting the
mark; if you don’t, the operation begins at the byte where the mark currently points. You
can find the current position of the mark by calling GetFPos. You can set the mark before

the read or write operation with SetFPos; you can also set it in the Read or Write call itself.

You can move the logical end-of-file to adjust the size of the file (such as after a resource
file has been compacted); when the logical end-of-file is moved to a position more than one
allocation block short of the current physical end-of-file, the unneeded allocation block will
be deleted from the file. You can also increase the size of a file by moving the logical-endfile past the physical end-of-file.
A file can be open or closed. An application can perform only certain operations, such as
reading and writing, on open files; other operations, such as deleting, can be performed
only on closed files.
Your application can lock a file to prevent unauthorized writing to it. Locking a file
ensures that none of the data in it can be changed; this is the same as the user-accessible
lock maintained by the Finder.

When a file is opened, the File Manager reads useful information about the file from its

volume and stores it in a data structure known as a file control block. The contents of
the file control block (described in detail in the section “Data Structures in Memory’’) are
used frequently and can be obtained with the function GetFileInfo.
When a file is opened, the File Manager creates an access path, a description of the route
to be followed when accessing the file. The access path specifies the volume on which the
file is located and the location of the file on the volume. Every access path is assigned a
unique path reference number (a number greater than 0) that’s used to refer to it. A file
can have multiple access paths open; each access path is separate from all other access paths
to the
file.

IV-94 About the File Manager

The File Manager
Each file has open permission information, which indicates whether data can be written

to it or not. When you open a file, you request permission to read or write via an access

path. You can request permission to read only, write only (rarely done), or both read and

write. There are two types of read/write permission—exclusive and shared. Applications
will generally want to request exclusive read/write permission. If an access path requests

and is granted exclusive read/write permission, no other access path will be granted
permission to write (whether write only, exclusive read/write, or shared read/write).

A second type of read/write permission allows multiple access paths to be open for writing.
If you’ll be using only a portion, or range, of a file, you can request shared read/write

permission. With shared read/write permission, the application must see to it that the file’s

data integrity is preserved. Before writing to a particular range of bytes, you need to “lock”
it so that other access paths cannot write to that range at the same time. In the meantime,
other access paths opened with shared read/write access can lock and write to other parts of
the file.
The shared read/write permission has no utility on a single Macintosh; this permission is
intended for, and will be passed by, external file systems, where multiple read/write
operations are performed.

Note: If an access path is open with shared read/write permission, no access path
can be granted exclusive read/write access.

64K ROM note: Shared read/write permission is not implemented in the 64K
ROM version of the File Manager.
If the file’s open permission doesn’t allow I/O as requested, a result code indicating the
error is returned.
Each access path can move its own mark and read at the position it indicates. All access

paths to the same file share common logical and physical end-of-file markers.

When an application requests that data be read from a file, the File Manager reads the data

from the file and transfers it to the application’s data buffer. Any part of the data that can

be transferred in entire 512-byte blocks is transferred directly. Any part of the data
composed of fewer than 512 bytes is also read from the file in one 512-byte block, but
placed in temporary storage space in memory. Then, only the bytes containing the
requested data are transferred to the application.

When an application writes data to a file, the File Manager transfers the data from the
application’s data buffer and writes it to the file. Any part of the data that can be transferred
in entire 512-byte blocks is written directly. Any part of the data composed of fewer than
512 bytes is placed in temporary storage space in memory until 512 bytes have
accumulated; then the entire block is written all at once.

Note: Advanced programmers: The File Manager can also read a continuous stream
of characters or a line of characters. In the first case, you ask the File Manager to
read a specific number of bytes: When that many have been read or when the mark
has reached the logical end-of-file, the read operation terminates. In the second case,
called newline mode, the read will terminate when either of the above conditions is

met or when a specified character, the newline character, is read. The newline

character is usually Return (ASCII code $0D), but it can be any character.

Information about newline mode is associated with each access path to a file, and can
differ from one access path to another.
About the File Manager IV-95

poo,
Vo)

ar
:

fae)
pb)

~

pers)
To
fas)

ine §

Inside Macintosh

Normally the temporary space in memory used for all reading and writing is the volume
buffer, but an application can specify that an access path buffer be used instead for a
particular access path (see Figure 5).
/

~

Nf

access path buffer ay

AN

)}*

application's

(
€

>

data buffer

\

K

Z

SJ

“\

access

P

path buffer

K

)*

>

rT

"A

rT

L

y

-

S

>

’

\
‘

volume buffer
L

a
file

>

r

)*

>

file "B"

\

y

Figure 5. Buffers for Transferring Data
Warning: You must lock any access path buffers of files in relocatable blocks, so
their location doesn’t change while the file is open.

USING THE FILE MANAGER
This section outlines the routines provided by the File Manager and explains some basic
concepts needed to use them. The actual routines are presented later in the chapter.
The File Manager is automatically initialized each time the system starts up.
You can call most File Manager routines via three different methods:

high-level Pascal

calls, low-level Pascal calls, and assembly language. The high-level Pascal calls are

designed for Pascal programmers interested in using the File Manager in a simple manner;
they provide adequate file I/O and don’t require much special knowledge to use. The lowlevel Pascal and assembly-language calls are designed for advanced Pascal programmers
and assembly-language programmers interested in using the File Manager to its fullest
Capacity; they require some special knowledge to be used most effectively.
Note: The names used to refer to File Manager routines in text (as opposed to in
particular routine descriptions) are actually the assembly-language macro names for
the low-level routines, but the Pascal routine names are very similar.

Hierarchical Routines
Many new routines are introduced in the hierarchical version of the File Manager; they can
be divided into two groups. These routines are used primarily by the File Manager itself.

IV-96 Using the File Manager

The File Manager
Routines in the first group are slight extensions of certain basic File Manager routines that
allow the specification of a directory ID in addition to the other parameters; in certain cases
they set or obtain additional information. These specialized routines have the same names

as their general-purpose counterparts, but preceded by the letter “H’’. For instance, the

routine HOpen is identical to the Open call except that it allows the specification of a

directory ID. The routines in this first group are: HOpen, HOpenRF, HRename, HCreate,
HDelete, HGetFileInfo, HSetFileInfo, and HGetVInfo. The calls in this group will work
with the 64K ROM version of the File Manager, but most applications will never need to
use them.

The second group of hierarchical routines consists of calls that perform operations unique
to the hierarchical file directory. The routines in this group are: SetVolInfo, LockRng,
UnlockRng, DirCreate, GetCatInfo, SetCatInfo, CatMove, OpenWD, CloseWD,
GetWDInfo, and GetFCBInfo.

pod,
\O

eal
=

oO
jah)
>
pe)
TQ

rae

Law

Warning:

Using any of the routines in this second group on a Macintosh equipped

only with the 64K ROM version of the File Manager will result in a system error.
Using them on a flat volume will have no effect on “folders” and will result in File

Manager errors.

In general, you will want your application to be independent of any particular version of the
File Manager. The benefits of the hierarchical file system are transparent to your
application and do not require use of the hierarchical routines. You may, however, want to

use the hierarchical routines under certain circumstances. One way of determining whether
the hierarchical version of the File Manager is present is to check which version of the

ROM is running

by calling the Operating System Utilities procedure Environs.

RAM-based hierarchical versions of the File Manager may also be encountered, however; a
better way of determining which version of the File Manager is running is to examine the
contents of the global variable FSFCBLen. Located at address $3F6, this variable is a
word (two bytes) in length; it contains a positive value if the hierarchical version of the File
Manager is active or —1 if the 64K ROM version of the File Manager is running. You
could test the value of this global variable in the following way:
CONST
VAR

FSFCBLen

HFS:

=

$3F6;

{address

of

global

variable}

“INTEGER;

HFS
:= POINTER(FSFCBLen) ;
IF HFS*
> 0
THEN
BEGIN

{we're

running

under

the

hierarchical

{we're

running

under

the

64K

END;
ELSE
BEGIN

ROM

version}

version}

END;

Even after determining that the hierarchical version is running, you'll still need to check that
a mounted volume is hierarchical by calling the HGetVInfo function.

Using the File Manager IV-97

|

Inside Macintosh

Assembly-language note: You can tell whether a Macintosh is equipped with the
64K ROM version or the hierarchical version of the File Manager by examining the

contents of the global variable FSFCBLen; if the 64K ROM version is running,
FSFCBLen will contain—1. You can determine if a mounted volume is flat or
hierarchical by calling the HGetVInfo function.

Working Directories
It’s useful to look at the relationship between the 64K ROM and 128K ROM versions of
the File Manager. In the 64K ROM version, the entire volume is a single directory (you
could consider it a barren root directory). It would seem that existing applications, when
introduced on a machine equipped with the 128K ROM version of the File Manager,
would be unable to handle the specification of which directory a file is in, since they only
exchange volume reference numbers and file names with the Finder and the File Manager.

The 128K ROM version, however, introduces the notion of a working directory to
allow existing applications to operate with the hierarchical file system.

When the File Manager makes a particular directory a working directory (using the function

OpenWD), it stores the directory ID, as well as the volume reference number of the volume
on which the directory is located, in a working directory control block. The File
Manager then returns a unique working directory reference number which you can
use in subsequent calls to refer to that directory.

Directories can be seen as mini-volumes. (The root directory is, in fact, just another minivolume; it contains only the files and directories immediately below it in the tree structure.)
A working directory reference number is just like a volume reference number for a

directory. It’s a temporary reference number that specifies where a file is located on a
hierarchical volume.

This relationship allows the hierarchical file system to be compatible with existing
applications. A working directory reference number can be used in place of a volume
reference number in any File Manager call. When you provide a working directory
reference number, the File Manager uses it to determine which directory a file is in, as well

as which volume the directory and file are on.

An example of the use of working directories is a situation where the Finder opens a
document. With the 64K ROM version of the File Manager, when the Finder launches the
application that handles the document, it has only to pass the volume reference number and
file name of the document. With the 128K ROM version, the Finder makes the directory
containing the file a working directory, and passes the application a working directory
reference number instead of the volume reference number. Upon being launched, the
application opens the file, passing the File Manager the working directory reference number
received from the Finder.
Warning: The possibility of incompatibility arises for programmers who (despite
numerous warnings) have written code that accesses and manipulates low-level data
structures directly (such as volume control blocks and file control blocks).
Programmers in this category will want to study the sections “Data Organization on
Volumes” and “Data Structures in Memory”’.

IV-98 Using the File Manager

The File Manager
Pathnames
The 128K ROM version of the File Manager also permits the specification of files (and
directories) using concatenations of volume names, directory names, and file names.
Separated by colons, these concatenations of names are known as pathnames.
A full pathname always begins with the name of the root directory; it names the path

from the root to a given file or directory, and includes each of the directories visited on that
path (see Figure 2). For instance, a full pathname to the file Geri is:

a

o>

MyDisk:Correspondence:Letters:Family:Geri

A full pathname is a complete and unambiguous identification of a file or directory. You

should avoid using full pathnames; they are cumbersome to enter and it takes longer to

process them.

pa)

—

a

T
om
ae

Another type of identification is a partial pathname, which describes the path to a file or

directory starting from a given directory. When using a partial pathname, you must also
specify the directory from which the partial pathname begins; this is discussed below.
64K ROM

pom
eo)

note:

In the 64K ROM version of the File Manager, the combination of

volume name followed by the file name constitutes a full pathname. A file name
alone constitutes a partial pathname; the directory from which this partial pathname
begins (the root directory) is specified by the volume reference number.

To distinguish them from full pathnames, partial pathnames must begin with a colon,
except in the case where the partial pathname contains only one name. (This exception is
needed to maintain compatibility with 64K ROM version of the File Manager, where the

only partial pathnames—file names—do not begin with a colon.) For the file Geri in
Figure 2, a valid partial pathname, starting from the directory Letters, would be:
:Family:Geri

The above pathname begins at the directory Letters and moves down the tree to the file
Status. It’s also possible to move up the tree by using consecutive colons (::). This
notation indicates, for instance, that the name following a double colon is an offspring of
the current location’s parent, rather than an offspring of the directory preceding the double
colon. In Figure 2, for example, the file Letter Form can be specified by the full pathname
MyDisk:Correspondence:Letters:Family:::Template

where the consecutive colons signify a move up the tree from Family to Letters and finally
to Correspondence.
If a full pathname consists of only one name (the volume name), the pathname must end in
acolon. For pathnames to other directories, if the last name is followed by a colon, the
colon is ignored. Multiname pathnames describing a file should not end in a colon.
To summarize, if the first character of a pathname is a colon, or if the pathname contains no

colons, it must be a partial pathname; otherwise, it’s a full pathname.

Warning: While there’s no limit to the number of levels of subdirectories allowed,
it may not always be possible in the case of a large volume to specify every file and
Using the File Manager IV-99

4

Inside Macintosh

directory with a full pathname, since character strings are limited to 255 characters.

In such cases, you can obtain the directory ID of a subdirectory somewhere along the
path and use it with a partial pathname to specify the desired file or directory.

Specifying Volumes, Directories, and Files
A volume can be specified explicitly by its name, its volume reference number, or its drive

number, and implicitly by a working

directory reference number or a full pathname. The

File Manager searches for volume specifications in the following order:
1. It looks for a volume name.

(Remember, it must be followed by a colon. )

2. If the name specified is NIL or an improper name, the File Manager looks for either a
volume reference number, a drive number, or a working directory reference number.
With routines that operate on a volume, such as mounting or ejecting, if you don’t provide
any of these specifications, the File Manager assumes you want to perform the operation on

the default volume. Initially, the volume used to start up the application is set as the

default volume, but an application can designate any mounted volume as the default
volume.

With routines that access files (or directories), if no directory is specified and the volume
reference number passed is zero, the File Manager assumes that the file or directory is
located in the default directory. Initially, the default directory is set to the root directory
of the volume used to start up the application, but an application can designate any directory
as the default directory.
To access a file or directory, you need to specify its name, the directory it’s in, and which
volume it’s on. There are a number of ways of doing this:
= Full pathname. A full pathname completely specifies a file or directory. Since the first
name in a full pathname (the name of the root directory) is always the name of the
volume, no separate volume specification is needed. In fact, a full pathname will
override an explicit volume specification. (This specification runs the risk of
ambiguity since there could be two mounted volumes with the same name.)
m Volume reference number and partial pathname. This is the most common type of
specification, since it’s the only form of specification in the 64K ROM version of the
File Manager. The volume reference number specifies the volume as well as the
directory (the root) to be used with the partial pathname (the file name).
= Directory ID and partial pathname. Another way to specify a file or directory is to use
the directory ID of any directory in the catalog along with a partial pathname from that
directory. Since neither the directory ID nor the partial pathname indicates the name of
the volume, a separate volume specification is also needed.
= Working directory reference number and partial pathname. This is the most common
type of specification in the 128K ROM version of the File Manager. It’s similar to the
previous one; it does not, however, require a separate volume specification. The
working directory reference number is used to obtain both the directory ID (to be used
with the partial pathname) and the volume reference number.

IV-100 Using the File Manager

The File Manager
If both a directory ID and a working directory reference number are specified, the directory
ID is used to identify the directory on the volume indicated by the working directory
reference number. In other words, a directory ID specified by the caller will override the
directory referred to by the working directory reference number.
Advanced programmers: If the File Manager doesn’t find a given file in the directory
specified, it looks in the directory containing the currently open System file (obtained from
the global variable BootDrive), provided it's on the volume specified by the call. If the file
isn't found there, the File Manager looks in the folder, on the volume specified by the call,
whose directory ID is returned in the vcbFndrInfo field by the HGetVInfo function.

Warning: It’s important to be aware of this search path. You can’t assume that a
given file is located in the directory that you specified when accessing it.

—"
So

ey
=

oO
poe)
~
poe)
tT

o

Law

Indexing
In most of the File Manager routines, you’ll be referring to a particular file, directory, or
volume by its name or some sort of reference number. With a routine such as GetFileInfo,
however, you may want to make the same call repeatedly for all files in a given directory

without specifying each file individually. Such routines provide a parameter where you can
simply specify an index number. In the first iteration of the GetFileInfo function, for
example, you would pass an index of 1 and get information about the first file in a given
directory. In the second iteration you would pass an index of 2, and so on.
It’s possible to determine how many files are contained in a given directory and thereby
specify the number of iterations for a GetFileInfo indexing loop. The presence of .
subdirectories, however, complicates the situation.

A faster and more reliable technique is

to begin with an index of 1 and continue until the result code fnfErr (file not found) is
returned.

The routines that allow you to provide an index are: GetVolInfo, GetFileInfo, GetCatInfo,
GetWDInfo, and GetFCBInfo. Respectively, they provide information about mounted

volumes, files in a given directory, files and directories in a given directory, working

directories, and file control blocks.

On flat volumes, programmers can use the function GetFileInfo to index through all the
files on a volume. On hierarchical volumes, files can be in subdirectories, which may
themselves contain other subdirectories and files. With such volumes, you should instead
use GetCatInfo since it returns information about both files and directories.
Advanced programmers: While it’s questionable whether an application would want to
index through all the files on a hierarchical volume (since such a volume may contain a
large number of files), you may want to index through a particular directory or portion of
the tree structure. You can use GetCatInfo in a recursive way to do this. While indexing
through the initial directory, if a subdirectory is found, you need to interrupt the indexing
of the initial directory and index through the subdirectory.

Accessing Files
To create a new, empty file, call Create. Create allows you to set some of the information
stored on the volume about the file. DirCreate allows you to create directories.

Using the File Manager IV-101

|

Inside Macintosh

To open a file, call Open. The File Manager creates an access path and returns a path
reference number that you’ll use every time you want to refer to it. Before you open a file,
you may want to call the Standard File Package, which presents the standard interface

through which the user can specify the file to be opened. The Standard File Package will
return the name of the file, the volume reference number or working directory reference

number, and additional information. (If the user inserts an unmounted volume into a drive,
the Standard File Package will automatically call the Disk Initialization Package to attempt
to mount it.)
After opening a file, you can transfer data from it to an application’s data buffer with Read,
and send data from an application’s data buffer to the file with Write. If you’ve opened a
file with shared read/write permission, you need to call LockRng before writing to it in
order to prevent another access path from writing to the same portion of the file. When
you’re done writing, call UnlockRng to release that portion of the file.
You can’t use Write on a file whose open permission only allows reading, or on a file on a
locked volume. In addition, you can’t write to a range that’s been locked by another access

path with the LockRng call.

You can specify the byte position of the mark before calling Read or Write by calling
SetFPos. GetFPos returns the byte position of the mark.
Once you’ve completed whatever reading and writing you want to do, call Close to close
the file. Close writes the contents of the file’s access path buffer to the volume and deletes
the access path. You can remove a closed file (both forks) from a volume by calling
Delete.
Applications will normally use the Resource Manager to open resource forks and change
the information contained within, but programmers writing unusual applications (such as a
disk-copying utility) might want to use the File Manager to open resource forks. This is
done by calling OpenRF. As with Open, the File Manager creates an access path and
returns a path reference number that you’ll use every time you want to refer to this resource
fork.

Accessing Volumes
When the Toolbox Event Manager function GetNextEvent receives a disk-inserted event, it
calls the Desk Manager function SystemEvent. SystemEvent calls the File Manager
function MountVol, which attempts to mount the volume on the disk. GetNextEvent then
returns the disk-inserted event: The low-order word of the event message contains the
number of the drive, and the high-order word contains the result code of the attempted
mounting. If the result code indicates that an error occurred, you’ll need to call the Disk

Initialization Package to allow the user to initialize or eject the volume.

Note: Applications that rely on the Operating System Event Manager function
GetOSEvent to learn about events (and don’t call GetNextEvent) must explicitly call
MountVol to mount volumes.
|
After a volume has been mounted, your application can call Get VolInfo, which will return
the name of the volume, the amount of unused space on the volume, and a volume
reference number that you can use to refer to that volume. The volume reference number is
also returned by MountVol.
IV-102

Using the File Manager

The File Manager
To minimize the amount of memory used by mounted volumes, an application can unmount
or place off-line any volumes that aren’t currently being used. To unmount a volume, call
UnmountVol, which flushes a volume (by calling FlushVol) and releases all of the memory
used for it. To place a volume off-line, call OffLine, which flushes a volume and releases

all of the memory used for it except for the volume control block. Off-line volumes are
placed on-line by the File Manager as needed, but your application must remount any

unmounted volumes it wants to access. The File Manager itself may place volumes off-line
during its normal operation.

To protect against power loss or unexpected disk ejection, you should periodically call
FlushVol (probably after each time you close a file), which writes the contents of the
volume buffer and all access path buffers (if any) to the volume and updates the descriptive
information contained on the volume.
Whenever your application is finished with a disk, or when the user chooses Eject from a
menu, call Eject. Eject calls FlushVol, places the volume off-line, and then physically
ejects the volume from its drive.
If you would like all File Manager calls to apply to one volume, you can specify that
volume as the default. You can use SetVol to set the default volume to any mounted
volume, and GetVol to learn the name and volume reference number of the default volume.
The preceding paragraphs covered the basic File Manager routines. The remainder of this
section describes some less commonly used routines.
Advanced Routines
Normally, volume initialization and naming is handled by the Standard File Package, which
calls the Disk Initialization Package. If you want to initialize a volume explicitly or erase all
files from a volume, you can call the Disk Initialization Package directly. When you want
to change the name of a volume, call the File Manager function Rename.

Whenever a disk has been reconstructed in an attempt to salvage lost files (because its

directory or other file-access information has been destroyed), the logical end-of-file of

each file will probably be equal to its physical end-of-file, regardless of where the actual
logical end-of-file is. The first time an application attempts to read from a file on a

reconstructed volume, it will blindly pass the correct logical end-of-file and read

misinformation until it reaches the new, incorrect logical end-of-file. To prevent this from
happening, an application should always maintain an independent record of the logical
end-of-file of each file it uses. To determine the File Manager’s conception of the size of a
file, or to find out how many bytes have yet to be read from it, call GetEOF, which returns
the logical end-of-file. You can change the length of a file by calling SetEOF.

Allocation blocks are automatically added to and deleted from a file as necessary. If this
happens to a number of files alternately, each of the files will be contained in allocation
blocks scattered throughout the volume, which increases the time required to access

those files. To prevent such fragmentation of files, you can allocate a number of

contiguous allocation blocks to an open file by calling Allocate or AllocContig.

Using the File Manager IV-103

pmoeh
Vo)

=

oO
poe)
mj
joe)
To
(as)

bene §

Inside Macintosh

Instead of calling FlushVol, an unusual application might call FlushFile. FlushFile forces
the contents of a file’s volume buffer and access path buffer (if any) to be written to its
volume. FlushFile doesn’t update the descriptive information contained on the volume, so
the volume information won’t be correct until you call FlushVol.
To get information about a file in a given directory (such as its name and creation date), call

GetFileInfo; you can change this information by calling SetFileInfo. On hierarchical
volumes, you can get information about both files and directories by calling GetCatInfo;
you can change this information with SetCatInfo. Changing the name of a file is
accomplished by calling Rename.

file, call RstFilLock.

You can lock a file by calling SetFilLock; to unlock a

Given a path reference number, you can get the volume reference

number of the volume containing that file by calling either GetVRefNum or GetFCBInfo
(described in the section “Data Structures in Memory’).
64K ROM note:
SetFilType.

You can change the version number of a file by calling

To make a particular directory a working directory, call OpenWD; you can remove a

working directory with CloseWD. To get information about a working directory (from its

working

directory control block), call GetWDInfo.

INFORMATION USED BY THE FINDER
The file directory (whether hierarchical or flat) lists information about all the files and
directories on a volume. This information is returned by the GetFileInfo and GetCatInfo
functions.
Flat Volumes
On flat volumes, all of the information used by the Finder is contained in a data structure of
type FInfo. (This data structure is also used with hierarchical volumes, along with
additional structures described below.) The FInfo data type is defined as follows:
TYPE

FInfo

=

RECORD

fdType:
fdCreator:
fdFlags:
fdLocation:
fdFldr:

OSType;
OSType;
INTEGER;
Point;
INTEGER

{file type}
{file's creator}
{flags}
{file's location}
{file's window}

END ;

Normally an application need only set the file type and creator when a file is created, and
the Finder will manipulate the other fields. (File type and creator are discussed in the
Finder Interface chapter.)

IV-104 Information Used by the Finder

The File Manager

FdFlags indicates whether the file’s icon is invisible, whether the file has a bundle, and
other characteristics used internally by the Finder:
Bit

Meaning

0
13
14

Set if file is on desktop (hierarchical volumes only)
Set if file has a bundle
Set if file’s icon is invisible

pnd
Oo

Masks for these three bits are available as predefined constants:
CONST

fOnDesk

1;

fHasBundile
finvisible

8192;
16384;

=

{set if file is on desktop
(hierarchical
{ volumes only) }
{set if file has a bundle}
{set if file's icon is invisible}

}

For more information about bundles, see the Finder Interface chapter.
FdLocation contains the location of the file’s icon in its window, given in the local
coordinate system of the window; it’s used by the Finder to position the icon. FdFldr

indicates the window in which the file’s icon will appear, and may contain one of the
following values:
CONST

f£Trash
fDesktop
fDisk

-3;

~2;

0;

{file

is

{file

is

{file

is

in

on

in

Trash

window}

desktop}
disk

window}

64K ROM note: The fdFidr field of FInfo is not used with hierarchical volumes.

Hierarchical Volumes
On hierarchical volumes, in addition to the FInfo record, the following information about
files is maintained for the Finder:
TYPE

FXInfo

=

RECORD
fdIconID:
fdUnused:
fdComment:

fdPutAway:

INTEGER;
{icon ID}
ARRAY[1..4]
OF INTEGER;
INTEGER;
{comment
ID}

LONGINT;

{home

directory

{reserved}

ID}

END;

On hierarchical volumes, the following information about directories is maintained for the
Finder:
Dinfo

=

RECORD

frRect:
frFlags:

frLocation:
frView:
END;

Rect;
INTEGER;

Point;
INTEGER;

{folder's
{flags}

{folder's
{folder's

rectangle}
location}
view}

Information Used by the Finder IV-105

oO

=

pe)
~
pols
To
fae)

lem j

Inside Macintosh
DXInfo

= RECORD

frScroll:
frOpenChain:

Point;
LONGINT;

frUnused:
£frComment:

INTEGER;
INTEGER;

frPutAway:

LONGINT;

{scroll position}
{directory ID chain
{ open folders}
{reserved}
{comment
ID}

{directory

of

}

ID}

END;

When a file (or folder) is moved to the desktop on a hierarchical volume, it’s actually
moved to the root level of the file directory. (This permits all the desktop icons to be
enumerated by one simple scan of the root.) The fOnDesk bit of fdFlags is set.

FDPutA way

(or frPutAway for directories) contains the directory ID of the folder that

originally contained the file (or folder); this allows the file (or folder) to be returned there
from the desktop.

HIGH-LEVEL FILE MANAGER ROUTINES
This section describes all the high-level Pascal routines of the File Manager. For

information on calling the low-level Pascal and assembly-language routines, see the next
section.
When accessing a volume other than the default volume, you must identify it by its volume
name, its volume reference number, the drive number of its drive, or a working directory

reference number. The parameter volName is a pointer, of type StringPtr, to the volume

name. DrvNurn is an integer that contains the drive number, and vRefNum is an integer
that an contain either the volume reference number or a working directory reference

number.

Note: VolName is declared as type StringPtr instead of type STRING to allow you
to pass NIL in routines where the parameter is optional.

Warning: Before you pass a parameter of type StringPtr to a File Manager routine,
be sure that memory has been allocated for the variable. For example, the following
Statements will ensure that memory is allocated for the variable myStr:
VAR

myStr:

result

:=

Str255;

GetVol (@myStr,myRefNum)

FileName can contain either the file name alone or both the volume name and file name.

Note: The high-level File Manager routines will work only with files having a
version number of 0.
You can’t specify an access path buffer when calling high-level Pascal routines.
All high-level File Manager routines return an integer result code of type OSErr as their
function result. Each routine description lists all of the applicable result codes, along with a
short description of what the result code means. Lengthier explanations of all the result
codes can be found in the summary at the end of this chapter.
IV-106 High-Level File Manager Routines

The File Manager

Accessing Volumes
FUNCTION

GetVInfo

vRefNum:
in ROM]

(drvNum:

INTEGER;

INTEGER;

VAR

volName:

freeBytes:

StringPtr;

LONGINT)

VAR

: OSErr;

[Not

GetVInfo returns the name, reference number, and available space (in bytes), in volName,

vRefNum, and freeBytes, for the volume in the drive specified by drvNum.
Result codes

FUNCTION

noErr

nsvErr
paramErr

GetVRefNum

OSErr;

—
vo)

No error

a

oO

No default volume
Bad drive number

(pathRefNum:

[Notin ROM]

INTEGER;

VAR

vRefNum:

INTEGER)

Given a path reference number in pathRefNum, GetVRefNum returns the volume reference
number in vRefNum.
Result codes

FUNCTION

noErr
rfNumErr

GetVol

(volName:

[Not in ROM]

No error
Bad reference number
StringPtr;

VAR

vRefNum:

INTEGER)

:

OSErr;

GetVol returns the name of the default volume in volName and its volume reference
number in vRefNum.
|
Result codes

FUNCTION

noErr
nsvErr

SetVol
(volName:
[Not in ROM]

No error
No such volume
StringPtr;

vRefNum:

INTEGER)

:

OSErr;

SetVol sets the default volume to the mounted volume specified by volName or vRefNum.
Result codes

noErr

No error

nsvErr

No such volume

bdNamErr
paramErr

Bad volume name
No default volume

High-Level File Manager Routines IV-107

oe)
=}
a)
T3
fae)
a |

Inside Macintosh
FUNCTION

FlushVol

(volName:

StringPtr;

[Not in ROM]

vRefNum:

INTEGER)

:

OSErr;

On the volume specified by volName or vRefNum, FlushVol writes the contents of the
associated volume buffer and descriptive information about the volume (if they’ve changed
since the last time FlushVol was called).
noErr
bdNamErr
extFSErr
10Err
nsDrvErr
nsvErr

Result codes

paramErr

FUNCTION

No error
Bad volume name

External file system
I/O error
No such drive
No such volume

No default volume

UnmountVol
(volName:
[Not in ROM]

StringPtr;

vRefNum:

INTEGER)

:

OSErr;

UnmountVol unmounts the volume specified by volName or vRefNum, by calling

FlushVol to flush the volume buffer, closing all open files on the volume, and releasing the
memory used for the volume.

Warning:

Don’t unmount the startup volume.

Result codes

noErr
bdNamErr
extFSErr
i0Err
nsDrvErr
nsvErr

paramErr
FUNCTION

Eject

(volName:

[Not in ROM]

No error
Bad volume name

External file system
I/O error
No such drive
No such volume
No default volume

StringPtr;

vRefNum:

INTEGER)

:

OSErr;

Eject flushes the volume specified by volName or vRefNum, places it off-line, and then
ejects the volume.
Result codes

noErr
bdNamErr
extFSErr
10Err
nsDrvErr
nsvErr

paramErr

No error
Bad volume name

External file system
I/O error
No such drive
No such volume
No default volume

IV-108 High-Level File Manager Routines

The File Manager

Accessing Files
FUNCTION

FSOpen
(fileName:
Str255;
vRefNum:
INTEGER)
: OSErr;
[Not in ROM]

INTEGER;

VAR

refNum:

FSOpen creates an access path to the file having the name fileName on the volume specified
by vRefNum. A path reference number is returned in refNum. The access path’s

read/write permission is set to whatever the file’s open permission allows.
Note:

called.

There’s no guarantee that any bytes have been written until FlushVol is

mc

os

<=

Result codes

OpenRE

poe)

noErr
bdNamErr
extFSErr
fnfErr
10Err
nsvErr

No error

tmfoErr

Too many files open

;

=

External file system
File not found

Law §

I/O error

No such volume

File already open for writing

(fileName:

INTEGER)

5

Bad file name

op WrErr

FUNCTION

pet

VO

OSErr;

Str255;

vRefNum:

[Not in ROM]

INTEGER;

VAR

refNum:

OpenRF is similar to FSOpen; the only difference is that OpenRF opens the resource fork
of the specified file rather than the data fork. A path reference number is returned in
refNum. The access path’s read/write permission is set to whatever the file’s open
permission allows.
Note: Normally you should access a file’s resource fork through the routines of the
Resource Manager rather than the File Manager. OpenRF doesn’t read the resource
map into memory; it’s really only useful for block-level operations such as copying
files.
Result codes

noErr
bdNamErr
extFSErr
fnfErr
10Err
nsvErr

op WrErr
tmfoErr
FUNCTION

FSRead
:

(refNum:

OSErr;

No error
Bad file name
External file system
File not found

I/O error

No such volume
File already open for writing
Too many files open
INTEGER;

[Not in ROM]

VAR

count:

LONGINT;

buffPtr:

Ptr)

FSRead attempts to read the number of bytes specified by the count parameter from the
open file whose access path is specified by refNum, and transfer them to the data buffer
pointed to by buffPtr. The read operation begins at the current mark, so you might want to

High-Level File Manager Routines IV-109

Inside Macintosh

precede this with a call to SetFPos. If you try to read past the logical end-of-file, FsRead
moves the mark to the end-of-file and returns eofErr as its function result. After the read is
completed, the number of bytes actually read is returned in the count parameter.
Result codes

noErr
eofErr

No error
End-of-file

ioErr

I/O error

rfNumErr

Bad reference number

extFSErr
fnOpnErr

paramErr

FUNCTION

FSWrite
Ptr)

:

(refNum:
OSErr;

External file system
File not open

Negative count

INTEGER;
VAR
[Notin ROM]

count:

LONGINT;

buffPtr:

FS Write takes the number of bytes specified by the count parameter from the buffer pointed
to by buffPtr and attempts to write them to the open file whose access path is specified by
refNum. The write operation begins at the current mark, so you might want to precede this
with a call to SetFPos. After the write is completed, the number of bytes actually written is

returned in the count parameter.
Resultcodes

FUNCTION

noErr
dskFulErr
fLckdErr
fnOpnErr
ioErr
paramErr
rfNumErr
vLckdErr
wPrErr
wrPermErr

GetFPos

(refNum:

[Not in ROM]

No error
Disk full
File locked
File not open
I/O error
Negative count
Bad reference number
Software volume lock
Hardware volume lock
Read/write permission doesn’t allow writing
INTEGER;

VAR

filePos:

LONGINT)

:

OSErr;

GetFPos returns, in filePos, the mark of the open file whose access path is specified by
refNum.
Resultcodes

FUNCTION

noErr
extFSErr
fnOpnErr
ioErr
rfNumErr

No error
External file system
File not open
1/O error
Bad reference number

SetFPos
(refNum:
INTEGER;
posMode:
LONGINT ) : OSErr;
[Not in ROM]

INTEGER;

posOff:

SetFPos sets the mark of the open file whose access path is specified by refNum to the
position specified by posMode and posOff (except when posMode is equal to fsAtMark, in

IV-110 High-Level File Manager Routines

The File Manager
which case posOff is ignored). PosMode indicates how to position the mark; it must
contain one of the following values:
CONST

fsAtMark
fsFromStart
fsFromLEOF
fsFromMark

=
=
=
=

0;
1;
2;
3;

{at current mark}
{set mark relative
{set mark relative
{set mark relative

to
to
to

beginning of file}
logical end-of-file}
current mark}

If you specify fsAtMark, posOffset is ignored and the mark is left wherever it’s currently
positioned. If you choose to set the mark (relative to either the beginning of the file, the

—
~

logical end-of-file, or the current mark), posOffset specifies the byte offset from the chosen.

=

past the logical end-of-file, SetFPos moves the mark to the end-of-file and returns eofErr as

=

point (either positive or negative) where the mark should be set. If you try to set the mark
its function result.
Resultcodes

= noErr
eofErr

extFSErr
fnOpnErr

10Err
posErr
rf{NumErr
FUNCTION

GetEOF

(refNum:

[Not in ROM]

External file system
File not open

I/O error
Attempt to position before start of file
Bad reference number
VAR

logEOF:

LONGINT)

:

OSErr;

GetEOF returns, in logEOF, the logical end-of-file of the open file whose access path is
specified by refNum.
Result codes

FUNCTION

noErr

No error

10Err
rfNumErr

I/O error
Bad reference number

extFSErr
fnOpnErr

SetEOF

ROM]

(refNum:

External file system
File not open

INTEGER;

logEOF:

LONGINT)

:

OSErr;

([Notin

SetEOF sets the logical end-of-file of the open file whose access path is specified by
refNum to the position specified by logEOF. If you attempt to set the logical end-of-file
beyond the physical end-of-file, the physical end-of-file is set to one byte beyond the end
of the next free allocation block; if there isn’t enough space on the volume, no change is
made, and SetEOF returns dskFulErr as its function result. If logEOF is 0, all space
occupied by the file on the volume is released.
Result codes

noErr
dskFulErr

No error
Disk full

fLcokdErr

File locked

extFSErr

fnOpnErr

ioErr
rf{NumErr

2

@
=

No error
End-of-file

INTEGER;

2

External file system

File not open

I/O error
Bad reference number

High-Level File Manager Routines IV-11]

Inside Macintosh
vLckdErr
wPrErr

wrPermErr

FUNCTION

Allocate

(refNum:

[Not in ROM]

Software volume lock
Hardware volume lock

Read/write permission doesn’t allow writing
INTEGER;

VAR

count:

LONGINT)

>:

OSErr;

Allocate adds the number of bytes specified by the count parameter to the open file whose

access path is specified by refNum, and sets the physical end-of-file to one byte beyond the

last block allocated. The number of bytes actually allocated is rounded up to the nearest
multiple of the allocation block size, and returned in the count parameter. If there isn’t
enough empty space on the volume to satisfy the allocation request, Allocate allocates the
rest of the space on the volume and returns dskFulErr as its function result.
Result codes

noErr
dskFulErr
fLckdErr

No error
Disk full
File locked

ioErr
rfNumErr
vLckdErr
wPrErr

I/O error
Bad reference number
Software volume lock
Hardware volume lock

fnOpnErr

wrPermErr

FUNCTION

FSClose

(refNum:

File not open

Read/write permission doesn’t allow writing

INTEGER)

: OSErr;

[Notin ROM]

FSClose removes the access path specified by refNum, writes the contents of the volume
buffer to the volume, and updates the file’s entry in the file directory.
Note:

called.

There’s no guarantee that any bytes have been written until FlushVol is

Result codes

noErr

No error

fnfErr

File not found

extFSErr
fnOpnErr

ioErr
nsvErr
rfNumErr

External file system
File not open

1/O error
No such volume
Bad reference number

Creating
and Deleting Files
FUNCTION

Create

(fileName:

OSType;

fileType:

Str255;

OSType)

vRefNum:

: OSErr;

INTEGER;

creator:

[NotinROM]

Create creates a new file (both forks) with the specified name, file type, and creator on the

specified volume. (File type and creator are discussed in the Finder Interface chapter.) The
new file is unlocked and empty. The date and time of its creation and last modification are
Set to the current date and time.

IV-112 High-Level File Manager Routines

The File Manager
Result codes

noErr
bdNameErr

No error
Bad file name

10Err
nsvErr
vLckdErr
wPrErr

I/O error
No such volume
Software volume lock
Hardware volume lock

dupFNErr
dirFulErr
extFSErr

Duplicate file name and version
File directory full
External file system

—
vo)

og
oy

FUNCTION

FSDelete
(fileName:
[Not in ROM]

Str255;

vRefNum:

INTEGER)

:

OSErr;

FS Delete removes the closed file having the name fileName from the specified volume.
Note:

This function will delete both forks of a file.

Result codes

noErr
bdNamErr

extFSErr
fBsyErr

fLckdErr
fnfErr
ioErr
nsvErr
vLckdErr
wPrErr

No error
Bad file name

External file system
File busy

File locked
File not found
I/O error
No such volume
Software volume lock
Hardware volume lock

Changing Information About Files
All of the routines described in this section affect both forks of the file, and don’t require
the file to be open.
FUNCTION

GetFInfo
(fileName:
fndrinfo:
Finfo)

:

Str255;
OSErr;

vRefNum:
INTEGER;
[Notin ROM]

VAR

For the file having the name fileName on the specified volume, GetFInfo returns
information used by the Finder in fndrInfo (see the section “Information Used by the
Finder’).
Result codes

noErr
bdNamErr

No error
Bad file name

fnfErr
ioErr
nsvErr

File not found
I/O error
No such volume

extFSErr

paramErr

External file system

No default volume

High-Level File

Manager Routines IV-113

je)
~
po)
v2

rae
ar

Inside Macintosh
FUNCTION

SetFInfo

FInfo)

(fileName:

: OSErr;

Str255;

[Notin ROM]

vRefNum:

INTEGER;

fndrinfo:

For the file having the name fileName on the specified volume, SetFInfo sets information
used by the Finder to fndrInfo (see the section “Information Used by the Finder’).
Result codes

FUNCTION

noErr

No error

fLckdErr
fnfErr
ioErr
nsvErr
vLckdErr
wPrEtrr

File locked
File not found
I/O error
No such volume
Software volume lock
Hardware volume lock

extFSErr

External file system

SetFLock
(fileName:
[Not in ROM]

Str255;

vRefNum:

INTEGER)

SetFLock locks the file having the name fileName on the specified volume.
currently in use aren’t affected.
Result codes

FUNCTION

noErr

No error

fnfErr
ioErr
nsvErr
vLckdErr
wPrEtrr

File not found
I/O error
No such volume
Software volume lock
Hardware volume lock

extFSErr

>:

Access paths

External file system

RstF Lock
(fileName:
[Not in ROM]

Str255;

vRefNum:

INTEGER)

RstFLock unlocks the file having the name fileName on the specified volume.
paths currently in use aren’t affected.
Result codes

FUNCTION

noErr

No error

fnfErr
ioErr
nsvErr
vLckdErr
wPrEtr

File not found
I/O error
No such volume
Software volume lock
Hardware volume lock

extFSErr

OSErr;

:

OSErr;

Access

External file system

Rename
(oldName:
Str255;
vRefNum:
Str255)
>: OSErr;
[Not in ROM]

INTEGER;

newName:

Given a file name in oldName, Rename changes the name of the file to newName. Access
paths currently in use aren’t affected. Given a volume name in oldName or a volume
reference number in vRefNum, Rename changes the name of the specified volume to
newName.

IV-114 High-Level File Manager Routines

The File Manager
Warning:
Result codes

If you’re renaming a volume, be sure that both names end with a colon.
noErr
bdNamErr
dirFulErr

dupFNErr
extFSErr
fLokdErr
fnfErr
fsRnErr
ioErr |
nsvErr

paramErr

vLckdErr
wPrErr

No error
Bad file name
Directory full

Duplicate file name
External file system
File locked
File not found
Problem during rename
I/O error
No such volume

S
cs
S
<

Software volume lock

¥

No default volume

Hardware volume lock

LOW-LEVEL FILE MANAGER ROUTINES
This section contains information for programmers using the low-level Pascal or assembly-

language routines of the File Manager, and describes them in detail.

Most low-level File Manager routines can be executed either synchronously (meaning
that the application can’t continue until the routine is completed) or asynchronously
(meaning that the application is free to perform other tasks while the routine is executing).
Some, however, can only be executed synchronously because they use the Memory
Manager to allocate and release memory.
When an application calls a File Manager routine asynchronously, an I/O request is
placed in the file I/O queue, and control returns to the calling program—possibly
even before the actual I/O is completed. Requests are taken from the queue one at a time,
and processed; meanwhile, the calling program is free to work on other things.

The calling program may specify a completion routine to be executed at the end of an
asynchronous operation.

At any time, you can clear all queued File Manager calls except the current one by using the
InitQueue procedure. InitQueue is especially useful when an error occurs and you no
longer want queued calls to be executed.

Low-Level File Manager Routines IV-115

=

5

Inside Macintosh

Parameter Blocks
Routine parameters passed by an application to the File Manager and returned by the File
Manager to an application are contained in a parameter block, which is a data structure in
the heap or stack. When there are a number of parameters to be passed to, or returned
from, a routine, the parameters are grouped together in a block and a pointer to the block is
passed instead.
Most low-level calls to the File Manager are of the form
FUNCTION PBCallName
OSErr;

(paramBlock:

PtrToParamBlk;

async:

BOOLEAN)

PBCallName is the name of the routine. ParamBlock points to the parameter block

containing the parameters for the routine; its data type depends on the type of parameter
block.

If async is TRUE, the call is executed asynchronously; otherwise the call is

executed synchronously. The routine returns an integer result code of type OSErr. Each
routine description lists all of the applicable result codes, along with a short description of
what the result code means. Lengthier explanations of all the result codes can be found in
the summary at the end of this chapter.
Assembly-language note: When you call a File Manager routine, AO must point
to a parameter block containing the parameters for the routine. If you want the
routine to be executed asynchronously, set bit 10 of the routine trap word. You can
do this by supplying the word AS YNC as the second argument to the routine macro.
For example:
_Read

,ASYNC

You can set or test bit 10 of a trap word by using the global constant asyncTrpBit.
(This syntax applies to the Lisa Workshop Assembler; programmers using another
development system should consult its documentation for the proper syntax.)

All File Manager routines except InitQueue return a result code in DO.
There are many parameters used in the File Manager routines. To group them all together
in a single parameter block would be unmanageable, so several different parameter block
records have been defined. Figure 6 gives an overview of the various parameter blocks.

IV-116 Low-Level File Manager Routines

The File Manager
ParamBlkType

=

(ioParam, fileParam,
volumeParam, cntrlParam) ;
ParmBlkPtr =
“ParamBlockRec;
ParamBlockRec =
RECORD
qLink:
QElemPtr;
qType:
INTEGER;
ioTrap:
INTEGER;
ioCmdAddr:
Ptr;
ioCompletion:
ProcPtr;
ioResult:
OSErr;
LoNamePtr:
StringPtr;
LovRefNum:
INTEGER;
CASE ParamBlkType OF
joParam:
(ioRefNum:
INTEGER;
ioVersNum:
SignedByte;
ioPermssn:
SignedByte;
ioMisc:
Ptr;
ioBuffer:
Ptr;
ioReqCount:
LONGINT;
LoActCount:
LONGINT;
LoPosMode:
INTEGER;
ioPosOffset:
LONGINT} ;
fileParam:
(ioFRefNum:
INTEGER;
ioFVersNum:
SignedByte;
fillerl:
SignedByte;
ioFDirIndex:
INTEGER;
LloFlAttrib:
SignedByte;
LoFlVersNum:
SignedByte;
LoFlFndriInfo:
FInfo;
LoF1lNum:
LONGINT;
1oF1StBlk:
INTEGER;
LoFlLgLen:
LONGINT;
LoFlPyLen:
LONGINT;
LoF1RStBlk:
INTEGER;
ioF1RLgLen:
LONGINT;
ioF1RPyLen:
LONGINT;
ioFlCrDat:
LONGINT;
LoF1MdDat:
LONGINT) ;
volumeParam:
(filler2:
LONGINT;
LoVolIndex:
INTEGER;
iovCrDate:
LONGINT;
ioVLsBkUp:
LONGINT;
ioVAtrb:
INTEGER;
ioVNmF 1s
INTEGER;
iovDirSt:
INTEGER;
LoVBlLn:
INTEGER;
LoVNmA1Blks:
INTEGER;
LOVA1B1kSiz:
LONGINT;
LovClpSiz:
LONGINT;
1oA1B1St:

INTEGER}

LoVNxtFNum:
LONGINT?
LOVFrBlk:
INTEGER) ;
cntrlParam:
{used by Device Manager}
END;
CMovePBPtr
CMovePBRec

=
=

*CMovePBRec;
RECORD

qLink:
qType:
ioTrap:
ioCmdAddr:
ioCompletion:
ioResult:
ioNamePtr:
ioVRefNum:
fillerl:
ioNewName:
filler2:
ioNewDirID:
filler3:
ioDirID:

END;

HParmBlkPtr

(ioFRefNum:

INTEGER;

INTEGER;

LONGINT;
LONGINT;
INTEGER;

LoF1RPyLen:

LONGINT;

ioF1lRLgLen:

LoFlCrDat:
LloF1MdDat:

volumeParam:

StringPtr;
[1..2]

OF LONGINT;
LONGINT) ;

LONGINT;

LONGINT;
LONGINT) ;

(filler2:

LONGINT;
LONGINT;

LoVNmF

INTEGER;

LoVLsMod:
LoVAtrb:

ls:

LoVBitMap:

LoAllocPtr:

LoVNmAI1Blks:

INTEGER;

LONGINT;
INTEGER;

INTEGER;

INTEGER;

INTEGER;

LOVALB1LkSiz:

LONGINT;

LoVFrBlk:

INTEGER;

LlovClpSiz:
1oAl1B1St:
LOVNxtCNID:
lovSigWord:
iovDrvinfo:
iovDRefNum:
LOVFSID:
LoVBkUp:

LONGINT;
INTEGER;
LONGINT;
INTEGER;
INTEGER;

INTEGER;
INTEGER;
LONGINT;

iovSeqNum:
LoVWrCnt

INTEGER;
LONGINT;

LovDirCnt:
iovFndrinfo:

LONGINT;
ARRAY
[1..8]
OF LONGINT);

WDPBPtr =
WDPBRec =
qLink:

LONGINT;
LONGINT;

INTEGER;

iovCrDate:

loVol Index:

OSErr;

LONGINT;

INTEGER;

LoFlLgLen:
LoFlPyLen:
LoFlRStBlk:

LoF1StBlk:

END;

StringPtr;
INTEGER;

INTEGER;
SignedByte;
SignedByte;
Ptr;
Ptr;
LONGINT;
LONGINT;
INTEGER?
LONGINT) 7
SignedByte;
SignedByte;
INTEGER;
SignedByte;
SignedByte;
FInfo;
LONGINT;

Ptr;

ProcPtr;

“HParamBlockRec
RECORD
QElemPtr;
INTEGER;
INTEGER;
Ptr;
ProcPtr;
OSErr;
StringPtr;
INTEGER;
OF

ioFVersNum:
fillerl:
LoFDirIndex:
1oFlAttrib:
ioFlVersNum:
LloFlFndrInfo:
ioDirID:

iovFilcnt:

QElemPtr;

ARRAY

=

HParamBlockRec =
qLink:
qType:
ioTrap:
ioCmdAddr:
ioCompletion:
ioResult:
ioNamePtr:
iovRefNum:
CASE ParamBlkType
loParam:
(ioRefNum:
ioVersNum:
joPermssn:
ioMisc:
ioBuffer:
ioReqCount:
ioActCount:
LoPosMode:
ioPosOffset:
fileParam:

qType:

LONGINT;

“WDPBRec;
RECORD
QElemPtr;

INTEGER;

ioTrap:
ioCmdAddr:
LoCompletion:
LoResult:
ioNamePtr:

INTEGER;
Ptr;
ProcPtr;
OSErr;
StringPtr;

fillerls:
LoWDIndex:
LoWDProcID:

INTEGER;
INTEGER;
LONGINT;

filler2:

ARRAY

[1..7]

OF

INTEGER;

iovRefNum:

LoWDVRefNum:

LowDDirID:
END;

CInfoType
CInfoPBPtr
CInfoPBRec
qLink:

=
=

qType:

(hfileInfo,dirInfo);
*cInfoPBRec;
RECORD
QElemPtr;
INTEGER;

ioTrap:

ioCmdAddr:
loCompletion:
ioResult:
LoNamePtr:
LoVRefNum:
ioFRefNum:
ioFVersNum

fillerl:

INTEGER;

Ptr;
ProcPtr;
OSErr;
StringPtyr;
INTEGER;
INTEGER;
SignedByte;

SignedByte;

ioFDirIndex:
INTEGER;
ioFlAttrib:
SignedByte;
filler2:
SignedByte;
CASE CInfoType OF
hFileInfo:
(iloFlFndrInfo:
FInfo;
ioDirID:
LONGINT?

ioF1StBlk:

INTEGER;

ioFlLgLen:

=

LONGINT;
LONGINT;
LONGINT;
LONGINT;

LoF1lXFndrinfo:
LoFlParID:
LoF1lClpSiz:
dirInfo:
(ioDrUsrWds:

FiInfo;
LONGINT;
LONGINT) ;

LONGINT;

ioDrDirID:
LoDrNmFls:
filler3:

ARRAY
[1..8]
OF INTEGER;
LONGINT;
INTEGER;
ARRAY
[1..9]

ioDrCrDat:
ioDrMdDat:
ioDrBkDat:
ioDrFndrInfo:

LONGINT;
LONGINT;
LONGINT;
ARRAY
[1..8]

FCBPBPtr
FCBPBRec

=
=

OF

INTEGER;

OF

INTEGER;

LONGINT) ;
*FCBPBRec
RECORD

qLink:
qType:
ioTrap:
ioCmdAddr:
ioCompletion:
ioResult:
ioNamePtr:

QElemPtr;
INTEGER;
INTEGER;
Ptr;
ProcPtr;
OSErr;
StringPtr;

iovRefNum:

INTEGER;

ioRefNum:
filler:
LoFCBIndx:
LoFCBF1Nm:
LoFCBFlags:
LloFCBStBlks:
LoFCBEOF:
LoFCBPLen:

INTEGER;
INTEGER;
LONGINT;
LONGINT;
INTEGER;
INTEGER;
LONGINT;
LONGINT;

ioFCBVRefNum:
LoFCBClpSiz:

INTEGER;
LONGINT;

LoFCBCrPs:

LoFCBParID:
END;

~

INTEGER;

LONGINT;

loDrParID:
END;

<
a)

os

ioF1lRLgLen:
ioF1lRPyLen:
loFlCrDat:
LoF1MdDat:
LoF1BkDat:

7
oO

LONGINT;

ioFlPyLen:

LoF1lRStBlk:

pen

No

LONGINT;

LONGINT;

INTEGER;

INTEGER;

LONGINT) ;

Figure 6. File Manager Parameter Block Records

Low-Level File Manager Routines IV-117

o

Inside Macintosh

ParamBlockRec is the record used by all routines in the 64K ROM version of the File

Manager; these routines include general I/O operations, as well as access to information
about files and volumes. The RAM-based version of the File Manager provides additional
calls that are slight extensions of certain basic routines, allowing you to take advantage of
the hierarchical file directory. For instance, HOpen is an extension of the Open call that lets
you use a directory ID and a pathname to specify the file to be opened. These hierarchical
routines use the record HParamBlockRec, which, as you can see from Figure 6, is a
superset of ParamBlockRec.
Assembly-language note: The hierarchical extensions of certain basic File
Manager routines are actually not new calls. For instance, Open and _HOpen both
trap to the same routine. The trap word generated by the _HOpen macro is the same
as the trap word that would be generated by invoking the _Open macro with bit 9 set.
(Note that this is the same bit used in the Device Manager to indicate that a particular
call should be executed immediately.) The setting of this bit tells the File Manager to
expect a larger parameter block containing the additional fields (such as a directory
ID) needed to handle a hierarchical directory volume. You can set or test bit 9 of a
trap word by using the global contstant hfsBit.
Three parameter block records—CInfoPBRec, CMovePBRec, and WDPBRec—are used
by routines that deal specifically with the hierarchical file directory. These routines work
only with the 128K ROM version of the File Manager.
Finally, the record FCBPBRec is used by a single routine, PBGetFCBInfo, to gain access
to the contents of a file’s file control block; this routine also works only with the 128K
ROM version of the File Manager.
Assembly-language note: You can invoke each of the routines that deal
specifically with the hierarchical file directory with a macro that has the same name as
the routine preceded by an underscore. These macros, however, aren’t trap macros
themselves; instead they expand to invoke the trap macro _HFSDispatch. The File
Manager determines which routine to execute from the routine selector, an integer
that’s placed in register DO. The routine selectors are as follows:
Routine

Call number

OpenWD

1

CloseWD

2

GetWDInfo
GetFCBInfo
GetCatInfo
SetCatInfo
SetVolinfo

7
8
9
10
11

CatMove
DirCreate

LockRng
UnlockRng

5
6

=

16
17

Warning: Using these routines on a Macintosh equipped only with the 64K ROM
will result in a system error.
IV-118 Low-Level File Manager Routines

The File Manager
Three of the records—ParamBlockRec, HParamBlockRec, and CInfoPBRec—have CASE

statements that separate some of their parameters into functional subsections (also known

as variants of the record).

The other records—CMovePBRec, WDPBRec,

FCBPBRec—are not divided in this way.

and

All of the parameter block records used by the File Manager begin with eight fields of
standard information:
qLink:

QElemPtr;

{next

loTrap:

INTEGER;

{routine

trap}

{volume

reference

qType:

INTEGER;

ioCmdAddr :
ioCompletion:
ioResult:
ioNamePtr:

ioVRefNum:

Ptr;
ProcPtr;
OSErr;
StringPtr;

INTEGER;

{queue

queue

type}

entry}

So
oe

{routine address}
{completion routine}
{result code}
{pathname}
{

or

working

=

number,

directory

drive

reference

number,

number}

}

The first four fields in each parameter block are handled entirely by the File Manager, and

most programmers needn’t be concerned with them; programmers who are interested in
them should see the section “Data Structures in Memory”’.

JOCompletion contains a pointer to a completion routine to be executed at the end of an

asynchronous call; it should be NIL for asynchronous calls with no completion routine,
and is automatically set to NIL for all synchronous calls.
Warning:

Completion routines are executed at the interrupt level and must preserve

all registers other than AO, Al, and DO-D2.

Your completion routine must not make

any Calls to the Memory Manager, directly or indirectly, and can’t depend on handles
to unlocked blocks being valid. If it uses application globals, it must also ensure that
register A5 contains the address of the boundary between the application globals and
the application parameters; for details, see SetUpA5 and RestoreA5 in the Operating
System Utilities chapter.
When your completion routine is called, register AO points to the parameter block of the
asynchronous call and register DO contains the result code.
Routines that are executed asynchronously return control to the calling program with the

result code noErr as soon as the call is placed in the file I/O queue. This isn’t an indication
of successful call completion, but simply indicates that the call was successfully queued.

To determine when the call is actually completed, you can poll the ioResult field; this field
is set to 1 when the call is made, and receives the actual result code upon completion of the
call. Completion routines are executed after the result code is placed in ioResult.

Low-Level File Manager Routines IV-119

z
~
ft
o

7

Inside Macintosh

IONamePtr points to a pathname (i.e. it does not itself contain the characters. It can be
either a full or partial pathname. In other words, it can be a volume name (that is, the name
of the root directory), a file name, or a concatenation of directory and file names.

If

ioNamePtr is NIL or points to an improper pathname, an error is returned. For routines
that access directories, if a directory ID is specified, ioNamePtr can be NIL.
Note: Although ioNamePtr can be a full pathname, you should not require users to
enter full pathnames.
JOVRefNum contains either a volume reference number, a drive number, or a working

directory reference number.

The remainder of the parameters are presented below, organized by parameter block

records.

1OParam Variant (ParamBlockRec and HParamBlockRec)
The ioParam variants of ParamBlockRec and HParamBlockRec are identical; the fields are

presented below.
ioParam:

(ioRefNum:

ioVersNum:
ioPermssn:
ioMisc:
ioBuffer:
ioReqCount:
ioActCount:
1oPosMode:
ioPosOffset:

INTEGER;

SignedByte;
SignedByte;
Ptr;
Ptr;
LONGINT;
LONGINT;
INTEGER;
LONGINT) ;

{path

reference

number}

{version number}
{read/write permission}
{miscellaneous }
{data buffer}
{requested number of bytes}
{actual number of bytes}
{positioning mode and newline
{positioning offset}

character}

For routines that access open files, the File Manager determines which file to access by

using the path reference number in ioRefNum.

64K ROM note: The 64K ROM version of the File Manager also allows the
specification of a version number to distinguish between different files with the same
name. Version numbers are generally set to 0, though, because the Resource
Manager, Segment Loader, and Standard File Package won’t operate on files with
nonzero version numbers, and the Finder ignores version numbers.
JOPermssn requests permission to read or write via an access path, and must contain one of

the following values:
CONST

fsCurPerm
fsRdPerm
fsWrPerm
fsRdWrPerm
fsRdWrShPerm=

=
=
=
=

0;
1;
2;
3;
4;

{whatever is
{request for
{request for
{request for
{ permission}
{request for

IV-120 Low-Level File Manager Routines

currently allowed}
read permission only}
write permission}
exclusive read/write
}
shared

read/write

permission}

The File Manager
This request is compared with the open permission of the file. If the open permission
doesn’t allow I/O as requested, a result code indicating the error is returned.

Warning: To ensure data integrity be sure to lock the portion of the file you’ll be
using if you specify shared write permission.

The content of ioMisc depends on the routine called. It contains either a new logical end-

of-file, a new version number, a pointer to an access path buffer, or a pointer to a new
pathname. Since ioMisc is of type Ptr, you’ll need to perform type coercion to correctly
interpret the value of ioMisc when it contains an end-of-file (a LONGINT) or version
number (a SignedByte).
JOBuffer points to a data buffer into which data is written by Read calls and from which
data is read by Write calls. IOReqCount specifies the requested number of bytes to be
read, written, or allocated. I[OActCount contains the number of bytes actually read,
written, or allocated.

IOPosMode and ioPosOffset specify the position of the mark for Read, Write, LockRng,
UnlockRng, and SetFPos calls. IOPosMode contains the positioning mode; bits 0 and 1
indicate how to position the mark, and you can use the following predefined constants to
set or test their value:
CONST

fsAtMark
fsFromStart
fsFromLEOF
fsFromMark

=
=
=
=

0;
1;
2;
3;

{at current mark}
{set mark relative
{set mark relative
{set mark relative

to
to
to

beginning of file}
logical end-of-file}
current mark}

If you specify fsAtMark, ioPosOffset is ignored and the operation begins wherever the
mark is currently positioned. If you choose to set the mark (relative to either the beginning
of the file, the logical end-of-file, or the current mark), ioPosOffset must specify the byte
offset from the chosen point (either positive or negative) where the operation should begin.
Note: Advanced programmers: Bit 7 of ioPosMode is the newline flag; it’s set if
read operations should terminate at a newline character. The ASCII code of the

newline character is specified in the high-order byte of ioPosMode. If the newline
flag is set, the data will be read one byte at a time until the newline character is
encountered, 10ReqCount bytes have been read, or the end-of-file is reached. If the
newline flag is clear, the data will be read one byte at a time until ioReqCount bytes
have been read or the end-of-file is reached.

To have the File Manager verify that all data written to a volume exactly matches the data in
memory, make a Read call right after the Write call. The parameters for a read-verify
operation are the same as for a standard Read call, except that the following constant must
be added to the positioning mode:
CONST

rdVerify

=

64;

{read-verify

mode}

The result code ioErr is returned if any of the data doesn’t match.

Low-Level File Manager Routines [V-121

pou
\O

ar

7

g
jon
poe)
TT?
fae)
ae |

Inside Macintosh

FileParam Variant (ParamBlockRec and HParamBlockRec)
The fileParam variants of ParamBlockRec and HParamBlockRec are identical, with one

exception: The field ioDirID in HParamBlockRec is called ioFINum in ParamBlockRec.
The fields of the fileParam variant of HParamBlockRec are as follows:
fileParam:
(ioFRefNum:

1oFVersNum:
fillerl:
1oFDiriIndex:
1oFlAttrib:

ioFlVersNum:
ioFlFndriInfo:
ioDirID:
1oF1StBlk:
ioFlLgLen:
ioF1lPyLen:
10oF1RStBlk:

ioF1RLgLen:
ioF1RPyLen:
1oF1CrDat:
1OF1MdDat :

INTEGER;

SignedByte;
SignedByte;

{path reference
number}
{version number}
{not used}
{index}
{file attributes}
{version number}

LONGINT;

{directory

SignedByte;
SignedByte;
INTEGER;

Finfo;

INTEGER;
LONGINT;
LONGINT;

INTEGER;
LONGINT;
LONGINT;
LONGINT;

LONGINT) ;

{information

ID

used
or

by

file

the

{first allocation block
{logical end-of-file of

{physical

end-of-file

{date
{date

time
time

Finder}

number}

of

of data fork}
data fork}

data

fork}

{first allocation block of resource fork}
{logical end-of-file of resource fork}
{physical end-of-file of resource fork}
and
and

of
of

creation}
last modification}

IOFDirIndex can be used with the PBGetFInfo and PBHGetFInfo to index through the

files in a given directory.

Warning: When used with GetFileInfo, ioFDirIndex will index only the files in a
directory. To index both files and directories, you can use ioFDirIndex with
PBGetCatInfo.
JOFIAttrib contains the following file attributes:

Bit

Meaning

0
2

Set if file is locked
Set if resource fork is open

4

Set ifadirectory

3

7

Set if data fork is open

—

Set if file (either fork) is open

When passed to a routine, ioDirID contains a directory ID; it can be used to refer to a
directory or, in conjuction with a partial pathname from that directory, to other files and
directories. If both a directory ID and a working directory reference number are provided,
the directory ID is used to identify the directory on the volume indicated by the working
directory reference number. In other words, a directory ID specified by the caller will
override the working directory referred to by the working directory reference number. If
you don’t want this to happen, you can set ioDirID to 0. (If no directory is specified
through a working directory reference number, the root directory ID will be used.)
When returned from a routine, ioDirID contains the file number of a file; most

programmers needn’t be concerned with file numbers, but those interested can read the
section “Data Organization on Volumes”.

IV-122 Low-Level File Manager Routines

The File Manager

IOFIStBlk and ioFIRStBlk contain 0 if the filé’s data or resource fork is empty,

respectively; they’re used only with flat volumes. The date and time in the ioFlCrDat and
ioFl1MdDat fields are specified in seconds since midnight, January 1, 1904.

VolumeParam Variant (ParamBlockRec)
When you call GetVolInfo, you’ll use the volumeParam variant of ParamBlockRec:
volumeParam:
(filler2:

ioVoliIndex:
iovCrDate:
LOVLSBkUp:
10oVAtrb:

LoVNmF 1s:
i1ovDirSt:
10VB1Ln:

LONGINT;

INTEGER;
LONGINT;

LONGINT;
INTEGER;

INTEGER;
INTEGER;
INTEGER;

1LOVNMA1B1lks:
10VA1B1kSiz:

INTEGER;
LONGINT;

LOVNXtFNum:
LOVFrBlk:

LONGINT;
INTEGER) ;

10oVClpSiz:
i0A1B1St:

LONGINT;
INTEGER;

{not

ae
>

used}

{index}
{date and time

of

initialization}

{date and time of last
{volume
attributes}

modification}

{number of files in root directory}
{first block of directory}
{length of directory in blocks}
{number of allocation blocks}
{size of allocation blocks}

{number of bytes to allocate}
{first blockin volume block map}
{next unused file
{number of unused

number}
allocation

blocks}

IOVolIndex can be used to index through all the mounted volumes; using an index of 1

accesses the first volume mounted, and so on. (For more information on indexing, see the
section “Indexing” above.)

IOVLsBkUp contains the date and time the volume information was last modified (this is
not necessarily when it was flushed). (This field is not modified when information is
written to a file.)

Note:

The name ioVLsBkUp is actually a misnomer; this field has always contained

the date and time of the last modification to the volume, not the last backup.

Most programmers needn’t be concerned with the remaining parameters, but interested

programmers can read the section “Data Organization on Volumes”.

VolumeParam Variant (HParamBlockRec)
When you call HGetVInfo and SetVolInfo, you’ll use the volumeParam variant of
HParamBlockRec. This is a superset of the volumeParam variant of ParamBlockRec; the
names and functions of certain fields have been changed, and new fields have been added:
volumeParam:
(filler2:
10VolIndex:
10VCrDate:
10VLSMod:
1oVAtrb:

LONGINT;
INTEGER;
LONGINT;
LONGINT;
INTEGER;

{not used}
{index}
{date and time of initialization}
{date and time of last modification}
{volume
attributes }

ioAllocPtr:

INTEGER;

{block

1ioVNmF 1s:
1oVBitMap:

INTEGER;
INTEGER;

{number of files in root directory}
{first block of volume bit map}
at

which

—"
\O

next

new

file

starts}

Low-Level File Manager Routines IV-123

<=
=

pa
e

Inside Macintosh
1LOVNMAILBlks:
1OVA1B1kSiz:

INTEGER;
LONGINT;

{number of allocation blocks}
{size of allocation blocks}

LOVNXtCNID:
10OVFrBlk:

LONGINT;
INTEGER;

{next unused file
{number of unused

number}
allocation

10OVFSID:
LOVBkUp:
ioVSeqNum:

INTEGER;
INTEGER;

INTEGER;
LONGINT;
INTEGER;

{drive number}
{driver reference

number}

1oVWrCnt
10VFilCnt:
LovDirCnt:
1oVFndrinfo:

LONGINT;
LONGINT;
LONGINT;
ARRAY[1..8]

{volume write count}
{number of files
on volume}
{number of directories
on volume}
OF LONGINT);
{information
used by
{ Finder}

10oVClpSiz:
10A1B1St:

ioVSigwWord:

1oVDrvinfo:
10VDRefNum:

LONGINT;
INTEGER;

INTEGER;

{number of bytes to allocate}
{first block in volume block map}
{volume
{file
{date
{used

signature}

blocks}

system handling this volume}
and time of last backup}
internally}

the

}

TOVolindex can be used to index through all the mounted volumes; using an index of 1
accesses the first volume mounted, and so on.

section “Indexing” above.)

(For more information on indexing, see the

IOVLsMod contains the date and time the volume information was last modified (this is not
necessarily when it was flushed). (This field is not modified when information is written
to a file.)
Note: IOVLsMod replaces the field ioVLsBkUp in ParamBlockRec. The name
io VLsBkUp was actually a misnomer; this field has always contained the date and
time of the last modification, not the last backup. Another field, ioVBkUp, contains
the date and time of the last backup.
IOVClIpSiz can be used to set the volume clump size in bytes; it’s used for files that don’t
have a clump size defined as part of their file information in the catalog. To promote file
contiguity and avoid fragmentation, space is allocated to a file not in allocation blocks but in
clumps. A clump is a group of contiguous allocation blocks. The clump size is always a
multiple of the allocation block size; it’s the minimum number of bytes to allocate each time
the Allocate function is called or the end-of-file is reached during the Write routine.
IOVSigWord contains a signature word identifying the type of volume; it’s $D2D7 for flat
directory volumes and $4244 for hierarchical directory volumes. The drive number of the
drive containing the volume is returned in ioDrvInfo. For on-line volumes, ioVDRefNum
returns the reference number of the I/O driver for the drive identified by ioDrvInfo.
IOVESID is the file-system identifier. It indicates which file system is servicing the
volume; it’s 0 for File Manager volumes and nonzero for volumes handled by an external
file system.
IOVBkUp specifies the date and time the volume was last backed up (it’s 0 if never
backed up).

JOVNmFIs contains the number of files in the root directory. IOVFilCnt contains the total
number of files on the volume, while ioVDirCnt contains the total number of directories

(not including the root directory).

IV-124 Low-Level File Manager Routines

The File Manager
Most programmers needn’t be concerned with the other parameters, but interested

programmers can read the section “Data Organization on Volumes”.
CinfoPBRec

The routines GetCatInfo and SetCatInfo are used for getting and setting information about
the files and directories within a directory.

With files, you’ll use the following 19

additional fields after the standard eight fields in the parameter block record CInfoPBRec:
ioFRefNum:
ioFVersNum:
fillerl:

ioFDirIndex:

ioFlAttrib:

INTEGER;
SignedByte;

o
=

{index}

po

{not

used}

=

filler2:
hFileiInfo:
(10F1lFndrinfo:
ioDirID:

SignedByte;

{file

FInfo;
LONGINT;

{information used by the Finder}
{directory ID or file number}

ioFlLgLen:
1oF1PyLen:

LONGINT;
LONGINT;

{logical end-of-file of data fork}
{physical end-of-file of data fork}

ioF1lRLgLen:
ioF1RPyLen:
ioF1CrDat:

LONGINT;
LONGINT;
LONGINT ;

{ fork}
{logical end-of-file of resource fork}
{physical end-of-file of resource fork}
{date and time of creation}

1oF1BkDat:

LONGINT;

{date

ioF1StBlk:

ioF1RStBlk:

ioF1lMdDat:

SignedByte;

INTEGER;

INTEGER;

LONGINT;

10F1XFndrinfo:

FXInfo;

10oF1ParID:
1oF1ClpSiz:

LONGINT;
LONGINT) ;

{not

attributes}

a

used}

{first

allocation

block

of

data

{first

allocation

block

of

resource

{date

and

and

time

time

of

of

last

last

fork}

}

modification}

backup}

{additional
information
used by the
}
{ Finder}
{file's parent
directory
ID
(integer) }
{file's
clump size}

JOFDirIndex can be used with the function PBGetCatInfo to index through the files and
directories in a given directory.

For each iteration of the function, you can determine

whether it’s a file or a directory by testing bit 4 (the fifth least significant bit) of ioFlAttrib.
You can test for a directory by using the Toolbox Utilities BitTst function in the following
manner (remember, the Toolbox Utilities routines reverse the standard 68000 notation):
BitTst (@myCInfoRec.ioFlAttrib,3)

JOF1Attrib contains the following

attributes:

Bit

Meaning

0
2
3
4
7

Set if file is locked
Set if resource fork is open
Set if data fork is open
Set if a directory
Set if file (either fork) is open

=

{path reference number}
{version number}

SignedByte;

| INTEGER;

©

When passed to a routine, ioDirID contains a directory ID; it can be used to refer to a
directory or, in conjuction with a partial pathname from that directory, to other files and
directories. If both a directory ID and a working directory reference number are provided,
Low-Level File Manager Routines IV-125

Inside Macintosh

the directory ID is used to identify the directory on the volume indicated by the working
directory reference number. In other words, a directory ID specified by the caller will
override the working directory referred to by the working directory reference number. If
you don’t want this to happen, you can set ioDirID to 0. (If no directory is specified
through a working directory reference number, the root directory ID will be used.)
Warning: With files, ioDirID returns the file number of the file; when indexing
with GetCatInfo, you’ll need to reset this field for each iteration.
IOFIStBlk and ioFIRStBlk contain 0 if the file’s data or resource fork is empty,
respectively; they’re used only with flat volumes. The date and time in the ioFlCrDat,
i0F1MdDat, and ioF1BkDat fields are specified in seconds since midnight, January 1, 1904.

IOF|ParID contains the directory ID of the file’s parent. IOFICIpSiz is the clump size to be
used when writing the file; if it’s 0, the volume’s clump size is used when the file is
opened.

With directories, you’ll use the following 14 additional fields after the standard eight fields
in the parameter block record CInfoPBRec:
1oFRefNum:

INTEGER;

{file

reference

ioFVersNum
fillerl:

SignedByte;
SignedByte;

{version number}
{not used}

ioFlAttrib:
filler2:
dirinfo:

SignedByte;
SignedByte;

{file attributes}
{not used}

1oFDirIndex:

INTEGER;

(loDrUsrwWds:

Dinfo;

filler3:

ARRAY[1..9]

ioDrDirID:
1oDrNmF 1s:

ioDrCrDat:
ioDrMdDat :
i1oDrBkDat :
ioDrFndrinfo:
1oDrParID:

LONGINT;
LONGINT;
LONGINT;
DXInfo;
LONGINT)

{index}

{information

LONGINT;
INTEGER;

;

number}

{directory
{number of

OF

INTEGER;

used

ID}
files
{not

by

in

the

Finder}

directory}

used}

{date and time of creation}
{date and time of last modification}
{date and time of last backup}
{additional information used by the
{ Finder}
{directory's parent directory ID }
{

}

(integer) }

JOFDirIndex can be used with the function PBGetCatInfo to index through the files and
directories in a given directory. For each iteration of the function, you can determine
whether it’s a file or a directory by testing bit 4 of ioFlAttrib.
When passed to a routine, ioDrDirID contains a directory ID; it can be used to refer to a
directory or, in conjuction with a partial pathname from that directory, to other files and
directories. If both a directory ID and a working directory reference number are provided,
the directory ID is used to identify the directory on the volume indicated by the working
directory reference number. In other words, a directory ID specified by the caller will
override the working directory referred to by the working directory reference number. If
you don’t want this to happen, you can set ioDirID to 0. (If no directory is specified
through a working directory reference number, the root directory ID will be used.)

With directories, ioDrDirID returns the directory ID of the directory.

IV-126 Low-Level File Manager Routines

The File Manager
IODrNwmF's is the number of files and directories contained in this directory (the valence of
the directory).
The date and time in the ioDrCrDat, ioDrMdDat, and ioDrBkDat fields are specified in

seconds since midnight, January 1, 1904.

IODrParID contains the directory ID of the directory’s parent.
a

\O

CMovePBRec

fae)

When you call CatMove to move files or directories into a different directory, you'll use the
following six additional fields after the standard eight fields in the parameter block record

CMovePBRec:
fillerl:

ioNewName

3©
:

filler2:
1oNewDirID:
filler3:
10DirID:

LONGINT;

{not

LONGINT;
LONGINT;
ARRAY[1..2]
LONGINT) ;

{not used}
{directory
ID of new directory}
OF LONGINT;
{not used}
{directory
ID of current
directory}

StringPtr;

{name

used}

of

new

directory}

IONewName and ioNewDirID specify the name and directory ID of the directory to which

the file or directory is to be moved. IODirID (used in conjuntion with the ioVRefNum and

ioNamePtr) specifies the current directory ID of the file or directory to be moved.

WDPBRec
When you call the routines that open, close, and get information about working directories,
you'll use the following six additional fields after the standard eight fields in the parameter
block record WDPBRec:
fillerl:

INTEGER;

{not

i1oWDProcID:
ioWDVRefNum:

LONGINT;
INTEGER;

{working
{working

directory user identifier}
directory's volume reference

LONGINT);

{working

directory's

10oWDIndex:

filler2:

LOWDDirID:

<=
=

INTEGER;

ARRAY[1..7]

used}

{index}

OF

INTEGER;

{not

used}

directory

number}

ID}

JOWD Index can be used with the function PBGetWDInfo to index through the current
working directories.
IOWDProcID is an identifier that’s used to distinguish between working directories set up
by different users; you should use the application’s signature (discussed in the Finder
Interface chapter) as the ioWDProcID.

Routine Descriptions
Each routine description includes the low-level Pascal form of the call and the routine’s
assembly-language macro. A list of the parameter block fields used by the call is also
given.
Low-Level File Manager Routines IV-127

Inside Macintosh

Assembly-language note: The field names given in these descriptions are those
found in the Pascal parameter block records; see the summary at the end of this

chapter for the names of the corresponding assembly-language offsets. (The names
for some offsets differ from their Pascal equivalents, and in certain cases more than

one name for the same offset is provided.)

The number next to each parameter name indicates the byte offset of the parameter from the
start of the parameter block pointed to by register AO; only assembly-language
programmers need be concerned with it. An arrow next to each parameter name indicates
whether it’s an input, output, or input/output parameter:

Arrow

Meaning

—>
<—

Parameter is passed to the routine
Parameter is returned by the routine

<—>

Parameter is passed to and returned by the routine

Warning: You must pass something (even if it’s NIL) for each of the parameters
shown for a particular routine; if you don’t, the File Manager may use garbage that’s
sitting at a particular offset.

Initializing the File /O Queue
PROCEDURE

FInitQueue;

Trap macro

_InitQueue

FInitQueue clears all queued File Manager calls except the current one.

Accessing Volumes
To get the volume reference number of a volume, given the path reference number of a file

on that volume, both Pascal and assembly-language programmers can call the high-level
File Manager function GetVRefNum. Assembly-language programmers may prefer calling
the function GetFCBInfo (described below in the section “Data Structures in Memory”).
FUNCTION

PBMountVol

Trap macro

(paramBlock:

ParmBlkPtr)

:

OSErr;

_MountVol

Parameter block
<—
16
<—>
22

ioResult
ioVRefNum

word
word

PBMountVol mounts the volume in the drive specified by ioVRefNum, and returns a

volume reference number in ioVRefNum. If there are no volumes already mounted, this
volume becomes the default volume. PBMountVol is always executed synchronously.

IV-128 Low-Level File Manager Routines

The File Manager

Note: When mounting

hierarchical volumes, PBMountVol opens two files needed

for maintaining file directory and file mapping information. PBMountVol can fail if
there are no access paths available for these two files; it will return tmfoErr as its
function result.
Resultcodes

= noErr
badMDBErr
extFSErr
ioErr
memFullErr

noMacDskErr

No error
_ Bad master directory block
External file system
I/O error
§ Not enough room in heap zone

nsDrvErr

paramErr

tmfoErr

volOnLinErr

FUNCTION PBGetVInfo
OSErr;

Trap macro

Nota Macintosh disk
No

7

Volume already on-line

(paramBlock:

18

1oCompletion
1oResult

ioNamePtr

<—
<—

46
48

ioVNmAIBlks
ioVAIBIkSiz

56
58
62

ioAIBISt
ioVNxtFNum_
ioVFrBlk

<—
<—
<—

=

Too many files open

22
28
30
34

<—

=

Bad drive number

<->
—>
<—
<—
<—
<——
<—
<—

7

such drive

ParmBlkPtr;

async:

BOOLEAN)

_GetVolInfo

Parameter block
—>
12
<—
16

<>

S
es

ioVRefNum _
ioVolIndex
i0VCrDate
ioVLsBkUp _

38
ioVAtrb
40
ioVNmFls
42 = ioVDirSt
44
ioVBILn

52

i0VCipSiz

pointer
word

pointer

word
word
long word
long word
word
word
word
word

word
long word

long word

word
long word
word

PBGetVInfo returns information about the specified volume. If ioVolIndex is positive, the
File Manager attempts to use it to find the volume; for instance, if ioVolIndex is 2, the File
Manager will attempt to access the second mounted volume. If ioVolIndex is negative, the
File Manager uses ioNamePtr and ioVRefNum in the standard way (described in the
section “Specifying Volumes, Directories, and Files”) to determine which volume. If
10 VolIndex is 0, the File Manager attempts to access the volume by using ioVRefNum

only. The volume reference number is returned in ioVRefNum, and a pointer to the
volume name is returned in ioNamePtr (unless ioNamePtr is NIL).
If a working

directory reference number is passed in ioVRefNum (or if the default directory

is a subdirectory), the number of files and directories in the specified directory (the

directory’s valence) will be returned in ioVNmFls. Also, the volume reference number
won’t be returned; ioVRefNum will still contain the working directory reference number.
Low-Level File Manager Routines IV-129

Inside Macintosh

Warning: JOVNmAIBlks and ioVFrBlks, which are actually unsigned integers, are
clipped to 31744 ($7C00) regardless of the size of the volume.
Result codes

noErr
nsvErr

No error
No such volume

paramErr
FUNCTION

PBHGetVinfo

No default volume

(paramBlock:

OSErr;

HParmBlkPtr;

Trap macro

_HGetVInfo

Parameter block
—>
<—
<—>
<>

12
16
18
22

ioCompletion
ioResult
ioNamePtr
ioVRefNum_

pointer
word
pointer
word

<—
<—
<—
<—
<—
<—
<—
<—
<—
<—
<—
<—
<
<—

40
42.
44
46
48
52
56
58
62
64
66
68
70
72

ioVNmfFls
1ioVBitMap
jio0VAllocPtr
ioVNmAIBlks
ioVAIBIkSiz
10VCIpSiz
1i0AIBlSt
ioVNxtFNum
i0VFrBlk
ioVSigWord
ioVDrviInfo
ioVDRefNum_
i0VFSID
ioVBkUp

word
word
word
word
long word
long word
word
long word
word
word
word
word
word
long word

<—
<—
<—
<—

78
82
86
90

—>
<—
<—
<—

<—

28
30
34
38

76

ioVolIndex
ioVCrDate
ioVLsMod
ioVAtrb

ioVSeqNum_

ioVWrCnt
ioVFilCnt
i0VDiCnt
ioVFndrInfo

async:

BOOLEAN)

word
long word
long word
word

word

long word
long word
long word
32 bytes

PBHGetVInfo is similar in function to PBGetVInfo but returns a larger parameter block.
In addition, PBHGetVInfo always returns the volume reference number in ioVRefNum

(regardless of what was passed in). Also, ioVNmAIBlks and ioVFrBlks are not clipped as

they are by PBGetVInfo.
Resultcodes

|

noErr

No error

paramErr

No default volume

nsvErr

No such volume

IV-130 Low-Level File Manager Routines

The File Manager
FUNCTION

PBSetVInfo

(paramBlock;

OSErr;

‘Trap macro

HParmBlkPtr;

async:

BOOLEAN)

_SetVolinfo

Parameter block

—>

12.

i0Completion

pointer

—>
—>
—>
—>
—>

18
22
30
34
38

ioNamePtr
i10VRefNum
ioVCrDate
ioVLsMod
ioVAtrb

pointer
word
long word
long word
word

—>
—>
—>

72
76
90

ioVBkUp
i0VSeqNum_
ioVFndrInfo

long word
word
32 bytes

<—

—>

16

52

1oResult

ioVClpSiz

word

—"
\o

i

o

je)
mj
pk)
45e]
fae)

long word

Lear |

PBSetVInfo lets you modify information about volumes. A pointer to a new name for the
volume can be specified in ioNamePtr. The date and time of the volume’s creation and
modification can be set with ioVCrDate and ioVLsMod respectively. Only bit 15 of
10 V Atrh can be changed; setting it locks the volume.
Note: The volume cannot be specified by name; you must use either the volume
reference number or the drive number.
Warning:

PBSetVInfo operates only with the hierarchical version of the File

Manager; if used on a Macintosh equipped only with the 64K ROM version of the

File Manager, it will generate a system error.
Result codes

FUNCTION

noErr

nsvErr
paramErr

PBGetVol

Trap macro
Parameter block

—>

<—
<—
<—

No error

No such volume
No default volume

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

:

OSErr;

_GetVol

12

16
18
22

10Completion

ioResult
ioNamePtr
ioVRefNum

pointer
word
pointer
word

PBGetVol returns a pointer to the name of the default volume in ioNamePtr (unless
ioNamePFtr is NIL) and its volume reference number in ioVRefNum. If a default directory
was set with a previous PBSetVol call, a pointer to its name will be returned in ioNamePtr
and its working directory reference number in i0VRefNum.
Result codes

noErr
nsvEir

No error
No default volume

Low-Level File Manager Routines IV-131

Inside Macintosh
FUNCTION

PBHGetVol

(paramBlock:

Trap macro

_HGetVol

Parameter block
—>
<—
<—
<—
<—
<—
<—

12
16
18
22
28
32
48

ioCompletion
1ioResult
1oNamePtr
ioVRefNum
ioWDProcID
ioWDVRefNum
ioWDDirID

WDPBPtr;

async:

BOOLEAN)

:

OSErr;

pointer
word
pointer
word
long word
word
long word

PBHGetVol returns the default volume and directory last set by either a PBSetVol or a

PBHSetVol call. The reference number of the default volume is returned in ioVRefNum.

Warning:

IOVRefNum will return a working directory reference number (instead

of the volume reference number) if, in the last call to PBSetVol or PBHSetVol, a

working directory reference number was passed in this field.

The volume reference number of the volume on which the default directory exists is
returned in ioWDVRefNum. The directory ID of the default directory is returned in
ioWDDirrID.
Resultcodes

FUNCTION

noErr
nsvErr

PBSetVol

Trap macro

No error
No default volume

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

:

OSErr;

_SetVol

Parameter block

—>

<—
—>

—>

12

16
18

22

ioCompletion

ioResult
ioNamePtr

ioVRefNum

pointer

word
pointer
word

PBSetVol sets the default volume to the mounted volume specified by ioNamePtr or
ioVRefNum.

directory.

On hierarchical volumes, PBSetVol also sets the root directory as the default

Result codes

noErr
bdNamErr
nsvErr

paramErr

No error
Bad volume name
No such volume

No default volume

IV-132 Low-Level File Manager Routines

The File Manager
FUNCTION

PBHSetVol

Trap macro
Parameter block

—>
<—

—>
—>
—>

(paramBlock:

WDPBPtr;

async:

BOOLEAN)

:

OSErr;

_HSetVol

12
16

18
22
48

ioCompletion
ioResult

ioNamePtr
ioVRefNum _
ioWDDirID

pointer
word

pointer
word
long word

po,
\O

=

PBHSetVol sets both the default volume and the default directory. The default directory to

be used can be specified by either a volume reference number or a working directory
reference number in ioVRefNum, a directory ID in ioWDDzrID, or a pointer to a pathname
(possibly NIL) in ioNamePtr.
Note:

Both the default volume and the default directory are used in calls made with

no volume name and a volume reference number of zero.
Result codes

noErr
nsvErr

FUNCTION PBFlushVol
OSErr;

No error
No default volume
(paramBlock:

Trap macro

_FlushVol

Parameter block
—>
<—
—>
—>

12
16
18
22

ioCompletion
ioResult
ioNamePtr
ioVRefNum

ParmBlkPtr;

async:

BOOLEAN)

pointer
word
pointer
word

On the volume specified by ioNamePtr or ioVRefNum, PBFlushVol writes descriptive

information about the volume, the contents of the associated volume buffer, and all access
path buffers for the volume (if they’ve changed since the last time PBFlushVol was called).
Note: The date and time of the last modification to the volume are set when the
modification is made, not when the volume is flushed.
Result codes

noErr
bdNamErr

No error
Bad volume name

10Err
nsDrvErr
nsvErr

I/O error
No such drive
No such volume

extFSErr

paramErr

External file system

No default volume

Low-Level File Manager Routines IV-133

o

f
=}
joe)
T2
cas)

—

Inside Macintosh
FUNCTION

PBUnmountVol

Trap macro

(paramBlock:

ParmBlkPtr)

:

OSErr;

_UnmountVol

Parameter block
<—
16

—>

—>

18

22

ioResult

word

ioNamePtr

ioVRefNum

pointer
word

PBUnmountVol unmounts the volume specified by ioNamePtr or io VRefNum, by calling
PBFlush
Vol to flush the volume, closing all open files on the volume, and releasing the
memory used for the volume. PBUnmountVol is always executed synchronously.
Warning:
Note:

Don’t unmount the startup volume.

Unmounting a volume does not close working directories; to release the

memory allocated to a working

directory, call PBCloseWD.

Result codes

noErr

No error

extFSErr
i0oErr
nsDrvErr
nsvErr
paramErr

External file system
1/O error
No such drive
No such volume
No default volume

FUNCTION

bdNamErr

PBOffLine

Trap macro

Bad volume name

(paramBlock:

ParmBlkPtr)

_OffLine

Parameter block
—>
12.
<—
16

ioCompletion
ioResult

pointer
word

—>

ioVRefNum

word

—>

: OSErr;

18

22

ioNamePtr

pointer

PBOffLine places off-line the volume specified by ioNameFtr or ioVRefNum, by calling
PBFlushVol to flush the volume and releasing all the memory used for the volume except
for the volume control block. PBOffLine is always executed synchronously.
Result codes

noErr
bdNamErr
extFSErr
10Err
nsDrvErr
nsvErr

paramErr

No error
Bad volume name

External file system
I/O error
No such drive
No such volume
No default volume

IV-134 Low-Level File Manager Routines

The File Manager
FUNCTION

PBEject

Trap macro
Parameter block

(paramBlock:

ParmBlkPtr)

:

OSErr;

_Fject

—>

12.

ioCompletion

pointer

—>

22

ioVRefNum_

word

—"
\O

PBEyject flushes the volume specified by ioNamePtr or ioVRefNum, places it off-line, and

>

<—
—>

16
18

ioResult
ioNamePtr

word
pointer

then ejects the volume.

Assembly-language note:

You may invoke the macro _Eject asynchronously;

the first part of the call is executed synchronously, and the actual ejection is executed
asynchronously.

Result codes

noErr
bdNamErr

No error
Bad volume name

ioErr
nsDrvErr
nsvErr

I/O error
No such drive
No such volume

extFSErr

paramErr

External file system

No default volume

Accessing Files
FUNCTION

PBOpen

(paramBlock:

Trap macro

_Open

Parameter block
—>
<—
—>
—>
<—
—>
—>
—>

12.
16
18
22
24
26
27
28

ioCompletion
ioResult
ioNamePtr
ioVRefNum
ioRefNum
ioVersNum
ioPermssn
ioMisc

ParmBlkPtr;

async:

BOOLEAN)

:

OSErr;

pointer
word
pointer
word
word
byte
byte
pointer

PBOpen creates an access path to the file having the name pointed to by ioNamePtr (and on
flat volumes, the version number ioVersNum) on the volume specified by ioVRefNum. A
path reference number is returned in ioRefNum.
IOMisc either points to a portion of memory (522 bytes) to be used as the access path’s
buffer, or is NIL if you want the volume buffer to be used instead.
Warning: All access paths to a single file that’s opened multiple times should share
the same buffer so that they will read and write the same data.
Low-Level File Manager Routines IV-135

a

pom)
=}
pom)
To
fae)

Law |

Inside Macintosh

JOPermssn specifies the path’s read/write permission. A path can be opened for writing
even if it accesses a file on a locked volume, and an error won’t be returned until a
PBWrite, PBSetEOF, or PBAllocate call is made.

If you attempt to open a locked file for writing, PBOpen will return permErr as its function
result. If you request exclusive read/write permission but another access path already has
write permission (whether write only, exclusive read/write, or shared read/write), PBOpen

will return the reference number of the existing access path in ioRefNum and opWrErr as

its function result. Similarly, if you request shared read/write permission but another

access path already has exclusive read/write permission, PBOpen will return the reference

number of the access path in ioRefNum and opWr Err as its function result.
Result codes

noErr
bdNamErr

No error
Bad file name

fnfErr
ioErr
nsvErr

File not found
I/O error
No such volume

extFSErr

op WrErr

permErr
tmfoErr
FUNCTION

PBHOpen

Trap macro
Parameter block

—>
<—
—>

—>
<—

—>
—>
—>

External file system

File already open for writing

Attempt to open locked file for writing
Too many files open

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_HOpen

12
16

i0Completion
ioResult

pointer
word

22
24

ioVRefNum
1oRefNum

word
word

18

27
28
48

ioNamePtr
ioPermssn
ioMisc
ioDirID

pointer

byte
pointer
long word

PBHOpen is identical to PBOpen except that it accepts a directory ID in ioDirID.
Resultcodes

noErr
bdNamErr
dirNFErr
extFSErr
fnfErr
ioErr
nsvErr
opWrErr
permErr
tmfoErr

No error
Bad file name
Directory not found or incomplete pathname
External file system
File not found
I/O error
No such volume
File already open for writing
Attempt to open locked file for writing
Too many files open

IV-136 Low-Level File Manager Routines

:

OSErr;

The File Manager
FUNCTION

PBOpenRF

(paramBlock:

Trap macro

_OpenRF

Parameter block
—>
<—
—>
—>
<—

12
16
18
22
24

—>

—>

—>

26
27

28

1io0Completion
ioResult
ioNamePtr
ioVRefNum
ioRefNum

ioVersNum
ioPermssn

ParmBlkPtr;

async:

BOOLEAN)

:

OSErr;

pointer
word
pointer
word
word

=
=

byte

=

pointer

~

byte

ioMisc

Ke

PBOpenRF is identical to PBOpen, except that it opens the file’s resource fork instead of
its data fork.
Note: Normally you should access a file’s resource fork through the routines of the
Resource Manager rather than the File Manager. PBOpenRF doesn’t read the
resource map into memory; it’s really only useful for block-level operations such as
copying files.
Resultcodes

noErr
bdNameErr
extFSErr
fnfErr
ioErr
nsvErr

No error
Bad file name
External file system
File not found
I/O error
No such volume

permErr
tmfoErr

Attempt to open locked file for writing
Too many files open

op WrErr

FUNCTION PBHOpenRF
OSErr;

Trap macro
Parameter block

—>
<—

—>
—>
<—
—>
—>
—>

File already open for writing

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_HOpenRF

12
ioCompletion
16 = ioResult

18
22
24
27
28
48

ioNamePtr
ioVRefNum
ioRefNum
ioPermssn
ioMisc
ioDirID

pointer
word

pointer
word
word
byte
pointer
long word

PBHOpenRF is identical to PBOpenRF except that it accepts a directory ID in ioDirID.

Low-Level File Manager Routines IV-137

v2

Inside Macintosh
noErr
bdNamErr
dirNFErr
extFSErr
fnfErr
10Err
nsvErr

Result codes

op WrErr

permErr
tmfoErr

FUNCTION

PBLockRange

OSErr;

Trap macro

No error
Bad file name
Directory not found or incomplete pathname

External file system

File not found
I/O etror
No such volume
File already open for writing
Attempt to open locked file for writing
Too many files open

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

_LockRng

Parameter block

12

16
24

36

io0Completion

= ioResult
ioRefNum

44
46

ioReqCount
10PosMode
ioPosOffset

pointer
word
word
long word
word
long word

On a file opened with a shared read/write permission, PBLockRange is used in conjunction
with PBRead and PBWrite to lock a certain portion of the file. PBLockRange uses the
same parameters as both PBRead and PBWrite; by calling it immediately before PBRead,
you can use the information present in the parameter block for the PBRead call.
When you’re finished with the data (typically after a call to PB Write), be sure to call
PBUnlockRange to free up that portion of the file for subsequent PBRead calls.

Warning:

PBLockRange operates only with the hierarchical version of the File

Manager; if used on a Macintosh equipped only with the 64K ROM version of the
File Manager, it will generate a system error.

Result codes

noErr

eofErr
extFSErr

fnOpnErr

10Err
paramErr

rfNumErr

No error
End-of-file
External file system
File not open
I/O error

Negative 1oReqCount

Bad reference number

IV-138 Low-Level File Manager Routines

The File Manager
FUNCTION

PBUnlockRange

OSErr;

Trap macro

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

_UnlockRng

Parameter block
—>
12
<—

pointer

ioRefNum

word

1oResult

36

ioReqCount

—>

24

—>
—>

44
46

—>

ioCompletion

16

word

pend,
\o

long word

es)

ioPosMode — word
ioPosOffset
long word

om

ae)

PBUnlockRange is uséd in conjunction with PBRead and PBWrite to unlock a certain

portion of a file that you locked with PBLockRange.
Warning:

PBUnlockRange operates only with the hierarchical version of the File

File Manager, it will generate a system error.
noErr
eofErr

No error
End-of-file

fnOpnErr

File not open

extPSErr
ioErr

paramErr

rf{NumEtrr
FUNCTION

PBRead

Trap macro

—>
<—
—>
<>

I/O error

Negative ioReqCount

Bad reference number
ParmBlkPtr;

async:

BOOLEAN)

:

OSErr;

_Read

Parameter block
—>
12
<—
16

—>
—>

External file system

(paramBlock:

24
32

36
40
44
46

ioCompletion
ioResult

pointer
word

ioReqCount
1oActCount
jio0PosMode
i0PosOffset

long word
long word
word
long word

ioRefNum
ioBuffer

fae)

=

Manager; if used on a Macintosh equipped only with the 64K ROM version of the
Result codes

pee)
=
pe)
va

word
pointer

PBRead attempts to read ioReqCount bytes from the open file whose access path is
specified by ioRefNum, and transfer them to the data buffer pointed to by ioBuffer. The
position of the mark is specified by ioPosMode and ioPosOffset. If you try to read past the

Low-Level File Manager Routines IV-139

Inside Macintosh

logical end-of-file, PBRead moves the mark to the end-of-file and returns eofErr as its
function result. After the read is completed, the mark is returned in ioPosOffset and the
number of bytes actually read is returned in ioActCount.
Resultcodes
:

FUNCTION

noErr
eofErr
extFSErr
fnOpnErr
10Err
paramErr
rfNumErr

PBWrite

No error
End-of-file
External file system
File not open
I/O error
Negative ioReqCount
Bad reference number

(paramBlock:

ParmBlkPtr;

Trap macro

_Write

Parameter block
—>
<—
—>
—>

12
16
24
32

ioCompletion
ioResult
10RefNum
10Buffer

pointer
word
word
pointer

40
44
46

ioActCount
ioPosMode
io0PosOffset

long word
word
long word

—>

<—
—>
<->

36

ioReqCount

async:

BOOLEAN)

:

OSErr;

long word

PBWrite takes ioReqCount bytes from the buffer pointed to by ioBuffer and attempts to
write them to the open file whose access path is specified by ioRefNum. The position of
the mark is specified by ioPosMode and ioPosOffset. After the write is completed, the
mark is returned in ioPosOffset and the number of bytes actually written is returned in
ioActCount.

Result codes

noErr
dskFulErr
fLckdErr

fnOpnErr
i0Err

paramErr
posErr

rfNumErr
vLckdErr
wPrErr
wrPermErr

No error
Disk full
File locked
File not open

I/O error

Negative ioReqCount
Attempt to position before start of file
Bad reference number
Software volume lock
Hardware volume lock
Read/write permission doesn’t allow writing

IV-140 Low-Level File Manager Routines

The File Manager
FUNCTION PBGetFPos
OSErr;

Trap macro
Parameter block

—>
<—

ParmBlkPtr;

async:

BOOLEAN)

_GetFPos

12
16

i0Completion
ioResult

pointer
word

36

ioReqCount

long word

—>

24

<—
<—
<—

40
44
46

<—

(paramBlock:

ioRefNum

ioActCount
ioPosMode
ioPosOffset

word

a"
vo)

cz

long word
word
long word

Oo
joe)
=
jab)
TS?
fas)

PBGetFPos returns, in ioPosOffset, the mark of the open file whose access path is
specified by ioRefNum. It sets ioReqCount, ioActCount, and ioPosMode to 0.

Result codes

noErr
extFSErr
fnOpnErr
gfpErr
10Err

r{NumErr
FUNCTION

PBSetFPos

Trap macro
Parameter block

—>

<—
— >

—>
<—>

Lew §

No error
External file system
File not open
Error during GetFPos
I/O error

Bad reference number

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

:

OSErr;

_SetFPos
12

16
24

44
46

ioCompletion

ioResult
ioRefNum

ioPosMode
ioPosOffset

pointer
word

word

word
long word

PBSetFPos sets the mark of the open file whose access path is specified by ioRefNum to

the position specified by ioPosMode and ioPosOffset. The position at which the mark is

actually set is returned in ioPosOffset. If you try to set the mark past the logical end-offile, PBSetFPos moves the mark to the end-of-file and returns eofErr as its function result.
Result codes

noErr
eofErr
extFSErr

fnOpnErr
10Err

posErr

rfNumErr

No error
End-of-file
External file system
File not open

I/O error

Attempt to position before start of file
Bad reference number

Low-Level File Manager Routines IV-141

Inside Macintosh
FUNCTION

PBGetEOF

Trap macro
Parameter block

—>

<—
—>
<—

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

: OSErr;

_GetEOF

12.

16
24
28

ioCompletion

ioResult
ioRefNum
1i0Misc

pointer

word
word
long word

PBGetEOF returns, in ioMisc, the logical end-of-file of the open file whose access path is
* specified by ioRefNum.
Result codes

noEnrr
extFSErr

fnOpnErr

File not open

rf{NumErr

Bad reference number

i0Err

FUNCTION

PBSetEOF

Trap macro
Parameter block

—>

<—
—>
—>

No error
External file system
1/O error

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

: OSErr;

_SetEOF

12

16
24
28

ioCompletion

ioResult
ioRefNum
ioMisc

pointer

word
word
long word

PBSetEOF sets the logical end-of-file of the open file, whose access path is specified by
ioRefNum, to ioMisc. If you attempt to set the logical end-of-file beyond the physical endof-file, another allocation block is added to the file; if there isn’t enough space on the
volume, no change is made, and PBSetEOF returns dskFulErr as its function result. If

ioMisc is O, all space occupied by the file on the volume is released.
Result codes

noErr
dskFulErr

No error
Disk full

fLekdErr
fnOpnErr

File locked
File not open

extFSErr
ioErr

rfNumErr
vLckdErr
wPrErr

wrPermErr

External file system
I/O error

Bad reference number
Software volume lock
Hardware volume lock

Read/write permission doesn’t allow writing

IV-142 Low-Level File Manager Routines

The File Manager
FUNCTION

PBAllocate

OSErr;

Trap macro

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

_Allocate

Parameter block

—>

<—
—>
—>
<—

12

16
24
36
40.

ioCompletion

10Result
ioRefNum
ioReqCount
ioActCount

pointer

word
word
long word
long word

ae
‘©

=

oO

PBAllocate adds ioReqCount bytes to the open file whose access path is specified by
ioRefNum, and sets the physical end-of-file to one byte beyond the last block allocated.
The number of bytes actually allocated is rounded up to the nearest multiple of the
allocation block size, and returned in ioActCount. If there isn’t enough empty space on
the volume to satisfy the allocation request, PBAllocate allocates the rest of the space on the
volume and returns dskFulErr as its function result.

Note: Even if the total number of requested bytes is unavailable, PBAllocate will
allocate whatever space, contiguous or not, is available.

To force the allocation of

the entire requested space as a contiguous piece, call PBAllocContig instead.
Result codes

— noErr
dskFulErr
fLckdErr

No error
Disk full
File locked

fnOpnErr

File not open

ioErr
rfNumErr
vLckdErr
wPrErr

I/O error
Bad reference number
Software volume lock
Hardware volume lock

wrPermErr

FUNCTION

PBAllocContig

OSErr;

Trap macro
Parameter block

—>

<—
—>
—>
<—

Read/write permission doesn’t allow writing

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

_AllocContig
12.

16
24
36
40

ioCompletion
ioResult
ioRefNum
ioReqCount
ioActCount

pointer

word
word
long word
long word

PBAllocContig is identical to PBAIlocate except that if there isn’t enough contiguous empty
space on the volume to satisfy the allocation request, PBAJlocContig will do nothing and
will return dskFulErr as its function result. If you want to allocate whatever space is

available, even when the entire request cannot be filled as a contiguous piece, call

PBAllocate instead.

Low-Level File Manager Routines IV-143

pow)

~

po)
Tt?
fas)
=

Inside Macintosh
Result codes

noErr
dskFulErr
fLcokdErr

No error
Disk full
File locked

10Err
rfNumErr
vLckdErr
wPrEtr
wrPermErr

I/O error
Bad reference number
Software volume lock
Hardware volume lock

fnOpnErr

FUNCTION

PBFlushFile

Parameter block
—>
<—

—>

Read/write permission doesn’t allow writing

(paramBlock:

OSErr;

Trap macro

File not open

ParmBlkPtr;

async:

BOOLEAN)

_FlushFile

12

16
24

ioCompletion

pointer
word
word

= ioResult
ioRefNum

PBFlushFile writes the contents of the access path buffer indicated by ioRefNum to the
volume, and updates the file’s entry in the file directory (or in the file catalog, in the case of
hierarchical volumes).
Warning: Some information stored on the volume won’t be correct until
PBFlushVol is called.
Result codes

noErr
extFSErr
fnfErr

No

i0Err
nsvErr
rfNumErr

I/O error
No such volume
Bad reference number

fnOpnErr

FUNCTION

PBClose

Trap macro
Parameter block
—>
<—
—>

error

External file system
File not found

File not open

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

:

OSErr;

_Close
12

16
24

ioCompletion
~=‘1oResult
ioRefNum

pointer
word
word

PBClose writes the contents of the access path buffer specified by ioRefNum to the volume
and removes the access path.
7
Warning: Some information stored on the volume won’t be correct until
PBFlushVol is called.

IV-144 Low-Level File Manager Routines

The File Manager
Result codes

noErr
extFSErr
fnfErr

fnOpnErr

i0Err
nsvErr
rfNumErr

No error

External file system
File not found
File not open
[/O error

No such volume
Bad reference number
—"
\O

Creating and Deleting Files and Directories
FUNCTION

PBCreate

Trap macro
Parameter block

ParmBlkPtr;

async:

BOOLEAN)

: OSErr;

12

—>
—>
—>

18
22
26

16

je
Te
fac)
=!

ioCompletion _ pointer

ioResult

ioNamePtr
ioVRefNum
ioFVersNum

word

pointer
word
byte

PBCreate creates a new file (both forks) having the name pointed to by ioNamePtr (and on
flat volumes, the version number ioVersNum) on the volume specified by ioVRefNum.
The new file is unlocked and empty. The date and time of its creation and last modification
are set to the current date and time.

If the file created isn’t temporary (that is, if it will exist

after the application terminates), the application should call PBSetFInfo (after PBCreate) to
fill in the information needed by the Finder.
Assembly-language note: If a desk accessory creates a file, it should always
create it in the directory containing the system folder. The working directory

reference number for this directory is stored in the global variable BootDrive; you can

pass it in io VRefNum.
Result codes

noErr
bdNamEtrr

No error
Bad file name

dirFulErr
extFSErr
10Err
nsvErr
vLckdErr
wPrErr

File directory full

dupFNErr

S)

=

_Create

—>

<—

(paramBlock:

=

o

Duplicate file name and version

External file system
I/O error

No such volume
Software volume lock
Hardware volume lock

Low-Level File Manager Routines IV-145

Inside Macintosh
FUNCTION

PBHCreate

(paramBlock:

OSErr;

Trap macro

HParmBlkPtr;

async:

BOOLEAN)

_HCreate

Parameter block

—>
<—

12
16

ioCompletion
ioResult

pointer
word

—>

22

i0oVRéefNum

word

—>

—>

18

48

ioNarnePtr

ioDirID

pointer
long word

PBHCreate is identical to PBCreate except that it accepts a directory ID in ioDirID.

Note: To create a directory instead of a file, call PBDirCreate.
Resultcodes

noErr
bdNamErr
dupFNErr

No error
Bad file name
Duplicate file name and version

dirNFEtrr
extFSErr
ioErr
nsvErr
vLckdErr
wPrErr

Directory not found or incomplete pathname
External file system
J/O error
No such volume
Software volume lock
Hardware volume lock

dirFulErr

FUNCTION

PBDirCreate

OSErr;

Trap macro

File directory full

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN):

_DirCreate

Parameter block

—>
<—

12
16

—>

22

<—>
<—>

ioCompletion
ioResult

pointer
word

ioVRefNum

word

18

ioNamePtr

48

ioDirID

pointer

long word

PBDirCreate is identical to PBHCreate except that it creates a new directory instead of a
file. You can specify the parent of the directory to be created in ioDirID; if it’s 0, the new
directory will be placed in the root directory. The directory ID of the new directory is
returned in ioDirID.
Warning:

PBDirCreate operates only with the hierarchical version of the File

Manager; if used on a Macintosh equipped only with the 64K ROM version of the
File Manager, it will generate a system error.

IV-146 Low-Level File Manager Routines

The File Manager
Result codes

= noErr
bdNamErr
dupFNErr
dirFulErr
dirNFErr

extFSErr
10Err
nsvErr

vLckdErr
wPrErr

FUNCTION PBDelete
Trap macro
Parameter block

—>

<—
—>
—>
—>

No error
Bad file name
Duplicate file name and version
File directory full
Directory not found or incomplete pathname

External file system
I/O error
No such volume

Software volume lock

2

Hardware volume lock

(paramBlock:

ParmBlkPtr;

|

async:

BOOLEAN)

: OSErr;

v2

_Delete
12.

16
18
22
26

S

ioCompletion
1oResult
ioNamePtr
ioVRefNum
ioFVersNum

pointer

word
pointer
word
byte

PBDelete removes the closed file having the name pointed to by ioNamePtr (and on flat

volumes, the version number ioVersNum) from the volume pointed to by ioVRefNum.
PBHDelete can be used to delete an empty directory as well.
Note:

This function will delete both forks of the file.

Result codes

noErr
bdNamErr
extFSErr
fBsyErr
fLekdErr

fnfErr
nsvErr
i0Err
vLckdErr
wPrErr

FUNCTION PBHDelete
OSErr;

Trap macro

<—

—>
—>
—>

No error
Bad file name
External file system
File busy, directory not empty, or working
control block open
File locked

directory

File not found
No such volume
1/O error
Software volume lock
Hardware volume lock

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN):

_HDelete

Parameter block
—>
12

16

18
22
48

io0Completion

pointer

ioNamePtr
ioVRefNum
1io0DirID

pointer
word
long word

ioResult

=

=

word

Low-Level File Manager Routines IV-147

:

Inside Macintosh

PBHDelete is identical to PBDelete except that it accepts a directory ID in ioDirID.
PBHDelete can be used to delete an empty directory as well.
Result codes

noErr
bdNamErr

No error
Bad file name

extFSErr
fBsyErr

External file system
File busy, directory not empty, or working

dirNFErr

Directory not found or incomplete pathname
control block open

fLcokdErr
fnfErr
nsvErr

directory

File locked
File not found
No such volume

ioErr —

I/O error

vLckdErr

Software volume lock

wPrEtrr

Hardware volume lock

Changing Information About Files and Directories
FUNCTION PBGetFInfo
OSErr;

(paramBlock:

ParmBlkPtr;

Trap macro

_GetFileInfo

Parameter block
—>

12

1ioCompletion

pointer

<—>
—>
<—
—>
—>
<—
<—
<—

18
22
24
26
28
30
31
32

ioNamePtr _
ioVRefNum
ioFRefNum
ioFVersNum
ioFDirIndex
10F1Attrib
ioF]VersNum
ioFlFndrInfo

pointer
word
word
byte
word
byte
byte
16 bytes

<—
<—

52
54

<—

<—

<—

<—
<—
<—
<—
<—

16

48

58

62
64
68
72
76

ioResult

ioFINum

BOOLEAN)

word

long word

ioF1StBlk
ioFlLgLen

word
_—__ long word

i0FIRStBIk
i0FIRLgLen
i0FIRPyLen
10F1CrDat
1i0FIMdDat

word
long word
long word
long word
_long word

ioFlPyLen

async:

long word

PBGetFinfo returns information about the specified file. If ioFDirIndex is positive, the

File Manager returns information about the file whose directory index is ioFDirIndex on the
volume specified by ioVRefNum. (See the section “Data Organization on Volumes” if
you’re interested in using this method.)
Note: If a working directory reference number is specified in ioVRefNum, the File
Manager returns information about the file whose directory index is ioFDirIndex in
the specified directory.

IV-148 Low-Level File Manager Routines

The File Manager
If ioFDirIndex is negative or 0, the File Manager returns information about the file having

the name pointed to by ioNamePtr (and on flat volumes, the version number ioF VersNum)

on the volume specified by ioVRefNum. If the file is open, the reference number of the
first access path found is returned in ioFRefNum, and the name of the file is returned in
ioNamePtr (unless ioNamePtr is NIL).
Resultcodes

noErr
bdNamErr

No error
Bad file name

fnfErr
ioErr
NsvErr

File not found
I/O error
No such volume

extFSErr

External file system

paramErr

—"
\o

=)

Oo

No default volume

be
—
joe)
v3
cae)
—

FUNCTION

PBHGetFinfo

OSErr;

(paramBlock:

HParmBlkPtr;

Trap macro

_HGetFileInfo

Parameter block
—>
<—
<—>
—>
<—
—>
<—

12
16
18
22
24
28
30

ioCompletion pointer
ioResult
word
ioNamePtr _— pointer
ioVRefNum
word
ioFRefNum
word
ioFDirIndex
word
ioFlAttrib
byte

<—>
<—
<—
<—
<—
<—

48
52
54
58
62
64

ioDirID
i0FIStBlk
ioFlLgLen
ioFlPyLen
iOFIRStBIk
ioFIRLgLen

long word
word
long word
long word
word
long word

<—
<—

72
76

ioF1CrDat
ioFIMdDat

long word
long word

<—

<—

PBHGetF Info

32

68

ioFlFndrInfo

ioFIRPyLen

async:

BOOLEAN)

16 bytes

long word

is identical to PBGetFInfo except that it accepts a directory ID in ioDirID.

Result codes

noErr
bdNamErr

No error
Bad file name

fnfErr
ioErr
nsvErr

File not found
I/O error
No such volume

dirNFErr
extFSErr

paramErr

Directory not found or incomplete pathname
External file system

No default volume

Low-Level File Manager Routines IV-149

Inside Macintosh
FUNCTION

PBSetFInfo

(paramBlock:

OSErr;

Trap macro

ParmBlkPtr;

async:

BOOLEAN)

_SetFileInfo

Parameter block

—>
<—
—>
—>
—>
—>
—>
—>

12.
16

18
22
26
32
72.
76

io0Completion
ioResult
ioNamePtr
ioVRefNum
ioFVersNum
ioFlFndrinfo
ioFlCrDat
ioFlMdDat

pointer
word

pointer
word
byte
16 bytes
long word
long word

PBSetFInfo sets information (including the date and time of creation and modification, and
information needed by the Finder) about the file having the name pointed to by ioNamePtr
(and on flat volumes, the version number ioF VersNum) on the volume specified by
ioVRefNum.

You should call PBGetFInfo just before PBSetFInfo, so the current

information is present in the parameter block.
Result codes

noErr
bdNamErr

No error
Bad file name

fLckdErr
fnfErr
ioErr
nsvErr
vLckdErr
wPrErr

File locked
File not found
I/O error
No such volume
Software volume lock
Hardware volume lock

extFSErr

FUNCTION

PBHSetFiInfo

OSErr;

Trap macro
Parameter block

12

—>

18

16

—>

22

—>
—>

48
72

—>
—>

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_HSetFileInfo

—>

<—

External file system

ioCompletion

pointer

ioNamePtr

pointer

ioResult

ioVRefNum

32

ioFlFndrinfo

76

ioFlMdDat

ioDirID
ioFlCrDat

word

word

16 bytes

long word
long word

long word

PBHSetFInfo is identical to PBSetFInfo except that it accepts a directory ID in ioDirID.

IV-150 Low-Level File Manager Routines

The File Manager
Result codes

noErr
bdNamErr

No error
Bad file name

fLckdErr
fnfErr
ioErr
nsvErr

File locked
File not found
I/O error
No such volume

dirNFErr
extFSErr

vLckdErr

Software volume lock

wPrEtrr

FUNCTION

PBSetFLock

Directory not found or incomplete pathname
External file system

S

Hardware volume lock

(paramBlock:

ParmBlkPtr;

'

async:

BOOLEAN)

OSErr;

Trap macro
Parameter block

=

12

—>

18

—>

—>

A

_SetFilLock

—>

<—

16.

22

26

~

ioCompletion

pointer

ioNamePtr

pointer

ioFVersNum

byte

ioResult

ioVRefNum

word

word

PBSetFLock locks the file having the name pointed to by ioNamePtr (and on flat volumes,
the version number ioFVersNum) on the volume specified by ioVRefNum. Access paths
currently in use aren’t affected.
Result codes

FUNCTION

noErr

No error

fnfErr
ioErr
nsvErr
vLckdErr
wPrEtr

File not found
I/O error
No such volume
Software volume lock
Hardware volume lock

extFSErr

PBHSetFLock

OSErr;

Trap macro
Parameter block

—>

<—

—>
—>
—>

=

External file system

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_HSetFLock
12

16

18
22
48

ioCompletion

pointer

ioNamePtr
ioVRefNum
ioDiID

pointer
word
long word

ioResult

word

PBHSetFLock is identical to PBSetFLock except that it accepts a directory ID in ioDirID.

Low-Level File Manager Routines IV-1I51

Inside Macintosh

Result codes

FUNCTION

noErr

PBRstFLock

Parameter block

Directory not found or incomplete pathname
External file system
File not found
I/O error
No such volume
Software volume lock
Hardware volume lock

(paramBlock:

OSErr;

Trap macro

No error

dirNFErr
extFSErr
fnfErr
ioErr
nsvErr
vLckdErr
wPrErr

ParmBlkPtr;

BOOLEAN)

_RstFilLock

—>

12.

ioCompletion

pointer

—>
—>
—>

18
22
26

ioNamePtr
ioVRefNum
1ioFVersNum

pointer
word
byte

<—

async:

16.

ioResult

word

PBRstFLock unlocks the file having the name pointed to by ioNamePtr (and on flat
volumes, the version number ioF VersNum) on the volume specified by ioVRefNum.

Access paths currently in use aren’t affected.
Result codes

FUNCTION

noErr
extFSErr
fnfErr
10Err
nsvVErr
vLckdErr
wPrErr

PBHRstFLock

OSErr;

Trap macro
Parameter block

—>

<—

—>

—>
—>

No error

External file system
File not found
I/O error
No such volume

Software volume lock

Hardware volume lock
(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_HRstFLock

12.

ioCompletion

pointer

18

ioNamePtr

pointer

16

22
48

ioResult

ioVRefNum
ioDirID

word

word

long word

PBHRstFLock is identical to PBRstFLock except that it accepts a directory ID in ioDirID.

IV-152 Low-Level File Manager Routines

The File Manager
Result codes

noErr

dirNFErr
extFSErr
fnfErr

ioErr

nsvErr
vLckdErr
wPrErr
FUNCTION PBSetFVers
OSErr;

Trap macro

No error

Directory not found or incomplete pathname
External file system
File not found

I/O error

No such volume
Software volume lock
Hardware volume lock

(paramBlock:

ParmBlkPtr;

pan
\o

async:

BOOLEAN)

Oo
po)
=|
iS
To
ras)

_SetFilType

Lew

Parameter block

—>

<——
—>

—>
—>

—>

12

16
18

22
26
28

ioCompletion
ioResult
ioNamePtr

pointer
word

pointer

ioVRefNum
ioVersNum

word
byte
byte

ioMisc

PBSetFVers has no effect on hierarchical volumes.

On flat volumes,

PBSetF Vers changes

the version number of the file having the name pointed to by ioNamePtr and version

number ioVersNum, on the volume specified by ioVRefNum, to the version number stored
in the high-order byte of ioMisc. Access paths currently in use aren’t affected.
Result codes

noErr
bdNamErr

dupFNErr
extFSErr
fLcokdErr
fnfErr
nsvErr

10Err
paramErr

vLckdErr
wPrErr

wre VolTypErr

FUNCTION

PBRename

Trap macro
Parameter block

—>

File not found

No such volume

I/O error

No default volume
Software volume lock
Hardware volume lock
Attempt to perform hierarchical operation on a flat
volume

(paramBlock:

ParmBlkPtr;

async:

BOOLEAN)

:

OSErr;

_Rename
12.

<—
— >
—>

16
18
22

—>

28

—>

No error
Bad file name
Duplicate file name and version
External file system
File locked

26

ioCompletion

pointer
word
pointer

ioVersNum

byte
pointer

1oResult
ioNamePtr
ioVRefNum -

ioMisc

word

Low-Level File Manager Routines IV-153

|

Inside Macintosh

Given a pointer to a file name in ioNamePtr (and on flat volumes, a version number in
ioVersNum), PBRename changes the name of the file to the name pointed to by ioMisc. (If
the name pointed to by ioNamePtr contains one or more colons, so must the name pointed
to by ioMist.) Access paths currently in use aren’t affected. Given a pointer to a volume
name iri ioNamePtr or a volume referencé number in ioVRefNum, it changes the name of
the voltime to the name pointed to by ioMisc. If a volume to be renamed is specified by its
volume reference number, ioNamePtr can be NIL.
Warning:

If a volume to be renamed is specified by its volume name, be sure that it

ends with a colon, or Rename will consider it a file. name.
Result codes

noErr
bdNamErr
dirFulErr

dupFNErr

extFSErr
fLckdErr
fnfErr
fsRnErr
i0Err
nsvErr

paramErr

vLckdErr
wPrErr

FUNCTION

PBHRename

OSErr;

Trap macro

No error
Bad file name

File directory full

Duplicate file name and version
External file system
File locked
File not found

Problem during rename
I/O error
No such volume
No default volume
Software volume lock
Hardware volume lock

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_HRename

Parameter block
— >
12

<—
—>
—>
—>
—>

16
18

22
28
48

ioCompletion

pointer

ioVRefNum _
10Misc
1ioDirID

word
pointer
long word

ioResult
ioNamePtr

word
pointer

PBHRename is identical to PBRename except that it accepts a directory ID in ioDirID and
can be used to rename directories as well as files and volumes. Given a pointer to the name
of a file or directory in ioNamePtr, PBHRename changes it to the name pointed to by
ioMisc. Given a pointer to a volume name in ioNamePtr or a volume reference number in
ioVRefNum, it changes the name of the volume to the name pointed to by ioMisc.
Warning:

Result codes

PBHRename cannot be used to change the directory a file is in.

= noErr

|

No error

bdNamErr

Bad file name

fLekdErr

File locked

dirFulErr
dirNFErr
dupFNErr
extFSErr

File directory full
Directory not found or incomplete pathname
Duplicate file name and version
External file system

IV-154 Low-Level File Manager Routines

The File Manager
fnfErr
fsRnErr
ioErr
nsvErr

File not found

Problem during rename
I/O error |
No such volume

paramErr

No default volume

Software volume lock

vLckdErr
wPrErr

Hardware volume lock
—
\©

Hierarchical Directory Routines

=

>

Warning: The routines described in this section operate only with the hierarchical
version of the File Manager; if used on a Macintosh equipped only with the 64K
ROM version of the File Manager, they will generate a system error.

poe)
—
joe)
To
fae)
baw

FUNCTION

PBGetCatInfo

OSErr;

Trap macro

(paramBlock:

<—

24

ioFRefNum _

<—
<—

54
58

ioFlLgLen
ioFlPyLen

<—
<—

<—

<—
<—
<—
<—
<—

<—

async:

BOOLEAN) :

_GetCatInfo

Parameter block
Files:
—>
12.
ioCompletion
<—
16
ioRésult
<—>
18
ioNamePtr
—>
22
ioVRefNum
—>
<—
<—
<—>
<—

CInfoPBPtr;

28
30
32
48
52

62
64

68

72.
76
80.
84
100

104

1oFDirIndex
ioFlAttrib
ioFlFndrInfo
10DirID
ioFlStBlk
ioFIRStBlk
ioFIRLgLen

ioFIRPyLen

1i0FICrDat
ioFlMdDat
ioFIBkDat
ioFlXFndrInfo
ioFlParID

ioFIClpSiz

pointer
word
pointer
word

word

word
byte
16 bytes
long word
word

long word
long word

Directories:
—>
12

<—

<>

16

18

—>
<—
—>
<—
<—
<>
<—

22
24
28
30
32
48
52

<—
<—
<—

72
76
80

10Completion
i0oResult
ioNamePtr
io VRefNum
ioFRefNum
i0FDirIndex
ioFlAttrib
ioDrUsrWds
ioDrDirID
ioDrNmFls

pointer
word
pointer
word
word
word
byte
16 bytes
long word
word

ioDrCrDat
1i0oDrMdDat
ioDrBkDat
ioDrFndrInfo
i0oDrParID

long word
long word
long word
16 bytes
long word

word
long word

long word

long word
long word
long word
16 bytes
long word

long word

<—
<—

84
100

PBGetCatInfo gets information about the files and directories in a file catalog. To

determine whether the information is for a file or a directory, test bit 4 of ioFlAttrib, as
described in the section “CInfoPBRec”. The information that’s returned for files is shown
in the left column, and the corresponding information for directories is shown in the right
column.

If ioFDirIndex is positive, the File Manager returns information about the file or directory
whose directory index is ioFDirIndex in the directory specified by ioVRefNum (this will be
the root directory if a volume reference number is provided).
Low-Level File Manager Routines IV-155

|

a

Inside Macintosh

If ioFDirIndex is 0, the File Manager returns information about the file or directory

specified by ioNamePtr, in the directory specified by ioVRefNum (again, this will be the

root directory if a volume reference number is provided).

If ioFDirIndex is negative, the File Manager ignores ioNamePtr and returns information

about the directory specified by ioDirID.

With files, PBGetCatInfo is similar to PBHGetFileInfo but returns some additional

information. If the file is open, the reference number of the first access path found is

returned in ioFRefNum, and the name of the file is returned in ioNamePtr (unless
10NamePtr is NIL).
Result codes

noErr
bdNamErr

No error
Bad file name

extFSErr

External file system

ioErr

I/O error

dirNFErr

Directory not found or incomplete pathname

fnfErr

File not found

nsvErr

No such volume

paramErr
FUNCTION PBSetCatInfo
OSErr;

Trap macro

No default volume

(paramBlock:

Files:
—>

12

—>
—>

22
30

ioCompletion

pointer

Directories:
—>
12

ioVRefNum_
ioFlAttrib

word
byte

—>
—>

16
18

ioResult
ioNamePtr

—>
—>
—>

32
48
72

ioFlFndrinfo
ioDrID
ioFlCrDat

—>

104

—>
—>
—>

async:

BOOLEAN)

_SetCatInfo

Parameter block
<—
<—>

CInfoPBPtr;

76
80
84

word
pointer
16 bytes
long word
long word

ioFlMdDat
long word
ioFlBkDat
long word
ioFlXFndrInfo 16 bytes
ioFlClpSiz

long word

<—
<—>

—>
—>
—>

—>
—>
—>

ioCompletion

pointer

ioVRefNum_
ioFlAttnib

word
byte

16
18

ioResult
ioNamePtr

32
48
72

ioDrUsrWds_
ioDrDirID
1ioDrCrDat

22
30

76
80
84

ioDrMdDat
ioDrBkDat
ioDrFndrinfo

word
pointer
16bytes
long word
long word

long word
long word
16 bytes

PBSetCatInfo sets information about the files and directories in a catalog. With files, it’s
similar to PBHSetFileInfo but lets you set some additional information. The information

that can be set for files is shown in the left column, and the corresponding information for
directories is shown in the right column.

IV-156 Low-Level File Manager Routines

The File Manager
Result codes

noErr

bdNamErr
dirNFErr
extFSErr
fnfErr
i0Err
nsvErr

paramErr

FUNCTION

PBCatMove

Trap macro
Parameter block

Directory not found or incomplete pathname
External file system
File not found

I/O error

No such volume

No default volume

(paramBlock:

async:

BOOLEAN)

:

OSErr;

joe)
|
2
T2
ae)

—>

18

10Completion

pointer

ioNamePtr

pointer

ioNewName
1oNewDirID

pointer
long word

16

ioResult

—>

22

ioVRefNum_

—>

48

28
36

ioDrID

word

word

long word

PBCatMove moves files or directories from one directory to another. The name of the file
or directory to be moved is pointed to by ioNamePtr; ioVRefNum contains either the
volume reference number or working directory reference number. A directory ID can be
specified in ioDirID. The name and directory ID of the directory to which the file or

directory is to be moved are specified by ioNewName and ioNewDrrID.

PBCatMove is strictly a file catalog operation; it does not actually change the location of the
file or directory on the disk. PBCatMove cannot move a file or directory to another volume

(that is, ioVRefNum is used in specifying both the source and the destination). It also

cannot be used to rename files or directories; for that, use PRHRename.
Result codes

=

o>

Law §

12

—>
—>

CMovePBPtr;

pom,
‘Oo

_CatMove

—>

<—

No error
Bad file name

noErr
badMovErr
bdNamErr

dupFNErr

fnfErr
ioErr
nsvErr

paramErr

vLckdErr
wPrErr

No error
Attempt to move into offspring
Bad file name or attempt to move into a file
Duplicate file name and version
File not found

I/O error

No such volume
No default volume
Software volume lock
Hardware volume lock

Low-Level File Manager Routines IV-157

Inside Macintosh

Working Directory Routines
Warning: The routines described in this section operate only with the hierarchical
version of the File Manager; if used on a Macintosh equipped only with the 64K
ROM version of the File Manager, they will generate a system error.

FUNCTION

PBOpenWD

Trap macro
Parameter block

—>

<—
—>
<>
—>
—>

(paramBlock:

WDPBPtr;

async:

BOOLEAN)

:

OSErr;

_OpenWD

12.

16
18
22
28
48

i0Completion
ioResult
ioNamePtr
ioVRefNum
ioWDProcID
ioWDDirID

pointer

word
pointer
word
long word
long word

PBOpenWD takes the directory specified by ioVRefNum, ioWDDirID, and ioWDProcID

and makes it a working directory. (You can also specify the directory using a combination

of partial pathname and directory ID.) It returns a working

i0VRefNum that can be used in subsequent calls.

directory reference number in

If a given directory has already been made a working directory using the same
10oWDProcID, no new working directory will be opened; instead, the existing working
directory reference number will be returned. If a given directory was already made a
working directory using a different ioWDProcID, a new working directory reference
number is returned.
Resultcodes

FUNCTION

noErr
tmwdoErr

PBCloseWD

Trap macro
Parameter block

—>

<—

—>

No error
Too many working directories open

(paramBlock:

WDPBPtr;

async:

BOOLEAN)

:

OSErr;

_CloseWD
12.

16

22

i0Completion

pointer

ioVRefNum

word

ioResult

word

PBCloseWD releases the working directory whose working directory reference number is
specified in ioVRefNum.
Note:

If a volume reference number is specified in ioVRefNum, PBCloseWD does

nothing.

Result codes

noErr
nsvErr

No error
No such volume

IV-158 Low-Level File Manager Routines

The File Manager
FUNCTION

PBGetWDInfo

Trap macro

(paramBlock:

WDPBPtr;

ioCompletion

pointer

<>
—>

ioVRefNum
ioWDIndex

word
word

<—>
<>

<—

BOOLEAN)

:

OSErr;

_GetWDInfo

Parameter block
—>
12
<—
<—

async:

16
18

22
26

28

32

48

ioResult
1oNamePtr

word
pointer
pom
©

ioWDProcID

long word

ioWDDirID

long word

ioWDVRefNum

word

PBGetWDiInfo returns information about the specified working directory. The working
directory can be specified either by its working directory reference number in ioVRefNum

(in which case ioWDIndex should be 0), or by its index number in 1oWDIndex. In the

latter case, if ioVRefNum is nonzero, it’s interpreted as a volume specification (volume
reference number or drive number), and only working directories on that volume are
indexed.
IOWDVRefNum always returns the volume reference number. IOVRefNum returns a
working directory reference number when a working directory reference number is passed
in that field; otherwise, it returns a volume reference number. The volume name is returned
in ioNamePtr.
If L[OWDProcID is nonzero, only working directories with that identifier are indexed;
otherwise all working directories are indexed.
Result codes

noErr
nsvErr

No error
No such volume

DATA ORGANIZATION ON VOLUMES
This section explains how information is organized on volumes. Most of the information is
accessible only through assembly language, but may be of interest to some advanced Pascal

programmers.

The File Manager communicates with device drivers that read and write data via block-level
requests to devices containing Macintosh-initialized volumes. (Macintosh-initialized

volumes are volumes initialized by the Disk Initialization Package.) The actual type of
volume and device is unimportant to the File Manager; the only requirements are that the

volume was initialized by the Disk Initialization Package and that the device driver is able to
communicate via block-level requests.

Data Organization on Volumes IV-159

es
=

oO
ee)

=

oe)
0Ke)

rae)
=

Inside Macintosh

The 3 1/2-inch built-in and optional external drives are accessed via the Disk Driver. The
Hard Disk 20 is accessed via the Hard Disk 20 Driver. If you want to use the File Manager
to access files on Macintosh-initialized volumes on other types of devices, you must write a

device driver that can read and write data via block-level requests to the device on which the

volume will be mounted. If you want to access files on volumes not initialized by the
Macintosh, you must write your own external file system (see the section “Using an
External File System’’).

The information on all block-formatted volumes is organized in logical blocks and

allocation blocks. Logical blocks contain a number of bytes of standard information (512

bytes on Macintosh-initialized volumes), and an additional number of bytes of information
specific to the device driver (12 bytes on Macintosh-initialized volumes; for details, see the

Disk Driver chapter). Allocation blocks are composed of any integral number of logical
blocks, and are simply a means of grouping logical blocks together in more convenient

parcels. The allocation block size is a volume parameter whose value is set when the
volume is initialized; it cannot be changed unless the volume is reinitialized.

The remainder of this section applies only to Macintosh-initialized volumes; the information

may be different in future versions of Macintosh system software. There are two types of
Macintosh-initialized volumes—flat directory volumes and hierarchical directory volumes.
Other volumes must be accessed via an external file system, and the information on them
must be organized by an external initializing program.

Flat Directory Volumes
A flat directory volume contains system startup information in logical blocks 0 and 1
(see Figure 7) that’s read in at system startup. This information consists of certain
configurable system parameters, such as the capacity of the event queue, the initial size of
the system heap, and the number of open files allowed. The development system you’re
using may include a utility program for modifying the system startup blocks on a volume.
Logical block 2 of the volume begins the master directory block. The master directory
block contains volume information and the volume allocation block map, which

records whether each block on the volume is unused or what part of a file it contains data
from.

IV-160 Data Organization on Volumes

The File Manager

logical block 0

Leaeeeceeece[ececceeaees

system startup
information

seeeseeeeeel

b zero If not a startup disk

occ]

master directory block

volume information

logical block 2
rs

block map

logical block 3
Li seeeeeeees

unused

logical block 4
Le vecescecee|eceeeeesuns

file directory

ZL

nein

J

Z

Z

gical block 799

file contents

~
=
S
E

“7

unused

jical block n+1

a

i

allocation block 2
4
allocation block m

Figure 7. A 400K Volume With 1K Allocation Blocks
The master directory “block” always occupies two blocks—the Disk Initialization Package
varies the allocation block size as necessary to achieve this constraint.
The file directory begins in the next logical block following the block map; it contains
descriptions and locations of all the files on the volume. The rest of the logical blocks on

the volume contain files or garbage (such as parts of deleted files). The exact format of the

volume information, volume allocation block map, and file directory is explained in the
following sections.

Volume Information
The volume information is contained in the first 64 bytes of the master directory block (see
Figure 8). This information is written on the volume when it’s initialized, and modified
thereafter by the File Manager.

Data Organization on Volumes IV-161

Inside Macintosh

byte 0

drSigWord (word)

always $D2D7

2 | drCrDate (long word)

date and time of initialization

6 | drLsBkUp (long word)

date and time of last modification

10

drAtrb (word)

volume attributes

12

drNmFls (word)

number of files in directory

14

drDirSt (word)

first block of directory

16

drBILen (word)

length of directory in blocks

18

drNmAIBIks (word)

number of allocation blocks

20 | drAIBIkSiz (long word) |

allocation block size

24 |

drCipSiz (long word)

number of bytes to allocate

28

drAIBISt (word)

first allocation block in block map

30 | drNxtFNum (long word) |

next unused file number

34 |

drFreeBks (word)

number of unused allocation blocks

36

~ deVN (byte)

length of volume name

37

dtVN +1 (bytes)

characters of volume name

Figure 8. Volume Information on Flat Directory Volumes

DrAtrb contains the volume attributes, as follows:
Bit

Meaning

7
15

Set if volume is locked by hardware
Set if volume is locked by software

DrClpSiz contains the minimum number of bytes to allocate each time the Allocate function
is called, to minimize fragmentation of files; it’s always a multiple of the allocation block
size. DrNxtFNum contains the next unused file number (see the “File Directory”’ section

below for an explanation of file numbers).

Volume Allocation Block Map
The volume allocation block map represents every allocation block on the volume with a
12-bit entry indicating whether the block is unused or allocated to a file. It begins in the
master directory block at the byte following the volume information, and continues for as
many logical blocks as needed.

IV-162 Data Organization on Volumes

The File Manager
The first entry in the block map is for block number 2; the block map doesn’t contain
entries for the system startup blocks. Each entry specifies whether the block is unused,
whether it’s the last block in the file, or which allocation block is next in the file:

Entry

Meaning

0
1
24095

Block is unused
Block is the last block of the file
Number of next block in the file

pom
\©

For instance, assume that there’s one file on the volume, stored in allocation blocks 8, 11,
12, and 17; the first 16 entries of the block map would read

000000110012

1700001

The first allocation block on a volume typically follows the file directory. It’s numbered 2
because of the special meaning of numbers 0 and 1.

Note: As explained below, it’s possible to begin the allocation blocks immediately
following the master directory block and place the file directory somewhere within

the allocation blocks. In this case, the allocation blocks occupied by the file directory
must be marked with $FFF’s in the allocation block map.

Flat File Directory
The file directory contains an entry for each file. Each entry lists information about one file
on the volume, including its name and location. Each file is listed by its own unique file
number, which the File Manager uses to distinguish it from other files on the volume.

A file directory entry contains 51 bytes plus one byte for each character in the file name. If
the file names average 20 characters, a directory can hold seven file entries per logical

block. Entries are always an integral number of words and don’t cross logical block

boundaries. The length of a file directory depends on the maximum number of files the
volume can contain; for example, on a 400K volume the file directory occupies 12 logical
ocks.
|
The file directory conventionally follows the block map and precedes the allocation blocks,
but a volume-initializing program could actually place the file directory anywhere within the

allocation blocks as long as the blocks occupied by the file directory are marked with

$FFF’s in the block map.

The format of a file directory entry is shown in Figure 9.

Data Organization on Volumes IV-163

ri

o
po)
—}
jo)
tpo)
ae)

a |

Inside Macintosh

byte 0

flFlags (byte)

bit 7=1

if entry used: bit O=1

if file locked

1

flTyp (byte)

version number

2 |

flUsrWds (16 bytes)

information used by the Finder

18

fIFINum (long word)

file number

22

fIStBIk (word)

first allocation block of data fork

24

fiLgLen (long word)

logical end-of-file of data fork

28

fiPyLen (long word)

physical end-of-file of data fork

32

TIRStBIk (word)

first allocation block of resource fork

34 |

fIRLgLen (long word)

logical end-of-file of resource fork

38 | fIRPyLen (long word)

physical end-of-file of resource fork

42

fiCrDat (long word)

date and time of creation

46

flMdDat (long word)

date and time of last modification

50

fINam (byte)

D1

fiINam+1

(bytes)

length of file name
characters of file name

Figure 9. A File Directory Entry
FIStBlk and flRStBlk are 0 if the data or resource fork doesn’t exist.

are given in seconds since midnight, January 1, 1904.

FlCrDat and flMdDat

Each time a new file is created, an entry for the new file is placed in the file directory. Each
time a file is deleted, its entry in the file directory is cleared, and all blocks used by that file

on the volume are released.

Hierarchical Directory Volumes
A hierarchical directory volume contains system startup information in logical blocks
0 and 1 (see Figure 10) that’s read in at system startup. This information is similar to the
system startup information for flat directory volumes; it consists of certain configurable
system parameters, such as the capacity of the event queue, the initial size of the system
heap, and the number of open files allowed.

IV-164 Data Organization on Volumes

The File Manager

logical block 0
es

nen

;
logical block 1

logical block 3
/

eet ereseneee

eebloc

logical

logical block n+1

t

em

startup

Information

sesseeeeeeel

b& ZERO

Pee
teens

sceeeee

;
volume bit map
—

;

If NOt

a startup

;

disk

i volume information block

volume information

logical block 2
ve veaeeeeues
rs

“Ys

veveeeeeees
eee

a
“a
.
=

<=
:

Z

snccecas

ho

unused

ie
allocation block 2

file contents

Z

logical block 1599

allocation block m

Figure 10. An 800K Volume With 1K Allocation Blocks
Logical block 2 of the volume (also known as the volume information block) contains
the volume information. This volume information is a superset of the volume
information found on flat directory volumes. Logical block 3 of the volume begins the
volume bit map, which records whether each block on the volume is used or unused.

The rest of the logical blocks on the volume contain files or garbage (such as parts of
deleted files).

The volume bit map on hierarchical directory volumes replaces the volume allocation block

map used on flat directory volumes. While the bit map does handle volume space
management (as does the block map), it does not handle file mapping. A separate file,

known as the extents tree file, performs this function.

Finally, a file known as the

catalog tree file is responsible for maintaining the hierarchical directory structure; it

corresponds in function to the file directory found on flat directory volumes.

The exact format of the volume information, volume bit map, extents tree file, and catalog

tree file is explained in the following sections. The discussion of the extents tree and

catalog tree files is preceded by a short introduction to a data structure known as a B*-tree
that’s used to organize and access the information in these files.

Data Organization on Volumes IV-165

Inside Macintosh

Volume Information
The volume information is contained in the first 104 bytes of the volume information block
(see Figure 11). This information is written on the volume when it’s initialized, and

modified thereafter by the File Manager.
byte 0

drSigWord (word)

2 |

drCrDate (long word)

6

drLsMod (long word)

10

drAtrb (word)

12

drNmFls (word)

14

drVBMSt (word)

16

drAllocPtr (word)

18

drNmAIBIks (word)

20 | drAIBIkSiz (long word)
24 | drClpSiz (long word)
28

drAIBISt (word)

30

| drNxtCNID (long word)

34

drFreeBks (word)

36

drVN (byte)

37
64

drVN +1 (bytes)
| drVolIBkUp (long word)

68
70

drVSeqNum (word)
drWrCnt (long word)

74
78
82
84
88

| drXTClpSiz (long word)
| drCTClpSiz (long word)
| drNmRtDirs (word)
drFilCnt (long word)
| drDirCnt (long word)

92

drFndrinfo (32 bytes)

124
126

drVCSize (word)
drVCBMSize (word)

128

drCtiICSize (word)

always $4244
date and time of initialization
date and time of last modification
volume attributes
number of files in directory
first block of volume bit map
used internally
number of allocation blocks
allocation block size
default clump size
first block in bit map
next unused directory ID or file number
number of unused allocation blocks
length of volume name
characters of volume name

date and time of last backup
used internally
volume write count
clump size of extents tree file
clump size of catalog tree file
numberof directories in root
number of files on volume
number of directories on volume
information used by the Finder
used internally
used internally
used internally

130 | drXTFISize (long word)

length of extents tree (LEOF and PEOF)

134

extent record for extents tree

| drXTExtRec (12 bytes)

146 | drCTFISize (long word)

length of catalog tree (LEOF and PEOF)

150

first extent record for catalog tree

| drCTExtRec (12 bytes)

Figure 11. Volume Information on Hierarchical Directory Volumes

IV-166 Data Organization on Volumes

The File Manager
64K ROM note: The volume information on a flat directory volume is a subset of
the hierarchical volume information. The flat directory volume information contains
only the fields up to and including drVN+1.

In addition, the names of several fields

have been changed in the hierarchical volume information to reflect their new
function: drLsBkUp, drDirSt, drBILn, and drNxtFNum have been changed to
drLsMod, drVBMSt, drAllocPtr, and drNxtCNID respectively. All of the offsets of
the flat directory volume information, however, have been preserved to maintain
compatibility.
DrLsMod contains the date and time that the volume was last modified (this 1s not
necessarily when it was flushed).

64K ROM note: DrLsMod replaces the field drLsBkUp from flat directory

volumes.

The name drLsBkUp was actually a misnomer; this field has always

contained the date and time of the last modification, not the last backup.

field, drVolBkUp, contains the date and time of the last backup.

Another

DrVBMSt replaces the field drDirSt; it contains the number of the first block in the volume

bit map.

DrAtrb contains the volume attributes, as follows:

Bit

Meaning

7
15

Set if volume is locked by hardware
Set if volume is locked by software

DrClpSiz contains the default clump size for the volume. To promote file contiguity and
avoid fragmentation, space is allocated to a file not in allocation blocks but in clumps. A
clump is a group of contiguous allocation blocks. The clump size is always a multiple of
the allocation block size; it’s the minimum number of bytes to allocate each time the
Allocate function is called or the end-of-file is reached during the Write routine. A clump

size can be set when a particular file is opened, and can also be changed subsequently. If
no clump size is specified, the value found in drClpSiz will be used.
DrNxtCNID replaces the field drNxtFNum; it’s either the next file number or the next

directory ID to be assigned.

Warning: The format of the volume information may be different in future versions
of Macintosh system software.

Volume Bit Map
The flat directory file system uses the volume allocation block map to provide both volume
space management and file mapping; the hierarchical file system instead uses a volume bit
map. The block map contains a 12-bit entry for each allocation block. If an entry is 0, the
corresponding allocation block is unused. If an allocation block is allocated to a file, its
block map entry is nonzero, and can be used to find the next allocation block used by that
file.

Data Organization on Volumes IV-167

—"
\o

esl

jm

ras)
jo)
ij
pou)
TS

ras)

Lew §

Inside Macintosh

The File Manager keeps the entire block map in memory. The size of the block map is

obviously a function of the number of allocation blocks on the volume. Similarly, the
number of allocation blocks depends on the allocation block size. For larger volumes, the
allocation block size must be increased in order to keep the block map to a reasonable size.

A tradeoff occurs between waste of space and speed of file access in this situation.
Obviously, the use of large allocation blocks can waste disk space, particularly with small
files. On the other hand, using smaller allocation blocks increases the size of the block

map; this means the entire block map cannot be kept in memory at one time, resulting in a
time-consuming sector-caching scheme.
The hierarchical file system discards the block map concept entirely, and instead uses a
structure known as the volume bit map. The bit map has one bit for each allocation
block on the volume; if a particular block is in use, its bit is set.
With extremely large volumes, the same space/time tradeoff can become an issue. In
general, it’s desirable to set the allocation block size such that the entire bit map can be kept
in memory at all times.
B*-Trees
This section describes the B*-tree implementation used in the extents tree and catalog tree
files. The data structures described in this section are accessible only through assembly
language; an understanding of the B*-tree data structure is also assumed.
The nodes of a B*-tree contain records; each record consists of certain information (either
pointers or data) and a key associated with that information (see Figure 12). A basic
feature of the B*-tree is that data is stored only in the leaf nodes. The internal nodes (also
known as index nodes) contain pointers to other nodes; they provide an index, used in
conjunction with a search key, for accessing the data records stored in the leaf nodes.

key length

(1 byte)

key

| (up to 255 bytes)

data or pointer

| (limited only by size of node)

Figure 12. A B*-Tree Node Record
Within each node, the records are maintained so that their keys are in ascending order.
Figure 13 shows a sample B*-tree; hypothetical keys have been inserted to illustrate the
structure of the tree and the relationship between index and leaf nodes.

IV-168 Data Organization on Volumes

The File Manager

1 8 | pointer] 16 | pointer|
~ index nodes
f

/

a

| 8 |pointer| 13 {pointer}

a

[16 | pointer} 23 | pointer|

15 [data]
| 8 [data] 10 |data] | 13 [data]
: | 16 |data| 19 [deta] | , 23 [deta] 25 | data]
:

a
=2

™ leaf nodes ~

E

pot)

Figure 13. A Sample B*-Tree

When a data record is needed, the key of the desired record (the search key) is provided.
The search begins at the root node (which is an index node, unless the tree has only one

level), moving from one record to the next until the record with the highest key that’s less

than or equal to the search key is reached. The pointer of that record leads to another node,
one level down in the tree. This process continues until a leaf node is reached; its records
are examined until the desired key is found. (The desired key may not be found; in this
case, the search stops when a key larger than the search key is reached.) Figure 14 shows
a sample B*-tree search path; the arrows indicate the path to the second record in the
second leaf node.

| search key

15
| 8 | pointer} 16 | pointer |

| 8 |pointer| 13| pointer}

\

|16 | pointer} 23 | pointer|

NN

| 8 |data] 10 [data] | 13 |datal 15 |data] | 16 |data]
19 |data| | 23 [data] 25 | datal
Figure 14. A Sample B*-Tree Search Path
All nodes in the B*-tree are of the same fixed size; the structure of a node is shown in
Figure 15.

Data Organization on Volumes IV-169

Inside Macintosh

f | ndFLink (long word)
node ,

NdBLink (long word)

;

ndType (byte)

descriptor

ndLevel (byte)
ndNRecs (word)
record 0

records

<

<
record 1
free space
f

record
offsets

offset to free space

[—

offset to record 1
L

offset to record 0

Figure 15. Structure of a B*-Tree Node
Each node begins with the node descriptor. NDNRecs contains the number of records
currently in the node. NDType indicates the type of node; it contains $FF if it’s a leaf node
and 0 if it’s an index node. NDLevel indicates the level of the node in the tree; leaf nodes
are always at level 1, the first level of index nodes above them are at level 2, and so on.

NDBLink and ndFLink are used only with leaf nodes as a way of quickly moving through
the data records; for each leaf node, they contain pointers to the previous and subsequent

leaf nodes respectively.

The records in a node can be of variable length; for this reason, offsets to the beginning of

each record are needed. The records begin after the field ndNRecs; they’re followed by the
unused space. The offsets to the records begin at the end of the node and work backwards;
they’re followed by an offset to the unused space.
Extents Tree File

File mapping information (or the location of a file’s data on the volume) is contained in the

extents tree file. A file extent is a series of contiguous allocation blocks. Ideally, a file
would be stored in a single extent. Except in the case of preallocated or small files,
however, the contents of a particular file are usually stored in more than one extent on
different parts of a given volume. The extents tree file, organized as a B*-tree, records the
volume location and size of the various extents that comprise a file.

IV-170 Data Organization on Volumes

The File Manager

Each extent on a volume is identified by an extent descriptor; each descriptor consists of
the number of the first allocation block of the extent followed by the length of the extent in
blocks (see Figure 16).
number of extent’s first allocation block (word)

number of allocation blocks in éxtent (word)
Figure 16. Extent Descriptor

=

The extent descriptors are stored in extent records in the leaf nodes of the tree. Each
extent record consists of a key followed by three extent descriptors. The extent records are
kept sorted by the key, which has the format shown in Figure 18.

>
©
2

byte 0

xkrKeyLen (byte)

1

xkrFkType (byte)

2

xkrFNum (long word)

6

xkrFFABN (word)

key length in bytes
|

$00 for data fork; $FF for resource fork

file number
allocation block number within file

Figure 17. Extents Key

Catalog Tree File
The catalog tree file corresponds in function to the flat file directory found on volumes

formatted by the 64K ROM.

Whereas a flat file directory contains entries for files only, the

catalog tree file contains three types of records—file records, directory records, and thread

records. (Threads can be viewed as the branches connecting the nodes of a catalog tree.)

The catalog tree file is organized as a B*-tree; all three types of records are stored in the leaf
nodes. The index nodes contain the index records used to search through the tree.
The catalog tree records consist of a key followed by the file, directory, or thread record.

The records are kept sorted by key. The exact format of the key is shown in Figure 18.

byte 0

_ckrKeyLen (byte)

key length in bytes

1

ckrResrv1 (byte)

used internally

2

ckrParlD (long ward)

parent ID

6

ckrCName (bytes)

file or directory name

Figure 18. Catalog Key

Data Organization on Volumes IV-171

Inside Macintosh

A file record is a superset of the file directory entry found on volumes formatted by the
64K ROM; its contents are shown in Figure 19.

_edrType (byte)

always 2 for file records

cdrResrv2 (byte)

used internally

2

filFlags (byte)

bit 7=1

3

filTyp (byte)

file type

4

filUsrWds (16 bytes)

information used by the Finder

20

FIIFINUm (long word)

file number

24

fiIStBIk (word)

first allocation block of data fork

26

fillgLen (long word)

logical end-of-file of data fork

30

filPyLen (long word)

physical end-of-file of data fork

byte 0

1

if record used; bit O=1

if file locked

34

fiIRStBIk (word)

36

filRLgLen (long word)

logical end-of-file of resource fork

filRPyLen (long word)
filCrDat (long word)

physical end-of-file of resource fork
date and time of creation

48

filMdDat (long word)

date and time of last modification

92

filBkDat (long word)

date and time of last backup

36

filFndrinfo (16 bytes)

additional information used by the Finder

72

filClpSize (word)

file clump size

74

filExtRec (12 bytes)

first extent record for data fork

40
44

86

fiIRExtRec (12 bytes)

98

filResrv (long word)

first allocation block of resource fork

first extent record for resource fork
used internally

Figure 19. File Record
A directory record records information about a single directory; the format of a directory
record is shown in Figure 20.

IV-172 Data Organization on Volumes

The File Manager
byte 0

cdrType (byte)

always 1 for directory records

1

cdrResrv2 (byte)

used internally

2

dirFlags (word)

flags

4

dirVal (word)

valence

6

dirDirID (long word)

directory ID

10

dirCrDat (long word)

date and time of creation

i

14

dirMdDat (long word)

date and time of last modification

=

18

dirBkDat (long word)

date and time of last backup

>

22

dirUsrInfo (16 bytes)

information used by the Finder

=

38

dirFndrinfo (16 bytes)

additional information used by the Finder

°

54

dirResrv (16 bytes)

used internally

Figure 20. Directory Record
Thread records are used in conjunction with directory records to provide a link between a
given directory and its parent. For any given directory, the records describing all of its
offspring are stored contiguously. A thread record precedes each set of offspring; it
contains the directory ID and name of the parent and provides a path to the parent’s
directory record. The format of a thread record is shown in Figure 21.
byte 0

cdrType (byte)

always 3 for thread records

1

cdrResrv2 (byte)

used internally

2

thdResrv (8 bytes)

used internally

10

thdParlD (long word)

parent ID of associated directory

14

thdCName (bytes)

name of associated directory

Figure 21. Thread Record

Data Organization on Volumes IV-173

Inside Macintosh

A portion of a sample tree, along with the corresponding file, directory, and thread records,
is Shown in Figure 22.

<0> MyVol

dirlD = 1

directory record

<1>

= 0

parentID

name

= MyVol

thread record

<1> FBI

file record
<1> Mail

dirlD = 35
<1>

IRS

directory record

file record

<35>

parentID
name

=

= 1

thread record

Mail

<35> Bob

file record
<35> Jody

file record
Figure 22.

Sample Tree, with Catalog Tree Records

DATA STRUCTURES IN MEMORY
This section describes the memory data structures used by the File Manager and any
external file system that accesses files on Macintosh-initialized volumes. Some of this data
is accessible only through assembly language.

IV-174 Data Structures in Memory

The File Manager
The data structures in memory used by the File Manager and all external file systems
include:
m the file I/O queue, listing all asynchronous routines awaiting execution (including the
currently executing routine, if any)
m the volume-control-block queue, listing information about each mounted volume
ma copy of the volume bit map for each on-line volume (volume allocation block map
for flat directory volumes)
= the file-control-block buffer, listing information about each access path
= volume buffers (one for each on-line volume)

bp,
vo)

=

oO
po)
i}
po)
v2

fae)
=

= optional access path buffers (one for each access path)
a the drive queue, listing information about each drive connected to the Macintosh

The File I/O Queue
The file I/O queue is a standard Operating System queue (described in the Operating
System Utilities chapter) that contains parameter blocks for all asynchronous routines
awaiting execution. Each time a routine is called, an entry is placed in the queue; each time
a routine is completed, its entry is removed from the queue.
Fach entry in the file I/O queue consists of a parameter block for the routine that was called.
Most of the fields of this parameter block contain information needed by the specific File
Manager routines; these fields are explained above in the section “(Low-Level File Manager

Routines’. The first four fields of the parameter block, shown below, are used by the File
Manager in processing the I/O requests in the queue.
TYPE

ParamBlockRec

=

RECORD

qLink:
qType:
i1oTrap:
ioCmdAddr:
.

QElemPtr;
INTEGER;
INTEGER;
Ptr;

8

{next queue entry}
{queue type}
{routine trap}
{routine address}
{rest

of

block}

END;

QLink points to the next entry in the queue, and qType indicates the queue type, which
must always be ORDGoQType). IOTrap and ioCmdAddr contain the trap word and
address of the File Manager routine that was called.
You can get a pointer to the header of the file I/O queue by calling the File Manager
function GetFSQHdr.
FUNCTION

GetFSQHdr

:

QHdrPtr;

[Notin ROM]

GetFSQHdr returns a pointer to the header of the file I/O queue.

Data Structures in Memory IV-175

Inside Macintosh

Assembly-language note:
the file I/O queue.

The global variable FSQHdr contains the header of

Volume Control Blocks
Each time a volume is mounted, its volume information is read from it and is used to build
a new volume control block in the volume-control-block queue (unless an ejected

or off-line volume is being remounted). A copy of the volume block map is also read from
the volume and placed in the system heap, and a volume buffer is created in the system
heap.

The volume-control-block queue is a standard Operating System queue that’s maintained in
the system heap. It contains a volume control block for each mounted volume. A volume

control block is a 178-byte nonrelocatable block that contains volume-specific information.
It has the following structure:
TYPE

VCB

=

RECORD

qLink:
qType:
vebFlags:
vebSigWord:
vcebCrDate:
vcbLsMod:

QElemPtr;
INTEGER;
INTEGER;
INTEGER;
LONGINT;
LONGINT;

{next queue entry}
{queue type}
{bit 15=1 if dirty}
{$4244 for hierarchical,
$D2D7 for flat}
{date and time of
initialization}
{date and time of last modification}

vcbAtrb:

INTEGER;

{volume

attributes}

{number

of

vcbNmF 1s:
VCbVBMSt :
vcbAllocPtr:

vcbNmA1Blks:

INTEGER;
INTEGER;
INTEGER;
INTEGER;

{number of files in directory}
{first block of volume bit map}
{used internally}
allocation

blocks}

vcbA1B1kSiz:
vcbClpSiz:
vcbA1B1St:

LONGINT;
LONGINT;
INTEGER;

{allocation block size}
{default clump size}
{first block in block map}

vcebFreeBks:

INTEGER;

{number

VCbNxtCNID:

VCbVN:
vcbDrvNum:
vcbDRefNum:

vcbFSID:

vcebVRefNum:

LONGINT;

STRING[27];
INTEGER;
INTEGER;

INTEGER;

INTEGER;

{next

unused

of

directory

unused

ID

{volume name}
{drive number}
{driver
reference

number}

{volume

number}

{file-system

or

file

allocation

identifier}

reference

vcbMAdr:
vcbBufAdr:
vcbMLen:

Ptr;
Ptr;
INTEGER;

{pointer to block map}
{pointer to volume buffer}
{number of bytes in block map}

vebDirBlk:
vcbVolBkUp:
vebVSeqNum:
vebWrCnt:
vcbXTClpSiz:
vcbCTClpSiz:

INTEGER;
LONGINT;
INTEGER;
LONGINT;
LONGINT;
LONGINT;

{used internally}
{date and time of last
{used internally}
{volume write count}
{clump size of extents
{clump size of catalog

vcebDiriIndex:

vcbNmRtDirs:
vebFilCnt:
vebDirCnt:

INTEGER;

INTEGER;
LONGINT;
LONGINT;

IV-176 Data Structures in Memory

{used

internally}

{number
{number
{number

of
of
of

backup}
tree
tree

number}

blocks}

file}
file}

directories
in root}
files
on volume}
directories
on volume}

The File Manager
vcbFndriInfo:

ARRAY[1..8]

vcebVvCSize:

INTEGER;

VCbVBMCSiz:
vebCtlCSiz:
vcbXTAI1Bks:
vcbCTAIBks:
vcbxXTRef:

INTEGER;
INTEGER;
INTEGER;
INTEGER;
INTEGER;

OF LONGINT;
{information
{ Finder}
{used internally}

{used
{used
{size
{size
{path

internally}
internally}
in blocks of extents
in blocks of catalog
reference number for

{ file}
{path reference

vcbCTRef:

INTEGER;

vebCt1Buf:

Ptr;

{ file}
{pointer

vebDirIDM:
vcbOffsM:

LONGINT;
INTEGER

{directory
{offspring

END;

used

{ caches}

to

number

extents

and

for

by

the

}

tree file}
tree file}
extents tree

}

catalog

}

catalog

tree

tree

}

last searched}
index at last search}

64K ROM note: A volume control block created for a flat volume is a subset of
the above structure. It’s actually smaller and contains only the fields up to and

including vcbDirBlk. In addition, the names of several fields have been changed to
reflect the fact that they contain different information on hierarchical volumes:
vcbLsBkUp, vcbDirSt, vcbBlLn, vcbNmBlks, and vcbNxtFNum have been
changed to vcbLsMod, vcbVBMSt, vcbAllocPtr, vcbNmAIBlks, and vcbNxtCNID

respectively.

QLink points to the next entry in the queue, and qT ype indicates the queue type, which
must always be ORD(fsQT ype). Bit 15 of vcbFlags is set if the volume information has
been changed by a routine call since the volume was last affected by a FlushVol call.
VCBLsMod contains the date and time that the volume was last modified (this is not
necessarily when it was flushed).
64K ROM note: VCBLsMod replaces the field vcbLsBkUp from flat directory
volumes. The name vcbLsBkUp was actually a misnomer; this field has always
contained the date and time of the last modification, not the last backup. Another
field, vcbVolBkUp, contains the date and time of the last backup.
VCBAtrb contains the volume attributes, as follows:

Bit

Meaning

O-4

Setif inconsistencies were found between the volume information and the file
directory when the volume was mounted
Set if volume is busy (one or more files are open)
Set if volume is locked by hardware
Set if volume is locked by software

6
7
15

VCBVBMSt contains the number of the first block in the volume bit map; on flat volumes,
it contains the first block of the file directory. WCBNmAIBIks contains the number of
allocation blocks on the volume, and vcbFreeBks specifies how many of those blocks are
unused. VCBAIBISt is used only with flat volumes; it contains the number of the first
block in the block map.

Data Structures in Memory IV-177

a
oO

a
oO

<=

=
os
©

Inside Macintosh

VCBDrvNum contains the drive number of the drive on which the volume is mounted;

vcbDRefNum contains the driver reference number of the driver used to access the volume.

When a mounted volume is placed off-line, vcbDrvNum is cleared. When a volume is

ejected, vcbDrvNum is cleared and vcbDRefNum is set to the negative of vcbDrvNum
(becoming a positive number). WVCBFSID identifies the file system handling the volume;
it’s O for volumes handled by the File Manager, and nonzero for volumes handled by other
file systems.

When a volume is placed off-line, its buffer and bit map (or block map, in the case of flat

directory volumes) are released. Wheri a volume is unmounted, its volume control block is
removed from the volume-control-block queue.
You can get a pointer to the header of the volume-control-block queue by calling the File
Manager function GetVCBQHadr.

FUNCTION

GetVCBQHdr

: QHdrPtr;

[Notin ROM]

GetVCBQHar returns a pointer to the header of the volume-control-block queue.

Assembly-language note: The global variable VCBQHdr contains the header of
the volume-control-block-queue. The default volume’s volume control block is
pointed to by the global variable Def VCBPtr.
File Control Blocks
Each time a file is opened, the file’s directory entry is used to build a file control block
in the file-control-block buffer, which contains information about all access paths.
The file-control-block-buffer is a nonrelocatable block in the system heap; the first word
contains the length of the buffer.
The number of file Control blocks is contained in the system startup information on a
volume. With the 64K ROM, the standard number is 12 file control blocks on a Macintosh
128K and 48 file control blocks on the Macintosh 512K. With the 128K ROM, there’s a

standard of 40 file control blocks per volume.

Each open fork of a file requires one access path. Two access paths are used for the
system and application resource files (whose resource forks are always open). On
hierarchical directory volumes, two access paths are also needed for the extents and catalog
trees. You should keep such files in mind when calculating the number of files that can be
opened by your application.
Note: The size of the file-control-block buffer is determined by the system startup
information stored on a volume.
You can get information from the file control block allocated for an open file by calling the
File Manager function PBGetFCBInfo. When you call PBGetFCBInfo, you’ll use the

IV-178 Data Structures in Memory

The File Manager

following 12 additional fields after the standard eight fields in the parameter block record
FCBPBRec:
ioRefNum:

INTEGER;

{path

filler:
ioFCBIndx:

INTEGER;
LONGINT;

{not
{FCB

10FCBFlags:

INTEGER;

{flags}

ioFCBF1Nm:

1oFCBStBlk:

LONGINT;

{file

INTEGER;

reference

used}
index}

number}

number}

{first

allocation

block

1OFCBEOF :
ioFCBPLen:

LONGINT;
LONGINT;

{logical end-of-file}
{physical end-of-file}

1oFCBClpSiz:
10oFCBParID:

LONGINT;
LONGINT;

{file clump size}
{parent directory

10FCBCrPs:
10FCBVRefNum:

LONGINT;
INTEGER;

{mark }
{volume

reference

of

file}

poe
\&

a

Oo

number}

j=)
~
jo)
T3

ID}

fae)

~~

FUNCTION PBGetFCBInfo
OSErr;

Trap macro
Parameter block

12

<—

ioCompletion

pointer

18

ioNamePtr

pointer

44

ioFCBPLen

long word

16

<—>
<>
—>
<—
<—
<—
<—

22
24
28
32
36
38
40

<—

48

<—
<—
<—

<—

FCBPBPtr;

async:

BOOLEAN)

_GetFCBInfo

—>

<—

(paramBlock:

52
54

58

ioResult

ioVRefNum
ioRefNum
ioFCBIndx
ioFCBFINm
ioFCBFlags
ioFCBStBlk
ioFCBEOF
ioFCBCrPs

ioFCBVRefNum
ioFCBClpSiz

ioFCBParID

word

word
word
long word
long word
word
word
long word

long word

word
long word

long word

PBGetFCBInfo returns information about the specified open file. If ioFCBIndx is
positive, the File Manager returns information about the file whose file number is
ioFCBIndx on the volume specified by ioVRefNum (which may contain a drive number,
volume reference number, or working directory reference number).

If ioVRefNum is 0, all

open files are indexed; otherwise, only open files on the specified volume are indexed.

If ioFCBIndx is 0, the File Manager returns information about the file whose access path is
specified by 1oRefNum.
Assembly-language note:

The global variable FCBSPtr points to the length

word of the file-control-block buffer.

Data Structures in Memory IV-179

Inside Macintosh

Each file control block contains 94 bytes of information about an access path; Figure 23

shows its structure (using the assembly-language offsets).
byte 0

fcbFiNum (long word)

file number

4

fcbMdRByt (byte)

flags

rs)

fcbTypByt (byte)

version number

6

fcDSBIlk (word)

first allocation block of file

8

fcbEOF (long word)

logical end-of-file

12

fcbPLen (long word)

physical end-of-file

16

fcbCrPs (long word)

mark

20

fcbVPtr (pointer)

pointer to volume control block

24

fcbBfAdr (pointer)

pointer to access path buffer

28

fcbFIPos (word)

used internally

30

fcbCImpSize (long word)

file clump size

34

fcbBTCBPtr (long word)

pointer to B*-tree control block

38

febExtRec (12 bytes)

first three file extents

90

fcbFType (long word)

file’s finder type bytes

04

fcbCatPos (long word)

used internally

38

febDirlD (long word)

file’s parent ID

62

fcbCName (bytes)

name of open file

Figure 23. A File Control Block
64K ROM

note:

The structure of a file control block in the 64K ROM version of

the File Manager is a subset of the above structure. The old file control block

contained only the fields up to and including fcbF1Pos.

FCBMdRByt (which corresponds to ioFCBFlags in the parameter block for

PBGetFCBInfo) contains flags that describe the status of the file, as follows:

Ie ©

Bit

Meaning

Set if data can be written to the file
Set if the entry describes a resource fork

Set if the file has been changed since it was last flushed

IV-180 Data Structures in Memory

The File Manager
Warning: The size and structure of a file control block may be different in future
versions of Macintosh system software.

The Drive Queue
Disk drives connected to the Macintosh are opened when the system starts up, and
information describing each is placed in the drive queue. This is a standard Operating

System queue, and each entry in it has the following structure:
TYPE DrvQEl = RECORD

qLink:

QElemPtr;

{next

dQDrive:
dQRefNum:
daQFSID:
dQDrvSz:

INTEGER;
INTEGER;
INTEGER;
INTEGER;

dQDrvSz2:

INTEGER;

{drive number}
{driver reference
number}
{file-system identifier}
{number of logical blocks}
{ on drive}
{additional
field to handle}

qType:

INTEGER;

{queue

{

queue

large

type}

entry}

drive

size}

END;

QLink points to the next entry in the queue. If qType is 0, this means the number of logical

blocks on the drive is contained in the dQDrvSz field alone. If qType is 1, both dQDrvSz
and dQDrvSz2 are used to store the number of blocks; dqDrvSz2 contains the high-order
word of this number and dQDrvSz contains the low-order word.
DQDrive contains the drive number of the drive on which the volume is mounted;
dQRefNum contains the driver reference number of the driver controlling the device on
which the volume is mounted. DQFSID identifies the file system handling the volume in
the drive; it’s 0 for volumes handled by the File Manager, and nonzero for volumes
handled by other file systems.

Four bytes of flags precede each drive queue entry; they’re accessible only from assembly
language.

Assembly-language note:

These bytes contain the following:

Byte

Contents

0

Bit 7=1 if volume is locked

2
3

is nonejectable but driver wants a call
Used internally during system startup
Bit 7=0 if disk is single-sided

1

0 if no disk in drive; 1 or 2 if disk in drive; 8 if nonejectable disk in drive;

$FC-$FF if disk was ejected within last 1.5 seconds; $48 if disk in drive

You can get a pointer to the header of the drive queue by calling the File Manager function
GetDrvQHdr.

Data Structures in Memory IV-1&1

—_

~
2
s

5

™
™

Inside Macintosh
FUNCTION

GetDrvQHdr

:

QHdrPtr;

[Notin ROM]

GetDrvQHadr returns a pointer to the header of the drive queue.
Assembly-language note:
the drive queue.

The global variable DrvQHdr contains the header of

The drive queue can support any number of drives, limited only by memory space.

USING AN EXTERNAL FILE SYSTEM
Due to the complexity of writing an external file system for the 128K ROM version of the
File Manager, this subject is covered in a separate document. To receive a copy, write to:
Developer Technical Support
Mail Stop 3-T
Apple Computer, Inc.
20525 Mariani Avenue
Cupertino, CA 95014

IV-182

Using an External File System

The File Manager

SUMMARY OF THE FILE MANAGER
Constants
{

Flags

in

file

fOnDesk

=

fHasBundle
fInvisible

=
=

fDisk

=

fTrash
fDesktop

{ Values

information
{set

1;

=
=

if

file

is

in
on

fsRdWrShPerm

= 4;

modes

}

=

3;

{at

=

Ps se

eo

“Se

™e

l
DWNr OO

rdVerify

Q;
1;
2;

{set
{set
{set
{add

disk

read/write

{whatever is
{request for
{request for
{request for
{request for

fsAtMark
fsFromStart
fsFromLEOF
fsFromMark

on

desktop

}
(hierarchical

current

}

Trash window}
desktop}

in

=
=
=

Positioning

is

Finder

{file

is
is

fsCurPerm
fsRdPerm
fsWrPerm

{

the

0;

{file
{file

requesting

fsRdWrPerm

by

8192;
16384;

-3;
-2;

for

used

{ volumes
only) }
{set if file has a bundle}
{set if file's
icon is invisible}

“we

CONST

window}

permission}

currently allowed}
read permission only}
write permission only}
exclusive read/write permission}
shared read/write permission}

mark}

mark relative to beginning of file}
mark relative to logical end-of-file}
mark relative to current mark}
to above for read-verify}

Data Types
TYPE

FIn£fo

=

RECORD

fdType:

fdCreator:
fdFlags:
fdLocation:
fdFldr:

OSType;
OSType;
INTEGER;

Point;

INTEGER

{file

{file's
{flags}
{file's

{file's

type}

creator}
location}

window}

END;

FXInfo

= RECORD
fdiIconID:
fdUnused:
fdComment :
fdPutAway:

{icon ID}
INTEGER;
ARRAY [1. .4]
OF INTEGER;
{reserved}
INTEGER;
{comment ID}
{home directory ID}
LONGINT;

END;

Summary of the File Manager IV-183

—
Oo

ey

=<

o
je)
~
po)
4xen)

rae

Low

|

Inside Macintosh
Dinfo

= RECORD

frRect:
frFlags:
frLocation:

frView:

Rect;
INTEGER;
Point;

INTEGER;

{folder's
{flags}
{folder's

{folder's

rectangle}
location}

view}

END;
DXInfo

= RECORD

frScroll:
Point;
{scroll position}
frOpenChain:
LONGINT; {directory ID chain
frUnused:
frComment:
frPutAway:

INTEGER;
INTEGER;
LONGINT;

{ folders}
{reserved}
{comment
ID}
{directory
ID}

of

open

}

END;

ParamBlkType

=

ParmBlkPtr
=
ParamBlockRec =

qLink:
qType:
ioTrap:
i1oCmdAddr :
ioCompletion:
ioResult:

ioNamePtr:

ioVRefNum:

CASE

ParamBlkType

ioParam:
(10RefNum:
ioVersNum:
ioPermssn:
ioMisc:
ioBuffer:
ioReqCount :
ioActCount:
10PosMode:

ioPosOffset:
fileParam:
(10FRefNum:
ioFVersNum:
fillerl:
ioFDirIndex:
1oFlAttrib:
ioFlVersNum:
ioFlFndrInfo:
ioF1Num:
ioF1StBlk:
ioF1lLgLen:
ioF1PyLen:
ioF1RStBlk:
ioF1lRLgLen:

(ioParam,

fileParam, volumeParam,
cntrlParam) ;

“ParamBlockRec;
RECORD

QElemPtr;
INTEGER;
INTEGER;
Ptr;
ProcPtr;

{next queue entry}
{queue type}
{routine trap}
{routine address}
{completion routine}

StringPtr;

{pathname}

OSErr;

INTEGER;

{result

code}

{volume

reference

{
{

number,

number,
or working
reference number}

drive

directory

}

}

OF

INTEGER;
SignedByte;
SignedByte;
Ptr;
Ptr;
LONGINT;
LONGINT;
INTEGER;
LONGINT);
INTEGER;
SignedByte;
SignedByte;
INTEGER;
SignedByte;
SignedByte;
FInfo;
LONGINT;
INTEGER;
LONGINT;
LONGINT;
INTEGER;
LONGINT;

IV-184 Summary of the File Manager

{path reference number}
{version number}
{read/write permission}
{miscellaneous}
{data buffer}
{requested number-of bytes}
{actual number of bytes}
{positioning mode and newline
{

character}

{positioning

}

offset}

{path reference number}
{version number}
{not used}
{directory index}
{file attributes}
{version number}
{information used by the Finder}
{file number}
{first allocation block of data fork}
{logical end-of-file of data fork}
{physical end-of-file of data fork}
{first allocation block of resource
}
{ fork}
{logical end-of-file of resource fork}

The File Manager
ioF1RPyLen:

ioVClpSiz:

}

LONGINT;
INTEGER;
LONGINT;
LONGINT;
INTEGER;
INTEGER;
INTEGER;
INTEGER;
INTEGER;
LONGINT;
LONGINT;

{not used}
{volume
index}
{date and time
{date and time

of
of

initialization}
last modification}

INTEGER;

{first block
in block map}
{next unused file number}
{number of unused allocation

(filler2:

1OVAtrb:
1LOVNmF
1s
1ovDirSt:
10VB1Ln:
LOVNMAILBILlks:
10VA1B1kSiz:

resource

creation}
last modification}

LONGINT) ;

i1OVLSBkUp:

of

of
of

LONGINT;

1oVolIndex:
iovCrDate:

end-of-file

{ fork}
{date and
{date and

time
time

1oF1CrDat:
10F1MdDat:
volumeParam:

10A1B1St:
LOVNxtFNum:
10OVFrBlk:
cntrlParam:
.
{used

{physical

LONGINT;

{volume attributes}
{number of files in directory}
{first block of directory}
{length of directory in blocks}

=

oO
pot)
~
ee)
T2
fae)

{number of allocation blocks}
{size of allocation blocks}

{number

LONGINT;
INTEGER) ;

of

by

Device

=

RECORD
QElemPtr;

{queue

INTEGER;

{routine

bytes

to

allocate}

Low

blocks}

Manager}

END;

HParmBlkPtr
HParamBlockRec

“HParamBlockRec;

qLink:
qType:

INTEGER;

i1oCmdAddr:

Ptr;

ioResult:
i1oNamePtr:
i1oVRefNum:

OSErr;

ioTrap:

ioCompletion:

CASE

ParamBlkType

ioParam:
(1oRefNum:
1oVersNum:
ioPermssn:
1oMisc:
loBuffer:

ioReqCount :
ioActCount:

10oPosMode:
i1oPosOffset:
fileParam:
(10oFRefNum:
ioFVersNum:
fillerl:

1oFDirIndex:

ProcPtr;
StringPtr;
INTEGER;

OF
INTEGER;

SignedByte;

SignedByte;

Ptr;
Ptr;
LONGINT;
LONGINT;
INTEGER;

LONGINT) ;
INTEGER;

SignedByte;
SignedByte;
INTEGER;

ioFlAttrib:
10F1VersNum:

SignedByte;
SignedByte;

1oDirID:

Finfo;
LONGINT;
INTEGER;

ioFlFndriInfo:

1ioF1StBlk:

{queue

link}

type}

trap}

{routine

address}

{completion

routine}

{result

code}

{volume

reference

{pathname}
{

number,

{

reference

{path

or

number,

working

drive

directory

}

}

number}

reference

number}

{version number}
{read/write permission}
{miscellaneous }
{data buffer}
{requested number of bytes}
{actual number of bytes}
{positioning mode and newline
{ character}
{positioning offset}

}

{path reference
number}
{version number}
{not used}
{directory
index}
{file attributes}

{version number}
{information used by the Finder}
{directory ID or file number}
{first

allocation

block

of

—"
\6

data

fork}

Summary of the File Manager IV-I8&5

|

Inside Macintosh
ioFlLgLen:

LONGINT;

{logical

1oF1LRStBlk:

INTEGER;

{first

ioFlPyLen:

LONGINT;

ioF1RLgLen:

{ fork}
{logical

LONGINT;

ioF1RPyLen:

LONGINT;

ioF1lCrDat:

LONGINT;

10F1MdDat:
volumeParam:
(filler2:

LONGINT)

{
;

INTEGER;
LONGINT;
LONGINT;

fork}

{date

LOVNXtCNID:

LONGINT;

ioVSigwWord:
ioVDrvinfo:
1LoVDRefNum:
1OVFSID:
1OVBkUp:
L1ovSeqNum:
i1oVWrCnt

INTEGER;
INTEGER;
INTEGER;
INTEGER;
LONGINT;
INTEGER;
LONGINT;

iovDirCnt:

LONGINT;

10Al1B1St:

INTEGER;

ioVFrBlk:

INTEGER;

10oVFilCnt:

LONGINT;

ioVFndriInfo:

ARRAY{1..8]

of

fork}

fork}

resource

resource

fork}

resource

}

{volume index}
{date and time
{date and time

of
of

initialization}
last modification}

{not

used}

{first

{number

{next

of

last

attributes}
of files
in

block

of

internally}

{size of
{default
{first

time

of

modification}

directory}

volume

allocation

bitmap}

blocks}

allocation blocks}
clump size}

block

in

unused

{number

of

{number

of

volume

node

block

ID}

unused

allocation

files

on

{volume signature}
{drive number}
{driver reference number}
{file-system identifier}
{date and time of last backup}
{used internally}
{volume write count}
{number

OF

of

LONGINT);

volume}

directories

on

map}

blocks}

volume}

{information
used
{ the Finder}

by

END;

CInfoType

=

(hfileInfo,dirInfo) ;

CInfoPBPtr
CInfoPBRec

=
=

“CInfoPBRec;
RECORD

qLink:

QElemPtr;

{next

1oCmdAddr:

Ptr;

{routine

1oResult:

OSErr;

ioVRefNum:

INTEGER;

qType:
ioTrap:

ioCompletion:
ioNamePtr:

INTEGER;
INTEGER;

ProcPtr;
StringPtr;

i1oFRefNum:
ioFVersNum:

INTEGER;
SignedByte;

10FDirIndex:
1oFlAttrib:
filler2:

INTEGER;
SignedByte;
SignedByte;

fillerl:

SignedByte;

IV-186 Summary of the File Manager

}

creation}

{used

INTEGER;

of

data

of

INTEGER;
LONGINT;
LONGINT;

of

data

time

i1oAllocPtr:

iOVA1IB1kSiz:
1oVClpSiz:

block

end-of-file

and

{volume
{number

INTEGER;

of

end-of-file

and

INTEGER;
INTEGER;

1oVNmMA1Blks:

allocation

{date

10VAtrb:
ioVNmF 1s:

ioVBitMap:

of

end-of-file

{physical

LONGINT;

10VolIndex:
iovCrDate:
1LOVLSMod:

end-of-file

{physical

queue

entry}

{queue type}
{routine trap}

address}

{completion

routine}

{result

code}

{volume

reference

{pathname}
{

{

number,

reference

or

number,

working

number}

{file reference number}
{version number}

{not

used}

{directory index}
{file attributes}
{not used}

drive

directory

}

}

}

The File Manager
CASE CInfoType
OF
hFileInfo:
(LoF1Fndrinfo:
FInfo;
1oDirID:
LONGINT;
ioF1StBlk:

INTEGER;

10oF1lLgLen:

LONGINT;

ioF1RStBlk:

INTEGER;

ioF1lPyLen:

LONGINT ;

ioF1RLgLen:
ioF1RPyLen:

LONGINT;
LONGINT;

of

fork}

resource

}

{information
{ Finder}

LONGINT) ;

1oDrDirID:

LONGINT;

ioDrNmFl1s:

INTEGER;

filler3:

ARRAY

10oDrMdDat:

[1..9]

LONGINT;

LONGINT;

10oDrBkDat:

end-of-file

{ fork}

resource

Dinfo;

LONGINT;

ioDrCrDat:

of

{file

10oF1BkDat:

diriInfo:
(1oDrUsrWds:

{physical

end-of-file

LONGINT;

LONGINT;

1oF1ClpSiz:

fork}

{logical

FXInfo;

LONGINT;

10F1MdDat:

10F1ParID:

{

{date and time of creation}
{date and time of last modification}
{date and time of last back-up}
{additional information used by the

1oF1CrDat:

10F1XFndrinfo:

{information used by the Finder}
{directory ID or file number}
{first allocation block of data fork}
{logical end-of-file of data fork}
{physical end-of-file of data fork}
{first allocation block of resource
}

LONGINT;

ioDrFndrinfo:

DXInfo;

1oDrParID:

LONGINT) ;

{

Finder}

parent

{file's

{directory
{number

OF

of

INTEGER;

{date

{date

{date

directory

clump

ID

size}

used

ID}

files

by
in

the

creation}

and

time

of

last

{additional
{ Finder}

of

last

parent

}

modification}

information

{directory's

~

directory}

of

time

poe)

}

time

back-up}
used

by

directory

the

}

ID}

END;

CMovePBPtr
CMovePBRec

qLink:

=
=

“CMovePBRec;
RECORD

QElemPtr;

qType:

INTEGER;

ioCmdAddr:

Ptr;

ioResult:

OSErr;

ioTrap:

INTEGER;

ioCompletion:
ioNamePtr:

ProcPtr;
StringPtr;

ioVRefNum:

INTEGER;

fillerl:

LONGINT;

{next queue entry}
{queue type}
{routine trap}
{routine address}
{completion routine}
{result
code}
{pathname }
{volume
reference

{

{

ioNewName

:

filler2:
1oNewDirID:
filler3:
10oDirID:

StringPtr;

LONGINT;
LONGINT;
ARRAY[1..2]
LONGINT) ;

number,

reference

or

{not used}
{name of new
{not

used}

number}

{directory

ID

{directory

ID

OF

LONGINT;

number,

working

drive

directory

}

}

directory}
of

new

of

current

{not

directory}

used}

=

o

(integer) }

and

and

—
vo)

directory}

END;

Summary of the File Manager IV-187

eu)
Te
om

Lea §

Inside Macintosh
WDPBPtr

=

WDPBRec

“WDPBRec;

= RECORD

qLink:
qType:
ioTrap:
ioCmdAddr :
ioCompletion:
ioResult:
ioNamePtr:
10VRefNum:

QElemPtr;
INTEGER;
INTEGER;
Ptr;
ProcPtr;
OSErr;
StringPtr;
INTEGER;

LOWDProcID:
LOWDVRefNum:

LONGINT;
INTEGER;

filler2:

ARRAY[1..7]

FCBPBPtr
FCBPBRec

=
=

LONGINT)

number,

reference

reference

{not

INTEGER;

END;

used}

{working

or

number,

working

number}

directory

drive

directory

}

}

index}

{working directory user identifier}
{working directory's volume
}
{ reference number}
;

*“FCBPBRec;
RECORD

OF

INTEGER;

{working

{not

used}

directory's

directory

ID}

qLink:
qType:
ioTrap:
ioCmdAddr :
ioCompletion:
ioResult:
ioNamePtr:
ioVRefNum:

QElemPtr;
INTEGER;
INTEGER;
Ptr;
ProcPtr;
OSErr;
StringPtr;
INTEGER;

ioRefNum:
filler:

INTEGER;
INTEGER;

{next queue entry}
{queue type}
{routine trap}
{routine address}
{completion routine}
{result code}
{pathname}
{volume reference number,
drive }
{ number,
or working directory }
{ reference number}
{path reference number}
{not used}

LONGINT;
INTEGER;
INTEGER;
LONGINT;
LONGINT;
LONGINT;
INTEGER;
LONGINT;
LONGINT;

{file number}
{flags }
{first allocation block of
{logical end-of-file}
{physical end-of-file}
{mark}
{volume reference number}
{file's clump size}
{parent directory ID}

i10oFCBIndx:

ioFCBF1Nm:
1oFCBFlags:
10oFCBStB1lk:
LOFCBEOF :
i1oFCBPLen:
10FCBCrPs:
ioFCBVRefNum:
ioFCBClpSiz:
ioFCBParID:

END;
VCB

{

INTEGER;

ioWDDirID:

{volume

{

fillerl:

LoWDIndex:

{next queue entry}
{queue type}
{routine trap}
{routine address}
{completion routine}
{result code}
{pathname}

=

LONGINT;

RECORD

{FCB

qLink:
qType:
vebFlags:
vebSigWord:

QElemPtr;
INTEGER;
INTEGER;
INTEGER;

vebCrDate:
vcbLsMod:
|

LONGINT;
LONGINT;

vcbNmF 1s:

INTEGER;

vebAtrb:

INTEGER;

IV-188 Summary of the File Manager

index}

file}

{next queue entry}
{queue type}
{bit 15=1 if dirty}
{$4244 for hierarchical,
}
{SD2D7 for flat}
{date and time of initialization}
{date and time of last }
{ modification}
{volume

{number

attributes}

of

files

in

directory}

4

The File Manager
VCbVBMSt:
vcbAllocPtr:

vcbNmA1LBlks:
vcbA1B1kSiz:

vebClpSiz:

vcbAl1B1St:
VCDNXtCNID:
vcbFreeBks:
vVCbVN:
vebDrvNum:
vcbDRefNum:
vcbFSID:
vcbVRefNum:
vcbMAdr:
vcbBufAdr:
vcbMLen:
vcbDirIndex:

vcbDirBlk:

vcbVolBkUp:

vebVSeqNum:

vcbWrCnt:

vcbXTClpSiz:

vcbCTClpSiz:

INTEGER;
INTEGER;
INTEGER;
LONGINT;
LONGINT;
INTEGER;
LONGINT;
INTEGER;
STRING [27];
INTEGER;
INTEGER;
INTEGER;
INTEGER;
Ptr;

Ptr;
INTEGER;
INTEGER;
INTEGER;
LONGINT;
INTEGER;
LONGINT;
LONGINT;
LONGINT;
INTEGER;
LONGINT;
LONGINT;

vcbNmRtDirs:
vebFilCnt:
vebDirCnt:
vebFndrinfo:

ARRAY[1..8}

vcebvCSize:
VCbVBMCSiz:
vcebCt1CSiz:
vcbXTAIBILlks:

INTEGER;
INTEGER;
INTEGER;
INTEGER;

vcbCTAIBlks:

INTEGER;

vcbxXTRef:

INTEGER;

vcbCTRef:

INTEGER;

vcbCtl1lBuf:

Ptr;

vcbDirIDM:

LONGINT;
INTEGER

vcbOffsM:
END;
RECORD

qLink:

QElemPtr;

qtype:
dQoDrive:
dQRefNum:
GQFSID:
qadQDrvSz:
dqdQDrvsSz2:

INTEGER;

END;

INTEGER;

INTEGER;
INTEGER;
INTEGER

INTEGER

{first block of volume bit map}
{used internally}
{number of allocation blocks}
{allocation block size}
{default clump size}
{first block in bit map}
{next unused node ID}
{number of unused allocation }
{ blocks}

pod,
\O

{volume name}
{drive number}
{driver
reference

number}

a

{volume

number}

joe)
jem |
j=)
itxo)
fas)

{file-system

ir

identifier}

reference

rd
pa

{pointer to block map}
{pointer to volume buffer}
{number of bytes in block map}
{used internally}
{used internally}
{date and time of last backup}
{used internally}
{volume write count}
{clump size of extents tree file}
{clump size of catalog tree file}
{number of directories in root}

Lame |

{number of files
on volume}
{number of directories
on volume}
OF LONGINT;
{information
used
}
{ by the Finder}

{used

internally}

{used

internally}

{used internally}
{size in blocks of extents tree
{ file}
{size in blocks of catalog tree
{ file}
{path reference number for }
{ extents tree file}
{path reference number for }
{ catalog tree file}
{pointer to extents and catalog
{ caches}
{directory last searched}
{offspring index at last search}

{next

{queue

{drive

queue

{driver

type}

}

}

entry}

number}

reference

{file-system

}

number}

identifier}

{number of logical blocks}
{additional field to handle
{ large drive}

}

Summary of the File Manager IV-I8&9

Inside Macintosh

High-Level Routines [Not in ROM]
Accessing Volumes
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION

(drvNum:

INTEGER;

INTEGER;

VAR

Get VRefNum

(pathRefNum:

GetVol

OSErr;
(volName:

StringPtr;

VAR

(fileName:

Str255;

vRefNum:

INTEGER;

VAR

refNum:

INTEGER)

OSErr;

vRefNum:

INTEGER;

VAR

refNum:

GetVinfo

SetVol

FlushVol
UnmountVol

Eject

(volName:
(volName:
(volName:
(volName:

volName:

freeBytes:

INTEGER;

VAR

StringPtr;
StringPtr;
StringPtr;
StringPtr;

StringPtr;
LONGINT)

vRefNum:

vRefNum:

vRefNum:
vRefNum:
vRefNum:
vRefNum:

VAR

vRefNum:

OSErr;

INTEGER)
INTEGER)

INTEGER)
INTEGER)
INTEGER)
INTEGER)

OSErr;

OSErr;
OSErr;
OSErr;
OSErr;

Accessing Files
FUNCTION
FUNCTION
FUNCTION

FSOpen
OpenRF

FSRead

FUNCTION

FSWrite

FUNCTION
FUNCTION

GetFPos

FUNCTION
FUNCTION
FUNCTION
FUNCTION

GetEOF
SetEOF
Allocate
FSClose

SetFPos

(fileName:

Str255;

INTEGER)

(refNum:

OSErr;

INTEGER;

VAR

count:

LONGINT;

buff£Ptr:

Ptr)

INTEGER;

VAR

count:

LONGINT;

buffPtr:

Ptr)

INTEGER;
INTEGER;

VAR filePos:
LONGINT)
OSErr;
posMode:
INTEGER;
posOff:

OSErr;
(refNum:
OSErr;
(refNum:
(refNum:
LONGINT)

OSErr;

(refNum:

INTEGER;

VAR

(refNum:

INTEGER;

logEOF:

LOgEOF:

(refNum:

INTEGER;

VAR

(refNum:

INTEGER)

LONGINT)

LONGINT)

count:

OSErr;
OSErr;

LONGINT)

OSErr;

OSErr;

Creating and Deleting Files
FUNCTION

Create

FUNCTION

FSDelete

(fileName: Str255;
OSType; fileType:
(fileName: Str255;

vRefNum:
OSType)
vRefNum:

INTEGER;
OSErr;
INTEGER)

creator:

vRefNum:

INTEGER;

VAR

OSErr;

Changing Information About Files
FUNCTION
FUNCTION
FUNCTION

FUNCTION
FUNCTION

GetFinfo

(fileName:
Finfo)

SetFiInfo
Set FLock

RstFLock
Rename

Str255;

£f£ndriInfo:

OSErr;

(fileName:
Str255;
vRefNum:
INTEGER;
fndrInfo:
Finfo)
: OSErr;
(fileName:
Stxr255;
vRefNum:
INTEGER)
OSErr;
(fileName:
Str255;
vRefNum:
INTEGER)
OSErr;
(oldName:
Str255;
vRefNum:
INTEGER;
newName:
Str255)
OSErr;

IV-190 Summary of the File Manager

The File Manager
Low-Level Routines

Initializing the File /O Queue
PROCEDURE
FUNCTION

FInitQueue;
PBMountVol
<—
<>

16
22

(paramBlock:

ParmBlkPtr)

ioResult
io VRefNum

word

:

OSEryr;
—
Yo

word

=

Accessing Volumes
FUNCTION

~

(paramBlock:

ParmBlkPtr;

12.

ioCompletion

28
30
34
38
40
42
44
46
48
52
56
58

10Volindex
§ ioVCrDate
ioVLsBkUp
10VAtrb
10VNmFis
10VDirSt
ioVBILn
ioVNmAIBlks
ioVAIBIkSiz
ioVClIpSiz
= ioAIBISt
ioVNxtFNum

pointer
word
pointer
word
word
long word
long word
word
word
word
word
word
long word
long word
word
long word
word

PBGetVInfo

16
18
22

62

FUNCTION

po)

~=i10Result
ioNamePtr
ioVRefNum

ioVFrBlk

PBHGetVInfo

12

(paramBlock:

ioCompletion

16
18
22

~=ioResult
ioNamePtr
ioVRefNum

44

10VAllocPtr

28
30
34
38
40
42

46
48
532.

i10Volindex
ioVCrDate
ioVLsMod
ioVAtrb
ioVNmFis
ioVBitMap

ioVNmAIBlks
ioVAIBIkSiz
10VCIpSiz

56

~=— io AIBISt

62

i10VFrBlk

58

64

66
68

70
72

ioVNxtFNum
ioVSigWord

ioVDrvInfo
ioVDRefNum

ioVFSID
ioVBkUp

HParmBlkPtr;

async:

async:

BOOLEAN)

BOOLEAN)

>:

OSErr;

:

OSErr;

pointer
word
pointer
word
word
long word
long word
word
word
word
word
word
long word
long word
word
long word
word
word
word
word
word
long word

Summary of the File Manager IV-19]

ps)
Tw?
®
La

|

Inside Macintosh
<—

76

<—
<—
<

82
86
90

FUNCTION

PBSetVInfo

(paramBlock:

HParmBlkPtr;

—>
<—

12
16

—>

22

—>

34

ioCompletion
i0Result
ioNamePtr
i0 VRef{Num
10 VCrDate
10 VLsMod
ioVAtrb
10 VClpSiz
i0oVBkUp

pointer
word
pointer
word
long word
long word
word
long word
long word

10 VFndrInfo

32 bytes

—>

—>

—>
—>

—>
—>

38

52
72

76
90

i0VSeqNum

(paramBlock:

ParmBlkPtr;

18
2

pointer
word
pointer
word

PBHGetVol

(paramBlock:

WDPBPtr;

—>
<—
<—
<—

12
16
18
2

<—

48

ioCompletion
i0Result
ioNamePtr
i0 VRef{Num
10WDProcID
ioWDVRefNum
ioWDDirID

<—
<—

16

28
32

PBSetVol

(paramBlock:

ParmBlkPtr;

pointer
word
pointer
word

12

—>
—>

18
22

ioCompletion
idResult
ioNamePtr
i0 VRefNum

PBHSetVol

(paramBlock:

WDPBPtr;

—>

ioCompletion

pointer

12.

16
18
22
48

async:

async:

async:

word
pointer
word
long word

PBFlushVol

(paramBlock:

ParmBlkPtr;

—>
<—
—>
—>

ioCompletion
ioResult
ioNamePtr
ioVRefNum

pointer
word
pointer
word

IV-192 Summary of the File Manager

BOOLEAN)

:

BOOLEAN):

async:

ioResult
ioNamePtr
ioVRefNum
ioWDDirID

12
16
18
22

BOOLEAN)

:

OSErr;

OSErr;

OsErr;

pointer
word
pointer
word
long word
word
long word

—>

16

async:

word

ioCompletion
ioResult
10oNamePir
1i0 VRefNum

<—
—>
—>
—>
FUNCTION

30

12

<—

FUNCTION

18

—>

<—
<

FUNCTION

78

PBGetVol

<—

FUNCTION

word

long word
long word
long word
32 bytes

—>

FUNCTION

ioVSeqNum

i0V WrCnt
1i0VFilCnt
i0VDirCnt
i0 VFndrInfo

<

BOOLEAN)

BOOLEAN)

async:

:

:

BOOLEAN)

OSErr;

OSErr;

:

OSErr;

The File Manager
FUNCTION

PBUnmountVol

<—
—>
—>
FUNCTION

16 _— ioResult
18
ioNamePtr

22

—>

:

OSErr;

word

(paramBlock:

12
ioCompletion
16 = ioResult
18
ioNamePtr

22

ParmBlkPtr)

word
pointer

ioVRefNum

PBOffLine

—>
<—
—>

(paramBlock:

ioVRefNum

ParmBlkPtr)

:

OSErr;

pointer
word
pointer

a
‘

word

=

ae)

FUNCTION

PBEJect

—>
<—
—>
—>

(paramBlock:

12.
16 _
18

22

.

ParmBlkPtr)

.

ioCompletion
ioResult
ioNamePir
ioVRefNum

:

OSErr;

<=

.

~

pointer
word
pointer

2
©

word

Accessing Files
FUNCTION

PBOpen

(paramBlock:

—>

12

<—
—>
—>
<—
—>
—>
—>

FUNCTION

PBHOpen

—>
<—
—>
—>

ioCompletion
ioResult
ioNamePtr
ioVRefNum
ioRefNum
ioVersNum
ioPermssn
ioMisc

(paramBlock:

12
16
18
22

pointer

48

28

PBOpenRF

—>

<—
—>
—>
<—
—>
—>
—>

12.

HParmB1lkPtr;

ioMisc

—>

~ ioDirID

:

OSErr;

async:

BOOLEAN)

:

OSErr;

async:

BOOLEAN)

: OSErr;

word
byte

long word

(paramBlock:

ParmBlkPtr;

ioCompletion

pointer

16
ioResult
18
ioNamePtr
22
10VRefNum
24
ioRefNum
26
ioVersNum
27 — ioPermssn
28
ioMisc

BOOLEAN)

word
pointer
word
word
byte
byte
pointer

pointer
word
pointer
word

24
ioRefNum
27 — ioPermssn

async:

pointer

ioCompletion
ioResult
ioNamePtr
ioVRefNum

<—
—>

—>

FUNCTION

16
18
22
24
26
27
28 _

ParmBlkPtr;

word
pointer
word
word
byte
byte
pointer

Summary of the File Manager IV-193

Inside Macintosh
FUNCTION

PBHOpenRF

(paramBlock:

HParmBlkPtr;

—>

12.

ioCompletion

pointer

—>
<—
—>
—>
—>

22
24
27
28
48

ioVRefNum
ioRefNum
1i0Permssn
10Misc
ioDirID

word
word
byte
pointer
long word

<—
—>

FUNCTION

12
16
24 _

—>
—>

44 — ioPosMode
46 ~ ioPosOffset

ParmBlkPtr;

ParmBlkPtr;

pointer

36

ioReqCount

long word

44 — 10PosMode
46 = i0PosOffset

PBRead

(paramBlock:

—>

12

ioResult
ioRefNum

ParmBlkPtr;

ioCompletion
ioResult
ioRefNum
ioBuffer
ioReqCount
10ActCount

46 — ioPosOffset

long word

(paramBlock:

ParmBlkPtr;

44 = ioPosMode

BOOLEAN)

BOOLEAN)

:

: OSErr

pointer
word
word
pointer
long word
long word

<>

46 = i0PosOffset

long word

44 — ioPosMode

(paramBlock:

—>

ioCompletion _ pointer

IV-194 Summary of the File Manager

OSErr;

async:

BOOLEAN)

:

OSErr;

word

PBGetFPos

ioResult
i0oRefNum
ioReqCount
10ActCount
i0PosMode
ioPosOffset

async:

word

12
ioCompletion
16 _— ioResult
24
ioRefNum
32
10Buffer
36
i0ReqCount
40
ioActCount

16
24 _
36
40 =
44
46 =

async:

word
word
pointer
long word
long word

—>
<—
—>
—>
—>
<—

12

OSErr;

pointer

<>

<—
—>
<—
<—
<—
<—

:

word
long word

16
24
32
36
40

—>

BOOLEAN)

word
word

<—
—>
—>
—>
<—

PBWrite

async:

word
long word

ioCompletion

—>
—>

OSErr;

long word

12

16
24

:

pointer
word
word

(paramBlock:

<—
—>

—>

FUNCTION

10ReqCount

PBUnlockRange

—>

FUNCTION

36

ioCompletion
ioResult
ioRefNum

BOOLEAN)

word
pointer

(paramBlock:

—>
<—
—>

—>

FUNCTION

ioResult
ioNamePtr

PBLockRange

—>

FUNCTION

16
18

async:

ParmBlkPtr;

word
word
long word
long word
word
long word

async:

BOOLEAN)

:

OSErr;

The File Manager
FUNCTION

PBSetFPos

—>
<—
—>
—>
<>
FUNCTION

(paramBlock:

12
ioCompletion
16
1i0Result
24
ioRefNum
44 — ioPosMode
46 — ioPosOffset

PBGetEOF

—>
<—
—>

<—

ParmBlkPtr;

async:

BOOLEAN)

async:

BOOLEAN)

:

OSErr;

pointer
word
word
word
long word

(paramBlock:

ParmBlkPtr;

12
16

ioCompletion
ioResult

pointer
word

©
=

28

ioMisc

long word

=

24

ioRefNum

:

OSErr;

word

©

~~

FUNCTION

PBSetEOF

—>

FUNCTION

PBAllocate

(paramBlock:

ParmBlkPtr;

—>
<—
—>

12
16
24

ioCompletion
ioResult
ioRefNum

pointer
word
word

<—

40

i0ActCount

long word

<—
—>
—>

<—

ioResult
ioRefNum
10Misc

36

12

(paramBlock:

ParmBlkPtr;

i0Completion

pointer

—>

24

ioRefNum

word

—>
<—
—>

12.
16
24

ioCompletion
ioResult
ioRefNum

async:

BOOLEAN)

:

OSErr;

async:

BOOLEAN)

:

OSErr;

long word

12

(paramBlock:

=

ParmBlkPtr;

—>

PBClose

a

word
word
long word

(paramBlock:

ioResult

OSErr;

pointer

ioResult
ioRefNum
1ioReqCount

40 _~ ioActCount

16

:

long word

ioCompletion

16
24
36

BOOLEAN)

word
word
long word

ioReqCount

PBFlushFile

<—

FUNCTION

16
24
28

PBAllocContig

—>

FUNCTION

async:

pointer

—>

12

ParmBlkPtr;

ioCompletion

<—
—>
—>
FUNCTION

(paramBlock:

async:

BOOLEAN)

:

OSErr;

word

ParmBlkPtr;

async:

BOOLEAN)

async:

BOOLEAN)

:

OSErr;

pointer
word
word

Creating and Deleting Files and Directories
FUNCTION

PBCreate

(paramBlock:

ParmBlkPtr;

—>
<—

12
16

ioCompletion
ioResult

pointer
word

—>
—

22
26

ioVRefNum
ioFVersNum

word
byte

— >

18

ioNamePtr

:

OSErr;

pointer

Summary of the File Manager IV-195

Inside Macintosh
FUNCTION

FUNCTION

PBHCreate

(paramBlock:

HParmBlkPtr;

—>
<—
—>
—>
—>

ioCompletion
ioResult
ioNamePtr
10VRefNum
ioDirID

pointer
word
pointer
word
long word

PBDirCreate

—>

<—
<>
—>

ioCompletion

ioResult
ioNamePtr
1i0VRef{Num

PBDelete

(paramBlock:

48 = ioDirID

ParmBlkPtr;

—>
—>
—>

18
22.
26

ioNamePtr
i0VRefNum
i0FVersNum

pointer
word
_pyte

(paramBlock:

HParmBlkPtr;

—>
<—
—>
—>
—>

12
ioCompletion
16 ~ ioResult
18
10NamePtr
22
io0VRefNum
48 = ioDirID

OSErr;

BOOLEAN)

:

OSErr;

long word
pointer

PBHDelete

async:

:

word
pointer
word

ioCompletion
ioResult

BOOLEAN)

pointer

12

16 _

async:

HParmBlkPtr;

—>

<—

FUNCTION

12

(paramBlock:

16
18
22

<>

FUNCTION

12
16 _—
18
22
48 ~

async:

BOOLEAN)

:

OSErr;

word

async:

BOOLEAN)

:

OSErr;

async:

BOOLEAN)

:

OSErr;

pointer
word
pointer
word
long word

Changing Information About Files and Directories
FUNCTION

PBGetFInfo

(paramBlock:

ParmBlkPtr;

—>
<—

12
16

ioCompletion
ioResult

pointer
word

—>
<—

22
24

io0VRefNum
ioFRefNum

<—
<—
<—
<—
<—
<—
<—
<—
<—
<—
<—
<—

30 ~
31
32 =
48
$2
SS
58
@2
©
68
72
76 =

<>

—>
—>

18

26
28

ioNamePir

pointer

1i0FVersNum
ioFDirIndex

byte
word

ioFlAttnb
ioFlVersNum
ioFlFndrinfo
ioFINum
ioFMStBlk
.ioFiLgLen
ioFlPyLen
ioFIRStBlk
ioFIRLgLen
ioFlRPyLen
ioFlCrDat
ioFIMdDat

I[V-196 Summary of the File Manager

word
word

byte
byte
16 bytes
long word
word
long word
long word
word
long word
long word
long word
long word

The File Manager
FUNCTION

PBHGetFInfo

12
16
18
22
24
28
30
32
48
52
4
38
62
64
68
T2
76
FUNCTION

PBSetFInfo

12
16
18
22
26
32
72
76
FUNCTION

PBHSetFinfo

12
16
18
22
32
48
72
76
FUNCTION

PBSetFLock

12
16
18
22
26
FUNCTION

PBHSetFLock

12
16
18
22
48

(paramBlock:

ioCompletion

HParmBlkPtr;

i0FlCrDat
10F1IMdDat

pointer
word
pointer
word
word
word
byte
16 bytes
long word
word
long word
long word
word
long word
long word
long word
long word

(paramBlock:

ParmBlkPtr;

ioCompletion

pointer

10Result
ioNamePtr
io VRefNum
1i0FRefNum
10FDiriIndex
ioF Attrib
i0FlFndrIinfo
ioDirID
i0FIStBlk

ioFlLgLen
i0FlPyLen

iOFIRStBlk

ioFIRLgLen
i0FIRPyLen

ioResult

ioNamePtr
10 VRefNum
ioFVersNum
ioFlFndriInfo
10F1CrDat
1i0FIMdDat
(paramBlock:

_

ce*)
om)

~

poe
te)
fas)
=

HParmBlkPtr;

ParmBlkPtr;

i0oCompletion

pointer

1ioNamePir

pointer

ioFVersNum

byte

ioResult
ioNamePtr
io VRefNum
10DirID

async:

BOOLEAN)

:

OSErr;

word
pointer
word
byte
16 bytes
long word
long word

(paramBlock:

ioCompletion

OSErr;

eon

pointer
word
pointer
word
16 bytes
long word
long word
long word

(paramBlock:

:

pad

i0Result
1ioNamePtr
i0 VRefNum
ioFlFndrInfo
ioDirID
ioFlCrDat
1i0FiIMdDat

10 VRefNum

BOOLEAN)

=)

i0Completion

10Result

async:

async:

async:

BOOLEAN)

BOOLEAN)

:

:

OSErr;

OSErr;

word
word

HParmBlkPtr;

async:

BOOLEAN)

:

OSErr;

pointer
word
pointer
word
long word

Summary of the File Manager IV-197

Inside Macintosh
FUNCTION

FUNCTION

PBRstFLock

(paramBlock:

ParmBlkPtr;

—>
<—
—>
—>
—>

ioCompletion
ioResult
1ioNamePtr
ioVRefNum
ioFVersNum

pointer
word
pointer
word
byte

PBHRstFLock

—>
<—
—>
—>
—>
FUNCTION

FUNCTION

12
16
18
22
48

(paramBlock:

HParmBlkPtr;

ioCompletion
ioResult
ioNamePtr
ioVRefNum
ioDrID

pointer
word
pointer
word
long word

PBSetFVers

(paramBlock:

ParmBlkPtr;

—>
<—
—>
—>
—>
—>

12
16
18
22
26
28

ioCompletion
ioResult
ioNamePtr
ioVRefNum
ioVersNum
ioMisc

pointer
word
pointer
word
byte
byte

PBRename

(paramBlock:

ParmBl1kPtr;

—>
<—
—>
—>
—>
—>
FUNCTION

12
16
18
22
26

12
16
18
22
26
28

ioCompletion
ioResult
ioNamePtr
ioVRefNum
ioVersNum
ioMisc

pointer
word
pointer
word
byte
pointer

PBHRename

(paramBlock:

HParmBlkPtr;

—>
<—
—>
—>
—>
—>

ioCompletion
ioResult
ioNamePtr
ioVRefNum
10Misc
i0DrID

12
16
18
22
28
48

async:

BOOLEAN)

async:

async:

async:

:

OSErr;

BOOLEAN)

BOOLEAN)

BOOLEAN)

async:

:

:

:

BOOLEAN)

OSErr;

OSErr;

OSErr;

:

OSErr;

pointer
word
pointer
word
pointer
long word

Hierarchical Directory Routines
FUNCTION

PBGetCatiInfo
—>
<—
<—>
—>
<—
—>

12
16
18
22
24
28

<—
<—
<>
<>
<—

32
32
48
48
52

<—

30

(paramBlock:

ioCompletion

ioResult
ioNamePtr
i0VRefNum
ioFRefNum
i0FDirIndex

i0F Attrib

ioFlFndrinfo
1i0DrUsrWds
i0DirID
10DrDirID

i0FIStBlk

IV-198 Summary of the File Manager

CInfoPBPtr;

pointer
word
pointer
word
word
word
byte
16 bytes
16 bytes
long word
long word
word

async:

BOOLEAN)

:

OSErr;

The File Manager
<—
<—
<—
<—
<—
<—
<—
<—
<—

$2
ioDrNmFis
SM = ioMLgLen
38
ioFlPyLen
@
ioFIRStBlk
4
ioFIRLgLen
68
ioFIRPyLen
72 ~ 1i0FICrDat
72 = ioDrCrDat
76
ioFlMdDat

word
long word
long word
word
long word
long word
long word
long word
long word

<—
<—

80
ioHBkDat
80 = ioDrBkDat

long word
long word

100
104

long word
long word

<—

<—
<—
<—

<—
<—
FUNCTION

ioDrMdDat

8
ioFlXFndrinfo
& _ jioDrFndrinfo
100 _ ioF!ParID
ioDrParID
ioFlClpSiz

PBSetCatInfo

—>

12

(paramBlock:

=

16 bytes
16 bytes
long word

=
—
ha

pointer

ioNamePtr

pointer

16

—>
—>
—>
—>
—>
—>
—>
—>
—>
—>
—>

22
io0VRefNum
28
i0FDirindex
30
ioFlAttrib
32
ioFlFndrinfo
32
1ioDrUsrWds
48
ioDirID
48
ioDrDirID
72
ioFlCrDat
72 ~~ ioDrCrDat
76
ioFlMdDat
76
ioDrMdDat

—>
—>
—>
—>

80
& _
& _
104

ioDrBkDat
ioFlXFndrinfo
ioDrFndrinfo
ioFlClpSiz

PBCatMove

(paramBlock:

CMovePBPtr;

—>

12.

ioCompletion

pointer

—>

18

ioNamePtr

pointer

ioNewName

pointer

—>

<—

18

980 = ioFlBkDat

16

ioResult

—>

22

ioVRefNum

—>
—>

36
48

£ioNewDirID
ioDirID

—>

28

=
o

a

CInfoPBPtr;

ioCompletion

ioResult

Z

long word

<—

<>

FUNCTION

76

async:

BOOLEAN)

:

OSErr;

word

word
word
byte
16 bytes
16 bytes
long word
long word
long word
long word
long word
long word

long word

long word
16 bytes
16 bytes
long word
async:

BOOLEAN)

:

OSErr;

word

word

long word
long word

Summary of the File Manager IV-199

Inside Macintosh

Working Directory Routines
FUNCTION

PBOpenWD

—>
<—
—>
<>
—>
—>
FUNCTION

WDPBPtr;

12
16
18
22
28
48

ioCompletion
ioResult
ioNamePtr
ioVRefNum
ioWDProcID
ioWDDirID

pointer
word
pointer
word
long word
long word

PBCloseWD

(paramBlock:

WDPBPtr;

—>

12

ioCompletion

pointer

—>

22

i1o0VRefNum

word

<—

FUNCTION

(paramBlock:

16

1oResult

PBGetWDInfo

async:

async:

(paramBlock:

WDPBPtr;

12 = ioCompletion

pointer

<—

18

ioNamePtr

pointer

ioWDProcID
ioWDVRefNum_
ioWDDirID

long word
word
long word

<>
—>

<>
<>
<—

16

ioResult

22
26

# ioVRefNum
10WDIndex

28
32
48

FUNCTION

GetFSQHdr

:

QOHdrPtr;

[Not

in

ROM]

FUNCTION

GetVCBOHdr

:

QHdrPtr;

[Not

in

ROM]

FUNCTION

GetDrvQHdr

:

QHdrPtr;

[Not

in

ROM]

FUNCTION

PBGetFCBInfo

(paramBlock:

12 — i0Completion

16 _
18
22
24
28
32
36
38
40
44
48
32
SM =
58

ioResult
ioNamePtr
ioVRefNum
ioRefNum
ioFCBIndx
1i0FCBFINm
ioFCBFlags
ioFCBStBlk
ioFCBEOF
ioFCBPLen
ioFCBCrPs
ioFCBVRefNum_
ioFCBClpSiz
i0FCBParID

IV-200 Summary of the File Manager

:

OSErr;

async:

BOOLEAN)

:

OSErr;

word
word

Routines

<—
<—
<>
<>
—>
<—
<—
<—
<—
<—
<—
<—
<—
<—

BOOLEAN)

OSErr;

word

Advanced

—>

:

word

—>

<—

BOOLEAN)

FCBPBPtr;

pointer

word
pointer
word
word
long word
long word
word
word
long word
long word
long word
word
long word
long word

async:

BOOLEAN)

:

OSErr;

The File Manager

Result Codes
Name

badMDBErr
badMovErr

bdNamErr
dirFulErr

Value

Meaning

-60

Master directory block is bad; must reinitialize volume

-122

~—37
—33

dirNFErr

-120

eofErr

~39

dskFulErr
dupFNErr
extFSErr

—34
-48
—58

Attempted to move into offspring

Bad file name or volume name (perhaps zero-length); attempt to

move into a file

_

Allallocation blocks on the volume are full
.
A file with the specified name and version number already exists

>
S

External file system; file-system identifier is nonzero, or path
reference number is greater than 1024
File is busy; one or more files are open; directory not empty or

°

_ Directory not found

Logical end-of-file reached during read operation

fBsyErr

—47

fLekdErr
fnfErr
fnOpnErr
fsDSIntErr
fsRnErr
efpErr

—45
—43
—38
-127
-59
—52

memFullErr
noErr
noMacDskErr
nsDrvErr

-108
0
-57
~56

nsvErr

—35

paramErr

—50

permErr
posErr
rf{NumErr

—54
—40
—51

The read/write permission of only one access path to a file can
allow writing
Parameters don’t specify an existing volume, and there’s no
default volume
Attempt to open locked file for writing
Attempt to position before start of file
Reference number specifies nonexistent access path

tmwdoErr
—121
volOffLinErr
-53
volOnLinErr
-55
vLckdErr
—46
wrgVolTypErr —-123
wrPermErr
-—61
wPrErr
—44

Too many working directories open
Volume not on-line
Specified volume is already mounted and on-line
Volume is locked by a software flag
Attempt to do hierarchical operation on nonhierarchical volume
Read/write permission doesn’t allow writing
Volume is locked by a hardware setting

ioErr

opWrErr

tmfoErr

—36

-49

—42

-

File directory full

working directory control block is open

__— File locked
File not found
File not open
Internal file system error
Problem during rename
Error during GetFPos

=: [/Oerror

Not enough room in heap zone
No error
Volume lacks Macintosh-format directory
Specified drive number doesn’t match any number in the drive
queue

Specified volume doesn’t exist

Too many files open

Summary of the File Manager IV-201

=

=

Inside Macintosh

Assembly-Language Information
Constants
;

Flags

in

file

information

fOnDesk

-EQU

1

fHasBundle

-EQU

13

-EQU

-2

fInvisible
fTrash

.EQU
-EQU

fDesktop

fDisk
;

Flags

-EQU
in

trap

asnycTrpBit

; Values

for

-EQU

fsRdWrShPerm

.EQU

Positioning

the

Finder

;set if file is
; volumes only)
;set

14
-3

if

file

has

on

desktop

a

bundle

(hierarchical

;set if file's icon is invisible
;file is in Trash window

0

;file

;file

is

on

desktop

10

;set

for

an

asynchronous

requesting
-EQU

;

by

is

in

disk

window

words

fsCurPerm

fsRdPerm
fsWrPerm
fsRdWrPerm

used

-EQU
-EQU
.EQU

read/write

0

;whatever

4

;request

1
2
3

; request
;request
;request

call

permission
is

for
for
for
for

currently

allowed

read permission only
write permission only
exclusive read/write permission
shared

read/write

modes

fsAtMark

.EQU

0

;at

current

fsFromLEOF
fsFromMark
rdVverify

. EQU
.EQU
-EQU

2
3
64

;set
;set
;add

mark relative
to logical
mark relative
to current
to above
for read-verify

fsFromStart

. EQU

1

;set

mark

mark

relative

to

Structure of File Information Used by the Finder
fdType
fdCreator
fdFlags
fdLocation
fdFldr
fdIconID

File type (long)
File’s creator (long)
Flags (word)
File’s location (point; long)
File’s window (word)
File’s icon ID (word)

fdComment
fdPutA way

File’s comment ID (word)
File’s home directory ID (long word)

fdUnused

Reserved (8 bytes)

Structure of Directory Information Used by the Finder
frRect
frFlags
frLocation

permission

Folder’s rectangle (8 bytes)
Flags (word)
Folder’s location (point; long)

IV-202 Summary of the File Manager

beginning

of

file

end-of-file
mark

The File Manager

frOpenChain

Folder’s view (word)
Folder’s scroll position (point; long)
Directory ID chain of open folders (long word)

frPutAway

Folder’s comment ID (word)
Folders’s home directory ID (long word)

frView
frScroll

frUnused
frComment

Reserved (word)

_

Standard Parameter Block Data Structure
qLink
qT ype
ioTrap

10CmdAddr

ioCompletion
10Result
1i0FileName
io VNPtr
10 VRefNum
ioDrvNum

—
Oo

Pointer to next queue entry
Queue type (word)
Routine trap (word)
Routine address
Address of completion routine
Result code (word)
Pointer to pathname (preceded by length byte)

Pointer to volume name (preceded by length byte)
Volume reference number or working
Drive number (word)

directory reference number (word)

Structure of I/O Parameter Block
ioRefNum

10FileType

10Permssn
10NewName
10LEOF
10OwnBuf

ioNewType
10Buffer
10ReqCount

10ActCount
10PosMode
10PosOffset
10QEISize

Path reference number (word)
Version number (byte) —
Read/write permission (byte)
Pointer to new pathname (preceded by length byte)

Logical end-of-file for SetEOF (long)

Pointer to access path buffer
New version number for SetFilType (byte)
Pointer to data buffer
Requested number of bytes (long)
Actual number of bytes (long)
Positioning mode and newline character (word)
Positioning offset (long)
Size in bytes of I/O parameter block

Structure of File Parameter Block
i0oRefNum

ioFileType

10FDirIndex
10F Attrib

ioFF1Type

i0oFlUsrWds
ioDirID
ioFFINum
ioFIStBlk

ioFlLgLen

Path reference number (word)
Version number (byte)
Directory index (word)
File attributes (byte)
Version number (byte)
|
Information used by the Finder (16 bytes)
Directory ID (long)
File number (long)
First allocation block of data fork (word)
Logical end-of-file of data fork (long)

Summary of the File Manager IV-203

er
=

o

S

SS
~

ry

itxm)

fen)

Lee §

Inside Macintosh

10F1PyLen
i0FIRStBlk
1i0FIRLgLen
i0FIRPyLen
ioFlCrDat
ioFIMdDat
i0FQEISize

Physical end-of-file of data fork (long)
First allocation block of resource fork (word)
Logical end-of-file of resource fork (long)
Physical end-of-file of resource fork (long)

Date and time of creation (long)

Date and time of last modification (long)
Size in bytes of file information parameter block

Structure of Volume Information Parameter Block (Flat Directory)
10 VolIndex
10 VCrDate
1i0VLsBkUp
10 VAtrb
1i0VNmFls
i0VDirSt
10 VBILn
ioVNmAIBlks
io VAIBIkSiz

Volume index (word)

ioAIBISt
io VNxtFNum
io VFrBlk
10V QEISize

First block in block map (word)

i0 VClpSiz

Date and time of initialization (long)

Date and time of last modification (long)
Volume attributes; bit 15=1 1f volume locked (word)
Number of files in directory (word)
First block of directory (word)
Length of directory in blocks (word)
Number of allocation blocks on volume (word)
Size of allocation blocks (long)
Number of bytes to allocate (long)
Next unused file number (long)
Number of unused allocation blocks (word)

Size in bytes of volume information parameter block

Structure of Volume Information Parameter Block (Hierarchical Directory)
10 VolIndex
1i0VCrDate
10 VLsMod
ioVAtrb
i0oVNmFls
i0VCBVBMSt
1i0 VNmAIBlks
10 VAIBIkSiz
io VClpSiz
i0AIBISt
10 VNxtCNID
10 VFrBlk

10 VSigWord

10 VDrvInfo
10VDRefNum
10 VFSID
ioVBkUp
10VWrCnt
ioVFilCnt
10 VDirCnt
i0VFndrInfo

10HVQEISize

Volume index (word)
Date and time of initialization (long)
Date and time of last modification (long)
Volume attributes (word)
Number of files in directory (word)

First block of volume bit map (word)

Number of allocation blocks (word)
Size of allocation blocks (long)
Default clump size (long)
First block in block map (word)
Next unused node ID (long)
Number of unused allocation blocks (word)

Volume signature (word)

Drive number (word)
Driver reference number (word)
File-system identifier (word)
Date and time of last backup (long)
Volume write count (long)
Number of files on volume (long)
Number of directories on volume (long)

Information used by the Finder (32 bytes)

Size in bytes of hierarchical volume information parameter block

IV-204 Summary of the File Manager

The File Manager

Structure of Catalog Information Parameter Block (Files)
10RefNum
10FileType

Path reference number (word)
Version number (byte)

ioFDirIndex

Directory index (word)

i0FFINum

File number (long)

10F Attrib
10FlUsrWds

iOFIStBlk
ioFlLgLen
ioF1PyLen

ioFIRStBlk

ioFIRLgLen
i0FIRPyLen
ioFlCrDat
10FIMdDat
10F1BkDat
ioF1XFndrInfo
i0FlParID
10F1ClpSiz

File attributes
Information used by the Finder (16 bytes)
First allocation block of data fork (word)
Logical end-of-file of data fork (long)
Physical end-of-file of data fork (long)

S
=
o

Logical end-of-file of resource fork (long)
Physical end-of-file of resource fork (long)
Date and time of creation (long)
Date and time of last modification (long)
Date and time of last backup (long)
Additional information used by the Finder (16 bytes)
File parent directory ID (long)
File’s clump size (long)

5
v3
.

First allocation block of resource fork (word)

Structure of Catalog Information Parameter Block (Directories)
ioRefNum
10FDirIndex
10F1Attrib
10DrUsrWds
10DrDirID
ioDrNmFls

Path reference number (word)
Catalog index (word)
File attributes
Information used by the Finder (16 bytes)
Directory ID (long)
Number of files in directory (word)

10DrMdDat
ioDrBkDat

Date and time of last modification (long)
Date and time of last backup (long)

1i0DrCrDat

ioDrFndrInfo
10DrParID

Date and time of creation

(long)

Additional information used by the Finder (16 bytes)

Directory’s parent directory ID (long)

Structure of Catalog Move Parameter Block
10NewName
10NewDirID
10DirID

Pointer to name of new directory (preceded by length byte)
Directory ID of new directory (long)
Directory ID of current directory (long)

Structure of Working Directory Parameter Block
ioWD Index

ioWDProcID

ioWDVRefNum
ioWDDirID

Working

Working

directory index (word)

directory’s

user identifier (long)

Working directory’s volume reference number (word)
Working directory’s directory ID (long)

Summary of the File Manager IV-205

=

Inside Macintosh
Structure of File Control Block Information Parameter Block
ioFCBIndx
ioFCBFINm

i0FCBFlags

ioFCBStBlk
i0FCBEOF
ioFCBPLen
ioFCBCrPs
ioFCBVRefNum
ioFCBCIpSiz
ioFCBParID

FCB index (long)
File number (long)
Flags (word)
First allocation block of file (word)
Logical end-of-file (long)

Physical end-of-file (long)

Mark (long)
Volume reference number (word)
File’s clump size (long)
Parent directory ID (long)

Volume Information Data Structure (Flat Directory)
drSigWord
drCrDate

drLsBkUp
drAtrb

drNmFls
drDirSt
drBILn
drNmAIBlks
drAIBIkSiz
drClpSiz
drAlBISt
drNxtFNum
drFreeBks
drVN

Always $D2D7 (word)

Date and time of initialization (long)

Date and time of last modification (long)
Volume attributes (word)
Number of files in directory (word)
First block of directory (word)
Length of directory in blocks (word)
Number of allocation blocks (word)
Allocation block size (long)
Number of bytes to allocate (long)
First allocation block in block map (word)
Next unused file number (long)
Number of unused allocation blocks (word)
Volume name preceded by length byte (28 bytes)

Volume Information Data Structure (Hierarchical Directory)
drSigWord

drCrDate
drLsMod

drAtrb

drNmFls
drVBMSt
drNmAIBlks
drAlBlkSiz
drClpSiz
drAIBISt
drNxtCNID
drFreeBks
drVN
drVolBkUp
drWrCnt

drXTClpSiz

drCTClpSize

Always $4244 (word)
Date and time of initialization (long)

Date and time of last modification (long)
Volume attributes (word)
Number of files in directory (word)
First block of volume bit map (word)
Number of allocation blocks (word)
Allocation block size (long)
Default clump size (long)
First block in block map (word)
Next unused directory ID (long)
Number of unused allocation blocks (word)
Volume name (28 bytes)
Date and time of last backup (long)
Volume write count (long)
Clump size of extents tree file (long)
Clump size of catalog tree file (long)

IV-206 Summary of the File Manager

The File Manager
drNmkRtDirs
drFilCnt
drDirCnt
drFndrInfo
drX TF1Size
drXTExtRec
drCTFISize
drCTExtRec

Number of directories in root (word)
Number of files on volume (long)
Number of directories on volume (long)
Information used by the Finder (32 bytes)
Length of extents tree (LEOF and PEOF) (long)
Extent record for extents tree file (12 bytes)
Length of catalog tree file (LEOF and PEOF) (long)
First extent record for catalog tree file (12 bytes)

—
\O

=

File Directory Entry Data Structure (Flat Directory)

oO

flFlags
flTyp
flUsrWds
flFINum
f1StBlk
flLgLen
flPyLen
fIRStBlk
flRLgLen
flRPyLen
flCrDat
flMdDat
fINam

j=)
~~
pom)
T2
fas)

Bit 7=1 if entry used; bit O=1 if file locked (byte)
Version number (byte)
Information used by the Finder (16 bytes)
File number (long)
First allocation block of data fork (word)
Logical end-of-file of data fork (long)
Physical end-of-file of data fork (long)
First allocation block of resource fork (word)
Logical end-of-file of resource fork (long)
Physical end-of-file of resource fork (long)
Date and time file of creation (long)
Date and time of last modification (long)
File name preceded by length byte

Extents Key Data Structure (Hierarchical Directory)
xkrKeyLen
xkrFkT ype
xkrFNum
xkrFABN

Key length (byte)

$00 for data fork; $FF for resource fork (byte)

File number (long)

Allocation block number within file (word)

Catalog Key Data Structure (Hierarchical Directory)
ckrKeyLen
ckrParID

ckrCName

Key length (byte)
Parent ID (long)
File or directory name preceded by length byte

File Record Data Structure (Hierarchical Directory)
cdrType
filFlags
filTyp
filUsrWds
filFINum

fulStBlk

filLgLen
filPyLen
filRStBlk

Always 2 for file records (byte)

Bit 7=1 if entry used; bit O=1 if file locked (byte)

Version number (byte)
Information used by the Finder (16 bytes)
File number (long)
First allocation block of data fork (word)
Logical end-of-file of data fork (long)
Physical end-of-file of data fork (long)

First allocation block of resource fork (word)

Summary of the File Manager IV-207

La

|

Inside Macintosh

filRLgLen
filRPyLen

filCrDat
filMdDat
filBkDat
filFndrInfo
filClpSize
filExtRec
filRExtRec

Logical end-of-file of resource fork (long)

Physical end-of-file of resource fork (long)
Date and time of creation (long)

Date and time of last modification (long)

Date and time of last backup (long)
Additional information used by the Finder (16 bytes)
File’s clump size (word)
First extent record for data fork (12 bytes)
First extent record for resource fork (12 bytes)

Directory Record Data Structure (Hierarchical Directory)
cdrType
dirFlags

dirVal
dirDirID
dirCrDat
dirMdDat
dirBkDat
dirUsrInfo
dirFndrInfo

Always 1 for directory records (byte)
Flags (word)
Valence (word)
Directory ID (long)

Date and time of creation (long)
Date and time of last modification (long)

Date and time of last backup (long)
Information used by the Finder (16 bytes)
Additional information used by the Finder (16 bytes)

Thread Record Data Structure (Hierarchical Directory)
cdrType

thdParID
thdCName

Always 3 for thread records (byte)
Parent ID of associated directory (long)
Name of associated directory preceded by length byte

Volume Control Block Data Structure (Flat Directory)
qLink

ql'ype

vcbFlags
vebSigWord
vcbCrDate

vcbLsBkUp

vcbAtrb
vcbNmFIs
vebDirSt
vcbBILn
vcbNmBlks
vcbAIBIkSiz

vcbClpSiz

vcbAIBISt
vcbNxtFNum
vcbFreeBks
vcbVN
vcebDrvNum
vcbDRefNum
vcbFSID

Pointer to next queue entry
Queue type (word)
Bit 15=1 if volume control block is dirty (word)

Always $D2D7 (word)

Date and time of initialization (word)
Date and time of last modification (long)
Volume attributes (word)
Number of files in directory (word)
First block of directory (word)
Length of directory in blocks (word)
Number of allocation blocks (word)
Allocation block size (long)
Number of bytes to allocate (long)
First allocation block in block map (word)
Next unused file number (long)
Number of unused allocation blocks (word)
Volume name preceded by length byte (28 bytes)
Drive number (word)
Driver reference number (word)
File-system identifier (word)

IV-208 Summary of the File Manager

The File Manager
vcbVRefNum
vcbMAdr
vcbBufAdr
vcbMLen

Volume reference number (word)
Pointer to block map
Pointer to volume buffer
Number of bytes in block map (word)

Volume Control Block Data Structure (Hierarchical Directory)
qLink

qT ype
vcbFlags
vcbSigWord

vcbCrDate
vcbLsMod
vebAtrb
vcbNmFls
vcbVBMSt
vcbNmAIBlks
vcbAIBIkSiz

vcebClpSiz

vcbAIBISt
vcbNxtCNID
vcbFreeBks
vcbVN
vcbDrvNum
vcbDRefNum
vcbFSID

vcbVRefNum
vcbMAdr
vcbBufAdr
vcbMLen

vcbVolBkUp
vcbVSeqNum
vcbWrCnt

vcbXTClpSiz
vebCTClpSiz

vcbNmRtDirs
vcbFilCnt
vcebDirCnt
vcbFndrInfo
vcbX TAIBks
vcbCTAIBks
vcbX TRef
vcbCTRef
vebCiBuf
vcbDirIDM
vcbOffsM

Pointer to next queue entry
Queue type ¢word)
Bit 15=1 if volume control block is dirty (word)
$4244 for hierarchical, $D2D7 for flat (word)

Date and time of initialization (word)
Date and time of last modification (long)
Volume attributes (word)
Number of files in directory (word)
First block of volume bit map (word)
Number of allocation blocks (word)
Allocation block size (long)
Default clump size (long)
First block in bit map (word)
Next unused node ID (long)
Number of unused allocation blocks (word)
Volume name preceded by length byte (28 bytes)
Drive number (word)
Driver reference number (word)
File-system identifier (word)
Volume reference number (word)
Pointer to block map
Pointer to volume buffer

Number of bytes in block map (word)
Date and time of last backup (long)
Index of volume in backup set (word)
Volume write count (long)
Clump size of extents tree file (long)
Clump size of catalog tree file (long)
Number of directories in root (word)
Number of files on volume (long)
Number of directories on volume (long)
Information used by the Finder (32 bytes)
Size in blocks of extents tree file (word)
Size in blocks of catalog tree file (word)

Path reference number for extents tree file (word)

Path reference number for catalog tree file (word)
Pointer to extents and catalog tree caches (long)
Directory last searched (long)
Offspring index at last search (word)

Summary of the File Manager IV-209

—"

oie
o
=
5
ou
re

fas]
=“

Inside Macintosh

File Control Block Data Structure (Flat Directory)
fcbFINum

fcbMdRByt
fcbTypByt
fcbSBlk
fcbEOF
fcbPLen

File number (long)
Flags (byte)
Version number (byte)
First allocation block of file (word)

Logical end-of-file (long)

Physical end-of-file (long)
Mark (long)
Pointer to volume control block (long)
Pointer to access path buffer (long)

fcbCrPs
fcbVPtr

fcbBfAdr

File Control Block Data Structure (Hierarchical Directory)

fcbFINum

fcbMdRByt
febT ypByt
fcbSBlk
fcbEOF
fcbPLen
fcbCrPs
fcbVPtr
fcbBfAdr

fcbClmpSize
febBTCBPtr
fcbExtRec

fcbFType

fcbDirID
fcbCName

File number (long)
Flags (byte)

Version number (byte)

|

First allocation block of file (word)
Logical end-of-file (ong)
Physical erid-of-file (ong)
Mark (long)
Pointer to volume control block (long)

Pointer to access path buffer (long)

File’s clump size (long)
Pointer to B*-tree control block (long)
First three file extents (12 bytes)
File’s four Finder type bytes (long)

File’s parent ID (long)

Name of open file, preceded by length byte (32 bytes)

Drive Queue Entry Data Structure
qLink
qT ype
dQDrive
dQRefNum
dQFSID
dQDrvSz
dQDrvSz2

Pointer to next queue entry
Queue type (word)
Drive number (word)
Driver reference number (word)
File-system identifier (word)
Number of logical blocks on drive (word)
Additional field to handle large drive size (word)

Macro Names
Pascal

name

FInitQueue

PBMountVol
PBGetVInfo
PBHGetVInfo
PBSetVInfo

Macro

name

_InitQueue

_MountVol
_GetVolInfo
_HGetVInfo
_SetVollinfo

IV-210 Summary of the File Manager

The File Manager
Pascal

name

Macro

name

PBGetVol
PBHGetVol

_GetVol
_HGetVol

PBHSetVol

_HSetVol

PBSetVol

PBFlushVol
PBUnmountVol
PBOffLine
PBEject
PBOpen

PBHOpen

PBOpenRF
PBHOpenRF

PBLockRange

_SetVol

_FlushVol
_UnmountVol
_OffLine

peed
\o

_Eject
_Open

i

O

_HOpen

_OpenRF
_HOpenRF

po)
=
po)
v2
fae)

_LockRng

Lae

PBUnlockRange _UnlockRng
PBRead
PBWrite

_Read
_Write

PBSetFPos

_SetFPos

PBGetFPos
PBGetEOF

PBSetEOF

PBAllocate
PBAllocContig
PBFlushFile
PBClose
PBCreate
PBHCreate

PBDirCreate

PBGetFInfo
PBHGetFInfo
PBSetFInfo
PBHSetFInfo

PBSetFLock

PBHSetFLock
PBRstFLock

|

_GetFPos
_GetEOF

_SetEOF

_Allocate
_AllocContig
_FlushFile
_Close
_Create
_HCreate

_DirCreate

_GetFileInfo
_HGetFileInfo
_SetFileInfo
_HSetFileInfo

_SetFilLock

_HSetFLock
_RstFilLock

PBHRstFLock
PBSetF Vers

_HRstFLock
_SetFilType

PBHRename

_HRename

PBRename

PBDelete
PBHDelete
PBGetCatInfo

PBSetCatInfo

_Rename .

_Delete
_HDelete
_GetCatInfo

_SetCatInfo

PBCatMove

_CatMove

PBCloseWD

_CloseWD

PBOpenWD

PBGetWDInfo
PBGetFCBInfo

_OpenWD

_GetWDInfo
_GetFCBInfo

Summary of the File Manager IV-211

§

Inside Macintosh

Special Macro Name
_HFSDispatch
Variables
BootDrive
FSQHadr |
VCBQHdr
DefVCBPtr
FCBSPtr

Working directory reference number for system startup volume (word)
File I/O queue header (10 bytes)
Volume-control-block queue header (10 bytes)
Pointer to default volume control block
Pointer to file-control-block buffer

ToExtFS
FSFCBLen

Pointer to external file system
Size of a file control t:ock; on 64K ROM contains —1 (word)

DrvQHdr

Drive queue header (10 bytes)

IV-212 Summary of the File Manager

20

THE DEVICE MANAGER

215
216
217
217
218
218
218
218
219
219
219
219
221
222

About the Device Manager
The Chooser
The Device Package
Communication with the Chooser
The NewSelMsg Parameter
The FileListMsg Parameter
The GetSelMsg Parameter
The SelectMsg Parameter
The DeselectMsg Parameter
The TerminateMsg Parameter
The ButtonMsg Parameter
Operation of the Chooser
Writing a Device Driver to Run Under Chooser
Summary of the Device Manager

Nv
moe)

—)
o

x.

O
©

go
~

g5
o
=

v3

Contents IV-213

Inside Macintosh

IV-214

The Device Manager

ABOUT THE DEVICE MANAGER
While no new routines have been added to the Device Manager, the handling of the existing
routines has been significantly improved.
When an Open call is made, installed drivers are searched first (before resources) to avoid
replacing a current driver; this search is done by name so be sure that your driver’s name is
in the driver header.

All drivers, exclusive of desk accessories, must have a name that

begins with a period; otherwise, the Open call is passed on to the File Manager.

If a driver is already open, Open calls will not be sent to the driver’s open routine,

preserving its device control entry. A desk accessory will, however, receive another call
(certain desk accessories count on this).

If a driver fails to open because of a resource load problem, the Open call terminates with
the appropriate error code instead of being passed on to the File Manager (which would
usually return the result code fnfErr). If a driver returns a negative result code in register
DO from an Open call, the result code is passed back and the driver is not opened. Ifa
driver returns the result code closeErr in register DO from a Close call, this result code is
passed back and the driver is not closed.

la
oS

or)

fae]
<

=e

QC}
ae)

poe)

~

pee)
4go
ae)

Leap |

Open, Close, Read, Write, Control, and Status return all results in the ioResult field as well

as in register DO. A KilllO call is passed to the driver only if it’s open and enabled for
Control calls.

The number of device control entries in the 128K ROM has been increased from 32 to 48.
The unit table is now a 192-byte nonrelocatable block containing 48 four-byte entries; the
standard unit table assignments are as follows:
Unit

Number

0
1
2
3
4
5
6
7
8
9
10
11
12—26
27-31
32-39
40-47

Device

Reserved
|
Hard disk driver: Macintosh XL internal or Hard Disk 20 external
.Print driver
.sound driver
sony driver
Modem port asynchronous driver input (.AIn)
Modem port asynchronous driver output (.AOut)
Printer port asynchronous driver input (.BIn)
Printer port asynchronous driver output (.BOut)
AppleTalk .MPP driver
AppleTalk .ATP driver
Reserved
Desk accessories in System file
Desk accessories in application files
SCSI drivers 0-7
Reserved

About the Device Manager IV-215

Inside Macintosh

THE CHOOSER
The Chooser is a desk accessory that provides a standard interface to help solicit and accept

specific choices from the user. It allows new device drivers to prompt the user for choices

such as which serial port to use, which AppleTalk zone to communicate with, and which
LaserWriter to use.

The Chooser relies heavily on the List Manager for creating, displaying, and manipulating
possible user selections. The List Manager is described in chapter 30 of this volume.
Under the Chooser, each device is represented by a device resource file in the system

folder on the user’s system startup disk. (This is an extension of the concept of printer
resource files, described in chapter 5 of volume II.) The Chooser accepts three types of
device resource files to identify different kinds of devices:
File type

Device

type

'PRES'
'PRER'
‘RDEV'

Serial printer
Non-serial printer
Other device

The creator of each file is left undefined, allowing each device to have its own icon.
In addition to any actual driver code, each device resource file of type "PRER' or "RDEV'
contains a set of resources that tell the Chooser how to handle the device.
include:

Resource

type

‘PACK’

Resource
—4096

‘STR '
'GNRL'

—4096
—4096

'STR
'STR
'STR

'
'
'

—4093
—4092
—4091

'BNDL'
'STR '

—4090

ID

These resources

Description
Device package (described below)

Type name for AppleTalk devices
NBP timeout and retry information for
AppleTalk devices

Left button title
Right button title
String for Chooser to use to label the list
when choosing the device
Icon information
Reserved for use by the Chooser

Warning: You should give your device type a distinctive icon, since this may be
the only way that devices are identified in the Chooser’s screen display.
Device resource files of type 'PRES' (serial printers) contain only the driver code, without
any of the resources listed above. The configuration of such devices is implemented
entirely by the Chooser.

IV-216

The Chooser

The Device Manager

The Device Package
The device package is usually written in assembly language, but may be written partially in
Pascal. The assembly-language structure of the 'PACK' —4096 resource is as follows:
(hex)

Word

BRA:S to offset $10

=H=HQParhNO

Offset

Device ID (word)
‘PACK’ (long word)
$FO00 (4096)
Version (word)

Flags (long word)
Start of driver code

0

The device ID is an integer that identifies the device. The version word differentiates
versions of the driver code. The flags field contains the following information:

TS)
S
o
@
<

hes o

©
@

Bit

Meaning

31
30-29
28
27
26

Set if an AppleTalk device
Reserved (clear to 0)
Set if device package can have multiple instances selected at once
Set if device package uses left button
Set 1f device package uses right button

24
23-17
16
15
14
13
12
11
10-0

Set if device package uses actual zone names
Reserved (clear to 0)
Set if device package accepts the newSel message
Set if device package accepts the fillList message
Set if device package accepts the getSel message
Set if device package accepts the select message
Set if device package accepts the deselect message
Set if device package accepts the terminate message
Reserved (clear to 0)

25

iS
=)
go
7
co

Lane |

Set if no saved zone name

Communication with the Chooser
The Chooser communicates with device packages as if they were the following
FUNCTION

Device

(message,caller:

StringPtr;

pl,p2:

INTEGER;

LONGINT)

:

objName,

OSErr;

The message parameter identifies the operation to be performed.
following values:
CONST

newSelMsg

fillListMsg

getSelMsg
selectMsg

=

=
=

12;

13;
14;
15;

{new

{£111

user

the

{mark one
{a choice

selections

list

with

function:

zoneName:

It has one of the
have

been

choices

to

made}

be

made}

or more choices
as selected}
has actually been made}

The Chooser IV-217

Inside Macintosh
deselectMsg
terminateMsg
buttonMsg

=
=
=

16;
17;
19;

{a choice has been cancelled}
{lets device package clean up}
{tells driver a button has been

selected}

The device package should always return noErr, except with select and deselect; with these
messages, a result code other than noErr prevents selection or deselection from occurring.
The device package must ignore any other messages in the range 0..127 and return noErr.
If the message is selectMsg or deselectMsg, it may not call the List Manager.
The caller parameter identifies the caller as the Chooser, with a value of 1. Values in the
range 0..127 are reserved; values outside this range may be used by applications.
For AppleTalk devices, the zoneName parameter is a pointer to a string of up to 32
characters containing the name of the AppleTalk zone in which the devices can be found.

If the Chooser is being used with the local zone and bit 24 of the Flags field of the

'PACK' -4096 resource is clear, the string value is '*'; otherwise it’s the actual zone

name.

The p1 parameter is a handle to a List Manager list of choices for a particular device; this
device list must be filled by the device package in response to the fillListMsg message.
Other details of the Chooser messages and their parameters are given below.

The NewSelMsg Parameter
The Chooser sends the newSel message (instead of the select or deselect message) only to
device packages that allow multiple selections, when the user changes the selection.

The objName and p2 parameters are not used.

The FillListMsg Parameter
When the Chooser sends the fillList message, the device package should fill a List Manager
list filled with choices for a particular device; the p1 parameter is a handle to this list.

The objName and p2 parameters are not used.

The GetSelMsg Parameter
When the Chooser sends the getSel message the device package should mark one or more
choices in the given list as ciirrently selected, by a call to LSetSelect.

The objName and p2 parameters are not used.

The SelectMsg Parameter
The Chooser sends the select message whenever a particular choice has become selected,
but only to device packages that do not allow multiple selections. The device package may
not call the List Manager.
IV-218

The Chooser

The Device Manager
If the device accepts fillList messages, objName is undefined. Otherwise, the objName
parameter is a pointer to a string of up to 32 characters containing the name of the device.
If the device accepts fillList messages, p2 gives the row number of the list that has become
selected; otherwise (if the device is an AppleTalk device) p2 gives the AddrBlock value for
the address of the AppleTalk device that has just become selected.

The DeselectMsg Parameter
The Chooser sends the deselect message whenever a particular choice has become

deselected, but only to device packages that do not allow multiple selections. The device
package may not call the List Manager.
If the device accepts fillList messages, objName is undefined. Otherwise, the obj Name
parameter is a pointer to a string of up to 32 characters containing the name of the device.

If the device accepts fillList messages, p2 gives the row number of the list that has become
deselected; otherwise (if the device is an AppleTalk device) p2 gives the AddrBlock value
for the address of the AppleTalk device that has just become deselected.

ho
—_

0

@m

<.

er)
a4)
po)

—

The TerminateMsg Parameter

oe)
ve
ae)
=

The Chooser sends the terminate message when the user selects a different device icon,
closes the Chooser window, or changes zones. It allows the device package to perform
cleanup tasks, if necessary. The device package should not dispose of the device list.
The objName and p2 parameters are not used.

The ButtonMsg Parameter
The Chooser sends the button message when a button in the Chooser display has been
clicked.
|
The low-order byte of the p2 parameter has a value of 1 if the left button has been clicked

and 2 if the right button has been clicked.

The objName parameter is not used.

Operation of the Chooser
When the Chooser is first selected from the desk accessory menu, it searches the system

folder of the startup disk for device resource files—that is, resource files of type 'PRER’,

‘PRES’, or 'RDEV'.

For each one that it finds, it opens the file, fetches the device’s icon,

The Chooser IV-219

Inside Macintosh

fetches the flags long word from the device package, and closes the file. The Chooser then
takes the following actions for each device, based on the information just retrieved:

~ m It displays the device’s icon in the Chooser’s window.
m If the device is an AppleTalk device and AppleTalk is not connected, the Chooser
grays the device’s icon.
When the user selects a device icon that is not grayed, the Chooser reopens the
corresponding device resource file. It then does the following:

m If the device is type ‘PRER’ or 'PRES', it sets the current printer type to that device.
w It labels the device’s list box with the string in the resource ‘STR ' with an ID of

—4091.

u If the device is a local printer, the Chooser fills its list box with the two icons for the

printer port and modem port serial drivers. Later it will record the user’s choice in low
memory and parameter RAM.

m If the device accepts fillList messages, the Chooser calls the device package, which

should fill column 0 of the list pointed to by p1 with the names (without length bytes)

of all available devices in the zone.

u If the device is an AppleTalk device that does not accept fillList messages, the Chooser
initiates an asynchronous routine that interrogates the current AppleTalk zone for all
devices of the type specified in the device’s resource 'STR '-4096. The NBP retry
interval and count are taken from the 'GNRL' resource —-4096; the format of this
resource consists one byte for the interval followed by another byte for the count. As
responses arrive, the Chooser updates the list box.
= To determine which list choices should be currently selected, the Chooser calls the

device with the getSel message. The device code should respond by inspecting the list
and setting the selected/unselected state of each entry. The Chooser may make this call
frequently; for example, each time a new response to the AppleTalk zone interrogation
arrives. Hence the device should alter only those entries that need changing. This
procedure is not used with serial printers; for them, the Chooser just accesses low

memory.

m The Chooser checks the flag in the "PACK' -4096 resource that indicates whether
multiple devices can be active at once, and sets List Manager bits accordingly.
Whenever the user selects or deselects a device, the Chooser will call the device

package with the appropriate message (if it’s accepted). For packages that do not
accept multiple active devices, this is the select or deselect message; otherwise it’s the
newSel message. The device code should implement both mounting and unmounting
the device, if appropriate, and recording the user’s selections on disk, preferably in the
device resource file (which is the current resource file).
When the Chooser is deactivated, it calls the UpdateResFile procedure on the device
resource file and flushes the system startup volume.

IV-220

The Chooser

The Device Manager
When the user chooses a different device type icon or closes the Chooser, the Chooser will
call the device with the terminate message (if it’s accepted). This allows device packages to
clean up, if necessary. After this check, the Chooser closes the device resource file (if the

device is not the current printer) and flushes the system startup volume.

Writing a Device Driver to Run Under Chooser
The code section of a driver running under chooser is contained in the "PACK' -4096

resource, as explained earlier. The driver structure remains as described in chapter 6 of
Volume I.
Device packages initially have no data space allocated. There are two ways to acquire data
space for a device package:
to
S

= Use the List Manager

lo)

©
x=
O
©

w Create a resource
These options are discussed below.
The best method is to call the List Manager. The Chooser uses column 0 of the device list
to store the names displayed in the list box. If the device package currently in use does not
accept fillList messages, column 1 stores the four-byte AppleTalk internet addresses of the

entities in the list. Therefore, the device package can use column 1 and higher (if it accepts
fillList) or column 2 and higher to store data private to itself. The standard List Manager
calls can be used to add these columns, place data in them, and retrieve data stored there.

There are several restrictions on data storage in List Manager cells. The list is disposed
whenever :
m the user changes device types.
m the user changes the current zone.
m the device package does not accept fillList messages, and a new response to the

AppleTalk zone interrogation arrives. The device package will be called with the
getSel message immediately afterwards.

When either of the first two situations occurs, the device package is called with the

terminate message before the list is disposed.

Another way to get storage space is to create a resource in the device’s file. This file is
always the current resource file when the package is called; therefore it can issue

GetResource calls to get a handle to its storage.

It is important for most device packages to record which devices have been chosen. To do
this, the recommended method is to create a resource in the resource file. This resource can
be of any type; it fact, it’s advantageous to provide your own resource type so that no other
program will try to access it. If you choose to use a standard resource type, you should
use only resource IDs in the range -4080 to —-4065.

The Chooser [V-22]

po
~
fg
a
©

Lee §

Inside Macintosh

SUMMARY OF THE DEVICE MANAGER
Constants
CONST

{Chooser

message

newSelMsg

=

fillListMsg

12;

{new

= 13; {fi11

getSelMsg

selectMsg
deselectMsg

=

14;

=

17;

=
=

terminateMsg

buttonMsg
{caller

values}

=

user

{mark

15;
16;

the

one

selections

have

been

made}

list with choices
to be made}
or more choices
as selected}

{a choice has actually been made}
{a choice has been cancelled}
{lets device package clean up}

19;

{tells

driver

a

button

has

been

{caller

value

for

the

Chooser}

selected}

values}

chooserID

=

1;

Routines
FUNCTION

Device
(message, caller:
INTEGER; ob jName,
StringPtr;
pl,p2:
LONGINT)
: OSErr;

zoneName:

Assembly-Language Information
Constants
;

message

values

newsel

. EQU

fillList

- EQU

getSel
select
deselect
terminate
button

-EQU
. BQU
-EQU
.EQU
. EQU

12
13
14
15
16
17
19

;

Chooser

Caller

;new user
;£111 the
;mark one

sa

;a

choice

choice

;lets device package clean
;tells driver a button has

- EQU

;caller

Device Package Data Structure
Byte

Value

0
2
4
8

BRA.S to offset $10

C

Flags (long word)

10

up
been

values

chooserID

A

selections
have been made
list with choices
to be made
or more choices
as selected
has actually been made
has been cancelled

Device ID (word)
‘PACK’ (long word)
$FO00 (4096)
Version (word)

Start of driver code

IV-222 Summary of the Device Manager

value

for

the

Chooser

selected

21

THE DISK DRIVER

The Disk Driver has been extended to support the double-sided 3 1/2-inch drive and the

Apple Hard Disk 20™ drive; support for the single-sided 3 1/2-inch drive is of course

maintained.

A second Hard Disk 20 drive, an external double-sided drive, or an external

single-sided drive can also be connected through the pass-through connector of a Hard
Disk 20.

The Disk Driver's name remains '.Sony' and the reference number for 3 1/2-inch drives
(both single-sided and double-sided) is still —5. The drive numbers for the 3 1/2-inch
drives—1 for the internal drive and 2 for the external drive—are also unchanged.
The Hard Disk 20 has a reference number of —2 and drive numbers of 3 and 4. The Hard

Disk 20 returns 20 tag bytes per sector instead of the 12 bytes returned by the 3 1/2-inch
drives.

The new Disk Driver ignores KillIO calls; as before, you cannot make immediate calls to
this driver. Read-verify mode is still supported for 3 1/2-inch drives, but has no effect on

hard disk drives. A new track cache feature speeds the disk access on 3 1/2-inch drives; an
advance control call (described below) let you control this feature.
The DiskEject function, if used with a hard disk drive, returns the Device Manager result

tr

reposted for that drive.

n

code controlErr; at the next Disk Driver vertical retrace task, a disk-in-place event is

—"

iS)
x

oS

=

Assembly-language note: The additional eight bytes of tag data for the Hard
Disk 20 are stored in the global variable TFSTagData.

ADVANCED CONTROL CALLS
This section describes several advanced control calls used by the Operating System; you
will probably have no need to use them.

csCode

= 5

This call verifies that the disk in the drive specified by ioRefNum in the parameter block
data structure (including hard disks) is correctly formatted.
csCode

= 6

= csParam

= integer

This call formats the disk in the drive specified by ioRefNum in the parameter block data
structure.

With the Hard Disk 20, it zeros all blocks.

A csParam value of 1 causes it to

Advanced Control Calls [V-223

<
ies)

La §

Inside Macintosh
format a single-sided 3 1/2-inch disk in a double-sided drive; otherwise, the value of
csParam should be 0.
Warning:
Package.

csCode

= 9

Use this call with care. It’s normally used only by the Disk Initialization

= csParam =

integer

This call controls the track cache feature. The high-order byte of csParam is nonzero to
enable the cache feature and 0 to disable it. The low-order byte of csParam is 1 to install
the cache, —1 to remove it, and 0 to do neither.

The cache is located in the system heap; the

driver will relinquish cache space, if necessary, when the GrowZone function is called for
the system heap.

csCode

= 21

csParam =

ptr (long)

This call works only with the Hard Disk 20; it returns a pointer to an icon data structure
whose format is identical to that of an ‘ICN#' resource. The drive number must be in
ioRefNum in the parameter block data structure.

SUMMARY OF THE DISK DRIVER
Advanced Control Calls
csCode

csParam_§

5

Effect

Verifies disk formatting

6

integer

Formats a disk

9

integer

Controls track cache feature

21

ptr (long)

Fetches hard disk icon

Assembly-Language Information
Variables

TFSTagData

Additional 8 bytes of Hard Disk 20 tag data

IV-224 Summary of the Disk Driver

22

THE SERIAL DRIVER

In the 128K ROM, a single new Serial Driver replaces the RAM and ROM Serial Drivers.

Note: The new Serial Driver has a version number of 2. The old ROM driver had a

version number of 0, and the old RAM driver a version number of 1.

For best results, include the RAM Serial Drivers as resources of type 'SERD' in the
resource fork of your application and continue to use RAMSDOpen and RAMSDClose.

the 128K ROM is present, the new driver is automatically substituted.

If

The new Serial Driver verifies that the serial port is correctly configured and free; if not, the

result code portNotCf or portInUse is returned. When opened, the Serial Driver defaults to
hardware handshake on (as did the old ROM driver).

The Data Terminal Ready (DTR) line in the RS2372 interface is now automatically asserted
when the Serial Driver is opened; DTR is negated when it is closed. Control calls let you

explicitly set the state of this line, as well as use it to automatically control the input data
flow from an external device.

New advanced control calls let you control the DTR line, set certain control options, and

modify the translation of parity error default characters; they re described below.
All control and status calls may be immediate.
chapter 6 of Volume II.)

(For information about immediate calls, see

The following bugs have been fixed:
a The procedure RAMSDClose preserves mouse interrupts during its execution.
a The execution of break and close routines is now synchronized to the current
transmission.

ho
bo
N

a2)

=f

=

—)
=

<

a Incoming clock pulses on the CTS line are now detected; if they’re present, CTS
interrupts are disabled.

= If you open only the input channel of a driver, the Open routine checks to see if the
necessary variables have been initialized and exits if they have not.

The Serial Driver IV-225

2°)
~

Inside Macintosh

ADVANCED CONTROL CALLS
This section describes several new advanced control calls. Control calls to the Serial Driver
should be made to the output character channel driver.
csCode

= 14

csParam

through

csParam+7

= serShk

This call is identical to a control call with csCode=10 (the SerHShake function, described
in the chapter 9 of Volume II) with the additional specification of the DTR handshake
option in the eighth byte of its flags parameter (the null field of the SerShk record). You

can enable DTR input flow control by setting this byte to a nonzero value. This works
symmetrically to hardware handshake output control.

csCode

= 16

csParam

= byte

This call sets miscellaneous control options. Bits O—-6 should be set to 0 for future options.
Bit 7, if set to 1, will cause DTR to be left unchanged when the driver is closed (rather than
the normal procedure of negating DTR). This may be used for modem control to prevent

the modem from hanging up just because the driver is being closed (such as when the user
temporarily exits the terminal program).
esCode

=

17

This call asserts DTR.

csCode

= 18

This call negates DTR.
csCode

= 20

csParam = char

csParam+lI

= alt char

This call is an extension of call 19, which would simply clear bit 7 of an incoming character

when it matched the replacement character. After this call is made, all incoming characters

with parity errors will be replaced by the character specified by the ASCII code in csParam.
If csParam is 0, no character replacement will be done. If an incoming character is the same
as the replacement character specified in csParam, it will be replaced instead by the second
character specified in csParam+1.
Note;

With this call, the null character (ASCII $00) can be used as the alternate

character but not as the first replacement.

IV-226 Advanced Control Calls

The Serial Driver

SUMMARY OF THE SERIAL DRIVER
Constants
CONST

{

Indication

dtrNegated

that
=

$40;

Result

codes

}

portInUse

=

-97

{

portNotcf£

=

memFullErr

DTR

-98

=

~-108;

is

negated

}

{driver

Open

{ this

connection}

{driver

{not

error,

Open

enough

error,

room

in

port

already

port

not

heap

zone}

in

use}

configured

for

}

Data Types
SerShk

=

PACKED RECORD
fXOn: Byte;

{XOn/XOff

fCTS:

Byte;

{CTS

xOff;

CHAR;

{XOff

evts:

Byté;

{status

xOn:

errs:

CHAR;

Byte;

{XOn

output

hardware

character}

{errors

flow

handshake

character}

that

fiInX:

Byte;

{xOn/XOff

£DTR:

Byte

{DTR

cause

control

flag}

abort}

changes

that

cause

input

flow

control

input

flow

control

flag}

events}
flag}

flag}

END ;

tN

to

SP
fae)

=f

SS

Advanced Control Calls

csCode
14
16

csParam_
serShk
byte

17
18
20

=)
~

Effect
Set handshake parameters
Set miscellaneous contro] options
Asserts DTR
Negates DTR

2 chars

Replace parity errors, with alternate replacement character

Summary of the Serial Driver [V-227

<
Cee)
bone §

Inside Macintosh

Assembly-Language Information
Constants
;

Result

codes

portiInUse
portNotcf

.EQU
.EQU

-977
-98

memFullErr

.EQU

-108

;driver Open error,
;driver Open error,
; this connection
;not enough room in

Structure of Control Information for SerHShake
shFXOn
shFCTS
shXOn

shxX Off
shErrs
shEvts

shFInX
shDTR

XOn/XOff output flow control flag (byte)
CTS hardware handshake flag (byte)
XOn character (byte)

XOff character (byte)
Errors that cause abort (byte)

Status changes that cause events (byte)

XOn/XOff input flow control flag (byte)
DTR control flag (byte)

IV-228 Summary of the Serial Driver

port
port

already in use
not configured

heap

zone

for

23

THE APPLETALK MANAGER

The two AppleTalk device drivers, named .MPP and .ATP, are included in the 128K

ROM.

The AppleTalk Manager, however (the interface to the drivers), is not in ROM;

your application must link to the appropriate object files.

On the Macintosh Plus, you need only open the .MPP driver; this will also load the .ATP
driver and NBP code automatically.

Since, in the 128K ROM, device drivers return errors,

it’s no longer necessary to check whether port B is free and configured for AppleTalk.
port B isn’t available, the .MPP driver won’t open and the result code portInUse or
portNotCf will be returned.

If

Assembly-language note: When called from assembly language, the Datagram
Delivery Protocol (DDP) allows 14 (instead of 12) open sockets.

N
td
>

SS

—

ae

—

or

is
—
p
r2
oO
“

The AppleTalk Manager IV-229

24

THE SYSTEM ERROR HANDLER

A new system error, user alert ID 84, has been added.
Manager tries to access a menu that’s been purged.

This error results when the Menu

nN

BEN

N
tt

i? 2)
en

=

ies

oy

=

—)
=

The System Error Handler IV-231
w

Inside Macintosh

IV;232

25

THE OPERATING SYSTEM UTILITIES

Because in the 128K ROM there can be both an Operating System trap and a Toolbox trap
for any given trap number (for details, see the Using Assembly Language chapter), two

variants of GetIrapAddress and SetTrapAddress have been added. These new routines,
NGetTrapAddress and NSetTrapAddress, require you to specify whether the given trap
number refers to an Operating System trap or a Toolbox trap; the following data type is
defined for this purpose:
TYPE

TrapType

=

(OSTrap,

ToolTrap)

;

The RelString function fills the need for a full-magnitude, language-independent string
comparison, particularly in the hierarchical file system, where entries are sorted in
alphabetical order. Whereas the EqualString function compares two strings only for
equality, RelString compares two strings and returns a value indicating whether the the first
string is less than, equal to, or greater than the second string.
You can use the existing routine Environs to determine whether the 128K ROM is in use; a

description of this procedure is provided below.

OPERATING SYSTEM UTILITY ROUTINES
Assembly-language note:

To use GetTrapAddress and SetTrapAddress with

128K ROM routines, set bit 9 of the trap word to indicate the new trap numbering.

The state of bit 10 then determines whether the intended trap is a Toolbox or
Operating System trap. You can set these two bits with the arguments NEWOS and
NEWTOOL.
Of course, the 64K ROM versions of GetTrapAddress and SetTrapAddress will fail

if applied to traps that exist only in the 128K ROM.

|

The NGetTrapAddress and NSetTrapAddress routines list the possible permutations
of arguments. (The syntax shown applies to the Lisa Workshop Assembler;
programmers using another development system should consult its documentation

$T

for the proper syntax.)

©

MN

=--

Operating System Utility Routines IV-233

—

as)

i? 2)

Inside Macintosh
FUNCTION

NGetTrapAddress

LONGINT;

[Notin ROM]

(trapNum:

INTEGER;

tType:

TrapType)

NGetTrapAddress is identical to GetTrapAddress except that it requires you to specify in
tT ype whether the given routine is an Operating System or a Toolbox trap.

| Trap macro

_GetTrapAddress ,NEWOS

_GetTrapAddress INEWTOOL

On entry

DO:

trapNum (word)

On exit

AO:

address of routine

PROCEDURE

NSetTrapAddress

tType:

TrapType);

(trapAddr:

[Not in ROM]

(bit 9 set, bit 10 clear)
(bit 9 set, bit 10 set)

LongInt;

trapNum:

INTEGER;

NSetTrapAddress is identical to SetTrapAddress except that it requires you to specify in
tT ype whether the given routine is an Operating System or a Toolbox trap.

Trap macro

_SetTrapAddress ,NEWOS

On entry

AO: trapAddr (address)
DO: trapNum ¢word)

FUNCTION

_SetTrapAddress INEWTOOL

RelString
:

(aStr,bStr:

Str255;

(bit 9 set, bit 10 clear)
(bit 9 set, bit 10 set)

caseSens,diacSens:

BOOLEAN)

INTEGER;

RelString is similar to EqualString except that it indicates whether the first string is less

than, equal to, or greater than the second string by returning either —1, 0, or 1 respectively.
Trap macro

_RelString

_RelString ,MARKS

_RelString ,CASE
_RelString ,MARKS,CASE
On entry

IV-234

(sets bit 10, for caseSens=TRUE)
(sets bits 9 and 10)

AO: pointer to first character of first string

Al: pointer to first character of second string

DO:

On exit

(sets bit 9, for diacSens=FALSE)

high-order word:

length of first string

low-order word: length of second string

DO: —1 if first string less than second, 0 if equal, 1 if first string
greater than second (long word)

Operating System Utility Routines

The Operating System Utilities
RelString follows the sort order described in chapter 19 of Volume I except for the
reordering of the following ligatures:
& falls between A and a
z falls between 4 and B

CE falls between @ and o
ce falls between g and P
B falls between s and T

If diacSens is FALSE, diacritical marks are ignored; RelString strips diacriticals according
to the following table:

A

<

E

<

Cc

N
O

U0

<

¢

A,A,AA

E

<—

N.

<

0,0,@

<

iU

a

<—

A,

a,

a,

a,

O

<—

6,

0,

6,

O,

y

<—

c
<—
e
<—
i<
n<m
u

<

¢
6 6,6,é
“7i,i,7
nn

i

46,0, i, ti

a,

O,

a,

a

Q,

°

y

Note: This stripping is identical to that performed by the UprString procedure when
the diacSens parameter is FALSE.

a

Note:

Bt MveQ
©:
Or
om

NA

CHE BOLO: Zt

| |

GY

py ee

Hoo fo:

or

fo”

N

;

|

A

-N | >

If caseSens is FALSE, the comparison is not case-sensitive; RelString performs a
conversion from lower-case to upper-case characters according to the following table:

This conversion is identical to that performed by the UprString procedure.

ed

wm

o)
N

Cc
-

Operating System Utility Routines IV-235

—_

@

if 2)

Inside Macintosh

PROCEDURE

Environs

(VAR rom,machine:

INTEGER)

[Notin ROM]

In the rom parameter, Environs returns the current ROM version number (for a Macintosh
XL, the version number of the ROM image installed by MacWorks). To use the 128K
ROM information described in this volume, the version number should be greater than or
equal to 117 ($75). In the machine parameter, Environs returns an indication of which
machine is in use, as follows:
CONST

0;
1;

macXLMachine
macMachine

{Macintosh XL}
{Macintosh 128K,
{ 512K enhanced,

512K,
512K upgraded,
or Macintosh Plus}

|}

Note: The machine parameter does not distinguish between the Macintosh 128K,
512K, 512K upgraded, 512K enhanced, and Macintosh Plus.
Assembly-language note:

From assembly language, you can get this

information from the word that’s at an offset of 8 from the beginning of ROM (which
is stored in the global variable ROMBase). The format of this word is $00xx for the
Macintosh 128K, 512K, 512K enhanced, or Macintosh Plus, and $xxFF for the
Macintosh XL, where xx is the ROM version number. (The ROM version number

will always be between $01 and $FE.)

SUMMARY OF THE OPERATING SYSTEM UTILITIES
Constants
CONST

{Values

returned

macXLMachine
macMachine

=

=

by

0;
1;

the

Environs

{Macintosh

{Macintosh

{

512K

procedure}

XL}

128K,

enhanced,

512K,
or

|

512K

upgraded,

Macintosh

}

Plus}

Data Types
TYPE

TrapType

=

(OSTrap,TooltTrap) ;

Routines
FUNCTION

NGetTrapAddress

(trapNum:

PROCEDURE

NSetTrapAddress

Longint;
[Notin ROM]
(trapAddr: LongInt; trapNum:
TrapType);
[Notin ROM]

INTEGER;

FUNCTION

RelString

(aStr,bStr:

PROCEDURE

Environs

Str255;

tType:

INTEGER;

caseSens,diacSens:

BOOLEAN) : INTEGER;
(VAR rom,machine: INTEGER)

IV-236 Summary of the Operating System Utilities

TrapType)

tType:

|
[Notin ROM]

The Operating System Utilities

Assembly-Language Information
Routines
Trap macro

On entry

On exit

_GetTrapAddress

_GetTrapAddress ,NEWOS
(bit 9 set, bit 10 clear)

_GetTrapAddress ,NEWTOOL

DO:

(bit 9 set, bit 10 set)
trapNum (word)

AO: address of routine

_SetTIrapAddress

_SetTrapAddress ,NEWOS
(bit 9 set, bit 10 clear)
_SetTrapAddress ,NEWTOOL
(bit 9 set, bit 10 set)
AO: trapAddr (address)
DO: trapNum (word)

_RelString

_RelString ,MARKS
(sets bit 9, for diacSens=FALSE)
_RelString ,CASE
(sets bit 10, for caseSens=TRUE)
_RelString ,MARKS,CASE
(sets bits 9 and 10)
AO: ptr to first string
DO: —1 if first less than second,
Al: ptr to second string
0 if equal, 1 if first greater

DO: high word: length of
first string
low word: length of
second string

than second (long)

Variables
ROMBase

Base address of ROM

ho

7

©

ep)

om,

Summary of the Operating System Utilities IV-237

t som od
pmo
="

@

7 2

Inside

Macintosh

No

AN

o

ee

iF 2)
x

—

~~

=

26

THE DISK INITIALIZATION PACKAGE

a

&

| ed

N

poe)

--

This chapter describes the Disk Initialization Package found in the system resource file.
The package and its resources together occupy about 5.3K bytes.
The Disk Initialization Package initializes disks, formatting the disk medium and placing the
appropriate file directory structure on the disk. Earlier versions of the Disk Initialization
Package format a 3 1/2—inch disk on a single side only, creating a 400K-byte volume and
placing a flat file directory on the disk. The new version of the Disk Initialization Package
can format the 3 1/2—inch disks on either one or both sides, creating 400K or 800K

volumes respectively. It will format other devices (such as hard disks) as well; the size of
volumes is determined by the driver for the particular device.
When the 128K ROM version of the File Manager is present, all volumes except the 400K,

single-sided disks are automatically given hierarchical file directories. (Even the 400K

disks can be given a hierarchical directory by holding down the option key.) If the 128K

version of the File Manager is not present, all volumes are given flat file directories.

The DIFormat function formats disks in single-sided disk drives as 400K volumes and

disks in double-sided drives as 800K volumes; the size of all other volumes is determined
by the driver for the particular device.

The DIZero function places a flat file directory on disks in single-sided disk drives and a
hierarchical file directory on disks in double-sided drives as 800K volumes. With all other
devices, the type of directory placed on a volume is determined by the driver for the
particular device.
The DIBadMount function is called with the result code returned by MountVol as a
parameter. Based on the value of this result code, on the type of drive containing the disk,
and on the disk itself, DIBadMount decides what messages and buttons to display in its

dialog box.

The dialog displayed by DIBadMount gets its messages and buttons from a dialog item list
CDITL' resource —6047). The new dialog item list contains messages and buttons for
responding to all situations, but it’s possible that a new Disk Initialization Package might
run into an old dialog item list. The new Disk Initialization Package determines which item
list it’s using, and makes certain choices as to the best buttons and messages to display.
If the user places a double-sided disk into a single-sided drive, MountVol returns ioErr. If
there’s a new item list, the message “This is a two-sided disk!” is displayed; if there’s an

old item list, the message ““This disk is unreadable:” is used instead.

If the user tries to erase or format a disk that’s write-protected, and there’s a new item list,

the messages “Initialization failed!” and “This disk is write-protected!”’ will be displayed.
If there’s an old item list, the second message is omitted.

If the user tries to erase or format a disk that’s not ejectable, and there’s a new item list, the

Eject button that’s normally displayed is replaced by a Cancel button.

The Disk Initialization Package IV-239

—)
|

Inside Macintosh

If the user tries to erase or format a disk in a double-sided drive, and there’s a new item
list, three buttons are displayed: Eject, One-sided, and Two-sided. If an old version of the

item list is present, only two buttons are displayed: Eject and Initialize. If the user chooses
the Initialize button, the disk is formatted as an 800K volume (and if the hierarchical

version of the File Manager is present, a hierarchical file directory is written).

If the user tries to erase or format a disk in a single-sided drive, only two buttons are
displayed (regardless of which version of the Disk Initialization Package or item list is

present):

Eject and Initialize.

If the user chooses the Initialize button, the disk is formatted

as a 400K, flat volume. With other types of devices, the user can choose to eject the
volume or format it with a size determined by the driver.

When the result code noErr is passed, DIBadMount can be used to reformat a valid,
mounted volume without changing its name. This can be used, for instance, to change the
format of a disk in a double-sided drive from single-sided to double-sided. If there’s a new
item list, your application can specify its own message using the Dialog Manager
procedure ParamText; the message can be up to three lines long. The message is stored as

the string “40”. (Because the TextEdit procedure TextBox is used to display statText

items, word wraparound is done automatically.) If there’s an old item list, the message

“Tnitialize this disk?” is displayed instead.

Warning: If your application uses this call, it must call DILoad before ejecting the
system disk. This will prevent accidental formatting of the system disk.
Note:

The volume to be reformatted must be mounted when DIBadMount is called.

Formatting Hierarchical Volumes
The Disk Initialization Package must set certain volume characteristics when placing a
hierarchical file directory on a volume. Default values for these volume characteristics are
stored in the 128K ROM; this section is for advanced programmers who want to substitute

then own values.

ook like

this:

The record containing the default values, if defined in Pascal, would

TYPE HFSDefaults
PACKED RECORD

SigWord:
abSize:
clpSize:
nxFreeFN:
btClpSize:
rsrvl1:
rsrv2:
rsrv3:

=

ARRAY[1..2]
LONGINT;
LONGINT;
LONGINT;
LONGINT;
INTEGER;
INTEGER;
INTEGER;

OF CHAR;
{signature word}
{allocation block size in bytes}
{clump size in bytes}
{next free file number}
{B*-Tree clump size in bytes}
{reserved}
{reserved}
{reserved}

END;

IV-240 The Disk Initialization Package

Ko

AN

The Disk Initialization Package

o

—_e

hi

_

jamel

The default values for these fields are as follows:

—

bat @

me

2

Field

Default

| el

value

NN
)

is

sigWord
abSize

clpSize

nxFreeFN

btClpSize

©
i)

'BD'
0

4 * abSize
16

0

To supply your own values for these fields, create a similar, nonrelocatable record
containing the desired values and place a pointer to it in the global variable FmtDefaults.

To restore the system defaults, simply clear FmtDefaults.

The sigWord must equal 'BD' (meaning “big disk’’) for the volume to be recognized as a

hierarchical volume. If the specified allocation block size is 0, the allocation block size is
calculated according to the size of the volume:
abSize = (1 + (volSize in blocks / 64K)) * 512 bytes
If the specified B*-tree clump size is 0, the clump size for both the catalog and extent trees

is calculated according to the size of the volume:

btClpSize = (volSize in blocks)/128 * 512bytes

SUMMARY OF THE DISK INITIALIZATION PACKAGE
Variables
FmtDefaults

Pointer to substitute values for hierarchical volume characteristics

Summary of the Disk Initialization Package IV-241

97. THE FINDER INTERFACE
The Finder has been modified to work with the hierarchical file system. In the 64K ROM,
the user’s perceived desktop hierarchy of folders and files is essentially an illusion
maintained (at great expense) by the Finder. In the 128K ROM version of the File
Manager, this hierarchy is recorded in the file directory itself, relieving the Finder of the
task of maintaining this information.

Ne
~~]

=

—|
oO.
fas)
my

—

|

=|

ae)

Law |
maha,

pew)
io)
fae)

THE DESKTOP FILE
Most of the information used by the Finder is kept in a resource file named Desktop. (The

Finder doesn’t display this file on the Macintosh desktop, to ensure that the user won’t
tamper with it.) On flat volumes, file and folder information is kept in resources known as
file objects (resources of type ‘FOBJ'). On hierarchical volumes, the only dynamic file
object data remaining in the Desktop file are the Get Info comments. The other information

about files and folders is maintained by the File Manager; for more details, see the section
“Information Used by the Finder” in chapter 19 of this volume.

With flat volumes, the Finder enumerates the entire volume; this means that it can always
locate a particular application by scanning through all the file objects in memory.

With

hierarchical volumes, however, the Finder searches only open folders, so there’s no

guarantee that it will see the application. A new data structure, called the application
list, is kept in the Desktop file for launching applications from their documents in the
hierarchical file system. For each application in the list, an entry is maintained that includes
the name and signature of the application, as well as the directory ID of the folder
containing it.
Whenever an application is moved or renamed, its old entry in the list is removed, and a

new entry is added to the top of the list. The list is rebuilt when the desktop is rebuilt; this
makes the rebuilding process much slower since the entire volume must be scanned.
Note:

The user has control over the search order in the sense that the most recently

moved or added applications will be at the top of the list and will be matched first.

The Desktop File IV-243

28

THE MACINTOSH PLUS HARDWARE

This chapter describes the hardware features of the Macintosh Plus. Two of these

features—the 800K internal disk drive and the 128K ROM—are also found in the
Macintosh 512K enhanced. This chapter covers only the new features and does not repeat
information already covered in chapter 2 of Volume III.
Note: A partially upgraded Macintosh 512K is identical to the Macintosh 512K
enhanced, while a completely upgraded Macintosh 512K includes all the features of
the Macintosh Plus.

This chapter is oriented toward assembly-language programmers and assumes you’re

familiar with the basic operation of microprocessor-based devices. Knowledge of the
Macintosh Operating System will also be helpful. To learn how your program can

determine the hardware environment in which it’s operating, see the description of the

Environs procedure in chapter 25 of this volume.

Warning: Memory sizes, addresses and other data specific to the Macintosh Plus
are presented in this chapter. To maintain software compatibility across the
Macintosh line, and to allow for future changes to the hardware, you’re strongly
advised to use the Toolbox and Operating System routines wherever provided. In
particular, use the low-memory global variables to reference hardware; never use
absolute addresses.

OVERVIEW OF THE HARDWARE
Features of the Macintosh 512K enhanced (not found in the Macintosh 128K and 512K)
are:
=

8QOK internal disk drive

ms

128K ROM

Features of the Macintosh Plus are:

m

8OOK internal disk drive

a

128K ROM

=

SCSI high-speed peripheral port

=

1Mb RAM, expandable to 2Mb, 2.5Mb, or 4Mb.

m

2 Mini-8 connectors for serial ports, replacing the 2 DB-9 connectors
found on the Macintosh 128K, 512K, and 512K enhanced.

m= keyboard with built-in cursor keys and numeric keypad

Overview of the Hardware IV-245

Nv
ors
<9
p
2.
<
p95
=
©

Leap |

Inside Macintosh

The Macintosh Plus contains the Motorola MC68000 microprocessor clocked at 7.8336

megahertz, random access memory (RAM), read-only memory (ROM), and several chips
that enable it to communicate with external devices. In addition to the five I/O devices
found in the Macintosh 128K, 512K, and 512K enhanced (the video display, sound
generator, VIA, SCC and IWM), the Macintosh Plus contains a NCR 5380 Small

Computer Standard Interface (SCSI) chip for high-speed parallel communication with

devices such as hard disks.

In the Macintosh Plus, the 16 Mb of addressable space is divided into four equal sections.

The first four megabytes are for RAM, the second four megabytes are for ROM and SCSI,

the third are for the SCC, and the last four are for the IWM and the VIA. Since the devices
within each block may have far fewer than four megabytes of individually addressable
locations or registers, the addressing for a device may “wrap around” (a particular register
appears at several different addresses) within its block.

RAM
The Macintosh Plus RAM is provided in four packages known as Single In-line Memory

Modules (SIMMs). Each SIMM contains eight surface-mounted Dynamic RAM (DRAM)
chips on a small printed circuit board with electrical “finger” contacts along one edge.
Various RAM configurations are possible depending on whether two or four SIMMs are
used and on the density of the DRAM chips that are plugged into the SIMMs:

m If the SIMMs contain 256K-bit DRAM chips, two SIMMs will provide 512K bytes of
RAM, or four SIMMs will provide 1Mb of RAM (this is the standard configuration).
m If the SIMMs contain 1M-bit DRAM chips, two SIMMs will provide 2Mb of RAM,
or four SIMMs will provide 4Mb of RAM.
m If two of the SIMMs contain 1M-bit DRAM chips, and two of the SIMMs contain
256K-bit DRAM chips, then these four SIMMs will provide 2.5Mb of RAM. For this
configuration, the 1M-bit SIMMs must be placed in the sockets closest to the 68000
CPU.
Warning: Other configurations, such as a single SIMM or a pair of SIMMs
containing DRAMs of different density, are not allowed. If only two SIMMs are

installed, they must be placed in the sockets closest to the MC68000.

The SIMMs can be changed by simply releasing one and snapping in another. However,
there are also two resistors on the Macintosh Plus logic board (in the area labelled “RAM
SIZE”) which tell the electronics how much RAM is installed. If two SIMMs are plugged
in, resistor R9 (labeled “ONE ROW”) must be installed; if four SIMMs are plugged in, this
resistor must be removed. Resistor R8 (labelled “256K BIT’’) must be installed if all of the
SIMMs contain 256K-bit DRAM chips. If either two or four of the SIMMs contain 1M-bit

chips, resistor R8 must be removed.

Each time you turn on the Macintosh Plus, system software does a memory test and

determines how much RAM is present in the machine. This information is stored in the

global variable MemTop, which contains the address (plus one) of the last byte in RAM.

IV-246 Overview of the Hardware

The Macintosh Plus

Hardware

ROM
The Macintosh Plus contains two 512K-bit (64K x 8) ROM chips, providing 128K bytes
of ROM. This is the largest size of ROM that can be installed in a Macintosh 128K, 512K,
or 512K enhanced. The Macintosh Plus ROM sockets, however, can accept ROM chips of

up to 1M-bit (128K x 8) in size. A configuration of two 1M-bit ROM chips would provide
256K bytes of ROM.

THE VIDEO INTERFACE
The starting addresses of the screen buffers depend on the amount of memory present in
the machine. The following table shows the starting address of the main and the alternate
screen buffer for various memory configurations of the Macintosh Plus:
System

Main

Macintosh
Macintosh
Macintosh
Macintosh

Plus, 1Mb
Plus, 2Mb
Plus, 2.5Mb
Plus, 4Mb

Screen

$FA700
$1FA700
$27A700
$3FA700

Alternate
$F2700
$1F2700
$272700
$3F2700

Warning: To ensure that software will run on Macintoshes of different memory
size, aS well as on future Macintoshes, use the address stored in the global variable
ScrnBase.

Also, the alternate screen buffer may not be available in future versions of

the Macintosh and may not be found in some software configurations of current
Macintoshes.

THE SOUND GENERATOR
The starting addresses of the sound buffers depend on the amount of memory present in the
machine. The following table shows the starting address of the main and the alternate

sound buffer for various memory configurations of the Macintosh Plus:
System
Macintosh Plus, 1Mb

Macintosh Plus, 2Mb
Macintosh Plus, 2.5Mb
Macintosh Plus, 4Mb

Main

Sound

$FFDO0O

$1FFDO0
$27FD00
$3FFD00

Alternate
$FA100

$1FA100
$27A100
$3FA100

The Sound Generator IV-247

Nv
oo
=
po
=
2.
<
g
©

Leaw |

Inside Macintosh

Warning: To ensure that software will run on Macintoshes of different memory
size, aS well as future Macintoshes, use the address stored in the global variable
SoundBase.

Also, the alternate sound buffer may not be available in future versions

of the Macintosh and may not be found in some software configurations of current
Macintoshes.

THE SCC
The Macintosh Plus uses two Mini-8 connectors for the two serial ports, replacing the two
DB-9 connectors used for the serial ports on the Macintosh 128K, 512K, and 512K

enhanced.

The Mini-8 connectors provide an output handshake signal, but do not provide the +5

volts and +12 volts found on the Macintosh 128K, 512K, and 512K enhanced serial

ports.

The output handshake signal for each Macintosh Plus serial port originates at the SCC’s

Data Terminal Ready (DTR) output for that port, and is driven by an RS423 line driver.
Other signals provided include input handshake/external clock, Transmit Data + and -,

and Receive Data + and -.

CON

OU

A

WN

—

Figure 1 shows the Mini-8 pinout for the SCC serial connectors.

Output handshake
Input handshake / external clock

Transmit data Ground

Receive data Transmit data +

(not connected)

Receive data +

Figure 1. Pinout for SCC Serial Connectors
Diagram

Figure 2 shows a circuit diagram for the Macintosh Plus serial ports.

IV-248

The SCC

The Macintosh Plus

8530 (SCC)

112 of 26LS30_

1xD4-—_H

ATS,

an

O-| FFT FTIter)

OE

Hardware

A-tO*1_ FFT Filter

At

—_———.

Not

RTxCahk——— 3.672 MHz

Connected

=

RXDA+

1/2 of 26LS32

RxD A

O <t--]
<HELFiiter
[7

_

CTSabr
TRxC,

oe

i}

RFT Filter

I+

— [CREELFilter
aL

RXDAUSK;

{{ =

Ye

tv
ors
=
fo

T

lA

—

2.

x
=
=
©

1/2 of S636A (or 3488A)

DTRa

E

|e o

CFI Filter

ua
4

W/REQah

© _6522 (VIA)_

W7REQE dea

|

Note:

R1

-CHETF
Ife = W>-W\nes Pitter
Cc

1/2 of 26LS30

+s QO"! __ RFT Filtep

+2) NotFilter
ATSg}__1e Slew-rateE
va

(Ri+R2 = 40 to 60 ohms,

Modey7.;
wee
PCLKL,
ATxCp 1 3.672 MHz
12 of 26LS32
Q <t

TsTSBIT

O <f

T Cal!

aoe

B

,

AFI Filter

7
AFL Filter
=|
CELE»
Filter —
I1

+12V-1Vec”

Wave

FI

Et.

Not

1/2 of 9636A (or 3488A)
—_TRea-—_! 2 - |_ RETF
Figure 2.

C = 150 to 300 pF)

Vcc controlsE connected

AxDp

’

ya

L

TxDg

sR?

Connected
AAD
Bt
RXDB —
{f
HSKip

1

CRO
87

ae

6

oe
2

SK
HSKOB

Circuit Diagram for the Macintosh Plus Serial Ports
The SCC IV-249

Inside Macintosh

THE KEYBOARD
The Macintosh Plus keyboard, which includes a built-in numeric keypad, contains a
microprocessor that scans the keys. The microprocessor contains ROM and RAM, and is
programmed to conform to the same keyboard interface protocol described in chapter 2 of
Volume III.
The Macintosh Plus keyboard reproduces all of the key-down transitions produced by the
keyboard and optional keypad used by the Macintosh 128K, 512K, and 512K enhanced;
the Macintosh Plus keyboard is also completely compatible with these other machines. If a
key transition occurs for a key that used to be on the optional keypad in /owercase, the
Macintosh Plus keyboard still responds to an Inquiry command by sending back the
Keypad response ($79) to the Macintosh Plus. If a key transition occurs for an key that
used to be on the optional keypad in uppercase, the Macintosh Plus keyboard responds to

an Inquiry command by sending back the Shift Key-down Transition response ($71),
followed by the Keypad response ($79). The responses for key-down transitions on the
Macintosh Plus are shown (in hexadecimal) in Figure 3.
~7T17273

65 | 25

1475

27129

|2B]

T6OT7

2F | 2D}

7879

TOT

- | =

35 | 39 | 33 | 3B]

bacspce

37 | 31

1 alsloltlslalslele olla)

61... 1
BJID}
CapsLock] A | S
73
014 03 re

Shift

Sa

75

E

OD]
6F

E

OF]

|

E

1F fj 23.]
07

4.

21

oe

E

1417

os

E

45)

ip

E

3F

=

E

11113117/5B75D]57

space
63

147

4B

E

1434

3D
' | Return
4F]
49

53

|] 5F]

|

59

| or

l. E |?
55 | OD}

054

a

1B

¥

11

Clear]

=

OF}

| / | x

11}1By

05

33137 | 39]

33137})3911D
415
76]
+
2D] 2F 13114 OD

1,213

2712912B

0

25

[te

; |

034,19

U.S. and International Keyboard

Figure 3. Key-Down Transitions

THE FLOPPY DISK INTERFACE
The Macintosh Plus has an internal double-sided disk drive; an external double-sided drive
or the older single-sided drive, can be attached as well.
Note: The external double-sided drive can be attached to a Macintosh 512K through
the back of a Hard Disk 20. The Hard Disk 20 start-up software contains a device
driver for this drive and the hierarchical (128K ROM) version of the File Manager.

IV-250 The Floppy Disk Interface

The Macintosh Plus Hardware

The double-sided drive can format, read, and write both 800K double-sided disks and
400K single-sided disks. The operation of the drive with double-sided disks differs from
that on single-sided disks. With double-sided disks, a single mechanism positions two
read/write heads—one above the disk and one below—so that the drive can access two
tracks simultaneously—one on the top side, and a second, directly beneath the first, on the

bottom side. This lets the drive read or write two complete tracks of information before it
has to move the heads, significantly reducing access time. For 400K disks, the double-

sided drive restricts itself to one side of the disk.
Warning:

Applications (for instance, copy protection schemes) should never

interfere with, or depend on, disk speed control.

The double-sided drive controls its

own motor speed, ignoring the speed signal (PWM) from the Analog Signal
Generator (ASG).

tu
or
<fg

_—

2.

<=

oS
mt
©

THE REAL-TIME CLOCK
The Macintosh Plus real-time clock is a new custom chip. The commands described in
chapter 2 of Volume III for accessing the Macintosh 512K clock chip are also used to
access the new chip. The new chip includes additional parameter RAM that’s reserved by
Apple. The parameter RAM information provided in chapter 13 of Volume II, as well as
the descriptions of the routines used for accessing that information, apply for the new clock
chip as well.

THE SCSI INTERFACE
The NCR 5380 Small Computer Standard Interface (SCSI) chip controls a highspeed parallel port for communicating with up to seven SCSI peripherals (such as hard

disks, streaming tapes, and high speed printers). The Macintosh Plus SCSI port can be

used to implement all of the protocols, arbitration, interconnections, etc. of the SCSI
interface as defined by the ANSI X3T9.2 committee.

The Macintosh Plus SCSI port differs from the ANSI X3T9.2 standard in two ways.
First, it uses a DB-25 connector instead of the standard 50-pin ribbon connector. An Apple
adapter cable, however, can be used to convert the DB-25 connector to the standard 50-pin

connector. Second, power for termination resistors is not provided at the SCSI connector
nor is a termination resistor provided in the Macintosh Plus SCSI circuitry.

Warning:

Do not connect an RS232 device to the SCSI port. The SCSI interface is

designed to use standard TTL logic levels of 0 and +5 volts; RS232 devices may
impose levels of —25 and +25 volts on some lines, thereby causing damage to the
logic board.

The SCSI Interface IV-251

Inside Macintosh

The NCR 5380 interrupt signal is not connected to the processor, but the progress of a

SCSI operation may be determined at any time by examining the contents of various status
registers in the NCR 5380. SCSI data transfers are performed by the MC68000; pseudoDMA mode operations can assert the NCR 5380 DMA Acknowledge (DACK) signal by

reading or writing to the appropriate address (see table below). Approximate transfer rates
are 142K bytes per second for nonblind transfers and 312K bytes per second for blind

transfers.

(With nonblind transfers, each byte transferred is polled, or checked.)

Figure 4 shows the DB-25 pinout for the SCSI connector at the back of the Macintosh
Plus.

1

REQ

14

Ground

3

170

16

Ground

2
4
S
6

7

8
9
10
11

12
13

MSG
RST
ACK
BSY

Ground

DBO
Ground
DB3
DBS

DB6
DB7

15

17.
18
19
20

C/D

ATN
Ground
SEL
DBP

21
22
23

+#DBi
# DB2
DB4

25

— (not connected)

24

Ground

Figure 4. Pinout for SCSI Connector
The locations of the NCR 5380 control and data registers are given in the following table as
offsets from the constant scsiWr for write operations, or scsiRd for read operations. These
base addresses are not available in global variables; instead of using absolute addresses,

you should use the routines provided by the SCSI Manager (covered in chapter 31 of this
volume).

IV-252

The SCSI Interface

The Macintosh Plus Hardware

Read and write operations must be made in bytes. Read operations must be to even

addresses and write operations must be to odd addresses; otherwise an undefined operation
will result.

The address of each register is computed as follows:

$580drn
where r represents the register number (from 0 through 7),

n determines whether it a read or write operation
(0 for reads, or 1 for writes), and
d determines whether the DACK signal to the NCR 5380 is asserted.
(0 for not asserted, 1 is for asserted)
Here’s an example of the address expressed in binary:

lew

p

tS
©

Lee §

Note: Asserting the DACK signal applies only to write operations to the output data
register and read operations from the input data register.
Symbolic
Location

Memory
Location

NCR

scsiWr+sODR+dackWr
scsikd+sIDR+dackRd
scsiWr+sODR
scsiWr+sICR
scsiWr+sMR
scsiWr+sTCR
scsiWr+sSER
scsiWr+sDMAtx
scsiWr+sTDMArx
scsiWr+sIDMArx
scsiRd+sCDR

$580201
$580260
$580001
$580011
$580021
$580031
$580041
$580051
$580061
$580071
$580000

Output Data Register with DACK
Current SCSI Data with DACK
Output Data Register
Initiator Command Register
Mode Register
Target Command Register
Select Enable Register
Start DMA Send
Start DMA Target Receive
Start DMA Initiator Receive
Current SCSI Data

scsiRd+sMR
scsiRd+sTCR
scsiRd+sCSR
scsiRd+sBSR
scsiRd+sIDR
scsiRd+sSRESET

$580020
$580030
$580040
$580050
$580060
$580070

Mode Registor
Target Command Register
Current SCSI Bus Status
Bus and Status Register
Input Data Register
Reset Parity/Interrupt

Note:

$580010

3

Q.

0101 1000 0000 00d0 Orrr 000n

scsiRd+sICR

ty
ors
se
g

5380

Internal

Register

Initiator Command Register

For more information on the registers and control structure of the SCSI,

consult the technical specifications for the NCR 5380 chip.

The SCSI Interface [V-253

Inside Macintosh

SUMMARY
Constants
;

SCSI

scsiRd
scsiwr

;

base

addresses
.EQU
-EQU

SCSI

offsets

dackRd
dackwWr

-EQU
-EQU

;

SCSI

offsets

$580000
$580001

for

NCR

SCDR
SOCR

. EQU
- QU

$00
S00

SICR

- EQU

$10

SMR

-EQU

$20

STCR

-EQU

$30

sCSR

.EQU

$40

SSER

- EQU

$40

-EQU

$50

. EQU
. EQU

$60
$60

SBSR

sDMAtx

SIDR
STDMArx

-EQU

$50

SRESET

- EQU

$70

SIDMArx

.EQU

$70

IV-254 Summary

address
address

for
for

read operations
write operations

DACK
;for
;for

$200
$200

to

;base
;base

5380

use
use

with
with

sOCR
sOCR

and
and

sIDR
sIDR

register
;Current SCSI Read Data
(read)
;Output Data Register
(write)
;Initiator Command Register
(read/write)
;Mode Register
(read/write)
;Target Command Register
(read/write)
;Current SCSI Bus Status
(read)
;Select Enable Register
(write)
;Bus & Status Register
(read)
;DMA Transmit Start
(write)
;Data

input

;Reset

Parity/Interrupt

;Start

;Start

Target

register

DMA

Initiator

(read)

receive

DMA

(write)

(read)

receive

(write)

29

THE SYSTEM RESOURCE FILE

This chapter describes the contents of the System file version 3.2 whose creation date is

June 4, 1986.

The System file, also known as the system resource file, contains standard resources that

are shared by all applications, and are used by the Macintosh Toolbox and Operating
System as well. This file can be modified by the user with the Installer and Font/DA
Mover programs.

Warning: You should not add resources to, or delete resources from, the system
resource file directly.
Note: Some of the resources in the system resource file are also contained in the
128K ROM; they’re duplicated in the system resource file for compatibility with
machines not equipped with the 128K ROM. Other resources are put in the system
resource file because they are too large to be put in ROM.
The system resource file contains the standard Macintosh packages and the resources they
use (or Own):
m the List Manager Package (‘PACK' resource 0), and the standard list definition
procedure (‘LDEF' resource 0)
m the Disk Initialization Package (‘PACK'’ resource 2), and code (resource type
'FMTR’) used in formatting disks
m the Standard File Package (PACK '’ resource 3), and resources used to create its alerts
and dialogs (resource types 'ALRT’, ‘DITL’', and 'DLOG’)

w the Floating-Point Arithmetic Package (PACK resource 4)
= the Transcendental Functions Package (‘PACK' resource 5)
u the International Utilities Package (‘PACK’ resource 6)
= the Binary-Decimal Conversion Package (‘PACK' resource 7)
Certain device drivers (including desk accessories) and the resources they use (or own) are

also found in the system resource file; these resources include:

= the .PRINT driver ((DRVR' resource 2) that communicates between the Printing
Manager and the printer
m the .MPP and .ATP drivers (DRVR' resources 9 and 10 respectively) used by
AppleTalk
w the Control Panel desk accessory (‘DRVR' resource 15) and the bit maps (resource
type 'bmap') and windows (resource type "WIND') used in displaying its various
options

The System Resource File IV-255

Ne

Oo
Nr
at
N

--

=

w~
eo
nn

©
=

=™
CA
@m

Inside Macintosh

m the Chooser desk accessory (‘DRVR' resource 16), and the dialogs, icons, list
definition procedures, and strings (resource types ‘DITL’, 'DLOG’, ‘ICON’, and
'LDEF'’) that it uses (or owns)
Other general resources contained in the system resource file include:
= standard definition procedures for creating windows, menus, controls, lists, and so on
m system fonts and font families (resource types "FONT" and 'FOND")
m system icons
= code for patching bugs in ROM routines (resource type 'PTCH’)
= initialization resources (described below) used during system startup

INITIALIZATION RESOURCES
The system resource file contains initialization resources (resource type 'INIT") used
during system startup. A mechanism has been provided so that applications can supply
code to be executed during system startup without adding resources of type 'INIT" to the
system resource file. Instead of putting your code in the system resource file, you should
create a separate file with a file type of 'INIT' (or for Chooser devices, file type RDEV’).
A special initialization resource in the system resource file, ‘INIT’ resource 31, searches
the System Folder of the system startup volume for files of type 'INIT' or 'RDEV'. When
it finds one, it opens the file (with ResLoad set to FALSE) and uses GetIndResource (with
ResLoad set to TRUE) to find all resources in that file of type 'INIT’. It calls each
resource it finds. After calling the last resource, it closes the file, and continues searching

for other files of type INIT’ or 'RDEV'.

Warning: If you do not want your 'INIT' resources to be released, be sure to call
the Resource Manager procedure DetachResource.
Note: The order in which your 'INIT' resources are called depends on the order in
which your ‘INIT’ and 'RDEV' files are opened, and on the order of the 'INIT'

resources within these files; these orders are not predictable.

Assembly-language note: The 'INIT' resource 31 saves all registers and places
the handle to your ‘INIT’ resource in register AO.

The System Startup Environment
This section discusses the organization of the Macintosh Plus RAM at the time your 'INIT'
files are loaded (see Figure 1); most the information presented here is useful only to
assembly-language programmers.

IV-256 Initialization Resources

The System Resource File

high memory
static allocation

<—

(MemTop)

<—

(BufPtr)

<—

(MemTop)/2

€—

(MemTop)/2

<—

(AppliLimit)

€—

(HeapEnd)

<—

(ApplZone)

<—

(SysZone)

room for

static allocation
system startup blocks
system startup stack (8K)

pe

ee
application heap
system heap

:

system globals

+ 1K

Ll ]
\o

N

|

el
72)

-_-

ea)

5

w

low memory

fee)

17 2)

o

Figure 1. Macintosh Plus RAM at System Startup
The global variables, shown in parentheses, contain the addresses of the indicated areas.

The application heap limit (stored in the global variable ApplLimit) is set to 8K below the
beginning of the boot stack to protect the stack.
Static allocation off the address contained in the global variable BufPtr is useful when a
large amount of space is needed which will never be deallocated (once space is allocated, it
may not be deallocated unless no one has allocated space below). An 'INIT' resource may
obtain permanent space by moving BufPtr down, but no further than the location of the
boot blocks (MemTop/2 + 1K). (If it’s necessary to allocate space below MemTop/2 +

1K, contact Developer Technical Support for details.) It may also use the application zone

for temporary heap memory.

Warning: An 'INIT' resource that wants to grow the system heap should be aware
that its associated resource map is open in the application heap at the time.
To avoid their being deallocated when the application heap is initialized, vertical retrace

tasks, AppleTalk listeners, and RAM-based drivers (and their storage) should be placed in

the system heap or in statically allocated space.

Initialization Resources I[V-257

—)
ee
a)
fae]

30

THE LIST MANAGER PACKAGE

261

About This Chapter

261
261

262

About the List Manager Package
Appearance of Lists

Drawing

Lists

262
263

List Records
The List Record Data Structure

268
269
210

Using the List Manager Package
List Manager Package Routines
Creating and Disposing of Lists

266
266

271

272
273
274

275
276

276
277
277
277
277
278

The LClikLoop Field
Cell Selection Algorithm

Adding and Deleting Rows and Columns

Operations on Cells
Mouse Location
Accessing Cells

List Display
Defining Your Own Lists

The List Definition Procedure
The Initialize Routine
The Draw Routine
The Highlight Routine
The Close Routine
Summary of the List Manager Package

Cad
i)

C.

i? 2)
-

po)

i}

pa)
Te
fee)
ian j

Contents IV-259

Inside Macintosh

IV-260

The List Manager Package

ABOUT THIS CHAPTER
This chapter describes the List Manager Package, which lets you create, display, and
manipulate lists.
You should already be familiar with:
m resources, as discussed in the Resource Manager chapter
= the basic concepts and structures behind QuickDraw, particularly points, rectangles,
and grafPorts

m the Toolbox Event Manager and the Window Manager
m packages in general, as described in the Package Manager chapter
Warning: Early versions of the system resource file may not contain the List
Manager Package.

ABOUT THE LIST MANAGER PACKAGE
The List Manager Package is a tool for storing and updating elements of data within a list
and for displaying the list in a rectangle within a window. It handles all hit-testing,
selection, and scrolling of list elements within that list. In its simplest form, the List

Manager Package can be used to display a “text-only” list of names; with some additional
effort, it can be used to display an array of images and text.
A list element is simply a group of consecutive bytes of data, so it can be used to store
anything—a name, the bits of an icon, or the resource ID of an icon. There’s no specific

restriction on the size of a list element, but the total size of a list cannot exceed 32K bytes.

Appearance of Lists
A list is drawn in a window.

When you create a list, you need to supply a pointer to the

window to be used; the grafPort of this window becomes the port in which drawing is
done.

You must also supply a rectangle in which to display the list. You specify whether the list
should use scroll bars and a size box. If you request scroll bars, they’re drawn outside the
rectangle (but within the window). If you request a size box, the List Manager leaves room
for one but does not draw it; to draw the size box, see the Window Manager procedure
DrawGrowlcon. The rectangle can take up the entire area of the content region (except for
the space needed by scroll bars, if any), or it can occupy only a small portion of the content
region.

About the List

Manager Package IV-261

Crd
co)

c.

Ni
-

po)
|
pe)
we
ce
=

Inside Macintosh

List elements are displayed in cells; an element can be seen as the contents of a cell. Cells
provide the basic structure of a list, and may or may not contain list elements. While list
elements (the actual data) may vary in length, the cells in which they’re displayed must be
the same size for any given list. You can specify the horizontal and vertical size of a cell
when you create a list; if either dimension is unspecified, the List Manager calculates a

default dimension.

The dimensions of a list are always specified as a number of rows and columns of cells.
When you create a list, you can specify the number of cells it is to contain initially; if you
don’t, it’s created with no cells. To add cells to an empty list, you call routines that add
entire rows or columns of cells at a time. For instance, to add a single column of 15 cells
to an empty list, you would first call a routine to add one column, followed by a routine
adding 15 rows.
All cells are initially empty. Once you’ve added the rows and columns of a list, you can set
the values of the cells. At some later point, you can also add empty rows and columns to a
list that already contains data.

Drawing Lists
The List Manager provides a drawing mode that you can set either on or off. When the

drawing mode is on, all routines that affect the contents of cells, the number of rows or
columns, the size of the window, or which cells are visible within the rectangle will cause

drawing to happen.

In certain cases, such as the insertion or setting of many cells (typically when the list is
created), drawing is either unsightly or slow. In these cases, you’ll want to set the drawing
mode to off; when the action is completed, you can set the drawing mode back to on.
The appearance and behavior of a list is determined by a routine called its list definition
procedure, which is stored as a resource in a resource file. The List Manager calls the
definition procedure to perform any additional list initialization (such as the allocation of
Storage space for the application), to draw a cell, to invert the highlight state of a cell, and
to dispose of any data it may have allocated.
The system resource file includes a list definition procedure for a standard text-only list. If
you'd like another type of list, you’ll have to write a list definition procedure, as described
later in the section “Defining Your Own Lists”.

LIST RECORDS
The List Manager maintains all the information it requires for its operations on a particular
list in a list record. A list record includes:
= A pointer to the grafPort used by the list; it’s set to the port of the window specified
when the list is created.
w The rectangle, given in the window’s local coordinates, in which the list is to be
displayed.
IV-262

List Records

The List Manager Package
= A rectangle that specifies, by row and column, the dimensions of the list.

m A rectangle that determines, by row and column, which cells are currently visible.

m A handle to the list definition procedure, which actually performs the drawing
cells.

of the

w The size of a cell.

u A field containing flags that control the selection process.
The list record also contains a handle to the cell data. The data is stored as a contiguous
block of data in list order (cells 0..n of row 0, cells 0..n of row 1, and so on). The cell
data is locked down only while it’s being searched.

The last field of the list record is an array of integers containing the offset of each cell’s data
within the contiguous block of cell data. The high-order bit of an array element is set if the
corresponding cell is selected; the remaining 15 bits contain the offset. This provides the
maximum total data size of 32K, and an overhead of one word per cell.

Warning: Since a variety of routines are provided for accessing cell data, you should
never need to directly access the array of offsets or the data itself.

The List Record Data Structure
Cad

The exact data structure of a list record is as follows:

~
iF 9)

TYPE

Cell

=

Point;

DataArray

DataPtr
DataHandle
ListRec

<=

= PACKED ARRAY

=
=

“DataArray;
“DataPtr;

[0..32000]

po)

OF CHAR;

E

©

=

RECORD

rView:
port:

Rect;
GrafPtr;

indent:
cellSize:

Point;
Point;

vScroll:
hScroll:

ControlHandle;
ControlHandle;

visible:

selFlags:

Rect;

{list's
{list's

display rectangle}
grafPort}

{indent distance}
{cell
size}

{boundary

SignedByte;

{selection

SignedByte;
SignedByte;

{reserved}
{automatic

1C1likLoop:

“Ptr;

{routine

listDefProc:

Handle;

lActive:

BOOLEAN;

clikTime:
clikLoc:
mouseLoc:

LONGINT;
Point;
Point;

lReserved:
listFlags:

lastClick:
refCon:

Cell;
LONGINT;

of

visible

cells}

{vertical
scroll bar}
{horizontal
scroll bar}

{TRUE

if

flags}

active}

scrolling

flags}

{time of last click}
{position
of last click}
{current mouse
location}

for

LClick}

{last cell clicked}
{list's
reference
value}

{list

definition

procedure}

List Records

IV-263

Inside Macintosh
userHandle:
dataBounds:
cells:
maxIndex:
cellArray:

Handle;
Rect;
DataHandle;
INTEGER;
ARRAY
[1..1]

{additional storage}
{boundary of cells allocated}
{cell data}
{used internally}
OF INTEGER
{offsets to data}

END;

ListPtr
ListHandle

=
=

“ListRec;
“ListPtr;

RView is the rectangle, given in the local coordinates of the grafPort, in which the list is

displayed. Room for scroll bars is not included in this rectangle. If the list has scroll bars
and is to fill the entire window, rView should be 15 points smaller in each dimension than
the grafPort.
Port is the grafPort used by the list; it’s set to the port of the window specified when the list
is created. Indent is the distance in pixels that the list definition procedure should indent
from the topLeft of the cell when drawing the contents. The default value for indent is 0,
but it can be set by the list definition procedure.

CellSize is the size of a cell in pixels. If it’s not specified when the list is created, a default

cell size is set. CellSize.v is set to the ascent plus descent plus leading of the port’s font,
and cellSize.h is set to
(rView.right — rView.left) DIV (dataBounds.right — dataBounds.
left)

A cell is a box in which a list element is displayed. Cells are identified by their column and
row numbers. In Figure 1, for instance, the highlighted cell is in column 1, row 2.
Cells are declared as points, using the Point data type simply as a way of specifying the

column and row number of a cell. Similarly, visible and dataBounds use the Rect data type

to specify a rectangular set of cells as two diagonally opposite cell coordinates (rather than
two diagonally opposite points in the local coordinates of a grafPort).

DataBounds is the boundary of the cells currently allocated, specified by row and column.
The list in Figure 1 (assuming the entire list is visible) has seventeen rows and five
columns of cells. DataBounds for this list can be represented, using the QuickDraw
rectangle notation (left,top)(right,bottom), as (0,0)(5,17). Notice that the column and row
specified for the bottom right of dataBounds are 1 greater in each dimension than the
column and row number of the bottom right cell. Thus, you can test to see if a cell is a
valid cell within the boundary of a list using the statement:
IF

PtInRect

(c,myList**.dataBounds)

THEN...

The visible rectangle reflects which cells are currently within the visible part of the list; it’s
calculated by the List Manager according to the values you specify for rView, dataBounds,
and cellSize when you create the list. (Visible.topLeft is the row and column of the top left
visible cell; visible.botRight is 1 greater in both dimensions than the row and column of the
bottom right visible cell.) For example, if only four cells—row 2, column 0; row 2,
column 1; row 3, column 0; and row 3, column 1—are visible, the visible rectangle is
(0,2)(2,4). You can test to see if a cell is visible using the statement:
IF

IV-264

PtInRect

(c,myList**.visible)

List Records

THEN...

The List Manager Package

2 SSS

Cell 0,0
Cell 0,1
Cell 0,2
Cell 0,3
Cell 0,4
Cell 0,5
Cell 0,6
Cell 0,7
Cell 0,8
Cell 0,9
Cell 0,10
Cell 0,11
Cell 0,12
Cell 0,13
Cell 0,14
Cell 0,15
Cell 0,16

a sample

Cell 1,0
Cell 1,1
z
Cell 1,3
Cell 1,4
Cell 1,5
Cell 1,6
Cell 1,7
Cell 1,8
Cell 1,9
Cell 1,10
Cell 1,11
Cell 1,12
Cell 1,13
Cell 1,14
Cell 1,15
Cell 1,16

Cell 2,0
Cell 2,1
Cell 2,2
Cell 2,3
Cell 2,4
Cell 2,5
Cell 2,6
Cell 2,7
Cell 2.8
Cell 2,9
Cell 2,10
Cell 2,11
Cell 2,12
Cell 2,13
Cell 2,14
Cell 2,15
Cell 2,16

Cell 3,0
Cell 3,1
Cell 3,2
Cell 3,3
Cell 3,4
Cell 3,5
Cell 3,6
Cell 3,7
Cell 3,8
Cell 3,9
Cell 3,10
Cell 3,11
Cell 3,12
Cell 3,13
Cell 3,14
Cell 3,15
Cell 3,16

Cell 4,0
Cell 4.1
Cell 4.2
Cell 4,3
Cell 4.4
Cell 45
Cell 4.6
Cell 4,7
Cell 4.8
Cell 4.9
Cell 4,10
Cell 4,11
Cell 4,12
Cell 4,13
Cell 4,14
Cell 4,15
Cell 4,16

Figure 1. A Sample List
SelFlags contains selection flags for the List Manager. It’s initialized to 0; with this setting,
the List Manager selects cells according to the Macintosh User Interface Guidelines. The
meaning of these flags is explained below in the section “Cell Selection Algorithm’. The
listFlags field contains automatic scrolling flags; the List Manager sets these flags
automatically when you specify scroll bars. There are predefined constants that let you set
or test the status of the corresponding bits:
CONST

1DoVAutoScroll
1DoHAutoScroll

2;
1;

{set to allow
{set to allow
{ scrolling}

automatic
automatic

vertical scrolling}
horizontal
}

ClikLoc is the position of the last mouse click in local coordinates; you can use it in the list
definition procedure to get the position within the cell. LClikLoop is a pointer to the

routine to be called during the LClick function, as described later. LastClick contains the

cell coordinates of the last cell clicked in.

RefCon is the list’s reference value field, which the application may store into and access
for any purpose. In addition, the application may use the field userHandle to store a handle
to an additional storage area.
CellArray contains offsets to the cell data. For each list element, this includes the bit
indicating whether the cell is selected or not.

List Records

IV-265

ie)
S
C
2)

aaa
po}
i}
pe)
TS?

fae)
=

Inside Macintosh

The LClikLoop Field
The 1ClikLoop field of a list record lets you specify a routine that will be called repeatedly
(by the LClick function, described below) as long as the mouse button is held down within
the rView rectangle or its scroll bars.
Note:

The LClick function performs automatic scrolling if the mouse is dragged outside

the visible rectangle, so there’s no need to write a list click loop routine to do automatic

scrolling.

The list click loop routine has no parameters and returns a Boolean value. You could
declare a list click loop routine named MyClikLoop like this:
FUNCTION

MyClikLoop

:

BOOLEAN;

The function should return TRUE. You must put a pointer to your list click loop routine in
the IClikLoop field of the list record so that the List Manager will call your routine.

Warning: Returning FALSE from your list click loop routine tells the LClick function
that the mouse button has been released, which aborts LClick.
Assembly-language note: Your routine should set register DO to 1; returning 0
in register DO aborts LClick. For your convenience, register D5 contains the current
mouse location.

CELL SELECTION ALGORITHM
The default algorithm used by the List Manager for user selection of cells follows the
techniques described in the Macintosh User Interface Guidelines, as summarized below.
1. If neither the Shift nor the Command key is held down, a click causes all current
selections to be deselected, and the cell receiving the click to be selected. While the
mouse button is held down and the mouse moved around, only the cell under the
cursor is selected.
2. If the Shift key is held down, then as long as the mouse button is down, the List

Manager expands and shrinks a selected rectangle that’s defined by the mouse

location and the “‘anchor’’. When the mouse is first pressed, the List Manager

calculates the smallest rectangle that encloses all selected cells. If the click is above or
to the left of this rectangle (or on the top left corner), the bottom right corner of the

rectangle becomes the anchor; otherwise the top left corner becomes the anchor.
no cells are selected, the clicked cell is used as the anchor.)

IV-266 Cell Selection Algorithm

(If

The List Manager Package
3. If the Command key is held down, then while the mouse button is down, all cells that

the mouse passes over are either selected or deselected. Like FatBits in MacPaint, if
the initial cell was off, cells are turned on; otherwise they’re turned off.

The selFlags byte, initialized to 0 by the List Manager, contains flags that let you change
the way selections work. Each flag is specified by a bit, as illustrated in Figure 2.

—

1 to not highlight empty cells
1 for Shift to use sense of first cell
1 to not grow selections as rectangles

——_——

| to not extend Shift selections
1 to turn off multiple selections with click
1 for dragging without Shift key
1 if only one selection at a time

* reserved for use by the List Manager

Figure 2. Selection flags
Cod
i)

The List Manager provides a predefined constant for each flag, in which the bit
corresponding to that flag is set.
CONST

.

N

-

10nlyOne
lExtendDrag
1NoDisjoint

=
=

-128;
64;
32;

1NoExtend
1NoRect

=
=

16;
8;

{set if only one selection at a time}
{set for dragging without Shift key}
{set to turn off multiple selections with
{ click}
{set to not extend Shift selections}
{set to not expand selections as }

1UseSense

=

4;

{ rectangles}
{set for Shift

INoNilHilite

=

2;

{set

to

not

to

use

highlight

sense

empty

of

first

cells}

po)

}

cell}

Setting one or more of bits 5-7 modifies the selection algorithm in the following ways:
u If you set the 1OnlyOne bit, only one cell can be selected at a time.

a If you set the INoDisjoint bit, multiple cells can be selected, but everything is

deselected when the mouse button is pressed (even if the Shift or Command keys are
held down).

w If you set the IExtendDrag bit, clicking and dragging selects all cells in its path. (It
works best if you also set INoDisjoint, INoRect, lUseSense, and INoExtend.)

Cell Selection Algorithm IV-267

~
pou)
TS
fa]
-

Inside Macintosh

Bits 2-4 affect Shift selection. If all three are set, Shift selection works exactly like
Command selection.
u If you set the INoRect bit, Shift selections are not dragged out as rectangles, but _
instead select everything they pass over. They use the anchor point, but do not shrink
selections when you back over them.
a If you set the INoExtend bit, the click is used as the anchor point for Shift selections,
and current selections are ignored.
u If you set the 1UseSense bit, the cell that’s clicked determines whether cells are turned
off or on.
Bit 1, the INoNilHilite bit, determines whether or not empty cells can be selected. If you

set this bit, cells not containing data cannot be selected (that is, the list definition procedure

isn’t called to highlight empty cells).

Note: For the convenience of your application’s user, remember to conform to the
Macintosh User Interface Guidelines for selection.

USING THE LIST MANAGER PACKAGE
The List Manager Package is automatically read into memory from the system resource file
when one of its routines is called; it occupies a total of about 5K bytes.

Before using the List Manager, you must initialize QuickDraw, the Font Manager, the

Window Manager, the Menu Manager, and TextEdit, in that order.

Before creating a list, you must create a window in which the drawing will take place. To
create a new list, call the LNew function. When you’re done using a list, you should
dispose of its data with LDispose. Before you dispose of the list, make sure you dispose
of any data that you may have stored in the userHandle or refCon fields of the list record.
To change the size of a list’s cells, call LCelISize.
The procedure LDoDraw controls whether operations performed on cells by List Manager
routines cause drawing on the screen.
To add rows or columns to the list, call LAddRow and LAddColumn.

To delete rows or

columns, call LDelRow and LDelColumn. These routines do all necessary updating of the
screen if you’ve set drawing on with LDoDraw.
To assign a value to a cell, call the procedure LSetCell. To append data to a cell, you can
call LAddToCell; to clear the contents of a cell, call LClrCell. To get a cell’s data, call
LGetCell. The new value of a cell is displayed if you’ve set drawing on.
Warning: If you add or delete rows or columns, change the data in a cell, or call a
routine that may move or purge memory, pointers (to a cell’s data) obtained by earlier
calls to the List Manager may no longer be valid.

IV-268

Using the List Manager Package

The List Manager Package
To select or deselect a cell, call LSetSelect. To determine whether or not a cell is selected,
call LGetSelect. LGetSelect can also be used to find the next selected cell in the list.

The Window Manager NewWindow or GetNewWindow call generates an update event for
the entire window.

Call LUpdate in response to the update event, and all visible cells in the

update region will be drawn (or redrawn). When you change the value or selection of a cell
from your program, it’s redisplayed only if drawing is on. If drawing is off, you can call
the procedure LDraw to display the contents of the cell.
If a mouse-down event occurs within the list’s window, call LClick.

This routine tracks

the mouse, selecting cells and scrolling the display as necessary. The result of LClick is a
Boolean value that is TRUE if a double-click occurred.

received the double-click by calling LLastClick.

You can discover which cell

If an activate or deactivate event occurs for the window containing the list, you should call
the procedure LActivate. This routine highlights the selected cells and scroll bars as

necessary.

If the window containing the list has a size box (and you want the list to grow along with
the window), call the Window Manager routines GrowWindow and SizeWindow as usual,
then call LSize with the new size of the list. The list is automatically expanded to fill the

new area and the scroll bars are updated accordingly. The drawing mode does not affect
the updating of scroll bars in LSize.

You can find a cell with specified contents by calling LSearch. The default search routine
is the International Utilities Package function IUMagIDString, but you can pass LSearch
another search routine if you wish. Given a cell, you can call LNextCell to find the next
cell in the list.

Cd
eS

.

N

You can find the local coordinates of a given cell by calling LRect. To scroll the list, call
LScroll. You can call LAutoScroll to make sure that the first selected cell is visible. It
automatically places the first selected cell in the top left corner of the visible rectangle.
All the data in a list is stored as a single block. You can find the offset of a particular cell’s
data using LFind.

LIST MANAGER PACKAGE ROUTINES

.EQU
.EQU
.EQU

lAddToCell

.EQU

rh
PO

lActivate
lAddColumn
lAddRow

©

Assembly-language note: You can invoke each of the List Manager routines
with a macro that has the same name as the routine preceded by an underscore.
These macros expand to invoke to trap macro _Pack 0. The package determines
which routine to execute from a routine selector, an integer that’s passed to it ina
word on the stack. The routine selectors are as follows:

2

lAutoScroll
1CellSize

.EQU
.EQU

16
20

1Click

. EQU

24

1Cl1irCell

. EQU

28

List Manager Package Routines IV-269

>

a)
i}

pet)

2

fas]
mt

Inside Macintosh
1DelColumn

.EQU

32

1Dispose

. EQU

40

1DelRow

1DoDraw
1Draw
1Find
1GetCell
lGetSelect

lLastClick

-EQU

. EQU
- EQU
.EQU
-EQU
.EQU

.EQU

lNew

. EQU

68

36

1NextCell

.EQU

72

44
48
52
56
60

1Scroll
1l1Search
1SetCell
1SetSelect
1Size

-EQU
.EQU
.BQU
.EQU
. EQU

80
84
88
92
96

64

1Rect

lUpdate

. EQU

.EQU

76

100

Creating and Disposing of Lists
FUNCTION

LNew
(rView,dataBounds:
Rect;
cSize:
Point;
theProc:
INTEGER;
theWindow:
WindowPtr;
drawlIt, hasGrow,
scrollHoriz,scrollVert:
BOOLEAN)
: ListHandle;

Call LNew to create a new list. It returns a handle to the new list. The list’s grafPort is set
to theWindow’s port. If drawlt is FALSE, the list is not displayed.
RView specifies, in the local coordinates of theWindow, the rectangle in which the list will

be displayed.

(Remember that this doesn’t include space for scroll bars. If the list,

including scroll bars, is to fill the entire window, rView should be 15 points smaller in each

dimension than theWindow’s portRect.)

DataBounds is the rectangle for specifying the initial array dimensions of the list. For
example to preallocate space for a list that’s 5 cells across by 10 cells down, you should set
dataBounds to (0,0)(5,10). If you want to allocate the space for a one-column list, set
dataBounds to (0,0)(1,0) and use LAddRow.
CSize.h and cSize.v are the desired height and width of each cell in pixels; if they’re not
specified, a default cell size is calculated (as described above).
TheProc is the resource ID of your list definition procedure; for a text-only list, pass 0 and

the default list definition procedure (about 150 bytes in size) will be used. The list
definition procedure is called to initialize itself after all other list record fields have been
initialized; thus, it can use any of the values in the list record (or set particular fields, such
as the indent distance).
If hasGrow is TRUE, the scroll bars are sized so that there’s room for a size box in the

standard position. It’s up to the program to display the size box (using the Window
Manager procedure DrawGrowlIcon). If scrollHoriz is TRUE, a horizontal scroll bar is
placed immediately below rView and all horizontal scrolling functions are implemented. If
scrollVert is TRUE, a vertical scroll bar is placed immediately to the right of rView and all

vertical scrolling functions are implemented.

The visible rectangle is set to contain as many cells of cSize (or the default) as will fit into
rView. If the cells do not fit exactly into rView, the visible rectangle is rounded up to the
nearest cell. Scrolling will always allow all cells to be fully displayed. The selection flags
are set to O, and the active flag is set to TRUE.
Note:

Scrolling looks best if rView is a multiple of cSize.v in height.

IV-270 List Manager Package Routines

The List Manager Package
PROCEDURE

LDispose

(lHandle:

ListHandle) ;

Call LDispose when you are through using a list. It issues a close call to the list definition
procedure, and calls the Memory Manager procedure DisposHandle for the data handle, the
Control Manager procedure DisposeControl for both scroll bars (if they’re there), and
DisposHandle for the list record.
Note:

Calling LDispose is much faster than deleting one row at a time.

Adding and Deleting Rows and Columns
FUNCTION

LAddColumn

(count,colNum:

INTEGER;

lHandle:

ListHandle)

INTEGER;

LAddColumn inserts into the given list the number of columns specified by the count
parameter, starting at the column specified by colNum. Column numbers that are greater

than or equal to colNum are increased by count. If colNum is not within dataBounds, new
last columns are added. The number of the first added column is returned and
dataBounds.right is increased by count. All cells added are empty. If there are no cells

(because dataBounds.top = dataBounds.bottom), no cells are added, but dataBounds is still

extended. If drawing is on and the added columns (which are empty) are visible, the list
and its scroll bars are updated.
FUNCTION

LAddRow

(count,rowNum:

INTEGER;

lHandle:

ListHandle)

INTEGER;

LAddRow inserts the number of rows specified by the count parameter, starting at the row
specified by rowNum. Row numbers that are greater than or equal to rowNum are
increased by count. If rowNum is not within dataBounds, new last rows are added. The
number of the first added row is returned, and dataBounds.bottom is increased by count.

All cells added are empty.

If there are no cells (because dataBounds.left =

dataBounds.right), no cells are added, but dataBounds is still extended.

If drawing is on

PROCEDURE

ListHandle);

and the added rows (which are empty) are visible, the list and its scroll bars are updated.
LDelColumn

(count,colNum:

INTEGER;

lHandle:

LDelColumn deletes the number of columns specified by the count parameter, starting with

the column specified by colNum. Column numbers that are greater than colNum are

decreased by count. If colNum is not within dataBounds, nothing is done.
DataBounds.right is decreased by count. If drawing is on and the deleted columns were

visible, the list and its scroll bars are updated.

If count is 0, or
colNum = dataBounds.left AND count >=

dataBounds.right — dataBounds.left

all the data in the list is quickly deleted, dataBounds.right is set to dataBounds.left, and the
number of rows is left unchanged.

List Manager Package Routines [V-27]

Crd
eo

‘SS

| dad

¢ 2)
--

po)
~

pow)

TS

a)

oe

Inside Macintosh
PROCEDURE

LDelRow

(count,rowNum:

INTEGER;

lHandle:

ListHandle);

LDelRow deletes the number of rows specified by the count parameter, starting with the

row specified by rowNum.

Row numbers that are greater than rowNum are decreased by

count. If rowNum is not within dataBounds, nothing is done. DataBounds.bottom is

decreased by count.

If drawing is on and the deleted rows were visible, the list and its

scroll bars are updated.

If count is 0, or

rowNum = dataBounds.top AND count > = dataBounds.bottom — dataBounds.top
all the data in the list is quickly deleted, dataBounds.bottom is set to dataBounds.top, and
the number of columns is left unchanged.

Operations on Cells
PROCEDURE

LAddaToCell
(dataPtr:
Ptr; dataLen:
Cell;
lHandle:
ListHandle) ;

INTEGER;

theCell:

LAddToCell appends the data pointed to by dataPtr and of length dataLen to the cell
specified by theCell in IHandle. If drawing is off, you must turn drawing on and call

LDraw (or LUpdate) to display the cell’s new value.
PROCEDURE

LClrCell

(theCell:

Cell;

lHandle:

ListHandle);

LClirCell clears the contents of the specified cell (by setting the length to 0). If theCell is
not a valid cell, nothing is done. If drawing is off, you must turn drawing on and call
LDraw to display the cell’s new value (or simply call the Window Manager procedure
InvalRect).
PROCEDURE

LGetCell
(dataPtr:
Ptr; VAR dataLen:
Cell;
lHandle:
ListHandle);

INTEGER;

theCelil:

Given a cell in theCell, LGetCell copies the cell’s data to the location specified by dataPt;
dataLen is the maximum number of bytes allowed. If the data is longer than dataLen, only
dataLen bytes are copied into the location specified by dataPtr. If the data is shorter than
dataLen, dataLen is set to the true length of the cell’s data.
PROCEDURE

LSetCell

lHandle:

(dataPtr:

Ptr;

ListHandle);

dataLen:

INTEGER;

theCell:

Cell;

LSetCell places the data pointed to by dataPtr and of length dataLen into the specified cell.
It replaces any data that was already in the cell. If dataLen is 0, this is equivalent to
LCirCell. If theCell is not a valid cell, nothing is done. If drawing is off, you must turn
drawing on and call LDraw (or LUpdate) to display the cell’s new value.

[IV-272 List Manager Package Routines

The List Manager Package
PROCEDURE

LCellSize

(cSize:

Point;

lHandle:

ListHandle);

LCellSize sets the cellSize field in the list record to cSize and updates the visible rectangle

to contain cells of this size. This command should be used only before any cells have been

drawn.

FUNCTION

LGetSelect
(next:
BOOLEAN;
ListHandle)
: BOOLEAN;

VAR

theCell:

Cell;

lHandle:

If next is FALSE, LGetSelect returns TRUE if the specified cell is selected, or FALSE if

not. If next is TRUE, LGetSelect returns in c the cell coordinates of the next selected cell
in the row that is greater than or equal to theCell. If there are no more cells in the row, it

returns in theCell the cell coordinates of the next selected cell in the next row.
no more rows, FALSE is returned.
PROCEDURE

LSetSelect
(setIt:
ListHandle) ;

BOOLEAN;

theCell:

Cell;

If there are

lHandle:

If setIt is TRUE, LSetSelect selects the cell and redraws if it is visible and was previously
unselected.

If setIt is FALSE, it deselects the cell and redraws if necessary.

Mouse Location
FUNCTION

LClick
:

(pt:

BOOLEAN;

Point;

modifiers:

INTEGER;

lHandle:

ListHandle)

Cad
oS
pe

N

foes

Call LClick when there is a mouse-down event in the destination rectangle or its scroll bars.

Pt is the mouse location in local coordinates. Modifiers is the modifiers word from the
event record. LHandle is the list to be tracked. The result is TRUE if a double-click

occurred (and the two clicks took place within the same cell).

LClick keeps control until the mouse is released; each time through its inner loop, it calls

the routine whose pointer is in the IClikLoop field of the list record.

If the mouse is in the visible rectangle, cells are selected according to the state of the
modifiers and the selection flags. If the mouse was in the cells but is dragged outside the
list’s rectangle, the list is auto-scrolled. If the mouse was in a control, the control’s

definition procedure is called to track the mouse. To discover which cell was clicked in,
use the LLastClick function.
FUNCTION

LLastClick

(lHandle:

ListHandle)

:

Cell;

LLastClick returns the cell coordinates of the last cell clicked in. If no cell has been clicked

in since LNew, the value returned (for both integers) is negative.

Note: The value returned by this call is not the last cell double-clicked in, or the last cell
selected, but merely the last cell clicked in.

List Manager Package Routines IV-273

pet)

—
pe)
v2

fac]
an |

Inside Macintosh

Accessing Cells
PROCEDURE

LFind
(VAR offset,len:
ListHandle) ;

INTEGER;

theCell:

Cell;

lHandle:

Given a cell in theCell, LFind returns the offset and the length in bytes of the cell’s data. If
an invalid cell is specified, offset and len are set to—1.
more convenient to use from Pascal.
FUNCTION

LNextCell
(hNext,vNext:
lHandle:
ListHandle)

:

A similar procedure, LGetCell, is

BOOLEAN;
VAR
BOOLEAN;

theCell:

Cell;

Given a cell in theCell, LNextCell returns in theCell the next cell in the list. If both hNext

and vNext are TRUE, theCell is first advanced to the next cellin the row. Ifthere areno
more cells in the row, theCell is set to the first cell in the next row. If there arenomore
rows, FALSE is returned. If only hNext is TRUE, theCell is advanced within the current
row. If only vNext is TRUE, theCell is advanced within the current column.
returned if there are no remaining cells in the row or column.
PROCEDURE

LRect
(VAR cellRect:
ListHandle) ;

Rect;

theCell:

Cell;

FALSE is

lHandle:

LRect returns in cellRect the local (QuickDraw) coordinates of the cell specified by theCell.
If an invalid cell is specified, (0,0)(0,0) is returned in cellRect.
FUNCTION

LSearch
(dataPtr:
Ptr;
dataLen:
INTEGER;
searchProc:
VAR theCell:
Cell;
lHandle:
ListHandle)
: BOOLEAN;

Ptr;

LSearch searches for the first cell greater than or equal to theCell that contains the specified
data. Ifa cell containing matching data is found, the function result TRUE is returned, and
the cell coordinates are returned in theCell.

If searchProec is NIL, the International Utilities

Package function [UMagIDString is called to compare the specified data with the contents
of each cell. If searchProc is not NIL, the routine pointed to by searchProc is called.
Note: Your searchProc should have the same parameters as the [UMagIDString
function.
PROCEDURE

LSize

(listWidth,listHeight:

ListHand1le) ;

INTEGER;

lHandle:

You'll usually call LSize immediately after the Window Manager procedure SizeWindow.
It causes the bottom right of the list to be adjusted so that the list is the width and height

indicated by listWidth and listHeight, The contents of the list and the scroll bars are

adjusted and redrawn as necessary. The values of listWidth and listHeight do not include
the scroll bars; for a list that entirely fills the window, listWidth and listHeight should be 15
fewer pixels than the portRect if both scroll bars are present.

IV-274 List

Manager Package Routines

_
4%.

The List Manager Package

List Display
PROCEDURE

LDraw

(theCell:

Cell;

lHandle:

ListHandle);

Call LDraw after updating a cell’s data or selection status. (You can achieve the same result
by invalidating the cell’s rectangle and calling LUpdate in response to the update event.)
The List Manager makes its grafPort the current port, sets the clipping region to the cell’s
rectangle, and calls the list definition procedure to draw the cell. It restores the clipping

region and port before exiting.
PROCEDURE

LDoDraw

(drawIt:

BOOLEAN;

lHandle:

ListHandle) ;

LDoDraw sets the List Manager’s drawing mode to the state specified by drawiIt. If drawlt
is TRUE, changes made by most List Manager calls will cause some sort of drawing to

take place. If drawIt is FALSE, all cell drawing is disabled. (Two exceptions: The scroll

bars are still updated after LSize, and the scroll arrows are still highlighted if the user clicks
them.)
The recommended use of LDoDraw is to disable drawing while you’re building a list (that
is, addin g TOWS oF columns, setting or changing cell values, or setting default selections).
Once you’ve finished building the list, you should then re-enable drawing. In general,
drawing should be on while you’re in your event loop and dispatching events to the List
Manager.
PROCEDURE

LScroll

(dCols,dRows:

INTEGER;

lHandle:

ListHandle) ;

LScroll scrolls the given list by the number of columns and rows specified in dCols and
dRows, either positively (down and to the right) or negatively (up and to the left).
Scrolling i is pinned to the list’s dataBounds. If drawing is on, LScroll does all necessary
updating of the screen.
PROCEDURE

LAutoScroll

(lHandle:

ListHand1le);

For the given list, LAutoScroll scrolls the list until the first selected cell is visible. It
automatically places the first selected cell in the top left corner of the visible réctangle.
PROCEDURE

LUpdate

(theRgn:

RgnHandle;

lHandle:

ListHandle);

LUpdate should be called in response to an update event. TheRgn should be set to the
visRgn of the list’s port (for more details, see the BeginUpdate procedure in the Window
Manager chapter). It redraws any visible cells in lHandle that intersect theRgn. It also
redraws the controls, if necessary.

List Manager Package Routines IV-275

Cd
oS

c.

Hh
>

po)
=

at
itgol
as)
|

Inside Macintosh
PROCEDURE

LActivate

(act:

BOOLEAN;

lHandle:

ListHandle);

Call LActivate to activate or deactivate the list specified by [Handle (in response to an
activate event in the window containing the list). The act parameter should be set to TRUE
to activate the list, or FALSE to deactivate the list. LActivate highlights or unhighlights the
selections, and shows or hides the scroll bars (but not the size box, if any).

DEFINING YOUR OWN LISTS
The List Manager calls a list definition procedure to perform any additional list initialization
(such as the allocation of storage space for the application), to draw a cell, to invert the
highlight state of a cell, and to dispose of any data it may have allocated. The system
resource file includes a default list definition procedure for a standard text-only list; you
may, however, wish to define your own type of list with special features.
To define your own type of list, you write a list definition procedure and store it in a
resource file as a resource of type 'LDEF'. The standard list definition procedure has a

resource ID of 0; your definition procedure should have a different ID.

When you create a list, you provide the resource ID of the list definition procedure to be
used. The List Manager calls the Resource Manager to access the list definition procedure
with the given resource ID. The Resource Manager reads the list definition procedure into
memory and returns a handle to it. The List Manager then stores this handle in the
listDefProc field of the list record.
The List Definition Procedure
The list definition procedure is usually written in assembly language, but may be written in
Pascal.
Assembly-language note:

The procedure’s entry point must be at the beginning.

You may choose any name you wish for your list definition procedure.
would declare one named MyList:
PROCEDURE

MyList

1Cell:

(lMessage:
Cell;

ListHandle) ;

INTEGER;

l1DataOffset,

1Select:

1DataLen:

BOOLEAN;

INTEGER;

Here’s how you
l1Rect:

The IMessage parameter identifies the operation to be performed. It has one of the
following values:
CONST

lInitMsg

=

0;

{do

lHiliteMsg
1CloseMsg

=
=

2;
3;

{invert cell's highlight state}
{take any additional disposal action}

1DrawMsg

=

1;

IV-276 Defining Your Own Lists

any

{draw

additional

the

cell

}

list

Rect;

lHandle:

initialization}

The List Manager Package

LSelect is used for both the drawing and highlighting operations; it’s TRUE if the cell
should be selected.
LRect indicates the rectangle in which a cell should be drawn. LDataOffset is the offset
into the cell data of the cell to be drawn or highlighted; [DataLen is the length in bytes of
that cell’s data. LHandle is the handle to the list record.
The routines that perform these operations are described below.

Note: “Routine” here doesn’t necessarily mean a procedure or function. While it’s
a good idea to set these up as subfunctions within the list definition procedure,

you’re not required to do so.
The Initialize Routine

The list definition procedure is called by the LNew function with an initMsg message after
all list initialization has been completed. Since all default settings have been stored in the
list record, this routine is a good place to change any of these settings. This routine can
also be used to allocate any private storage needed by the list definition procedure.
The Draw Routine
The list definition procedure receives a |IDrawMsg message when a cell needs to be drawn.
The ISelect parameter is TRUE if the given cell should be selected.

Cd
—
C

LRect is the rectangle in which the cell should be drawn. The draw routine sets the
clipping region of the list’s window to this rectangle.
LDataOffset is the offset into the cell data of the cell to be drawn; IDataLen is the length of

that cell’s data in bytes.

The Highlight Routine
The definition procedure receives a lHiliteMsg message when a cell’s data is visible and its

highlight state needs to be inverted (from selected to deselected or vice versa). This routine
is provided for the extra speed usually gained by using an invert operation instead of a
combination of the draw and highlight operations.
The parameters for this routine are identical to those for the IDrawMsg routine. If you want
(for instance, if highlighting is more complicated than mere inversion), you can simply call
your |DrawMsg routine when you get a IHiliteMsg message.

The Close Routine
The definition procedure receives a l1CloseMsg message in response to a LDispose call. If
any private storage was allocated by the definition procedure, this routine should dispose
of it.
Defining Your Own Lists [V-277

Mz)

eo

=)
|
&
v2

fas)
|

Inside Macintosh

SUMMARY OF THE LIST MANAGER PACKAGE
Constants
CONST

{ Masks

for

automatic

1DoVAutoscroll

=

2

1DoHAutoscroll

=

1

{ Masks

for

scrolling
{set

{set

to

to

}

allow

automatic

allow

vertical

automatic

horizontal

scrolling}

scrolling}

selection

flags

10nlyOne
lExtendDrag
1INoDisjoint

=
=
=

-128;
64;
32;

1NoExtend

=

16;

{set if only one selection at a time}
{set for dragging without Shift key}
{set to turn off multiple selections with
{ click}
{set to not extend Shift selections}

lUseSense
=
INoNilHilite =

4;
2;

{set
{set

{ Messages

list

1NoRect

=

to

linitMsg
O;
lDrawMsg
= 1;
lHiliteMsg=2;
1CloseMsg = 3;

8;

{set

}

to

not

grow

selections

for Shift to use
to not highlight

definition

procedure

sense
empty

as

rectangles}

of first
cells}

}

{initialize list,
set defaults,
allocate space}
{draw the indicated cell data}
{invert
(select/deselect)
the state of a cell}
{dispose of list and any associated data}

Data Types
TYPE

Cell

=

Point;

DataArray
DataPtr
DataHandle

ListRec

=
=
=

PACKED ARRAY
“DataArray;
“DataPtr;

[0..32000]

OF

CHAR;

=

RECORD

rView:
port:
indent:
cellSize:
visible:
vScroll:
hScroll:

selFlags:
lActive:
1Reserved:
listFlags:
clikTime:
clikLoc:
mouseLoc:
1ClikLoop:

cell}

Rect;
{list's display rectangle}
GrafPtr;
{list's grafPort}
Point;
{indent distance}
Point;
{cell size}
Rect;
{boundary of visible cells}
ControlHandle;
{vertical scroll bar}

ControlHandle;

SignedByte;
BOOLEAN ;
SignedByte;
SignedByte;
LONGINT;
Point;
Point;
Ptr;

IV-278 Summary of the List Manager Package

{horizontal

scroll

bar}

{selection flags}
{TRUE if active}
{reserved}
{automatic scrolling flags}
{time of last click}
{position of last click}
{current mouse location}
{routine for LClick}

}

The List Manager Package
lastClick:
refCon:
listDefProc:
userHandle:
dataBounds:
cells:
maxIndex:
cellArray:

Cell;
LONGINT;
Handle;
Handle;
Rect;
DataHandle;
INTEGER;
ARRAY
[1..1]

{last cell clicked}
{list's reference value}
{list definition procedure}
{additional storage}
{boundary of cells allocated}
{cell data}
{used internally}
OF INTEGER
{offsets to data}

END;

ListPtr
ListHandle

=
=

“ListRec;
“ListPtr;

Routines
Creating and Disposing of Lists
FUNCTION

LNew

PROCEDURE

LDispose

(rView,dataBounds:
Rect;
cSize:
INTEGER;
theWindow:
WindowPtr;
hasGrow, scrollHoriz,scrollVert:

ListHandle;
(lHandle: ListHandle) ;

Point;
theProc:
drawIit,
BOOLEAN)

Adding and Deleting Rows and Columns
FUNCTION

LAddColumn

(count,colNum:

INTEGER;

lHandle:

ListHandle)

FUNCTION

LAddRow

(count,

rowNum:

INTEGER;

lHandle:

ListHandle)

(count,colNum:
(count, rowNum:

INTEGER;
INTEGER;

lHandle:
lHandle:

ListHandle) ;
ListHandle) ;

INTEGER;

INTEGER;

PROCEDURE
PROCEDURE

LDelColumn
LDelRow

Operations on Cells
PROCEDURE

LAddToCell

PROCEDURE
PROCEDURE

LClrCell
LGetCell

PROCEDURE

LSetCell

PROCEDURE
FUNCTION

LCellSize
LGetSelect

PROCEDURE

LSetSelect

(dataPtr:
Ptr;
dataLen:
INTEGER;
theCell:
Cell;
lHandle:
ListHandle);
(theCell:
Cell;
lHandle:
ListHandle);
(dataPtr:
Ptr;
VAR dataLen:
INTEGER;
theCell:
Cell;
lHandle:
ListHandle) ;
(dataPtr:
Ptr;
dataLen:
INTEGER;
theCell:
Cell;
lHandle:
ListHandle) ;
(cSize:
Point;
lHandle:
ListHandle
);
(next:
BOOLEAN;
VAR theCell:
Cell;
lHandle:
ListHandle)
: BOOLEAN;
(setIt:
BOOLEAN;
theCell:
Cell;
lHandle:
ListHandle);

Mouse Location
FUNCTION
FUNCTION

LClick

(pt:

LLastClick

ListHandle)
: BOOLEAN;
(lHandle:
ListHandle)
:

Point;

modifiers:

INTEGER;

lHandle:

Cell;

Summary of the List Manager Package [V-279

ee)
=

c.
7

=

=
7
a

Inside Macintosh

Accessing Cells
PROCEDURE

LFind

(VAR

offset,len:

INTEGER;

FUNCTION

LNextCell

PROCEDURE

LRect

(hNext, vNext:
BOOLEAN;
VAR theCell:
ListHandle)
BOOLEAN
(VAR cellRect:
Rect;
theCell:
Cell;

FUNCTION

LSearch

PROCEDURE

LSize

ListHandle) ;

ListHandle)

;

(listWidth,

listHeight:

theCell:

Cell;

lHandle:

Cell;

lHandle:

lHandle:

:

(dataPtr:
Ptr;
dataLen:
INTEGER;
searchProc:
Ptr;
VAR theCell:
Cell;
lHandle:
ListHandle)
: BOOLEAN;

INTEGER;

lHandle:

ListHandle) ;

List Display
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE

(theCell:
Cell;
lHandle:
ListHandle) ;
(drawIt:
BOOLEAN;
lHandle:
ListHandle) ;
(dCols,dRows:
INTEGER;
lHandle:
ListHandle) ;
(lHandle:
ListHandle) ;
ListHandle) ;
(theRgn: RgnHandle;
lHandle:
ListHandle);
(act:
BOOLEAN;
lHandle:

LDraw
LDoDraw

LScroll
LAutoScroll

LUpdate
LActivate

List Definition Procedure
PROCEDURE

MyListDef

(l1Message:

INTEGER;
1Select:
BOOLEAN;
lRect:
1Cell:
Cell;
l1DataOffset,1DataLen:
INTEGER;
lHandle:
ListHandle);

Rect;

Assembly-Language Information
Constants
;

Automatic

scrolling

LDoVAutoscroll
1DoHAutoscroll

;

Selection

flags

. EQU
. EQU

1
0)

to
to

allow
allow

automatic
automatic

vertical scrolling
horizontal scrolling

flags

10nlyOne
1ExtendDrag
1INoDisjoint

-EQU
-EQU
-EQU

7
6
5

1NoExtend
1lNoRect

-EQU
-EQU

-EQU

4
3

2

INoNilHilite

-EQU

1

1UseSense

;set
;set

;set if only one selection at a time
;set for dragging without Shift key
;set to turn off multiple selections
; click
;set
;set

;set
;set

to
to

not
not

extend Shift
selections
grow selections
as rectangles

for Shift to use
to not highlight

IV-280 Summary of the List Manager Package

with

sense
empty

of first
cells

cell

The List Manager Package
; Messages
1InitMsg
lDrawMsg_
1HiliteMsg
1CloseMsg
;
;

;

Routine
(Note:

that

1LAddColumn
1lAddRow —
lAddToCell
lAutoScroll

1CellSize

1Click
1cirCell
1DelColumn
1DelRow
1DoDraw
lDraw
1Find
1GetCell
1GetSelect
lLastClick
lNew
lNextCell
lRect
1Scroll
1Search
1SetCell
1SetSelect
1Size

1lUpdate

list
-EQU
-EQU
-EQU
-EQU

definition
0
1
2
3

procedure

sinitialize list,
set defaults,
allocate
;draw the indicated cell data
s;invert
(select/deselect)
the state of a
;dispose of list and any associated data

selectors

You can invoke each of
has the same name as the

lActivate

1Dispose

to

.EQU
.EQU
.EQU
.EQU
.EQU
.EQU
.EQU
.EQU

0
4
8
12
16
20
24
28

.EQU
.EQU
.EQU
.EQU
.EQU
_EQU
.EQU
-EQU

36
40
44
48
52
56
60
64

. EQU

.EQU

we

80
84

z
s

.EQU

88

-EQU

-EQU

routines with a macro
by an underscore.)

68

72
76

.EQU

cell

32

.EQU
.EQU

- EQU
- EQU

the List Manager
routine preceded

space

—
a

5

92

ow"

96

7

100

List Record Data Structure
rView
port

indent

cellSize
visible
vScroll

hScroll

selFlags

lActive

clikTime
clikLoc
mouseLoc

IClikLoop

List’s display. rectangle (rectangle; 8 bytes)
List’s grafPort (portRec bytes)
Indent distance (point; long)
Cell size (point; long)

Boundary of visible cells (rectangle; 8 bytes)

Handle to vertical scroll bar
Handle to horizontal scroll bar
Selection flags (byte)
Nonzero if active (byte)
Time of last click (long)
Position of last click (point; long)
Current mouse location (point; long)

Pointer to routine to be called during LClick

Summary of the List Manager Package IV-281

Inside Macintosh

lastClick

Last cell clicked (point; long)

listDefHandle
userHandle
dataBounds
cells

Handle to list definition procedure
Handle to uséf storage
Boundary of cells allocated (rectangle; 8 bytes)
Handle to cell data

refCon

maxIndex
cellArray

Reference value (long)

Used internally (word)
Offsets to cells

Trap Macro Name
_PackO

(N ote: You can invoke each of the List Manager routines with a macro that has the same
nartié ds the routine preceded by an underscore.)

IV-282 Summary of the List Manager Package

31

THE SCSI MANAGER

285
285

About This Chapter
About the SCSI Manager

286

286
288

289

292
294

Using the SCSI Manager

Describing the Operation to be Performed
Example

SCSI Manager Routines

Writing a Driver for an SCSI Block Device
Summary of the SCSI Manager

oS)
pom
'F 9)

‘°)

N

—

f

~

fi
itke
fae)
on |

Contents IV-283

Inside Macintosh

IV-284

The SCSI Manager

ABOUT THIS CHAPTER
This chapter describes the SCSI Manager, the part of the Operating System that controls the
exchange of information between a Macintosh and peripheral devices connected through the
Small Computer Standard Interface (SCSI).
The SCSI Manager is the Macintosh implementation of an SCSI bus and its attached
devices. This chapter describes the routines and data structures you’Il use to communicate
between a Macintosh and peripherals over an SCSI bus. It also explains how to write an
SCSI device driver that’s capable of performing the Macintosh system startup.
This chapter provides information needed to connect a device to the Macintosh via an SCSI

bus; it is not intended as a guide to designing an SCSI device. A familiarity with the

American National Standard Committee (ANSC) documentation for SCSI, specifically the
ANSC X3T9.2/82-2 draft proposal, is assumed; the information provided in the draft
proposal will not be repeated in this chapter.
You should also already be familiar with:
= the use of devices and device drivers, as described in the Device Manager chapter

m sectors and file tags, as described in the Disk Driver chapter
m any documentation provided with the particular SCSI device you want to connect to
the Macintosh

ABOUT THE SCSI MANAGER
The Small Computer Standard Interface (SCSI) is a specification of mechanical,

electrical, and functional standards for connecting small computers with intelligent
peripherals such as hard disks, printers, and optical disks. The SCSI Manager is the part
of the Operating System that provides routines and data structures for communicating
between a Macintosh and peripheral devices according to this industry-standard interface.
Up to eight devices can be connected, in a daisy-chain configuration, to an SCSI bus.
When two SCSI devices communicate with each other, one acts as the initiator and the

other as the target. The initiator asks the target to perform a certain operation, such as
reading a block of data. An SCSI device typically has a fixed role as an initiator or target;
for instance, the Macintosh acts as initiator to a variety of peripherals acting as targets.
There may also be intelligent peripherals capable of acting as initiators. Multiple initiators
(as well as multiple targets) are allowed on an SCSI bus, but only one Macintosh can be
connected to an SCSI bus at a time.
Each device on the bus has a unique ID, an integer from 0 to 7. The Macintosh always has

an ID of 7; peripheral devices should choose another number.

At any given time, the Apple SCSI bus is in one of eight phases. When no SCSI device is
actively using the bus, the bus is in the bus free phase.

About the SCSI Manager IV-285

Cad
pm

MN

(@)

7 a)
—_
poh)
|
po)
it5]
fas)

Law |

Inside Macintosh

Since multiple initiators are possible, an initiator must first gain control of the bus; this

process is called the arbitration phase.

Note: If more than one initiator arbitrates for use of the bus at the same time, the
initiator with the higher ID gains control first. Once an initiator (regardless of ID)
gains control of the bus, no other device can interrupt that session.
Once the initiator has gained control of the bus, it selects the target device that will be asked
to perform a certain operation; this phase, known as the selection phase, includes an
acknowledgement from the target that it has been selected. In the event that the target
suspends (or disconnects) the communication, an optional phase, known as the
reselection phase, lets the target reconnect to the initiator.

In the command phase, the initiator tells the target what operation to perform. The data

phase follows; this is when the actual transfer of data between initiator and target takes
place. When the operation is completed, the target sends two completion bytes. The first
byte contains status information and the second contains a message; they constitute the
status phase and message phase respectively.

A typical communication might involve a Macintosh requesting a block of data to be read
from a hard disk connected via an SCSI bus. The Macintosh waits for a bus free phase to
occur and then arbitrates for use of the bus. It selects the hard disk as target and sends the
command for the read operation. The hard disk transfers the requested data back to the
Macintosh, completing the session by sending the status and message bytes.

USING THE SCSI MANAGER
The SCSI Manager is automatically initialized when the system starts up. To gain control

of the SCSI bus, call SCSIGet. To select a target device to perform an operation (such as

reading or writing data), call SCSISelect.
what operation to perform.

The SCSICmd function tells the target device

To transfer data from the target device to the Macintosh, you can call SCSIRead;
SCSIWrite transfers data from the Macintosh to the target device. The read and write
operations can be performed without polling and waiting for the /REQ line on each data
byte by calling SCSIRBlind and SCSIWBlind, respectively. All four read/write functions
require a transfer instruction block telling the SCSI Manager what to do with the data bytes
transferred during the data phase.
The SCSIComplete function gives the current command a specified number of ticks to
complete and then returns the status and message bytes.
You can obtain a bit map of the SCSI control and status bits by calling SCSIStat. To reset
the SCSI bus (typically when a device has left it in a suspended phase), call SCSIReset.

Describing the Operation to be Performed
You tell the SCSI Manager what operation to perform by passing a pointer to a command
descriptor block; the SCSI command structure is outlined in the ANSC document
X3T9.2/82-2.
IV-286

Using the SCSI Manager

The SCSI Manager

When the command to be performed involves a transfer of data (such as a read or write

operation), you also need to pass a pointer to a transfer instruction block, which tells
the SCSI Manager what to do with the data bytes transferred during the data phase. A
transfer instruction block contains a pseudo-program consisting of a variable number of
instructions; it’s similar to a subroutine except that the instructions are provided and
interpreted by the SCSI Manager itself. The instructions are of a fixed size and have the
following structure:
TYPE

SCSIInstr

=

RECORD

scOpcode:

scParaml:

scParam2:

INTEGER;

{operation

LONGINT;

{first

LONGINT

{second

code}

parameter}

parameter}

END;

Eight instructions are available; their operation codes are specified with the following

predefined constants:
CONST

scInc

=

scAdd
scMove
scLoop

=
=
=

scComp

=

SCNoInc

scNOp
scStop

1;

{SCINC

3;
4;
5;

{SCADD
instruction}
{SCMOVE
instruction}
{SCLOOP
instruction}

=

2;

=
=

6;
7;
8;

{SCNOINC

instruction}

instruction}

{SCNOP instruction}
{SCSTOP instruction}
{SCCOMP

instruction}

A description of the instructions is given below.

opcode

= sciInc

paraml

= buffer

param2 = count

The SCINC instruction moves count data bytes to or from buffer, incrementing buffer by
count when done.
opcode

=

scNolInc

The SCNOINC
unmodified.
opcode

paraml

= buffer

param2

= count

instruction moves count data bytes to or from buffer, leaving buffer

= scAdd

= scMove

Fa)

o)
N
~—
&

~~

paraml

= addr

param2

= value

The SCADD instruction adds the given value to the address in addr. (The addition is
performed as an MC68000 long operation.)
opcode

Cd
peach

paraml

= addrl

param2

= addr2

The SCMOVE instruction moves the value pointed at by addr1 to the location pointed to by
addr2. (The move is an MC68000 long operation.)

Using the SCSI Manager IV-287

&
TS
fae)
ian

|

Inside Macintosh
opcode

= scLoop

paraml

= relAddr

param2

= count

The SCLOOP instruction decrements count by 1. If the result is greater than 0, pseudoprogram execution resumes at the current address+relAddr. If the result is 0, pseudoprogram execution resumes at the next instruction. RelAddr should be a signed multiple of
the instruction size (10 bytes). For example, to loop to the immediately preceding
instruction, the relAddr field would contain -10.

would contain 30.
opcode

= scNOp

paraml

= NIL

To loop forward by three instructions, it

param2

= NIL

param2

= NIL

The SCNOP instruction does nothing.
opcode

= scStop

paraml

= NIL

The SCSTOP instruction terminates the pseudo-program execution, returning to the calling
SCSI Manager routine.
opcode

= scComp

paraml

= addr

param2

= count

The SCCOMP instruction is used only with a read command. Beginning at addr, it
compares incoming data bytes with memory, incrementing addr by count when done. If
the bytes do not compare equally, an error is returned to the read command.

Example
This example gives a transfer instruction block for a transfer of six

from or to address $67B50.
SCINC
SCLOOP
SCSTOP

IV-288

$67B50
-10

512
6

Using the SCSI Manager

512-byte blocks of data

The SCSI Manager

SCSI MANAGER ROUTINES
Assembly-language note: Unlike most other Operating System routines, the SCSI
Manager routines are stack-based. You can invoke each of the SCSI routines with a
macro that has the same name as the routine preceded by an underscore. These macros,
however, aren’t trap macros themselves; instead they expand to invoke the trap macro
_SCSIDispatch. The SCSI Manager determines which routine to execute from the

routine selector, an integer that’s passed to it in a word on the stack. The routine
selectors are as follows:
scsiReset
scsiGet
scsiSelect

.EQU
.EQU
. EQU

0
1
2

scsiCmd

. EQU

3

scsiRead
scsiWrite

. EQU
. EQU

5
6

scsiRBlind

.EQU

8

scsiwWBlind
scsiStat

-EQU
. EQU

9
10

scsiComplete

.EQU

4

Most of the SCSI Manager routines return an integer result code of type OSErr. Each
routine lists all of the applicable result codes, along with a short description of what the
result code means. Lengthier explanations of all the result codes can be found in the

summary at the end of this chapter.

|

Warning: The error codes returned by SCSI Manager routines typically indicate
only that a given operation failed. To determine the actual cause of the failure, you
need to send another SCSI command asking the device what went wrong.

2
DN

FUNCTION

SCSIReset

O

: OSErr;

Z
<

SCSIReset resets the SCSI bus.
Result codes

:

FUNCTION

= noErr

commErr

SCSIGet

:

=

4gon]

No error

Breakdown in SCSI protocols

OSErr;

SCSIGet arbitrates for use of the SCSI bus.

Result codes

= noErr
commErr

No error
Breakdown in SCSI protocols

SCSI Manager Routines IV-289

<

Inside Macintosh
FUNCTION

SCSISelect

(targetID:

INTEGER)

:

OSErr;

SCS Select selects the device whose ID is in targetID.
Result codes

FUNCTION

noErr

commeErr

SCSICmd

(buffer:

No error

Breakdown in SCSI protocols

Ptr;

count:

INTEGER)

:

OSErr;

SCSICmd sends the command pointed to by buffer to the selected target device.
of the command in bytes is specified in count.

Result codes

FUNCTION

= noErr
commeErr
phaseErr

SCSIRead

(tibPtr:

The size

No error
Breakdown in SCSI protocols
Phase error
Ptr)

:

OSErr;

SCSIRead transfers data from the target to the initiator, as specified in the transfer
instruction block pointed to by tibPtr.
Result codes

= noErr
badParmsErr
commeErr
compareErr
phaseErr

FUNCTION

SCSIRBlind

No error
Unrecognized instruction in transfer instruction block
Breakdown in SCSI protocols
§ Data comparison error (with scComp command in
transfer instruction block)
Phase error

(tibPtr:

Ptr)

:

OSErr;

SCSIRBlind is functionally identical to SCSIRead, but does not poll and wait for the /REQ

line on each data byte. Rather, the /REQ line is polled only for the first byte transferred by
each SCINC, SCNOINC, or SCCOMP instruction. For in..tance, given the following

transfer instruction block
SCINC
SCLOOP
SCSTOP

$67B50
-10

512
6

SCSIRBlind polls and waits only for the first byte of each 512-byte block transferred.
Resultcodes

noErr
badParmsErr
commErr

compareErr

phaseErr

IV-290 SCSI Manager Routines

No error
Unrecognized instruction
Breakdown in SCSI protocols

§ Data comparison error
Phase error

The SCSI Manager
FUNCTION

SCSIWrite

(tibPtr:

Ptr)

:

OSErr;

SCSIWrite transfers data from the initiator to the target, as specified in the command

descriptor block pointed to by tibPtr.
Result codes

FUNCTION

-noErr
badParmsErr
commeErr
phaseErr

SCSIWBlind

No error
Unrecognized instruction
Breakdown in SCSI protocols
Phase error

(tibPtr:

Ptr)

:

OSErr;

SCSIWBlind is functionally identical to SCSIWrite, but does not poll and wait for the
/REQ line on each data byte. As with SCSIRBlind, SCSIWBlind polls the /REQ line only
for the first byte transferred by each SCINC, SCNOINC, or SCCOMP instruction.
Resultcodes

noErr
badParmsErr
commeErr
phaseErr

FUNCTION SCSIComplete
OSErr;

No error
Unrecognized instruction
Breakdown in SCSI protocols
Phase error

(VAR

stat,message:

INTEGER;

wait:

LONGINT)

SCSIComplete gives the current command wait number of ticks to complete; the two
completion bytes are returned in stat and message.
Resultcodes

FUNCTION

noErr

No

phaseErr

Phase error

commErr

SCSIStat

error

Breakdown in SCSI protocols

: INTEGER;

This function returns a bit map of SCSI control and status bits; these bits are shown in
Figure 1. See the NCR 5380 SCSI chip documentation for a description of these signals.
(Bits 0-9 are complements of the SCSI bus standard signals.)
15

END
|DMA|PTY INT _|PHS|BSY
DMA|REQ|ERR|REQ|MAT|
ERR

ATN

8

7

ACK|

RST

0
|BSY|REQ}MSG|

C/D | 170 | SEL}

DBP

Figure 1. SCSI Control and Status Bits
Resultcodes

noErr
commEtrr
phaseErr

No error
Breakdown in SCSI protocols
Phase error

SCSI Manager Routines IV-29]

am
yn
OQ
m
<
5

i)

Inside Macintosh

WRITING A DRIVER FOR AN SCSI BLOCK DEVICE
Device drivers are usually written in assembly language. The structure of a device driver is
described in the Device Manager chapter. This section presents additional information to
enable SCSI block devices to perform the Macintosh system startup.
For each attached SCSI device, the ROM attempts to read in its driver prior to system
startup. In order to be loaded, the device must place two data structures in the first two
physical blocks. A driver descriptor map must be put at the start of physical block OQ; it
identifies the various device drivers available for loading (see Figure 2). The drivers can
then be located anywhere else on the device and can be as large as necessary.
sbSig (word)
sbBIkSize (word)

always $4552

sbDevID (word)

block size of device
number of blocks on device
device type
device ID

sbData (long word)

not used

sbDrvrCount (word)

driver descriptor count
first block of driver
driver size in blocks
system type (1 for Macintosh

sbBlkCount (long word)
sbDevType (word)

first

ddBlock (long word)

driver
descriptor

ddSize (word)
ddType (word)

Plus)

Figure 2. Driver Descriptor Map
A second data structure, the device partition map, must be put at the start of physical
block 1; it describes the allocation of blocks on the device for different partitions and/or
operating systems (see Figure 3).

first
partition

pdSig (word)

always $5453

pdStart (long word)

starting block address

pdSize (long word)

number

pDdFSID (long word)

file system ID ("TFS1" for
Macintosh Plus)

of blocks

Figure 3. Device Partition Map
Since there’s no field in the device partition map for specifying the number of partitions,
you need to signal the end of the map with a partition whose pdStart, pdSize, and pdFSID

fields are set to 0.

[IV-292 Writing a Driver for an SCSI Block Device

The SCSI Manager
The system startup procedure takes the following steps:
1. It attempts to select the first target device on the bus by its ID, beginning with the
device, if any, having an ID of 6.

2. It reads the first 256 bytes of physical block 0, checking for the signature indicating a
valid driver descriptor map ($4552). It then reads the device partition map from
physical block 1 and checks for the proper signature ($5453).
3. It searches the driver descriptor map for a driver for the Macintosh.
4. It reads the driver from the indicated physical blocks into the system heap, using

standard SCSI read commands.

It checks for a proper driver signature.

5. It calls the driver to install itself, and passes a pointer to the device partition map for
examination by the driver.
6. It performs steps 1 through 5 for all other SCSI devices on the bus.
Note: During system startup, the SCSI Manager may call SCSIReset after your
driver has been loaded.
Since the driver is called to install itself, it must contain code to set up its own entry in the
unit table and to call its own Open routine. An example of how to do this can be obtained
from
Developer Technical Support.
Mail Stop 3-T
Apple Computer, Inc.
20525 Mariani Avenue
Cupertino, CA 95014

os)
a"
Cp)

?)

Fp)

|

pole]
=
job)
v2
fae)
=

Writing a Driver for an SCSI Block Device IV-293

Inside Macintosh

SUMMARY OF THE SCSI MANAGER
Constants
{

Transfer

instruction

operation

codes

sciInc
scNoInc
scAdd
scMove

=
=
=
=

1;
2;
3;
4;

{SCINC
instruction}
{SCNOINC
instruction}
{SCADD
instruction}
{SCMOVE
instruction}

ScNop

=

6;

{SCNOP

scStop

=

scComp

SCSI

{SCLOOP

7;

instruction}
instruction}

{SCCOMP

Manager

result

=

scCompareErr

scPhaseErr

=

5;

instruction}

codes

}

{unrecognized

{ instruction
{breakdown in

2;

I

scCommErr

fo»)

scBadParmsErr

}

instruction}

{SCSTOP

8;

ll

{

=

5;

“=e

=

“=e

scLoop

>

CONST

instruction

in

block}
SCSI protocols:

transfer

usually

SCSIInstr

=

{phase error:
{ agreement as
{ transfer}

RECORD

scOpcode:

scParaml:
scParam2:

target and
to type of

INTEGER;

{operation

LONGINT;
LONGINT

code}

{first parameter}
{second parameter}

Routines

SCSIReset

:

OSErr;

FUNCTION
FUNCTION
FUNCTION

SCSIGet
:
SCSISelect
SCSICmd

FUNCTION

SCSIRead

(tibPtr:

FUNCTION
FUNCTION
FUNCTION
FUNCTION

SCSIRBlind
SCSIWrite
SCSIWBlind
SCSIComplete

(tibPtr:
Ptr)
: OSErr;
(tibPtr:
Ptr )
: OSErr;
(tibPtr:
Ptr)
: OSErr;
(VAR stat,message:
INTEGER;
OSErr;

FUNCTION

SCSIStat

INTEGER;

IV-294

:

OSErr;
(targetID:
INTEGER)
(buffer:
Ptr;
count:
Ptr)

Summary of the SCSI Manager

:

:

OSErr;
INTEGER)

}
}

initiator not in
information to }

END;

FUNCTION

no

{ device
connected or bus not terminated}
{data comparison
error during read
(with
{ SCCOMP
instruction
in transfer
}
{ instruction block) }

Data Types
TYPE

}

:

OSErr;

OSErr;

wait:

LONGINT)

}

The SCSI Manager

Assembly-Language Information
Constants
Transfer

sciInc
scNoInc
scAdd
scMove
scLoop
SCNOp
scStop
scComp

;
;
;

instruction

- BQU
.EQU
. EQU
- EQU
.EQU
- EQU
.EQU
.EQU

PDP WNP
SO INU

;

. EQU
. EQU

scsicCmd
scsiComplete
scsiRead
scsiwWrite
scSsiRBlind
scsiWBlind
scsiStat

.EQU
.EQU
.EQU
.EQU
.EQU
. EQU
.EQU

scsiSelect

SCSI

Manager

codes

;SCINC
instruction
;SCNOINC
instruction

;SCADD instruction
;SCMOVE instruction
;SCLOOP instruction
;SCNOP

;SCSTOP
;SCCOMP

instruction

instruction
instruction

Routine selectors
(Note:
You can invoke each of
that has the same name as the

scsiReset
scsiGet

;

operation

.EQU

the SCSI Manager
routine preceded

routines with a macro
by an underscore.)

0
1

2

3
4
5
6
8
9
10

result

codes

scBadParmsErr

.EQU

4

scCommErr

. EQU

2

scCompareErr

. EQU

6

scPhaseErr

.EQU

5

;unrecognized
; instruction

;breakdown

instruction
block

in

SCSI

in

transfer

protocols:

usually

no

; device connected or bus not terminated
;data comparison error during read (with
; scComp command in transfer instruction
;

block)

;phase

error:

; agreement
;

transfer

as

target

to

type

and

of

initiator

not

information

to

in

Trap Macro Name
_SCSIDispatch
(Note: You can invoke each of the SCSI Manager routines with a macro that has the same

name as the routine preceded by an underscore.)

Summary of the SCSI Manager [V-295

wo
A
D

z

S

i

”
c

Inside Macintosh

IV-296

32

THE TIME MANAGER

299

About This Chapter

300

Time Manager Routines

299
299
301

About the Time Manager
Using the Time Manager
Summary of the Time Manager

Ue

bho

=
=

fae)

po
=
peu)
7

cae)
=

Contents [V-297

Inside Macintosh

IV-298

The Time Manager

ABOUT THIS CHAPTER
This chapter describes the Time Manager, the part of the Operating System that lets you
schedule a routine to be executed after a given number of milliseconds have elapsed.

ABOUT THE TIME MANAGER
The Time Manager provides the user with an asynchronous “wakeup” service with 1millisecond accuracy; it can have any number of outstanding wakeup requests. The Time
Manager is independent of clock speed or interrupts, and should be used in place of cyclecounting timing loops.
An application can add any number of tasks for the Time Manager to schedule. These tasks
can perform any desired action so long as they don’t rhtke any calls to the Memory -

Manager, directly or indirectly, and don’t depend on Handles to unlocked blocks being

valid. They must preserve all registers other than AO-A3 and DO-D3. If they use
application globals, they must also ensure that register A5 contains the address of the
boundary between the application globals and the application parameters; for details, see

SetUpA5 and RestoreAS5 in chapter 13.
Note:

To perform periodic actions that do allocate aiid release memory, you can use

the Désk Manager procedure SystemTask.

Information describing each Time Manager task is contained in the Time Manager queue;
you need only supply a pointer to the routine to be executed. The Time Manager queue is a

standard Macintosh queue, as described in the Operating System Utilities chapter. Each

entry in the Time Manager queue has the following structure:
TYPE

TMTask

=

RECORD
qLink:

qType:

tmAddr:

tmCount:

QElemPtr;

{next

queue

INTEGER;

{queue

INTEGER

{reserved}

ProcPtr;

type}

{pointer

to

entry}

routine}

END;

)

bo

USING THE TIME MANAGER

=
=

The Time Manager is automatically initialized when the system starts up. Since the “sleep”
time for a given task can be as small as 1 millisecond, you need to install a queue element in
the Time Manager queue before actually making the wakeup request; to do this, call
InsTime. To make the actual wakeup request, call PrimeTime. When you’re done, call
RmvTimie to remove the element from the queue.

Using the Time Manager IV-299

ee)

po
5
rs
ge

fae)
=

Inside Macintosh

TIME MANAGER ROUTINES
PROCEDURE

InsTime

(tmTaskPtr:

QElemPtr);

Trap macro

_InsTime

On entry

AO: tmTaskPtr (pointer)

On exit

DO: result code (word)

InsTime adds the task specified by tmTaskPtr to the Time Manager queue. InsTime returns
one of the result codes listed below.
Result codes

noErr

PROCEDURE PrimeTime

No error

(tmTaskPtr, count:

Trap macro

_PrimeTime

On entry
|
On exit

AO: tmTaskPtr (pointer)
DO: count (long word)
DO: result code ( word)

LONGINT);

PrimeTime schedules the routine specifiedby tmTaskPtr to be executed after count

milliseconds have elapsed. The queue element must already be inserted into the queue by a

call to InsTime before making the PrimeTime call. The PrimeTime routine returns
immediately, and the specified routine will be executed after count milliseconds have
elapsed.

Result codes
PROCEDURE

noErr

RmvTime

No error
(tmTaskPtr:

QElemPtr) ;

Trap macro

_RmvTime

On entry

AO: tmTaskPtr (pointer)

On exit

DO: result code (word)

RmvTime removes the task specified by tmTaskPtr from the Time Manager queue.
RmvTime returns one of the result codes listed below.
Result codes

noErr

IV-300 Time Manager Routines

No

error

The Time Manager

SUMMARY OF THE TIME MANAGER
Data Types
TYPE

TMTask

=

RECORD

qLink:
qType:
tmAddr:
tmCount :

END ;

QElemPtr;
INTEGER;
ProcPtr;
INTEGER

{next queue entry}
{queue type}
{pointer to task}
{reserved}

Routines
PROCEDURE
PROCEDURE

PROCEDURE

InsTime

(tmTaskPtr:

PrimeTime

(tmTaskPtr,count:

RmvTime

(tmTaskPtr:

QElemPtr);
QElemPtr)

;

LONGINT) ;

Assembly-Language Information
Routines

Trap macro

On entry

On exit

_InsTime
_RmvTime
_PrimeTime

AQ: tmTaskPtr (ptr)
AO: tmTaskPtr (ptr)
AO: tmTaskPtr (ptr)
DO: count (long)

DO: result code (word)
DO: result code (word)
DO: result code (word)

Structure of Time Manager Queue Entry
qLink
qType
tmAddr
tmCount

Pointer to next queue entry
Queue type (word)
Pointer to task
Reserved (word)

7)
ws

=
=

mM

S
=
oS
v3
eo

Le

Summary of the Time Manager IV-301

§

Inside Macintosh

IV-302

APPENDIX A: ROUTINES THAT MAY MOVE
OR PURGE MEMORY
This appendix lists all the new routines that may move or purge blocks in the heap. As
described in chapter 1 of Volume II, calling these routines may cause problems if a handle
has been dereferenced. None of these routines may be called from within an interrupt,
such as in a completion routine or a VBL task.
DelMenultem
Draw1 Control
FindDItem
FontMetrics
GetlIndResource

GetlIndType

Get1 NamedResource
Get1 Resource
HideDItem
InsMenultem
MeasureText
MoveHHi

NewEmptyHandle

OpenRFPerm

PStr2Dec

Dec2Str
CStr2Dec
ShowDItem
TEAutoView
TEPinScroll
TESel View
TrackBox

UpdtControl
UpdtDialog

ZoomWindow

>

—)
a=)

o

~~

=

°
©
wn

Routines That May Move or Purge Memory IV-303

Inside Macintosh

APPENDIX B: SYSTEM TRAPS
This appendix lists the trap macros for the new Toolbox and Operating System routines and
their corresponding trap word values in hexadecimal. The “Name” column gives the trap
macro name (without its initial underscore character). In those cases where the name of the
equivalent Pascal call is different, the Pascal name appears indented under the main entry.
The routines in Macintosh packages are listed under the macros they invoke after pushing a
routine selector onto the stack; the routine selector follows the Pascal routine name in

parentheses.

There are two tables: The first is ordered alphabetically by name; the second is ordered
numerically by trap number, for use when debugging. (The trap number is the last two
digits of the trap word unless the trap word begins with A9, in which case the trap number
is 1 followed by the last two digits of the trap word.)
Warning:
use.

Traps that aren’t currently used by the system are reserved for future
Trap word

Name

A838
A817
A80D
A81C
A952
A96D
A984
A841
A840
A843
A818
A84D
A835
A842
A845
A847
A84B
A84A
A848
A849
A80E

CalcMask

CopyMask

Countl Resources

Count1Types

DelMenultem
Draw1Control
FindDItem
Fix2Frac

Fix2Long

Fix2X
FixAtan2
FixDiv
FontMetrics
Frac2Fix
Frac2X
FracCos
FracDiv
FracMul
FracSin

FracSaqrt

GetlIxResource
GetlIndResource

A80F

GetlIxType
GetlIndType

Get 1 NamedResource
Get1 Resource
HCIrRBit

HEFSDispatch

OpenWD

CloseWD

(1)

(2)

A820
A81F
A068
A260

Trap word

Name
CatMove
DirCreate
GetWDInfo
GetFCBInfo
GetCatInfo

SetCatInfo

SetVolinfo

LockRng
UnlockRng

A069
A827
A067
A06A
A826
A83F
A063
A061
A821
A837
A064
A066
A9IC4
A9E7

HGetS tate
HideDItem
HSetRBit
HSetState
InsMenultem

Long2Fix
MaxApp!Zone
MaxBlock
MaxSizeRsrc
MeasureText
MoveHHi

NewEmptyHandle
OpenRFPerm
PackO
LActivate
LAddColumn
LAddRow
LAddToCell

>
—
SS
cas)
|

LAutoScroll
LCellSize
LClick

(24)
System Traps [V-305

=

C3
a°)
”

Inside Macintosh

Name

Trap word

LCirCell
LDelColumn
LDelRow
LDispose
LDoDraw
LDraw
LFind
LGetCell
LGetSelect
LLastClick
LNew
LNextCell
LRect

LScroll
LSearch (84)

LSetCell

(28)
(32)
(36)
(40)
(44)
(48)
(52)
(56)
(60)
(64)
(68)
(72)

SCSIReset
SCSIGet
SCSISelect
SCSICmd
SCSIComplete
SCSIRead
SCSIWrite
SCSIInstall
SCSIRBlind
SCSIWBlind
SCSIStat
SeedFill
SetFScaleDisable
ShowDItem

IV-306

Trap word

StackSpace

A065

TrackBox
Unique1ID

A83B
A810

TEAutoView
TEPinScroll
TESel View

A813
A812
A811

UpdtControl
UpdtDialog
X2Fix
X2Frac
ZoomW indow

(76)

A953
A978
A844
A846
A83A

(80)

Trap word

(88)

A050
A067
A068
A069
A06A
A061
A062
A063
A064
A065

RelString
HSetRBit
HCIrRBit
HGetS tate
HSetState
MaxBlock
PurgeS pace
MaxApplZone
MoveHHi
StackS pace

A260

HFS Dispatch
OpenWD
CloseWD

LSetSelect
(92)
LSize
(96)
LUpdate
(100)
Pack7
A9EE
PStr2Dec
(2)
Dec2Str
(3)
CStr2Dec
(4)
Pack8
A816
Pack9
A82B
Pack10
A82C
Pack11
A82D
Pack12
A82E
Pack13
A82F
Pack14
A830
Pack15
A831
(Pack 8—Pack 15 reserved for future use)
PPostEvent
A12F
PurgeS pace
A062
RelString
A050

RsrcMapEntry
SCSIDispatch

Name

(0)
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(8)
(9)
(10)

System Traps

A066
Al12F

NewEmptyHandle
PPostEvent

A80D
A80E
A80F

(5)
(6)

SetCatInfo

(10)

(7)
(8)
(9)

SetVolInfo
(11)
LockRng
(16)
_ UnlockRng
(17)
Count1 Resources
GetlIxResource
~ GetlIndResource

A810
A81C
A81F
A811

GetlIxType
GetlIndType
UniquelID
Count1Types
Getl Resource
TESel View

A813

TEAutoView

A812

(1)
(2)

CatMove
DirCreate

GetWDInfo
GetFCBInfo
GetCatInfo

A9CS
A815

A839
A834
A828

Name

TEPinScroll

System Traps
Trap word
A815

SCS Dispatch

SCSIReset
SCSIGet

SCSISelect
SCSICmd

SCSIComplete

A816
A817
A818
A820
A821
A82B
A82C
A8&2D
A82E
A82F
A830
A831
A834
A835
A826
A827
A828
A836
A837
A838
A839
A83A
A83B
A83F
A840
A841
A842
A843
A844
A845
A846

Trap word

Name

SCSIRead
SCSIWrite
SCS Install
SCSIRBlind
SCSIWBlind
~ScCsSIStat
Pack8
CopyMask

FixAtan2
Getl NamedResource
MaxSizeRsrc
Pack9
Pack10
Pack11
Pack12
Pack13
Pack14
Pack15
SetFScaleDisable
FontMetrics
InsMenultem
HideDItem

(4)

(5)
(6)
(7)
(8)
(9)

A847
A848
A849
A84A
A84B
A84D
A952
A953
A96D
A978
A984
A9C4
A9CS
A9SE7

FracCos
FracSin
FracSart
FracMul

FracDiv
FixDiv
DelMenultem
UpdtControl
Draw1Control
UpdtDialog
FindDItem

OpenRFPerm
RsrcMapEntry
PackO

LActivate
LAddColumn
LAddRow
LAddToCell
LAutoScroll
LCellSize
LClick
LClrCell

(0)
(4)
(8)
(12)
(16)
(20)
(24)
(28)

LDelRow
LDispose
LDoDraw
LDraw
LFind
LGetCell
LGetSelect
LLastClick
LNew
LNextCell
LRect

(36)
(40)
(44)
(48)
(52)
(56)
(60)
(64)
(68)
(72)
(76)

LDelColumn

ShowDItem

GetMaskTable

MeasureText

CalcMask
SeedFill
ZoomWindow

LScroll

TrackBox
Long2Fix
Fix2Long

Fix2Frac

Frac2Fix

Fix2X
X2Fix
Frac2X
X2Frac

Name

AQEE

(32)

(80)

LSearch
LSetCell
LSetSelect
LSize
LUpdate
Pack7

(84)
(88)
(92)
(96)
(100)

Dec2Str

(3)

PStr2Dec

CStr2Dec

(2)

(4)
>

S
no)

co
~

=
°
©
wn

System Traps [V-307

Inside Macintosh

APPENDIX C: GLOBAL VARIABLES
This appendix gives an alphabetical list of all system global variables described in this
volume, along with their locations in memory.
Name

Location

ApFont ID
BootDrive

$984
$210

CurDirStore
Def VCBPtr

$352

FCBSPtr
FractEnable
FSFCBLen

$BF4
$3F6

DrvQHdr

$398

$308
$34E

FSQHdr
IntlSpec

$360
$BAO

LastFOND
MemErr
ROMBase

$BC2

SFSaveDisk

$214

SysFontFam

$BA6

SysFontSize

$BA8
$B9F

ToExtFS
VCBQHdr
WidthListHand

$3F2

WidthPtr
WidthTabHandle

$B10

RomMapInsert

TmpResLoad

$220
$2AE

$B9E

$356
$8E4

$B2A

Contents

Font number of application font (word)
Working directory reference number for system
startup volume (word)

Directory ID of directory last opened (long)

Pointer to default volume control block
Drive queue header (10 bytes)
Pointer to file-control-block buffer
Nonzero to enable fractional widths (byte)
Size of a file control block; on 64K ROM, it
contains —1 (word)

File I/O queue header (10 bytes)

International software installed if not equal to —1

(long)

Handle to last family record used

Current value of MemError (word)
Base address of ROM
Flag for whether to insert map to the ROM
resources (byte)
Negative of volume reference number, used by

Standard File Package (word)
If nonzero, the font number to use for system font

(word)

If nonzero, the size of the system font (word)

Temporary SetResLoad state for calls using

ROMMapInsert (byte)

Pointer to external file system
Volume-control-block queue header (10 bytes)
Handle to a list of handles to recently-used width
tables
Pointer to global width table
Handle to global width table

>

—)
S

©

i}
o.

o
©
wn

Global Variables [V-309

Inside Macintosh

IV-310

GLOSSARY
access path: A description of the route that the File Manager follows to access a file;
created when a file is opened.

access path buffer: Memory used by the File Manager to transfer data between an
application and a file.

active end:
selection.

In a selection, the location to which the insertion point moves to complete the

allocation block: Volume space composed of multiples of logical blocks.
anchor point:
Started.

In a selection, the location of the insertion point when the selection was

application list: A data structure, kept in the Desktop file, for launching applications
from their documents in the hierarchical file system. For each application in the list, an
entry is maintained that includes the name and signature of the application, as well as the
directory ID of the folder containing it.
arbitration phase:

The phase in which an initiator attempts to gain control of the bus.

asynchronous execution: After calling a routine asynchronously, an application is free
to perform other tasks until the routine is completed.
block map:

Same as volume allocation block map.

bus free phase:

The phase in which no SCSI device is actively using the bus.

catalog tree file: A file that maintains the relationships between the files and directories
on a hierarchical directory volume. It corresponds to the file directory on a flat directory

volume.

cell: The basic component of a list from a structural point of view; a cell is a box in which
a list element is displayed.

Chooser: A desk accessory that provides a standard interface for device drivers to solicit
and accept specific choices from the user.
closed file: A file without an access path.

Closed files cannot be read from or written to.

clump: A group of contiguous allocation blocks. Space is allocated to a new file in
clumps to promote file contiguity and avoid fragmentation.
clump size: The number of allocation blocks to be allocated to a new file.
command phase:
perform.

The phase in which the SCSI initiator tells the target what operation to
Q
co
n
wn
a)

Glossary IV-311

Lemp §

‘<

Inside Macintosh

completion routine: Any application-defined code to be executed when an
asynchronous call to a routine is completed.

data buffer: Heap space containing information to be written to a file or device driver
from an application, or read from a file or device driver to an application.
data fork: The part of a file that contains data accessed via the File Manager.
data phase: The phase in which the actual transfer of data between an SCSI initiator and
target takes place.
default directory: A directory that will be used in File Manager routines whenever no
other directory is specified. It may be the root directory, in which case the default directory
is equivalent to the default volume.
default volume: A volume that will receive I/O during a File Manager routine call,
whenever no other volume is specified.

device partition map: A data structure that must be placed at the start of physical block
1 of an SCSI device to enable it to perform Macintosh system startup. It describes the
allocation of blocks on the device.
device resource file:

An extension of the printer resource file, this file contains all the

resources needed by the Chooser for operating a particular device (including the device
driver code).
directory:

A subdivision of a volume that can contain files as well as other directories;

equivalent to a folder.

directory ID: A unique number assigned to a directory, which the File Manager uses to
distinguish it from other directories on the volume. (It’s functionally equivalent to the file
number assigned to a file; in fact, both directory IDs and file numbers are assigned from the
same set of numbers.)
drive number:

A number used to identify a disk drive. The internal drive is number 1,

drive queue: A

list of disk drives connected to the Macintosh.

the external drive is number 2, and any additional drives will have larger numbers.

driver descriptor map: A data structure that must be placed at the start of physical
block 0 of an SCSI device to enable it to perform Macintosh system startup. It identifies
the various device drivers on the device.

end-of-file:

See logical end-of-file or physical end-of-file.

extent: A series of contiguous allocation blocks.
extent descriptor:

A description of an extent, consisting of the number of the first

allocation block of the extent followed by the length of the extent in blocks.

extent record:

A data record, stored in the leaf nodes of the extents tree file, that

contains three extent descriptors and a key identifying the record.
extents tree file:

IV-312

Glossary

A file that contains the locations of the files on a volume.

Glossary

family record: A data structure, derived from a family resource, that contains all the
information describing a font family.

file: A named, ordered sequence of bytes; a principal means by which data is stored and
transmitted on the Macintosh.

file catalog: A hierarchical file directory.
file control block: A fixed-length data structure, contained in the file-control-block
buffer, where information about an access path is stored.
file-control-block buffer: A nonrelocatable block in the system heap that contains one
file control block for each access path.
file directory: The part of a volume that contains descriptions and locations of all the
files and directories on the volume. There are two types of file directories: hierarchical file
directories and flat file directories.

file I/O queue: A queue containing parameter blocks for all I/O requests to the File
Manager.

file number: A unique number assigned to a file, which the File Manager uses to
distinguish it from other files on the volume. A file number specifies the file’s entry in a
file directory.
font: A complete set of characters of one typeface, which may be restricted to a particular

size and style, or may comprise multiple sizes, or multiple sizes and styles, as in the

context of menus.
font family:
slant.

A group of fonts of one basic design but with variations like weight and

font record: A data structure, derived from a font resource, that contains all the
information describing a font.
fork:

One of the two parts of a file; see data fork and resource fork.

full pathname:

A pathname beginning from the root directory.

global width table: A data structure in the system heap used by the Font Manager to

communicate fractional character widths to QuickDraw.

initiator device: An SCSI device that initiates a communication by asking another
device (known as the target device) to perform a certain operation.
I/O request: A request for input from or output to a file or device driver; caused by
calling a File Manager or Device Manager routine asynchronously.

list definition procedure:

A procedure called by the List Manager that determines the

appearance and behavior of a list.

>)
io)

wn
wn

pou)

Glossary IV-313

Lew

Let

§

Inside Macintosh

list element:

The basic component of a list from a logical point of view, a list element is

simply bytes of data. In a list of names, for instance, the name Melvin might be a list

element.

List Manager: The part of the Operating System that provides routines for creating,
displaying, and manipulating lists.
list record: The internal representation of a list, where the List Manager stores all the
information it requires for its operations on that list.
locked file: A file whose data cannot be changed.
locked volume: A volume whose data cannot be changed.
either a software flag or a mechanical setting.

logical block:

Volumes can be locked by

Volume space composed of 512 consecutive bytes of standard

information and an additional number of bytes of information specific to the disk driver.

logical end-of-filé: The position of one byte past the last byte in a file; equal to the
actual number of bytes in the file.

mark: A marker used by the File Mariager to keep track of where it is during a read or
write operation.
master directory block: Part of the data structure of a flat directory volume; contains
the voltime information and the volume allocation block map.
messagé phase:

The phase in which the target sends one byte of message information

mounted volume:

A volume that has been inserted into a disk drive and has had

newline character:

Any character, but usually Return (ASCII code $0D), that indicates

back to the initiator.

descriptive information read from it by the File Manager.
the end of a sequence of bytes.

newline mode: A mode of reading data where the end of the data is indicated by a
newline character (and not by a specific byte count).

off-line volume:

A mounted volume with all but the volume control block released.

offspring: For a given directory, the set of files and directories for which it is the parent.
on-line volume: A mounted volume with its volume buffer and descriptive information
contained in memory.
open file: A file with an access path. Open files can be read from and written to.
open permission:

Information about a file that indicates whether the file can be read

from, written to, or both.

parameter block: A data structure used to transfer information between applications and
certain Operating System routines.
IV-314

Glossary

Glossary
parent:

For a given file or directory, the directory immediately above it in the tree.

parent ID: The directory ID of the directory containing a file or directory.
partial pathname:
directory.

A pathname beginning from any directory other than the root

pathname: A series of concatenated directory and file names that identifies a given file or
directory. See also partial pathname and full pathname.
path reference number:

A number that uniquely identifies an individual access path;

assigned when the access path is created.

physical end-of-file: The position of one byte past the last allocation block of a file;
equal to 1 more than the maximum number of bytes the file can contain without growing.
reselection phase: An optional phase in which the SCSI initiator allows a target device
to reconnect itself to the initiator.
resource fork:

The part of a file that contains data used by an application (such as

menus, fonts, and icons). The resource fork of an application file also contains the
application code itself.
root directory:

The directory at the base of a file catalog.

routine selector:

For routines that expand to the same macro, an integer that’s pushed

onto the stack or placed into a register before the macro is invoked, to identify which

routine to execute. For instance, all SCSI routines expand to invoke the trap macro
_SCSIDispatch; each routine has a selector that’s passed to the SCSI Manager in a word on
the stack before _SCSIDispatch is invoked.

SCSI:

See Small Computer Standard Interface.

SCSI Manager:

The part of the Operating System that controls the exchange of

information between a Macintosh and peripheral devices connected through the Small

Computer Standard Interface (SCSI).

selection phase: The phase in which the initiator selects the target device that will be
asked to perform a certain operation.

Small Computer Standard Interface (SCSD:

A specification of mechanical,

electrical, and functional standards for connecting small computers,
with intelligent
peripherals such as hard disks, printers, and optical disks.

status phase: The phase in which the SCSI target sends one byte of status information
back to the initiator.
subdirectory:

Any directory other than the root directory.

synchronous execution: After calling a routine synchronously, an application cannot
continue execution until the routine is completed.
op)
i)

7 2)
Fa)

poe

Glossary IV-315

=

<4

Inside Macintosh

Time Manager:

The part of the Operating System that lets you schedule a routine to be

executed after a given number of milliseconds have elapsed.

target.device: An SCSI device (typically an intelligent peripheral) that receives a request
from an initiator device to perform a certain operation.
unmounted volume: A volume that hasn’t been inserted into a disk drive and had
descriptive information read from it, or a volume that previously was mounted and has

since had the memory used by it released.

valence:

The number of offspring for a given directory.

volume: A piece of storage medium formatted to contain files; usually a disk or part of a
disk. A 3 1/2-inch Macintosh disk is one volume.
volume allocation block map: A list of 12-bit entries, one for each allocation block,
that indicate whether the block is currently allocated to a file, whether it’s free for use, or
which block is next in the file. Block maps exist both on flat directory volumes and in

memory.

volume attributes:

Information contained on volumes and in memory indicating

whether the volume is locked, whether it’s busy (in memory only), and whether the

volume control block matches the volume information (in memory only).

volume bit map: A data structure containing a sequence of bits, one bit for each

allocation block, that indicate whether the block is allocated or free for use. Volume bit
maps exist both on hierarchical directory volumes and in memory.

volume buffer: Memory used initially to load the master directory block, and used
thereafter for reading from files that are opened without an access path buffer.
volume control block:
information.

A nonrelocatable block that contains volume-specific

volume-control-block queue: A
volumes.

list of the volume control blocks for all mounted

volume information: Volume-specific information contained on a volume, including
the volume name and the number of files on the volume.
volume information block:

Part of the data structure of a hierarchical directory

volume reference number:
used to refer to the volume.

A unique number assigned to a volume as it’s mounted,

volume; it contains the volume information.

working directory: An alternative way of referring to a directory. When opened as a
working directory, a directory is given a working directory reference number that’s used to
refer to it in File Manager calls.
working directory control block:

A data structure that contains the directory ID of a

working directory, as well as the volume reference number of the volume on which the

directory is located.
IV-316 Glossary

Glossary

working directory reference number: A temporary reference number used to
identify a working directory. It can be used in place of the volume reference number in all
File Manager calls; the File Manager uses it to get the directory ID and volume reference

number from the working directory control block.

>)
co)

NM
7 2)

fo

Glossary IV-317

ej

te

Inside Macintosh

INDEX
A
access path [V-94

access path buffer IV-96

active end IV-5
Allocate function
high-level IV-112
low-level IV-143
allocation block IV-89
AllocContig function IV-143

anchor point IV-5

ApFontID global variable [V-31

AppleTalk Manager IV-229
application list IV-243
ApplLimit global variable [V-257
arbitration phase IV-286
arrow keys IV-3, 57
asynchronous execution, File
Manager IV-115
assembly language IV-13

automatic scrolling in TextEdit IV-57

CMovePBPtr data type IV-117
CMovePBRec data type [V-127
click loop routine
List Manager IV-266
TextEdit IV-58

Clock chip IV-251
Close function

high-level IV-112
low-level IV-144
Closed file IV-94

CloseWD function IV-158
clump IV-124, 167
clump size IV-124, 167
Command-key combination See keyboard
equivalent
command phase IV-286

completion routine

File Manager IV-115
control, multiple lines of text in IV-53
control definition function IV-53
Control Manager IV-53

routines

I[V-53

CopyMask procedure IV-24
B*-tree IV-168
Binary-Decimal Conversion Package IV-69
block (file) See allocation block
block map IV-162
boot blocks See system startup information

BufPtr global variable IV-257

bus free phase IV-285

C
CalcMask procedure IV-24
catalog tree file IV-171
CatMove function IV-157
Chooser IV-216
communication with IV-217
Operation of IV-219
writing a driver to run under IV-221
CInfoPBPtr data type [V-117
CInfoPBRec data type IV-125
CInfoType data type IV-117

CountlResources function IV-15
CountiTypes function IV-15
Create function

high-level IV-112
low-level IV-145
CurDirStore global variable [V-72
Current directory button IV-72

D
data buffer IV-95
data fork IV-93
data phase I[V-286

Data Terminal Ready line IV-225, 248
default directory ITV-100
default volume IV-100
getting See GetVol function
setting See SetVol function

DefVCBPtr global variable

IV-178

Delete function
high-level IV-113
low-level IV-147
DelMenultem procedure IV-56

Index IV-319

Inside Macintosh
F

desk scrap IV-61
Desktop file IV-243

family number IV-30
family record IV-36

device control entry IV-215

device ID IV-217
Device Manager IV-213

family resource [V-43
FamRec data type IV-36
FCBPBPtr data type IV-117
FCBPBRec data type IV-179

device package IV-217
device partition map IV-292
dialog box

FCBSPtr global variable

Close IV-10
routines

IV-59

Dinfo data type ITV-105

DirCreate function IV-146
directory IV-89

directory ID IV-92
directory name IV-90
directory record [V-172
Disk Driver IV-223
advanced Control calls IV-223
Disk Initialization Package IV-239

File Manager

DRAM See Dynamic RAM chips
Draw1Control procedure [V-53
drive number IV-93
drive queue IV-181
driver descriptor map IV-292
DrvQEIl datatype IV-181
DrvQHdr global variable IV-182
DTR See Data Terminal Ready line
DXInfo data type IV-106

Fix2Long function IV-65

Fix2X function IV-65
flat file directory IV-89, 163
FlushFile function IV-144
FlushVol function
high-level IV-108
low-level IV-133

IV-320 Index

FMetric data type IV-32
FmtDefaults global variable IV-241

IV-236

Memory Manager IV-80
Resource Manager IV-18
Event Manager, Operating System
routines IV-85
extent IV-170
extent descriptor [V-171
extent record I[V-171
extents tree file [V-170
external file system IV-182

IV-176, 178, 181

FixATan2 function IV-65
FixDiv function [V-64
Fix2Frac function IV-65

Eject function

error reporting

for queue access

filename IV-90
filenumber IV-163
file record IV-172
FindDItem function I'V-60
Finder information IV-104
Finder Interface I[V-243

Finfo data type IV-104
FInitQueue procedure IV-128

Dynamic RAM chips IV-246

Environs procedure

IV-89

File Manager routines
high-level IV-106
low-level IV-115

dispatch table See trap dispatch table
DlgHook function IV-75

high-level IV-108
low-level IV-135
end-of-file IV-93

IV-179

file IV-89, 93
file catalog See hierarchical file directory
file control block IV-94, 178
file-control-block buffer IV-178
file directory IV-89
fileicon IV-105
file I/O queue IV-115, 175

creating your own IV-74
Dialog Manager IV-59

IV-85

folder IV-105
font IV-29
variable size [V-56
Font/DA Mover IV-31

font family IV-29

Font Manager IV-27
communication with QuickDraw
data structures IV-34
routines IV-31
font number IV-30
font record IV-35

IV-33

Index
font resource IV-42
font scaling IV-33

FontMetrics procedure IV-32
fork

IV-93

formatting hierarchical volumes IV-240

FracCos function IV-64
FracDiv function IV-64
FracMul function I'V-64
FracSin function I'V-64

FracSqrt function I'V-64

FractEnable global variable IV-32
fractional character widths IV-33
Frac2Fix function IV-65
Frac2X function IV-65
FScaleDisable global variable IV-32
FSClose function IV-112
FSDelete function [V-113

GetVol function
high-level IV-107
low-level IV-131
GetVolinfo function

high-level

IV-107

low-level IV-129
GetVRefNum function IV-107
GetWDInfo function IV-159
global variables, list of IV-309
global width table [V-41

H
Hard Disk 20 IV-223

hardware

IV-245

FSFCBLen global variable IV-97

HCIrRBit procedure IV-79
HCreate function IV-146
HDelete function IV-147

FSRead function

HGetFileInfo function IV-149

FSOpen function IV-109
FSQHdr global variable IV-176

IV-109

FSWrite function IV-110
full pathname IV-99
FXInfo data type IV-105

G

HFSDispatch trap macro IV-118
HGetState function IV-79

HGetVInfo function IV-130
HGetVol function IV-132
HideDItem procedure I'V-59
hierarchical file directory IV-89

HOpen function IV-136

GetCatInfo function IV-155
GetDrvQHadr function IV-181
GetEOF function
high-level IV-111
low-level IV-142
GetFCBInfo function IV-179
GetFileInfo function

high-level

low-level

IV-113

IV-148

GetFInfo function

IV-113

GetFPos function
high-level IV-110
low-level IV-141
GetFSQHdr function IV-175
GetMaskTable function IV-25
GetlIndResource function IV-15
GetlIndType procedure IV-15
Get1NamedResource function IV-15
GetlResource function IV-16
GetTrapAddress function IV-234

GetVCBQHadr function

GetVInfo function

IV-178

IV-107

HOpenkRF function I'V-137
HParamBlkPtr data type IV-117
HParmBlockRec data type [V-118
FileParam variant [V-122
IOParam vanant IV-120
VolumeParam vanant IV-123
HRename function IV-154
HRstFLock function IV-152
HSetFileInfo function IV-150
HSetFLock function IV-151
HSetRBit procedure I'V-79
HSetState procedure IV-80
HSetVol function [V-133
HSetVolinfo function [V-131

LJ
indexing IV-101
initialization resources I'V-256
initiator device [V-285
InitQueue procedure IV-128

InsMenultem procedure IV-55

InsTime procedure IV-300

Index IV-321

Inside Macintosh
IntlSpec global variable [V-42

I/O queue See file I/O queue
I/O request

IV-115

K
keyboard I[V-250
keyboard equivalent, reserved IV-7
key-down transitions IV-250
keypad IV-250

LRect procedure [V-274

LScroll procedure IV-275
LSearch function IV-274

LSetCell procedure [V-272
LSetSelect procedure IV-273
LSize procedure IV-274
LUpdate procedure IV-275

mark, ina file

IV-94

master directory block

IV-160

L

MaxApplZone procedure

LActivate procedure [V-276
LAddColumn function [V-271
LAddRow function [V-271
LAddToCell procedure [V-272

MaxSizeRsrc function IV-16
MeasureText procedure IV-25

LAutoScroll procedure [V-275

LCellSize procedure IV-273
LClick function I'V-273
LCirCell procedure [V-272
LDelColumn procedure [V-271
LDelRow procedure IY-272
LDispose procedure [V-271
LDoDraw procedure I'V-275

LDraw procedure IV-275

LFind procedure I'V-274
LGetCell procedure IV-272
LGetSelect function IV-273

list IV-261

cell selection IV-266
defining your own IV-276

drawing IV-262
element IV-261

List Manager Package IV-259
routines [V-269
list record [V-262
ListHandle data type IV-264
ListPtr data type IV-264
ListRec data type IV-263

LLastClick function IV-273
LNew function IV-270

LNextCell function [V-274
LoadSeg procedure IV-83
locked file IV-94
locked volume IV-93
LockRng function IV-138
logical block IV-89, 160
logical end-of-file IV-93

Long2Fix function IV-65

IV-322 Index

MaxBlock function IV-77

IV-77, 83

MemErr global variable [V-80
Memory Manager IV-77
routines [V-77
menu scrolling IV-56

menu definition procedure

IV-56

menuID 1-344
Menu Manager IV-55
routines IV-55
message phase IV-286
Mini-8 connector IV-248
mounted volume IV-92
MountVol function IV-128
MoveHHi procedure IV-77, 83

N
NewEmptyHandle function IV-78
newline character [V-95
newline mode IV-95

NGetTrapAddress function IV-234

NSetTrapAddress procedure IV-234
numeric formatter [V-69
numeric scanner IV-69

O
off-line volume IV-92
OffLine function IV-134
offset/width table IV-34

offspring, of a directory IV-91

on-line volume IV-92
open file IV-94

Index

PBGetFPos function

Open function

high-level [V-109

PBGetVInfo function

low-level IV-135

PBGetVol function

Open permission IV-95
OpenRF function

high-level IV-109
low-level IV-137
OpenRFPerm function IV-17

OpenWD function IV-158

Operating System Event Manager IV-85
Operating System Utilities IV-233
routines IV-233

P
Pack 0 See List Manager Package
Pack 2 See Disk Initialization Package
Pack 3 See Standard File Package

Pack 7 See Binary -Decimal Conversion
Package
Package Manager IV-67
packages IV-67
ParamBlkType datatype IV-117
ParamBlockRec datatype IV-118
file I/O queue entry IV-175
FileParam variant [V-122
JOParam variant [V-120

VolumeParam variant IV-123

parameter block IV-116
parameter RAM IV-251
parent directory IV-91
parent ID IV-92

IV-117

path reference number

IV-94

partial pathname IV-99
pathname IV-99
PBAllocate function

IV-143

IV-129

IV-131

PBGetWDInfo function IV-159
PBHCreate function IV-146
PBHDelete function IV-147
PBHGetFInfo function IV-149
PBHGetViInfo function IV-130
PBHGetVol function IV-132

PBHOpen function IV-136
PBHOpenRF function
PBHRename function

IV-137

IV-154

PBHRstFLock function IV-152
PBHSetFInfo function IV-150
PBHSetFLock function IV-151
PBHSetVol function IV-133
PBLockRange function IV-138
PBMountVol function IV-128
PBOffLine function IV-134

PBOpen function IV-135
PBOpenkRF function I[V-137

PBOpenWD function IV-158
PBRead function [V-139
PBRename function IV-153
PBRstFLock function

IV-152

PBSetCatInfo function IV-156

PBSetEOF function

PBSgtFInfo function

PBSetFLock function

IV-142

IV-150

IV-151

PBSetFPos function

IV-141

PBSetVInfo function

IV-131

PBSetFVers function

ParmBlkPtr data type

IV-141

IV-153

PBSetVol function IV-132
PBUnlockRange function [V-139
PBUnmountVol function IV-134
PBWrite function IV-140

physical end-of-file IV-93
PrimeTime procedure IV-300

PBAlocContig function IV-143

PurgeSpace procedure IV-78

PBClose function IV-144
PBCloseWD function IV-158

Q

PBCatMove function IV-157

PBCreate function IV-145
PBDelete function IV-147
PBDirCreate function IV-146

PBEject function

IV-135

PBFlushFile function

PBFlushVol function

IV-144

IV-133

PBGetCatInfo function IV-155
PBGetEOF function IV-142

PBGetFCBInfo function IV-179
PBGetFinfo function

IV-148

queue
drive IV-181
file YO IV-115, 175
Time Manager [V-299
volume-control-block IV-176
QuickDraw IV-23

communication with Font Manager
routines IV-23

IV-33

Index IV-323

Inside Macintosh

R
RAM. IV-246
Read function

high-level IV-109
low-level IV-139

read/write permission

IV-95

relocatable blocks, properties of IV-78

RelString function IV-234
Rename function
high-level IV-114
low-level IV-153
reselection phase IV-286
resource fork IV-93
Resource Manager IV-15
routines IV-15
resource type list [V-17
result code

Resource Manager IV-18

RmvTime procedure IV-300
ROM IV-247
ROM resource IV-18
list IV-19
map IV-19

overriding IV-20

ROM Serial Driver IV-225
advanced Control calls IV-226
ROMBase global variable IV-236
ROMMapInsert global variable IV-19
root directory IV-91
routine selector
File Manager IV-118

List Manager IV-269
SCSI Manager IV-289
RsrcMapEntry function IV-16
RstFilLock function
high-level IV-114
low-level IV-152
RstFLock function IV-114

SCSIWBlind function IV-291
SCSIWrite function IV-291
SeedFill procedure IV-24
Segment Loader

IV-83

selection phase IV-286

Serial Communications Controller [V-248
Serial Driver [V-225
advanced Control calls [V-226

serial port [V-225,

SetCatInfo function IV-156
SetEOF function
high-level IV-111
low-level IV-142
SetFileInfo function
high-level IV-114
low-level IV-150
SetFilLock function
high-level IV-114
low-level IV-151

SetFilType function

IV-153

SetFInfo function IV-114
SetFLock function IV-114
SetFPos function
high-level IV-110

low-level

IV-141

SetFractEnable [V-32
SetFScaleDisable procedure IV-32
SetTrapAddress procedure IV-234
SetVol function
high-level IV-107
low-level IV-132

SFSaveDisk global variable

IV-72

ShowDItem procedure IV-59
SIMM See Single In-Line Memory Module

Single In-Line Memory Module IV-246

S

Small Computer Standard Interface

SANE IV-69
SCC IV-248

Scrap Manager IV-61
screen buffer IV-247

SCSI See Small Computer Standard Interface
SCSI Manager IV-283
routines [V-289
writing a driver IV-292
SCSICmd function IV-290
SCSIComplete function I'V-291

IV-324

SCSIGet function IV-289
SCSIInstr data type [V-287
SCSIRBlind function [V-290
SCSIRead function IV-290
SCSIReset function I'V-289
SCSISelect function ITV-290
SCSJStat function [V-291

Index

IV-251,

285
socket [V-229
sound buffer [V-247
sound generator [V-247
StackSpace function IV-78
Standard File Package IV-71
status phase IV-286
subdirectory [V-89
synchronous execution, File Manager IV-115

Index
SysFontFam global variable IV-31

SysFontSiz global variable [V-31
System Error Handler IV-231
System file ITV-255
system font IV-31
system font size IV-31

System Resource File IV-255
system startup
environment IV-256
information IV-160, 164
system traps

IV-305

T
tag byte IV-223
target device IV-285

TEAutoView procedure IV-57
TEPinScroll procedure IV-57
TESel View procedure IV-57
TextEdit IV-57
routines I[V-57
TFSTagData IV-223
thread record IV-173

Time Manager IV-297
routines IV-300
TmpResLoad global variable IV-19
TMTask data type IV-299
Toolbox Utilities IV-63

routines IV-63
track cache IV-224
TrackBox function IV-50
transfer instruction block IV-287
trap dispatch table IV-13

trap macro list IV-305
trap number IV-13
trap word

IV-13

TrapType data type IV-233

U
Unique1ID function

unit number

IV-215

IV-16

unit table IV-215
UnlockRng function IV-139
unmounted volume IV-92
UnmountVol function

high-level
low-level

IV-108

IV-134

UpdtControl procedure I'V-53
UpdtDialog procedure IV-60
user interface guidelines I-23
Utilities, Operating System IV-233
routines IV-233

Utilities, Toolbox
routines IV-63

IV-63

V
valence of a directory IV-91
VCB datatype IV-176
VCBQHdr global variable IV-178
version number of a file IV-90
video interface IV-247
volume (on a disk) IV-89
volume allocation block map I[V-162
volume attributes IV-162

volume bitmap IV-167

volume buffer IV-92
volume control block IV-92, 176
volume-control-block queue IV-176
volume information IV-161, 166
volume information block IV-165
volume name IV-90
volume reference number IV-93, 98

W
WDPBPtr data type IV-117

WDPBRec data type [V-127

WidthListHand global variable [V-42
WidthPtr global variable [V-42
WidthTabHandle global variable [V-42
WidthTable data type IV-41
window

standard state [V-7
user state IV-8

zooming IV-7, 49
window definition function
Window Manager IV-49
routines IV-50
working directory IV-98

IV-49

working directory control block IV-98

working directory reference number IV-98
Write function

high-level IV-110

low-level IV-140
WStateData data type TV-49

Index IV-325

Inside Macintosh

X, Y

Z

X2Fix function IV-65
X2Frac function IV-65

zoom window box IV-8
Zoom Window procedure IV-50

IV-326 Index

Inside

Macintosh

Welcome to the world of programming for the Macintosh®. No other personal computer has been as
enthusiastically received by the programming community, as the large—and growing—body of Macintosh
software attests. Inside Macintosh provides the guidelines and technical information that you’ll need to
develop Macintosh programs, but many other resources can help speed and simplify your software

development efforts.

Development

|

Languages

You won't have to look far to find a development language that suits your specific requirements. A
growing family of Macintosh languages will serve your development needs whether your expertise is in

Pascal, C, Assembler, FORTH, FORTRAN, COBOL, BASIC, Lisp, Modula-2, or one of many others.

And the information in Inside Macintosh can be applied to any of the Macintosh languages.

The

Certified Developer

Program

If your primary business is developing software products for commercial markets, we strongly suggest that

you investigate the Apple Certified Developer Program. This program helps developers produce and bring
Macintosh products to market by providing them with support programs, services, and information.
Among them are
¢ Technical Support: Apple’s Developer Technical Support Group offers fast answers by way of
AppleLink® or MCI electronic mail.
¢ Macintosh Technical Notes: This is a bimonthly package of supplemental technical information.
¢ AppleLink: Through this electronic service, you can get answers to your technical questions and
current information on Apple and third-party products and programs.
¢ Certified Developer Mailings: These monthly mailings keep you informed about Apple’s
products, development tools, and technical and company directions.

¢ The Information Exchange: This information, available in printed and HyperCard® stack form,
lists company-sponsored programs and services available to you and your company.
¢ Outside Apple: This monthly newsletter informs you of developer-oriented Apple groups, programs,
and events.
You must meet certain criteria to get Certified Developer status. You can get an information package and

application by writing to

Developer

Programs

Apple Computer, Inc.
20525 Mariani Avenue, M/S 51-W
Cupertino, CA 95014

APDA

The Apple Programmer’s and Developer’s Association, APDA™, provides technical documentation and

products for all programmers and developers who work on Apple equipment. It provides material that is
unavailable elsewhere (including preliminary documentation of new Apple products). APDA also sells
compilers and other tools from both Apple and third-party sources. For information on joining, write to
APDA
290 SW 43rd Street
Renton, WA 98055
(206) 251-6548

Technical

Notes

Published bimonthly by Developer Technical Support, these notes answer frequently asked questions

through examples and sample code and provide updates, additions, and corrections to the Inside Macintosh
books. They are available through the Certified Developer Program, APDA, and major electronic
information services.

|

@.
Apple’

Inside Macintosh

The Official

Volume IV

Publication from
Apple Computer, Inc.

> #2495 FPT

Inside Macintosh, Volume IV, is a companion to the first three volumes of Inside Macintosh and

describes the features of the Macintosh ® Plus and Macintosh 512K Enhanced computers.

Written by the people at Apple Computer, /nside Macintosh is the definitive source of information
for programmers writing application programs, desk accessories, device drivers, and other
software for any of the computers in the Apple Macintosh family. It includes:
* Guidelines for designing a user interface that conforms to the Macintosh standard.
* Descriptions of more than 1,200 ROM- and disk-based routines.
* A description of the Macintosh hardware.
Inside Macintosh is your guide to creating software for the Macintosh. It describes the Pascal
interfaces to the routines and, wherever applicable, gives special information for programming in
assembly language. (If you're using a high-level language other than Pascal, your development

system documentation should tell you how to apply the information in Inside Macintosh.) A typical

chapter describes a related set of routines, such as the Window Manager, and provides key concepts
and background information, hints on which routines you need to learn about and how they fit into
your program, and a detailed description of each routine.
Inside Macintosh consists of six volumes. This volume, Volume IV, contains descriptions of hundreds
of changes and additions to the original set of programming tools, including:

* An in-depth discussion of the Hierarchical File System.

* Details on the interface to the Small Computer Standard Interface (SCSI) port.

¢ Information on disk I/O for the 800K disk drive and the Hard Disk 20.
¢ A description of the Macintosh Plus and Macintosh 512K Enhanced hardware.
Volume I contains important introductory material and describes the QuickDraw graphics package

and important Managers such as the Resource, Font, and Menu Managers. Volume II complements
Volume I in describing the Managers that perform such basic routines as file and device I/O,
memory management, and interrupt handling. Volume III discusses your program’s interface with
the Finder” describes the Macintosh 128K and 512K computers, and provides summaries of the
software described in volumes I through III. Volume V discusses the changes introduced by the
Macintosh SE and II computers, including color, NuBus™ slots, and the Apple Desktop Bus™ /nside
Macintosh X-Ref provides a single index to Inside Macintosh and other Macintosh technical books.

About the cover: This design represents a new look for the original edition of Inside Macintosh,

Volume IV, and the other books in the Apple Technical Library. The contents have not been changed.

Printed in US.A.

y)

Apple Computer, Inc.
20525 Mariani Avenue

Cupertino,CA

(408) 996-1010

95014

TLX 171-576

Addison-Wesley Publishing Company, Inc.

9

"780201°054095

ISBN

O0-201-05409-4

