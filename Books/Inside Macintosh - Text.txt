INSIDE

Text

MACINTOSH

« Apple Computer, Inc.
© 1993 Apple Computer, Inc.
All rights reserved.
No part of this publication may be
reproduced, stored in a retrieval system,
or transmitted, in any form or by any
means, mechanical, electronic,

photocopying, recording, or otherwise,
without prior written permission of
Apple Computer, Inc. Printed in the
United States of America.
No licenses, express or implied, are

granted with respect to any of the
technology described in this book.
Apple retains all intellectual property
rights associated with the technology
described in this book. This book is
intended to assist application
developers to develop applications only
for Apple Macintosh computers.
Apple Computer, Inc.

20525 Mariani Avenue
Cupertino, CA 95014
408-996-1010

Simultaneously published in the United
States and Canada.
LIMITED WARRANTY
REPLACEMENT

ON MEDIA

AND

ALL IMPLIED WARRANTIES ON THIS
MANUAL, INCLUDING IMPLIED
WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR
PURPOSE, ARE LIMITED IN DURATION
TO NINETY (90) DAYS FROM THE DATE
OF THE ORIGINAL RETAIL PURCHASE
OF THIS PRODUCT.
Even though Apple has reviewed this
manual, APPLE MAKES NO WARRANTY
OR REPRESENTATION, EITHER EXPRESS
OR IMPLIED, WITH RESPECT TO THIS
MANUAL, ITS QUALITY, ACCURACY,
MERCHANTABILITY, OR FITNESS FOR A
PARTICULAR PURPOSE. AS A RESULT,
THIS MANUALIS

SOLD

“AS IS,” AND

YOU, THE PURCHASER, ARE ASSUMING
THE ENTIRE RISK AS TO ITS QUALITY
AND ACCURACY.

Apple, the Apple logo, APDA,
AppleLink, AppleShare, ImageWriter,

IN NO EVENT WILL APPLE BE LIABLE
FOR DIRECT, INDIRECT, SPECIAL,

SANE are trademarks of Apple

DAMAGES RESULTING FROM ANY
DEFECT OR INACCURACY IN THIS
MANUAL, even if advised of the possibility
of such damages.

LaserWriter, Macintosh, MPW, and

Computer, Inc., registered in the United
States and other countries.

Apple Desktop Bus, Balloon Help,

Chicago, Finder, Geneva, KanjiTalk,
Monaco, New York, PowerBook,
QuickDraw, ResEdit, System 7,

TrueType, and WorldScript are
trademarks of Apple Computer, Inc.
Adobe, Illustrator, and PostScript are

trademarks of Adobe Systems
Incorporated, which may be registered
in certain jurisdictions.
AGFA is a trademark of Agfa-Gevaert.
America Online is a service mark of
Quantum Computer Services, Inc.
CompuServe is a registered service
mark of CompuServe, Inc.
FrameMaker is a registered trademark
of Frame Technology Corporation.
Helvetica and Palatino are registered
trademarks of Linotype Company.
Internet is a trademark of Digital
Equipment Corporation.
ITC Zapf Dingbats is a registered
trademark of International Typeface
Corporation.
Microsoft is a registered trademark of
Microsoft Corporation.
SuperPaint is a registered trademark of
Aldus Corporation.
The world map in Plate 1 is reprinted
from Writing Systems of the World by
Akira Nakanishi, with the permission of
the Charles E Tuttle Publishing Co.,
Tokyo, Japan.

INCIDENTAL,

OR CONSEQUENTIAL

THE WARRANTY AND REMEDIES SET
FORTH ABOVE ARE EXCLUSIVE AND IN
LIEU OF ALL OTHERS, ORAL OR
WRITTEN, EXPRESS OR IMPLIED. No
Apple dealer, agent, or employee is
authorized to make any modification,
extension, or addition to this warranty.

Some states do not allow the exclusion or
limitation of implied warranties or liability
for incidental or consequential damages, so
the above limitation or exclusion may not
apply to you. This warranty gives you
specific legal rights, and you may also have
other rights which vary from state to state.

Contents
Figures, Tables, and Listings

Preface

About

This

Book

What to Read

XXXi

xxi
XXxi

Format of a Typical Chapter

XXXil

Conventions Used in This Book

Special Fonts
Types of Notes

XXXiii
XXXiii

Development Environment

Chapter 1

XXXili

XXX1V

Introduction to Text on the Macintosh
Macintosh Text Overview
1-3
Separation of Tasks
1-4
Text Is Graphics
1-5
Characters, Glyphs, Character Codes, and Bytes
Text Storage
1-9
Keyboards and Input Methods
1-11
Writing Systems and Script Systems
1-14
Macintosh Text Utilities
1-16
TextEdit, a Text-Processing Service

1-1

1-8

1-16

Planning Your Text Handling Capabilities
1-18
Rudimentary Text Handling
1-18
Moderate Text Handling
1-19
Sophisticated Text Handling
1-20
Writing Systems and Script Systems
1-21
Features of the World’s Writing Systems
1-21
Character Representation
1-22
Line Direction and Alignment
1-23
Contextual Forms and Character Reordering
1-26
Diacritical Marks
1-29
Uppercase and Lowercase Characters
1-30
Word Demarcation

Styles

1-31

1-30

Numbers, Currencies, and Dates

1-32

Character Order and Text Sorting
1-34
Variations Among Languages and Regions

1-34

ili

Components of the Macintosh Script Management System
The Macintosh Text Managers
1-36
The WorldScript Extensions
1-39
Components of a Script System
1-40
International Resources

Keyboard Resources
Fonts

1-41

1-42

1-44

How Script Systems Are Classified
1-45
Types of Script Systems
1-46
Script Codes, Language Codes, and Region Codes
The System Script and Auxiliary Scripts
1-51
Font Script and Keyboard Script
1-51
How Script Systems Work
1-52
Character Encoding
1-52
The Standard Roman Character Set
1-54
Other 1-Byte Character Encodings
1-56
2-Byte Character Encodings
1-57
Font Handling
1-60
Font Availability and Selection
1-61
System Font and Application Font
1-61
Roman Characters and Associated Fonts
1-62
Other Font Issues
1-63
Character Rendering and Text Display
1-64
Storage Order and Display Order
1-65
Line Direction and Alignment
1-67
Style Runs, Font Runs, Script Runs, Direction Runs

Text Layout
1-71
Caret Handling
1-74
Highlighting
1-80
Converting Screen Position to Text Offset
Printing
1-85
Text Input
1-87
Keyboards and Key Translation
1-87
Input Methods
1-91
Text Manipulation
1-94
Sorting Strings
1-94

1-48

1-70

1-82

Formatting Dates, Times, Numbers, and Symbols

Analyzing Characters
1-98
Searching, Modifying, and Converting Text
1-98
Finding Word Boundaries and Line Breaks
1-99
Script Systems in Use
1-100
Installing and Enabling Script Systems
1-100
Components of the System Script
1-101
Components of Auxiliary Scripts
1-102
Installing Modifications to a Script System
1-103
How the User Switches Among Script Systems
1-104
User Control of Script Settings
1-107

iv

1-35

1-96

Chapter 2

TextEdit

2-1

About TextEdit
2-6
TextEdit and Standard Macintosh Features

2-6

Multistyled and Monostyled Text = 2-7
Font and Keyboard Script Synchronization
Cutting, Copying, and Pasting Text
2-9
The TextEdit User Interface

2-8

2-10

The Selection Range, the Insertion Point, and Highlighting

in TextEdit
2-10
Caret Position and Movement
2-11
Text Alignment
2-13
Line Measurement
2-14
Text Buffering
2-14
The TextEdit Private, Null, and Style Scraps
An Overview of the TextEdit Data Structures
An Overview of the Edit Record
2-16
Related Data Structures
2-17

2-15
2-16

Using TextEdit
2-21
Getting Started With TextEdit
2-22
Preparing to Use TextEdit
= 2-22
Displaying Static Text

2-24

Creating an Edit Record
2-24
Specifying the Destination and View Rectangles
Setting the Text of an Edit Record
2-29
Setting the Selection Range or the Insertion Point
Scrolling Text

—2-28
— 2-30

2-31

Disposing of an Edit Record
=. 2-32
Responding to Events Using TextEdit
Handling a Null Event

2-32

2-32

Activating an Edit Record

2-33

Handling Mouse-Down Events

Responding to an Update Event

2-34

= 2-36

Accepting Text Input Through Key-Down Events

Moving Text In and Out of Edit Records

= 2-38

Using TextEdit to Cut, Copy, and Paste Text
Inserting and Deleting Text
2-43
Text Attributes
2-43

2-39

Checking the Text Attributes Across a Selection Range
Toggling an Attribute
Handling a Font Menu

2-46
2-47

Handling a Font Size Menu
2-48
Handling a Style Menu
2-48
Changing the Text Alignment
2-50
Saving and Restoring a TextEdit Document, and
Implementing Undo
2-51

Saving a TextEdit Document

=. 2-51

2-36

= 2-44

Restoring an Existing TextEdit Document
— 2-53
Handling Undo
—_.2-55
Customizing TextEdit
2-56
Replacing the End-of-Line Routine
2-57
Replacing the Drawing Routine
2-58
Replacing the Width-Measuring Routines
—_2-58
Replacing the Hit Test Routine —_ 2-60
Customizing Word Selection
2-60
Customizing Automatic Scrolling
2-61
Determining the Line Length
2-62
Advanced Customization
2-63
TextEdit Reference
2-64
Data Structures
2-64
The Edit Record
2-67
The High Hook and Caret Hook Fields
—2-70
The Style Record
2-71
The Style Table
2-72
The Line Height Table
2-73
The Null Style Record
2-74
The Style Scrap Record
2-74
The Scrap Style Table
2-75
Text Style Record
2-76
Routines
2-76
Initializing TextEdit, Creating an Edit Record, and Disposing of an
Edit Record
2-77
Activating and Deactivating an Edit Record — 2-80
Setting and Getting an Edit Record’s Text and Character Attribute
Information
2-81
Setting the Caret and Selection Range
= 2-84
Displaying and Scrolling Text
2-86
Modifying the Text of an Edit Record
2-93
Managing the TextEdit Private Scrap
2-98
Checking, Setting, and Replacing Styles
2-99
Using Byte Offsets and Corresponding Points
2-105
Additional TextEdit Features
2-107
Customizing TextEdit
2-110
Summary of TextEdit
2-118
PascalSummary
2-118
Constants
2-118
Data Types
2-120
Routines
2-123
C Summary
2-125
Constants
2-125
Types
2-127
Routines
2-130

Assembly-Language Summary
Trap Macros
2-132
Global Variables
2-133

Chapter 3

QuickDraw Text

2-132

3-1

About QuickDraw Text

3-4

Graphics Ports and Text Drawing

= 3-4

Font, Font Style, and Font Size

3-5

Transfer Modes

3-8

QuickDraw Text, Script Systems, and Other Managers

3-10

Determining the Version and Initializing QuickDraw

3-18

Text Formatting and Justification
3-13
Scaling
3-15
Carets and Highlighting
3-16
Using QuickDraw Text
3-17
Preparing to Use QuickDraw
3-17

Setting Up the Text-Drawing Environment
3-19
Specifying Text Characteristics
3-19
Setting the Font
3-20
Modifying the Text Style
3-21
Changing the Font Size
3-22
Changing the Width of Characters
3-22
Using Fractional Glyph Widths — 3-23
Specifying the Transfer Mode
3-24
Basic Transfer Mode Operations
3-24
Arithmetic Transfer Mode Operations
3-25
The grayishTextOr Transfer Mode — 3-26
Text Mask Mode
3-26
Transparent Transfer Mode
3-27
Transfer Modes and Multibit Fonts
3-27
Measuring and Drawing Single Segments of Text
= 3-27
Individual Glyphs — 3-28
Pascal Strings
3-28
Text Segments
3-29
Measuring and Drawing Lines of Text
3-29
Determining Where to Break the Line
—3-30
Determining the Display Order for Style Runs
—3-33
Eliminating Trailing Spaces (for Justified Text)
3-36
Calculating the Slop Value (for Justified Text)

3-39

Allocating the Slop to Each Style Run (for Justified Text)
Drawing the Line of Text
3-42
Using Scaled Text
3-44
Drawing Carets and Highlighting
3-47
Converting an Onscreen Pixel Location to a Byte Offset
Finding a Caret Position and Drawing a Caret
3-49

3-39

3-49

vii

Synchronizing the Caret With the Keyboard Script
Highlighting a Text Selection
3-60
Customizing QuickDraw’s Text Handling
3-62
Text in QuickDraw Pictures

Fonts
3-63
Text With Multiple Style Runs

QuickDraw Text Reference

3-59

3-63

3-65

3-65

Data Structures
3-66
The Font Information Record
3-66
The Style Data Type
3-66
Routines
3-67
Setting Text Characteristics
3-68
Drawing Text
3-76
Measuring Text
3-81
Laying Outa Line of Text
3-87
Determining the Caret Position, and Selecting and Highlighting
Text
3-91
Low-Level QuickDraw Text Routines

Application-Supplied Routine
3-100
Summary of QuickDraw Text
3-102
Pascal Summary
3-102
Constants
3-102
Data Types
3-102
Routines
3-103
C Summary
3-105
Constants
3-105
Types
3-105
Routines
3-106
Assembly-Language Summary — 3-107
Trap Macros
3-107
Global Variables
3-108

Chapter 4

Font Manager

3-98

41

About Fonts
4-6
Characters, Character Codes, and Glyphs
Kinds of Fonts
4-7
Identifying Fonts
4-8
Font Measurements
4-8
About Font Resources

4-12

Font Resource Types
4-13
A Brief History of Font Resource Use

= 4-13

Font Family IDs
4-14
Restrictions on the Use of 'FONT" Resources
Font Resource Tables
4-16

viii

4-6

4-15

About the Font Manager
4-16
How QuickDraw Requests a Font
4-16
How the Font Manager Responds to a Font Request
4-17
How the Font Manager Scales Fonts
4-19
The Scaling Process for a Bitmapped Font
4-22
The Scaling Process for an Outline Font
= 4-23
How the Font Manager Calculates Glyph Widths
= 4-23
Synthetic Fonts
= 4-25
How the Font Manager Renders Outline Fonts
4-25
Using the Font Manager
= 4-31
Adding Font Sizes and Names totheMenu = 4-32
Storing a Font Name in a Document
4-33
Getting Font Measurement Information
4-34
Favoring Outline or Bitmapped Fonts
4-35
Preserving the Shapes of Glyphs
4-35
Using Width Tables
4-36
Getting the System or Application FontID
4-38
Using Fractional Glyph Widths and Font Scaling
4-38
Font Manager Reference
4-39
Data Structures
4-39
The Font Input Record
4-40
The Font Output Record
4-4]
The Global Width Table
4-43
The Font Record
4-46
The Font Family Record
4-47
The Font Association Table Record
4-47
The Family Glyph-Width Table Record
4-48
The Style-Mapping Table Record
4-49
The Font Family Kerning Table Record
4-49
Routines
4-50
Initializing the Font Manager
= 4-50
Getting Font Information
4-51
Using the Current, System, and Application Fonts
= 4-53
Getting the Characteristics of aFont
4-54
Enabling Fractional Glyph Widths
4-58
Disabling Font Scaling
4-59
Favoring Outline Fonts Over Bitmapped Fonts
4-60
Scaling Outline Fonts
4-62
Accessing Information About a Font
4-64
Handling Fontsin Memory
= 4-65
The Bitmapped Font ("NFNT") Resource

The Font Type Element
4-70
The Offset to the Width/Offset Table

The Outline Font (‘sfnt') Resource

The Font Directory
4-74
The Character-Code Mapping Table

4-66

= 4-71
4-72

4-76

1x

The
The
The
The
The
The
The
The
The
The

Control-Value Table
4-77
Font Program Table
4-77
Glyph Data Table
4-77
Horizontal Device Metrics Table
Font Header Table
4-79
Horizontal Header Table
4-83
Horizontal Metrics Table
4-83
Kerning Table
4-84
Location Table
4-84
Maximum Profile Table
4-84

4-78

The Font Naming Table
= 4-85
The PostScript Table
4-89
The Preprogram Table

4-89

The Font Family ("FOND") Resource
The Font StyleCode
4-94
The
The
The
The

Font Association Table
4-95
Offset Table
4-96
Bounding-Box Table
4-97
Family Glyph-Width Table
4-98

The Style-Mapping Table

4-99

The Font Family Kerning Table

Summary of the Font Manager
PascalSummary
4-108
Constants

4-108

Routines

4-112

Constants

4-113

Routines

4-118

Data Types
CSummary
Data Types

4-106

4-113
4-114

Global Variables

Text Utilities

4-108

4-108

Assembly-Language Summary
‘Trap Macros
4-119

Chapter 5

— 4-90

4-119

4-120

= 5-1

About the Text Utilities
5-3
The Text Utilities and the International Resources
Obtaining Resource Information
5-4
Pascal Strings and Text Strings
5-6
Using the Text Utilities
5-7
Defining Strings
5-8
Working With String Handles — 5-8
Working With String Resources
= 5-9

Sorting Strings in Different Languages — 5-9
Sorting Strings in the Same Language
5-12
Primary and Secondary Sorting Order
5-12
Expansion and Contraction of Characters
5-14
Ignorable Characters
5-14
Converting and Stripping Characters
5-14
Special Cases for Sorting
5-14
Variations in Sorting Behavior
5-15
Choosing a Comparison Routine
5-15
Testing Two Strings for Equality
5-17
Comparing Two Strings for Ordering
5-18
Modifying Text
5-18
Converting Characters and Stripping Marks in Strings
Fitting a String Into a Screen Area
5-19
Replacing a Portion of a String
5-21
Finding Word, Line, and Script Run Boundaries

5-19

5-23

Finding Word Boundaries — 5-23
Finding Line Breaks
5-24
Finding Subscripts Within a Script Run — 5-28
Working With Date and Time Strings
—5-29
Converting Formatted Date and Time Strings
Into Internal Numeric Representations
5-31
Date and Time Value Representations
5-34
Converting Standard Date and Time Values Into Strings
5-34
Working With Numeric Strings
5-35
Converting Between Integers and Numeric Strings
5-38
Using Number Format Specification Strings
5-39
Converting Number Format Specification Strings Into Internal
Numeric Representations
5-43
Converting Between Floating-Point Numbers and Numeric
Strings
5-43
Text Utilities Reference
5-44
Data Structures
5-44
Routines
5-47
Defining and Specifying Strings
5-47
Comparing Strings for Equality
5-50
Determining Sorting Order for Strings in Different Languages
5-54
Determining Sorting Order for Strings in the Same Language
5-59
Modifying Characters and Diacritical Marks
5-64
Truncating Strings
5-71
Searching for and Replacing Strings
5-74
Working With Word, Script, and Line Boundaries

Converting
Converting
Converting
Converting

5-77

Date and Time Strings Into Numeric Representations
Numeric Representations Into Date and Time Strings
Long Date and Time Values Into Strings
—_5-89
Between Integers and Strings
5-91

5-82
5-86

xi

Using Number Format Specification Strings for International Number
Formatting
5-94
Converting Between Strings and Floating-Point Numbers — 5-98
Summary of Text Utilities
5-102
Pascal Summary
5-102
Constants
5-102
Data Types
5-103
Routines
5-104
C Summary
5-107
Constants
5-107
Types
5-109
Routines
5-110
Assembly-Language Summary
5-113
‘Trap Macros
5-113

Chapter 6

Script Manager

6-1

About the Script Manager
6-3
The Script Manager and the Script Management System
6-4
The Script Manager and Applications
6-4
Evolution of the Script Manager
6-6
Using the Script Manager
6-7
Testing for the Script Manager and Script Systems
6-8
Controlling Settings
6-10
Checking and Setting the System Direction
6-10
Checking and Setting Script Manager Variables
6-11
Checking and Setting Script Variables
6-13
Making Keyboard Settings
6-17
Synchronizing the Font Script and Keyboard Script
6-19
Obtaining Information
6-21
Determining Script Codes From Font Information
6-21
Analyzing Characters
6-26
Directly Accessing International Resources
6-31
Using Currency, Number, and Date Formats — 6-33
Using Number Parts
6-34
Retrieving Text From Tokens
6-35
Using Word-Break Tables
6-37
Using Whitespace Information
6-37
Converting Text
6-37
Tokenization
6-38
Transliteration
6-43
Modifying Script Systems
6-48
Replacing a Script System’s Default International Resources
Replacing a Script System’s Default Routines
—6-50

xii

6-48

Script Manager Reference
6-52
Constants
6-52
Script Codes
6-52
Language Codes
6-54
Region Codes
6-57
Token Codes
6-58
Selectors for Script Manager Variables
6-61
Selectors for Script Variables
6-65
Data Structures
6-73
Token Block Record
6-74
Token Record
6-74
Routines
6-75
Checking and Setting the System Direction
6-76
Checking and Setting Script Manager Variables
6-77
Checking and Setting Script Variables
6-78
Making Keyboard Settings
6-80
Determining Script Codes From Font Information

Analyzing Characters
6-84
Directly Accessing International Resources
Tokenization
Transliteration

6-92
6-98

Replacing a Script System’s Default Routines
Summary of the Script Manager _—_ 6-107
Pascal Summary
6-107
Constants
6-107
Data Types
6-121
Routines
6-122
C Summary
6-124
Constants
6-124
Data Types
6-124
Routines
6-125
Assembly-Language Summary
6-127
Trap Macros
6-127
Global Variables
6-127

Chapter 7

Text Services Manager

6-81

6-89

6-101

= 7-1

About Text Services
7-6
About Input Methods
7-6
About the Text Services Manager
= 7-9
The Text Services Environment
7-9
The Text Services Manager and Input Methods
Inline Input
7-11
Floating Input Windows
7-13
Floating Utility Windows
7-14
About Text Service Components
7-14

7-11

xiii

Using the Text Services Manager (for Client Applications)

7-17

Testing for the Availability of the Text Services Manager

7-17

Calling the Text Services Manager
= 7-17
Initializing as a TSM-Aware Application
7-18
Creating a TSM Document
7-18
Making Text Services Available to the User
7-20
Activating and Deactivating a TSM Document
7-20
Passing Events, Menu

Selections, and Cursor Setting

7-21

Confirming Active Text Within a TSM Document
7-23
Deleting aTSM Document
—_7-24
Closing Down as a TSM-Aware Application
= 7-24
Requesting a Floating Input Window for Text Entry
7-24
7-25
Associating Input Methods With Scripts and Languages
Handling Text Service Apple Events
7-25
Receiving Text and Updating the Active Input Area
7-26
Converting Screen Position to Text Offset = 7-29
Converting Text Offset to Screen Position
7-32
Showing or Hiding the Input Window
7-36
Direct Access to Text Service Components
7-36
Calling the Component Manager
7-36
Calling Text Service Components
7-37
7-37
Using the Text Services Manager (for Text Service Components)
Providing Menus and Icons
7-38
Providing a Text Service Component Menu
7-38
Providing Input Method Icons for the Keyboard Menu
7-39
Responding to Calls
7-40
Initiating a Text Service
7-41
Activating Text Service Component Windows
7-41
7-41
Responding to Events and Updating the Cursor and Menu
Confirming Active Text Input
7-42
Closing a Text Service
7-42
Identifying the Supported Scripts and Languages
7-42
Making Calls
7-44
Sending Apple Events to Client Applications
7-44
Opening Floating Utility Windows
7-48
Text Services Manager Reference
7-48
Text Services Manager Routines for Client Applications
—_ 7-48
Initializing and Closing as a TSM-Aware Application
7-49
Creating and Activating TSM Documents
7-50
Passing Events to Text Service Components
7-54
Passing Menu Selections and Cursor Setting = 7-55
Confirming Active Input ina TSM Document
7-56
Making Text Services Available tothe User
—7-57
Requesting a Floating Input Window
7-61
Associating Scripts and Languages With Components
7-62

xiv

Apple Event Handlers Supplied by Client Applications
7-65
Creating and Updating an Active Input Area
7-68
Converting Global Coordinates to Text Offsets
7-72
Converting Text Offsets to Global Coordinates
7-74
Showing or Hiding the Floating Input Window
7-76
Text Services Manager Routines for Components
7-77
Sending Apple Events to a Client Application
7-77
Opening Floating Utility Windows
7-79
Text Service Component Routines
7-84
Providing a Text Service
7-84
7-87
Responding to Events and Updating the Cursor and Menu
Confirming Active Input in a TSM Document
7-89
Identifying the Supported Scripts and Languages
7-90
Summary of the Text Services Manager
7-92
PascalSummary
7-92
Constants
7-92
Data Types
7-94
7-95
Text Services Manager Routines for Client Applications
Text Services Manager Routines for Components
7-97
Text Service Component Routines
7-97
C Summary
7-98
Constants
7-98
Data Types
7-101
Text Services Manager Routines for Client Applications
7-102
Text Services Manager Routines for Components
7-104
Text Service Component Routines
7-104
Assembly-Language Summary = 7-105
Trap Macros
7-105
Result Codes
7-107

Chapter 8

Dictionary Manager

8-1

About Dictionaries for Input Methods
8-3
About the Dictionary Manager _— 8-4
The Structure of a Dictionary
8-5
Garbage Data
8-8
Dictionary Manager Limitations
8-10
Using the Dictionary Manager
8-11
Testing for the Presence of the Dictionary Manager _— 8-11
Making a Dictionary
8-11
Creating the File
8-12
Constructing the Dictionary
8-13
Accessing a Dictionary
8-13
Opening and Closing the Dictionary
8-13
Obtaining Information About the Dictionary
8-14

Locating Records in a Dictionary
8-15
Locating Records by Key
8-15
Locating Records by Index _— 8-17
Modifying a Dictionary
8-18
Compacting a Dictionary
8-20
Dictionary Manager Reference
8-20
Data Structures
8-20
Routines
8-20
Making a Dictionary
8-20
Accessing a Dictionary
8-22
Locating Records in a Dictionary
8-26
Modifying a Dictionary
8-30
Compacting a Dictionary
8-33
Summary of the Dictionary Manager
8-34
Pascal Summary
8-34
Constants
8-34
Data Types
8-34
Routines
8-35
C Summary
8-36
Constants
8-36
Data Types
8-37
Routines
8-37
Assembly-Language Summary — 8-39
‘Trap Macros
8-39
Result Codes
8-39

Appendix A

Built-in Script Support

= 4-1

The Roman Script System
A-4
The Standard Roman Character Set
Nonprinting Characters
A-6
Printing Characters
A-8
Variations in the Character Set

A-4

A-16

The U.S. Keyboard-Layout ("KCHR’) Resource

A-19

Standard Sorting Routines
A-20
Diacritical Stripping and Case Conversion
A-23
U.S. International Resources and Keyboard Resources
A-23
WorldScriptI] = A-25
About WorldScriptI
= A-25
Shared Script Utilities and QuickDraw Patches
A-25
Table-Based Script Behavior
A-27
Contextual Formatting Routines = A-27
Flexible Dispatching Method
<A-28
Initialization Sequence
A-28
How Calls Are Dispatched
= A-29

xvi

Saving User Preferences
A-31
Replacing a Script Utility or QuickDraw Patch
A-32
Patching Script Utilities
A-33
Patching QuickDraw Routines
A-34
Issues in Designing a Script Utility or QuickDraw Patch
WorldScript II
A-36
About WorldScript I
A-36
Shared Script Utilities
A-37
Table-Based Script Behavior
A-38
Initialization Sequence
A-38
How Calls Are Dispatched
A-39

Appendix B

International Resources

A-35

_—~&B1

About the International Resources
B-4
What the International Resources Are
B-4
Script Codes and Resource ID Ranges
__B-6
Using the International Resources
_—_—B-8
International Configuration Resource (Type ‘itlc’)
B-9
The ItlcRecord Data Type
B-10
Script-Sorting Resource (Type ‘itlm’)
B-12
International Bundle Resource (Type ' itlb’)
B-17
The ItlbRecord Data Type
B-18
The ItlbExtRecord Data Type
B-20
Numeric-Format Resource (Type ‘itl0’)
B-22
The IntlORec Data Type
B-23
Long-Date-Format Resource (Type ‘it1’)
B-28
The Intl1Rec Data Type
B-28
The Itl1ExtRec Data Type
B-31
String-Manipulation Resource (Type ‘itl2')
B-34
Resource Header
B-35
The ‘itl2' Sorting Hooks
B-37
The ‘itl2' Tables
B-39
Script Run Table Format — B-40
Supplying Custom Sorting Routines
B-43
Supplying Custom Word-Break Tables
B-44
NBreakTable Format
_—__B-44
How FindWordBreaks Uses the Break Table
B-49
Tokens Resource (Type ‘itl4’)
B-50
The NItl4Rec Data Type
B-51
The Token Table
B-53
The Extension-Fetching Routine
B-54
The Token-String Copy Routine
B-54
The Untoken Table
B-54
The Number Parts Table
B-55
The Whitespace Table
B-58
xvii

Encoding / Rendering Resource (Type 'itl5')
B-58
Resource Header
B-59
Tables for 1-Byte Script Systems
B-60
Script Configuration Table —_ B-60
Line-Layout Metamorphosis Table
—_B-63
Line-Layout Glyph-Properties Table
—_B-64
Character Expansion Table
B-64
Glyph-to-Character Table
—_B-65
Break-Table Directory
B-66
Script Run Tables
B-67
Kashida Preferences Table
B-68
Feature List Table
B-68
Reordering Table
B-68
Tables for 2-Byte Script Systems
B-68
Byte-Type Table
B-69
Character-Type Table
B-69
Transliteration Resource (Type ‘trsl’)
B-70
Resource Header
B-71
Rule-Based Format — B-72
Table-Based Format
—_B-73
Summary of the International Resources
B-74
PascalSummary _ B-74
Constants
B-74
Data Types
B-75
C Summary
B-80
Constants
B-80
Data Types
B-82

Appendix C

Keyboard Resources

C1

About Keyboards
C-4
About the Keyboard Resources
C-6
What the Keyboard Resources Are
C-7
Key Translation
C-8
Using the Keyboard Resources
C-10
Key-Map Resource (Type 'KMAP’)
C-11
Apple Extended Keyboard
C-13
Reassigning Right-Hand Key Codes
C-14
Other Hardware Dependencies
C-14
Virtual Key Codes for Non-ADB Keyboards
= =-C-15
Key-Remap Resource (Type ‘itlk’)
C-16
Keyboard-Layout Resource (Type 'KCHR’)
C-18
Resource Format
C-18
The KeyTranslate Function and the Keyboard-Layout Resource

xvill

C-19

Special Uses for the KeyTranslate Function
C-22
Installing a Custom Keyboard-Layout Resource
C-22
Using KeyTranslate for Command-Key Equivalents
= _C-23
Keyboard Icon Family (Types 'kcs#', 'kcs4’, 'kcs8')
C-25
Keyboard-Swap Resource (Type 'KSWP’)
C-26
Key-Caps Resource (Type 'KCAP’)
C-28
Resource Format
C-28
Key Caps Desk Accessory
C-32
Summary of the Keyboard Resources
= C-35
Assembly-Language Summary
C-35
Global Variables
C-35

Appendix D

Renamed

and Relocated Text Routines

Glossary

Index

p-1

GL

—IN-1

xix

Figures, Tables, and Listings

Chapter 1

Introduction to Text on the Macintosh
Figure 1-1
Figure 1-2

Figure 1-3
Figure 1-4
Figure 1-5

Figure 1-6

1-1

Separation of input, storage, and display in Macintosh

text handling
1-4
How QuickDraw draws text

1-6

Bytes, character codes, characters, and glyphs
Four bytes displayed in Japanese and in English
Storage order and display order
1-10

1-8
1-9

Figure 1-8

Style runs in text
1-11
Key translation (simplified)
1-12
Key Caps display of Thai keyboard layout (no modifier

Figure 1-9

Key Caps display of Cyrillic keyboard layout (Caps Lock

Figure 1-7

keys pressed)
key pressed)

1-13

1-13

Figure 1-10

TextEdit edits and displays mixed-directional text in a
dialog box
1-17

Figure 1-11

Writing-system examples

Figure 1-12

Words with alphabetic, syllabic, and ideographic
characters
1-22

Figure 1-13

Thai character cluster

1-23

Figure 1-14
Figure 1-15

Line directions in text
Text alignment
1-25

1-24

Figure 1-16

Justification through interword (Hebrew) and intercharacter
(Japanese) spacing
1-25

Figure 1-17

Justification with Arabic extension bar characters

Figure 1-18

Contextual forms in cursive English
1-26
Standalone and contextual forms in Arabic

Figure 1-19

1-22

1-26

1-27

Figure 1-20

A ligature in Roman text

1-27

Figure 1-21

A ligature in Arabic text

1-27

Figure 1-22

Figure 1-23

A complex ligature in Arabic text
1-28
Character reordering in the Devanagari writing system

Figure 1-24

Arabic text with diacritical mark to specify extra emphasis

Figure 1-25
Figure 1-26

Vowel marks in Hebrew text

on a consonant

1-29

1-29

Figure 1-27

Word demarcation in the Roman writing system
Line breaking in a bidirectional writing system

Figure 1-28

Word demarcation in Japanese

1-30
1-31

1-31

xxi

Figure 1-29
Figure 1-30
Figure 1-31

text display

1-36

Figure 1-32
Figure 1-33

Types of script systems

Figure 1-34

The script, language, and region hierarchy

Figure 1-35

Distinguishing scripts by resource ID range (for script

1-47

How the script management system handles different types

of scripts

1-48

codes 0-32)

1-49

1-50

Figure 1-36

The Standard Roman

Figure 1-37

Character encodings for 1-byte script systems

Figure 1-38
Figure 1-39

character set

1-55

1-57

Character encoding for a 2-byte script system (Japanese)
in Korean

1-60

Storage order and display order

Figure 1-41
Figure 1-42

How primary line direction affects display order

1-67

Dialog items truncated at dialog-box boundary

1-69

Figure 1-43

Style runs, font runs, script runs, and direction runs in text
Caret position and insertion point
1-75

1-66

Caret positions at direction bondaries

1-76

Figure 1-46

Dual caret at direction boundaries in
mixed-directional text
1-78

Figure 1-47

Single carets at direction boundaries in
mixed-directional text
1-79

Figure 1-48
Figure 1-49
Figure 1-50

Highlighting a selection range in unidirectional text
1-80
Highlighting a selection range in mixed-directional text
1-81
Interpreting caret position from a mouse-down event
1-83
Mouse-down regions and caret positions in
mixed-directional text
1-84

Figure 1-51

Figure 1-52
Figure 1-53

Apple Keyboard

Figure 1-54
Figure 1-55

Font script and keyboard script synchronization
1-90
Bottomline input window for Japanese input method
1-92

Figure 1-56

Active input area (underlined) for inline input

Figure 1-57

Bottomline input in Korean

Figure 1-58

Filenames and dates in Arabic and U.S. formats
(Arabic system script)
1-96

Figure 1-59
Figure 1-60

System-script components in the System Folder

Key translation

II (domestic layout)

1-89

Menu bar with keyboard icon

Figure 1-64

Text control panel

Figure 1-65
Figure 1-66

Numbers control panel
Date & Time control panel

Figure 1-68

1-108
1-109
1-110

Date Formats dialog box (from Date & Time

control panel)

1-110

Time Formats dialog box (from Date & Time
control panel)

1-111

1-92

1-105

Keyboard icons and input-method icons
Keyboard menu
1-106
Arabic Key Caps
1-107

Figure 1-67

1-87

1-93

Figure 1-62
Figure 1-63

Figure 1-61

1-59

Constructing blocks (Hangul) from elements (Jamo)

Figure 1-40

Figure 1-44
Figure 1-45

XXii

Selected valid styles in various writing systems
1-32
Standard international formats
1-33
Components of the script management system for

1-105

1-102

1-71

Table 1-1
Table 1-2

Chapter 2

The international resources
The keyboard resources

1-41
1-43

Figure 2-1

Style runs in a line of text

2-8

Figure 2-2

Mixed-directional text display

Figure 2-3
Figure 2-4

Discontinuous highlighting display
2-10
Outline highlighted text selection in background window

Figure 2-5
Figure 2-6
Figure 2-7

Caret movement across a direction boundary
2-12
Destination and view rectangles
2-16
Relationship between the TextEdit data structures for

TextEdit

2-1

Figure 2-8

monostyled text
2-19
Relationships among the TextEdit data structures for
multistyled text
2-20

Figure 2-9
Figure 2-10
Figure 2-11

Cutting text from a multistyled edit record
2-40
Continuous attributes over a selection range
2-44
An initial selection before TESet Sty1e is called
2-46

Figure 2-12
Figure 2-13

The result of calling
The result of calling

Figure 2-14

Determining when to use WIDTHHook

Figure 2-15

The TextEdit data structures and fields

Listing 2-1
Listing 2-2

Using TEText
Box to draw static text
A sample document record
2-25

TESet Style
TESet Style

to toggle to bold
to toggle italics

and nWIDTHHook

2-24

Creating a multistyled edit record
An idle-processing procedure

Listing
Listing
Listing
Listing

Passing a mouse-down event to TextEdit
2-35
Inserting text in a document
2-37
Getting the selection range length
2-38
Handling Cut, Copy, and Paste commands on an
Edit menu
2-41
Determining the font, style, size, and color of the current
selection range
2-45

2-28
2-33

Listing 2-10

Handling the Font menu

Listing 2-11

Handling the Size menu

2-48

Listing 2-12

Handling a Style menu

2-48

Listing 2-13

Checking the style and marking Style menu items to reflect
the current selection range
2-50
Saving a multistyled text edit record to disk
2-52
Restoring a document that uses multistyled TextEdit
2-54
Checking for 2-byte characters when backspacing
2-56

Listing 2-14
Listing 2-15
Listing 2-16

QuickDraw Text

2-59

2-66

Listing 2-3

2-5
2-6
2-7
2-8

2-11

2-46
2-47

Listing 2-4

Listing 2-9

Chapter 3

2-8

2-47

3-1

Figure 3-1
Figure 3-2

Stylistic variations
3-7
Effect of the basic transfer modes for

Figure 3-3

Multiple style runs on a single line

black-and-white images

3-9

3-11

Xxili

Figure 3-4

Figure 3-5
Figure 3-6
Figure 3-7
Figure 3-8
Figure 3-9
Figure 3-10
Figure 3-11

style run

3-37

Calling VisibleLength for a Hebrew style run

3-38

Calling VisibleLength for Hebrew text with Roman

space characters
3-38
What pixel position means for CharToPixel
PixelToChar
3-48

and

Caret position for a leading-edge mouse-down

event

event at a

Figure 3-13

Caret position for a trailing-edge mouse-down
direction boundary
3-54

event at a

Table 3-1
Table 3-2
Listing 3-1

3-50

Caret position for a trailing-edge mouse-down event
3-51
Caret position for a leading-edge mouse-down event at a direction
boundary
3-52
Caret position for a trailing-edge mouse-down
direction boundary
3-53

Figure 3-15

Caret position for a mouse-down event beyond the last glyph of

the text segment

3-55

Highlighting mixed-directional text

3-60

Effects of the basic transfer modes
3-71
Transfer mode constants and selectors
3-73
Using QuickDraw to set the graphics port

Listing 3-2

text-related fields
3-20
Calling StyledLineBreak to identify where to break the

Listing 3-3

An application-defined run direction function called by

Listing 3-4

Determining the style run display order and drawing
the line
3-36

text line

3-31

Get FormatOrder

3-35

Listing 3-5

Distributing slop value among

Listing 3-6

Calling Get Font Info to determine the line height
3-43
Turning off reordering of right-to-left text before calling

Listing 3-7
Listing 3-8
Listing 3-9
Listing 3-10
Listing 3-11

Font Manager
Figure 4-1
Figure 4-2

style runs

PixelToChar for line-breaking

3-41

3-45

Using StdTxMeas to get the font metrics for determining the line
height of scaled text
3-46
Drawing the caret and highlighting a selection range
3-55
Generating a picture file with font information
3-64
A picture file with font information
3-64

4-1
Terms for font measurements

4-9

The ascent line and maximum y-value

4-11

Figure 4-3

Unkerned text (top) and kerned text (bottom)

Figure 4-4
Figure 4-5

A comparison of scaled bitmapped and outline fonts

Figure 4-6
Figure 4-7

Figure 4-8
Figure 4-9

XXiV

3-14

Calling VisibleLength for a Roman

Figure 3-12

Figure 3-14

Chapter 4

Justification of Roman text

4-12

A glyph stretched horizontally
4-20
A glyph stretched vertically
4-21
A glyph condensed horizontally
4-21
The effect of an off-curve point on two Bézier curves
An outline with points on and off the curve

4-27

4-19

4-26

Figure 4-10
Figure 4-11
Figure 4-12

A curve with consecutive off-curve points
4-28
A glyph from an outline font
4-29
An unmodified glyph from an outline font at a small

Figure 4-13

An instructed glyph from an outline font

Figure 4-14
Figure 4-15

A sample Size menu and font size dialog box
The difference between a scaled glyph and a

Figure 4-16

The bitmapped font ('NFNT') resource

Figure 4-17

The font directory

Figure 4-18

A glyph description

Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure

The font header table
4-79
The horizontal metrics table
4-83
The naming table
4-85
The font family ('FOND') resource
4-91
Style codes
4-95
The font association table
4-95
The offset table
4-96
The bounding-box table
4-97
The font family glyph-width table
4-98

4-19
4-20
4-21
4-22
4-23
4-24
4-25
4-26
4-27

4-30

preserved glyph

4-32

4-67

4-74
4-78

The style-mapping table

Figure 4-29

The font family kerning table

Figure 4-30

A kerning pair entry

Table 4-1

Subdivisions of Roman font family IDs

Table
Table
Table
Table

Platform identifiers
4-86
ISO platform-specific identifiers
ISO language codes
4-87
Font name identifiers
4-88

4-2
4-3
4-4
4-5

4-31

4-36

Figure 4-28

4-100

4-106

4-107
4-14

4-87

Listing 4-1

Checking a font name against the system font name

Listing 4-2

Calculating the checksum of a given table

Listing 4-3

Calculating the checksum of a font

Listing 4-4

Chapter 5

point size

Text Utilities

4-33

4-76

4-81

Using the style-mapping table to build a PostScript

font name

4-103

5-1

Figure 5-1

Determining the current script

Figure 5-2

A string containing 1-byte and 2-byte characters

Figure 5-3
Figure 5-4

Strings in different languages in one list
5-11
Strings in different languages sorted by script

Figure 5-5

Strings in different languages sorted by language
within script
5-12

Figure 5-6
Figure 5-7
Figure 5-8

Choosing a string comparison routine
5-16
Truncating a pathname in its middle
5-20
Replacing a portion of a string with 1-byte and 2-byte
characters
5-21
Finding line breaks in multiscript text
5-25
Relationships of the parameters of StyledLineBreak

Figure 5-9
Figure 5-10

5-5
5-7

5-11

5-26

XXV

Figure 5-11
Figure 5-12

Extracting blocks of Roman text
5-28
Using the number formatting routines
5-37

Table 5-1

Excerpt from the Standard Roman
sorting order
5-13

Table 5-2
Table 5-3

Sorting features of the Macintosh file system
5-17
Variations in time and short date formats
5-29
Variations in long and abbreviated date formats
5-30

Table 5-4
Table 5-5
Table 5-6

StringToDateStatus values and their meanings
FormatResultType values for numeric conversion
functions
5-38

Table 5-7
Table 5-8

Numeric string formats
5-39
Examples of number format specification strings

Table 5-9

Literals in number format strings

Table 5-10
Table 5-11

Filling digits in

Table 5-13

Implicit language codes
Using the NewString

Listing 5-2
Listing 5-3

Truncating a pathname

Substituting and truncating text

5-22

Listing 5-4

Using the StyledLineBreak

function

Listing 5-5

Using StringToDate and StringToTime
Converting a long integer into a numeric string

Figure 6-4

5-42

5-55

Listing 5-1

Figure 6-1
Figure 6-2
Figure 6-3

5-40

5-41

Table 5-12

Script Manager

and

Set String

routines

5-8

5-20
5-27

5-31
5-39

6-1
Determining script code from font family ID

6-23

Fields in the CharacterType

return value

6-28

The action of Int 1Tokenize
6-39
Int1Tokenize data structures (simplified)

6-40

Figure 6-5
Figure 6-6

The effects of transliteration

Figure 6-7

Style code format

Table 6-1
Table 6-2

Evolution of the Script Manager
6-6
Version numbers for the Script Manager and Roman

Table 6-3

Table 6-4

6-45

Dispatch table entry for script utilities and QuickDraw
patches
6-51

6-73

script system
6-9
Script Manager variables accessed through
GetScriptManagerVariable/
SetScriptManagerVariable
6-11

Script variables accessed through

GetScriptVariable/SetScriptVariable

6-14

Table 6-5

Constants for the code parameter in the KeyScript
procedure
6-18

Listing 6-1

Specifying adualcaretwith SetScriptManagerVariable
Representing font names correctly in the script for that font

Listing 6-2

XXxvi

5-33

5-42

Quoting mechanisms in number format strings
Symbols in number format strings
5-43

Listing 5-6

Chapter 6

script system

6-13
6-16

Listing 6-5

Setting the size of the Balloon Help font
6-16
Setting the keyboard script from the font script
Setting the font (script) from the keyboard script

Listing 6-6
Listing 6-7

Handling 2-byte characters in a search procedure
6-27
Determining the number separators for the current script

Listing 6-8

Getting number parts from a script system’s number

Listing 6-9

Getting a token string from the untoken table

Listing 6-3
Listing 6-4

Chapter 7

parts table

Bottomline input with a floating input window

Figure 7-2

Inline input

Figure 7-3

Displaying conversion options for bottomline input

Figure 7-4

How a TSM-aware client application uses the Text

7-7

7-7

Services Manager

7-8

7-10

Entering, converting, and confirming text in an active

input area

7-12

How a non-TSM-aware application uses the Text

Services Manager

7-13

Figure 7-7

Floating window service layer

Figure 7-8

The format of the

Figure 7-9

6-36

7-1

Figure 7-1

Figure 7-6

description record

7-14

component Flags

field of the component

7-16

Drawing a window with conversion options next to the active

input area

7-33

Figure 7-10

Input method icons in the Keyboard menu and menu bar

Figure 7-11

Updating text in an active input area

Table 7-1

Apple event ID constants
7-66
Apple event keyword constants

Table 7-2
Table 7-3
Table 7-4

Apple event descriptor types

Initializing as

Listing 7-2

Creating

Listing 7-3
Listing 7-4

Activating and deactivating

Listing 7-6
Listing 7-7
Listing 7-8
Listing 7-9
Listing 7-10
Listing 7-11

7-40

7-69

7-66

7-67

Apple event descriptor type constants for the Apple event
region class
7-67

Listing 7-1

Listing 7-5

6-33

6-34

Text Services Manager

Figure 7-5

6-20
6-21

a window

a TSM-aware application

7-18

anew TSM document and associating it with
7-19

a TSM document

7-21

Passing events to a text service component
7-22
Confirming text in an active input area
7-23
Closing a TSM-aware application
7-24
A sample handler for the Update Active Input Area
Apple event
7-26

A sample handler for the Position To Offset Apple event
A sample handler for the Offset To Position Apple event
Determining the script and language for a text service
component
7-43

7-30
7-33

Constructing and sending an Update Active Input Area
Apple event
7-45

XXVIi

Chapter 8

Appendix A

Dictionary Manager

8-1

Figure 8-1
Figure 8-2
Figure 8-3

General format of a dictionary record

8-5

Format of data associated with a key

8-6

Figure 8-4

A simple dictionary with no garbage data

Figure 8-5
Figure 8-6
Figure 8-7

Creating garbage data in a dictionary
Deleting garbage data from a dictionary
The requested attributes table

Table 8-1
Table 8-2

Sample data returned by FindRecordInDictionary
Defined attribute types for dictionary entries
8-27

Listing 8-1
Listing 8-2

Creating a dictionary file
8-12
Opening and closing a dictionary file

Listing 8-3

Obtaining information about a dictionary

Listing 8-4
Listing 8-5

Displaying all records in a dictionary by index

Format of an entry in the data associated with a key

Inserting a record into a dictionary

Built-in Script Support

8-9

8-10

8-16

8-15
8-17

8-19

= A-1

The Standard Roman

Dispatch table entry for script utilities and QuickDraw

Figure A-4

8-16

8-13

Figure A-2

patches

8-7

8-8

Figure A-1

Figure A-3

character set

A-5

A-29

How calls are dispatched to the 1-byte script utilities
A-30
How calls are dispatched to the 1-byte QuickDraw patches

A-31

Table A-1

Nonprinting characters in the Standard Roman character
set
A-6

Table A-2

Low-ASCIll characters to avoid as delimiters

Table A-3
Table A-4

Printing characters in the Standard Roman character set

A-9

Croatian variations from the Standard Roman
character set
A-16
Romanian variations from the Standard Roman
character set
A-17
Turkish variations from the Standard Roman character set

A-18

Table A-5
Table A-6
Table A-7

Table A-8
Table A-9
Table A-10
Table A-11
Table A-12
Table A-13
Table A-14
Table A-15

XXVili

_

A-7

Icelandic and Faroese variations from the Standard Roman
character set
A-18

Standard sorting order (for Standard Roman

character set)
A-20
International resources in U.S. system software
Keyboard resources in U.S. system software

A-23
A-24

Script utilities supported by WorldScript |
A-26
QuickDraw patches supported by WorldScript |
A-27
Classification of 1-byte script utilities by function
A-33
Classification of 1-byte QuickDraw patches by function
Script utilities supported by WorldScript II

A-37

A-35

Appendix B

International Resources
Figure B-1

Format of the script-sorting resource header

Figure B-2

Script, language, and region data tables in the script-sorting
resource
B-14

Figure B-3

Examples of long date formatting

Figure B-4

Format of the string-manipulation resource header

B-36

Figure B-5

Format of the script run table header (new format)

B-41

Figure B-6

Script run table state table

Figure B-7
Figure B-8

Format of a script run table action code
Format of the script run table return table

Figure B-9

NBreakTable

Figure B-10

Format of an NBreakTable

Figure B-11
Figure B-12
Figure B-13

Forward operation of the state machine for word selection
Format of the token table
B-53
Format of the whitespace table
B-58

Figure B-14

Format of the script configuration table

Figure B-15

Format of the character expansion table

Figure B-16

Format of the glyph-to-character table

Figure B-17

Format of the break-table directory

Figure B-18

Format of the transliteration resource header

Figure B-19

Format of a transliteration rule

Table B-1

The international resources

Table B-2

Resource ID ranges for each script system

B-6

Table B-3

Sorted scripts, languages, and regions from a

script-sorting

Table
Table
Table
Table
Table

B-4
B-5
B-6
B-7
B-8

Table B-9

Appendix C

__B-1
B-13

B-31

B-42

state table

B-43
B-43

B-47
action code

B-47

B-50

B-61

B-64
B-65

B-66
B-71

B-72

B-4

resource
B-15
Constants for specifying numeric separators
B-23
Separator positions in long date format
B-31
Example of classes for an NBreakTable state table
B-48
Example of states for an NBreakTable state table
B-48
A script configuration table for a Hebrew encoding/rendering
resource

B-62

Sample encoding/rendering resource for a 2-byte
script system
B-68

Keyboard Resources’

C-1

Figure C-1

Apple Keyboard II (domestic layout)

Figure C-2

Apple Extended Keyboard II (domestic layout)

C-5

Figure C-3

The key translation process

Figure C-4

Format of the key-map resource

Figure C-5

Format of an entry in the key-remap resource

Figure C-6

Format of the keyboard-layout resource

C-5

C-10

C-12
C-17

C-19

Figure C-7

Inside the keyboard-layout resource

Figure C-8

Sample keyboard icons

C-21

Figure C-9

Format of entries in the keyboard-swap resource

Figure C-10
Figure C-11

Format of the key-caps resource
C-29
Shape array and resulting region for the Return key

Figure C-12

Key Caps display with key origins

C-26
C-26

C-32

C-33

Xxix

Figure C-13
Figure C-14

Key Caps display of dead keys with Option key pressed
C-33
Key Caps display of completer keys after circumflex dead key has
been pressed
C-34

Table C-1
Table C-2
Table C-3

The keyboard types
C-4
The keyboard modifier bits in an event record
C-6
The keyboard resources
C-7
Key-map resource assignment of raw key codes to virtual
key codes
C-13
Reassigning right key codes for Shift, Option, and
C-14
Control keys
ADB and non-ADB virtual key codes for cursor keys and
keypad keys
C-15
Virtual key codes for the international Macintosh Plus
keyboard
C-16

Table C-4
Table C-5
Table C-6
Table C-7

Appendix D

Table C-8

Keyboard color icon types and standard icon equivalents

Listing
Listing
Listing
Listing

Loading a non-system keyboard-layout resource
C-22
Regenerating a character code with KeyTranslate
C-24

C-1
C-2
C-3
C-4

Renamed
Table D-1

XXX

A hypothetical keyboard-swap resource

C-27

Sample key-caps resource data in Rez format

and Relocated Text Routines
Renamed,
routines

C-31

D-1

relocated, and obsolete text and international
D-4

C-25

PREFACE

About This Book
Among personal computers, the Macintosh computer is foremost in the areas
of desktop publishing, page layout, high-end graphical word processing, and
international text presentation. The Macintosh computer’s capabilities in these
areas is due in large part to its unique and powerful support for text handling.
Inside Macintosh: Text describes how you can use that support to put superior
text capabilities into your software.
This book documents the parts of Macintosh system software that allow you
to generate and manipulate text, including text in multiple languages. It
includes introductory material on the Macintosh approach to text handling, as
well as a complete technical reference to each of the text-handling managers in
the system software.

What to Read
Whatever your text needs are, you should first read the chapter “Introduction
to Text on the Macintosh.” It describes Macintosh text concepts, outlines the
kinds of text features addressed by the system software, and describes the
organization and workings of script systems—collections of resources that
give the Macintosh its multiple-language text capabilities.
If your text-handling needs are minor, the only other chapter you may need to
read is “TextEdit,” which describes a simple, multiple-language
text-processing service provided by Macintosh system software. TextEdit is
used by the system software to present text and accept user input in
dialog boxes and alerts, and its capabilities are available for your application
to use as well.
If you are planning a text-handling application with capabilities beyond those
of TextEdit, read the remaining chapters of this book in any order.
“QuickDraw Text” describes how to lay out and draw text to the screen or
printer. “Font Manager” describes how to access Macintosh fonts and specify
text characteristics. “Text Utilities” describes a collection of text-handling
routines that allow you to specify, sort, format, search, and otherwise

manipulate text strings. “Script Manager” describes how to access and
manipulate script systems.
If you want your application to work efficiently with Japanese, Korean, or
Chinese text input, or if you are designing an input method for those
languages, read the chapter “Text Services Manager.” It describes how to make
your application work with multiple input methods in multiple languages,
and how to create an input method that provides multiple-language input for

XXX1

PREFACE

any application. If you are creating an input method, read also the chapter
“Dictionary Manager” to find out how to
create and use input dictionaries that are portable across input methods
and applications.
If you are planning to add specific language capabilities to an application, or
need to modify the system software’s text-handling for a given language, read
the chapter “Script Manager” and the appendixes “Built-in Script Support,”
“International Resources,” and “Keyboard Resources.” They describe the
organization of script systems on the Macintosh, and show you how to modify
parts of a script system in order to obtain the exact text-handling
characteristics you need.
If you are designing a font or a font editor, read the parts of the chapter “Font
Manager” that describe the data structures and tables that make up Macintosh
fonts. In addition, you will need information contained in the TrueType Font
Format Specification, available from APDA.
If you are already familiar with Macintosh system software and with previous
versions of Inside Macintosh, you may notice that in this book the organization
of some managers and the names of some routines have changed. You can
refer to the appendix “Renamed and Relocated Text Routines” for information
on how the new organization and terminology relate to previous
presentations.

Format of a Typical Chapter
Most chapters in this book follow a standard structure. For example, the
chapter “TextEdit” contains these sections:
mw “About TextEdit.” This section provides an overview of the features
provided by TextEdit.
mw “Using TextEdit.” This section describes the tasks you can accomplish using
TextEdit. It describes how to use the most common routines, gives related
user interface information, provides code samples, and supplies additional
information.
mw “TextEdit Reference.” This section provides a complete reference to TextEdit
by describing the constants, data structures, and routines that it uses. Each

routine description also follows a standard format, which gives the routine
declaration and description of every parameter of the routine. Some routine
descriptions also give additional descriptive information, such as
assembly-language information or result codes.

a “Summary of TextEdit.” This section provides the Pascal interface and the C
interface to TextEdit, defining the constants, data structures, routines, and
result codes associated with TextEdit. It also includes relevant

assembly-language interface information.

XXXxii

PREFACE

Some chapters contain additional main sections that provide more detailed
discussions of certain topics. For example, in the chapter “Font Manager,” the
sections “About Fonts” and “About Font Resources” describe the capabilities
and structure of the fonts that the Font Manager supports.

Conventions Used in This Book
Inside Macintosh uses various conventions to present information. Words that
require special treatment appear in specific fonts or font styles. Certain
information, such as parameter blocks, use special formats so that you can
scan them quickly.

Special Fonts
All code listings, reserved words, and the names of actual data structures,
constants, fields, parameters, and routines are shown in Courier (this
is Courier).

Words that appear in boldface are key terms or concepts and are defined in
the Glossary.

Types of Notes
There are several types of notes used in this book.
Note
A note like this contains information that is interesting but possibly not
essential to an understanding of the main text. (An example appears
on page 1-5.) @
IMPORTANT

A note like this contains information that is essential for an
understanding of the main text. (An example appears on page 2-63.) &
A

WARNING

Warnings like this indicate potential severe problems that you should be
aware of as you design your application. Failure to heed these warnings
could result in system crashes and loss of data. (An example appears on
page 4-17.) a

XXXili

PREFACE

Development Environment
The system software routines described in this book are available using Pascal,
C, or assembly-language interfaces. How you access these routines depends
on the development environment you are using. This book shows system
software routines in their Pascal interface, C interface, or assembly language
using the Macintosh Programmer’s Workshop (MPW).
Code listings in this book are shown in MPW Pascal or MPW C or MPW
Assembler. They suggest methods of using various routines and illustrate
techniques for accomplishing particular tasks. Most code listings have been
compiled and tested, although in some cases only fragments of the full listings
are shown. However, Apple Computer does not intend that you use exactly
these code samples in your application.

XXXiV

CHAPTER 1

Introduction to
Text on the Macintosh

Contents
Macintosh Text Overview
1-3
Separation of Tasks
1-4
Text Is Graphics
1-5
Characters, Glyphs, Character Codes, and Bytes

Text Storage
1-9
Keyboards and Input Methods
1-11
Writing Systems and Script Systems
1-14
Macintosh Text Utilities
1-16
TextEdit, a Text-Processing Service

1-8

1-16

Planning Your Text Handling Capabilities
1-18
Rudimentary Text Handling
1-18
Moderate Text Handling
1-19
Sophisticated Text Handling
1-20
Writing Systems and Script Systems
1-21
Features of the World’s Writing Systems
1-21
Character Representation
1-22
Line Direction and Alignment
1-23
Contextual Forms and Character Reordering
1-26
Diacritical Marks
1-29
Uppercase and Lowercase Characters
1-30
Word Demarcation
1-30
Styles
1-31
Numbers, Currencies, and Dates

1-32

Character Order and Text Sorting
1-34
Variations Among Languages and Regions
1-34
Components of the Macintosh Script Management System
The Macintosh Text Managers
1-36

Contents

1-35

1-1

CHAPTER

1

The WorldScript Extensions
Components of a Script System
International Resources

Keyboard Resources
Fonts

1-39
1-40
1-41

1-42

1-44

How Script Systems Are Classified
1-45
Types of Script Systems
1-46
Script Codes, Language Codes, and Region Codes
The System Script and Auxiliary Scripts
1-51
Font Script and Keyboard Script
1-51
How Script Systems Work
1-52
Character Encoding
1-52
The Standard Roman Character Set
1-54
Other 1-Byte Character Encodings
1-56
2-Byte Character Encodings
1-57
Font Handling
1-60
Font Availability and Selection
1-61
System Font and Application Font
1-61
Roman Characters and Associated Fonts
1-62
Other Font Issues
1-63
Character Rendering and Text Display
1-64
Storage Order and Display Order
1-65
Line Direction and Alignment
1-67
Style Runs, Font Runs, Script Runs, Direction Runs

Text Layout
1-71
Caret Handling
1-74
Highlighting
1-80
Converting Screen Position to Text Offset
Printing
1-85
Text Input
1-87
Keyboards and Key Translation
1-87
Input Methods
1-91
Text Manipulation
1-94
Sorting Strings
1-94

Analyzing Characters
1-98
Searching, Modifying, and Converting Text
1-98
Finding Word Boundaries and Line Breaks
1-99
Script Systems in Use
1-100
Installing and Enabling Script Systems
1-100
Components of the System Script
1-101
Components of Auxiliary Scripts
1-102
Installing Modifications to a Script System
1-103
How the User Switches Among Script Systems
1-104
User Control of Script Settings
1-107

Contents

1-70

1-82

Formatting Dates, Times, Numbers, and Symbols

1-2

1-48

1-96

CHAPTER

1

Introduction to Text on the Macintosh

This chapter is an overview of Macintosh text handling. It is meant to help you
get started by introducing the concepts described in detail throughout the rest of
Inside Macintosh: Text.
The chapter contains four major sections. The first presents high-level concepts, and the
following three develop those concepts further and give important programming
suggestions and hints:
m “Macintosh Text Overview” summarizes what text means for Macintosh
programmers, including how to support text in multiple languages. It concludes with
suggestions for planning your application’s level of text handling.
mg “Writing Systems and Script Systems” surveys the issues that must be addressed by
any computer-based text-handling system, and then describes the organization of the
Macintosh script management system, the set of software managers and resources that
help you support text-handling capabilities across many languages.
m “How Script Systems Work” describes the approach taken by the script management
system to provide multi-language capabilities in areas such as text display, text input,
and string manipulation.
m “Script Systems in Use” describes how the computer user interacts with script
systems, including installing script systems, switching text input and display from one
language to another, and controlling script-system configuration.
If you are developing a text-handling application, read this chapter’s first section,
“Macintosh Text Overview,” before reading any other parts of this book. You can then
either read the remainder of this chapter before going on, or start immediately on the
other chapters, returning to this chapter as needed for further explanation of
script-system concepts and for specific programming suggestions. The chapters that are
most important for general application development are “TextEdit,” “QuickDraw Text,”
“Font Manager,” “Text Utilities,” and “Script Manager.” The chapters that are most
important for applications that use input methods, or for developers of input methods,
are “Text Services Manager” and “Dictionary Manager.”
If you are developing or modifying a script system, read this chapter completely before
turning to other chapters and appendixes. Those that are most important for
understanding script-system design are “Script Manager,” “Built-in Script Support,”
“International Resources,” and “Keyboard Resources.”

Valuable information related to the topics discussed in this chapter can be found in
Guide to Macintosh Software Localization. That book discusses features of individual script
systems and gives specific techniques for software localization.

Macintosh Text Overview
Text handling on the Macintosh is fundamentally different from the way it is approached
on some common text-based computer systems. There is no hardware-based character
generator to put text on the screen; there is no standard input/output window (and no
Writeline command) for easy generation of text messages.

Macintosh Text Overview

1-3

CHAPTER

1

Introduction to Text on the Macintosh

To draw any text, you first must create a window to draw in. In that window, you can
then draw shapes, including the shapes of letters. See the Window Manager chapter in
Inside Macintosh: Macintosh Toolbox Essentials for a discussion of how to create a window.
In accepting text input and storing text in memory, you cannot assume any particular
hardware (keyboard) configuration, you should not assume a particular language
for input, you should not assume that characters are always represented by ASCII
codes, and you should not even assume that a single character is always represented
by 1 byte of storage.
This section paints a broad picture of how text processing works on the Macintosh, and
presents some fundamental terminology. It also introduces script systems and briefly
discusses two components of system software of special interest for text processing.
The section concludes with suggestions on how to give your application the level of
text-handling sophistication it requires.

Separation of Tasks
The Macintosh approach separates text handling tasks into three fundamental categories,
each relatively independent of the others:
m Text input
m Text storage and manipulation
m Text display
See Figure 1-1. In the discussions in this chapter and elsewhere in this book, keep in mind
which category of task is under discussion, to avoid misunderstanding.
Figure 1-1

O

COI

Separation of input, storage, and display in Macintosh text handling

Oo

oo) oo) = =~ e”

eae
(600
Ap

|

ET |

S|

$41

[1

m=

|

» A
[efi]

Input

Macintosh Text Overview

Storage and manipulation

Display

[>i

CHAPTER

1

Introduction to Text on the Macintosh

Through text input, your application obtains representations of text characters. It starts
with the user pressing keys on a keyboard. Text input is aided by specialized parts of
system software that allow input of text in many languages. Text input is completely
independent of text display.
Your application stores character representations in memory, as numeric codes. The main
focus of your application is on storing, tracking the characteristics of, and manipulating
these codes in memory. How those codes got into memory, and how you will display or
print them, are mostly separate issues. For much of your processing, you will be
concerned with codes in a memory buffer, rather than keypresses on a keyboard or pixel
locations on a screen. The system software has many routines that aid in manipulating
text of many languages in memory.
Note
In Figure 1-1 and throughout this book, text in computer memory is
drawn as a vertical table of codes, representing sequential (downward)
storage of text characters in a buffer. Some diagrams also include
byte offsets in the buffer, and even miniature representations of
the characters themselves in a given language. See, for example,
Figure 1-3 on page 1-8. #
Though text display, your application makes visible the characters it has stored and
manipulated in memory. The end result of the display process is a sequence of text
shapes drawn on a display device. As is shown later in this chapter, the displayed form of
text often has a complex relationship to the way it is stored. In most cases you can
consider text display as an independent task, handled in large part by system software,
that you call after you have finished receiving, storing, or otherwise processing characters
in memory. It is only during display, for example, that the concept of a font has meaning.
(Preparation for text display, such as width measurement and line-breaking, falls on the
boundary between storage and display, and is in general a cooperative effort between
your application and system software.)
If your application is a word processor that is drawing characters to the screen as the user
enters them, all three of these tasks are closely coupled in time. Nevertheless, they are
still independent of each other and can be understood best as separate processes.

Text Is Graphics
Your application draws graphic shapes on the Macintosh screen by making calls to
QuickDraw, the graphics manager of Macintosh system software. The graphics
components of QuickDraw are described in the chapter “QuickDraw,” in Inside
Macintosh: Imaging.
Drawing text is fundamentally the same as drawing graphics. The application makes
QuickDraw calls to write text to the screen or to a printer. Those parts of QuickDraw that
are concerned specifically with drawing text are documented in the chapter “QuickDraw
Text” in this book.

Macintosh Text Overview

1-5

CHAPTER

1

Introduction to Text on the Macintosh

When QuickDraw draws text, it places bitmapped shapes on a display device. Those
shapes are the forms of individual letters in a particular font. A font is a resource that
contains a complete set of character representations in a particular typeface, such as
Times® or Geneva. Without a font, QuickDraw cannot draw text.

When you ask QuickDraw to draw text, it draws it according to the settings of the
window (specifically, of the current graphics port record) that you are drawing into. The
text’s screen location, font, size, color, and style are all implied by the current state of the
graphics port; they are not explicit parameters of your text-drawing call.
For example, when QuickDraw draws a character, it draws it at the current pen position,
the screen position at which drawing occurs, in the current window. The character’s
origin (usually its left edge) is placed with respect to that location, with the rest of the
character extending to the right of the origin. After drawing, QuickDraw automatically
updates the pen location by the width of the character, so that the next character drawn
will be automatically placed the correct distance to the right of the first. See Figure 1-2.
Likewise, when QuickDraw draws a string of text, it keeps advancing the pen location as
it draws, so that the current location ends up at the right end of the string. This
left-to-right orientation of QuickDraw is fundamental, and applies whether or not
the text being drawn is meant to be read left-to-right (such as English) or right-to-left
(such as Arabic).
Figure 1-2

How QuickDraw draws text

Font request

Manager

a—=A=>
,

Bitmap

QuickDraw

————
|

r

—

. A:

Pen location

before drawing

=

Pen location

after drawing

QuickDraw’s text-measuring capabilities are as important as its drawing capabilities. In
many cases, before you draw a line of text, you first need to know its length in pixels,
so that you can correctly place it on the screen and be assured that it does not overrun
its allotted space. Pixels are screen dots, and are nominally equal to one point, or
approximately 1/72 inch, in size. You often make two sets of QuickDraw calls when
drawing a string; the first to measure it, and the second to actually draw it.
The Font Manager supports QuickDraw by providing the character bitmaps
that QuickDraw needs, in the typefaces, sizes, and styles (such as bold or italic) that

QuickDraw requests. The Font Manager keeps track of all fonts available to an
application. If QuickDraw requests a typeface that is not represented in the available

1-6

Macintosh Text Overview

CHAPTER

1

Introduction to Text on the Macintosh

fonts, the Font Manager substitutes one that is; if QuickDraw requests a size that is

not available, the Font Manager scales an available size and returns the bitmaps to
QuickDraw; if QuickDraw requests a style that is not available, the Font Manager returns
an unstyled set of bitmaps and QuickDraw applies a style to them (by slanting for italic,
or darkening extra pixels for boldface, and so on). In general, the Font Manager does the
calculations and creates the bitmaps; QuickDraw transfers those bitmaps
to the screen.
Fonts are strongly language-dependent. A font is the manifestation of the character
set—the body of meaningful characters—of a language or group of languages, called a
writing system. Fonts also implement additional symbols and forms, such as ligatures,
needed by that writing system. The Font Manager provides for fonts in many writing
systems; fonts are identified by a numbering scheme with which the writing system of a
font can be determined from its number.
Macintosh fonts come in two basic kinds: bitmapped and outline (such as TrueType).
Each bitmapped font is a set of character bitmaps of a given typeface in a single size; each
outline font is a set of templates from which bitmaps of any size can be generated. All
Macintosh text-handling routines work with both types of fonts.
Fonts can also be classified by the sizes of the character sets they implement. The typical
Macintosh fonts, suitable for most languages of the world, are called 1-byte fonts; each
contains fewer than 256 characters. Fonts for some East Asian languages, however, need
thousands of characters; they are called 2-byte fonts. The Macintosh text-handling
routines can work with both 1-byte and 2-byte fonts, although special techniques
may be required for character handling with 2-byte fonts. Bitmapped and outline
fonts are described in the chapter “Font Manager” in this book and in TrueType Font
Format Specification, available from APDA. For more information on how fonts are
used on the Macintosh, see “Fonts” beginning on page 1-44, and “Font Handling”
beginning on page 1-60.
The text measuring and drawing routines in QuickDraw and the Text Utilities operate
under certain assumptions, based principally on the fact that Macintosh system software
was originally developed for the left-to-right Roman writing system of the English
language, and that the system software provides line-layout, but not page-layout,
capabilities. Remember these points:
m QuickDraw draws all text from left to right. Whether your text has a left-to-right or
right-to-left line direction—the direction in which the text is read—QuickDraw places
its left edge at the current location in your window and draws its characters in order
from the leftmost to the rightmost character. QuickDraw and the Text Utilities provide
routines that allow you to order and draw your text properly regardless of its line
direction or directions.
m Ona line of text, screen position is in terms of pixel offset from the left edge of the
text-drawing area, regardless of the line direction of the text being drawn.
m The text-measuring routines in this book help you calculate and lay out individual
lines; it is up to you to track where a line starts, both in terms of vertical screen
position and in terms of offset in your text run.

Macintosh Text Overview

1-7

CHAPTER

1

Introduction to Text on the Macintosh

Characters, Glyphs, Character Codes, and Bytes
In memory, applications store text as numerical representations of characters. On the
screen, QuickDraw draws text as bitmapped representations of those characters,
generated from a particular font. To clarify how numbers in memory are converted to
letters on the screen, keep the following terms in mind. See also Figure 1-3.
A writing system’s alphabet, numbers, punctuation, and other writing marks consist of
characters. A character is a symbolic representation of an element of a writing system; it
is the concept of, for example, “lowercase a” or “the number 3”. It is an abstract object,
defined by custom in its own language.
As soon as you write a character, however, it is no longer abstract but concrete. The exact

shape by which a character is represented is called a glyph. A font, then, is a collection of
glyphs, all of similar design, that constitute one way to represent the characters of the
language. The “characters” that QuickDraw places on the screen are really glyphs.
In memory, text is stored as character codes, where each code is a number that defines a

particular (abstract) character. The “characters” that an application reads into or out of a
buffer, sorts, and searches for are really numeric codes. One purpose of a Macintosh font
is to provide glyphs that the system software can associate with character codes; different
fonts for the same language will typically have different glyphs, all representing the same
character, for a specific character code. Thus no matter which font you use, an English
“C” is always a “C” (character code $43), though it may be Garamond or Chicago font,
italic or bold style, and 7 points or 72 points in size. (Note that fonts in certain languages
may have more than one glyph per character, and may have special glyphs for various
combinations of characters.)

Figure 1-3

Byte
offsets

Character
codes

Characters

1|

$42

4:

|B

3|

gee

|x

4

$87

3

5}

$88

|

6

$a473 | IL]

7
8
9

A

B

1-8

Bytes, character codes, characters, and glyphs

ABCK3U
I «Kx

a

|

=

gaara | 7K
$A4EC

| 7X

Macintosh Text Overview

=
[ej

ala

CHAPTER

1

Introduction to Text on the Macintosh

In computer memory, 1 byte (8 bits) is commonly used to store a single character code.
For most languages that is sufficient: the standard ASCII character set (also called low
ASCII) requires only 7 bits per character code, and the Apple Standard Roman character
set (an extended ASCII character set derived from the original Macintosh character set)
requires only 1 byte per character code. In many other languages, such as Russian,
Arabic, and Thai, each character code is also 1 byte in size. But in some East Asian
languages such as Japanese, Chinese, and Korean, the character set is so large that most

character codes must be 2 bytes long. Macintosh system software provides routines to
help you recognize and manipulate 2-byte characters; if your application is to be useful
throughout the world, you must be prepared to deal with 2-byte characters.

The left side of Figure 1-3 shows a portion of a text buffer in memory. Byte offsets into the
buffer are shown down the left side of the column. The character codes the buffer
contains are shown within the column; note that some codes are a single byte, whereas
others are 2 bytes in size. (For clarity, miniature representations of the characters defined
by those character codes are shown down the right side of the column.)
The right side of Figure 1-3 shows what happens when QuickDraw draws the contents of
the buffer. The character codes define which glyphs are placed on the screen, and in what
order. The character codes do not define the style or size of the glyphs, however.
Character codes are only numbers; the meaning of each character code is different in
different writing systems. In Figure 1-4, for example, the same four bytes are interpreted
very differently if they are considered to be two Japanese character codes than if they are
considered to be four English (= Roman writing system) character codes.
Figure 1-4

Byte
offsets
0

1}

Four bytes displayed in Japanese and in English

Character
codes
$92

$a9

c=]
3|_ SFA

;
In English

In Japanese

BA
$9249
$93FA

,

Ne

1@©1
$92 $A9 $93 $FA

Text Storage
In considering how to store text in buffers, strings, and files, it may be clearer if you

understand the assumptions that the Macintosh text managers make about your
text-storage method. The discussions throughout this book assume that your text is
stored and accessed acording to these conventions:
m Your program stores text as a simple sequence of character codes. The character
codes may be 1-byte or 2-byte codes, but there is nothing else in the text stream
except for those codes. Using font information that your program stores separately,

Macintosh Text Overview

1-9

CHAPTER

1

Introduction to Text on the Macintosh

Script Manager routines can help you determine whether a character is 1 or 2 bytes,
and other managers allow you to work with either character size.
Character location within a text sequence in memory is in terms of byte offset (not
character offset) from the beginning of the text. Offset is zero-based; the first byte in
the sequence has an offset of 0.
The storage order of your text—the sequence in memory in which the character codes
occur—is the same as its logical order. It is the order in which the characters would be
read or pronounced in the language of the text. Because text of different languages
may be read either left-to-right or right-to-left, storage order is not always the same as
the left-to-right display order of the text when it is drawn. In Figure 1-5, for example,

note that the Hebrew characters are displayed in reverse order from the order in which
they are stored.
Figure 1-5

Byte

offsets

Storage order and display order

Character

codes

Characters

O|

$41

|A

{

$42

B

3|
4]

$E0
$eE1

N
4

5|

$E2

5)

$A473

| LL

gA4ra

| 7K

‘ee
6

7
8
ts)

A

B

$A4EC | JX

EL]

ABCIAN

=

rN
|

WKH
>

=

Display order

Storage
order

y

[Siu]

S

ela

m All writing-system, font, size, color, and style information about each part of your text
is stored separately from the text, and it is your application’s responsibility to maintain
that information. The text stream itself carries no information about what writing
system or font it was created with or is meant to be drawn with; you need to keep
track of and supply that information before making a drawing or measuring call.
Text is divided into runs. There are text runs, direction runs, script runs, font runs, and

style runs. A style run is a continuous sequence of text that is all of the same writing
system, font, size, color, style, and scaling factors (if the text is scaled).

Figure 1-6 shows four style runs on a single line. Because of the way many drawing
and measuring routines work, it is important to track all the individual style runs in

1-10

Macintosh Text Overview

CHAPTER

1

Introduction to Text on the Macintosh

your text. Runs are described in more detail under “Style Runs, Font Runs, Script
Runs, Direction Runs” beginning on page 1-70.

Figure 1-6

os

$42

B

PD

$43

C a

WO

$E0

|N

$E1

al

$E2

P|

$41

A

$42

B

$43

C

$61

a

$62

b

$63

c

oOo
wor

_

Style

EL]

> ha

JA

ABC)
x
me

1NABCabc
Nak
J

Style runs

runs
_
_

NA

WON

$41

BR

Characters

O|

oN

codes

DO

offsets

Character

Y

[<i

>

S|

Byte

Style runs in text

m Drawing involves converting character codes in memory to glyphs on the screen.
When drawn, some characters in some writing systems change their shape, size, or
position depending on their contextual position, that is, on what other characters
surround them. See “Contextual Forms and Character Reordering” beginning on
page 1-26. Using information in a set of international resources, the Macintosh
text-measuring and drawing routines can automatically perform these contextual
transformations for you.
m

For text that is contextual, you do not store the transformed, ready-to-draw version;

what you store in memory are the codes for the fundamental characters that make up
the text. That makes searching, sorting and other manipulation more straightforward.
Each time the text is drawn it is re-transformed as appropriate.

Keyboards and Input Methods
By means of keyboard input, the user can create text that your application stores as
character codes and displays as glyphs. At first glance this may seem a difficult task: your
application should be able to handle input from at least 13 different hardware types of
Apple keyboards, as listed in the appendix “Keyboard Resources” in this book.
Furthermore, it must be able to derive the proper character codes for any writing system
from each of the keyboards and recognize the states of the modifier keys (Shift, Caps
Lock, Command, Option, and Control).

Macintosh Text Overview

1-11

CHAPTER

1

Introduction to Text on the Macintosh

The system software and the keyboard resources make this relatively easy for
you. The Event Manager uses the keyboard resources to convert keypresses into the
correct character codes for the current writing system, for whatever keyboard is used.
Your application receives the codes directly and needn't keep track of the specific
keyboard in use.
Figure 1-7 is a simplified view of key translation, the process by which character codes
are generated. Each keyboard has a particular physical arrangement of keys, and each
keypress generates a value called a raw key code, which indicates which key was
pressed. The keyboard driver that handles the keypress uses the key-map resource to
map these raw key codes to keyboard-independent virtual key codes. It then uses the
Event Manager and the keyboard-layout resource to convert a virtual key code into a
character code, and passes it to your application in the event record generated by the
keypress. See “Keyboards and Key Translation” beginning on page 1-87 for a more
complete description of key translation; see the Event Manager chapter in Inside
Macintosh: Macintosh Toolbox Essentials for a description of events and event records.
Figure 1-7

O

Key translation (simplified)

COO
oo
oo" ~~”

feeeeeree et

Raw key
code
Key-map

resource

ital key code

Keyboard-layout

resource

!

Character code

Keyboard layout can be considered the overall relationship between the physical
arrangement of keys on a keyboard and the glyphs produced when those keys are
pressed. It is what the Key Caps desk accessory shows; see Figure 1-8.

1-12

Macintosh Text Overview

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-8

Key Caps display of Thai keyboard layout (no modifier keys pressed)

Changing the physical keyboard, changing the keyboard-layout resource, pressing
modifier keys, and changing the font can all change the relationship between keypresses
and glyphs. Figure 1-9 is a Key Caps display for the same physical keyboard as that
in Figure 1-8, but the writing system has been changed from Thai to Cyrillic. For
the purposes of this book, however, the keyboard-layout resource is the critical
item in determining keyboard layout; changing the keyboard layout means changing
the keyboard-layout resource. Because keyboard layouts are independent of the
physical keyboard attached to the computer, your application has the flexibility
of changing text input from one writing system to another by simply using a different
keyboard-layout resource.
Figure 1-9

Key Caps display of Cyrillic keyboard layout (Caps Lock key pressed)

Macintosh Text Overview

1-13

CHAPTER

1

Introduction to Text on the Macintosh

For languages with large character sets, it is impractical to manufacture keyboards with
keys for every possible character. In such a case, it is usually the job of an input method,
working in conjunction with a keyboard, to handle text input. An input method is a
software module, often independent of the application it serves, that converts character
codes that can be entered from the keyboard into character codes that cannot. Japanese
and Chinese input methods commonly display a small window, into which the user
types a sequence of phonetic characters; the input method converts them into one or
more ideographic character codes and sends them to the application. A more
sophisticated input method is inline input, in which entry and conversion of text occur
directly in the window of the text document being edited. See “Input Methods”
beginning on page 1-91 and the chapter “Text Services Manager” in this book for more
information on input methods and inline input.
In most cases, your application does not need to do anything special related to keyboard
input. You can use the character codes returned by the Event Manager function
WaitNext Event—whether generated directly from keypresses or through an input
method—and handle the text appropriately for the language being used for input.
Remember, however, that keyboard input is independent of text display; it is your
responsibility to keep the two synchronized when necessary. If the user switches
language for text input, you must switch the language for text display accordingly. The
Font Manager and Script Manager provide routines that help you with that; see “Font
and Keyboard Synchronization” beginning on page 1-90, and further discussion in the
chapter “Script Manager” in this book.

Writing Systems and Script Systems
Localization is the process of adapting software to local use. When a version of
Macintosh system software is created for a particular country or region, its text strings
usually must be translated and it must support the writing system of that region. To
facilitate the localization of Macintosh system software around the world, much of
Macintosh text-handling is concerned with proper presentation in multiple languages.
Macintosh computers are sold worldwide, and Macintosh system software is currently
available in over 30 localized versions, allowing computer users in many parts of the
world to use the Macintosh in their native languages. Macintosh system software
likewise provides your application with the capability of simultaneously supporting
multiple writing systems.
IMPORTANT

Even if you do not plan to localize your application, it should still
support multiple writing systems. Users in your own target region may
have capability for more than one writing system on their computers,
and may want your application to support that capability. a
In this book, a writing system denotes a method used to depict words visually. It consists
of a character set and a set of rules for displaying, ordering, and formatting those
characters. Writing systems can differ in line direction, the direction in which their
characters are read; the size of the character set used to represent the writing system; and
whether or not they are contextual—whether a character changes its form depending on

1-14

Macintosh Text Overview

CHAPTER

1

Introduction to Text on the Macintosh

its position relative to other characters. Writing systems have specific requirements for
text display, text editing, character set, and fonts. A writing system, of which one

example is Roman, can serve more than one language, of which two examples are French
and Spanish. A single language such as French can have regional variations with slightly
different requirements, such as Swiss French and Canadian French. Writing systems
and their features are described under “Features of the World’s Writing Systems”
beginning on page 1-21.
On the Macintosh computer, a script system (or script for short) is a collection of
resources that provides for the representation of a particular writing system. A script’s
keyboard resources define the character codes and keyboard layout for the writing
system, and its international resources provide a host of formatting and ordering rules
for the writing system. A script system requires one or more fonts designed specifically
for the writing system. The script system is accessed through the Script Manager, the Text
Utilities, the script extensions WorldScript I and WorldScript II, and the other text-related
software managers described in this book. Together, these software components make up
the Macintosh script management system. The files, managers, and resources that make
up the script management system are described under “Components of the Macintosh
Script Management System” beginning on page 1-35.
A script system on the Macintosh is identified primarily by number, its script code. And
just as writing systems can serve several languages, script systems can have variations
for different languages, specified by language code. Each language code “belongs” to a
particular script code. Regional variations can also be reflected in script systems, by
region code. Each region code “belongs” to a particular language code. See, for example,
Figure 1-34 on page 1-49.

More than one script system may be enabled, or present and available, on the Macintosh.
Script systems may be installed either as auxiliary scripts, which just provide
writing-system support, or as the system script, which affects system defaults such as the
default font, keyboard layout, line direction, and so forth, and is typically the writing
system used for localized dialog boxes, menus, and alerts. All other scripts are secondary

to the system script. The font script, also called the current script, is the script system
currently being used to draw text. The keyboard script is the script system currently
being used for text input.

The Roman script system is always available, either as the system script or as an auxiliary
script. Furthermore, the low-ASCII Roman characters are always available in any script
system; they are a standard part of every script system’s character set.
Macintosh system software routines that take into account the script system of the text
they manipulate are called script-aware routines. Likewise, applications that use those
routines to properly handle text according to its script system are also called script-aware.
Your applications should be script-aware.
More details about script systems and how they work are found under “Components of a
Script System” beginning on page 1-40, “How Script Systems Are Classified” beginning
on page 1-45, and “How Script Systems Work” beginning on page 1-52.

Macintosh Text Overview

1-15

CHAPTER

1

Introduction to Text on the Macintosh

Macintosh Text Utilities
The Text Utilities are a broad collection of text-manipulation routines provided by
Macintosh system software. With Text Utilities calls, you can
m specify strings for various purposes
m

sort strings, including strings in any writing system and combinations of strings in

different writing systems

m convert case or strip diacritical marks from text for sorting purposes
m format numbers and currency
m format dates and times
m search and replace text
m find word boundaries and line breaks when laying out lines of text
Some Text Utilities routines function with the Roman script system only, but many are
script-aware and work properly with all script systems. Script-aware Text Utilities
routines rely on a script system’s international resources to define the specific behavior in
that script system.
The Text Utilities are described in the chapter “Text Utilities” in this book.

TextEdit, a Text-Processing Service
Macintosh system software provides a simple text-processing service, used by the Dialog
Manager and other parts of system software, and available for your use also. TextEdit
handles certain basic text-handling tasks for small (less than 32 KB) amounts of text.
TextEdit maintains a text buffer, provides line breaks, tracks the selection range
and insertion point for text, handles insertions and deletions from the buffer, and tracks

style information for all its text. TextEdit formats and draws text properly in multiple
styles and different script systems—even multiple scripts on a single line. TextEdit
handles mixed-directional text, synchronizes fonts and keyboards, handles 2-byte

characters, determines word boundaries, and matches text alignment with line direction.
TextEdit even allows you to customize several of its features, such as word selection and
text measurement.

If you want multiscript text handling, and you do not need to manipulate large files and
do not need formatting other than font styles, TextEdit is a convenient alternative to

writing your own text processor. You can use TextEdit at different levels of complexity:
m For the very simplest text handling (in dialog boxes), you needn't even call

TextEdit directly. Use the Dialog Manager, which in turn uses TextEdit, to correctly

edit and display text in either the system script or Roman script. For example,
the Save As dialog box shown in Figure 1-10 handles mixed-directional text (in this
case, Arabic) correctly. The Dialog Manager is described in Inside Macintosh: Macintosh
Toolbox Essentials.

1-16

Macintosh Text Overview

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-10

TextEdit edits and displays mixed-directional text in a dialog box

[yell alSy]
Extensions 2 |}
Preferences O}

Save

SuperPaint 3.0 ©

9,603K

available

[

kiect

|

[

Desktop

]

as:

[|

Save

MyFileL. |

[

Cancel

Sustem
aly

<— Emily&Kelly

LL,

+

oe

£3

oO

document

$iitt

|

]

Save as: @| PICT

= If you simply want to display one or more lines of static (non-editable) text, you can
call the TextEdit TEText Box procedure. TEText Box draws your text at the location
you specify with the alignment you specify. You need not make any other TextEdit
calls or allocate any data structures if you use TEText Box.
m Other than dialog boxes and static text display, if your application requires very basic
text handling, in which neither styled text nor multiple fonts are needed (as in many
desk accessories), you may need only monostyled TextEdit. You can use monostyled
TextEdit with the application font (if you don’t allow the user to select a font) or with
any single available font (if you do allow user selection) in any version of Roman or
non-Roman Macintosh system software.
m

If your application requires a somewhat higher level of text handling (allowing the
user to set the font, size, and style of text, for example), you can use multistyled

TextEdit. You can use multistyled TextEdit with any combination of available fonts, in
any version of Roman or non-Roman Macintosh system software.
TextEdit does have limitations; it is not powerful or efficient enough for use as a general
text editor. For example, TextEdit
m can only handle up to 32 KB of text
m is not highly optimized for speed
m contains data structures that can be inefficiently large for multistyled text
Nevertheless, TextEdit’s convenience and multiscript capabilities make it an attractive
alternative to writing your own text processor. TextEdit is described in the chapter
“TextEdit” in this book.

Macintosh Text Overview

1-17

CHAPTER

1

Introduction to Text on the Macintosh

Planning Your Text Handling Capabilities
The Macintosh system of text handling—with its graphic approach to text drawing,
separation of text storage from text rendering, ability to handle many writing systems,
event-controlled text input, large library of utility routines, and availability of a simple
text-handling service—is general and powerful. But you may not need all of its power,
and the simpler your needs are the less you will have to do to meet them.
It may appear difficult at the outset to generalize your text-handling capabilities so that
they can work across all script systems around the world. You may instead wish to
customize your application to work with a specific regional variation or script system in a
target market that interests you. Either approach is possible; you can use the Macintosh
script management system to build in language-independence or language
customization, as you wish. There are three general approaches you can take:
m= Globalization is the preparation of a culturally neutral application that provides the
technical underpinnings for script-specific, linguistic, and regional variations, and that
is capable of running with any script system. Globalization involves careful design
and writing of the application and its textual and graphic resources.
m Localization is the adaptation of an application to a particular language or region, to
achieve proper formats for dates, times, currency, measurement, calendars, and

numbers, proper text sorting, and acceptable forms of other culturally specific
material. Localization involves translation of textual resources, modification of graphic
resources such as icons, and possibly creation of a customized set of script-system
resources. The better globalized an application is, the easier it is
to localize.
= Customization is the inclusion of script-specific, linguistic, or regional capabilities
supporting features that are not otherwise supported by Macintosh system software
(for instance, vertical text direction or special underlining modes for the Japanese
writing system).
This book supports and describes the process of globalization; it helps you prepare your
application to support all writing systems and regions. The process of localization is
discussed in Guide to Macintosh Software Localization. This book does not discuss
customization, beyond the few suggestions presented at the end of this section.
To achieve globalization, localization, or customization, the level of work required is

related to the level of text-handling sophistication you need. There are three general
levels to consider—rudimentary, moderate, and highly sophisticated.

Rudimentary Text Handling
Rudimentary text handling means that the user either cannot set fonts at all (the lowest
level of sophistication) or that the user can set fonts and styles but not alignment (a
slightly higher level). In either case large amounts of text and sophisticated formatting
are not required.

1-18

Macintosh Text Overview

CHAPTER

1

Introduction to Text on the Macintosh

If your application requires only rudimentary handling, use TextEdit—either directly or
through the Dialog Manager—to handle user input and editing. TextEdit exhibits the
correct behavior for editing and displaying text in multiple styles and different
script systems.
In addition, at an absolute minimum, design your application so that it can display its
own Roman text properly when operating with a non-Roman script system. For text in
dialog boxes, menus, alert boxes, and so on, if you do not plan to translate the text for
localization use only the low-ASCII character codes that are the same on all script
systems. High-ASCII character codes may map to incomprehensible characters in another
script. The ellipsis in menu items, for example, maps to other characters when displayed
in other system scripts. Instead of using the ellipsis, a high-ASCII character code, you can
use three periods, a low-ASCI string; the ellipsis is displayed regardless of the system
script. (A better approach, however, is to use the script management system to retrieve
the appropriate form of the ellipsis character for whatever script system you are running
under. See the discussion of retrieving text from tokens in the chapter “Script Manager”
in this book.)

Moderate Text Handling
Moderate text-handling sophistication means an application allows users to set font,
style, alignment, tabs, writing direction, keyboard, input method, and so forth, across
script systems. It handles large amounts of text and offers greater formatting
sophistication than TextEdit provides.
The Macintosh script management system and all the text managers documented in this
book are designed to support this level of sophistication. You can use these managers and
the rest of Macintosh system software to include basic word-processing capabilities in
your application, capabilities that work across the entire range of worldwide writing
systems supported by Macintosh system software.
Within the range of moderate text handling, the level of complexity is largely a function
of the number and types of script systems that are currently enabled. You may wish to
structure your application’s text-handling algorithms to allow for categories of increasing
complexity, based on conditions such as the following four. (The item in parentheses
following each condition is a selector or flag that tests for that condition. See the
discussion of selectors for Script Manager variables and script variables in the chapter
“Script Manager” in this book.)
mw Only one script system is present (smEnabled = 1). If there is only one script system,
it is Roman; you can assume all text-handling follows the built-in Roman rules, and
you do not need to account for or test for the script system of any text.
m= More than one script system is present (smEnabled > 1). You need to track the script
system associated with each run of text. You need to use script-aware routines for text
handling. You need to synchronize the font script with the keyboard script.

Macintosh Text Overview

1-19

CHAPTER

1

Introduction to Text on the Macintosh

mw A bidirectional script system is present (smBidirect = TRUE). You need to allow for
the possibility of right-to-left text, right alignment of text, discontinuous highlighting,
and a display order for style runs that is different from storage order. You need to
allow for contextual behavior in drawing; you cannot use font width tables for
measuring text.
m A 2-byte script system is present (smDoubleByte = TRUE). You need to allow for
the presence of 2-byte character codes in searching, drawing, and line-breaking.
You should also support inline input of text whenever the keyboard script is a 2-byte
script system.
These probably represent the major divisions in text-handling complexity that you
address, although you may want to account for others. For example, you may want to
test each individual script system to see if it is contextual (smsfContext set), 1-byte
(smsfSingByte set), or bidirectional (smScriptRight = TRUE) before deciding how to
handle its text.
With the moderate level of text-handling supported by the Macintosh script management
system as documented in this book, your application can be powerful enough and
general enough for worldwide acceptance.

Sophisticated Text Handling
Highly sophisticated text processing might be employed by a very powerful word
processor that works across many script systems. If you write such a program, you
will probably need to go beyond the capabilities provided by the Macintosh script
management system.

Areas that may need special attention include specialization or customization of
delimiters, higher-level grammatical structures, word selection, sorting, arrow keys,

and line direction. All of these issues are addressed by the current Macintosh script
management sytem, but if your needs go beyond what the system is now capable of,
you may need to write your own code to accomplish them. Here are a few examples:
m Your application may require the implementation of functions not supported by the
Macintosh script management system but needed by certain languages—for example,
text with a vertical line direction.
m Your application may mark text by language, and allow users to limit searching,
sorting, or spell-checking to specific languages.
mw Your application may want to display characters in a more sophisticated manner than
is supported—such as furigana, also called rubi, a Japanese text display in which small
Kana characters are placed adjacent to a Kanji character to indicate its pronunciation
or to explain it if it is rare.

1-20

Macintosh Text Overview

CHAPTER

1

Introduction to Text on the Macintosh

If you do write your own code to replace one or more of the Macintosh script
management capabilities, make sure you do it in a modular fashion, so that you can work
with current Macintosh text managers and also be prepared to take advantage of possible
future enhancements to system software.

Writing Systems and Script Systems
The first section of this chapter, “Macintosh Text Overview,” has given an overview to all

of Macintosh text handling. This section and the rest of the chapter develop many of
those concepts in more detail, to give you the background necessary to work with the
routines documented throughout the remainder of this book.

This section presents the language features that must be addressed by system software if
it is to properly handle the world’s writing systems. It also describes the organization of
the Macintosh script management system and the structure and classification of the
Macintosh script systems that implement that international text handling.

Features of the World’s Writing Systems
In order to understand the structure and workings of Macintosh text handling, it is useful
to first consider the range of text features that need to be represented on the computer.
This section presents the principal text-related features, taken from writing systems
around the world, that the Macintosh addresses.

A writing system is a set of characters and the basic rules for their use in creating
a visual depiction of language. There are more than 30 active writing systems in
the world today, used to represent the official written languages of one or more regions
and countries. Examples of writing systems are Roman, Chinese, Japanese, Hebrew,

and Arabic. Color Plate 1 shows the world distribution of some of the principal
writing systems.

Each writing system has distinct attributes. Simple systems such as Roman, Greek, and
Cyrillic usually have fewer than 200 characters; Japanese, a complex writing system,
theoretically contains more than 40,000. Printed Roman characters are relatively

independent of each other; Arabic characters change shape depending on the characters
that surround them. Some writing systems use spaces to separate words; others do not
separate words at all. Some writing systems, such as Japanese, actually include multiple
subsystems, each with its own set of characters and rules for how they are combined.

Writing Systems and Script Systems

1-21

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-11 shows the names of various languages and regions, written in the appropriate
writing system for each language.
Figure 1-11

Writing-system examples

Hh

ra

a=

SL

y)1y

WZ

isl
Rimski

AS

ft
EAAA

The variety of writing-system attributes presents difficult, though not insurmountable,
challenges to their representation on the Macintosh computer. This section discusses the
principal attributes that the Macintosh script management system addresses.

Character Representation
Writing systems differ in the kind and number of characters required to create words as
the basic components of language. Some writing systems, such as Roman and Cyrillic,
are basically alphabetic: the characters in the writing system symbolize, more or less, the
discrete phonemic elements in the languages represented by that writing system. Other
writing systems, such as Japanese Kana, are syllabic: the characters stand for syllables in
the language.
Some writing systems—namely, Japanese Kanji, Chinese Hanzi, and Korean Hanja—
include ideographic characters. These characters do not represent pronunciation alone,
but are also related to the component meanings of words. A typical character set for
ideographic writing systems is quite large, ranging from 7,000 to 30,000 characters.
Figure 1-12 shows examples of alphabetic, syllabic, and ideographic representations
of characters.
Figure 1-12

Rimski

1-22

Words with alphabetic, syllabic, and ideographic characters

([C(EA, 7

Writing Systems and Script Systems

*

CHAPTER

1

Introduction to Text on the Macintosh

Several writing systems, including Hebrew, Thai, and Korean, contain character clusters.

A character cluster is a collection of alphabetic characters.

m Insome systems, character clusters consist of a principal character plus attachments in
memory. For example, in Hebrew, a cluster may be composed of a consonant, a vowel,
a dot to soften the pronunciation of the consonant, and a cantillation mark.
m

In other systems, character clusters occur as alphabetic blocks made of 2 to 5

component parts. For example, in Korean, consonant and vowel components called
Jamo are combined into blocks called Hangul. See Figure 1-39 on page 1-60 for an
example. In Thai (as shown in Figure 1-13), consonants are combined with vowel
marks and tone marks to make clusters.

On the computer, character clusters pose difficulties in the treatment of word
demarcation, the movement of the caret, deletion, and highlighting.

Figure 1-13

Thai character cluster

tone

4

consonant

Ia

—

li

tone

ae

fa

consonant

——————_

‘

WW

+

+

tone

vowel |
consonant

f

|

consonant

+ vowel + tone

——

consonant

+ vowel + tone

|

tone ———_——_—_1
consonant ——

|

——

alte

1
li )
74

a ay
|

|
tone + vowel + tone

vowel

+ consonant

Line Direction and Alignment
Writing systems also vary in the direction in which characters are written:
m

In Roman writing systems, characters are written from left to right, with horizontal

lines of text filling the page from top to bottom.

m Arabic and Hebrew writing systems have most characters written from right to left,
with horizontal lines of text filling the page from top to bottom.
m In Japanese and Chinese, characters are traditionally written from top to bottom, with
vertical lines (columns) of characters filling the page from right to left. There are no

spaces between words. In modern China and Japan, technical documents and
academic journals are written in standard left-to-right horizontal lines, while text for
newspapers and magazines is written mostly in vertical columns.
mw In Mongolian, the characters are written in a vertical column, with spaces between

words, and the lines fill the page from left to right.

Writing Systems and Script Systems

1-23

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-14 shows several text directions. These three writing directions—left-right
top-bottom, right-left top-bottom, and top-bottom right-left—are the most common of the
eight possible combinations of line direction and fill direction.
Figure 1-14

Line directions in text

re)

aren)

|

Goodwill
towards Men

Ur yy

A

"15 awh! pw

|

oy St ae

Peace on Earth,

et seh)o>
Ct Ar aie:

_—
lanl

More than one line direction can exist within a single writing system. For example,
numbers in Arabic and Hebrew are commonly written left to right, even though
nonnumeric text is written from right to left. Furthermore, commonly interspersed
foreign words from the Roman writing system are also written from left to right. Thus the
Hebrew and Arabic writing systems are actually bidirectional, even though their
primary line direction is right-to-left.
The Macintosh script management system supports the ability to write text from left to
right and from right to left, and to mix text with different directions within lines and

blocks of text. Your application can add the ability to handle vertical text, if desired.

Alignment is the horizontal placement of lines of text with respect to the left and right
edges of the text area. Alignment can be left-aligned (also called flush left or ragged right),
right-aligned (also called flush right or ragged left), centered, or justified (that is, aligned to
both left and right edges of the text area). See Figure 1-15.

1-24

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-15

Text alignment

Left-aligned

Right-aligned

Centered

Justified

This is a figure illustrating
the concept of text alignment
and text justification. This
text is an important part of
this figure.

This is a figure illustrating
the concept of text alignment
and text justification. This
text is an important part of
this figure.

This is a figure illustrating
the concept of text alignment
and text justification. This
text is an important part of
this figure.

This is a figure illustrating
the concept of text alignment
and text justification. This
text is an important part of
this figure.

When using text, it is very
important to decide the type
of alignment and justification
to use.

When using text, it is very
important to decide the type
of alignment and justification
to use.

When using text, it is very
important to decide the type
of alignment and justification
to use.

When using text, it is very
important to decide the type
of alignment and justification
to use.

Note
Although the term justified is sometimes used as a synonym for aligned,
as in “left-justified” or “right-justified” text, this book considers justified
to be equivalent only to fully justified, and uses aligned exclusively when
referring to text that is left-aligned, right-aligned, or centered. @
Alignment is related to line direction in that text with a left-to-right line direction is
usually left-aligned, whereas text with a right-to-left line direction is usually
right-aligned.
Justification is achieved by spreading or compressing printed text to fit a given line
width. It can be performed in Roman text by altering the widths of interword spaces
alone, or by altering both interword and intercharacter spaces. Writing systems that don’t
use interword spaces typically justify text by modifying the intercharacter spacing alone.
See Figure 1-16.
Figure 1-16

Justification through interword (Hebrew) and intercharacter (Japanese) spacing

79002 Tin wivypnn
Right-aligned:

jopnla

«TDIN

wroypnn

Justified:

Writing Systems and Script Systems

H AR 3B ld

‘Left-aligned

H

‘Justified

A

HB

ld
1-25

CHAPTER

1

Introduction to Text on the Macintosh

Arabic text, however, is justified by extending characters themselves. Printed or
displayed text is justified by inserting extension bar characters (kashida) between joined
characters, and by widening blank characters to fill any remaining gaps. See Figure 1-17.
Figure 1-17

Justification with Arabic extension bar characters

SL

Right-aligned

&
! -

oo? S

|
Justified

!

The Macintosh script management system can take all of these justification methods into
account when drawing, measuring, or selecting text.

Contextual Forms and Character Reordering
In writing systems, contextuality or context dependence means that character forms may be
modified by the values of preceding and following characters in the input stream. In
Arabic, the displayed form of many characters changes depending on their position in a
word or on what other characters are nearby.
The displayed form that represents a character in printed English does not usually
depend on bordering characters. This is not the case for many writing systems. Even in
cursive English, for example, when one letter is joined to the preceding letter, the
connecting line varies according to which letters are being joined. Characters may also
have considerably different shapes depending on where they occur within a word, for
example, at the beginning (initial form) or elsewhere in the word (noninitial form). Figure

1-18 illustrates two of these variations in cursive English, which are called contextual
forms.
Figure 1-18

Initial form

2

1-26

Contextual forms in cursive English

Noninitial form

tbe

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

The ability to represent contextual forms is required for the proper display of Arabic text.
Figure 1-19 shows standalone and contextual forms in Arabic.
Figure 1-19

Independent

DA

Standalone and contextual forms in Arabic

Final

Medial

gl

Initial

Furthermore, certain character forms may be combined into a new form when they occur
together. Figure 1-20 provides an example of how characters combine to form ligatures
or conjunct characters in Roman text.

Figure 1-20

A ligature in Roman text

f+1—~

fi-—- fi

The composition rules for Arabic text, for example, are very complex. The use of ligatures
can be highly developed, and some ligatures are required for proper display. Each
character can have up to four contextual forms, and the precise form depends upon a
varying number of characters that precede and follow it. Figure 1-21 shows an example
of a simple ligature in Arabic text.
Figure 1-21

A ligature in Arabic text

Y=—l+J-—J+ J

Writing Systems and Script Systems

1-27

CHAPTER

1

Introduction to Text on the Macintosh

Dozens of Arabic characters form ligatures. As Figure 1-22 illustrates, in some cases, more

than two characters can join together into a completely different form, although usually
there are only two characters per ligature.
Figure 1-22

A complex ligature in Arabic text

Character reordering is another form of contextuality. Principles of text ordering differ
according to the type of writing system under consideration. In most writing systems
(including Roman, Greek, Cyrillic, Arabic, and Hebrew), phonetic and writing order

are synonymous except for vowel signs and other marks. With certain South Asian
writing systems, however, there may be significant differences between phonetic
and writing order.
Figure 1-23 shows an example of the reordering of vowels for the word hindi in the
Devanagari writing system. The left side of the figure shows, in order, the characters that
make up the word; the right side shows how the word is actually written. Where there is
no explicit vowel sign, consonants take a default vowel sound “a”. To cancel the default
vowel, you add a vowel marker (virama). Some vowel markers are written to the right of
the consonant they modify; others are written to the left, above, or below. In this example,

the consonant “h” is followed by a vowel sign, which appears on the left when displayed.
The consonant “n” is followed by a virama; together they make a small contextual form
when displayed. The consonant “d” is followed by a vowel sign, which appears in
normal order (on the right).

1-28

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Character reordering in the Devanagari writing system

—

=)

NN

=

>

4) a
Poy

—

Figure 1-23

ON
—-

S

S
S
a

virama)

Diacritical Marks
Many writing systems use diacritical marks, signs that modify the implicit sound or
value of the characters with which they are associated. Some diacritical marks are often
referred to as accents in Roman writing systems: the acute accent in “é”, for instance.
Others, such as certain Vietnamese diacritical marks, may indicate pitch, while certain
Arabic diacritical marks, such as shadda (shown in Figure 1-24), specify extra emphasis on
a consonant sound.
Figure 1-24

Arabic text with diacritical mark to specify extra emphasis on a consonant

w

ee
Hebrew text can contain optional vowel and cantillation marks. Vowel marks are shown
in Figure 1-25.

Figure 1-25

Vowel marks in Hebrew text

Tipra OY mM 2¥32 72°N2
Writing Systems and Script Systems

1-29

CHAPTER

1

Introduction to Text on the Macintosh

Uppercase and Lowercase Characters
English speakers are familiar with uppercase and lowercase characters in the Roman
writing system; however, the majority of the world’s writing systems do not have
separate uppercase and lowercase forms. The implications for computer applications
are primarily in the areas of searching, sorting, and proofreading (for example,

spell-checking).

Note
In the Roman writing system, different languages (and even different
regions or countries that use the same language) can have different
conventions for the treatment of accents and diacritical marks on
uppercase characters. These differences are accounted for in individual
localized versions of the Roman script system. @
Word

Demarcation

Words in Roman writing systems are generally delimited by spaces and punctuation
marks as shown in Figure 1-26. Note also that word demarcation for word selection may
follow different rules from word demarcation for line breaking.
Figure 1-26

Word demarcation in the Roman writing system

cat_(green-eyed),
dog
| dT
Mt
|
Word breaks for word selection

cat (green-eyed)

|

|

|

Word breaks for line breaking

dog

|

|

Bidirectional writing systems provide extra challenges to word selection and line breaks.
Figure 1-27 shows a single English phrase (“Writing systems including bidirectional”)
embedded within Hebrew text. The first line breaks within the English text. Note that the
line break itself occurs, not at the right or left edge of the first line, but in its interior; and
the continuation of the English phrase occurs in the interior of the following line.

1-30

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-27

Line breaking in a bidirectional writing system

Primary line direction

——_i
—<_

Writing

systems 790n2 JIN wroypnNn

Ayn mow

including bidirectional

NON? NIYNIN) INOW? 719 wD

In contrast, many Asian writing systems (such as Japanese and Thai) typically have no
word delimiters, so the Macintosh script management system provides a more
sophisticated method of finding word boundaries. Figure 1-28 shows word demarcation
in Japanese.
Figure 1-28

Word demarcation in Japanese

HK SH ld

|

EME

|

SO

The definition of a word can be an extremely complex issue. Word boundaries are not
always well-defined, and native writers of a language may not agree on where particular
word boundaries occur.

styles
Style for a writing system means the systematic alteration of a set of glyphs of a given
typeface, to uniformly change their appearance while preserving the overall sense of the
typeface. Boldfacing, italicizing, underlining, lining-through, and outlining are possible
styles that can be applied to text. Not all styles are appropriate or conventional for
all writing systems; for example, underlining may not be meaningful for text that is
written in vertical columns, and italicizing may not be appropriate for text that should
not be slanted.

Writing Systems and Script Systems

1-31

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-29 provides some examples of the application of styles to several
writing systems.
Figure 1-29

Selected valid styles in various writing systems

Roman

Japanese

:

=f |

Plain

WorldScript

Bold

WorldScript

Italic

WorldScript

H

AX no

Underline

WorldScript

H

AS An

Outline

WorldScript

A

.

.

pi

H

ZN HY

zh}

=i

=e

nA

Shadow

ARIS

Double

ea

strike through

Arabic

Hebrew

owe

Ss

WON)

a gS Ls

WIDYDN

Ix

PS

ix

.

WIVY

&

gS

Se
S

©

le

PID

WIP)

wiD»pD

Numbers, Currencies, and Dates
Each language—or in many cases each regional variation of a language—includes a set
of conventions for presentation of numbers. For example, in many European countries
the decimal character is a comma (,), and the thousands separator is a period (.). Insome
other areas, western numbers (1...9, 0) are not even used.

Each nation has its own currency format, including the symbol used to denote money.
The symbol may be one or more characters, and may precede or follow the numeric
amount. Negative monetary values are shown differently in different countries.

1-32

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Date and time formats vary with language and region. The order in which days, months,
and years are written, the words and common abbreviations for days and months, and
the separators used in writing dates and times can all differ from region to region.
Figure 1-30 shows some common differences in number, currency, and date formats

among the United States, European countries, and Japan.
Figure 1-30

Standard international formats

Numbers
List separators
United States

1,234.56

Great Britain

1,234.56

Germany

1.234,56

France

1 234.56

Greece

1 234.56

Japan

1 234.56

;

Currency
$0.23

Time

Short date

9:05 AM

12/22/85

Wednesday,

February 1, 1985

($0.45)
$345.00

11:20 PM
11:20:09 PM

,

£0.23
(£0.45)
£345

09:05
23:20
23:20:09

22/12/1985
1/02/1985

Wednesday, February 1, 1985
Wed., Feb 1, 1985

;

0,23 DM
-0,45 DM
345 DM

09:05 Uhr
23:20 Uhr
23:20:09 Uhr

22.12.1985
1.02.1985

Mittwoch, 1. Februar 1985
Mit, 1. Feb 1985

0,23 F
-0,45 F

09:05
23:20

22.12.1985
1.02.1985

Mercredi 1 Février 1985
Mer 1 fev 1985

*0,23
(0.45)
*345

09:05
23:20
23:20:09

:

;

345 F

¥0.23

(¥0.45)

¥345.00

23:20:09

09:05

11:20

AM

PM

11:20:09 PM

2/1/85

Long date (unabbreviated)
Long date (abbreviated)

22-12-85
1-02-85

85.12.22

85.2.1

Tetéptyn

Wed., Feb 1, 1985

1 Pepouapiou
Tet& 1 Depo

1985
1985

19854824 1 Aka

1985422 8 1A (7k)

Even the calendar itself is not the same around the world. The standard Gregorian
calendar used in Europe and the Americas is not universally accepted:
m In Japan, the Emperor’s year is sometimes used instead of the standard Gregorian
calendar. The rest of the Japanese calendar system is similar to the Gregorian calendar.
m The Arabic calendar is used extensively throughout the Middle East. It is lunar rather
than solar. The months are alternately 29 and 30 days long, so the Arabic calendar year
is about 11 days shorter than the Gregorian year. The months have no fixed relation to
the sun, so they slowly rotate through all of the seasons of the year (that is, every three
years the months shift forward by one Gregorian calendar month).

Writing Systems and Script Systems

1-33

CHAPTER

1

Introduction to Text on the Macintosh

There are actually two Arabic calendars in common use: the astronomical lunar
calendar, based on the moon’s phases as actually observed at each location around the

world; and the civil lunar calendar, a statutory version of the astronomical calendar. To

compute a date correctly for the astronomical lunar calendar requires calculating not
only the orbits of the sun and moon, but also knowing the exact latitude, longitude,
and time difference from Greenwich mean time.

mw Other calendars in common use include the Coptic, Jewish, and Persian calendars.

Character Order and Text Sorting
In most writing systems a need exists for ordering lists of characters, words, or lines of

text—such as for writing an alphabet or arranging a dictionary, encyclopedia, or
telephone book. Each writing system has its own rules and conventions for sorting text
into a meaningful order.
In Roman writing systems, sorting is usually based on alphabetic order, which is fairly
simple. However, complications arise when sorting text that includes mixed uppercase
and lowercase letters, letters with diacritical marks, ligatures, abbreviations, characters

that should be grouped, and characters that should be ignored for sorting purposes.

One important concept for Roman systems is the distinction between primary sorting
order and secondary sorting order. Text items that are equivalent in terms of primary
sorting characteristics are first grouped, and then differentiated according to secondary
sorting characteristics. This allows all variations of a character (uppercase and lowercase,
with or without diacritical marks, and so on) to be grouped together in sorted lists.
Nonalphabetic writing systems, such as Chinese or Japanese, can have more complex and
less standardized sorting conventions than Roman. Some sorting algorithms for
ideographic characters are based on the number of strokes per character. Others are based
on radicals, standard character subcomponents with a defined sorting order. Others
consider the phonetic spelling of the character with Roman or other types of characters
(such as Kana), and sort according to Roman alphabetic order or standard Kana order.
Macintosh support for sorting of text is fully described in the chapter “Text Utilities” and
the appendixes “International Resources” and “Built-in Script Support” in this book.
Tables of specific sorting orders for individual script systems are given in Guide to
Macintosh Software Localization.

Variations Among Languages and Regions
A writing system by itself may not be enough to define how a language is written. For
example, the Roman writing system is used for both the English and French languages. A
written language refers to the whole body of written words and of methods of combining
words, including their meanings, used by a particular group of people.
A single writing system may be used by multiple languages. Languages within
a writing system can modify the sorting order and word boundaries defined by the
writing system, and can define minor modifications to its character set.

1-34

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Conversely, some languages are written in more than one writing system. The official
language of Malaysia, for example, may be written in either the Roman or the Arabic
writing system, but the spoken language is called Malay in either case. Romanian and
Moldovan are essentially the same spoken language; however, in Romania this language
is written in the Roman writing system, whereas in the adjacent republic of Moldova,
it is written in the Cyrillic writing system.
A language in itself may not be enough to define all the conventions for written
communication in a particular region. A region is a linguistic or cultural entity, not
necessarily a nation or geographic area, whose written language or other text features are
unique enough to be treated separately from other regions. A single language, such as
French, may have several regional versions. For example, the French language is used in
France, in parts of Belgium, Switzerland, and Canada, and in other countries such as
Luxembourg, Haiti, Mali, Zaire, Tahiti, and Vanuatu. Such different areas that use the

same language may have different conventions for time, date, and number formats, as
well as rules for case conversion or placement of diacritical marks. Some differences may
also occur in the behavior of the written language. For example, in France, accents on
most characters are generally omitted if the character is written in uppercase; in Québec,
the accents are usually preserved.
The Macintosh script management system can account for multiple languages and
regional variations within script systems. See “Script Codes, Language Codes, and
Region Codes” beginning on page 1-48.

Components of the Macintosh Script Management System
This section describes the organization of the Macintosh script management system,
those parts of the system software that provide support for the writing-system features
described in the previous section, “Features of the World’s Writing Systems.”
The Macintosh script management system makes it possible to represent many writing
systems and languages on the Macintosh computer. With the Macintosh script
management system, your application’s text-manipulation capabilities can extend far
beyond the Roman writing system and its languages. If you use its features your
application can have a much wider market worldwide. You can implement text-handling
capabilities that work properly with any supported writing system, or you can tailor
your application to work correctly with any specific writing system or any regional
variation of a writing system.

The script management system supplies much of the same basic capability for entering
and displaying text as does a multi-language word processor—but on a system level.
Since the capability is built into the system, you do not have to duplicate the code
necessary to support each writing system; instead, you can devote your efforts to the
primary functions of your application.
As Figure 1-31 shows, the script management system consists of
m routines in various components (managers) of system software
m two WorldScript extensions (optional)

Writing Systems and Script Systems

1-35

CHAPTER

1

Introduction to Text on the Macintosh

m@

one or more script systems

m one or more fonts
The text managers and the script extensions are mostly code; they execute the
script-aware calls your application makes when handling text. The script systems and
fonts are mostly data; they consist largely of tables of script-specific information used by
the text routines, and glyph descriptions.
Figure 1-31

Components of the script management system for text display

Code

VUVxzX
wn o pr

ca)

Text
managers

rE

= Inwser || => A BC JAIN
i

aN

——

»

|

Data

Script

systems

[TH

-_,

LJ
Fonts

—

The Macintosh Text Managers
Several parts of Macintosh system software work together to provide specific
text-handling services to your application. These text-related managers include the Script
Manager, the text-handling components of QuickDraw, the Font Manager, the Text
Utilities, the Text Services Manager, and the Dictionary Manager.
The Script Manager

The Script Manager is at the center of the Macintosh script management system. It
initializes script systems and makes them available to applications; it maintains
important data structures and provides a standard application interface to script systems;
it supports switching text input among different script systems; and it provides several
text-manipulation services.

1-36

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

The Script Manager works closely with the Text Utilities and with QuickDraw. Your
program typically makes calls to all three managers in the course of text-handling, and in
many cases a call to one of these managers results in internal calls among them. TextEdit
also relies on the Script Manager, Text Utilities, and QuickDraw to make sure that it

handles text correctly in any script system.

The Script Manager provides routines with which you can
m control the values of many script-related settings, including the system direction and the
keyboard script
m get information about script systems, such as script codes, character-type information,
and direct access to a script’s international resources
m modify text through lexical conversion to tokens or phonetic conversion within a
script system
m= modify script systems by replacing international resources or routines
In particular, the Script Manager gives you access to Script Manager variables, which
control many overall settings of the text environment, and script variables, which control
settings specific to each enabled script system.
QuickDraw

QuickDraw is the graphics manager of Macintosh system software. The graphics
components of QuickDraw are described in the QuickDraw chapters in Inside Macintosh:

Imaging; the text-handling components of QuickDraw are described in the chapter
“QuickDraw Text” in this book.

Your application makes QuickDraw calls to write text to the screen or to a printer. When
QuickDraw draws text, it places bitmapped shapes on the display device that represent
the characters it is drawing. The characters are drawn according to the settings of the
currrent window’s graphics port record, which includes the location at which to draw
and a specification of the font and character attributes with which to draw.
For text in various script systems, the QuickDraw text routines allow you to
m set the characteristics of the drawing environment
m draw text
m measure the width of text
m lay out lines of text
m determine caret positions and highlight text

Font Manager
QuickDraw cannot draw text without a font. The Font Manager supports QuickDraw by
providing the character bitmaps that QuickDraw needs, in the typefaces, sizes, and styles
that QuickDraw requests. The Font Manager keeps track of all fonts available to an
application. The Font Manager supports fonts in many languages, for both bitmapped
and outline fonts, and for both 1-byte and 2-byte fonts.

Writing Systems and Script Systems

1-37

CHAPTER

1

Introduction to Text on the Macintosh

Besides providing QuickDraw with the bitmaps it needs, the Font Manager provides
routines with which you can
m determine the characteristics of a font
m change certain font settings, such as fractional widths or scaling
m favor outline fonts over bitmapped fonts
™ manipulate fonts in memory
Text Utilities

The Text Utilities are an integrated collection of routines for performing a variety of
operations on text, ranging from sorting strings to formatting dates and times to finding
word boundaries. The Text Utilities work in conjunction with the Macintosh script
management system and can take into account the differences in text-handling among
script systems. If you use these routines you can handle text operations in a manner that
is transportable to different parts of the world.
Many of the Text Utilities routines are script-aware; they work in conjunction with the
Script Manager and with QuickDraw to determine the script-system characteristics of
text and to prepare the text for drawing to the screen or printing.
The Text Utilities provide routines that, for text in any script system, allow you to
m define strings in various ways
m™ compare and sort strings

m™ modify the contents of strings by truncation, stripping of diacritical marks, case
conversion, or replacement
m

find boundaries of words, lines, and runs of Roman characters

m convert and format date and time strings
m convert and format numeric strings
Text Services Manager
The Text Services Manager is the part of Macintosh system software that provides an
environment for applications to use text services such as input methods. The Text
Services Manager handles communication between client applications and text service
components. Text service components are specialized software modules for entry,
processing, or formatting of text.
Client applications can use the Text Services Manager to
m make text services available to the user
m search for and communicate with text service components
m accept text input or other information from text service components
m ask for a special floating input window service

1-38

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Text service components can use the Text Services Manager to
m make their text service available to an application
m

act on events involving their windows, menus, or cursor

m pass text input or other information to an application
m

display floating utility windows

Dictionary Manager

The Dictionary Manager is the part of Macintosh system software that allows you to
create dictionaries for input methods and other text services that let the user enter,
format, and process text. A dictionary is a data file with information essential to the
conversion of text from one form to another. Most input methods provide both a main
dictionary, which contains standard information for conversion between forms, and a

user dictionary, which allows users to add custom information.

The Dictionary Manager defines a uniform and public dictionary format that you can
apply to your text service’s dictionaries. The Dictionary Manager provides routines with
which you can
m create and access a dictionary
m

locate, insert, or delete records in a dictionary

= compact data in a dictionary

The WorldScript Extensions
The Roman script system, always available on every Macintosh, needs only the
previously mentioned managers to function correctly. Several other similar script systems
also need no other software. However, for those 1-byte script systems that have
contextual characters or right-to-left line direction, additional code is needed so that the

Script Manager, Text Utilities, and QuickDraw routines can work properly. Likewise,
2-byte script systems need code extensions in order to properly handle the thousands of
characters they use.
Although each writing system has unique requirements and procedures for presenting,
sorting, and formatting text, in many cases separate script systems can use similar
algorithms. Therefore, to avoid inconsistencies and unnecessary duplication of code, the
script management system supplies two system extension files—WorldScript I and
WorldScript II—that support 1-byte complex script systems and 2-byte script systems,
respectively (see “Types of Script Systems” on page 1-46). They contain code that
implements many script-aware text-manipulation routines, eliminating the need for each
script system to maintain its own code extensions. Script-specific behavior is encoded in
resource-based tables accessed by the extensions.
WorldScript I and WorldScript II are described in the appendix “Built-in Script Support”
in this book.

Writing Systems and Script Systems

1-39

CHAPTER

1

Introduction to Text on the Macintosh

WorldScript I

WorldScript I is the script extension that implements table-driven text measuring and
drawing behavior for all 1-byte complex script systems (such as Hebrew, Arabic, Thai,
and Devanagari). Using tables in each script system’s international resources,
WorldScript I performs text manipulation properly for all supported scripts. WorldScript
lis a single file located in the Extensions folder within the System Folder on the user’s
Macintosh. It installs all compatible 1-byte script systems that are present in the System
file, and provides them with a standard set of script-aware text-manipulation routines.
WorldScript I implements script utilities, the low-level routines through which an
individual script system implements script-aware Text Utilities, QuickDraw, and Script
Manager routines. WorldScript I also implements patches to certain QuickDraw and Font
Manager text-handling routines.
The Script Manager provides routines that allow you to modify or replace a 1-byte
complex script system’s script utilities and QuickDraw patches. See the chapter “Script
Manager” in this book.
WorldScript Il

WorldScript II is the script extension that implements table-driven text measuring and
drawing behavior for all 2-byte (Chinese, Japanese, Korean) script systems. Using tables
in each script system’s international resources, WorldScript II performs text manipulation
properly for all supported scripts. WorldScript II is a single file located in the Extensions
folder within the System Folder on the user’s Macintosh. It installs all compatible 2-byte
script systems that are present in the System file, and provides them with a standard set
of script-aware text-manipulation routines.
Like WorldScript I, WorldScript II implements script utilities that implement script-aware
Text Utilities, QuickDraw, and Script Manager routines. Unlike WorldScript I,
WorldScript II does not support the Script Manager routines that allow replacement of
script utilities.

Components of a Script System
The Macintosh script management system, as described in the previous section, is
designed to manipulate text according to information contained in script systems. This
section describes how script systems are organized.
A Macintosh script system is a collection of resources, mostly tables of data, that defines
the behavior of a particular writing system. The script system specifies the character set,
sorting orders, date and number formats, line direction, character reordering, accent

placement, and other writing-system-specific features. Your application uses the
information in a script system when it makes a script-aware text-handling call, and it can
also access the resources of a script system directly, to inspect or modify its behavior.
Each Macintosh script system consists of a set of international resources and a set of
keyboard resources. In addition, a script system requires one or more fonts in order to
display its text. A script system may also have a control panel device through which the
user can configure the individual characteristics of the script at any time.
1-40

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Resources in general are described in the chapter “Resource Manager,” in Inside
Macintosh: More Macintosh Toolbox.
International Resources
The international resources are a set of Macintosh resources that specify text handling
and display information for a particular writing system, language, or region. Such
information includes number and currency formats, long and short date formats,
preferred sorting order, character type, case conversion, and word-boundary information.
Table 1-1 lists the international resources, shows their resource types, and summarizes
their contents.
Table 1-1

The international resources

Name

Resource type

Content

International configuration

'itle'

Configuration of the system script,
plus Script Manager flags, and the
region code for the system script

Script sorting

'itlm'

Tables showing sorting order and
mapping among script systems,
languages, and regions

International bundle

'itlb'

IDs of all required resources for a
script system, plus bit flags, default
language, and other settings

Numeric format

'it10'

Number and currency formats, short
date and time formats, unit of

measurement for a script system, plus
a region code
Long-date format

'itli'

Long date and time formats, names of
days and months for a script system,
plus a region code

String manipulation

'it12'

Sorting routines, tables for character
type, case conversion, and word
boundaries for a script system

Tokens

'3t14!

Tables and code for converting
characters to tokens and back ina

script system, and for formatting

numbers

Encoding /rendering

'itl15!

Tables for character rendering (for
1-byte script systems); tables for
character encoding (for 2-byte script
systems)

Transliteration

'trsl'

Tables for phonetic conversion among
subscripts of a 2-byte script system

Writing Systems and Script Systems

1-41

CHAPTER

1

Introduction to Text on the Macintosh

International resources reside in the resource fork of the Macintosh System file. However,
not every installed script system requires a complete set of them:
m There is only one international configuration resource for each Macintosh System file,
and its resource ID is 0. It configures the system and defines the system script.
m There is only one script-sorting resource for each Macintosh System file, and its
resource ID is 0. It does not belong to any script system.
m Each installed script has one international bundle resource. Its resource ID is the script
code of the script system it implements.
m Each installed script system has one or more numeric-format, long-date-format,
string-manipulation, and tokens resources. Their resource IDs are in a range that
defines the script system they belong to; see Figure 1-35 on page 1-50.
m Ascript system may have one or more optional encoding/rendering and
transliteration resources.Their resource [Ds are also in a range that defines the script
system they belong to.
A single script system may have multiple localized versions of its
'3t12',

'it1l4','it15',and

'trsl'

'1t10','it11',

resources, in order to represent different

languages or regional variations of the script. You can manipulate text in different
formats within that script system by switching among the multiple versions of the
resources. See “Installing Modifications to a Script System” beginning on page 1-103.
See the appendix “International Resources” in this book for more information on
international resources.

Keyboard Resources
The keyboard resources are a set of Macintosh resources that specify how keyboard input
is converted to text for a particular writing system, language, or region. The Event
Manager, the Script Manager, and the Menu Manager use the information in these
resources to convert keypresses to character codes, to switch input among different script
systems, and to display the icon of the current keyboard in the Keyboard menu. The
Resource Manager, the Event Manager and the Menu Manager are described in Inside
Macintosh: Macintosh Toolbox Essentials; the Resource Manager is described

in Inside Macintosh: More Macintosh Toolbox.

1-42

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Table 1-2 lists the keyboard resources, shows their resource types, and summarizes
their purpose.
Table 1-2

The keyboard resources

Name

Resource type

Content

Key map

'KMAP'

Maps hardware-dependent raw key codes to
hardware-independent virtual key codes

Key remap

'itlk'

Remaps some virtual key codes from certain
keyboards for use by some keyboard-layout
resources

Keyboard layout

'KCHR'

Maps virtual key codes to character codes;
represents the character set for a script system

Keyboard icons

'kes#!

Keyboard icon list for black-and-white icon
display in the Keyboard menu

'kes4!

Keyboard icon list for 4-bit color/ gray-scale icon
display in the Keyboard menu

'kes8!

Keyboard icon list for 8-bit color/ gray-scale icon
display in the Keyboard menu

Keyboard swap

'KSWP!

Specifies modifier-plus-key combinations to let
the user change keyboard layout, keyboard script,
or input method

Key caps

'KCAP!

Determines keyboard display for a given physical
keyboard (in Key Caps desk accessory)

Keyboard resources reside in the resource fork of the Macintosh System file. Some are
script-related, but others are hardware-related and script-independent:
m There is only one keyboard-swap resource per Macintosh System file. Because it
specifies how to switch among script systems, it does not belong to any script system.
Its resource ID is 0.
m There is one key-map resource that supports most types of physical keyboards. Some
keyboards need their own key-map resource, in which case the key-map resource ID is
equal to the ID number of the keyboard it is associated with.
m There is one key-caps resource for each type of physical keyboard available. It is
independent of any script system. Its resource ID is equal to the ID number of the
keyboard it is associated with.

Writing Systems and Script Systems

1-43

CHAPTER

1

Introduction to Text on the Macintosh

m There are one or more keyboard-layout resources per script system. There are one or
more families of keyboard icon resources per script system (one per keyboard layout
resource or input method). The resource ID for each keyboard-layout resource is in a
range that defines the script system it belongs to; see Figure 1-35 on page 1-50. The
resource ID for each keyboard icon family is equal to the ID of its associated
keyboard-layout resource.
m There is one key-remap resource for each keyboard-layout resource that needs one. Its
resource ID is equal to the ID number of its associated keyboard-layout resource.
See the appendix “Keyboard Resources” in this book for more information.
Fonts
A font is not technically part of a script system. The script’s international bundle resource
does not have to specify any particular font resource IDs, and even if it does, their
presence is not guaranteed. Nevertheless, no script system can be used unless one or
more fonts accompany it.

A Macintosh font implements the character set and other written forms such as ligatures
for a given script system. Each font contains a particular set of glyphs that share certain
design characteristics. Those glyphs constitute a typeface, and the typeface has a name,
such as Times, Helvetica®, or Kyoto. A font may be a plain implementation of a typeface,
or it may be styled—such as bold or italic. (QuickDraw can also produce styled versions of
the characters of a typeface from a plain font.)
Glyphs in a font represent each of the characters of a character set. Additional glyphs
may be present to represent ligatures, and other contextual forms. In some fonts there
may be more contextual glyphs than character glyphs.
A font maps character codes to glyphs, and may contain tables that map special glyph
codes to the glyphs of contextual forms. When laying out and drawing text, the script
management system uses information in the font to convert character codes in memory
to a properly formatted series of glyphs on the screen or on the page.
Macintosh fonts are either bitmapped (meaning that each glyph is a single bitmap) or
outline (meaning that each glyph is a mathematical outline that is size-independent). A
bitmapped font contains a single set of glyphs at a fixed size, whereas one outline font
can produce glyphs of any size.
Fonts are either 1-byte—meaning that they have glyphs for 256 or fewer characters—or
2-byte, meaning that they can have glyphs for thousands of characters. The 1-byte fonts
represent character codes that are 1 byte long, and include all fonts of the Roman script
system. The 2-byte fonts represent character codes that are 1 byte or 2 bytes long, and
include fonts of the Chinese, Japanese, and Korean script systems. The script
management system supports 2-byte fonts, and can correctly handle mixtures of 1-byte
and 2-byte characters in text.

1-44

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Each font is a Macintosh resource. For ease of reference, fonts are grouped into font
families (resource type 'FOND'). Each family consists of all the available sizes and styled
variations of a single named typeface. For example, “Courier 10”, “Courier 12 Italic”, and
“Courier Semibold” could be two bitmapped fonts and one outline font belonging to the
single font family “Courier”. Whenever you supply a font ID to a script management call,
itis the 'FOND' resource ID that you supply (unless you supply the special font
designators 0 or 1; see page 1-61).
As with other script-related resources, the ID numbers for fonts are in a range that

defines the script system they belong to. See, for example, Figure 1-35 on page 1-50. In
fact, the script management system relies fundamentally on font family ID to determine
the script system associated with any text that is to be manipulated or drawn.
See the section “Font Handling” beginning on page 1-60 of this chapter for more
information and programming suggestions involving fonts. See the chapter “Font
Manager” for more specific information on font structure and use. For more complete
information on both 1-byte and 2-byte TrueType fonts, see The TrueType Font Format
Specification, available from APDA.

How Script Systems Are Classified
Different kinds of script systems function differently. The previous section, “Components
of a Script System,” described the components of all script systems; this section describes
the different ways of classifying script systems. The following section, “How Script
Systems Work,” describes how to use script systems for your text handling needs.
Script systems are typed in general by the size of their character set and by their relative
similarity to Roman. The Roman script system is used widely in North America, South
America, Australia, Europe, and Africa, and in parts of Asia and Oceania. The Roman

script system is standard on all Macintosh system software versions 4.1 and higher, but
the Macintosh also supports all types of non-Roman script systems—simple or complex,
and with small or large character sets.
Script systems are individually classified by code numbers. Resources associated with a
script system have ID numbers that are related to the script’s code. Languages and
regional variations are subsets of script systems and have their own code numbers.
On an individual computer, more than one script system can be available at a time;
different scripts are classified by their function. The most important script system is the
system script; other script systems are secondary. The script system currently being used
for text display is the font script; the script currently being used for text input is the
keyboard script.
Note
Because the Roman script system is always installed, you can
always manipulate Roman text, no matter what other script
systems are present.

@

Writing Systems and Script Systems

1-45

CHAPTER

1

Introduction to Text on the Macintosh

Types of Script Systems
Because of its historical support for the Roman writing system, and because Roman text
layout is fairly simple, the Macintosh computer most easily supports script systems that
are like Roman. Other script systems can add complications like right-to-left line
direction, contextual character forms, and large character sets.

As shown in Figure 1-32, script systems are divided into three groups, based on the size
of their character set and their relative complexity compared to Roman:
m The 1-byte simple script systems have character sets of 256 characters or fewer. They
are called 1-byte because their character codes are one byte long. They are called
simple because they are similar to Roman: they have a uniform left-to-right line
direction and are noncontextual. The 1-byte simple script systems support variations
within the Roman writing system and among Roman-like writing systems such as

differences of character set, keyboard layout, sorting order, word boundaries, and the

formatting of dates, times, and numbers. The 1-byte simple script systems include
Roman, Greek, and Cyrillic.

m The 1-byte complex script systems also have character sets of 256 characters or fewer.
They are complex because they may have left-to-right or right-to-left line direction,
and may be contextual. The 1-byte complex script systems support the more difficult
formatting required for bidirectional writing and the extensive use of ligatures, cursive
fonts, character reordering, and other contextual features. The 1-byte complex script
systems include Thai, Devanagari, Hebrew, and Arabic.

m The 2-byte script systems have character sets so large that most character codes
are two bytes long. The 2-byte script systems require sophisticated methods for
character input, as well as an independent font mechanism for display and printing.
The 2-byte script systems include Traditional Chinese, Simplified Chinese, Japanese,
and Korean.

1-46

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-32

Types of script systems

a

Roman
Greek

Simple

Cyrillic

1-Byte
Bidirectional

Complex
Contextual

2-Byte

L
L

Hebrew

Arabic

Devanagari
Bengali
Thai
Japanese
Chinese
Korean

Figure 1-33 shows which parts of the Macintosh script management system are involved
in handling text from the different types of script systems:
m Roman text is handled with code and resources largely built into system software.
m Text of 1-byte simple script systems is handled with the same built-in Roman code and
resources, supplemented by minor additional resources such as alternate keyboard
layouts and fonts.
m Text of 1-byte complex script systems is handled by WorldScript I, which may use,
modify, or completely replace any of the built-in code. The complex 1-byte script
systems may replace much of the Roman resources with their own international and
keyboard resources and fonts.

Writing Systems and Script Systems

1-47

CHAPTER

1

Introduction to Text on the Macintosh

m Text of 2-byte script systems is handled by WorldScript I, which may use, modify, or
completely replace any of the built-in code. The 2-byte script systems may replace
much of the Roman resources with their own international and keyboard resources
and fonts; they also provide special input methods for text entry.
Figure 1-33

How the script management system handles different types of scripts

; Roman script |
|

routines

TO

1-byte simple scripts

[,

Text
Managers

Roman
Greek

Cyrillic

WorldScript |

WorldScript Il

1-byte complex scripts

Hebrew
Arabic
Devanagari

2-byte scripts

Japanese
Chinese
Korean

Script Codes, Language Codes, and Region Codes
The Macintosh script management system accommodates the international differences
within writing systems by defining languages and regional variations for script systems,
and organizing them into a classified hierarchy. Script systems are identified by script
codes, languages by language codes, and regions by region codes. A spoken language
that may be written in more than one writing system is treated on the Macintosh
computer as several languages, each belonging to a different script system.
Three general concepts underlie the hierarchy of script, language, and region.
m Ascript system is often differentiated by its character encoding, the specification of the
characters that compose the writing system and their numeric representations.
Different character encodings usually have different script codes. (This is not always
true within the Roman script system; see “The Standard Roman Character Set” on
page 1-54.)
m Each language belongs to a particular script system. Every language code thus implies
a particular script code. Several languages may be associated with a single script
system; in such a case, they share the same character set.
m Aregion code designates an area that may be smaller or larger than a single country
(for example, French Swiss or Arabic), in which a specific variation of a single script
system and language is used. Each region belongs to a particular language. Several
regions may be associated with a single language. A region code typically represents a
localized version of the system software for a particular language in a particular
country or region.

1-48

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-34 illustrates the script, language, and region hierarchy. Note, for example, that
the regions of France, Québec, and French Swiss are associated with the French language,
which is part of the Roman script system.
Figure 1-34

Script
Cyrillic

The script, language, and region hierarchy

Language

Region

Russian

Russia

Azerbaijani

Azerbaijan

Persian

Iran

Arabic

Arabic world

Japanese

Japan

Arabic

Japanese

France
French

French Canada
French Swiss

Roman
United Kindom

English

United States

You can use language codes and region codes to specify multiple subsets of the
international resources for a single script system. That way you can implement regional
variations to a writing system without having to create an entirely new script system
each time. See “Installing Modifications to a Script System” beginning on page 1-103.
See the chapter “Script Manager” in this book for a complete list of the constant names
that define the codes for all scripts, languages, and regional versions.
Script Codes and Resource ID Numbers
Each script system is assigned a unique script code. The script codes currently defined
are in the range 0-32, although the Script Manager can support 64 script systems at the
same time. All the resources related to a script system, including its fonts, have resource
ID numbers related in some way to the script ID:
m

The resource ID number for a script system’s international bundle ('it1b') resource

is the same as the script code.

Writing Systems and Script Systems

1-49

CHAPTER

1

Introduction to Text on the Macintosh

m The resource ID numbers for most other resources associated with a script are ina
range specific to that script. You can use these ID ranges to determine the script system
associated with a font or other resource. Likewise, even when a font is missing, the

Font Manager can use the ID range to substitute a font of the same script.
O For Roman (script code = 0), this range is 0-16383.

0 Scripts with script codes in the range 1-32 have a range of 512 resource ID numbers
each. For example, the script code for Japanese is 1, so Japanese resources can

have any of the first 512 ID numbers beyond the Roman range, that is, 16384-16895.
The script code for Korean is 3, so Korean resources can have resource IDs in

the range 17408-17919.

Figure 1-35 illustrates the resource ID ranges for script systems with script codes between
0 and 32. The ranges for the Roman, Japanese, Chinese, Korean, and Devanagari scripts

are noted. A full table of resource ID ranges is provided in the appendix “International
Resources” in this book.
Note

The Script Manager provides routines for determining the script system
based on the value of a font family ID.
Figure 1-35

Distinguishing scripts by resource ID range (for script codes 0-32)

Resource

ID Range

Script code
0
5

y

16384

0 (Roman)
1 (Japanese)

16896

2 (Chinese)

17408

3 (Korean)

20480
20992

9(D
;
(Devanagari)

17920

woredt

4

IMPORTANT

The special font designators 0 and 1, although in the range of the Roman
script system, specify the Macintosh system font and application font,
respectively; they do not necessarily indicate a Roman font and the
Roman script system. See the section “Font Handling” beginning on
page 1-60 for more information. &

1-50

Writing Systems and Script Systems

CHAPTER

1

Introduction to Text on the Macintosh

The System Script and Auxiliary Scripts
A script system may be installed either as an auxiliary script (also called a secondary
script), which only provides support for a particular writing system, or as the system
script (also called the primary script), which is the script system associated with the
currently running version of Macintosh system software. The system script affects system
defaults such as the default font, keyboard layout, and primary line direction. The system
script defines which writing system is used for dialog boxes, menus, and alerts.
Therefore, most text displayed by the Finder and other parts of the system is in the
language of the system script.
The system script is specified in the System file’s international configuration ('it1lc')
resource. All other script systems are secondary to the system script. In non-Roman
versions of system software, Roman is an auxiliary script.
Some versions of Macintosh system software, such as the Turkish or French, are

simply variations of the U.S. system software (which includes the Roman script system).
Their script system is a modified version of the standard U.S. Roman script system, and
they do not include a second script system. When a non-Roman script system is installed,
however, at least two script systems are always present. For example, the Japanese
system software is a combination of U.S. system software and the Japanese script system,
all of which are localized for Japan. Thus it contains both Roman and Japanese script
systems.

Font Script and Keyboard Script
In every version of Macintosh system software, the system script is always enabled and is
the principal script system for determining how text is presented and handled in the
Finder and other parts of system software. But if there are auxiliary scripts present, the
system script is not always the script system that controls text-handling.
The text-manipulation and drawing routines in the Macintosh script management system
work with individual character codes or strings of character codes, manipulating them or
converting them to glyphs. A character code by itself carries no identifier as to what
script system should be used to interpret it; the script management system uses other
information to decide what script system to use for presenting or processing a given run
of text.
Many of the routines use the script system associated with the font of the current
graphics port to perform their tasks. The font is specified by the txFont field of the
graphics port that is identified by the global variable the Port. The script system
associated with that font is called the font script. Therefore, to manipulate text in a given
script system, you typically first set the current port with a call to the QuickDraw
Set Port procedure, and then set the current font with a call to the QuickDraw

TextFont procedure, and then call the series of text-manipulation routines you need.
(For those routines that take a script code as an explicit parameter, you need not set the
current font before making the call.)

Writing Systems and Script Systems

1-51

CHAPTER

1

Introduction to Text on the Macintosh

Text input by the user involves the conversion of keypresses to character codes. Because
every script system has its own character set, the character codes produced depend
explicitly on the script system used for keyboard input. That script system is called the
keyboard script. It is not automatically the same as the script used for display of text;
your application must keep the keyboard script and the font script synchronized if
characters are to be displayed correctly as they are typed in. Synchronization of the font
script and keyboard script is further described on page 1-90 in this chapter and in the
chapter “Script Manager” in this book.
What is the “current” script?

As just stated, the font script is usually the script system that is used by a
script-aware text routine when the identity of the script or its resources is
not an explicit parameter of the call. However, if the font script is not
enabled, the routine uses the system script by default. Furthermore,
some script-aware routines may use the system script instead of the font
script, depending on the values of two Script Manager flags: the font
force flag and the international resources selection flag.
The font force flag, when

TRUE, specifies that fonts with ID numbers in

the Roman range are to be considered as fonts of the system script rather

than Roman fonts. The international resources selection flag, when TRUE,

specifies that resources of the system script are to be used by those Text

Utilities routines that format dates, times, and numbers. The font force

flag is supported only by some non-Roman 1-byte scripts for special
purposes, and is typically FALSE. The international resources selection
flag is typically TRUE.
The font force flag and the international resources selection flag are
described in the chapter “Script Manager” in this book. @

How Script Systems Work
The previous sections, “Components of a Script System” and “How Script Systems Are
Classified,” described the organizational aspects of script systems. This section explains
how Macintosh script systems function in support of the world’s writing systems. It
discusses how script systems represent the multitude of characters in the world’s
languages, how they format and draw those characters in the context of surrounding text,
how they support user input of text, and how they handle text-manipulation such as
sorting and searching across many languages.

Character Encoding
Character encoding is the organization of the set of numeric codes that represent all the
meaningful characters of a script system in memory. Each character is stored in memory
as a number. When a user enters characters, the user’s keypresses are converted to
character codes; when the characters are displayed onscreen, the character codes are
converted to the glyphs of a font.

1-52

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

There are two fundamental classes of character encodings supported by Macintosh
system software: 1-byte and 2-byte. A 1-byte encoding represents every character with a
1-byte number; a 2-byte encoding (actually a mixed encoding) represents characters with
either 1-byte or 2-byte numbers. There can be up to 256 characters in a character set that
has 1-byte encoding, whereas there can be over 28,000 characters in a character set that
has the currently supported 2-byte encoding. Roman and many other script systems use
1-byte encodings; Chinese, Korean, and Japanese script systems use 2-byte encodings.
The meaning of each character code is unique only within its script system. In an Arabic
font, the code $CC represents the character jiim, and in a standard Roman font, the code

$CC represents the character A. The traditional Chinese and simplified Chinese script
systems are two different script systems and use different character encodings; the
Chinese characters used in the Japanese and Korean script systems have still different
character encodings.

Much of a script system’s behavior, including sorting and composition rules for drawing
and measuring, is encoded in tables that rely on a particular order of character codes.
Therefore, the character encoding is fixed; it cannot be changed without significant
consequences. Ideally, each script system is consistent in its character encoding; all fonts
within a script system should have identical font layouts that reflect that encoding. This
is largely true, with the exception of some Roman fonts; Symbol font, for example, is a
Roman font but its glyphs are completely different from those of other Roman fonts.
The character set of a script system can include the characters of one or more subscripts.
A subscript is a portion of a script system that has its own character set and conventions
for use. Subscripts within the Japanese script system, for example, include the Katakana
and Hiragana syllabic characters. All non-Roman script systems include Roman as a
subscript. The parts of a script system’s character set that implement its natural writing
system are called native characters. In the Arabic script system, Arabic characters are
native and Roman characters constitute a subscript.
The Unicode standard
Unicode is an ISO standard for 16-bit universal worldwide character
encoding. It has been developed by a consortium that includes Apple
Computer, Inc. In the future, Unicode will replace individual script
systems’ character encodings with one complete 16-bit character
encoding applicable worldwide to all characters in all languages. The
script systems described in this book do not yet use Unicode encodings.
With a universal character encoding such as Unicode, the character sets

of separate writing systems do not overlap; there is no need to define
script systems, because each character code by itself determines which
writing system the character is part of. Furthermore, Unicode takes care
of the problem of conflicting character encodings within a single writing
system; for example, in Unicode, there

is no overlap between Roman

character codes and the codes of the symbols in Symbol font.

How Script Systems Work

1-53

CHAPTER

1

Introduction to Text on the Macintosh

The Standard Roman Character Set
The Apple Standard Roman character set is the 1-byte character encoding for the Roman
script system. It is the fundamental character set for the Macintosh computer, and is built
into every Macintosh throughout the world.
This character set (see Figure 1-36) uses all character codes from $00-$FF, and includes

uppercase versions of all of the lowercase accented Roman characters, a number of
symbols, and other forms. A complete set of glyphs for all characters is available in most
outline fonts, but not all characters are represented in the Apple bitmapped versions of
Chicago, Geneva, New York, and Monaco.

The Standard Roman character set is an extended version of the original Macintosh
character set, as described in Volume I of the original Inside Macintosh. It adds characters

with codes from $D9-$FF, which are empty in the original Macintosh character set. Like

the original Macintosh character set, the Standard Roman character set is an extended
version of the ASCII character set. The ASCII character set, sometimes called low ASCH,

is the traditional but limited character encoding for English-language computer systems.
It uses character codes from $00-$7F only, and includes uppercase and lowercase letters,
numerals, a few symbols, and a set of control (nonprinting) characters. The Standard
Roman character set includes all the ASCII character codes and adds the characters
(sometimes called high ASCH) with codes from $80-$FF.
The Standard Roman character set is implemented by the U.S. keyboard-layout resource
(type = 'KCHR', ID = 0) and other Roman keyboard layouts. The Standard Roman
character set and its sorting and formatting rules form a baseline which other
script systems adopt, modify, or replace as their needs align with or diverge from the
Roman conventions.

1-54

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-36

Ox

The Standard Roman character set

1x

2x

3x

4x

x0

|nul/dile}

sp}

0

|@|P

x1

}soh}DC1}

| | 4

x2 | stx |Dc2
x3

5x

6x

7x

8x

9x

Ax

Bx

Cx

Dx

Ex

Fx

p{/Aleltlo}le}]-]+4)]¢6

JA}Q;}alq}i]Ajle}le}t]

i

]—

o)

2/B/R/[b/}]ric}]i}/¢@¢]<s{al*«],]u

Jetx|DC3]}

# } 3

|c

|]s}ecls|eElile

|=

vy

, | U

x4feot|DC4)

g

[od

}]T]al}t{|nlii}ls

|¥l

sls

fu]

u

x5

%|5

|E

|U]e|

pfs

A

|

JF

|v}

jenqginak}

]4

u

on

x6 Jacklsynf

ale

x7 | bel | etb

7/G/wilgilwilalo/]Bl|XIK[Ol[A]~

x8

|bs Jcan|

x9}

htjem}

xA | If

xB|

sub]

vt jesc]

xC | ff

lis},

(| 8

|H

|X|

¢tlvlulalalalaAle-{eélh]x}]alo]@

{IIT

]>

E | -

)

|9]1}y]ily}]alo/o]z

*

J}Z]jtzitalo{™]

Ss

+];

|K/]

[|] k]¢]alo

2/alali|e

<

JL]

\]

o/Al<]i

it

| | ada

Y/|E]~
[nbsp]

7 | f
fs

xDjcr}gs}-}=-|{[mlyimizy}elaol#/Qlols]il”
xE | so | rs

>{|N]*/}]n]{~]e|fa

xF/silus}/}]2?]/o]

elae|fii|O]

|oldl]é/ulaloalelfAllol—

In Figure 1-36, note that each character code is represented by a two-digit hexadecimal
number. The first digit is determined by the column, and the second by the row. For
example, the character code for J is $A6 (from column Ax at row x6).

How Script Systems Work

1-55

CHAPTER

1

Introduction to Text on the Macintosh

Inconsistencies in Roman Character Encoding
For historical reasons, Roman character encoding has not always been consistent. The
Roman script system in particular contains many fonts with unique glyphs that are not
part of the Standard Roman character set. Since the character encoding is limited to 256
values, fonts such as Symbol, ITC Zapf Dingbats®, and other specialized fonts override
the standard Roman character encoding.
For example, in the standard Roman character set $70 corresponds to lowercase “p”,
but it is the numeric symbol for pi (“7”) in the Symbol font, an outlined square (“0”) in
ITC Zapf Dingbats, and the musical symbol pianissimo for play quietly in the Sonata font.
Hence, be aware that a Roman character code may have different interpretations in
different fonts.
Md

Furthermore, different variations of the Roman script system can have slightly different
character encodings to allow for their slightly different character sets. This situation
occurs only in the Roman script system; other script systems have uniform character
encodings. The Roman character set and its variations are described in more detail in the
appendix “Built-in Script Support” in this book.

Other 1-Byte Character Encodings
All 1-byte simple script systems have character encodings that can be thought of as
simple substitutions for parts of the standard Roman character set. As noted previously,
some encodings, such as Croatian or Turkish, replace or relocate relatively few characters,
and are still considered Roman scripts.
Other encodings for 1-byte simple script systems, such as Central European or Cyrillic,
replace much of the high-ASCII range of the Standard Roman character set (code values
from $80 to $FF) with a different alphabet.
The 1-byte complex script systems replace the same general range of Roman characters as
do the 1-byte simple script systems, but they also define additional text forms in order to
accommodate extensive use of ligatures or other contextual variations.
For all 1-byte script systems, the character sets include the standard low-ASCH control
characters (code values from $00 to $1F) and Roman characters (code values from $20 to

$7F). This allows users to enter Roman text, including western numbers, without having
to switch script systems. It also allows applications to display low-ASCII Roman text
regardless of the font in the current graphics port. It also means that control characters
are interpreted as control characters in any script system. Figure 1-37 shows the general
scheme of character encoding for 1-byte script systems.
Those 1-byte complex script systems that need more contextual forms than can fit in the
high-ASCH range solve the problem through associated fonts and fonts with special
glyph codes, rather than by changing any of the low-ASCII character encoding. See the
discussion of associated fonts in “Font Handling” beginning on page 1-60.

1-56

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-37

Character encodings for 1-byte script systems

Low Asel range
(ox

1x

2x

3x

4x

xO

Jnul

dle}

sp

QO

@_)>P

x1

Json|DC1)

| | 4

5x

High Ase
6x

7x

l|Qi

alg

|B

/|R}

bir

x2 | stx

|DC2}

"|

x3

Jetx

|DC3}

# | 3

x4

Jeot

|DC4)

xs
x6

Control
Codes

%
Roman
Uitely
& characters V
tly

x7

[bel

eto}

'

x8

| bs

can}

(

x9P

hi

em]

))/9

XA]

If

sub]

*

xB}

vi

esc}

+);

xc}

ff

fs},

$

| 4

| 7

Dx

Ex

Fx |

|G|Wigiw

Yi)

ily

Jo

Z)

jz

K.

[

k |

{

<

| L

\

|

|

=

Mi]

im)

}

xE | S° | 'S

>

|N/}*]n]

xF}

2

19

YS},

Cx

Script-specific
characters

|

Ss

Bx

dit

hh.

-

8

)/D)/T\

|X}

9S}

Ax

/>C/S/cis

-H

xD}

9x

p

| A

2

Bx

range

:

x

_ | o | del

2-Byte Character Encodings
Worldwide, the majority of script systems have character encodings that can fit within
the limits set by the size of a byte, which permits up to 256 distinct characters. However,
Asian scripts with ideographic characters, such as Chinese and Japanese, require
thousands to tens of thousands of characters. The Korean script system, which is not
ideographic, nevertheless requires at least 2,000 characters; furthermore, ideographic
Chinese-derived characters are often included in Korean text.
To define that many characters requires 2-byte character codes. The Macintosh script
management system is designed to handle 2-byte codes correctly. The use of script-aware
routines permits your application to handle text without having to know whether each
character code is 1 byte or 2 bytes, as long as the application allows for the possibility of
2-byte codes. Basically, that means not assuming that one byte equals one character, and
not breaking or truncating text in the middle of a 2-byte character.

How Script Systems Work

1-57

CHAPTER

1

Introduction to Text on the Macintosh

As with 1-byte script systems, the character encoding for each 2-byte script system
includes the standard ASCII control characters (code values from $00 to $1F) and the
low-ASCII Roman characters (code values from $20 to $7F) as a subscript. But in

addition, a 2-byte script system may include a second set of Roman characters with
2-byte character codes, and character encodings for several other subscripts besides that
of its native writing system. Figure 1-38 shows one example of a 2-byte encoding scheme.
IMPORTANT

2-byte scripts use a mixture of 1-byte and 2-byte encodings to represent
characters. You cannot use the terms byte and character interchangeably,
nor can you assume that every character is 2 bytes long. Obtaining
character-type information about characters is discussed in the chapter
“Script Manager” in this book. a
Japanese

Japanese is one of the most intricate writing systems in the world, containing four
individual subscripts: Romaji (alphabetic Roman letters), Katakana and Hiragana
(syllabic characters), and Kanji (ideographic characters). For example, the word Japan can
be written in these four ways, as
Romaji,

Katakana,

Hiragana,
or Kanji:

Nihon
RY

IAIZA

HAS

Romaji, Katakana, and Hiragana each have relatively few characters, but a minimal set of
Kanji contains over 3,000 characters.

The Japanese character encoding can be thought of as an extension of a typical
1-byte character encoding. Control codes and low-ASCII Roman characters are in
the range $00-$7F; script-specific 1-byte characters and the first bytes of 2-byte characters
are in the range $80-$FF. Additional 256-byte tables contain the second bytes of the 2-byte
characters.

1-58

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-38

Character encoding for a 2-byte script system (Japanese)

First byte or single byte
Low ASCII range
lox

1x

2x

3x

4x

5x

High ASCII range

Second

|

6x

7x

x0

gx

||

9x

Ax

Bx

Cx

Dx

Ex

Fx!

x0

xl

x1

x2

x2

x3

x3

x4

Ox

1x

2x

3x

4x

5x

6x

7x

byte
8x

9x

Ax

Bx

Cx

Dx

Ex

Fx

x4

xd

Control

x6

codes

1-byte Roman
characters

x7

1-byte

x5

and

x7

Katakana
characters
punctuation

x8

6

x8

x9

x9

xA

xA

xB

xB

xc

xc

xD

xD

xE

xE

iF

xF

[|

High-order byte of
2-byte characters

[|
|

Low-order byte of
2-byte characters

In Figure 1-38, each 2-byte character code is represented by a four-digit hexadecimal
number. The first two digits (the high-order byte) come from the First byte table, and
specify which of the many Second byte tables contains the character. The second two digits
(the low-order byte) come from the appropriate Second byte table. For example, the
character code for ] is $93FA (from column Fx at row xA in the Second byte table whose
location is specifed by the value at column 9x at row x3 in the First byte table).
Chinese

The Macintosh script management system supports two separate Chinese script systems:
Simplified Chinese and Traditional Chinese. Simplified Chinese consists of
approximately 8,000 ideographic characters, about 2,000 of which have been simplified
from their traditional presentation for ease of learning. Traditional Chinese consists of
approximately 13,000 of the traditional Chinese ideographic characters, called Hanzi.
Simplified Chinese and Traditional Chinese use incompatible character encodings; the
same character may have different character codes in the two scripts.

How Script Systems Work

1-59

CHAPTER

1

Introduction to Text on the Macintosh

Korean

The Korean script system is based on characters of the Hangul subscript, devised in 1443.
Chinese characters, called Hanja, are often mixed with Hangul, but their use is gradually
declining. The Korean Standard Hangul Coding Scheme for Communications (K55601)
defines 2,350 Hangul characters for Korean writing, which form the basic character set of

the Korean script system.

Hangul characters are syllabic blocks composed of component elements called Jamo.
Jamo can be simple or double consonants and vowels. There are 24 simple Jamo elements
and 27 double elements.
The first sound in a Hangul block is a simple or double consonant, the second is a simple
or complex vowel, and the third (optional) sound is a simple, double, or complex
consonant. Figure 1-39 shows an example. Each Hangul character (on the right) can have
two or three elements (first sound and middle sound, plus optional last sound).

Figure 1-39

s+

ge}

Constructing blocks (Hangul) from elements (Jamo) in Korean

} 3s

3}

> shy

}

=> oh

Bh+Lroy =-> BhO}
| > US
»

Eas

Font Handling
As discussed under “Fonts” on page 1-44, a Macintosh font provides a specifically
designed set of glyphs that implement the character set and other written forms that
belong to a given script system. Fonts can be classified as 1-byte and 2-byte, and as
bitmapped or outline. Some fonts provide plain (unstyled) glyphs, whereas others
provide styled variations, such as bold or italic. This section summarizes some of the
basic font issues to keep in mind when working with text, and especially multiscript text.

1-60

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Font Availability and Selection
You cannot display text in a given script system without a font for that script system. A
font is available only if its file resides in the Fonts folder within the System Folder, or if its

resources are installed in the System file itself.

In terms of font availability and font selection for text, remember these points:

mw The script management system uses font family ID (the ID number of the font resource
of type 'FOND') to refer to fonts. That is the ID you supply as a parameter to
text-handling calls. However, do not store font family ID numbers in your text files;
store font names instead, and redetermine the ID numbers at run time with Font

Manager calls. Font family IDs are not unique, and the system can renumber fonts
between executions of your application.
m Every font family has an ID number in a range that identifies the script system it
belongs to. Identifying the font family used to write text is equivalent to identifying
the script system of that text. See Figure 1-35 on page 1-50 for an illustration of
resource ID ranges. A text string in a font with a font family ID of 200 is interpreted as
Roman text, while the same text string in a font whose ID is 17000 is interpreted as
Chinese text and displayed accordingly. You can use the Script Manager to convert
font IDs into script codes.
m Because the script management system uses the font associated with a given range of
text to determine the script system of that text, store your text in such a way that, for
each run of text, you track the font to be used to display it.
m Because the script system can be determined from just the font family ID, the Font
Manager can use that information to substitute a font of the proper script system, even
when an entire font family is missing.
m Because the Roman script system is present in all Macintosh systems, at least two
Roman fonts are always available: 12-point Chicago and 12-point Geneva.

System Font and Application Font
Macintosh system software recognizes two special fonts that should always be present:
the system font and the application font. The system font is the font used for menus,
dialog boxes, and other messages to the user from the Finder or Operating System. The
application font is the suggested default font for use by monostyled TextEdit and by
applications that do not support user selection of fonts. In all unmodified Roman
versions of Macintosh system software, the system font is 12-point Chicago and the
application font is 12-point Geneva.
In all localized versions of Macintosh system software, whether Roman or not, the system

font has a special font designator of 0, and the application font has a special designator of 1.
These special designators are not actual font family resource ID numbers and cannot be
used as such in Resource Manager calls; however, you can use them in place of a font

family ID in the txFont field of the graphics port, and in text-related calls that take a
font family ID, such as Font ToScript. The system maps the special designators to the
actual font family IDs for the system font and application font. You can use the Font
Manager to determine the actual ID numbers of the system font and application font for
any system script.

How Script Systems Work

1-61

CHAPTER

1

Introduction to Text on the Macintosh

Remember these points about the system font and the application font, in relation to
Chicago font, Geneva font, and the special designators:
m On localized versions of system software in which the system script is Roman, Chicago
is the system font and it has a font family ID of 0. The special designator 0 also refers
to Chicago font.
mw When the system script is non-Roman, Chicago has a different font family ID (usually
16383), and the special font designator 0 refers to the system font for the non-Roman
system script. On system software in which Japanese is the system script, for example,
a value of 0 in the txFont field means the Osaka font, which has a font family ID
of 16384.
m When the system script is Roman, Geneva is the application font and it has a font
family ID of 3. The special designator 1 also refers to Geneva font.
m When the system script is non-Roman, Geneva has the same font family ID of 3, but
the special font designator 1 refers to the application font for the non-Roman system
script. On system software in which Thai is the system script, for example, a value of 1
in the txFont field means the Thonburi font, which has a font family ID of 26625.

m The actual font family ID of the system font is specified in the low-memory global
variable SysFont Fam; the actual font family ID of the application font is specified in
the low-memory global variable AppFont ID. You can get the actual font family ID of
the system font or the application font by making Font Manager calls; see the chapter
“Font Manager” in this book. You can also get the actual font family ID of the
preferred system font or application font for a script system by making Script Manager
calls; see the discussion of script variables in the chapter “Script Manager” in this
book.
Perhaps the most common mistake developers make in adapting their applications to
global markets is to assume that the application font is always Geneva. Do not assume that
different script systems have the same system and application fonts.

Roman Characters and Associated Fonts
All Macintosh script systems include the low-ASCII Roman characters and control
characters as part of their character sets. Most non-Roman fonts provide glyphs for those
low-ASCII Roman characters. If the font itself does not contain those characters, the script
system substitutes characters from an associated font—a Roman font that is associated
with that script system—for character codes (mostly in the low-ASCII range) that the
script system determines are Roman. Some contextual script systems must use associated
fonts because they need more glyphs than can fit into the high-ASCII range normally
available for native glyphs.
Note
A script system specifies the associated font for its system font and
application font, but may allow the user to select a single Roman font to
associate with all other fonts of the script system. @

1-62

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

In most cases your application does not have to account for associated fonts; glyphs from
the associated font are substituted automatically when you draw text that contains
Roman characters. However, keep in mind that font measurements (such as the results of
the Get Font Info and FontMetrics procedures) always account for the width and
height characteristics of both the current font and the associated font. This can sometimes
cause unexpected results, such as a line height that is greater than the current font’s
expected line height. The Get Font Info procedure is described in the chapter
“QuickDraw Text” in this book; font measurement and the FontMet rics procedure are
further described in the chapter “Font Manager” in this book.
There are several other issues to keep in mind related to Roman characters and
Roman fonts:
m Remember that the presence of Roman glyphs in displayed or printed text does not
necessarily imply that they were created with a Roman font. The Text Utilities can help
you locate Roman characters in a text buffer and explicitly change them to the Roman
script system, if you wish.
m As noted on page 1-56, the Roman script system does not have a consistent character
set across all fonts. For example, character codes in the Symbol font map to different
glyphs from the same character codes in the Geneva font. Conversely, identical
symbols can have different character codes in different fonts. The division sign (+) is
located at $D6 in the Helvetica font and $B8 in the Symbol font.
m Inconsistent character codes for symbols other than letters and numbers can also be a
problem across script systems. For instance, in the Roman script system the division
sign (+) is located at $D6 in most fonts, whereas in the Arabic script system the
division sign (+) is at $9B.

Other Font Issues
In general, when drawing text, you set the font characteristics before you make a call, and
the script management system makes sure that the font you specify is used. However,
there are some issues and complications to keep in mind:
m Ifa particular size or styled variation (such as bold or italic) of a font is not available
on the computer, the Font Manager can scale an existing size and QuickDraw can
apply a style to an existing plain version of a font. Certain styles may be disabled in
scripts where they are inappropriate. You can use the Script Manager to determine all
of the valid styles for a given script system.
m The setting of the font force flag is controlled by the user when a script system that
supports it is the system script. If the font force flag is TRUE, text written with a Roman
font is considered instead to be text of the system script; any character codes
corresponding to native characters of the system script are drawn in the system font
rather than in the specified Roman font. If you do not want that to happen in your
application, you must monitor the state of the font force flag and change it temporarily
whenever necessary.
m The font force flag exists to permit multiple-language support by applications that
expect a single font. It is only a partial solution to the problem. Do not hardcode your
application to require any single font.

How Script Systems Work

1-63

CHAPTER

1

Introduction to Text on the Macintosh

m If your application needs to have a font whose characters should never be interpreted
as system script characters (for example, symbol fonts used for paint program
palettes), you can assign the font an ID in the reserved range $7E00 to $7FFF
(uninterpreted symbols) rather than in the Roman range. Then, even if the font force
flag is set to TRUE, your symbols are not re-interpreted as system-script characters.
m When displaying characters as they are typed in by the user, you must make sure that
the font for text display belongs to the same script system that is used for text input.
See “Font Script and Keyboard Script” beginning on page 1-51.
mw Many fonts—particularly those associated with non-Roman writing systems—do not
draw legibly unless they are at least 12 point. However, you cannot assume that the
system font size is always 12 point. Use QuickDraw, Font Manager, and Menu
Manager calls to get the default size for the system font, default size for the current
font, and required menu bar height for the system font.
m Do not assume that the application font exists in a 9-point size. Use the Script Manager
to determine the application font family and size for legible small text.
m Diacritical marks (such as the acute accent over the “E” in “Ecole”) may extend above
or below the normal limits for character height. The Font Manager allows you to either
extend the spacing between lines or shrink the marked characters to make sure that
the characters are not cut off at the top or bottom.
m If you use your own menu-definition ('MDEF') resource to draw a Font menu in your
application, be sure it can draw all font names correctly. It should use the font itself, or
a font of the same script system, to display the font name. See the Menu Manager
chapter of Inside Macintosh: Macintosh Toolbox Essentials for more information on
creating menus.
m A2-byte font can be very large; outline fonts for 2-byte script systems can contain
single resources over 6 MB in size. Large numbers of 2-byte fonts can be a storage

problem for the user. Furthermore, because the Resource Manager limits the size of a

file’s resource fork to 16 MB, it may be difficult to include 2-byte fonts with your
application or document files.

Character Rendering and Text Display
The process of properly preparing characters for display is called character rendering.
When QuickDraw draws a character, string, or line of text, it takes the stored character

codes you supply it and processes them if necessary to take into account line direction,
contextual substitution, or character reordering. It uses the rules of the font script (the

script system of the current font of the active graphics port) to make these calculations.
QuickDraw then gets the glyphs for the resulting characters from the Font Manager, and
draws the glyphs in order on the screen, starting at the current pen location.

1-64

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

IMPORTANT

A fundamental assumption of the Macintosh script management system
is that contextual analysis, character reordering, and the formation of

ligatures should occur during the display of text, not its storage. That way
the stored version of text can be much simpler; it contains only the basic
characters of its writing system. Searching and other text-manipulation
tasks are much more straightforward that way. It is the Macintosh script
management system that has the job of handling differences between
storage order and display order, and differences between stored codes
and displayed glyphs. a
The 1-byte simple script systems and all 2-byte script systems currently have no
individual character-rendering specifications; QuickDraw’s built-in ability to draw
characters sequentially in a given font, style, and size is sufficient.
The 1-byte complex script systems carry character-rendering information in line-layout
tables in their encoding /rendering ('it15') resources. WorldScript I performs the
rendering based on specifications in those tables.
The section “Features of the World’s Writing Systems” beginning on page 1-21 shows
examples from writing systems that require the kinds of rendering abilities provided by
the Macintosh script management system. Your application should not have to explicitly
perform any of these tasks; you merely store character codes, and the script management
system renders those characters properly whenever you need to display them.

Storage Order and Display Order
QuickDraw draws glyphs and lines of text from left to right only. This left-to-right
orientation of QuickDraw is fundamental, and applies whether or not the text being
drawn is meant to be read left-to-right or right-to-left. Each character is drawn with its
origin (usually its left edge) placed at the current pen location, and after it is drawn
QuickDraw moves the pen location rightward by the width of the glyph. Likewise, when
QuickDraw draws a string of text, it keeps advancing the location as it draws, so that the
pen location ends up at the right end of the string.
Display order is this left-to-right order in which QuickDraw draws glyphs on a display
device. For example, QuickDraw draws a string of Hebrew text in reverse order from

the way the string is read: the glyph for the last ( = leftmost) character in the string is

drawn first, and the glyph for the first (= rightmost) character in the string is drawn last.

Figure 1-40 is an example showing a line of mixed Arabic and Roman text. The glyphs are

drawn as shown, from left to right in the sequence labeled Display order, even though the

primary line direction is right-to-left.

How Script Systems Work

1-65

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-40

Byte

Storage order and display order

Character
codes
Characters

offsets
0 | $E5

°

11$C7

|

2/$D1

|»

3/$E3 | J

“

ana

ele

order
an

eee

9}

$69 | 1

10|

$63

Storage
order

_—

2

pit

14

10

au

8

13

3 (Arabic 1

12

4

=

10 —

14

12
|

ax

U

Jc

11 | $29
12|S$CF

= right to left
Primary line direction

~

4 | $26 | (

|)

|

3

13)

$EA

S

14}

$E1

| 3

15 | $D3

uw

Storage order is the sequence of character codes in memory. The Macintosh script
management system assumes that your application stores characters in the order in
which they would be typed in—that is, with the first character code in a string at a lower
address than subsequent character codes in that string. Storage order is different from
display order for text with a right-to-left line direction.
In Figure 1-40, for example, the line of numbers labeled Storage order shows the byte
offset in the buffer of the character for each glyph. Note that the glyphs for the Hebrew
characters are drawn in reverse sequence from the order in which they are stored,
whereas the glyphs for the Roman characters are drawn in the same sequence as their
storage order.
If your application stores its text in the expected storage order, the script management
system properly orders all characters within each style run that you draw.
Storage order can differ from display order not only in the sequence of individual
characters within a run of text, but also in the order in which entire runs of text are drawn

on the screen. See Figure 1-41 on page 1-67 for an example. If multiple scripts with

different line directions occur on a single line, determining the order in which to draw the

individual runs can be complex. The Macintosh script management system helps you
with that determination; see the discussion of the Get Format Order procedure in the
chapter “QuickDraw Text” in this book.

1-66

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Line Direction and Alignment
Writing systems exist with several different line directions, as shown in Figure 1-14 on
page 1-24. The Macintosh script management system supports two of them: left-to-right
(used for Roman and most other writing systems), and right-to-left (used for Arabic and
Hebrew). As noted earlier in this chapter, Arabic and Hebrew systems are considered
bidirectional rather than purely right-to-left because numbers and commonly intermixed
foreign words are written from left to right. And although Japanese and Chinese are
traditionally written vertically, the Japanese and Chinese script systems currently support
only a left-to-right line direction.
The Macintosh script management system supports multiscript text, including text with
mixed directions, in a single line. The layout, measurement, and drawing routines can

help you correctly render textN even justifed textN from multiple script systems.
Primary Line Direction

When text with different line directions is mixed on a single line, the primary line
direction is the principal, controlling direction for display of that text. The concept
of primary line direction is important because it affects the order in which text elements
are drawn. For example, suppose a block of Hebrew text follows (in storage order) a
block of Roman text. If the primary line direction is left-to-rightN equivalent to
saying that the Hebrew text is embedded within a line of Roman textN the Hebrew text is
drawn after and to the right of the Roman text. If the primary line direction is
right-to-leftN equivalent to saying that the Roman text is embedded within a line
of Hebrew textN the Roman text is drawn after and to the right of the Hebrew text.
Figure 1-41 illustrates the concept.
Figure 1-41

Byte

offset

0}

How primary line direction affects display order

Character
codes
$41

Characters

Primary line direction

JA

1|

$42

1B

2/

$43

|C

3]

$E0

|N

sean
5|
$E2
|)

A

B

C

p| a

_

Primary line direction

_

N

JIN ABC

Your application controls the primary line direction of its text by specifying it in
parameters to certain text-layout calls such as the QuickDraw Get FormatOrder
procedure. You can set your primary line direction independently of any system settings,
but TextEdit and many text-processing applications tie their primary line direction to the
current value of the system direction.
How Script Systems Work

1-67

CHAPTER

1

Introduction to Text on the Macintosh

The system direction is a global setting, used by all parts of system software to control
the alignment of text elements in dialog boxes, menus, and so on. TextEdit sets the

primary line direction of its text to the system direction. Some script-aware routines
assume that the primary line direction for the text they manipulate is equal to the system
direction; see, for example, the description of the CharToPixel function in the chapter
CQQuickDraw TextOin this book.

System direction is determined by the value of the low-memory system global variable
SysDirection. At startup, SysDirection is initialized to the line direction speci

ed

by the system@ international con guration ('it1c') resource. That value is commonly
localized to correspond to the primary line direction of the system script, but if a
bidirectional script system is enabled the user can control the system direction from the
Text control panel; see CUser Control of Script SettingsObeginning on page 1-107.
Your application (and other applications) can also control the system direction with
Script Manager routines. Do not simply assume a value for system direction.
The right-to-left primary line direction of bidirectional script systems has several
further implications for program design. In working with bidirectional text, remember

these points:
m Characters are read from right to left. Numerals are read from left to right. A word
processor must therefore implement two sets of tabs and two ruler directions.
= Mathematical expressions are read from left to right in Hebrew and from right to left
in Arabic. If in Hebrew one writes @ + 4 = 10Q in Arabic the same expression in the
same order would be written C10 = 4 + 6O

m The concepts of leading edge and trailing edge of a glyph are important for
mouse-down event testing, caret positioning, and highlighting. In left-to-right text, a
eglyph@ leading edge is its left edge; in right-to-left text, a glyph@ leading edge is its
right edge. See GQCaret HandlingObeginning on page 1-74.
mw Some punctuation marks and numerals from the Standard Roman character set are
duplicated at different locations in bidirectional character sets in order to account for
this. For example, the exclamation point (!) is at $21 in the Standard Roman character
set, but Hebrew and Arabic add a second, right-to-left version of it, at $A1.

m Despite the fact that a single style run in a bidirectional script system can contain two
directions of text, your application can treat it as a unit. See the note on bidirectional
style runs on page 1-71.
Alignment

Alignment is the horizontal placement of lines of text with respect to the left and right
edges of the text area or page. Text is typically left-aligned, right-aligned, centered, or
justi edN aligned to both the left and right margins. See Figure 1-15 on page 1-25.
A script system@ default text alignment usually follows its line direction. The system
global variable SysDirection, which controls line direction, also controls the default
alignment for text and other items in dialog boxes, alerts, and menus. For example, in

Arabic system software (and in applications localized to the Arabic script system) menu
items are right-aligned, and radio buttons and checkboxes are modi ed so that the boxes
or buttons themselves are on the right. The user controls the system alignment by
1-68

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

controlling the system direction with the Text control panel. See GUser Control of Script
SettingsObeginning on page 1-107.
TextEdit uses the value of SysDirection, to set the default alignment for text in
its windows.

You should anticipate that right alignment might occur in your application@ text
elements. Be sure to allow for it:
m= Do not assume that, once you have measured the length of a line of text, you can
always place it at the left margin. For right-aligned text, you need to indent the pen
location from the left margin by an appropriate amount so that the right end of the text
line falls on the right margin.
m Do not allow a text item in a dialog box to extend to the right of the dialog-box
boundary; the right edge of a line of text in that item will be truncated if text is
right-aligned. See Figure 1-42 for an illustration of this.
Figure 1-42

Dialog items truncated at dialog-box boundary

Static text

)

Static text

I Dialog item should
not extend to the
right of dialog-box
_) boundary

Static text

[ Cancel

|

[

OK

|

mw When creating a column of checkboxes or radio buttons, make the text boxes all the

same length. This ensures that when the line direction and alignment are reversed, the
checkboxes or radio buttons remain correctly aligned.

If you are speci cally formatting right-aligned text in a bidirectional script system,
remember these additional alignment issues:
mw Text is typically right-aligned. It breaks near the left margin and continues at the right
margin of the following line. However, the QastOcharacter on a line is not always the
leftmost; see, for example, Figure 1-27 on page 1-31.

m Headers, footers, and footnotes are typically right-aligned.
m Ina

table or list, the

rst column is the rightmost.

m Line indentation is measured from the right margin.
m Odd pages are on the left in a book, and even pages are on the right. The inside front
cover is on the right when a book is opened, and page 1 is on the left.

How Script Systems Work

1-69

CHAPTER

1

Introduction to Text on the Macintosh

Justification

Justified text, which is aligned to both the left and right margins of the text area,
is a special form of alignment that poses particular challenges to multiple-language
formatting. The Macintosh script management system provides an entire set of routines
for measuring, laying out, and drawing lines of justi ed text. See, for example, the
descriptions of the PortionLine and DrawJustified routines, and the discussions
of measuring and drawing lines of justi ed text in the chapter GQQuickDraw TextOin
this book.

Style Runs, Font Runs, Script Runs, Direction Runs
When QuickDraw draws a character or string of text, it examines the current graphics
port record to determine how the text should be drawn. The font (and therefore the script
system), the point size, and the style of the text are all determined by elds in the current
graphics port.
This feature of QuickDraw has several consequences. First, it means that you must be
sure to set the graphics port elds properly before calling QuickDraw. Second, it means
that each call to QuickDraw must be restricted to a run of text that has uniform values for

all those

elds.

This nest division of the runs of text in your document is called a style run. A style run
comprises the set of contiguous characters that all share the same font, size, and style
characteristics. Because they share the same font, they naturally share the same script
system. The style run is the most important organizational unit for script-aware text handling,
and your application should always maintain style-run information for all its text. For
many script-aware calls, you. rst set up the graphics port record appropriately and then
make the call, passing it a single style run of text (or even less than a single style run, if
the style run spans more than one line of text).
A larger division than style run is the font run; it consists of those characters that share
the same font (and therefore the same script), but do not all share the same size or style
attributes. You need not reset the txFont eld of the graphics port between calls that
involve text within a single font run.
The next larger division is the script run; it consists of all contiguous characters that
belong to a given script system, regardless of their individual fonts. Within a script run,
all the text@ formatting and text-manipulation speci cations are constant; there is no
need to load different resources or validate the existence of another script system
between calls involving a single script run. If your application does not support multiple
script systems, all of your text is a single script run.
The largest division is the direction run. A direction run consists of all contiguous
characters with the same line direction, regardless of what script system they belong
to. (However, see the note on bidirectional style runs page 1-71.) Within a direction
run, the display order of characters and style runs has a very simple relation to their
storage order. If all of your text consists of a single direction run, your text-layout tasks
are simpli ed.

1-70

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-43 shows a line of text and its separation into style runs, font runs, script runs,
and direction runs.
Figure 1-43

text:
Direction run

Style runs, font runs, script runs, and direction runs in text

small Large
a

.. Jl

TIAY

Hebrew

Nihongo

=

-Xi#H

at

Script run

Roman

Arabic

Hebrew

Font run

.
Times

Baghdad

| Ramat Gan

Geneva

New York

Ryobi Hon
Mincho

Baghdad
16

| Ramat Gan
16

| Geneva 10
italic

New York
10

Ryobi Hon
Mincho 10

Style run

Times
10

Times
14

Roman

Japanese

Runs of Roman characters in text of anon-Roman script system are not necessarily
considered separate style runs, and may be displayed (as Roman characters) in the
non-Roman font of that script system. For greater formatting control, however, you may
want to explicitly separate out those Roman characters into style runs of their own. You
can use a Text Utilities routine to do so.
Bidirectional style runs
Bidirectional script systems have a unique concept of a style run.
Numerals and Roman characters in a bidirectional style run have a
different direction from the rest of the native text, but your application
needn@consider them as separate style runs. The script management
system handles all the special formatting, highlighting, and character
location for you in these cases, so you can treat such a mixed-direction
sequence just as you would any other single style run. @

Text Layout
Laying out lines of textN calculating how many characters

t ona

line, determining the

order of drawing of all the elements, performing all contextual formatting, and drawing

the textN is a standard task in word processing. It can be a challenging task in a single
language, but it is especially dif cult to write a text-layout routine that is general enough
to work with text in any script system. Even more complex is the laying out of text from
several script systems in a single line. Add to that the complications of trying to draw
justi ed lines of multiscript text, and the task can appear daunting.
The Macintosh script management system includes several groups of routines that ease
the task by helping you write very generalized text-layout code that can handle
multiscript lines of text, and can even justify those lines appropriately for the script
systems involved. Routines from the Script Manager, the Text Utilities, and QuickDraw
cooperate to analyze, arrange, format, measure, and draw the text.

How Script Systems Work

1-71

CHAPTER

1

Introduction to Text on the Macintosh

There are two main principles that control how text layout occurs on the Macintosh:
m There is no system support for layout of more than a single line at a time. You are
responsible for knowing where in memory your line starts and where on the screen to
start drawing it.
m (Nearly) all text-layout routines operate on a single style run at a time. Therefore, to
handle text with potentially multiple styles or scripts on a single line, you may need to
call a routine repeatedly, once for each style run on the line.
Therefore, if a syle run extends beyond the boundaries of the current line, you call
the routine for only that portion of the style run that is on the line. The part of a style run
that exists on a single line is called a text segment in the chapter GQQuickDraw TextOin
this book.
In general, text layout involves taking the following steps, in order, for each line you
intend to draw:
1. Starting with the buffer location of the

rst character on the line, and knowing the

width of your display line in pixels, calculate the byte offset of the character at which
to break the line. There are several ways to do this, using both QuickDraw and Text
Utilities routines. The routines give proper results for any script system.

2. Determine the order in which to draw the individual style runs on the line, using a
QuickDraw routine. If the line contains mixed-directional text, the left-to-right order in
which you draw style runs may not be the same as the order in which they occur in
memory. See, for example, Figure 1-41 on page 1-67.

If you are drawing justi ed text, take these additional steps:
4 Eliminate trailing spaces at the end of the rightmost or leftmost (depending on the
primary line direction) style run on your display line, so your justi ed text will line
up properly. You can use a QuickDraw routine for this purpose (remember that a
space character may not have the ASCII value $20 in a non-Roman script system).
0 Calculate the slop value, the extra amount of space that needs to be distributed
throughout your line of text. Do that by measuring the total pixel width of all the
style runs on the line and subtracting that from the display line width.
O Calculate how to distribute that slop value among the style runs on your line, using
a QuickDraw routine.

3. Position the QuickDraw pen both vertically and horizontally. The horizontal position
must be at the left end of the text to be drawn on the line, regardless of the primary
line direction. The vertical position is your responsibility; if you are drawing multiple

lines in sequence, you can use QuickDraw or Font Manager routines to obtain
font-height information to help you position the pen.

4. Draw the text, a style run at a time, using QuickDraw calls. For justi ed text, pass the
amount of slop you calculated for each style run when you call the drawing routine for
that run.

1-72

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

You can also use QuickDraw and Text Utilities calls to draw explicitly scaled multiscript
text, in which the character are enlarged, shrunk, or distorted from their normal shapes;

and you can even draw justi ed, scaled, multiscript text. For more information on text
measurement and drawing, see the chapter GQuickDraw TextOin this book. For more
information on line breaking, see the chapter (Text UtilitiesOin this book.
Remember these points when laying out and drawing lines of text:

There are tables available that help you measure text before drawing it. The global
width table is a table constructed in memory every time FMSwapFont is called; it can
be used to calculate the pixel width of each glyph in a font, and it is helpful in
determining line lengths. Each font family resource may have an optional width table
with normalized glyph widths. Bitmapped fonts have tables that give the actual
integer widths for their glyphs. For more information on these tables and on the
FMSwapFont call, see the chapter Font ManagerOin this book.
Don@break text into arbitrary chunks before formatting it for display: the second byte
of a 2-byte character can be lost, or improper contextual formatting can result. If you
need to truncate the displayed text at a location that is not a style run boundary or a
valid line break or word boundary, use the QuickDraw clipping facility rather than
truncating the string.
Roman characters within style runs of a non-Roman font may display better if
converted to the Roman script system and formatted as Roman text. You can use the
Text Utilities to locate sequences of such characters.
If you are measuring the pixel width of a line of text before drawing it, keep these
cautions in mind:
Do not assume that a glyph for a given character code always has the same
width. With certain scripts, using the Font Manager global width tables may give
inaccurate results. The QuickDraw text-measuring routines return correct results for
all script systems.
Do not assume that specifying a xed-width font in a graphics port always produces
monospaced text. For example, the printed versions of some glyphs in some
xed-width fonts (such as O Oin Courier) have widths different from other glyphs in
the font. Furthermore, when the Script Manager font force Sag is set, the user might,
for example, insert a wide Japanese character within a line of Monaco text. See the
description of the font force Sag in the chapter GScript ManagerOin this book.
Some characters, such as diacritical marks, may have zero width. A zero-width

character should never be divided from the previous character in the text when you
partition text. When truncating a string to t into a horizontal space, the correct
algorithm is to truncate from the end of the string toward the beginning, one character
at a time, until the total width is small enough. This prevents cutting text before a
zero-width character. You can also call Text Utilities functions to perform the
truncation correctly.

How Script Systems Work

1-73

CHAPTER

1

Introduction to Text on the Macintosh

m Donotset the chExtra eld of the graphics port to a nonzero value with text
containing connected glyphs or text that may include zero-width characters.
Diacritical marks are placed incorrectly in relation to their base characters, and
connected glyphs have white space inserted improperly, like this:
chExtra

=0

chExtra

nonzero

cst

ste

fect

feral

Caret Handling
By standard word-processing convention, the selection range is the sequence of zero or
more charactersN contiguous in memoryN where the next editing operation is to occur. A
selection range of zero characters is called an insertion point.
Highlighting a selection range and marking the insertion point both involve converting
offsets of characters in a text buffer into pixel positions on a display device. In multiscript
text, expecially text that has mixed line directions and contextual formatting, this can be a
complex task.
The Macintosh script management system provides a routine that helps you draw carets
properly for text in any combination of script systems. The QuickDraw function
CharToPixel returns the onscreen pixel position corresponding to a given offset in your
text buffer. The function returns the horizontal offset (in pixels) from the left margin of
the text you pass it to the proper caret position corresponding to the character at the
speci ed byte offset in your text buffer.
Caret and cursor

By convention in this book, the caret is de ned as the blinking bar that
marks the insertion point in text. The cursor, on the other hand, is the
arrow, I-beam, spinning disk, or other small icon that marks screen

position and moves with the mouse.

@

This section discusses the conventions underlying the relationship of text offset to
caret position. For more information on conversion of text offset to screen position,
see the description of the CharToPixel function in the chapter GQQuickDraw TextO
in this book.

1-74

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

The Caret

A caret position is a location on the screen that corresponds to an insertion point in
memory. It lets the user know where in the text le the next insertion (or deletion ) will
occur. A caret position is always between glyphs on the screen, usually on the leading
edge of one glyph and the trailing edge of another. The leading edge of a glyph is the
edge that is encountered rst when reading text of that glyph@ script system; the trailing
edge is opposite from the leading edge. In left-to-right text, a glyph@ leading edge is its
left edge; in right-to-left text, a glyph@ leading edge is its right edge.
In most situations for most text applications, the caret position is on the leading edge
of the glyph corresponding to the character at the insertion point in memory; see
Figure 1-44. When a new character is inserted, it displaces the character at the insertion

point, shifting it and all subsequent characters in the buffer forward by one character
position. (That shift may be one or two bytes, depending on the size of the inserted
character.)
Figure 1-44

Byte
offsets
O|

Caret position and insertion point

Character
codes

Primary line direction = left to right

ar ]A
$41

3|

=|

4|

$45

2

$44

Characters
|A

Trailing edge of C

|D ~<—\ Insertion point
offset
= 3
JE

(

awa

>
Leading edge of D

A BCIDE

)

Caret position

The caret position is unambiguous in text with a single line direction. In such a case, the
caret position is on the trailing and leading edges of characters that are contiguous in the
text buffer; it thus corresponds directly to a single offset in the buffer. This is not always
the case in mixed-directional text, as described next.

How Script Systems Work

1-75

CHAPTER

1

Introduction to Text on the Macintosh

Caret Positions at Direction Boundaries

In determining caret position, an ambiguous case occurs at direction boundaries because
the byte offset in memory can map to two different glyph positions on the screenN one
for text in each line direction. In Figure 1-45, for example, the insertion point is at byte
offset 4 in the buffer. If the next character to be inserted is Arabic, the caret should be
drawn at caret position 4 on the screen; if the next character is English, the caret should

be drawn at caret position 12.
Figure 1-45

Byte
offsets

Caret positions at direction bondaries

Character
codes

0|

Characters
$E5

e

1/$c7
|
2/$D1 | 5
3| $E3 | J
4|

$28 | ( ~— Insertion point
$41

1A

6|

$72

Ir

7/

$61

|a

5}

8| $62 |b
9] $69 |i
10|

$63

Jc

11 | $29

|)

(offset = 4)

_
16

Primary line direction
= right to left
15

ats

1-76

GS

14/$E1

|

15 | $D3

ue

1

12

11

10

°

How Script Systems Work

\*? |

9

é

7

6

|

bic

(

12 | SCF | >
13|$EA

14

°

T

2

|

!

Ye sf

Ara

1

ye
!

Caret position for
Roman text entry

Caret position for

Arabic text entry

oO

Caret

position

CHAPTER

1

Introduction to Text on the Macintosh

The Macintosh script management system codi
and caret position as follows:

es this relationship between text offset

m For any given offset in memory, there are two potential caret positions:
4 the leading edge of the glyph corresponding to the character at that offset
O the trailing edge of the glyph corresponding to the previous (in memory) character
(The rst and last characters of a text segment are special cases; see the discussion of
the CharToPixel function in the chapter GQuickDraw TextOin this book.)
m In unidirectional text, the two caret positions coincide: the leading edge of the glyph
for one character is at the same location as the trailing edge of the glyph for the
previous character. In Figure 1-44, the offset of 3 yields caret positions on the leading
edge of (DOand the trailing edge of CCQ which are the same unambiguous location.
m Ata boundary between text of opposite directions, the two caret positions do not

coincide. Thus, in Figure 1-45, for an offset of 4 there are two caret positions: 12, on the

leading edge of QQ and 4, on the trailing edge of QO Likewise, an offset of 12 yields
two caret positions (also 12 and 4, but on the edges of two different glyphs).

At an ambiguous character offset, the current line direction (the presumed direction of

the next character to be inserted) determines which caret position is the correct one:
O If the current direction equals the direction of the character at that offset, the caret
position is the leading edge of that character@ glyph. In Figure 1-45, if Roman text
is to be inserted at offset 4 (occupied by a Roman character), the caret position is on
the leading edge of that character@ glyph (QON that is, at caret position 12.
4 Ifthe current direction equals the direction of the previous (in memory) character,
the screen position is on the trailing edge of the glyph corresponding to that
previous (in memory) character. In Figure 1-45, if Arabic text is to be inserted at
offset 4, the caret position is on the trailing edge of the glyph of the character at
offset 3 (QJON that is, at caret position 4.

Two common approaches for drawing the caret at direction boundaries involve the use of
a dual caret and a single caret. A dual caret consists of two lines, a high caret and a low
caret, each measuring half the text height; see Figure 1-46. The high caret is displayed at
the primary caret position for the insertion point; the low caret is displayed at the
secondary caret position for that insertion point. Which position is primary, and which is
secondary, depends on the primary line direction:
m The primary caret position is the screen location associated with the glyph that has the
same direction as the primary line direction. If the current line direction corresponds to
the primary line direction, inserted text will appear at the primary caret position. A
primary caret is a caret drawn at the primary caret position.

How Script Systems Work

1-77

CHAPTER

1

Introduction to Text on the Macintosh

m The secondary caret position is the screen location associated with the glyph that has
a different direction from the primary line direction. If the current line direction is
opposite to the primary line direction, inserted text will appear at the secondary caret
position. In Figure 1-46, the display of the Roman keyboard icon shows that the
current line direction is not the same as the primary line direction, so the next
character inserted will appear at the secondary caret position. A secondary caret is a
caret drawn at the secondary caret position.
Figure 1-46

Dual caret at direction boundaries in mixed-directional text
Roman

keyboard
icon

|

Cpt 2(Arabic)' | ye
|
Secondary
caret

=

Primary
caret

A single caret (or moving caret) is simpler than a dual caret; see Figure 1-47. It is a single,
full-length caret that appears at the screen location where the next glyph will appear. At
direction boundaries, its position depends on the keyboard script. At a direction
boundary, the caret appears at the primary caret position if the current line direction
corresponds to the primary line direction; it appears at the secondary caret position if the
current line direction is opposite to the primary line direction. The moving caret is also
called a jumping caret because its position QumpsObetween the primary and secondary
caret positions as the user switches the keyboard script between the two text directions
represented.

1-78

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-47

Single carets at direction boundaries in mixed-directional text
Roman

keyboard
icon

@

File

Edit

Font

Style

Format
Styled Text

yuk of Arabic) J,
Arabic

keyboard
icon

| guto(Arabiofsjle =
The script management system permits the user to select a preference between dual
carets and a single (moving) caret; your text application should support both. TextEdit
employs both types of carets; see the chapter OlextEditOin this book.
Caret Movement With Arrow Keys
Most text applications allow the user to move the caret through displayed text with the
arrow keys. In general, using the Right or Left Arrow key should move the caret
uniformly right or left, regardless of the line direction of the text in which the caret
appears. To do this means that your application needs to take the current line direction
into consideration, rather than simply advancing the insertion point through the text
buffer in response to presses of, say, the Right Arrow.
When the caret moves through a direction boundary (or any style run boundary) in
response to a series of arrow keypresses, you need to set the keyboard script (and
graphics port settings) to match the characteristics of the text that the caret is in. By
convention, you should change the keyboard script and port characteristics after the caret
has passed the boundary, not when it rst reaches it.
For a discussion of how TextEdit handles the complications that occur at direction
boundaries and within runs of bidirectional text, see the chapter (fextEditOin this book.

How Script Systems Work

1-79

CHAPTER

1

Introduction to Text on the Macintosh

Highlighting
When displaying a selection range, an application typically marks it by highlighting,
drawing the glyphs in inverse video or with a colored or outlined background. As part of
its text-display tasks, your application is responsible for knowing what the selection
range is and highlighting it properlyN as well as for making the necessary changes in
memory that result from any cutting, pasting, or editing operations involving the
selection range.
Discontinuous selection
A selection range as de ned in this book always consists of characters
contiguous in memory. Some word processors allow for discontinuous
selection, in which the characters that constitute the selection range are
not necessarily contiguous in memory. You can think of discontinuous
selection as the simultaneous existence of several selection ranges of the
type described here. Discontinuous selection is not discussed further in
this book. In particular, keep in mind that the discontinuous highlighting
shown in this section is not an example of discontinuous selection; all
selection ranges shown here are single, contiguous ranges in memory. #
Unidirectional Text

In text with a single line direction, the selection range always appears on screen as a
continuous range of highlighted glyphs; see Figure 1-48.
Figure 1-48

Byte
offsets

Highlighting a selection range in unidirectional text

Character
codes

Characters

0)

geo

|N

1

$E1

al

2;

$e2

|)

3}

$63

T

4|

$64

n

Selection

range

Primary line direction = right to left

~
f

D|

The Macintosh script management system measures the limits of highlighting rectangles
in terms of caret position. Thus, in Figure 1-48, in which the selection range consists of
the characters at offsets 1 and 2 in memory, the ends of the highlighting rectangle
correspond to caret positions for offsets 1 and 3. It@ equivalent to saying that the
highlighting extends from the leading edge of the glyph for the character at offset 1 to the
leading edge of the glyph for the character at offset 3.

1-80

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Highlighting for word selection

If your application supports word selection by double-clicking, it
involves three steps. First, use

a QuickDraw call to locate the offset in

memory corresponding to the double-click. Second, use a Text Utilities

call to locate the offsets of the word boundaries on either side of the
double-click. Third, use QuickDraw calls to determine the boundaries of

the rectangle to highlight.
Mixed-Directional Text

If the displayed text has mixed direction runs, the selection range may appear as
discontinuous highlighted text. This is because the characters that make up the selection
range are always contiguous in memory, but characters that are contiguous in memory
may not be contiguous on screen.

Figure 1-49 is an example of text whose selection range consists of a contiguous sequence
of characters in memory, whereas the highlighted glyphs are displayed discontinuously.
Figure 1-49

Highlighting a selection range in mixed-directional text

Character
codes
Characters

FR

$28

$41
$72

a

$69

Selection

range

bffabi OBEL
Primary line direction = right to left

$CF
$EA

FB

$E1

on

$D3

a

=
DY

$63

a

oO

$62

WwW

ek

$61

$29

eee

?

a are

=
DY
WO

$E3

ON

$D1

oO

$E5
$C7

OD

Byte
offsets
0

How Script Systems Work

1-81

CHAPTER

1

Introduction to Text on the Macintosh

In describing the boundaries of the highlighting rectangles in terms of caret position, note
that for Figure 1-49 it is not possible to simply say that the highlighting extends from the
caret position of offset 2 to the caret position of offset 6. Using the de nitions of caret
position given earlier, however, it is possible to de ne it as two separate rectangles, one
extending from offset 4 to offset 2, and another extending from offset 12 to offset 6
(assuming for the ambiguous offsetsN 4 and 12N that the current text direction equals the
primary line direction).
The QuickDraw function HiliteText makes those kinds of calculations and is

especially useful for determining the correct caret positions when highlighting a selection
range in mixed-directional text. See the discussion of HiliteText in the chapter
CQQuickDraw TextOin this book for more details.

Converting Screen Position to Text Offset
Caret handling and highlighting, as just discussed, require conversion from text offset to
screen position. But that is only half the picture; it is just as necessary to be able to
convert from screen position to text offset. For example, if the user clicks the cursor

within your displayed text, you need to be able to determine the offset in your text buffer
equivalent to that mouse-down event. You can then use that information to set the
insertion point or selection range.
The script management system does most of this work for you. It provides routines that
convert a screen position to the byte offset of a character code in memory (and vice
versa); those routines function correctly with multiscript text, even text that has been
rendered with ligatures and contextual forms.
Determining the character associated with a screen position requires rstde ning
the caret position associated with a given screen position. Once that is done, the
previously de ned relationship between caret position and text offset can be used to
the character.

1-82

How Script Systems Work

nd

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-50 shows the cursor positioned within a line of text at the moment of a mouse
click. A mouse-down event can occur anywhere within the area of a glyph, but the caret
position that is to be derived from that event must be an in nitesimally thin line that falls
between two glyphs.
Figure 1-50

Interpreting caret position from a mouse-down event

u

ain

|

WETG)'
\)

L

Mouse-down region

Caret position

A line of displayed glyphs is divided by the script management system into a series of
mouse-down regions. A mouse-down region is the screen area within which any mouse
click will yield the same caret position. For example, a mouse click that occurs anywhere
between the leading edge of a glyph and the center of that glyph results in a caret
position at the leading edge of that glyph. For unidirectional text, mouse-down regions
extend from the center of one glyph to the center of the next glyph (except at the ends of
a line), as Figure 1-50 shows. A mouse click anywhere within the region results in a caret
position between the two glyphs.
At line ends, and at the boundaries between text of different line directions, mouse-down
regions are smaller and interpreting them is more complex. As Figure 1-51 shows, the

mouse-down regions at direction boundaries extend only from the leading
or trailing edges of the bounding glyphs to their centers. Note that the shaded part
of Figure 1-50 is a single mouse-down region, whereas each of the shaded parts of
Figure 1-51 is two mouse-down regions.

How Script Systems Work

1-83

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-51

Byte

Mouse-down

regions and caret positions in mixed-directional text

Character
codes

offsets

Characters

E&Y
>~

oO

16

oo

15

cy

ca

ae
16

Li?

ig

TT

5

te

iti

5 '14 "13 taza

G OG e~ >

=

ODO
ON
O
—

[20

—
—

=
ye)
=
ao
&

=
ao

Primary line direction = right to left

I
|

BR

WwW

PD

—

0| SES | »
$c7 | |
$D1
$E3
$28
$41
$72
$61
$62
$69
$63
$29
$CF
SEA
SE1
$D3

wt
|

0

9

rT

L

|

8

(Arabic
|

11 '

i

to 19

| 8

6

3.2

rT

|

|

|

'5 tb

a

1

anne

J Be.
|

'4a'

3

'2'

O— Caret

iti

Position

1 '0'— Mouse-down
region

Direction
boundaries

How do mouse-down regions relate to text offset? Referring to Figure 1-51, and
remembering that the primary line direction is right-to-left, consider the two
mouse-down regions 4a and 12a:
m A mouse click within region 4a is associated with the trailing edge of the Arabic
character QO In response, your application might make the keyboard script Arabic,
draw a primary caret (or single caret) at caret position 4, and place the insertion point
at offset 4 in the buffer, to insert Arabic text following asd (If you are drawing a dual
caret, the secondary caret should be at caret position 12, which also corresponds to an
insertion point at offset 4 in the buffer.)
m A mouse click within region 12a is associated with the leading edge of the Roman
character QO In response, your application might make the keyboard script Roman,
draw a secondary caret (or single caret) at caret position 12, and place the insertion
point at offset 4 in the buffer, to insert Roman text preceding QO (If you are drawing a
dual caret, the primary caret should be at caret position 4, which also corresponds to
an insertion point at offset 4 in the buffer.)
Thus mouse clicks in two widely separated areas of the screen can lead to an identical
caret display and to a single insertion point in the text buffer. One, however permits
insertion of Roman text, and the other Arabic text, and the insertions occur at different

screen locations.

1-84

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Mouse clicks in regions 4b and 12b in Figure 1-51 would lead to just the opposite
situation: a primary caret at caret position 12, a secondary caret at caret position 4, and
an insertion point at offset 12 in the text buffer. Either Roman text would be inserted
after the Roman character QO or Arabic text would be inserted before the Arabic

character O30

The QuickDraw function PixelToChar helps you make these calculations; it returns the
byte offset in your text buffer corresponding to the character associated with a particular
distance (in pixels) from the left margin of the displayed text. It even handles the special
cases of pixel locations outside (to the left or right of) the margins of
the displayed text. For more information on conversion of screen position to text offset,
see the description of the Pixel ToChar function in the chapter QQuickDraw TextOin
this book.

Printing
At the application level, printing on the Macintosh computer is not fundamentally
different from drawing to the screen. A printer is considered a display device, and your
application prints by creating a printing graphics port (a graphics port with a few extra
elds for printing), setting the port@ elds, and drawing in the port with calls to
QuickDraw. General procedures for printing are described in the Printing Manager
chapter of Inside Macintosh: Imaging. However, printing text, and especially contextual
text, can pose extra challenges.
A very common complication results from the difference in resolution and pixel size
between screen and printer. QuickDraw measurements are theoretically in terms of
points, which are nominally equivalent to screen pixels at normal resolution.
High-resolution printers have very much smaller pixel sizes, although printer drivers are

expected to take this into account so that the same QuickDraw calls will produce text
lines of the same width on the screen and on a printer. Nevertheless, this higher
resolution, and the fact that printers can use different fonts from those used for screen
display, can result in some loss of delity from the screen to the printed page:
m QuickDraw places text glyphs on the screen at whole screen-pixel intervals, whereas a
high-resolution printer has much smaller pixels and can therefore provide much ner
placement on the printed page. If your application speci es the use of fractional glyph
widths, the spacing of the text on the screen can be awkward but it more accurately
refsects the optimum layout of the printed text. Alternatively, specifying integer glyph
widths gives more pleasing screen results because the characters are drawn with
regular pixel spacing, but the results on the page can be typographically unacceptable.
See the discussions of fractional glyph width in the chapters QQuickDraw TextOand
(Font ManagerOin this book for more information.
m Printer drivers attempt to reproduce faithfully the text formatting as drawn by
QuickDraw on the screen, including keeping the same intended character spacing, line
breaks, and page breaks. However, because printers can have resident fonts that are
different from the fonts that QuickDraw uses, because the drivers may handle text

layout somewhat differently than QuickDraw, and because font metrics do not always
scale linearly, delity may not always be achieved. Typically, identical line breaks and
page breaks can be maintained, but character spacing can be noticeably different.

How Script Systems Work

1-85

CHAPTER

1

Introduction to Text on the Macintosh

Other complications result from the fact that high-resolution printers use deferred printing,
in which the document to be printed is rst converted into aspool le in picture- le
format, and it is the picture le rather than the original document that is printed. This can
result in loss of certain display features that picture les do not support, such as the
following:
m The grayishTextOr transfer mode cannot be used for printing. See the discussion of
transfer modes in the chapter GQuickDraw TextOin this book.
m

You cannot pass DrawText (or StdText) more than 255 bytes of text at a time when

printing. DrawText and StdText are documented in the chapter GQuickDraw TextO
in this book.

Some of the most dif cult problems result from the fact that printer drivers replace the
QuickDraw bottleneck routines StdText and StdTxMeas (by changing the graf Procs
eld of the printing graphics port) to allow printing to function with QuickDraw calls,

whereas certain script systems use different modi cations (trap patches) to those same
routines to perform contextual formatting. Printer drivers that print from spool les can
then interact with QuickDraw in several ways that may cause complications:
m Some drivers call QuickDraw twice: once to create a spool le for printing, and once
again to unwind the spooling. If the text is contextually transformed during spooling,
the transformation must not be repeated during unwinding.
m Some drivers may not call QuickDraw at all, meaning that necessary contextual
transformations might not be made at all.
m Some drivers may call QuickDraw re-entrantly, such as when displaying a status
message during printing.
To avoid these problems, printer drivers should call the Script Manager Print Action
routine whenever they change the grafProcs_ eld. For more information on the Print
Action routine, see the discussion on writing device drivers in Inside Macintosh: Devices.

To accommodate the special contextual formatting needs of 1-byte complex script
systems, WorldScript I patches the QuickDraw routines StdText, StdTxMeas,

MeasureText, and the Font Manager procedure FontMetrics. There are Script
Manager routines that allow you to modify or replace those patches if your text has
additional needs not met by the WorldScript I routines. To allow for the extra
complications that may occur during printing, WorldScript I allows you to de ne
separate entry points or even separate routines for printing as opposed to screen display.
See the discussion on replacing a script system@ default routines in the chapter CScript
ManagerOin this book, and the description of WorldScript I in the appendix (Built-in
Script Support.O

1-86

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Text Input
Typically, your application accepts text input from the user through the keyboard. The
Macintosh script management system allows you to accept text input in any script
system, and to switch easily among input script systems.
Keyboard input is a complex process that involves conversion of hardware keypresses to
software raw key codes, then to virtual key codes, and nally to character codes.
Subsequent display of those input characters on the screen involves conversion of
character codes to the glyphs of a font, and the drawing of those glyphs on the screen. As
noted under CSeparation of TasksObeginning on page 1-4, text input and text display are
completely independent of each other.
The conversion of keypresses to character codes is complex because the Macintosh
computer has to support many different physical keyboards and many script systems.
The conversion of raw key codes to virtual key codes accommodates the spectrum of
keyboards; the conversion of virtual key codes to character codes accommodates the
spectrum of script systems.

For 1-byte script systems, characters are generated directly from keypresses. For 2-byte
script systems, the large number of characters makes direct keyboard input impractical;
those systems provide input methods to make text input more convenient.

Keyboards and Key Translation
Every Macintosh keyboard has a speci c physical arrangement of keys. An example is
shown in Figure 1-52. The gure shows the physical arrangement of keys on the domestic
(U.S.) layout of the Apple Keyboard I. It also shows the virtual key codes produced
when each key is pressed, as well as the character generated (for U.S. system software) by
each key.
Figure 1-52

Apple Keyboard

! 18

489

@19

57

#20 IIs 21 Y]% 23 I" 20 Ye 26

2

a’

3

5

120130
iw
A

0

§

fe
1

6
58

140
D

7

Wa
2

150.170
ir
F

8

Iix28 Ii 25 YI) 29

7

3

G

9

fy
5

8

9

16 J 329
Wu

340

4

38 ff 40

H
B

SQ,

11
49

J
N

o

31

K

45 I 46
iM

I_o7 |e 24

0

L

-

fe
37

<43

35

130

;

'

944
/

123
<--

delete

i" 39

;
.

55

Wiss
Wr

41
47

,

=

return
shift

124)
B->

125
ty

51
IJ! 42
36
56
26
:

ir

option!

:

Eo

[es
1

II (domestic layout)

How Script Systems Work

1-87

CHAPTER

1

Introduction to Text on the Macintosh

Other keyboards produce a similar set of virtual key codes, although the keys and their
codes may be arranged differently. Apple supports at least 13 separate physical
keyboards, listed in the appendix (Keyboard ResourcesOin this book. All can produce a
set of hardware-independent virtual key codes, which translate directly into the
characters of any script system. That process is called key translation.
As far as the application is concerned, text input for all keyboards and for all script
systems is hardware-independent. Except for a few minor hardware-speci c
characteristics, the function of the keyboard is completely determined by a script
system@ keyboard-layout ('KCHR') resources. Tables within the keyboard-layout
resource specify the characters produced by each key in combination with each modi

er

key (Command, Shift, Caps Lock, Control, and Option).

Figure 1-53 illustrates the process of key translation. A keypress initially produces a raw
key code. The keyboard driver uses the hardware-dependent key-map (' KMAP') resource
to map the raw key code into a hardware-independent virtual key code and to set bits
indicating the state (up or down) of the modi er keys. It then calls the Event Manager
KeyTrans late

function.

If the optional key-remap ('it1k') resource is present, KeyTranslate uses it to remap
certain key combinations on certain keyboards before performing additional processing.
The key-remap resource transforms this information based on which keyboard is in use.
It reintroduces hardware dependence because certain writing systems, languages, and
regions need subtle differences in layout for speci _c keyboards. Generally, the key-remap
resource affects only a few keys.
The KeyTranslate function then uses the current script@ keyboard-layout resource to
map the virtual key code and modi er state into a character code. KeyTranslate
returns the character code, and the keyboard driver posts the key-down event into the
event queue. The application receives the original virtual key code and a character code
inthe message

modifiers

1-88

eld of the event record, and modi

eld of the event record.

How Script Systems Work

er-key information in the

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-53

O

CO

Co

Key translation

eo

Raw key
code

oo) ~ =~ el”

Modifier

KeyTranslate function

state

7
New modifier

—_—-——

ee

'KMAP'!

l (if

Virtual

present)

state

I

'KCHR!

jp Presen!) |(__——>

Character

New virtual

»

code

Virtual
key code

Character
code

Event message

The KeyTranslate function is described in the chapter CEvent ManagerOin

Inside Macintosh: Macintosh Toolbox Essentials. Por additional information on the
KeyTranslate function and the keyboard-layout resource, see the appendix
(Keyboard ResourcesOin this book.
Dead keys

The keyboard-layout resource also handles dead keys, by means of
additional subtables. A dead key is a key combination that has no
immediate effect, but sets a state that affects the results of the next

keypress (typically, the generation of one or two characters). Dead keys
are commonly used to generate accents and accented characters.
Dead-key processing is discussed in more detail in the appendix
(Keyboard ResourcesOin this book.

How Script Systems Work

1-89

CHAPTER

1

Introduction to Text on the Macintosh

Font and Keyboard Synchronization
Whenever your application displays text as it is being entered at the keyboard, it needs to
keep the font script coordinated with the keyboard script (see (Font Script and Keyboard
ScriptObeginning on page 1-51). The upper half of Figure 1-54 shows an example of font

and keyboard synchronization with the user entering the characters for Nihongo when the
font script corresponds to the keyboard script, which is Japanese. The lower half of
Figure 1-54 provides an example of the characters that are displayed when the user enters
the same characters when the font script does not match the keyboard script. If the two
scripts don®match, the results are meaningless to the user.
Figure 1-54

Keyboard script

(Japanese)
Ss

Font script and keyboard script synchronization

|

83]

Font script (Japanese) [===> |

Keyboard script

(Japanese)

Resulting character codes
$93 $FA $96 $7B $8C $EA

Display

H

AX

ai.

|

a)

"2 WI

| =>

Co) Co) ao) - = = 9°

Font script (Roman) ===>}

Resulting character codes
$93 $FA $96 $7B $8C $EA

Display

|

>

7A { Al

You use the Script Manager KeyScript procedure to set the keyboard script when, for
example, the user chooses a new font from your Fonts menu or when the user clicks in an
area of text that has a font different from the current one. The Operating System
automatically changes the keyboard script (or keyboard layout or input method) when
the user chooses a new one from the Keyboard menu (see Figure 1-62 on page 1-106).
When that happens you need to set the font script to equal the keyboard script.

1-90

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

The Operating System also automatically changes the keyboard script (or keyboard
layout or input method) when the user presses certain key combinations, as speci ed by
the keyboard-swap ('KSWP') resource. When that happens you should set the font script
to equal the keyboard script.
You can force a particular keyboard layout to be used with your application by using
the Script Manager to de ne the default keyboard layout for a script system and then
calling KeyScript.

For more information on setting the font script and keyboard script, see the discussion on
making keyboard settings and the description of the KeyScript procedure in the
chapter CScript ManagerOin this book. For more information on the keyboard-swap
resource, see the appendix (Keyboard ResourcesOin this book.
Handling Keyboard Equivalents
Many applications support keyboard commands or keyboard equivalents to menu
commands. This can be a problem in a multiscript environment. Be careful of these issues
in the keyboard equivalents that you allow:
m Avoid keyboard equivalents that use the Space bar in combination with the Command
key and other modi er keys. Command Space bar and Command Option Space bar
are already commonly used for switching among script systems and keyboard layouts.
See the discussion of the KeyScript procedure in the chapter Script ManagerOand
the description of the keyboard-swap resource in the appendix (Keyboard ResourcesO
in this book.
m When the Command key is pressed, some charactersN such as the period or question
markN cannot be produced on certain keyboard layouts. To make Command-key
handling work in these cases, it may be necessary to use the virtual key code to
determine which character code would have been produced if the Command key had not
been pressed. For more information, see the discussion of special uses for the

KeyTranslate function in the appendix (Keyboard ResourcesOin this book.

m If your application extends the set of standard Macintosh modi er-plus-key
combinations for speci c purposes, your keyboard equivalents might not function
properly in all script systems. Be sure to supply alternative methodsN such as menu or
dialog-box itemsN for gaining access to such features.

Input Methods
Script systems for ideographic writing systems such as Japanese cannot simply use a
larger keyboard or multiple dead keys for effective text input. The sheer numbers of their
characters demand a more complex solution, such as providing ways to convert phonetic
text into ideographic text and vice versa. Most script systems with large character sets
provide for the complex parsing of phonetic sequences to produce ideograms and
character clusters.

How Script Systems Work

1-91

CHAPTER

1

Introduction to Text on the Macintosh

Automatic conversion of phonetic glyphs into nal representations is performed by an
input method. For example, the Japanese script system supplements the keyboard by
providing software for transcribing Kana (phonetic Japanese) into ideographic Kanji.
Each Kanji character can correspond to more than one possible Kana sequence, and vice
versa. The input method must grammatically parse sentences or phrases of Kana text
(which has no word separations), and select the best combination of Kanji and Kana

characters to represent that text.
Entry and Conversion

When a user types a character, one kind of input method opens a window (called a
floating input window or bottomline input window) at the bottom of the screen for text
entry; see Figure 1-55. In Japanese, the user can type using either Roman or Kana
characters. When the converted glyphs are in the window, the user can freely cut and
paste or convert them to any of the other subscripts.
Bottomline input window for Japanese input method

LC-=a-_-zzzaaSSS=

ID 1( |

Figure 1-55

untitled

&5%435R7|

Oa]

Bd

The Text Services Manager supplies an interface for input methods that use inline input.
In inline input, the user types directly into an active input area within a document, as
shown in Figure 1-56. Conversion then occurs within the active input area.
Figure 1-56

Active input area (underlined) for inline input

Tl

lg

0usz

co

old]

Sn FTF p78
54s 5R ReSky

1-92

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Input methods are often extended so that glyphs may be converted in extremely precise
ways. For example, in the Japanese script system, when the text is converted to Kanji, the
user has the option of changing any individual phrase: lengthening it, shortening it, or
selecting different possible interpretations. All of the commands that perform these
changes have both mouse and keyboard equivalents. Once the user presses the Return
key, the text is entered as if it had been typed directly from the keyboard.
Differences Among Script Systems
In Japanese and Chinese input methods, the principal conversion is from Roman or other
phonetic input to Han (Chinese) characters. In Japanese the input can be Romaji
(Roman), Hiragana (phonetic), or Katakana (phonetic); the output is Kanji (Chinese
characters). In Chinese the input can be Pinyin (Roman) or Zhuyinfuhao (phonetic; also

called Bopomofo), and the output is Hanzi (Chinese characters). Chinese and Japanese
use a semi-automatic conversion to Han characters that requires user con rmation.
The Korean script system@ input method converts from Jamo (phonetic) to Hangul

(clusters of Jamo). Transcription to Hanja (Chinese characters) is optional. Furthermore,

the Korean input method uses a completely automatic conversion from Jamo to Hangul;
user con rmation is not required.
Figure 1-57 illustrates the process of constructing Hangul from Jamo during
bottomline input. Note that an added Jamo can appear in various positions
(beside, beneath, and so on) relative to the Jamo or Hangul that it is added to.

Bottomline input in Korean

Sn rts—xzX@—_ } aT

ao

fu

ws

|

ola]

K)
amie

oy et BE BS

I> I(q] |

Figure 1-57

To gain the greatest acceptance worldwide, your application should support text input,
and preferably inline input, in 2-byte script systems. For additional information on input
methods, inline input, and input-method dictionaries, see the chapters Clext Services
ManagerOand Dictionary ManagerOin this book.

How Script Systems Work

1-93

CHAPTER

1

Introduction to Text on the Macintosh

Text Manipulation
The Macintosh Operating System and Macintosh script management system implement
certain script features transparently. For example, your application may not need to know
that its dialog boxes can accept Japanese text. However, if your application actually
manipulates the text of any languageN as any word processor certainly doesN it needs
access to text-handling information that varies from script system to script system.
For example, to perform word selection and line-breaking, your application may
need routines to determine word boundaries in any language. To sort text, it may need
routines that sort acording to language-speci c rules, and possibly also routines that
perform case conversion or strip diacritical marks according to language-speci c rules.
Do not assume that all languages or regions have the same rules or conventions; use
Text Utilities and Script Manager routines to handle different conventions.
Note that the user can affect which of the available script-system resources are used to
control text manipulation such as sorting, number formatting, and date and time

formatting. See User Control of Script SettingsObeginning on page 1-107.

This section discusses routines that perform a variety of script-aware text manipulations
including sorting strings; formatting dates, times, and numbers; analyzing characters;
searching and modifying text; and nding word boundaries and line breaks. Most of
these topics are described more fully in the chapters ext UtilitiesOand CScript
ManagerOin this book.
Note
The script management system does not address all possible localizable
text issues. There is other information, not covered in a script@

international resources, that may vary from locale to localeN such as

formats for addresses, postal zone codes, and telephone numbers. You

should place all such information in resources for ease of localization.

Sorting Strings
Comparing strings can be an intricate operation that involves subtle issues. Even for
English, determining the sorting order cannot be done by a simple table look-up or
comparison of character-code values. Furthermore, sorting rules vary not just among
script systems but among the individual languages or regions within a script system.

1-94

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

Every script systemN and every language-speci c variation of a script systemN has
information specifying how its text is to be sorted. That information is in the script@
string-manipulation ('it12') resource. The Text Utilities provides routines for
comparing two strings for sorting purposes. Some routines work with Pascal strings,
others with generalized text strings (de ned by pointer and length). Some are
script-aware, some are not. The script-aware routines take into account the sorting rules
of the current script system or any script system that you explicitly specify, and can
address these sorting factors:
m primary and secondary sorting order
m expansion and contraction of characters
m ignorable characters
m case-conversion and stripping of diacritical marks
Other special cases, such as expansion of abbreviations that requires dictionary lookup,
may be beyond the capability of the script management system.
In sorting lists of strings that may be from more than one script system, keep these points
in mind:
m If you are sorting strings from different script systems into a single list, the ordering
relationship among the scripts as well as the sorting rules within each script are
important. The script-sorting ('it1m') resource that is part of system software
contains tables that de ne the sorting relationship among all de ned script systems.
Text Utilities functions use that information to help you create a sorted list of strings in
more than one script system.

m If you are sorting strings from different languages within a single script system, you
may or may not want to sort the strings into groups by language. If you do, you can
determine the ordering relationship between the languages from the the script-sorting
resource. Text Utilities functions use that information to help you create a sorted list of
strings in more than one language.
m If you need to sort strings in exactly the same way that the Macintosh le system does,
there are Text Utilities routines that perform that type of sorting. The sorting order is
xed, and it is independent of any script system or language. It should be used only
for operations internal to your application, not for user display of sorted lenames or
other text strings.
m Uppercase characters and diacritical marks affect sorting and searching, and
conventions for their handling vary among script systems and languages. Text Utilities
routines allow you to sort according to the rules of each script or language, and to take
into account or disregard case and diacritical marks.

How Script Systems Work

1-95

CHAPTER

1

Introduction to Text on the Macintosh

Formatting Dates, Times, Numbers, and Symbols
Dates, times, numbers, and symbols are common types of specialized strings whose
formats vary widely around the world. Each script system de nes how its times, dates,
numbers, and other symbols are to be de_ ned and formatted in its numeric-format
('it10'), long-date-format ('it11'), and tokens ('1t14') resources.
Dates and Times

Figure 1-58 shows two different Finder displays of the same lenames and modi cation
dates. The upper display uses Arabic date formats, Arabic month names (with
theGregorian calendar), Arabic numerals, and a right-to-left primary line direction.
The lower display is exactly the same, except with U.S. date formats, English month
names, western numerals, and a left-to-right primary line direction. (The changes
were made with control panel selections; see QUser Control of Script SettingsObeginning
on page 1-107.)
Figure 1-58

Filenames and dates in Arabic and U.S. formats (Arabic system script)

2c]

wal

one

2

x

a)

Finder

387K

vals

Oo

System

2,286K

duis

>O
bo
>O

ro
bo
D

cs Bee
Peis cay polic
bi dosli polic

pal lag)
plat oliale
agen!53 wale

-

29K

alae
alas
alas
alae
alas
ale

SS=_-_—]_E=_—E_=EEE==we

bac je bb

a Y08 1AAY Ls W dees
p HOV SRY pos

nan

VV Sai

ge RYT OSA gi TA clef
a iis AAA pol nd 19 ley i
a 1:40 RAY pol nd 19 ley i

a 1:40 AY pol nd 19 ley i
ge ATT OAAY
928i TA cle i
ge WNT AAA gS 11 dees

oy

fe]

ee

=
a)

0
>oO

>O

>oO

>O
> oO
a)

ple! al.

re}

Finder

Pee

System
edad

387K

29K

keel eb

Fri, Jan 3, 1992 «2:54 PM

-

dinniin
alas

Wed, Oct 28, 1992 «8:38 AM
Wed, Oct 28, 1992 «8:37 AM

-

alas

Wed, Feb 19, 1992 «1:25PM

-

hi dsld polic

fe]

wale

2,286K

cay polic

pac colag!
pla clits
Bagenkl p53 Wale

te

-

alas
alas
alas
ils

aE
Moy

Wed, Feb 19, 1992 «1:30 PM

Wed, Feb 19, 1992 «1:25PM
Wed, Oct 28, 1992 «8:26 AM
Fri, Oct 11, 1991 «12:33 AM

oy
ee

The Text Utilities include a number of routines for converting and formatting date and
time strings on the Macintosh. These routines allow you to specify each element of the
date and time formats, including the number of digits used for each numeric element

1-96

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

(for example, 3/01/90 or 3/1/90), the names of the months and the days of the week,

and other characteristics such as the order of the elements and the use of a.m. and p.m.
instead of a 24-hour clock.
Be careful about abbreviating the names of the weekdays (for instance, in English S, M, T,
W, Th, FE, and S). In Hebrew, for example, the names all begin with the same character, so

the English convention would not be useful. Use instead the Text Utilities routines that
give you the abbreviated versions provided by each script system.

Multiple calendars may be available on some Macintosh systems. The time-formatting
and date-formatting routines in the Text Utilities are generalized enough that they can
handle other calendar systems. The Gregorian calendar is the standard Macintosh
calendar that is used in most of the world, but other calendars are also supported. See the
description of the long-date-format resource in the appendix Ginternational ResourcesOin
this book for a list of de ned calendar types.
Numbers and Symbols
Western numerals (1, 2, 3, and so forth) are not universal, and the decimal separator is

not always the period. The formats of numbers vary widely. The Japanese writing
system, for instance, uses the standard ASCII Western digits, 2-byte encodings of the
same Western digits, and 2-byte Japanese number characters in two forms.

To accommodate differences in number and currency formats around the world, the Text
Utilities provide routines that separate the presentation of numeric values from their
internal representation. They allow a script system or your application to de ne
separately how positive numbers, negative numbers, and zero values are presented. They
allow you to specify what separators, digits, text annotations, marks (such as + ), and
literals (such as brackets or parentheses) can appear in numbers, and what kinds of
padding can be used. In addition, they allow you to de ne how to represent positive and
negative exponents for scienti_c notation. Each script system@ numeric-format ('it10')
and tokens ('it14') resources contain information used for formatting numbers.

Currency formats include the speci cation of the currency symbol (for example, $, £, or
DM) and whether it precedes or follows the value. Each script system@ numeric-format
resource speci es formats for currency.
Use the regional forms of symbols such as the bullet (center dot, ¥). Tokens that allow
you to de ne these symbols in a language-independent fashion are found in each script
system@ international resources; use the Script Manager to gain access to those tokens.
Note
Units of measure should be appropriate for the region you are targeting.
For example, lines per inch is meaningless in the metric world. Units of
measurement can be speci

ed as metric or imperial (inches and miles).

Each script system@ numeric-format resource indicates the preferred
measurement unit. You can use the Operating System Utilities function
IsMetric to determine the appropriate unit of measure for the current
script system. See Inside Macintosh: Operating System Utilities.

How Script Systems Work

1-97

CHAPTER

1

Introduction to Text on the Macintosh

Analyzing Characters
Analyzing characters is another common type of text-manipulation task. The Script
Manager provides functions that let you analyze the size and type of individual
characters. For example, with script systems that use 2-byte characters, you may need to
determine what part of a character a single byte represents. In either 1-byte or 2-byte
systems, you may need to know what type of character a particular character code
represents. Character-type information is contained in a script system@
string-manipulation ('it12') or encoding/rendering ('it15') resource.
For example, when searching for a single 1-byte character in text that may contain 2-byte
characters, it is important not to mistake part of a 2-byte character for the character you
are seeking. You can also determine whether a particular character is a letter, number, or
punctuation mark, or whether or not it is uppercase. This information can be useful, for
example, to Iter input into specialized text elds. Also, for example, because several
uppercase letters in the Cyrillic and Roman script systems are identical in appearance,
you can detect an unwanted mixture of Cyrillic and Roman characters.
The Text Utilities provide a function that locates sequences of Roman characters (or
characters of any other subscript) within non-Roman text. Use this routine when you
want to separate out Roman characters into their own style runs, so that they can be
formatted independently of the surrounding non-Roman text.

Searching, Modifying, and Converting Text
The Text Utilities provide several script-aware routines that you can use to modify the
contents of strings or convert text from one form to another. You can use these routines
on strings of any script system; the script-speci_c information they need is in the script@
string-manipulation ('i1t12'), tokens ('it14'), encoding/rendering ('1t15"'), or
transliteration ('trs1') resource.

For modifying strings, there are routines to
m convert case and strip diacritical marks from characters (such as for sorting)
m truncate a string to make it

tintoaspeci

ed area on the screen

m search for a character sequence in a string and replace it with a different sequence
(accounting for both 1-byte and 2-byte characters)
When searching, note that the text of some script systems can have accents or other
diacritical marks that are considered optional. In Hebrew, for example, you may want to
give the user the option to have search procedures ignore vowel and cantillation marks,
because they are infrequently used in everyday writing. Note, however, that your
application would have to provide this capability on its own; the Text Utilities stripping
routines do not strip vowel or cantillation marks.
Different script systems have their own rules for dictionaries and hyphenation references.
In searching text, your routines must be able to ignore text from script systems other than
those to which the dictionaries and hyphenation references apply. As usual, it is your
application® responsibility to track the script system of the text you manipulate; the
script management system does not.

1-98

How Script Systems Work

CHAPTER

1

Introduction to Text on the Macintosh

If you need to truncate a string, use the regional form of the ellipsis to indicate the
truncation; different symbols may be expected in different languages. The Script Manager
and the Text Utilities have routines that help you truncate strings and insert the proper
symbol for an ellipsis.
Macintosh Human Interface Guidelines has guidelines for implementing intelligent
cut-and-paste in your application. If the user cuts an entire word and pastes it in another
location or document, you should make sure that the pasted word has proper word
delimiters at its new location, and that extra word delimiters are not left at the location it

was cut from. Applying intelligent cut-and-paste across all script systems requires
complete understanding of word delimiters for each one. The Macintosh script
management system does not provide support for this. However, the guidelines
presented in Macintosh Human Interface Guidelines can work for any script system that
uses spaces as word delimiters, and each script system sets a Sag that you can access to
determine whether it uses spaces. See the descriptions of script-variable selectors in the
chapter CScript ManagerOin this book.

Compilers, assemblers, and scripting-language interpreters usually parse sequences of
characters to tokens, abstract entities that stand for variables, symbols, and quoted
literals. Each script system provides tokenizing information in its tokens resource, for use
by the Script Manager. Using the Script Manager you can create tokens recognizable by a
parser in any script system.
The Script Manager also provides support for transliteration, the automatic conversion
of text from one phonetic form or subscript to another within a single script system. In
the Roman script system, this simply means case conversion. In Japanese, Chinese, and
Korean script systems, it means the phonetic conversion of characters from one subscript
to another. Script-speci_c information for transliteration is in a script@
string-manipulation or transliteration resource. With the Script Manager you can convert,
for example, from Hiragana to Romaji and Romaji to Katakana in Japanese; from
Bopomofo to Roman in Chinese; and from Roman to Jamo, Jamo to Hangul, Hangul to
Jamo, and Jamo to Roman in Korean.

Finding Word Boundaries and Line Breaks
Finding word boundaries for word-selection and for line-breaking is a common, though
often dif cult, text-manipulation task. Word-selection methods differ among script
systems. For example, the Thai script does not use spaces between words; the Thai
system must detect word boundaries by parsing. The Text Utilities provide a procedure
that you can use to determine word boundaries, in order to support double-clicking,
highlighting of search targets, and so on. You can also use the same procedure to
nd word boundaries for line breaking; see text LayoutOon page 1-71. The procedure
works for all script systems and uses information in the script@ string-manipulation
('1t12') resource.

How Script Systems Work

1-99

CHAPTER

1

Introduction to Text on the Macintosh

Script Systems in Use
When a version of Macintosh system software is created for a particular country or
region, its system script supports the writing system of that country or region. In
addition, the system software@ text strings are usually translated, and its icons and other
graphical elements may be altered to t the cultural conventions of the region. This
process of adapting software to local use is called localization.
Localization of system software is performed by Apple Computer, Inc. In constructing a
localized system, many different combinations of script capability and text translation are
possible. For example, one localized version of Hebrew system software might use
Hebrew text strings and Israeli currency, date, and calendar formats. Another might leave
all text strings in English and use Roman formatting. In both, of course, the system script
would be Hebrew. In another example, localized system software for India might
possibly use Gurmukhi (an Indic script system) as the system script but leave all text
strings in English, using the low-ASCII characters in the Gurmukhi character set.
This nal section of the chapter discusses how a localized system is presented to a user. It
shows the locations of the les and resources that make up the system script and any
auxiliary scripts. It then describes how you can modify existing script systems or make
additional auxiliary script systems available to the user. The section then summarizes
how the user can switch among the available script systems. Finally, it shows how the
user can alter the con gurations of the script systems on the computer, including
possibly selecting as script-system defaults resources that you provide.
More information on localization and localized versions of system software can be found
in Guide to Macintosh Software Localization.

Installing and Enabling Script Systems
A user receives a script system in one of two forms: as a system script, already installed
in the user@ System le and System Folder; or as a secondary script consisting of a set of
les that, if not present in the System le already, need to be installed before they can be
used.
Initialization

The Operating System initializes the Script Manager at startup, and the
Script Manager, along with WorldScript I and WorldScript I, initializes
all installed script systems. If a script system is properly installed and
successfully initialized, it becomes enabled (made available for use by

the Script Manager and applications). For more information, see the
discussion on testing for the Script Manager and script systems in the
chapter CScript Manager.O

1-100

Script Systems in Use

CHAPTER

1

Introduction to Text on the Macintosh

Components of the System Script
Because localization of system software involves more than installing script-system
resourcesN for example, system and Finder text strings need to be translatedN the user
typically does not install a system script. However, if the user has two separate systems
with two different localized versions of system software, the user can change system
scripts by using the CUpdate InstallOcommand in the installer to completely replace one
localized version@ system script (and all other localized resources) with those of the
other localized version.
Once installed, the system script and associated
System Folder as follows (see Figure 1-59):

les and resources are organized in the

The essential resources that make up the system script are in the System le. This
includes the script@ 'it1b' resource and any of the following resources speci ed by
the

'itlb'

'KCHR',

resource:

'kces#',

The System

'1t10',

'1t11',

'kes4',and

'kcs8'.

'1t12',

le also contains an international con

script-sorting resource ('it1m').

'1t14','it15','trsl','itlk',

guration resource ('itlc') anda

The Keyboard resources needed for each type of supported keyboard ('KMAP' and
'KCAP'), though not considered part of any script system, are in the System le.
If the system script is a 1-byte complex script system or a 2-byte script system, the
Extensions folder contains a script extension: either WorldScript I or WorldScript II,
respectively.
If the system script is a 2-byte script system, the Extensions folder contains one or
more input-method les. The Extensions folder may also contain one or more
dictionary les needed by the input method.
Depending on its individual needs or version, the system script may also have an
extension le ofitsown,a leoftype 'scri' in the Extensions folder.
The Fonts folder contains the fonts needed by the system script.
If the system script provides a control panel for the user, its control panel le is in the
Control Panels folder. If the control panel allows the user to save script settings, there
is a script preferences le in the Preferences folder to hold those settings. (The le is
created the rst time the user changes any settings.) Note that this control panel and

preferences

le are separate from the Text, Numbers, and Date & Time control panels

described under User Control of Script SettingsObeginning on page 1-107.

If the system script needs additional

Script Systems in Use

les, they are in the System Folder.

1-101

CHAPTER

1

Introduction to Text on the Macintosh

Figure 1-59

System-script components in the System Folder
=[u:

- System Folder

11 items

‘itlc'
‘itim'

System

‘l=

72.9 MB in disk

3.9 MB avail

resource
resource

.

System

Finder

-

~

Apple Menu Items

Preferences

script’s international

and keyboard resources

WorldScript |

fe

WorldScript Il _
Input-method file
Input-method dictionaries
Script-specific extensions

Extensions

Text control panel
Numbers control panel
Date & Time control panel
Script-specific control panels

Script preferences file

Fonts for system script

Fonts

ge

iO)

Scrapbook File

Startup Items

Control Panels
vy

@

>i

Components of Auxiliary Scripts
Auxiliary scripts consist of a set of resources and_ les mostly similar to those of a system
script. The essential resources that make up the auxiliary scriptN an international bundle
resource and any other international and keyboard resources needed by the scriptN may
have been installed in the System le during system localization or may be contained in a
le that is shipped separately from system software or applications. Other les are
parallel to the les associated with a system script, as shown in Figure 1-59. (The closer a
script system is to the U.S. version of the Roman script system, the fewer resources and
les it has.)
To install a separately shipped secondary script from the Finder, the user can simply drag
the contents of a folder containing the script@ resources and_les to the System Folder.
The Finder automatically installs the les and resources properly, as follows:
m The Finder installs the resources from the script le into the System le. That includes
the script@ 'it1lb' resource and any of the following resources speci ed by the
'itlb'

resource:

'1t10',

'KCHR',

'kcs#',

'kces4',and

'it11',

'1tl12',

'it14','itl5',

'trsl','itlk',

'kcs8'.

m The Finder places all system extension les, including input-method les, dictionary
les,and les of type 'scri' , into the Extensions folder. This includes the
WorldScript I or WorldScript II script extensions, if included.

1-102

Script Systems in Use

CHAPTER

1

Introduction to Text on the Macintosh

m The Finder places all fonts for the script system into the Fonts folder.
m The Finder places any control panel documents for the script system into the Control
Panels folder. (Once the user saves any new settings, a script preferences le is created
in the Preferences folder.)
m The Finder places all other

les into the System Folder.

If a script system has been installed but not yet enabled (if the computer has not been
restarted), the user can take the script system@ resources back out of the System le.
(When the System le is opened, the Finder displays any script les that can be moved
out of the System le.) Once the script system has been enabled, its resources can no
longer be removed from the System le with the Finder.
Disabling script systems at startup
Holding down the Option Space bar key combination at startup disables
all (non-Roman) auxiliary scripts. This allows the user to remove
auxiliary scripts from the System le that would normally have been
enabled and thus impossible to remove from the Finder.
Holding down the Shift key at startup prevents system extension les
from executingN including WorldScript I and WorldScript IL. If the
system script requires a script extension, system messages may not
display properly.
Apart from installing a script system itself, users can always move fonts into and out of
the Fonts folder, and input methods into and out of the Extensions folder.

Installing Modifications to a Script System
Applications that are written to take advantage of the Macintosh script management
system function correctly regardless of the localized version of Macintosh system
software under which they run. However, it is also possible to tailor an individual
application for a speci c script system or set of scripts, or for a speci c regional variation
of the system script or other script.
To do so may require installing a new script system or a modi ed set of resources to
replace those of a currently installed script system. (This is especially true if your target
region is not already supported by a localized version of system software.) Either way
usually involves modifying the System le. The Apple Computer system software
licensing policy forbids shipping a modi ed System le, so you cannot install your
replacement resources ina System le and ship it with your application. However, there
are three other approaches you can take:
m If you create individual modi ed versions of an installed script system@ resourcesN in
order to implement region-speci c sorting or formatting conventionsN you can attach
those resources to your application and have them replace the existing script system@
resources whenever your application is running.

Script Systems in Use

1-103

CHAPTER

1

Introduction to Text on the Macintosh

This method requires no modi cations to the System le at all. For speci c
instructions, see the discussion on replacing a script system@ default international
resources in the chapter Gcript ManagerOin this book.
m If you want individual resources permanently installed in the System le, you
can have the user run the Installer to install your resources. Contact Macintosh
Developer Technical Support for information on how to use the Installer. The user
will then be able to select or deselect your resources as defaults through the Text,
Numbers, and Date & Time control panels. See CUser Control of Script SettingsO
beginning on page 1-107.
m If you want to provide a complete script system with your application, you can ship it
as a separate le ina folder along with fonts and any other assocated les. The user
can then install it as an auxiliary script as described earlier, under Components of
Auxiliary Scripts.O
Your script system must be complete or it will not be enabled at startup. What
constitutes a complete script system is described under testing for script systems in the
chapter CScript ManagerOin this book. The formats of the resources you need to
include are described in the appendixes Onternational ResourcesOand Keyboard
ResourcesOin this book.
In general, it is not feasible to replace a system script, except by doing an CUpdate
InstallOfrom another complete localized system, as described on page 1-101. Although
the user can replace individual resources in the System le by using a resource editor
such as ResEdit, it is not possible to directly replace a system script with an auxiliary
script because a system script requires an international con guration ('itlc') resource,
which is not part of any auxiliary script. Furthermore, replacing the system script is not
the same as localizing all of the system software. A system script should support the
system software it is shipped with, meaning that the language and icons of system
menus, dialog boxes, and messages should refsect the system script. Merely replacing the
system script does not accomplish that.

How the User Switches Among Script Systems
The script system for display of text is controlled by the application or by the system,
based on which graphics port is active, which font is the current font, and what the states
of the font force Sag and international resources selection Sag are.

1-104

Script Systems in Use

CHAPTER

1

Introduction to Text on the Macintosh

The script system for text input, the keyboard script, is controlled by the user, either
explicitly through a menu selection, or implicitly through choosing a font or selecting
or clicking in displayed text of a particular script system. This section summarizes how
the keyboard script is selected; for more complete information, see the discussions of
keyboard settings and synchronization in the chapter Script ManagerOin this book.
In any localized version of system software in which more than one script system is
present, a small icon called a keyboard icon appears on the right side of the menu bar.
Figure 1-60 shows the keyboard icon for the Korean script system, to the left of the
application icon and to the right of the Help menu icon.
Figure 1-60

Menu bar with keyboard icon

Oo~ |

NN

This symbol indicates which keyboard script, as represented by a keyboard layout or
input method, is currently being used for text input. For example, the Arabic keyboard is
represented by a crescent, the Hebrew keyboard by a Star of David, and common
European keyboards by fags or other appropriate symbols. The Japanese input method
is represented by an Apple icon in front of a rising sun; Chinese by a coin (Simpli ed) or
a pot called a Ding (Traditional); Korean by the circular yin-yang symbol. The default
Roman keyboard is represented by a blue diamond, except on versions of system
software localized for the United States, in which it is represented by a U.S. fag. Figure
1-61 gives some examples of keyboard icons and input-method icons. Color Plate 4
shows a larger set of keyboard icons in color.
Figure 1-61

m

Keyboard icons and input-method icons

tl =

Script Systems in Use

wer

=e

we

ONS

PB

1-105

CHAPTER

1

Introduction to Text on the Macintosh

The keyboard icon serves as the title for the Keyboard menu; the user can click
the keyboard icon to pull down the Keyboard menu. The Keyboard menu shows all
keyboard layouts and input methods for all available keyboard scripts. The user makes
a selection from the Keyboard menu in order to change the keyboard script, or to
select among different keyboard layouts or input methods within a given script.
See Figure 1-62.
Figure 1-62

Keyboard menu

Omm<

About Keyboards...

|

Y OUS.

4 U.S.

- System 6

me Pycckaa

Cn
© Ipod
x nay
yw) Awhnds nay

gcerzo™

Vv @vsya

oN
The Operating System provides keyboard equivalents for switching among script
systems. In system software localized for the U.S., for example, if the user presses
Command Space bar, the Operating System switches the keyboard script to the QhextO
script system, meaning the default keyboard layout or input method for the next script
system listed (down) the Keyboard menu. If the user presses Command Option Space
bar, the Operating System switches to the next keyboard layout or input method within
the current script system.

1-106

Script Systems in Use

CHAPTER

1

Introduction to Text on the Macintosh

To see how the current keyboard layout functions, the user can select the Key Caps
desk accessory. Whenever the keyboard script or keyboard layout changes, the Key Caps
display changes to resect the new character set and its arrangement on the keyboard.
See Figure 1-63.
Figure 1-63

Arabic Key Caps

SSS

Oo

Ke

SSS STs

Caps

ss spi sisi sis

-elilrirjedolajvjala)].)]-]=

SPReAPE

= Pe Py en
SRA
AE

i

AE:

=) ve

cy
eed?

-]a] \

i sisics
OlO/;/O}JO}
=] 7) *

olo}lz7)slol-

415/6]+
1])/2)3
0
oO

Application-Controlled Switching
Your application must synchronize the current font with the keyboard
script whenever you are displaying characters as the user enters them. If
the user changes fonts, you need to automatically change the keyboard
script to correspond to the new font. Conversely, if the user changes
keyboard scripts, you need to change the font appropriately before
displaying the next character typed. Failure to do so can lead to incorrect
text display. See (Font and Keyboard SynchronizationOon page 1-90.

User Control of Script Settings
The script management system provides three control panels that allow the user to
change the settings of certain script-system features and to save the settings across
system restarts.
The Text control panel, shown in Figure 1-64, is available on non-U.S. versions of system

software. It allows users to set the text behavior of any enabled script system, and may
allow the user to set the system direction, the state of the font force fag, the caret style,
and the rate of caret blinking. (Some of the settings are not available unless certain script
systems are present.)

Script Systems in Use

1-107

CHAPTER

1

Introduction to Text on the Macintosh

The appearance of the dialog box varies with the version of localized system software;
Figure 1-64 represents a Text control panel for Hebrew system software localized to have
all text strings in English.
Figure 1-64

a

Text control panel

SS=-_—S=-=-_—S====

Text

____a_a_a==EEa===®y

Text Behaviors
.

Script:

|

Behavior:

|

Insertion

Hebrew

w]

Hebrew

w

conversion, and word definitions.

{] Force
Display

Hebrew

all Hebrew

®

BN

font

Hebrew text.

O71 3W

Appearance

Rate of Blinking—

Oo

Oo

Singl

$1

ingle

©

ow

System

Direction

©)

«e—

;
Right to left

@

—®

Left to right

text in a Hebrew

font. This is only necessary for
applications that do not support

Sample:

-—

Split

Affects sort order, case

Point

EnglisHoru;

Oo

Fast
as

m9)

mw The Text Behaviors settings control which string-manipulation ('1t12') resource
is used for sorting, case conversion, and word selection for the selected script

system (including the system script). The choices are limited to the installed
string-manipulation resources for the enabled script systems (including the
Roman string-manipulation resource, which is always present). If more than one
choice is available and the user changes this setting, the new setting is saved in
the itlbSort eld of the script@ international bundle resource.
m The System Direction setting controls the primary line direction and alignment for all
text and interface elements controlled by the system. The system direction may be set
to either left to right or right to left. The user@ selection is immediately re8ected in the
alignment of elements in all system and Finder dialog boxes and in all menus.
It changes the setting of the system global variable SysDirection. The setting
is also saved inthe itlcSysFlags

eldofthe system@ international con

guration

resource. (This control appears only if at least one bidirectional script system
is enabled.)

m The font force Sag may be set to either TRUE or FALSE, which affects the setting of the
Script Manager variable accessed through the smFont Force selector for the
Get ScriptManagerVariable function. The font force Sag allows display of
non-Roman text in an application that normally supports Roman text only. See
the chapter CScript ManagerOin this book. The setting made by the user is saved in the
itleFontForce eld of the system@ international con guration resource.
(This control appears only if the system script supports font forcing.)

1-108

Script Systems in Use

CHAPTER

1

Introduction to Text on the Macintosh

m The Insertion Point setting sets the caret style. The caret may appear either as a single
caret or as a dual (split) caret (see Figure 1-46 on page 1-78 for an example). The setting
made by the user is refsected in the value of the Script Manager general fags, accessed
through the smGenFlags

selector for the

Get ScriptManagerVariable

function.

See the chapter Script ManagerOin this book. The setting made by the user is saved in
the itlcFlags_ eld of the system@ international con guration resource. (This control
appears only if at least one bidirectional script system is installed.)
The rate of caret blinking (slow, medium, or fast) affects the insertion point in text

elds. The userG setting is saved in parameter RAM.

The Numbers control panel, shown in Figure 1-65, allows users to specify the basic
number and currency formats for the system script. User settings made through this
control panel are saved in the system script@ numeric-format ('it10') resource.
Figure 1-65

Numbers control panel

(4

Numbers

Number Format: | U.S.
Separators

Decimal:
Thousands:

v|

Currency

|. |)

Symbol: [s__ |
@ Before number

|

|)

©) After number

Sample

$1,234.56

m

The Number Format setting controls which numeric-format ('1t10') resource is used
for default number, currency, and short-date formats. The choices are limited to the

installed numeric-format resources for the system script. If the user changes any of the
default settings, a new setting called custom is created in the Number Format popup
menu, and is saved as a new numeric-format resource for the system script;
its ID is then saved in the it lbNumber eld of the system script@ international
bundle resource.
m The Separators settings allow the user to override the default decimal separator and
thousands separator for the system script. Suggested separators are presented in the
popup menus for the settings, although the user can enter any 1-byte character for
either separator. The settings made by the user are saved in the decimal Pt and
thousSep elds of the system script@ custom numeric-format resource.
m The Currency settings allow the user to specify a currency symbol of up to three 1-byte
characters or a single 2-byte character, and to choose whether the symbol precedes or
follows a currency number. The settings made by the user are saved
in the currSym1 through currSym3_ elds of the system script@ custom
numeric-format resource.

Script Systems in Use

1-109

CHAPTER

1

Introduction to Text on the Macintosh

The Date & Time control panel, shown in Figure 1-66, allows users to set the current

date and time and to specify formatting preferences for both. The settings made with this
control panel affect the display of dates and times by the system and Finder and by the
Text Utilities date- and time-formatting routines, when the resources of the system script
are used (that is, as long as the international resources selection Sag is TRUE).

Figure 1-66
=[4

Date & Time control panel
Date & Time

a

Current date

| 9/26/92

Current time

|

[ Date Formats...

| 1:12:46 PM
]

|

[ Time Formats...

]

Format settings are made with individual Date Formats and Time Formats dialog boxes.
Custom user settings made through these dialog boxes are saved as new numeric-format
('it1l0') and long-date-format ('it11') resources for the system script.
The Date Formats dialog box sets date formats, as shown in Figure 1-67.

Figure 1-67

@y

Date Formats dialog box (from Date & Time control panel)

Date Formats: |

U.S.

v |

Prefix: [

| Month/Day/Year wv]

|

Weekday

¥ |

|}

|

Day

v |

:

|

(] Leading zero for day

|

Year

v |

|

|

[| Leading zero for month

| Month

y)

|

|

|

(] Leading zero for day
— Samples

Thursday , January 2, 1992

Thu, Jan 2, 1992

1/2/82

1-110

Script Systems in Use

Separator:

C] Show century

Cancel

CHAPTER

1

Introduction to Text on the Macintosh

The Date Formats setting allows the user to select a long-date-format ('i1t11') and
numeric-format ('it10') resource to be used for date formatting. The choices are
limited to the installed pairs of numeric-format and long-date-format resources for the
system script. If the user changes any of the default settings, a new setting called
QustomOis created in the Date Formats popup menu, and is saved as a new pair of
numeric-format and long-date-format resources for the system script; their IDs are
then saved inthe itlbNumber eldanditlbDate eld of the system script@
international bundle resource.
The Long date settings allow the user to select what elements to include in a long date,
what order they should be in, and what separators should be between them. The Long
date settings also allow the user to specify the use of a leading zero for the day number
in a long date. The settings made by the user are saved in the days, months,
suppressDay, lngDateFmt, st0 through st4,and dayLeading0o

system script@ custom long-date-format resource.

elds of the

The Short date settings allow the user to select the order of date elements in a
short date, and to specify a single (1-byte) character as separator. The Short date
settings also allow the user to specify whether to use a leading zero for day number or
month number, and whether to show the century. The settings made by the user are
saved in the dateOrder, dateSep, and shortDateFmt
custom numeric-format resource.

elds of the system script@

The Time Formats dialog box sets time formats, as shown in Figure 1-68.

Time Formats dialog box (from Date & Time control panel)

;

@ 12 hour

Format

Before noon: | AM

Noon & midnight:
©
®

After noon: | PM

0:00

12:00

Separator:

(] Use leading zero for hour
~

Samples

12:34 AM

m

©

© 24 hour

v |

se]

Clock

U.S.

Q
—|

Time Format: |

>|

Figure 1-68

4:56 PM

The Time Format setting allows the user to select a numeric-format ('it10') resource

to be used for time formatting. The choices are limited to the installed numeric-format
resources for the system script. If the user changes any of the default settings, a new
setting called QustomOis created in the Time Formats popup menu, and is saved as a
new pair of numeric-format and long-date-format resources for the system script; their
IDs are then saved in the it lbNumber eldand itlbDate eld of the system srcipt@
international bundle resource.

Script Systems in Use

1-111

CHAPTER

1

Introduction to Text on the Macintosh

m The Clock settings allow the user to choose a 12- or 24-hour time cycle, and to specify

whether midnight (and noon, if a 12-hour cycle) is considered to be hour 0 or hour 12.

The settings made by the user are saved in the
custom numeric-format resource.

timeCycle

eld of the system script@

m The Format settings allow the user to specify a 1-byte character as separator for the
time elements, and to specify morning and evening trailing strings (such as AM and
PM) for the 12-hour cycle. The current separators and trailing strings are presented in
the elds for the settings, but the user can enter any 1-byte character for the separator
and any string of up to 4 bytes for either trailing string. The settings made by the user
are saved in the timeSep, mornStr,and eveStr_ elds of the system script@ custom
numeric-format resource.
Script-specific control panels

In addition to the control panels described in this section, individual
script systems may provide their own control panels for other purposes,
such as allowing a user to select a custom calendar system, an associated
font, or a set of numerals (ASCII or non-ASCII). The results of those
selections may be kept ina script preferences le. @

1-112

Script Systems in Use

C

HAPTER 2

TextEdit

Contents
About TextEdit
2-6
TextEdit and Standard Macintosh Features
2-6
Multistyled and Monostyled Text = 2-7
Font and Keyboard Script Synchronization
2-8
Cutting, Copying, and Pasting Text
2-9
The TextEdit User Interface
2-10
The Selection Range, the Insertion Point, and Highlighting in

TextEdit

2-10

Caret Position and Movement
Text Alignment
2-13
Line Measurement
2-14
Text Buffering
2-14

2-11

The TextEdit Private, Null, and Style Scraps

2-15

An Overview of the TextEdit Data Structures
2-16
An Overview of the Edit Record
2-16
Related Data Structures
2-17
Using TextEdit
2-21
Getting Started With TextEdit
2-22
Preparing to Use TextEdit
2-22
Displaying Static Text
2-24
Creating an Edit Record
2-24
Specifying the Destination and View Rectangles
2-28
Setting the Text of an Edit Record
2-29
Setting the Selection Range or the Insertion Point —_ 2-30
Scrolling Text
2-31
Disposing of an Edit Record
=. 2-32
Responding to Events Using TextEdit
2-32
Handling a Null Event
2-32
Activating an Edit Record —. 2-33
Handling Mouse-Down Events
2-34

Contents

9-1

CHAPTER

2

Responding to an Update Event

= 2-36

Accepting Text Input Through Key-Down Events

Moving Text In and Out of Edit Records

—_2-38

Using TextEdit to Cut, Copy, and Paste Text
Inserting and Deleting Text
2-43
Text Attributes
2-43

2-39

Checking the Text Attributes Across a Selection Range
Toggling an Attribute
Handling a Font Menu

2-36

= 2-44

2-46
2-47

Handling a Font Size Menu
2-48
Handling a Style Menu — 2-48
Changing the Text Alignment

2-50

Saving and Restoring a TextEdit Document, and
Implementing Undo
2-51
Saving a TextEdit Document
2-51
Restoring an Existing TextEdit Document
— 2-53
Handling Undo
—_.2-55
Customizing TextEdit
2-56
Replacing the End-of-Line Routine
2-57
Replacing the Drawing Routine
2-58
Replacing the Width-Measuring Routines
—_2-58
Replacing the Hit Test Routine —_ 2-60
Customizing Word Selection
2-60
Customizing Automatic Scrolling
2-61
Determining the Line Length
2-62
Advanced Customization
2-63
TextEdit Reference
2-64
Data Structures
2-64
The Edit Record
2-67
The High Hook and Caret Hook Fields
—2-70
The Style Record
2-71
The Style Table
2-72
The Line Height Table
2-73
The Null Style Record
2-74
The Style Scrap Record
2-74
The Scrap Style Table
2-75
Text Style Record
2-76
Routines
2-76
Initializing TextEdit, Creating an Edit Record, and Disposing of an Edit
Record
2-77
Activating and Deactivating an Edit Record — 2-80
Setting and Getting an Edit Record@ Text and Character Attribute
Information
2-81
Setting the Caret and Selection Range
= 2-84
Displaying and Scrolling Text
2-86
Modifying the Text of an Edit Record
2-93
Managing the TextEdit Private Scrap
2-98

Contents

CHAPTER

2

Checking, Setting, and Replacing Styles
2-99
Using Byte Offsets and Corresponding Points
Additional TextEdit Features
2-107
Customizing TextEdit
2-110
Summary of TextEdit
2-118
PascalSummary
2-118
Constants
2-118
Data Types
2-120
Routines
2-123
C Summary
2-125
Constants
2-125
Types
2-127
Routines
2-130
Assembly-Language Summary
2-132
Trap Macros
2-132
Global Variables
2-133

Contents

2-105

2-3

CHAPTER

2

TextEdit

TextEdit is a collection of routines and data structures that give your application
basic text formatting and editing capabilities, including text display in multiple scripts.
TextEdit manages fundamental text processing tasks on text limited to 32 KB. You can use
the TextEdit routines in many kinds of applications, such as spreadsheets, online
(data-entry) forms, online advertising programs, simple programming-language or
text- le text editors, electronic mail programs, drawing and painting programs with
simple text-editing features, and electronic note cards. However, TextEdit was not
designed to be used to implement word-processing applications with complex support
that manipulate lengthy documents.
To use TextEdit and the information provided in this chapter, you should be familiar with
the basic concepts and structures behind QuickDraw and how it handles textN
particularly points, rectangles, graphics ports, fonts, and character styleN the
Event Manager, the Window ManagerN particularly update and activate eventsN the
Font Manager, the Script Manager, and Text Utilities.
For information on non-text features of QuickDraw, see Inside Macintosh: Imaging. For
information on the Event Manager and the Window Manager, see Inside Macintosh:
Macintosh Toolbox Essentials.
This book includes chapters that cover the Font Manager, Text Utilities, the Script
Manager, and QuickDraw Text. Although these chapters pertain to TextEdit, the only
chapter in this book that you need to read as a prerequisite to TextEdit is Gntroduction to
Text on the Macintosh.O
This chapter describes how to use TextEdit to perform a range of editing and formatting
capabilities including
m inserting new text
m selecting and highlighting ranges of text
m deleting selected text and possibly inserting it elsewhere, or copying text without
deleting it
m replacing selected text
m translating mouse activity into text selection
m scrolling text within a window, including automatically scrolling text that is not visible
but is affected by the editing activity
m

changing the characteristics of text, including font family, style, and size

m customizing some TextEdit behavior

2-5

CHAPTER

2

TextEdit

About TextEdit
TextEdit was originally designed to handle editable text items in dialog boxes and other
parts of the system software. Although TextEdit has been enhanced to provide more
text-handling support since its inception, especially in its handling of multi-script text, it
retains some of its original limitations. TextEdit was not originally intended to
manipulate lengthy documents or text requiring more than rudimentary formatting. For
example, TextEdit does not handle tabs. (Your application can provide support for tabs to
supplement TextEdit.)
However, TextEdit handles some of the cumbersome tasks that a text processor needs to
perform, and provides you with an alternative to writing your own text processor. For
example, when you use TextEdit routines to edit text, your application does not need to
allocate memory for blocks of text that change dynamically during the editing session
because TextEdit takes care of this for you. When the user selects a range of displayed
text of a TextEdit edit record, TextEdit recognizes this and responds by highlighting
the text.
TextEdit relies on the Script Manager, QuickDraw, and Text Utilities to handle text

correctly, and eliminates the need for your application to call these routines directly.
Because TextEdit supports text from more than one script system and manages scripts
having different primary line directions, you can use its routines and features to develop
applications that support multiple languages.
TextEdit uses Text Utilities routines: the FindWordBreaks procedure for determining
word breaks and the Sty ledLineBreak function for determining line breaks. TextEdit
also allows you to customize how word boundaries and line breaks are de ned.

TextEdit and Standard Macintosh Features
Because TextEdit routines follow the Macintosh user interface guidelines, using them
ensures the presentation of a consistent user interface in your application. Your
application can rely on TextEdit to support these standard features instead of having to
implement them directly:
m selecting text by clicking and dragging with the mouse
m double-clicking to select words, which are de ned according to the rules of the script
system in which they are written
m line breaking, which prevents a word from being split inappropriately between lines
when text is drawn

About TextEdit

CHAPTER

2

TextEdit

m extending or shortening a selection range by Shift-clicking
m highlighting of the current text selection, or display of a blinking vertical bar at an
insertion point
m cutting, copying, and pasting within and between applications
m

the use of more than one font, size, color, and stylistic variation from character to

character within a single block of text

m display of text in more than one language on a single line

Multistyled and Monostyled Text
Text is rendered in a certain font, style, size, and color. These aspects of text are

collectively referred to as character attributes. TextEdit supports the display of text in
various character attributes (different fonts, styles, sizes, and colors) within the context of

a single edit record.

Text that uses a variety of fonts, styles, sizes, or colors is referred to in this chapter as

multistyled text to distinguish it from text that uses a single font, style, size, and color,
which is referred to as monostyled text.
TextEdit lets you boldface, italicize, underline, outline, condense, extend, and shadow

text. Using TextEdit routines, you can change the font family and type size of the entire
text of an edit record (or a selected range of text that the user has chosen or the
application has set). You can even increase the type size incrementally across a range of
text containing various sizes, for example, so that all 10 point text is changed to 12 point
and all 12 point text is changed to 14 point. If your application uses multistyled TextEdit
and allows users to select fonts, TextEdit displays text correctly in all scripts. Apart from
the TextEdit routines that deal with multistyled text exclusively, you can use all of the
TextEdit routines to simplify and manage your application@ text editing tasks for both
multistyled and monostyled text.
Note

In the original Inside Macintosh documentation that describes TextEdit,
the term face is used to refer to the following text style attributes: bold,

italic, underline, outline, condense, extend, and shadow. The term style is
now used instead of face to refer to these attributes.

TextEdit organizes multistyled text into style runs. The characters comprising a style run
are contiguous in memory and are all displayed in the same font, size, color, and script as

well as style. TextEdit tracks style runs in the data structures that are allocated for a
multistyled edit record and uses this information to correctly display multistyled text.

About TextEdit

2-7

CHAPTER

2

TextEdit

Figure 2-1 shows four style runs in a line of text.

Figure 2-1

Style runs in a line of text

———nE

DIY peace on earth DIDW

a

RamatGan
24 plain

|

|

Helvetica
18 italic

|

Helvetica
18 plain

nS

CD

RamatGan
24 plain

TextEdit supports mixed-directional text: the combination of scripts with left-to-right
and right-to-left directional text within a single line. Figure 2-2 shows an example of
Hebrew and Roman text on the same line. The two runs of Hebrew text have a
right-to-left direction, and the Roman text direction is left to right.

Figure 2-2

Mixed-directional text display

————————

DIY peace on earth DIDW i

—_—__———_

P<

Font and Keyboard Script Synchronization
TextEdit handles synchronization of the font script, the script system that corresponds to
the font of the current graphics port, and the keyboard script, the script system used for
keyboard input, for multistyled and monostyled text.
For monostyled text, the primary script system determines whether or not TextEdit
synchronizes the font script and the keyboard script, based on the value of a Sag in the
script system@ international bundle resource (' it 1b'). TextEdit uses this 8ag, without
requiring any action on the part of your application.

About TextEdit

CHAPTER

2

TextEdit

For multistyled text, TextEdit always synchronizes the font script and the keyboard
script. (If the font script at the selection range or insertion point is the same as
the keyboard script, then this font is used.) The following sections explain the conditions
that determine whether TextEdit matches the keyboard script to the font script or
vice versa. TextEdit synchronizes the keyboard script with the font script under the following
conditions:
mw When your application calls a TextEdit routine to change the font of a text selection or
to process a mouse-down event in text as either an insertion point or a selection. This
means, for example, that if a user types Arabic text followed by Roman text and clicks
in the Arabic text, the keyboard adjusts and changes to Arabic without the user@
needing to change the keyboard manually. Similarly, if a user clicks in the Roman text,
the keyboard changes to Roman without the user@ altering the keyboard.
m If the selection range encompasses textN if it is not an insertion pointN then TextEdit
uses the font corresponding to the rst character of the selected text to determine the
keyboard script. When an insertion point falls on a script boundary, the keyboard is
synchronized to the font of the character preceding the boundary (in storage order). (A
selection range is a series of characters, selected by the user or the application, where
the next editing operation is to occur. Although the character representations are
contiguous in memory, they can be discontinuous on the display screen when the text
is bidirectional. For more information, see (The Selection Range, the Insertion Point,
and Highlighting in TextEditOon page 2-10.)

TextEdit synchronizes the font script with the keyboard script under the following condition:
mw When your application calls a TextEdit routine to input a character and if the keyboard
script is different from the font script at the selection range (or insertion point). Ifa
font was selected and never used, thus remaining in the scrap that TextEdit uses for

character attributes (null scrap) and if the font script coincides with the keyboard
script, then this font is used. Otherwise, TextEdit searches through the preceding fonts
in the style run table until it locates a font that corresponds to the keyboard. If one
does not exist, then it uses the application font. For more information about the null
scrap, see (Lhe TextEdit Private, Null, and Style ScrapsOon page 2-15.

Cutting, Copying, and Pasting Text
TextEdit provides routines that let you cut, copy, and paste text
m within a single edit record
m between edit records within an application
m between an application and a desk accessory
m across applications
You use the same routines to cut and copy monostyled and multistyled text. There are,
however, separate routines for pasting monostyled and multistyled text. For multistyled
text, the TextEdit routines preserve any stylistic variation along with the cut or copied
text in order to restore it when you paste the text.

About TextEdit

2-9

CHAPTER

2

TextEdit

The TextEdit User Interface
This section describes the TextEdit user interface, that is, how TextEdit displays text on

the screen and the methods it uses to communicate information about that text to an
application user. It explains some of the processes that TextEdit performs automatically
for your application, including how TextEdit uses highlighting or a caret to identify
where the next editing operation is to occur, how TextEdit handles line measurement for
your application, and how TextEdit uses buffering to handle 2-byte characters.
This section also covers some aspects of the user interface that your application can
control through TextEdit routines, such as the kind of text alignment and the use of

buffering to enhance performance.

The Selection Range, the Insertion Point, and Highlighting in TextEdit
Depending on the purpose of an application, a user might select a range of text to be
edited or the application might set the selection range. In either case, the selected text
becomes the current selection range. TextEdit uses a byte offset to identify the position of
a character in the text buffer of an edit record, and an edit record includes

elds that

specify the byte offsets of the characters in the text buffer that correspond to the
beginning and the end of the current selection range in the displayed text. (See OAn
Overview of the Edit RecordOon page 2-16 for more about edit records.)

When the byte offset values for the beginning and the end of the selection range are the
same, the selection range is an insertion point. TextEdit marks an insertion point with a
blinking caret in the form of a vertical bar (|).

TextEdit uses highlighting to display a selection range. Because TextEdit supports
mixed-directional text, the selection range can appear as discontinuous text. Displayed
text is highlighted according to the storage order of the characters. When multiple script
systems having different line directions are installed, a continuous sequence of characters
in memory may appear as a discontinuous selection when displayed.
Figure 2-3 shows how TextEdit highlights a range of text whose displayed glyphs are not
contiguous, although their corresponding byte offsets are contiguous in memory. In this
example, the primary line direction is left to right.

Figure 2-3

Discontinuous highlighting display

OE
————————————————=y

Diy peace Mileun 0

2-10

About TextEdit

F

CHAPTER

2

TextEdit

TextEdit provides a function that lets you to turn outline highlighting, the framing of
text in a selection range, in an inactive window, on or off. See Figure 2-4. (For more

information about outline highlighting, see O'EFeatureFlagOon page 2-107.)
Figure 2-4
=a

Outline highlighted text selection in background window

Active Window

‘=

Here is an example of background outline highlighting

|]

night the day,

Thou can not be false to any man.”

Inactive window
e of background outline highlighting
Hit document: |This, above all: ta

true, And it must follow, as the

u can not be false to any man.”

a
Caret Position and Movement
This section describes how TextEdit displays and moves a caret. For more information,
see the discussion of caret handling in the chapter Gntroduction to Text on the
MacintoshOin this book.
TextEdit marks the position in the displayed text where the next editing operation is to
occur with a caret. When TextEdit pastes text into a record, it positions a caret after the

newly pasted text on the screen. TextEdit uses a single caret for text that does not include
mixed directions. When TextEdit displays a single caret in unidirectional text and the
user presses an arrow key to move the caret left or right across the text, TextEdit moves
the caret in the direction of the arrow key.
When the text includes mixed directions, TextEdit uses either a moving caret or a dual

caret, depending on the value of a Script Manager fag. For example, if this Sag speci esa
moving caret, TextEdit displays the caret at the screen location where the next glyph is to
appear, based on the text direction of the keyboard script.
If this Sag speci es a dual caret, TextEdit displays a high caret and a low caret, each
measuring half the line@ height. The high caret is displayed at the screen location
associated with the glyph that has the same direction as the primary line direction, and
the low caret is displayed at the screen location associated with the glyph that has a
different direction from the primary line direction.

When TextEdit displays a dual caret on a direction boundary, only the primary caret
moves in the direction of the arrow. Figure 2-5 shows a sequence of two Right Arrow
keypresses and their impact on caret display and movement in a line containing
mixed-directional text. In this example, the primary line direction is right to left.

About TextEdit

2-11

CHAPTER

2

TextEdit

Figure 2-5

Caret movement across a direction boundary

Original caret
position

|.

|

Dual caret
positions

New caret
position

Inthe rst instance of the text segment, the caret is positioned within the Arabic text.
When the user presses the Right Arrow key once, the insertion point is positioned on a
direction boundary and the caret splits into a dual caret. When the user presses the Right
Arrow key again, TextEdit displays a single, full caret after the parenthesis in the Roman
text. Because the caret position is again in the middle of a style run, TextEdit no longer
uses the dual caret.
Note
TextEdit currently deviates from this model for caret movement in
monostyled left-to-right text (displayed in a non-Roman font) on any
primary right-to-left script system. On the Arabic script system, for
example, it is possible to display the low-ASCII Roman characters from
an Arabic font. If a user presses the arrow keys to move through these
characters, the caret moves in the opposite direction of the arrow. #
Vertical movement of the caret is less complex. When the user presses the Up Arrow key,
the caret moves up by one line, even in lines of text containing fonts of different sizes.
When the caret is positioned on the

rst line of an edit record, and the user presses the

Up Arrow key, TextEdit moves the caret to the beginning of the text on that line, at
primary caret position 0. (This position corresponds to the visible right end of a line when
the primary line direction is right to left and to the left end of the line when the primary
line direction is left to right.)

2-12

About TextEdit

CHAPTER

2

TextEdit

Similarly, when the user presses the Down Arrow key, the caret moves down one line.
When the caret is positioned on the last line of an edit record, and the user presses the

Down Arrow key, TextEdit moves the caret to the end of the text on that line (that is, the

visible left end of a line when the primary line direction is right to left and to the right
end of a line when the primary line direction is left to right).

Note
TextEdit does not support the use of modi er keys, such as the Shift key
or the Option key, in conjunction with the arrow keys. @
If spaces at the end of a text line extend beyond the view rectangle, TextEdit draws the
caret at the edge of the view rectangle, not beyond it. Whether TextEdit displays a caret at
the beginning or end of a line when a mouse-down event occurs at a line@ end depends
on the current caret position and the value ina eld (clikStuf £) of the edit record.
TextEdit sets this eld to refSect whether the most recent mouse-down event occurred on
the leading or trailing edge of a glyph.
For example, if the mouse-down event occurs on the leading edge of a glyph, TextEdit
displays the caret at the caret position corresponding to the leading edge of that glyph. If
the mouse-down event is on the trailing edge of a glyph, TextEdit displays the caret at the
beginning of the next line. For more information about determining a caret position, see
the sections that discuss caret handling in the chapters introduction to Text on the
MacintoshOand CQuickDraw TextOin this book.

Text Alignment
TextEdit allows you to specify the alignment of the lines of text, that is, their horizontal
placement with respect to the left and right edges of the text area or destination rectangle.
The different types of alignment that TextEdit supports accommodate script systems that
are read from right to left, as well as those that are read from left to right. The types of
alignment supported are
m default alignment (positions the text according to the line direction of the system
script. It can be either left or right. Line direction is the direction in which text in a
particular language is written and read. The English language has a rightward, or
left-to-right, line direction. Arabic and Hebrew have a [primarily] leftward, or

right-to-left, line direction.)

m center alignment (centers each line of text between the left and right edges of the
destination rectangle)
m right alignment (positions the text along the right edge of the destination rectangle)
m left alignment (lines up the text with the left edge of the destination rectangle)
If your application requires justi ed alignment, you can use the QuickDraw routines that
support full justi cation; TextEdit does not support justi ed alignment. See the chapter
CQuickDraw TextOin this book for more information.

About TextEdit

2-13

CHAPTER

2

TextEdit

Line Measurement
TextEdit measures a line of text appropriately for all script systems by removing any
trailing white space from the end of it, taking the line direction into account. It uses the
QuickDraw VisibleLength function to exclude trailing white space, based on the
script system, the text direction, and the primary line direction. For more information
about the behavior of VisibleLength for various script systems, see the chapter
CQQuickDraw TextOin this book.

An anomaly exists, however, in the way TextEdit draws at the end of a line. When the
primary line direction of a script system is right to left (for instance, on a Hebrew
system), when the alignment is left or center, and when spaces are entered in a
right-to-left font, TextEdit measures spaces at the end of the line and therefore may draw
the text beyond the edge of the view rectangle. The caret, however, remains in view and
is pinned to the left edge of the view rectangle.
This anomaly also exists when the primary line direction of a script system is left to right
and the alignment is center. In this instance, TextEdit measures spaces at the end of the
line, and as more spaces are added (and, therefore, measured), the visible text in the line

is drawn out of view beyond the left edge of the view rectangle. The caret, however,
remains in view and is pinned to the right edge of the view rectangle.

Text Buffering
TextEdit uses two methods of text buffering; one method, which is automatic, is used to

handle 2-byte characters properly. The other method, which you can enable or disable,
improves performance in relation to how TextEdit handles input of 2-byte characters.

For the rst method, which is automatic, TextEdit relies on the Script Manager. The Script
Manager handles 2-byte characters properly, and TextEdit takes advantage of this. If a
2-byte character, such as a Kanji character, is typed, TextEdit buffers the rst byte until it
processes the second byte, at which time it displays the character. The internal buffer that
TextEdit uses for a 2-byte character is unique to each edit record. For example, TextEdit
can buffer the rst byte of a 2-byte character in a record, then the application can call the
TextEdit TEKey procedure for another edit record. While TEKey processes the character
for the second edit record, the rst byte of the 2-byte character remains in the rst edit
record@ buffer until TextEdit processes the second byte of that 2-byte character, and then
displays the character.
The second method of text buffering enhances performance, and you can turn it on or off
through the TextEdit function, TEFeatureFlag. In this case, TextEdit uses a global

bufferN it differs from the TEKey procedure@ internal 2-byte bufferN that is used across
all active edit records. These records may be in a single application or in multiple
applications. Because of this, you should exercise care when you enable the text-buffering
capability in more than one active record; otherwise, the bytes that are buffered from one
edit record may appear in another edit record.
m Ensure that buffering is not turned off in the middle of processing a 2-byte character.
To guarantee the integrity of your record, it is important that you wait for an idle event
before you disable buffering or enable buffering in a second edit record.

2-14

About TextEdit

CHAPTER

2

TextEdit

mw When text buffering is enabled, ensure that TEI d1e is called before any pause of more
than a few ticksN for example, before WaitNextEvent. A possibility of a long delay
before characters appear on the screen existsN especially in non-Roman systems. If
you do not call TEIdle, the characters may end up in the edit record of another
application.
If you enable text buffering for performance enhancement on a non-Roman script system
and the keyboard has changed, TextEdit Sushes the text of the current script from the
buffer before buffering characters in the new script.

The TextEdit Private, Null, and Style Scraps
There are three scrap areas that TextEdit uses exclusively: the TextEdit private scrap, the
TextEdit null scrap, and the TextEdit style scrap. The TextEdit routines use all of these
scraps to hold transient information.
TextEdit uses the private scrap for all cut, copy, and paste activity whether the text is
multistyled or monostyled. The private scrap belongs to the application. When the text is
multistyled, TextEdit also copies the text to the Scrap Manager@ desk scrap.
TextEdit uses the null scrap to store character attribute information associated with a null
selection (an insertion point) or text that is deleted when the user backspaces over it. The

null scrap belongs to the multistyled edit record. Character attribute information stored
in the null scrap is retained until it is used, for example, when applied to newly inserted
text, or until some other editing action renders it unnecessary, such as when TextEdit sets
anew selection range. A number of routines that deal with multistyled text check the null
scrap for character attribute information and, if there is any, apply it to newly inserted
text when character attributes for that text are not available.
When you cut or copy multistyled text, memory is allocated dynamically for the style
scrap and the character attribute information is copied to it. Your application can also use
the style scrap for other purposes. For example, to save and restore multistyled text both
the text and the associated character attribute information must be preserved;
you can save character attributes associated with a range of text in the style scrap. Also,
you can create a style scrap record and store character attribute information in it to
be applied to inserted text. Your application can create as many style scraps as it needs.
For more information, see the discussion of the style scrap record under CData
StructuresOon page 2-64.
As part of TextEdit initialization, TEInit creates the private scrap and allocates a handle
to it. TextEdit creates and initializes a null scrap for a multistyled edit record when an
application calls TESt y1eNew to create the edit record. (The null scrap remains
throughout the life of the edit record: it is disposed of when the application calls
TEDispose to destroy the edit record and release the memory allocated for it.) TextEdit
allocates memory used for the style scrap dynamically when your application calls a
routine that uses it.
Note

Because these scraps are in RAM, they are volatile, and a power failure
can cause the data in a scrap to be lost.

About TextEdit

2-15

CHAPTER

2

TextEdit

An Overview of the TextEdit Data Structures
To edit text on the screen, TextEdit maintains information about where the text is stored,

where to display it, and the text style. This information is contained in a record that
de nes the complete editing environment. You can allocate a monostyled edit record to
contain text that is set in a single font, size, and style, or you can allocate a multistyled

edit record to contain text with attributes that can vary from character to character.

An Overview of the Edit Record
An edit record, which is the primary data structure that TextEdit uses, carries text
storage, display, and editing information. When you allocate an edit record, you specify
where the text is to be drawn and where it is to be made visible. The destination
rectangle is the area in which the text is drawn, and the view rectangle is that portion of
the window within which the text is actually displayed. (For a complete discussion of
destination and view rectangles, see the QuickDraw chapters in Inside Macintosh:

Imaging.) Figure 2-6 shows two sets of destination and view rectangles. The view
rectangles are shaded and de ned by dotted lines. The text is drawn in the destination
rectangle; the part of it that is displayed is de ned by the view rectangle.
Figure 2-6

Destination and view rectangles

View
rectangles

|

"Whatla piece of work is aiman, how

reason, how infinite in
faculties, in form and
moving, how express
and admirable in action,
how like an angel in
apprehension, how like
a god!, the beauty of
the world; the paragon
of animals; and yet to
Me what is this
quintessence of)dust?”

in form and moving, how express and
admirable in action, how like an angel in
apprehension, how like aigod!, the
beauty of the world; the piaragon of
animals; and yet to me whiat is this
quintessence of dust?"

is

aman, how noble in

Destination
rectangles

2-16

|

"What a piece of work

About TextEdit

noble in reason, how infinite in faculties,

CHAPTER

2

TextEdit

The edit record includes elds that point to these rectangles. In addition to the two
rectangles, the edit record also contains
m

a handle to the text to be edited

m the current selection range that determines exactly which characters are to be affected
by the next editing operation
m

the alignment of the text, as left, right, or center

m for multistyled edit records, a handle to a subsidiary record, the style record,
containing the character attributes used to portray the text. This style record, itself,
contains subsidiary data structures.

Related Data Structures
Stemming from the main TextEdit edit record, relationships exist among the rest of the
TextEdit data structures.
When TextEdit creates an edit record, the record contains a_

eld that stores the handle to

the dispatch record. The dispatch record is an internal data structure whose _ elds,
referred to as hook

elds or hooks, contain the addresses of routines that TextEdit uses

internally, for example, to measure and draw text, or to determine a character@ position
on a line. These routines, called hook routines, determine the way TextEdit behaves. You

can use a TextEdit customization routine to replace the address of a default hook routine
with the address of your own customized routine. For example, you can provide a
routine to be used for word selection that de nes word boundaries more precisely for
any script system.
When you allocate a monostyled edit record, the edit record, a handle to the text, and a

single subsidiary internal data structure, the dispatch record, are created. However, when
you allocate a multistyled edit record, a number of additional subsidiary data structures
are created to support the text styling capabilities and the display of text in multiple
languages.
For a multistyled edit record, the edit record contains a handle to the style record. The

style record stores the character attribute information for the text, and contains a handle
to the style table, which has one entry for each distinct set of character attributes. Each
entry in the style table is a style element record. The style record also contains a style run
table, which is an array that gives the start of each style run, and an index into the style
table. The style run table array identi es the byte offset of the starting character to which
the character attributes, stored in the style table, apply.

About TextEdit

2-17

CHAPTER

2

TextEdit

The style record contains two other handles: a handle to the line-height table and a
handle to the null style record. The line-height table provides vertical spacing and line
ascent information for the text to be edited with one element for each line of an edit
record. A line number is a direct index into this array. The null style record consists of a
reserved eld and a handle to the style scrap record.
The style scrap record, which is part of the null scrap, stores character attribute
information associated with a null selection to be applied to inserted text. It also holds
character attribute information associated with a selected range of multistyled text when
the character attributes are to be copied, or the text and its attributes are to be cut

or copied.

Part of the style scrap record is the scrap style table which has a separate element for each
style run in the style scrap record. The character attribute information for each of these
elements is stored in a scrap style element record.
Several TextEdit routines use a text style record to pass character attribute information
between the application and the routine.
Figure 2-7 shows the two data structures that TextEdit creates for monostyled text. Figure
2-8 shows the data structures that TextEdit creates for multistyled text and
how they are related; these data structures consist of the two records that TextEdit

also creates for monostyled text plus additional structures needed to store character
attribute information. See Figure 2-15 on page 2-66 for a version of the data structures
including elds.

2-18

About TextEdit

CHAPTER

2

TextEdit

Figure 2-7

Relationship between the TextEdit data structures for monostyled text

Edit record

Dispatch record

hDispatchRec

About TextEdit

|TEDispatchHandle
>

2-19

CHAPTER

2

TextEdit

Figure 2-8

Relationships among the TextEdit data structures for multistyled text

Edit record

Style record

Style table

styleTab
LHHandle 4

STHandle

IhTab

nullStyle

array of

StyleRun

»nullSTHandle

~S
Null style record

Style run table r
STScrpHandle_

nullScrap

Line height table

Style scrap record
>

Dispatch record

Scrap style +
table

hDispatchRec

txFont

txFace

2-20

)TEDispatchHandle

| >

J

(if txSize = —-1)
)TEStyleHandle

i

About TextEdit

(array of
ScrpsTElement) ss

Scrap style element record

CHAPTER

2

TextEdit

Using TextEdit
This section describes how to initialize TextEdit and use the TextEdit routines and data
structures to display text and implement editing features in an application. It also
describes how to customize the behavior of TextEdit, for example, to better suit the

requirements of your application and the script systems it supports.

a (Getting Started With TextEditOdescribes how to display static text in a box, create an
edit record for modi

able text, set the text of an edit record and scroll it, set its

insertion point, and dispose of the edit record.

m CResponding to Events Using TextEditOdescribes how to handle mouse-down,
key-down, and idle events.

= (Moving Text In and Out of Edit RecordsOdescribes how to cut, copy, and paste text
and its character attributes within or across applications, or between an application
and a desk accessory.
m Clext AttributesOdescribes how your application can check the current attributes of a
range of text to determine which ones are consistent across the text. It also describes
how you can manipulate the font, style, size, and color of a range of text.

m (Saving and Restoring a TextEdit Document, and Implementing UndoOdescribes how
to save to disk the contents of a document created using TextEdit, and restore it when
the user opens the document.
m (Customizing TextEditOdescribes how to replace the default end-of-line, drawing,
width-measuring, and hit test hook routines, use the multi-purpose low-memory
global variable TEDOText hook routine, customize word selection and automatic

scrolling, and determine the length of a line of text.

This section includes sample application-de ned routines and code fragments that show
some of the ways you can use TextEdit. These examples are provided for illustrative
purposes only; they are not meant to be used in applications you write.
Note
For both monostyled and multistyled edit records, the text is limited to

32 KB. Whenever you insert or paste text, you need to ensure that adding
the new text does not exceed the 32 KB limit. Your application can check
for this limit before you insert or paste text.

Using TextEdit

2-21

CHAPTER

2

TextEdit

Getting Started With TextEdit
You can use TextEdit to display static text, for example, in a dialog box; the TextEdit
procedure that you use to do this creates its own edit record. You can use TextEdit to
display and manipulate modi able text, for which purpose you must rst create an edit
record. This section discusses these two uses of TextEdit. It describes how you create an
edit record and bring existing text into its text buffer, then set the text selection range or
insertion point, scroll the text, and,

record when you are

nally, release the memory allocated for the edit

nished with it. The topics are described in the following order:

m preparing to use TextEdit
m displaying static text
m creating an edit record
m setting the text of an edit record
m setting the selection range or the insertion point
m scrolling text
m disposing of an edit record

Preparing to Use TextEdit
This section describes two basic tasks that your application needs to perform before using
TextEdit. It must
m

determine the installed version of TextEdit

m initialize other managers and TextEdit
To determine the installed version of TextEdit, you use the Gestalt Manager, which is

fully documented in the chapter (Phe Gestalt ManagerOin Inside Macintosh: Operating
System Utilities.
You can get information about the current version of TextEdit using the Gestalt
function with the Gestalt selector gegstaltTextEditVersion, which returns one of
the values listed and described below. In this list, a new feature is shown only when it is

rst introduced in the software, although it is part of TextEdit in succeeding versions. For
system software version 6.0.4, different patches were made to TextEdit for different
hardware platforms. In these cases, unique values are returned that also identify
the hardware.

2-22

Using TextEdit

CHAPTER

2

TextEdit

Returned value

New features

System software/hardware

gestaltUndefSelectorErr

Multistyled
TextEdit

Systems before 6.0.4/all
hardware

gestaltTE1

System 6.0.4 Roman script
system /IIci-family

hardware
gestaltTE2

New width

measurement hook
Script Manager
compatible

gestaltTE3

System 6.0.4 non-Roman

script system /Ilci-family

hardware

System 6.0.4 non-Roman

script system /all non-IIci
family hardware

gestaltTE4

TEFeatureFlag

System 6.0.5/all
hardware

gestaltTES

Text width

System 7.0/all hardware

measurement hook

You need to initialize other managers and TextEdit before your application calls any
TextEdit routines, including TEInit.

First, you initialize QuickDraw, the Font Manager,

and the Window Manager, and then TextEdit, in that order. To do this, call the following

routines from an initialization procedure that is called from your application@
main routine.
BEGIN

InitGraf

(@thePort)

;

InitFonts;
InitWindows;
InitMenus;
TEInit;

In addition to initializing miscellaneous global variables, such as TEDoText and

TERecal, the TEInit procedure sets up the private scrap and allocates a handle to it.

Note
You should call TEInit even if your application doesn®use TextEdit so
that desk accessories and dialog and alert boxes, which use TextEdit
routines, work correctly.

Using TextEdit

@

2-23

CHAPTER

2

TextEdit

Displaying Static Text
TextEdit provides an easy way for your application to display static text whether or
not it uses other TextEdit features to implement editing services. The TEText Box
procedure displays unchanging text that you cannot edit. You don@create an edit record
because the TEText
Box procedure creates its own edit record, which it deletes when it@
nished with it.
The TEText Box procedure draws the text in a rectangle whose size you specify in the
local coordinates of the current graphics port. You can also specify how text is aligned in
the box. Text can be right aligned, left aligned, or centered.
You can use any of the following constants to specify how text is aligned in the box that
TETextBox creates.
Constant

Description

teFlushDefault

Default alignment according to the primary line direction

teCenter

Center for all scripts

teFlushRight

Right for all scripts

teFlushLeft

Left for all scripts

Listing 2-1 shows how to use TETextBox. The rst parameter is a pointer to the text to
be drawn, which is a Pascal string. Because Pascal strings start with a length byte, you
need to advance the pointer one position past the beginning of the string to point to the
start of the text.
Listing 2-1
str
SetRect

:=

Using TEText
Box
'String

in

a

to draw static text

box';

(r,100,100,200,200);

TEText
Box (POINTER

(ORD

(@str)+1),LENGTH(str),r,teCenter)

;

FrameRect
(r) ;

Creating an Edit Record
To use all other TextEdit routines in your application except the TEText Box procedure,
rst you need to create an edit record. This section discusses how to create an edit record.
It also describes
gm which type of edit record to use, monostyled or multistyled, and why
m™ some ways to store the edit record handle that the function returns when you create an
edit record
mg what to consider when you specify values for the destination and view rectangles
when you create an edit record
m how TextEdit initializes those edit record

elds that are used differently for

monostyled and multistyled edit records, and those that are used the same

2-24

Using TextEdit

CHAPTER

2

TextEdit

The TESt yl eNew function allocates a multistyled edit record which contains text with
character attribute information that can vary from character to character. The TENew
function allocates

a monostyled edit record which contains text in a single font, face, and

size. (Before your application calls either of these functions, the window must be the
current graphics port.)

If your application supports only monostyled text, use TENew to avoid the unnecessary
allocation of additional data structures used to store character attribute information for
multistyled edit records. You can use TEStyl eNew in this case also, although it is not
recommended.
Both TENew and TESty1eNew return a handle to the newly created record. Most TextEdit
routines require you to pass this handle as a parameter, so your application needs to store
it using any of the following methods:
m You can store the edit record handle in a private data structure whose handle is stored
in your application window@ refcon eld.
m

Youcan create a record in which to store information about the window, and include a

eld to store the edit record handle. Listing 2-2 provides an example of this method.

m Youcande nea variable in your application for each edit record handle, and then use
the variable to store the handle.
Listing 2-2 shows a sample document record declaration for an application that handles
text les. The document record is an application-speci c data structure that contains the
handle to the edit record, and any controls for scroll bars.

Listing 2-2

A sample document record

TYPE

MyDocRecHnd
MyDocRecPtr

=
=

MyDocRec

=

“MyDocRecPtr;
“MyDocRec;

RECORD

editRec:
vScrollBar:

TEHandle;
ControlHandle;

{handle to TextEdit record}
{vertical scroll bar}

hScrollBar:

ControlHandle;

{horizontal

scroll

bar}

END;

To associate an application-de ned document record with a particular window, you can
set a handle to that record as the reference constant of the window by using the Window
Manager procedure SetWRefCon. This technique is described further in the chapter
Ontroduction to File ManagementOin Inside Macintosh: Files.
When you create an edit record, you specify the area in which the text is drawn as the
destination rectangle, and the portion of the window in which the text is actually
displayed as the view rectangle.

Using TextEdit

2-25

CHAPTER

2

TextEdit

To ensure that the rst and last characters in each line are legible in a document window,
you can inset the destination rectangle at least four pixels from the left and right edges of
the graphics port (20 pixels from the right edge if the window contains a scroll bar
or size box).

The destination rectangle must always be at least as wide as the rst character drawn.
The view rectangle must not be empty; for example, if you do not want any text visible,
specify a rectangle off the screenN don®make its trailing edge less than its leading edge.
Editing operations may lengthen or shorten the text. The bottom of the destination
rectangle can extend to accommodate the end of the text. In other words, you can think of
the destination rectangle as bottomless. The sides of the destination rectangle determine
the beginning and the end of each line of text, and its top determines the position of the
rst line.
Your program should not have a destination rectangle that is wider than the view
rectangle if you are displaying mixed-directional text. For example, the Dialog Manager
makes the destination rectangle extend twice as far on the right as the view rectangle, so
that horizontal scrolling can be used in normal dialog boxes. When the Arabic script
system is installed, this extension is disabled, because the text may be right aligned, and
therefore out of view. Your application can include the following code to check that the
destination and view rectangles have the same width.
IF

scriptsInstalled
IF

GetEnvirons

>

1

THEN

(smBidirect)<>0

THEN

BEGIN

{make

the

rectangles

the

same

width}

END;

When you create an edit record, TextEdit initializes the record@

elds, based on values in

the current graphics port record and the kind of edit record you create. Although most
edit record elds are initialized similarly for both monostyled and multistyled edit
records, there aresome_

how they are used.

elds that are used differently, and their initial values depend on

For a monostyled edit record that you create by calling TENew, the txSize,
lineHeight,and fontAscent elds of the edit record hold actual values refsecting the
text size, the line height, and the font ascent. Because the text is monostyled, these values

apply to all of the text of the edit record.

m ThetxSize

eld is set to the value of the current graphics port@ text size (txSize)

eld, which indicates that all text is set in a single font, size, and face.

m The value of the lineHeight eldspeci esthe xed vertical distance from the ascent
line of one line of text down to the ascent line of the next. The line height corresponds
to the ascent plus descent for the font and leading to create single-spacing for the lines
in the new edit record.

2-26

Using TextEdit

CHAPTER

2

TextEdit

The value of the fontAscent eldspeci es how far above the base line the pen is
positioned to draw the caret or to highlight the text. For single-spaced text, this is the
ascent of the text in pixels (the height of the tallest characters in the font from the base
line). The font ascent corresponds to the ascent of the font indicated by the txFont
and txSize_ elds of the current graphics port.
Note
To adjust the spacing for a monostyled edit record, you can alter the

values in the

fontAscent and lineHeight

elds of the edit record.

For more information, see the discussion of font measurements in the chapter Font
ManagerOin this book.
For a multistyled edit record, TESt yleNew initializes the txSize,
fontAscent

elds of the edit recordto

1. Avalueof

lineHeight, and

lineachof these

elds means:

txSize

The edit record contains associated character attribute information and the txFont

and txFace

elds combine to contain the text style record handle for the character

attribute information.
lineHeight

The vertical distance from the ascent line of one line of text down to the ascent line of
the next is calculated independently for each line, based on the maximum value for
any individual character attribute on that line. These values are stored in the line
height table (LHTable).
fontAscent

The font ascent is calculated independently for each line, based on the maximum value
for any individual character attribute on that line. These values are stored in the line
height table (LHTable).
For both multistyled and monostyled records, the following
same values:

elds are initially set to the

The record initially contains no text. The text handle (hText) points to a zero-length

block in the heap, and the text length

eld (teLength) of the edit record is set to 0. To

furnish text to be edited, you use the TESet Text procedure if you are incorporating
existing text and the TEKey procedure if the user is entering text.

The value of the just eld determines the alignment of text in the edit record. The
default value is teFlushDefaul1t, indicating that the alignment is to follow the
primary line direction. For languages that are read from left to right, the default value
is left; for languages that are read from right to left, the default value is right. To
change the alignment of text in the record, you use the TESetAlignment procedure.
The selStart and selEnd
the beginning of the text.

elds are initially set to 0; this places the insertion point at

The edit record uses the drawing environment of the graphics port speci ed by the
destRect and viewRect parameters. These parameters contain the local coordinates
of rectangles within the current graphics port, which becomes the graphics port for the
new edit record. The text in the new edit record is to have the characteristics of the
current graphics port.

Using TextEdit

2-27

CHAPTER

2

TextEdit

Listing 2-3 shows the MyAddTE function, which is a sample application-de ned function
that creates a new multistyled edit record for an existing window. The TEStyleNew
function call returns a handle to the edit record that it creates. The code stores the handle
in the docTE variable. The TEAut oVi ew procedure call turns on automatic scrolling for
the newly created edit record. For a complete discussion of scrolling, see the chapter
(Control ManagerOin Inside Macintosh: Macintosh Toolbox Essentials.
Listing 2-3
FUNCTION

Creating a multistyled edit record
MyAddTE

(myWindow:

WindowPtr):

TEHandle;

VAR

destRect,

viewRect:

Rect;

docTE:

TEHandle;

CONST
kMaxDocWidth

=

576;

BEGIN

MyGetTERect

(myWindow,

destRect

viewRect;

:=

destRect.right
docTE
IF

:=

docTE

:=

viewRect);

destRect.left

TEStyleNew(destRect,
<>

NIL

{get
+

TextEdit

rectangle}

kMaxDocWidth;

viewRect) ;

THEN

BEGIN

THAuUtoView

(TRUE,

docTE**.clikLoop

docTE) ;

:= @AsmClikLoop;

END;

MyAddTE

:=

docTE;

END;

Specifying the Destination and View Rectangles
When you create an edit record, whether monostyled or multistyled, you specify the area
in which the text is drawn as the destination rectangle, and the portion of the window in
which the text is actually displayed as the view rectangle.
To ensure that the rst and last glyphs in each line are legible in a document window, you
can inset the destination rectangle at least four pixels from the left and right edges of the
graphics port (20 pixels from the right edge if the window contains a scroll bar
or size box).

The destination rectangle must always be at least as wide as the rst glyph drawn. The
view rectangle must not be empty; for example, if you do not want any text visible,
specify a rectangle off the screenN don®make its trailing edge less than its leading edge.

2-28

Using TextEdit

CHAPTER

2

TextEdit

Editing operations may lengthen or shorten the text. The bottom of the destination
rectangle can extend to accommodate the end of the text. In other words, you can think of
the destination rectangle as bottomless. The sides of the destination rectangle determine
the beginning and the end of each line of text, and its top determines the position of the
rst line.
Your program should not have a destination rectangle that is wider than the view
rectangle if you are displaying mixed-directional text. For example, the Dialog Manager
makes the destination rectangle extend twice as far on the right as the view rectangle, so
that horizontal scrolling can be used in normal dialog boxes. When the Arabic script
system is installed, this extension is disabled, because the text may be right aligned, and
therefore out of view. Your application can include the following code to check that the
destination and view rectangles have the same width.
IF

scriptsInstalled
IF

GetEnvirons

>

1

THEN

(smBidirect)<>0

THEN

BEGIN

{make

the

rectangles

the

same

width}

END;

Setting the Text of an Edit Record
When you create an edit record, it doesn®contain any text until either the user enters text
through the keyboard or opens an existing document. This section describes how to
specify existing text to be edited. OAccepting Text Input Through Key-Down EventsOon
page 2-36 discusses how to insert text that the user enters through the keyboard.
When a user opens a document, your application can bring the document@ text into the
text buffer of an edit record by calling TESet Text. If the text has associated character
attribute information, your application also needs to manage it.
There are two ways to specify existing text to be edited. The easier method is to use
TESet Text, which creates a copy of the text and stores the copy in the existing handle of
the edit record@ hText eld. One of the parameters that you pass to TESet Text
speci es the length of the text. The TESet Text procedure resets the teLength eld of
the edit record with this value and uses it to determine the end of the text; it sets the

selStart and selEnd elds to the last byte offset of the text so that the insertion point
is positioned at the end of the displayed text. The TESet Text procedure calculates line
breaks, eliminating the need for your application to do this.
You can use the second method to save space if you have a lot of text. Using this method,
you can bring text into an edit record by directly changing the hText eld of the edit
record, replacing the existing handle with the handle of the new text. When you do this
for a monostyled edit record, you need to modify the teLength eld to specify the
length of the new text, and then call TECal Text to recalculate the lineStarts array
and nLines values to match the new text.

Using TextEdit

2-29

CHAPTER

2

TextEdit

Using the second method is somewhat more complicated for multistyled text because
TECalText does not update the style run table (St
yleRun) properly. To compensate for
this, your application needs to perform the following tasks:
m Before changing the edit record@hText

eld, reduce the style run table to one entry.

Do this by setting the edit record@ selStart
then call
m

TESet Style.

eld to0andits selEnd

Before calling TECalText, set the start character (startChar)

table to the length of the new text plus one, that is:
TEStyleRec.runs[1]

to

length

eld to 32767,

eld of the style run

(hText)+1

Using the same edit record for different pieces of text
Rather than allocate a new edit record for each piece of text you want to
edit, you can use the same record to edit different pieces of text. For
example, you can create an edit record and either accept user input or
call TESet Text to incorporate existing text. If you know that you
want to edit the text again whose handle is currently stored in the hText
eld, rst you need to save the text before you call TESet Text, because
TESet Text

necessary. @

uses the same handle, resizing it for the new text, if

The TESet Text procedure doesn@affect the text drawn in the destination rectangle, so
call the Window Manager@ InvalRect procedure afterward, if necessary. For more
information about the InvalRect procedure, see the chapter ONindow ManagerOin
Inside Macintosh: Macintosh Toolbox Essentials.

Setting the Selection Range or the Insertion Point
You can use the TESet Select procedure to specify the selection range or the position of
the insertion point as determined by the application. For example, you can use
TESetSelect to highlight an initial default value in an application such as an online
data-entry form, or to position the caret at the start of the eld where you want the user
to enter a value. You can also use it to implement a Select All menu command.
You can set the selection range (or insertion point) to any character positions within
the text of the edit record corresponding to byte offsets 0 through 32767. To select a range
of text, you pass TESet Select the handle to the edit record along with the byte offsets
corresponding to the beginning and the ending characters of the text to be highlighted.
The TESetSelect procedure modi es the selStart and selEnd elds of the
edit record.
To display a caret at an insertion point, specify the same value for both the selStart
and selEnd parameters. To encompass the edit record@ entire text block as the selection
range, specify 0 as the value of sel Start and 32767 as the value of selEnd. You can
implement a Select All menu command by specifying the edit record@ entire range of
text, as shown in the following code fragment, by using the teLength eld.
iSelectAll:

TESetSelect
(0, myTERec**.teLength,

2-30

Using TextEdit

myTERec) ;

CHAPTER

2

TextEdit

Scrolling Text
Using TextEdit routines, your application can allow the user to control text scrolling
through the scroll bars; in this case, you scroll the text by calling a TextEdit procedure. It
can also automatically scroll the text of an edit record into view when the user clicks in
the view rectangle, and then drags the mouse outside of it, if you enable automatic
scrolling through another TextEdit procedure.
To scroll the text when a mouse-down event occurs in a scroll bar, your application needs
to determine how far to scroll the text. For example, to vertically scroll the text of a
monostyled edit record, you can use the lineHeight eld of the edit record to calculate
the number of pixels to scroll; you multiply every click in the scroll bar by the number of
pixels in the lineHeight eld and by the number of lines displayed in the view
rectangle. For multistyled text, you need to use the value of the LhHeight eld of the
line height table for each line in the view rectangle because line height can vary from line
to line.
To scroll the text, you call either TEScroll or TEPinScrol11 specifying the number of
pixels to scroll. The only difference between TEScroll1 and TEPinScro11 is that
TEPinScrol11 stops scrolling when the last line is scrolled into the view rectangle.
When the user clicks in the scroll arrow pointing down, you scroll the text up. When the
user clicks in the scroll arrow pointing up, you scroll the text down. Passing a positive
value to either routine moves the text right and down, passing a negative value moves
the text left and up. The destination rectangle is offset by the amount you scroll. For
example, the following call scrolls the text of a monostyled edit record up one line.
TEScroll(0,

-hTE**.lineHeight,

hTE)

There are two ways to enable or disable automatic scrolling for an edit record. You can
use the TEAut oView procedure or the teFAutoScrol11 feature of the TEFeatureFlag
function. However, neither of these routines actually scrolls the text. To ensure that the
selection range is always visible, your application should call TESe1 View. When
automatic scrolling is turned on, TESe1View scrolls the selection range into view,

if necessary.

Listing 2-3 on page 2-28 creates a multistyled edit record and turns on automatic scrolling
for it. It saves the address of the default click loop procedure installed in the edit record@
clikLoop eld, then replaces it with the address of its own customized click loop
routine.
The clikLoop eld of the edit record contains the address of a click loop procedure that
is called continuously as long as the mouse button is held down. When automatic
scrolling is turned on, the default click loop routine determines if the mouse has been
dragged out of the view rectangle; if it has, the default click routine scrolls the text using
TEPinScroll1. For example, if the user clicks in the text and drags the mouse outside of
it to the right, the text is automatically scrolled left.

How much the text is scrolled vertically is determined by the lineHeight eld of the
edit record for a monostyled edit record and by the lhHeight eld of the line height
table for a multistyled edit record.

Using TextEdit

2-31

CHAPTER

2

TextEdit

Scroll bars are not scrolled automatically with the text if the default click loop routine is
used. However, you can replace the default click loop routine with a routine that updates
scroll bars. For more information about customizing scrolling, see CCustomizing
Automatic ScrollingOon page 2-61. For a complete discussion of scrolling, see the chapter
Control ManagerOin Inside Macintosh: Macintosh Toolbox Essentials.

Disposing of an Edit Record
When your application is completely nished with an edit record, you should release any
memory allocated for it by calling TEDispose. To continue to refer to the text once
youQe destroyed the edit record, use the Operating System Utilities HandToHand
function before you call TEDispose. It copies the text (whose handle is stored in the edit
record@ hText eld), and returns a new handle to it. (See Inside Macintosh: Operating
System Utilities for more information.) For a multistyled edit record, you also need to save
the character attribute information. If your program retains the original handle to the text
stored in the hText

eld after you call TEDispose, the handle becomes invalid because

the text is removedN the memory used for it is deallocated.

Responding to Events Using TextEdit
This section discusses some of the TextEdit routines that your application can call in
response to event noti cation. You can use TextEdit routines to
m handle idle processing in response to null events (TEIdle)
m identify the active edit record in response to an activate event (TEActivate and
TEDeactivate)

m

handle mouse-down events (TEC1Lick)

m update the destination rectangle in response to an update event (TEUpdate)
m

handle key-down events (TEKey)

Handling a Null Event
Your program needs to call TEIdle whenever it receives a null event. If there is more
than one edit record associated with an active window, make sure you pass TEI dle the
handle to the currently active edit record. (See OActivating an Edit RecordOin the
following section for more information.)

If you have turned on text buffering through the TEFeatureFlag function, you should
call TEI dle before any pause of more than a few ticksN for example, before
WaitNextEvent. A possibility of a long delay before characters appear on the screen
existsN especially in non-Roman systems. Blinking the caret alerts the user to this delay.
To blink the caret at a constant frequency, you should call TEId1le at least once through
your main event loopN otherwise, the caret blinks irregularly. No matter how often you
call TEId1e, the time between blinks is never to be less than the minimum interval.

2-32

Using TextEdit

CHAPTER

2

TextEdit

Listing 2-4 shows a sample application-de
to handle a null event.
Listing 2-4

ned procedure, MyDoId1e, that calls TEIdle

An idle-processing procedure

PROCEDURE

MyDoIdle(myWindow:

WindowPtr) ;

VAR

myData:
myTERec:

MyDocRecHnd
TEHandle;

;

{handle
{handle

to
to

a document record}
TextEdit record}

BEGIN

myData

:=

IF

<>

myData

MyDocRecHnd
NIL

(GetWRefCon

(myWindow)

) ;

THEN

BEGIN

myTERec
IF

:= myData**.editRec;

myTERec

<>

NIL

THEN

TEI dle (myTERec);

END ;
END ;

Note
The value stored in the low-memory global Caret Time determines the
blinking time for the caret. (The user can also set the minimum interval
through the General Controls control panel.) You can use the Event
Manager@ Get Caret Time function to retrieve this value. For more
information, see the chapter (The Event ManagerOin Inside Macintosh:

Macintosh Toolbox Essentials.

Activating an Edit Record
When a window becomes active or inactive, the Window Manager updates the frames of
the windows on the screen, and then informs the Event Manager that an activate event
has occurred. The next time WaitNextEvent is called from your main event loop, the
Event Manager noti es your application that an activate event has occurred. (An activate
event can have a fag set indicating that a window is to be deactivated.) When your
application receives this noti cation, it needs to call TEActivate for an activate event
and TEDeactivate for a deactivate event. When you call TEActivate, you pass it the
handle to the edit record to be activated; when you call TEDeactivate, you pass it the
handle to the currently active edit record.
An application can have more than one edit record associated with it. The active edit
record is the one where the next editing operation is to take place. The TEActivate
procedure identi es an edit record as the active one by either highlighting the selection
range or displaying a caret at the insertion point. The TEDeact ivate procedure changes
an edit record@ status from active to inactive and removes the highlighting or the caret. If
outline highlighting is on, TEDeact ivate frames the selection range or displays a
dimmed caret.

Using TextEdit

2-33

CHAPTER

2

TextEdit

Note
The TEActivate procedure does not set the selection range; it uses the
current values in the selStart and selEnd elds of the edit record
to highlight the speci ed text or display a caret at the insertion point. The
TEDeactivate procedure does not affect the current settings of these
elds. @
Before you can activate an edit record, you need to deactivate the currently active edit
record, if there is one. If your application has a routine which it calls to activate and
deactivate its own windows, you can include processing in that routine to make an edit
record the active one or make the currently active record inactive. Because deactivate
events happen before activate events, these events occur in the proper order when the
user switches from one window to another.
If there is more than one edit record associated with a window, you@ probably want to
call TEDeactivate whenever the mouse button is clicked in an edit record other than
the active one. In this case, each TEDeactivate call not associated with a window

deactivate event would be coupled with a call to TEActivate.

You can modify the text of an edit record associated with a background window;
however, to do so, you need to call TEAct ivate for that edit record before you call any
other TextEdit routines.
Note
When you use TEClick and TESet Select to set the selection range or
insertion point, the selection range is not highlighted nor is a blinking
caret displayed at the insertion point until the edit record is activated
through TEActivate. However, if you had already turned on outline
highlighting (through the TEFeatureFlag function), the text of the
selection range is framed or a gray, unblinking caret is displayed at the
insertion point.

Handling Mouse-Down Events
When your application receives noti cation of a mouse-down event that it determines
TextEdit should handle, it needs to pass the click on to the TEClick procedure. Before
calling TEClick, your application needs to perform the following steps:
1. Convert the mouse location that is passed in the event record from global to local
coordinates, so that it can pass those local coordinates to TEClick. To perform the
conversion, you can use the Global ToLocal QuickDraw procedure. (For more
information, see Inside Macintosh: Imaging.)
2. Determine if the Shift key was held down at the time of the click to extend the
selection. The behavior of TEClick depends on the user@ actions.
O If the Shift key was down, TEClick extends the current selection range.
O

2-34

If the Shift key was not held down, TEClick removes highlighting of the current

selection range and positions the insertion point as close as possible to the location
where the mouse click occurred.

Using TextEdit

CHAPTER

2

TextEdit

11 When the mouse is moved or dragged, TEClick expands or shortens the selection
range a character at a time. The TEClick procedure keeps control until the user
releases the mouse button.
OO If the mouse button is clicked twice (a double-click), TECLick extends the selection

to include the entire word where the cursor is positioned.

Note

As long as the mouse button is held down, TEC1lick repeatedly calls
the click loop routine pointed to from the clikLoop eld of the
edit record. @
Listing 2-5 shows an application-de

ned procedure, MyDoContentClick, that calls

TEClick, passing it a mouse-down event.

Listing 2-5
PROCEDURE

Passing a mouse-down event to TextEdit

MyDoContentClick

(myWindow:

WindowPtr;

event:

EventRecord) ;

VAR

myData:
myTERec:

MyDocRecHnd;
TEHandle;

mouse:

Point;

{handle
{handle

to
to

a document record}
TextEdit record}

BEGIN

myData

=

MyDocRecHnd

IF

=

NIL

myData

exit

{get

window’s

{get

TERec}

data

record}

(MyDoContentClick) ;

myTERec
IF

(GetWrefCon(myWindow));

THEN

:= myData**.editRec;

myTERec

=

NIL

THEN

exit (MyDoContentClick) ;
SetPort

mouse

(myWindow)

:=

GlobalToLocal

IF

;

event.where;

PtInRect

(mouse)

(mouse,

{get
;

the

{convert

myTERec**.viewRect)

click
to

position}

local

coordinates}

THEN

BEGIN
shiftDown

:=

BAnd

(event.modifiers,

{extend
TEClick

(mouse,

shiftDown,

if

shiftKey)

Shift

is

<>

0;

down}

myTERec) ;

END;
END;

When TEC1lick is called, the clickTime

eld of the edit record contains the time when

TEClick was last called. When TEClick returns, it sets the clickTime
the current tick count. The default click loop procedure uses this value.

Using TextEdit

eld, adjusting

2-35

CHAPTER

2

TextEdit

Responding to an Update Event
After changing any elds of the edit record that affect the appearance of the text or after
any editing or scrolling operation that alters the onscreen appearance of the text, you
need to call TEUpdate.

Your application needs to call TEUpdate every time the Event Manager function
WaitNextEvent reports an update event for a text editing windowN after you call the
Window Manager procedure BeginUpdate, and before you call the EndUpdate

procedure. You call the following routines when an update event occurs:
BeginUpdate

(myWindow)

;

EraseRect (myWindow™.portRect)
TEUpdate (myWindow*.portRect,
EndUpdate

(myWindow)

;
hTE) ;

;

If you don@include the EraseRect procedure, the caret may sometimes remain visible
when the window is deactivated. For more information about responding to events, see
the chapter Event ManagerOin Inside Macintosh: Macintosh Toolbox Essentials. For more
information about the Window Manager, see the chapter ONindow ManagerOin Inside
Macintosh: Macintosh Toolbox Essentials.

Accepting Text Inout Through Key-Down Events
When the user enters text through the keyboard, your application needs to call the TEKey
procedure to accept the keyboard input a byte at a time or to delete a character when the
user backspaces over it. Call TEKey every time the Event Manager function
WaitNextEvent reports a key-down event that your application determines TextEdit
should handle.
Because TEKey accepts every character it is passed, your application needs to rst_ Iter
out Command-key equivalents, special keys, and nonprinting characters as appropriate,
such as Enter or Tab, and only pass TEKey a text, a Return key character, an arrow key
character, or a backspace key character.
Note
If you want to display the text as multiple paragraphs, don@®
Return key characters. @

Iter out

Listing 2-6 shows the MyHandleKeyDown procedure which calls TEKey to
accept text a character at a time. First MyHandleKeyDown
lters out special characters.

For example, it treats the Tab key as a special character, and calls an application-de ned
routine, MyDoTab, to handle this character appropriately for the document. Then it
checks to make sure that inserting the character won®exceed the maximum text length
allowed. It does not count the Delete or arrow keys because they are not text characters.
If the maximum text length is not exceeded, the code passes the character to TEKey.
Otherwise, it calls an application-de ned routine, MyAlertUser, to notify the user that
the character is not inserted, and that inserting it would exceed the edit record text

2-36

Using TextEdit

CHA

PTER

2

TextEdit

limitation. In this example listing, the maximum text length is set to the highest possible
value; you can specify a lower limit.
Listin g

PROCEDURE

2-6

Inserting text in a document

MyHandleKeyDown

(myWindow:

WindowPtr;

event:

EventRecord) ;

CONST
kMaxTELength
kTab

=

$09;

kDel

=

$08;

=

kRightArrow

=

32767;

$1D;

kLeftArrow

=

S1C;

kDownArrow

=

S1F;

kUpArrow

=

$ 1E;

VAR

myData:

MyDocRecHnd;

myTERec:

TEHandle;

key:

CHAR ;

{handle
{handle

to
to

a document record}
TextEdit record}

BEGIN

myData
IF

MyDocRecHnd

=

myData
exit

NIL

(GetWRefCon

(myWindow)

) ;

{get

window’s

{get

TERec}

data

record}

THEN

(MyDo ContentClick) ;

myTERec
:= myData~*.editRec;
IF myTERec = NIL THEN
exit

(MyDo ContentClick) ;

key

:=

CHR

IF

key

=

(BAnd

(event

char(kTab)

.message,

THEN

charCodeMask));

{handle

special

characters}

MyDoTab(e vent)
ELSE
BEGIN

(ke y

IF

= CHR(kDel))

|

(key

=

CHR(kRightArrow) )

|

(key = CHR (kUpArrow))
|
{don’t count deletes or arrow
(LongInt (myTERec**.teLength - MyGetTESelLength(myTERec)
(key
(key

=

CHR

(kLeftArrow) )

CHR

(kDownArrow) )

keys}
+ 1 <

kMaxT ELength)
THEN
BEG IN

TEKey

(key,

myTERec);

MyAdjustScrollbars

{insert

(window,

character

in

document}

FALSE) ;

END
ELSE

Using TextEdit

2-37

CHAPTER

2

TextEdit

MyAlertUser

(eExceedChar) ;

END;
END;

Before testing to ensure that the input character does not exceed the edit record@ text
limitation, the code subtracts the length of the selection range, which the inserted
character is to replace, from the current length of the text. To get the length of the
selection range, the code calls an application-de ned function, MyGet TESel Length.
Listing 2-7 shows this function. Several other sample application-de ned routines in this
chapter also call this function.
Listing 2-7
FUNCTION

Getting the selection range length
MyGetTESelLength

(myTERec:

TEHandle):

Integer;

Begin

MyGetTESelLength

:= myTERec*

A

.selEnd

- myTERec**.selStart;
A

END;

If the selection range is an insertion point and the key is not an arrow key character or a
Backspace key character, TEKey inserts the character before the insertion point. When the
character direction is right-to-left, the character is inserted to the right of the insertion
point. When the character direction is left-to-right, the character is inserted to the left of

the insertion point.

When you call TEKey and the keyboard script is different from the font script, TextEdit
changes the font script to correspond to the keyboard script. If the font at the insertion
point is the same as the keyboard script, then this font is used. If a font was written to the
TextEdit style scrap record (in the null scrap) and never used and that font script
coincides with the keyboard script, then it is used. Otherwise, TextEdit searches through

the fonts in the style table until it locates a font that corresponds to the keyboard. If one
does not exist, then it uses the application font.

When the user backspaces over characters of a multistyled edit record, TEKey deletes the
characters but it saves the character attributes associated with the last character deleted
in order to apply it to any new characters that the user might enter; the character
attributes are saved in the null scrap@ style scrap record. As soon as the user clicks in
another area of the text, TEKey clears the attributes from the null scrap.

Moving Text In and Out of Edit Records
This section describes how to cut, copy, and paste text, and insert and delete it. Because

TextEdit manages the varying character attribute information associated with multistyled
text, you use separate routines for monostyled and multistyled text
to perform some of these tasks; this section explains those differences. If your
application supports both monostyled and multistyled text, you need to handle these
cases separately.

2-38

Using TextEdit

CHAPTER

2

TextEdit

Using TextEdit to Cut, Copy, and Paste Text
You can use TextEdit to cut, copy, and paste text within a single edit record, between edit
records, or across applications, and to handle menu commands that let the user perform
these actions. You use the TECut and TECopy procedures to cut and copy both
monostyled and multistyled text. To paste monostyled text, you use the TEPaste
procedure. To paste multistyled text, you use the TEStylePaste procedure. To move
monostyled text across applications or between an application and a desk accessory, you
use the TEFromScrap and TEToScrap functions. This section describes how to use

these routines and what they do.
Note
This section and those that follow do not describe how to create menus
and their commands. For guidelines and a complete discussion of how to
create and manage the menus in your application, see the chapter
he
Menu ManagerOin Inside Macintosh: Macintosh Toolbox Essentials.
The TECut procedure removes and transfers the selected text. The TECopy procedure

copies the selected text, leaving the original text intact. To implement cut-and-paste
or copy-and-paste services, you can couple either of these calls with TEPaste or
TEStylePaste to overlay a text selection or insert the text to be pasted at an
insertion point.

To cut, copy, and paste text within the same edit record or between two edit records
within the same application, you do not need to write the text to and from the desk scrap,
although this is always done automatically for multistyled text. However, to carry text
across applications or between an application and a desk accessory, whether the text is
multistyled or monostyled, you must write it to and from the desk scrap.
For monostyled text, TECut and TECopy write the text to the private scrap only. The
TEPaste procedure pastes the monostyled text from the private scrap to the edit record.
To determine the length of the text to be pasted, you can call the TEGet ScrapLength
function which returns the size in bytes of the text in the private scrap, or you can check
the value of the global variable TEScrapLength.

To move monostyled text across applications or between an application and a desk
accessory, you need to use the TEFromScrap and TEToScrap functions, which write
text to and from the desk scrap.
For multistyled text, TECut and TECopy always write both the text and its associated

character attribute information to the Scrap Manager@ desk scrap under scrap types
'TEXT! and 'sty1'. For more information, see the chapter Scrap ManagerOin Inside
Macintosh: More Macintosh Toolbox.
The TEStylePaste procedure reads both the text and its attributes back from the desk
scrap and writes the multistyled text into the edit record@ text buffer at the current
selection range or insertion point.

Using TextEdit

2-39

CHAPTER

2

TextEdit

You can use these procedures to move multistyled text across two applications or
between an application and a desk accessory; you don@need to call TEFromScrap and
TEToScrap for multistyled text. To either copy or move the text selection from the text
buffer to the desk scrap, TECut and TECopy write the text to the private scrap and to the
Scrap Manager@ desk scrap. To copy or move the attributes along with the text, TECut
and TECopy write the character attribute information stored in the style table to both the

style scrap and the Scrap Manager@ desk scrap. Figure 2-9 shows what happens when
you cut multistyled text using TECut.
Figure 2-9

Cutting text from a multistyled edit record

Before TECut | The exception Bjjmag probes the rule;
it does not prove it.

TextEdit
private scrap

TextEdit
style scrap

After TECut | The exception probes the rule;
it does not prove it.
often

Times

12 point, italic

TextEdit
private scrap

TextEdit
style scrap

‘TEXT '!

'styl'

often

Times

12 point, italic

Scrap Manager’s desk scrap

The TEStylePaste procedure either pastes the text from the desk scrap at the insertion
point or replaces the current selection range with the text to be pasted. Along with the
text, TESt ylePaste writes the character attribute information to the style record@ style
table and applies it to the inserted text.
For multistyled text, text is pasted from the desk scrap. Therefore, before you call
TEStylePaste, use the Scrap Manager@ Get Scrap procedure to check the size of the
text ('TEXT'

2-40

Using TextEdit

data) to be pasted.

CHAPTER

2

TextEdit

To calculate the amount of memory required for the style scrap before you cut or copy
multistyled text, you can use the information returned by the TENumStyles function.
This function returns the number of attribute changes contained in a range of text. Since
the style scrap is linear in structure, with one element for each attribute change, you can
multiply the number returned by TENumStyles by SizeOf (ScrpSTElement) and
add 2 to get the number of bytes needed.
Listing 2-8 shows a sample application-de ned procedure that handles cut, copy, and
paste menu commands. Before the application pastes the multistyled text into the edit
record@ text at the current selection range, it calls the Scrap Manager@ Get Scrap
function to get the size of the text to be pasted. The code adds the returned value to
the size of the text in the edit record, subtracts the size of the selection range, then

compares the result against the maximum length of the edit record text to make sure that
pasting the text won@exceed it. (To get the selection range length, the code calls the
application-de ned function MyGet
TESel Length, as shown in Listing 2-7 on page 2-38.)
To avoid copying the data when you want only the length of the text returned, pass a
value of NIL for the hDest parameter to Get Scrap. For more information about
Get Scrap, see the chapter crap ManagerOin Inside Macintosh: More Macintosh Toolbox.
Listing 2-8
PROCEDURE

Handling Cut, Copy, and Paste commands

MyHandleEditMenu

(myWindow:

WindowPtr;

on an Edit menu

menuItem:

Integer) ;

CONST
kMaxTELength
kTESlop

=

=

32000;

1024;

{kTESlop

provides

some

extra

security

when

preflighting

edit

commands. }

VAR

myData:
myTERec:

MyDocRecHnd
TEHandle;

myErr:

OSErr;

offset:

LONGINT;

aHandle:

;

{handle
{handle

to
to

a document record}
TextEdit record}

Handle;

oldSize,

newSize:

LONGINT;

SaveErr:

OSErr;

BEGIN

myData

:=

MyDocRecHnd

IF

=

NIL

myData
exit

:= myData**.editRec;

myTERec

Exit
CASE

{get

window’s

{get

TERec}

data

record}

(MyDoContentClick) ;

myTERec
IF

(GetWrefCon(myWindow));

THEN

=

NIL

THEN

(MyDoContentClick) ;

menuitem

OF

iCut:

Using TextEdit

2-41

CHAPTER

2

TextEdit

BEGIN

IF

ZeroScrap

=

nokrr

THEN

BEGIN

PurgeSpace
IF

(total,

contig);

MyGetTESelLength(myTERec)

contig

+

kTESlop

>

THEN

MyAlertUser

(eNoSpaceCut

)

ELSE

TECut

(myTERec)

;

END;
END;

iCopy:
BEGIN

IF

ZeroScrap

TECopy

=

nokrr

(myTERec)

THEN

;

END;

iPaste:
BEGIN

IF

GetScrap(NIL,

'TEXT',

(myTERec**.teLength

offset)

+

- MyGetTESelLength(myTERec))

kMaxTELength
THEN

MyAlertUser

(eExceedPaste)

ELSE
BEGIN

aHandle

:=

Handle

(TEGetText

oldSize

:=

GetHandleSize(aHandle) ;

oldSize

newSize

+

GetScrap

SetHandleSize(aHandle,

{see

if

handle

saveErr

:=

MemError;

can

saveErr

<>

MyAlertUser

nokErr

resized}

oldSize);

THEN

(eNoSpacePaste)

ELSE

TEStylePaste
END;
END;
END;
END;

2-42

Using TextEdit

+

newSize);

be

SetHandleSize(aHandle,
IF

(myTERec)

(myTERec)

;

) ;

kTESlop

>

CHAPTER

2

TextEdit

Inserting and Deleting Text
You can use TextEdit routines to delete and insert text. You use TEInsert to insert
monostyled text into the edit record@ text buffer if the current selection range is an
insertion point. If the current selection range is a range of text, TEInsert replaces it with
the text to be inserted. You use TEStyleInsert to insert multistyled text in
the same way; however, the text and its associated character attribute information
are inserted.
To delete text, your application calls the same routine whether the text is multistyled or
monostyled. The TEDelete procedure removes the text of the current selection range.
When the text is multistyled, TEDelete saves the character attributes in the null scrap to

be applied to characters that the user might enter following the deletion. After each
editing procedure, TextEdit redraws the text if necessary from the insertion point to the
end of the text.

You can handle a Clear command using TEDelete; you call TEDelete with the handle
to the edit record containing the text you want to eliminate. The TEDelete procedure
removes the selected text without transferring it to the scrap.
iClear:

TEDelete

(myTEREec) ;

Text Attributes
This section describes how your application can check the current attributes of a range of
text to determine which ones are consistent across the text. It also describes how you can
manipulate the font, style, size, and color of a range of text; the text selection can consist
of a segment of text, the entire text of the edit record, a single character, or even an
insertion point.
You use the TECont inuousSty1e function to determine the current attributes for a

range of text, and you use the TESet Style procedure to change them. You can change
character attributes singly, collectively, or in any combination using TESet Style. For
example, you can change the font style to bold or italic, and you can underline, outline,
or shadow the selected text. You can increase or decrease the type size incrementally, or
change the color in which the text is displayed. You use the TESetAlignment procedure
to change the alignment of the entire text of an edit record.
This section describes these tasks in this order:
m checking the text attributes across a selection range
m toggling an attribute
m handling a font menu that lets the user change the font family
m handling a font size menu that lets the user change the text size
m handling a style menu that lets the user change the style of the text
changing the text alignment

Using TextEdit

2-43

CHAPTER

2

TextEdit

Some general information about TESet Style that applies to many of the tasks for which
you can use it is discussed here. If you call TESet Style for an insertion point, TextEdit
stores the input character attribute information in the null scrap@ style scrap record. If
the user then enters text (pastes without attributes, inserts, or types it), the attributes are
written to the style record and applied to that text.
There are many ways in which you can use TESet Style to handle menu commands
that let the user modify text attributes. If your application allows a user to change any or
all the text attributes from a single format menu before redrawing the text, you can make
one call to TESet Style specifying the particular attributes to be changed. If your
application provides separate menus to let a user manipulate different aspects of the text,
you can make separate calls to TESet Style specifying the discrete text attribute to be
changed.
Note
A. eld in the text style record is only valid if the corresponding bit is set
in the mode parameter; otherwise, the
information. #

eld contains invalid

The value of mode speci es which existing character attributes are to be changed to the
new character attributes speci ed by newStyle.
Constant

Value

doFont

1

Sets the font family ID

Description

doFace

2

Sets the character style

doSize

4

Sets the type size

doColor

8

Sets the color

doAll

15

Sets all attributes

addSize

16

Increases or decreases the type size

doToggle

32

Modi

es the mode

Checking the Text Attributes Across a Selection Range
When a particular attribute is set for an entire selection range, that attribute is said to be

continuous over the selection. For example, in the selected text in Figure 2-10, the bold
attribute is continuous over the selection range and italic is not.
Figure 2-10

Continuous attributes over a selection range

“Take each man’s censure,

but reserve thy judgement.”
u

y)
Bold, 16 point Times

2-44

Using TextEdit

CHAPTER

2

TextEdit

To determine the actual values for continuous attributes, you can use the
TECont inuousStyle function. This function takes two variable parameters: mode and
aStyle. For its input value, mode speci es the attributes to be checked; for its output
value, mode speci es those attributes that are continuous over the selection range. For the
input value of aStyle, you pass a pointer to a text style record (of type Text Style); for
those attributes that are continuous, the text style record
when TEContinuousStyle
returns.

A.

elds contain the actual values

eld in the text style record is only valid if the corresponding bit is set in the mode

parameter; otherwise, the

eld contains invalid information. Possible values for the

TECont inuousStyle mode parameter are de ned by the following constants.
Constant

Value

Description

doFont

1

Speci

es the font family

doFace

2

Speci

es the character
style

doSize

4

Speci

es the type size

doColor

8

Speci
es the color

doAll

15

Speci

number

es all the attributes

Listing 2-9 illustrates how to use the TECont inuousSty1e function to determine the
font, style, size, and color of the current selection range. The code sets the mode

parameter. Then it calls TECont inuousStyl]e, passing it the text style record. When
TECont inuousStyle returns, it checks each bit of the mode parameter to see which
attributes are continuous across the selection.

Listing 2-9

Determining the font, style, size, and color of the current selection range

PROCEDURE

MyGetCurrentSelection
VAR

continuous:

myTERec:

(VAR

Boolean;

mode:

VAR

Integer;

astyle:

TextStyle;

TEHandle) ;

BEGIN

mode

:=

doFont

continuous
IF

+

:=

doFace

+

doSize

+

doColor;

TEContinuousStyle(mode,

BitAnd(mode,

doFont)

<>

0

aStyle,

myTERec) ;

THEN

{font

for

selection

=

aStyle.tsFont}

{more

than

one

in

selection};

ELSE

IF

BitAnd(mode,

font

doFace)

<>

0

THEN

{aStyle.tsFace contains the text
{ are common to the selection. }

faces

(or

plain)

that

}

ELSE

{No
IF

text

face

BitAnd(mode,

{size

Using TextEdit

for

is

common

doSize)

selection

<>

to

the

0

THEN

entire

selection.};

= aStyle.tsSize}

2-45

CHAPTER

2

TextEdit

ELSE

{more
IF

than

one

BitAnd(mode,

size

in

doColor)

selection};
<>

0

THEN

{color

for

selection

= aStyle.tsColor}

{more

than

one

in

ELSE

color

selection}

END;

Toggling an Attribute
Once you know what attributes are continuous across a selection range, you can use

TESet Style

to toggle an attribute on and off. For example, if you specify a mode

parameter for

TESet Style

that includes both doToggle and doFace, and an attribute

that has been set in the tsFace

eld of the text style record exists across the current

selection range, then TESet Style removes that attribute. However, if the attribute isn@®
continuous over the current selection, then all of the selected text is set to include it.

For example, in the selected text shown in Figure 2-11, the bold style is continuous over
the selection range and the italic style is not.
Figure 2-11

An initial selection before

TESet Sty1e

is called

“This, above all: to thine own self be true,
And it must follow, as the night the day,

Thou can not be false to any man.”
\

JAX

Bold

If you call

1

aN

Bold
italic

y)

Bold

TESet Style with a mode of doFace + doToggle and a text style record

parameter with its tsFace
shown in Figure 2-12.
Figure 2-12

eld set to bold, the resulting selection is no longer bold, as

The result of calling

TESet Style

to toggle to bold

“This, above all: to thine own self be true,

And it must follow, as the night the day,

Thou can not be false to any man.”
u

1

Plain

2-46

Using TextEdit

/

UY

uU__/

lialic

Plain

CHAPTER

2

TextEdit

On the other hand, if instead you call TESet Style with a mode of doFace + doToggle
and a text style record withits tsFace
eld set to italic, the resulting selection is all

bold italic as shown in Figure 2-13.
Figure 2-13

The result of calling

TESet Style

to toggle italics

“This, above all: to thine own self be true,
And it must follow, as the night the day,

Thou can not be false to any man.”

\

1

J

Bold
italic

Handling a Font Menu
You can use TESet Style to handle a Font menu that allows the user to change the font
family for a text selection. The user might select the entire text of an edit record ora
portion of it, then choose a different font family from your menu to be used to render the
text. Listing 2-10 shows how to handle a Font menu that allows the user to do this. The
code determines which font the user has selected from the menu. Next, it calls the Font

Manager@ Get FNum procedure to get the font family ID for the font of the selected text.
Then it calls TESet Style passing it the text style record with the tsFont eld set to the
font ID. Because the redraw parameter is set to TRUE, the current selection range is
redrawn immediately in the new font.
Listing 2-10
PROCEDURE

Handling the Font menu

MyHandleFontMenu

(myWindow:

WindowPtr;

menultem:

myTERec:

TEHandle;

Integer) ;

VAR

txStyle:
fontName :
fontID:

TextStyle;
Str255;
Integer;

{holds style selected}
{name of font selected}
{ID of font selected}

BEGIN

GetItem(GetMenuHandle(mFont),
GetFNum(fontName,

fontID) ;

txStyle.tsFont

fontID;

:=

menuItem,

TESetStyle(doFont,

txStyle,

true,

MyAdjustScrollBars

(window,

FALSE) ;

fontName) ;

myTERec) ;

END;

Using TextEdit

2-47

CHAPTER

2

TextEdit

Handling a Font Size Menu
If your application includes a menu that allows users to change the font size of the
selected text, you can use the TESet Style procedure to handle this modi cation. The
code in Listing 2-11 sets the tsSize_ eld of the text style record to the font size that the
user selects; then it calls TESet Style to apply the new font size immediately. The
doSize mode parameter value forces all the text to the new size.
Listing 2-11
PROCEDURE

Handling the Size menu

MyHandleSizeCommand

(myTERec:

TEHandle;

menulItem:

Integer) ;

VAR

txStyle:

TextStyle;

BEGIN

MyGet Size

(GetMenuHandle(mSize),

txStyle.tsSize

:=

menuItem,

sizeChosen) ;

sizeChosen;

TESetStyle(doSize,

txStyle,

TRUE,

MyAdjustScrollBars

(window,

FALSE) ;

myTERec) ;

END;

Handling a Style Menu
Your application can also use TESet Style to handle Style menu commands. For
example, you can set the mode parameter to doFace and set the tsFace eld of the text
style record to any of the font attributes that the user selects. If your menu supports a
Plain option to remove all attributes from the text selection, you need to explicitly set
tsFace.

Because of the behavior of TESet Style,

you cannot implement

a Plain

selection by passing a null (empty set) text style record to remove the current attributes.
Listing 2-12 shows how to use TESet Style to change the text attributes, including how
to render plain text.
Listing 2-12
PROCEDURE

Handling a Style menu

MyHandleStyleMenu

(myWindow:
menultem:

WindowPtr;
Integer) ;

VAR

txStyle:

TextStyle;

aniIntPtr:

Integer;

BEGIN

{mStyle}

WITH

txStyle

CASE

DO

menultem

BEGIN

OF

plainitem:
BEGIN

aniIntPtr

2-48

Using TextEdit

:=

@txStyle.tsFace;

myTERec:

TEHandle;

CHAPTER

2

TextEdit

anIntPtr®

:=

tsFace

[];

:=

0;

END;

boldiItem:

tsFace

:=

[bold];

italicItem:

tsFace

:=

[italic];

underlinelItem:

tsFace

:=

[underline] ;

outlinelItem:

tsFace

:=

[outline];

shadowItem:

tsFace

END;
IF

:=

[shadow] ;

<>

1

{case}
menuItem

THEN

TESetStyle(doFace
{if

we

don't

+

doToggle,

select

plain

txStyle,
then

use

TRUE,

myTERec)

doToggle}

ELSE

TESetStyle(doFace,

txStyle,

TRUE,

{TESetStyle has problems with
{ has no effect!so we need to
MyAdjustScrollBars

(window,

myTERec) ;

plain and doToggle
special case it.}

}

FALSE) ;

END;
END;

If you set redraw to TRUE, TextEdit redraws the current selection with the new
attributes, recalculating line breaks, line heights, and font ascents. If you call
TESetStyle with a value of FALSE for the redraw parameter, TextEdit does not
redraw the text or recalculate line breaks, line heights, and font ascents until the next

update event occurs. Consequently, when your application calls a routine that uses any
of this information, such as TEGetHeight (which returns a total height between two
speci ed lines), the routine uses the old character attribute information that existed
before you called TESet Style to change it. To be certain that the new information is
always refected immediately, call the TESet Style procedure with a redraw parameter
of TRUE.

Listing 2-13 shows a sample procedure that calls TECont inuousStyle

to check the

character attributes of the current selection range; it determines whether the style is
plain, bold, or italic. For each style that is continuous across the text, the
MyAdjustStyleNew procedure marks the item on the style menu. In this case, if

TECont inuousStyle

returns a mode parameter that contains

doFace and the text

style record tsFace

eld is bold, it means that the selected text is all bold, but may

contain other text styles, such as italic, as well. Italic does not apply to all of the selected
text, or it would have been included inthe tsFace eld.IfthetsFace eld isan empty
set, then all of the selected text is plain.
Using TextEdit

2-49

CHAPTER

2

TextEdit

Listing 2-13

PROCEDURE

Checking the style and marking Style menu items to reflect
the current selection range

MyAdjustStyleNew

(myTERec:

TEHandle) ;

VAR

styleMenu:

MenuHandle;

aStyle:

TextStyle;

mode:

Integer;

BEGIN

mode

:=

doFace;

styleMenu
IF

GetMenuHandle

(mStyle)

TEContinuousStyle
(mode,

:=

aStyle,

;
myTERec)

THEN

BEGIN

{There is at least one style that is continuous over }
{ the selection. Note that it might be plain, which is
{ actually the absence of all styles. }
CheckItem(styleMenu,

plainItem,

CheckItem(styleMenu,

boldItem,

CheckItem(styleMenu,

italicItem,

{Set

appropriately.}

other

menu

items

aStyle.tsFace

bold

IN

=

}

[]);

aStyle.tsFace) ;

italic

IN

aStyle.tsFace) ;

END
ELSE
BEGIN

{No

text

face

is

common

to

the

entire

CheckItem(styleMenu,

plainItem,

CheckItem(styleMenu,

boldItem,

CheckItem(styleMenu,

italicItem,

{Set

appropriately.}

other

menu

items

selection. }

FALSE) ;
FALSE) ;
FALSE) ;

END;
END;

Changing the Text Alignment
Your application can change the alignment of the entire text of an edit record by calling
the TESetAlignment procedure. The default alignment used to display the text of an
edit record is based on the primary line direction of the system script. For example, when
the system script is Arabic or that of any language that is read from right to left, the
default line direction is right to left and the text is right aligned.
For a script system whose primary line direction is right to left, you can force left
alignment of the text by specifying teFlushLeft as the value of the align parameter,
as shown in the following example:
TESetAlignment

2-50

Using TextEdit

(teFlushLeft,

myTERec) ;

CHAPTER

2

TextEdit

You can use any of the following constants to specify how text is aligned.
Constant

Description

teFlushDefault

Default alignment according to the primary line direction

teCenter

Center for all scripts

teFlushRight

Right for all scripts

teFlushLeft

Left for all scripts

Make sure that you call the Window Manager@ InvalRect procedure after you change
the alignment so the text is redrawn with the new alignment. For more information about
InvalRect, see the chapter ONindow ManagerOin Inside Macintosh: Macintosh Toolbox
Essentials.

Saving and Restoring a TextEdit Document, and
Implementing Undo
This section describes how to save to disk the contents of a document created using
TextEdit, and restore it when the user opens the document. For both monostyled and
multistyled text, you need to save and restore the text and its character attribute
information. This section also discusses how to implement an Undo feature.

Saving a TextEdit Document
To save the contents of a document created using TextEdit and a monostyled edit record,
you store the text. You can also save the text characteristics, such as the font and its size

and style, and the text margins; you can store this information in a resource. (Save the

font name, not the font number.)

To save the contents of a document created using TextEdit and a multistyled edit record,
you need to save all of the associated character attribute information in addition to the
text. Because the text format of the character attribute information in the style scrap is
easier to export than the style record itselfN it uses the Desk Manager@ 'styl' formatN
you should use the TextEdit routines that use the style scrap for moving character
attribute information:

TEGet StyleScrapHandle and TEUseStyleScrap. For

example, you can use the following steps to save a multistyled text document to disk:
1. Create a text
data fork.

le, select all the text of the edit record, and save it in the text

le@

2. Call TEGet StyleScrapHand1le to get a handle to the style scrap record. This creates
the style scrap record and uses it to store the character attribute information.
3. Save the character attribute information in the resource fork of the _ le.

The application-de ned procedure MyDoSaveAsText
Edit shown in Listing 2-14 uses
this method. Notice that this procedure avoids using TESet Select to select all of the
edit record@ text. The TESet Select procedure sets and highlights the selection range
that you specify. Because you are selecting the text to save it, you don®want it to be

Using TextEdit

2-51

CHAPTER

2

TextEdit

highlighted. (Highlighting the text before saving it can mislead a user to presume
some other action is required.)

that

However, if you want to use TESet Select, you can circumvent highlighting of the
selection range if you rst render the edit record inactive; before you call TESet Select,
call TEDeactivate. Also, if you have outline highlighting turned on through the
TEFeatureFlag function@ teFOut lineHilite feature, turn it off. When the edit

record is not the active one,
to be highlighted.
Listing 2-14

TESet Select can set the selection range without causing it

Saving a multistyled text edit record to disk

PROCEDURE

MyDoSaveAsTextEdit

(textToSave:

TEHandle) ;

CONST

kFileType
kFileCreator

=
=

'TEXT';
'NIIM';

{file type of
{creator code

text file}
of text file}

VAR

reply:

StandardFileReply;

{location,
styles:

name

of

file

StScrpHandle;

to

save

text

{contains

all

to}
character

}

dataLength:
dataRefNum:

LongInt;
Integer;

{ attributes in
{number of bytes of
{ref number of text

text}
text to write}
file's data fork}

rsrcRefNum:

Integer;

{ref

file's

savedStart:

Integer;

{saves

offset

of

start

savedEnd:

Integer;

{saves

offset

of

end

error:

OSErr;

{error

code

from

toolbox}

ending

offsets

number

of

text

rsrc

of
of

fork}

selection}

selection}

BEGIN

StandardPutFile(
IF

reply.sfGood

'',

'',

reply);

THEN

BEGIN

{save

the

current

starting

and

of

selection}

savedStart := textToSave**.selStart;
savedEnd := textToSave**.selEnd;
{select all text; don't use TESetSelect because it }
{ draws selection}
textToSave *“ selStart
:= 0;
textToSave~
.selEnd := textToSave**.teLength;
A

{get

a list
styles

2-52

Using TextEdit

of

all
:=

the

attributes

in

TEGetStyleScrapHandle

the

text}

(textToSave)

;

CHAPTER

2

TextEdit

{reset

the selection back to what it was}
textToSave**.selStart := savedStart;
A

textToSave**.selEnd

{create

the
IF

text

NOT

file

if

:=

it

savedEnd;

didn't

reply.sfReplacing

exist

before}

THEN

BEGIN
error

:=

FSpCreate(reply.sfFile,

kFileCreator,

kFileType,

reply.sfScript) ;

FSpCreateResFile(reply.sfFile,
kFileType,
error

:=

kFileCreator,

reply.sfScript) ;

ResError;

END ;

{open

the

error

:=

text

rsrcRefNum
error

:=

:=

:=

FSpOpenResFile(reply.sfFile,

dataRefNum) ;
fsCurPerm) ;

text to the file}
:= textToSave**.teLength;

FSWrite(dataRefNum,

dataLength,

textToSave**

{Write

fsCurPerm,

ResError;

{write the
dataLength
error

file}

FSpOpenDF(reply.sfFile,

the

AddResource

attributes

to

the

(Handle(styles),

.hText*

);

file}
'styl',

0,

'');

WriteResource
(Handle (styles) ) ;
ReleaseResource
(Handle (styles) );

{close

the

error

:=
:=

file}

FSClose(dataRefNum) ;

CloseResFile
error

text

(rsrcRefNum)

;

ResError;

END ;
END ;

Restoring an Existing TextEdit Document
You can restore the text of an edit record when a user opens a document that was created
using TextEdit. One way to do this is to read the text from the data fork into a handle,
then write the handle to the hText

eld of the edit record; call TECalText

after you do

this. Before you write the new handle to the hText eld, dispose of the existing handle,
if there is one. For a multistyled edit record, you need to reinstate both the text and the
character attribute information for it. (For information about how to opena_ le, see
Inside Macintosh: Files.)

Using TextEdit

2-53

CHAPTER

2

TextEdit

You can use a method similar to the one shown in Listing 2-14 on page 2-52 to save a
multistyled text document. However, to restore the text, you retrieve the data from the

le@ data fork and write it to a buffer, then call

and

set the hText

TESet Text to make a copy of the text

eld of the edit record to point to it. The MyDoOpenText Edit

procedure shown in Listing 2-15 shows an example of this. Before copying the text to a
buffer, the MyDoOpenText
Edit procedure checks to ensure that the text length does not
exceed the 32 KB limit; if it does, TextEdit truncates the text before it copies it.
The MyDoOpenText Edit procedure retrieves the character attribute information from

the resource fork of the disk
calling

Listing 2-15

PROCEDURE

le and reinstates it in the edit record@ style record by

TEUseStyleScrap.

Restoring a document that uses multistyled TextEdit

MyDoOpenTextEdit

(textToOpen:

TEHandle) ;

CONST

kFileType

=

'TEXT';

{file

type

of

text

file}

VAR

reply:

StandardFileReply;

{location,

name

of

file

to

get

text

typeList:
dataRefNum:

SFTypeList;
Integer;
{ref

{specifies 'TEXT' files in
number of text file's data

SF dialog}
fork}

rsrcRefNum:

Integer;

number

fork}

textBuffer:
textLength:

Handle;
LongInt;

from}

{ref

{holds text
{number of

styles:

StScrpHandle;

error:
savedState:

OSErr;
SignedByte;

of

text

from file}
bytes of text

{contains

{error
{saves

file's

all

rsrce

to

character

read}
attributes

code from toolbox}
state of 'styl' resource}

BEGIN

typeList[0]

:=

kFileType;

StandardGetFile(NIL,
IF

reply.sfGood

1,

typeList,

reply);

THEN

BEGIN

{open

the

error

:=

FSpOpenDF(reply.sfFile,

error

:=

SetFPos(dataRefNum,

{get

the

number

error

:=

GetEOF(

IF

fork

of

textLength

>

textLength

:=

{allocate
textBuffer

2-54

data

Using TextEdit

the

bytes

of

dataRefNum,
32767

a buffer
:=

of

text

file}
fsCurPerm,

fsFromStart,
text

in

THEN

32767;

for

the

the

textLength

text}

NewHandle(textLength) ;

dataRefNum) ;

0);
file;

);

limit

to

32KB}

in

text}

CHAPTER

2

TextEdit

{read

the

text

error

:=

FSRead(

{put

the

LockHHi

text

TESetText

into

the

(textBuffer*,

of

the

DisposeHandle

buffer}
TextEdit

text

the

FSClose(dataRefNum) ;

{open

the

resource

:=

{get

the

styles
error

IF

fork

of

;

:=

error

textToOpen) ;

buffer}

{close

:=

);

record}

textLength,

error

rsrcRefNum

textBuffer®

;

(textBuffer)

data

textLength,

;

(textBuffer)

rid

the

dataRefNum,

(TextBuffer)

HUnlock

{get

into

fork

the
of

text
the

file}

text

file}

FSpOpenResFile(reply.sfFile,

fsCurPerm) ;

Reskrror;

style
:=

:=

scrap}

StScrpHandle(GetResource('styl',

0));

Reskrror;

styles

<>

NIL

THEN

BEGIN

savedState

:=

{apply

character

the

HGetState(Handle(styles)
);

attributes

TEUseStyleScrap(0,

textLength,

{restore

state

'styl'

HSetState

(Handle(styles),

of

to

the

styles,

TextEdit
true,

record}

textToOpen) ;

resource}
savedState) ;

END;

{close

the

error

:=

forks

of

the

text

file}

FSClose(dataRefNum) ;

CloseResFile(rsrcRefNum) ;
error

:=

Reskrror;

END;
END;

Handling Undo
Application users nd Undo an especially useful feature. Users might accidently choose
Clear from the Edit menu instead of Cut, or they might backspace over more words than
intended. In these and cases like them, Undo is invaluable.

If you are implementing Undo for multistyled text, you need to save the character
attribute information along with the text. Although this section discusses one method,
there are a number of ways that you can do this. For example, when you want to save
the current attributes of the selected text to allow the user to revert to them, your
application calls the TEGet StyleScrapHandle function, which returns a handle to the
style scrap@ style record containing the attributes used for the selected text. To restore
the style later, you call the TEUseStyleScrap procedure. You also need to save the
offsets into the edit record@ text buffer of the rst and last characters to which the
character attribute information is to be applied.
Using TextEdit

2-55

CHAPTER

2

TextEdit

If your application supports any 2-byte script systems, your Undo operations needs to
check for 2-byte characters. Normal cut or paste operations do not present a problem,
but be careful when undoing a backspace. When TextEdit backspaces over single
characters, it checks CharByte to determine if the character to be removed is a 2-byte
character. If it is, it removes 2 bytes. (For more information about the CharByte function,
see the chapter the Gcript Manager,Oin this book.) When an application program
maintains a buffer of characters that have been backspaced over in order to
support Undo, it needs to make a test similar to that in Listing 2-16.
Listing 2-16
IF

Checking for 2-byte characters when backspacing

myChar

=

BS

{support
IF

then

aTeHandle

backspace

undo}

selStart

{not

an

<>

selEnd

insertion

point

then

AA

do

begin

begin

save

the

selection}

END
ELSE

begin

1

:=

selStart;

IF

i

>

0

then

repeat
until

begin
1

:=i-1

CharByte(hText*,

i)

<=

0;

{Note: Guarantees that CharByte(x,0)
<= 0}
{Also, CharByte does not touch the heap}
{Put bytes from i to selStart into buffer}
END;
END;
END;

Customizing TextEdit
This section describes how to customize TextEdit using the TECustomHook routine to
replace the end-of-line, drawing, width-measuring, and hit test default hook routines.
It also describes the multi-purpose low-memory global variable TEDoText hook routine
that displays, highlights, and hit-tests characters, and positions the pen to draw a caret.
Finally, this section discusses how to customize word selection, automatic scrolling, and

how to determine the length of a line of text in order to justify it. (For a brief discussion of
hook

elds and hook routines, see CRelated Data StructuresOon page 2-17.)

The next four sections describe how to customize TextEdit using the TECustomHook
procedure. Information about the use of TECustomHook that is common to all four
sections is provided here.

2-56

Using TextEdit

CHAPTER

2

TextEdit

You can customize TextEdit@ behavior by replacing any of the default hook
routines with those of your own. You use the TECust omHook procedure to replace
a routine installed ina hook eld of the dispatch record (TEDispatchRec). Initially, each
hook eld of the dispatch record contains the address of the default hook routine that
TextEdit uses.
The TECustomHook procedure returns the address of the default routine that it replaces
so that your application-supplied routine can call the default routine, daisy-chaining it, if
you want it to. For example, your routine can add additional functionality, then call the
default routine instead of replicating all of its behavior. If you replace the address of a
default hook routine with that of your own customized version, the next time you call
TECustomHook for that hook

eld, TECustomHook will return the address of your

routine. (For more information, see OQPECustomHookOon page 2-110.) To ensure future
compatibility, use the TextEdit customization routines to modify hooks rather than write
directly to these elds.
If you replace a default hook routine with a customized version that you write in a
high-level language, such as Pascal or C, you need to provide assembly-language glue
code that utilizes the registers for your high-level language routine. Refer to
(YECustomHookOon page 2-110 for a description of the register contents on entry and
return for each of the hook routines.
If you replace a default routine, take the following precautions:
m Before placing the address of your routine in the TextEdit dispatch record, strip the
addresses, using the Operating System Utilities StripAddress function, to guarantee
that your application is 32-bit clean. For more information, see Inside Macintosh:
Operating System Utilities.
m Before replacing a TextEdit routine with a customized one, determine whether more
than one script system is installed, and, if so, ensure that your customized routine

accommodates all of the installed script systems. This avoids the problem of your
customized routine producing results that are incompatible with the Script Manager.
m When you use assembly language, note that all registers must be preserved except
those speci ed as containing return values. Register A3 contains a pointer to the edit
record and Register A4 contains a handle to it. You can obtain line start positions from
the lineStarts array in the edit record. Register A5 is always valid. Refer to
TECustomHook in the TextEdit Reference section for complete coverage of the register
content requirements for all hook routines.

Replacing the End-of-Line Routine
You can replace the address of the default end-of-line hook routine with the address of
your own routine that determines an end-of-line character if you want the end-of-line to
be de ned by a character other than the carriage return.
The default routine compares a given character with $0D (a carriage return) to determine
whether it is an end-of-line character, and returns with the appropriate status fsags (either
TRUE or FALSE) in the status register.

Using TextEdit

2-57

CHAPTER

2

TextEdit

Replacing the Drawing Routine
TextEdit calls the draw hook routine any time the various components of a line are
drawn. The appropriate font, face, and size characteristics have already been set into the
current graphics port by the time this routine is called.
If your application uses an outline font, the default behavior of the Font Manager
ensure@ that glyphs t within the font@ ascent and descent. Glyphs that extend beyond
the ascent or descent, such as certain accented fonts, are scaled downto

t.

If your application has set the preserveGlyph parameter of the Font Manager@
Set PreserveGlyph procedure to TRUE to preserve the original unscaled shape of the
glyph, note that TextEdit sets it to FALSE before it calls the draw hook to perform any
drawing. This is to guarantee that the glyphs whose bounding boxes exceed the font@
ascent or descent are scaled down to prevent them from colliding with other glyphs on
the lines above or below. TextEdit then restores the preserveGlyph parameter to its

previous value before proceeding.

Replacing the Width-Measuring Routines
A width measurement hook routine measures portions of a line of text, and TextEdit calls

one each time the width of various components of a line is calculated. There are three

width measurement hooks: the width measurement hook, the new width measurement
hook, and the text width measurement hook. Default hook routines of the same name as
the hook eld are installed in each of these hooks.

The width measurement hook, which TextEdit used in the past, now exists to provide
backward compatibility for applications that have replaced the default routine with a
customized one. TextEdit uses the routine whose address is installed in this eld only
when both of the following conditions exist: when only the Roman script system is
installed and the eld contains the address of a customized routine.
In all other casesN when more than one script system is installed or when the width
measurement hook has not been customizedN TextEdit calls the routine whose address is
installed in the new width measurement hook

eld to measure text.

Figure 2-14 shows a Sow chart illustrating when the width measurement hook and the
new width measurement hook routines are used.

2-58

Using TextEdit

CHAPTER

2

TextEdit

Figure 2-14

Determining when to use WIDTHHook

and nWIDTHHook

Determine the

width-measuring
routine to use

Is script

count

number
>1?

Yes

No

Is
width hook
customized?

No

Yes

VY
Use
width hook

Use
new width hook

The new width measurement hook routine is called to measure text for both Roman and
non-Roman script systems. If you replace this routine, make sure that your customized
routine is script-aware.
The default action for the new width measurement hook routine is to call the QuickDraw
Manager@ CharToPixel function or TextWidth procedure to measure for non-Roman

scripts. By default, the TextWidthHook eld contains the address of the QuickDraw
TextWidth function. You can use this hook to replace TextEdit@ use of the
QuickDraw TextWidth function with your own measuring routine. If you replace

this hook routine with a customized version, when the routine whose address is installed
in the new width measurement hook eld makes a call to Text Width, your customized
routine is invoked.

Using TextEdit

2-59

CHAPTER

2

TextEdit

To test for the availability of the width-measuring hooks, you can call the Gestalt
function with the

gestalt TextEditVersion selector. A result of gestalt
TE2

or

greater returned in the response parameter indicates that the new width measurement

hook is available, and a result of gestalt TE5

is available.

or greater indicates that TextWidthHook

Replacing the Hit Test Routine
TextEdit calls the hit test hook routine to determine the glyph position in a line, given the
pixel width from the left edge of the view rectangle. For versions of software earlier than
7.0, the default action is to call the Text Width function to determine if the pixel width of
the measured text is greater than the input width. If it is, then the hit test hook routine
calls the QuickDraw PixelToChar function and returns. For system software version 7
and later, the default action is to call the QuickDraw

Pixel ToChar

function. In addition

to the values de ned by the register contents on entry, when TextEdit calls the
PixelToChar function, it passes a value of OnlyStyleRun for the

styleRunPosition parameter and scaling factors of 1/1 for the numer and demon
parameters. See CHit Test Hook RegistersOon page 2-113.

Customizing Word Selection
A word-selection break routine determines which word is highlighted when the user
double-clicks in the text. It also determines where TextEdit breaks the text at the end of a

line. You can use TESetWordBreak to replace the default routine, installed in the edit

record@ wordBreak
eld, that is used for word selection and line breaking under certain
circumstances. Whether or not TextEdit uses the word break hook routine installed in this

eld is determined by the algorithm implemented in the default TEFindWord routine,

which is described below.

When you replace the wordBreak eld hook routine, your customized word-selection
break routine is used instead of the default one. The default routine breaks words at
any character with an ASCII value of $20 or less (the space character or nonprinting
control characters).
Before non-Roman script systems were supported, TextEdit used the word-selection
break routine referenced by the wordBreak eld for all word selection and line breaking.
However, in order to support both Roman and non-Roman script systems, TextEdit now
uses the routine referenced by the low-memory global variable TEFindWord. The default
TEFindWord hook routine determines which hook TextEdit should use for word
selection and line breakingN the wordBreak hook or the Text Utilities
FindWordBreaks procedureN based on what script systems are installed
and some other factors. You can replace the TEFindWord hook routine with a
customized version.
The TEFindWord hook routine is a higher level routine than wordBreak. Because of
this, when you customize the TEFindWord hook you are completely changing how
TextEdit handles word selection and line breaking. However, when you replace
wordBreak, you are only impacting those aspects of word selection and line breaking
that are normally handled by the wordBreak routine.

2-60

Using TextEdit

CHAPTER

2

TextEdit

The TEFindWord hook routine gives your application more control over the breaking
process and allows you to write more ef cient routines. However, unless you include
explicit tests for scripts in your customized routine, the algorithms you provide may be
incorrect for non-Roman scripts. If you replace TEFindWord, you should understand the
behavior of the default routine.
Here@ how the default TEFindWord

routine works:

m TextEdit initially determines whether a non-Roman script system is installed. If more
than the Roman script system is installed, TextEdit always uses the Text Utilities
FindWordBreaks procedure for line breaking and word selection.
mw When TextEdit determines that only the Roman script system is installed and the

TEFindWord routine is being called for line breaking (not word selection), TextEdit

calls the wordBreak hook.

m If TEFindWord is called for word selection for system software with only the Roman
script system installed, TextEdit checks to see if your application has placed the

address of a customized word-selection breaks routine in the wordBreak
eld of the
edit record. If so, TextEdit calls your word-selection breaks routine. Otherwise, if the
wordBreak
eld contains the address of TextEdit@ internal word-selection breaks

routine, TextEdit uses the Text Utilities FindWordBreaks procedure to determine

word-selection breaks.

When TextEdit calls the Text Utilities FindWordBreaks procedure, it uses information in
the edit record to provide the necessary parameters. TextEdit determines the current
script boundaries from the Text Utilities FindWordBreaks procedure by using the font
run information in the style record (of type TEStyleRec). TextEdit also determines the
length of the script run and the offset within the script run from which to begin searching
for a word boundary. TextEdit uses the value in the clikStuff eld of the edit record to
determine the leading edge fsag for the FindWordBreaks procedure. You must use
similar information to replace TEFindWord correctly for non-Roman scripts.

Customizing Automatic Scrolling
Scroll bars associated with the text are not automatically scrolled with the text unless
you replace the address of the default click loop routine with that of a customized routine
that updates the scroll bars. You can write your own click loop routine that includes code
to update the scroll bars along with the text and install its address in the clikLoop eld.
To replace the default click loop routine with your customized version, you call the
TESetClickLoop procedure.
You can write a routine that manages the scroll bars, then calls the default click loop

routine, rather than replicating its behavior in your routine. However, if your routine
scrolls the text and updates scroll bars, you should consider what the default click loop
routine does. It adjusts the value in the clickTime eld of the edit record to allow for
slower scrolling.

When TEC1lick is called, the clickTime
eld contains the time when TEC1lick was last
called. TextEdit sets the clickTime
eld with the current tick count on exit from the

TEClick procedure and uses the new value at reentry the next time TEClick is called.

Using TextEdit

2-61

CHAPTER

2

TextEdit

If you code a click loop routine in Pascal, it should have no parameters and it should
return a Boolean value. You can declare a click loop routine named MyClickLoop

like this:

FUNCTION

MyClickLoop:

Boolean;

The function should return TRUE. Returning FALSE from your click loop routine tells the
TEClick procedure that the mouse button has been released, which aborts TEClick.

Installing a customized default click loop routine
If you code a click loop routine in Pascal, then call the TESet ClickLoop
procedure to install the Pascal routine in the clikLoop eld,
TESet ClickLoop installs a glue code routine in the clikLoop eld
because clikLoop expects a routine that uses assembly-language
conventions. Because of this, you must always use TESet ClickLoop to
install a Pascal routine, while you must always directly install an
assembly routine inthe clikLoop eld.
If you code a click loop routine in assembly, it should set register DO to 1 and preserve
register D2. Returning 0 in register DO aborts TEClick.

You can write a routine that manages the scroll bars, then calls the default click loop
routine, rather than replicating its behavior in your routine. If your customized routine
calls the default click loop routine, it must use assembly-language calling convention.

Determining the Line Length
This section describes how to determine the length of a line. You can use this information,
for example, to justify a line of text; although TextEdit aligns text with the right or left
margins, or centers it, it does not justify it.
To determine the length of a line, you use the information contained in the edit record@
line starts array and nLines eld. The line starts array is a variable-length eld in the
edit record that contains the byte offset for the rst character of each line. This array has
the following boundary conditions:
m The

rst entry has index 0 and value 0.

m The last entry in the array has index nLines and value teLength (therefore, there are
nLines + 1 entries).

mw The beginning of the rst line is given by lineStarts[0], and the beginning of the
second line is given by lineStarts[1]; therefore, the length of the rst line is given
by lineStarts[1]

m

2-62

The maximum

Using TextEdit

lineStarts[0].

number

of entries is 16,000.

CHAPTER

2

TextEdit

For example, if you want to determine the length of the line n (where n = 0 for the rst
line), subtract its start location (contained in the array entry with index n) from its end
location (contained in the array with index n + 1):
lengthOfLineN

:=

myTE**.lineStarts[n+1]

-

myTE**.lineStarts[n]

The terminating condition for this measurement is when 1 is equal to nLines

;

plus 1.

IMPORTANT

Do not change the information contained in the

lineStarts array. A

Advanced Customization
The low-memory global variable TEDoText is a hook which contains the address of a
multi-purpose text editing routine that advanced programmers may nd useful. It lets
you display, highlight, and hit-test characters, and position the pen to draw the caret.
Hit-testing is the process of determining where to place the insertion point when the user
clicks the mouse button; the point selected with the mouse isin the SelPoint

registers contain the following values.

eld. The

Registers on entry
A3

Pointer to the locked edit record

D3

Position of the

D4

Position of the last character; used as de

D7

Selectors for TEDoText (word)

rst character (word)
ned below (word)

teFind

EQU

0

to hit-test the character speci

ed in D3

teHighlight

EQU

1

to highlight the text range speci
and D4

ed in D3

teDraw

EQU

-1

to display the range of text speci
D4

ed in D3 and

teCaret

EQU

-2

to draw the caret at the position speci
in D3

teFind

EQU

0

to hit-test the character speci

ed

ed in D3

Registers on exit

AO

Pointer to current graphics port

DO

If hit-testing, byte offset where hit, or

1 for none (word)

Note
You need to use the value stored in the edit record selPoint eld
for hit-testing if you replace the routine pointed to by the global
variable TEDoText. (The assembly-language offset for this eld
isnamed teSelPoint.)

Using TextEdit

#

2-63

CHAPTER

2

TextEdit

TextEdit Reference
This section describes the data structures and routines that comprise TextEdit. The CData
StructuresOsection shows the Pascal data structures including the edit record and
subsidiary structures that allow for text styling and customization of TextEdit. Together
with the TextEdit private scrap and the TextEdit style scrap, these data structures de ne
the TextEdit environment.
The CRoutinesOsection describes the routines that provide applications with the means of
creating edit records and accessing, editing, and displaying multistyled and monostyled
text, including text highlighting and scrolling.

The constants that de ne values for some of the parameters used in several of these
routines are listed in the Gummary of TextEditOon page 2-118.

Data Structures
This section describes the data structures and their contents which provide information
to the TextEdit routines. Both monostyled and multistyled edit records have a 32 KB
maximum text size.
The TextEdit data structures are de

ned as follows:

m The edit record, de ned by the TERec data type, stores the display and editing
information for TextEdit.
m Along with various subsidiary data structures, the style record, de ned by the
TEStyleRec data type, stores the character attribute information for the text of the
edit record.
m The style run table, de ned by the StyleRun data type, is an array that contains the
boundaries of each style run and an index to its character attribute information in the
style element array.
m The style table, de ned by the TEStyleTable data type, contains one entry for each
distinct set of character attributes used in the text of the edit record.

m The line-height table, de ned by the LHTable data type, provides an array of line
heights to hold the vertical spacing information for a given edit record. It also contains
line ascent information.

2-64

TextEdit Reference

CHAPTER

2

TextEdit

m The null style record, de ned by the Nul1StRec data type, contains the null scrap
which is used to store character attribute information for a null selection.

m The style scrap record, de ned by the StScrpRec data type, is used by routines to
store character attribute information temporarily.
m The scrap style table, de ned by the scrpStyleTab data type, is contained in the
style scrap record.
m The scrap style element record, de ned by the ScrpSTElement data type, contains
the character attribute information for an element in the scrap style table. One scrap
style element record exists for each sequential attribute change in the associated text.
m The TextEdit dispatch record, de ned by the TEDispatchRec data type, contains the

internal addresses of the TextEdit routines for the end-of-line hook, the draw hook, the
width measurement hook, the new width measurement hook, and the text width

measurement hook, unless you replace them with the addresses of your own
customized versions of these routines.

m The text style record, de ned by the Text Style data type, is used by several routines
to pass character attribute information between the application and a routine. The
record is passed as a variable or reference parameter.
Figure 2-15 shows the TextEdit data structures and their elds to help you understand
how the TextEdit data structures are organized and related. (For a monostyled edit
record, TextEdit creates only the TERec and TEDispatchRec data structures.) To read
from and write to these data structures, use the TextEdit routines rather than modifying
these elds directly. This practice ensures future compatibility.
For most operations, you do not need to know the exact structure of an edit record;
TextEdit routines gain access to the record for you. However, when manipulating
character attribute information, you might nd it helpful to understand how the data
structures used to contain and track character attribute information are organized.
Note
The space beyond the hooks in the TextEdit dispatch record is reserved
for internal use. If you attempt to use this private area, you may corrupt
TextEdit data.

TextEdit Reference

2-65

CHAPTER

2

TextEdit

Figure 2-15

The TextEdit data structures and fields

TERec
0

destRect

4

8

IhTab

10

+———

selRect ———

15

Inchiciaht

runs

g
__fontAscent

Ta

——

selPoint

(0...nRuns)

:

SEL

a24

active

4

__(0...nRuns)

selEnd

OE

3234
38

clikLoop

clickTime

HEIomert|

LHElement

__clickLoc

caretTime

STScrpHandle_ | 4

P

scrpStyleTab7

hDispatchRec

txFace

(if txSize = —1)

ixFont

TEStyleHandle

i<

4E___txMode
50
txSize
52
.
inPort
56
5A
5E
60

0

draw hook

8

width hook

Reserved

highHook

Reserved

caretHook

18 Ww width hook
Cc

(0...nLines)
—»>—»

|

A

.

j
lineStarts

one word

= handle

| = 16 bits

TextEdit Reference

teReserved

nullScrap
StScrpRec
scrpNStyles

|

(array of

ScrpSTElement)

16
-(0...serpNStyles —1)7
.

~ end-of-line hook

hit test hook

nLines
__ array of
Inte ger

C

into this array.
(Only if lineHeight = —1)

L—»}

NullStRec

IhHeight

2___rAscent
4
(0...nLines)

One each per line in record.

TEDispatchHandle

(0...nStyles)

LHTable

0

42

4A

<

»|0
(5

TEDispatchRec
(Access through TECustomHook.)

4C

0

>

hText

46

12

—
|

into this array.

SE

crOnly

=|

stColor

array elements) is an index

——

Line number is a direct index

46 __ clikStuff

stFont
siface
stSize

___stAscent

record. stylelndex (in StyleRun

5

caret late
SA
just
3C _ teLength

6
[8
A

One each per unique style in

One each per style change.
Kept in ascending order of
offsets into record
(sorted by startChar).

wordBreak
2A

~nullSTHandle
-

StyleRun

selStart

TEStyleTable
stCount
stHeight

c

array of

StyleRun

0
2

4

STElement 4

nullStyle

20
26

, STHandle

teRefCon

10

2-66

styleTab

LHHandle .| 8

—
——+
—_

+——. viewRect
+

1A
iC

TEStyleRec
nRuns
nStyles

m1 0
2

text width hook

Raserred

0

scrpStartChar

4 _ scrpHeight

6

ScrpSTElement 7 | 8
A
C
E

scrpAscent
scrpFont
scrpFace
scrpSize

scrpColor
One each per sequential

style change in associated text

CHAPTER

2

TextEdit

The Edit Record
The edit record contains display, storage, styling, and other information related to editing
that TextEdit requires. Although some _ elds are used differently for multistyled edit
records and monostyled edit records, the structure of an edit record is the same whether

the text is multistyled or monostyled.
TYPE

TERec

=

RECORD

destRect:

Rect;

viewRect:

Rect;

selRect:

Rect;

lineHeight:

Integer;

fontAscent:

Integer;

selPoint:

Point;

selStart:

Integer;

selEnd:

Integer;

active:

Integer;

wordBreak:

ProcPtr;

clikLoop:

ProcPtr;

clickTime:

LongInt;

clickLoc:

Integer;

caretTime:

LongInt;

caretState:

Integer;

just:

Integer;

teLength:

Integer;

hText :

Handle;

hDispatchRec:

Handle;

clikStuff:

Integer;

erOnly:

Integer;

txFont :

Integer;

txFace:

Style;

txMode:

Integer;

txSize:

Integer;

inPort:

GrafPtr;

TextEdit Reference

{ destination rectangle}
{ view rectangle}
{ the selection rectangle}
{ used for vertical spacing of lines}
{ used for caret/highlighting }
{ position}
{ point selected with the mouse}
{ start of selection range}
{ end of selection range}
{ set when record is activated or }
{ deactivated}
{ word break hook}
{ click loop hook}
{ used internally}
{ used internally}
{ used internally}
{ used internally}
of
to

of text}
text}
text to be

to

TextEdit

{alignment

{ length
{ handle

{ handle

edited}

dispatch

record}

{ used internally}
{ if <0, new line at Return only}
{ text font.Otherwise, if txSize is }
combines with txFace to hold }
{ { a handle to the style record. }
{ character style; unpacked byte. }
{ Otherwise, if txSize is -1, }
{ combines with txFont to hold a }
{ handle to the style record}
{ pen mode}
{ tells if multistyled }
{ edit record; if not, font size}
{ a pointer to the graphics port }
{ for this TERec}

2-67

CHAPTER

2

TextEdit

highHook

:

ProcPtr;

{used

for

text

highlighting}

caretHook:

ProcPtr;

{used

for

caret

appearance}

nLines:

Integer;

{number

lineStarts:

ARRAY[0..16000]

of
OF

{positions

lines}
Integer;

of

line

starts}

END;
TYPK

TEPtr

=

“TFRec;

TEHandle

=

“TEPtr

Field descriptions
destRect

The destination rectangle, in local coordinates.

viewRect

The view rectangle, in local coordinates.

selRect

The selection rectangle, whose boundaries are de

ned in

local coordinates. This value is the current selection range or
insertion point.

lineHeight

The vertical spacing of lines of text. Vertical spacing may be xed or
it may vary from line to line, depending upon speci c text attributes.
If the value of lineHeight is greater than 0, this eld speci es the
xed vertical distance from the ascent line of one line of text down
to the ascent line of the next.
If the value of

lineHeight is less than 1, then this

eld speci

es the

vertical distance from the ascent line of one line of text down to the
ascent line of the next calculated independently for each line, based
on the maximum value for any individual character attribute on that
line.
fontAscent

The font ascent line. If the value of fontAscent is greater than 0,
this eld speci es how far above the base line the pen is positioned
to begin drawing the caret or highlighting.
For single-spaced text, this is the height of the text in pixels (the
height of the tallest characters in the font from the base line). If the
value of

fontAscent is less than 1, this

eld speci

es the font

ascent calculated independently for each line, based on maximum
value for any individual character attribute on that line.
selPoint

selStart
selEnd

active

2-68

TextEdit Reference

The point selected with the mouse, in the local coordinates of the

current graphics port. The assembly-language offset for this
named teSelPoint.

eld is

The byte offset of the beginning of a selection range. Note that byte
offset 0 refers to the rst byte in the text buffer.
The byte offset of the end of a selection range. To include that byte,
this value must be 1 greater than the position of the last byte offset
of the text.
This eld is used internally by TextEdit. It is set when an edit record
is activated through TEActivate and then reset when the edit
record is rendered inactive through TEDeactivate. To ensure
future compatibility, use TEActivate or TEDeactivate to access
this eld.

CHAPTER

2

TextEdit

wordBreak

clikLoop

The record@ word selection break routine. This routine determines
the word that is highlighted when the user double-clicks in the text
and the position at which text is wrapped at the end of a line.
The pointer to the click loop routine.The speci ed click loop routine
is called repeatedly by the TEClick procedure as long as the mouse
button is held down within the text.

clickTime

This

eld is for internal use only.

clickLoc

This

eld is for internal use only.

caretTime

This

eld is for internal use only.

caretState

This

eld is for internal use only.

just

The type of text alignment: default (according to primary line
direction), left, center, or right.

teLength

The number of bytes in the text to be edited. For two-byte systems,
potentially twice the number of characters. Initially set to zero. The
maximum length is 32767 bytes.

hText

A handle to the text. Initially, it points to a zero-length block of text
in the heap.

hDispatchRec

The handle to the TextEdit dispatch record. This eld is for internal
use only; do not modify this eld, or copy it to another edit record.
Each edit record has its own dispatch record. Attempting to use the
dispatch record of one edit record with another edit record can cause
TextEdit to crash.
This eld is for internal use only. TextEdit sets this eld to refSect
whether the most recent mouse-down event occurred on the leading
or trailing edge of a glyph. TextEdit uses this value in determining a
caret position.
A value specifying whether or not text wraps at the right edge of the
destination rectangle. If crOn1ly is positive, text does wrap.
If crOnly is negative, new lines are speci ed explicitly by Return
characters only; text does not wrap at the edge of the destination
rectangle. (This is useful in an application similar to a
programming-language editor, where you may not want a single
line of code to be split onto two lines.)

clikStuff

crOnly

txFont

The font of all the text in the edit record if the txSize_
eld of this
edit record = 0. If you change this value, the entire text of this
edit record has the new characteristic when it is redrawn; also,

remember to change the
as well.

Ifthe txSize

eldis

lineHeight and fontAscent

1,this

elds

eld combines with txFace to holda

handle to the associated style record.
txFace

The character attributes of all the text in an edit record if the txSize

eld of this edit record 2 0. If you change this value, the entire text of

this edit record has the new characteristic when it is redrawn; also,

remember to change the lineHeight and

well.

Ifthe txSize

eldis

1,this

fontAscent

elds as

eld combines with txFont to hold a

handle to the associated style record.
TextEdit Reference

2-69

CHAPTER

2

TextEdit

txMode

txSize

The pen mode of all the text in the edit record. If you change this

value, the entire text of this edit record has the new characteristic
when it is redrawn; also, remember to change the lineHeight and
fontAscent
elds as well.

Depending on its value, txSize either contains the point size of all
of the text or it acts as a Sag indicating whether or not there is

associated character attribute information. If txSize = 0, this isa
monostyled edit record, that is, all text is set in a single font, size,
and face, and the value of txSi ze is the size of the text. If txSize
is
1, the edit record contains associated character attribute
information and the txFont and txFace
elds combine to forma

inPort

handle to the style record.
A pointer to the graphics port associated with this edit record.

highHook

A pointer to the routine that deals with text highlighting. In

assembly language, the highHook

eld is located at the offset

teHiHook. For more information, see the following section, (The

High Hook and Caret Hook Fields.O
caretHook

A pointer to the routine that controls the appearance of the caret. In
assembly language, the caretHook eld is located at the offset
teCarHook. For more information, see the following section, (The

High Hook and Caret Hook Fields.O
nLines

The number

of lines in the text.

lineStarts

An array containing the character position of the rst character in
each line. It is declared to have 16001 elements to comply with
Pascal range checking. This is a dynamic data structure having only
as many elements as needed. TextEdit calculates these values
internally, so do not change the elements of the lineStarts array.
Because this data structure grows and shrinks, the size of the edit

record changes.

The High Hook and Caret Hook Fields
The highHook and caretHook

eldsN at the offsets teHiHook and teCarHook in

assembly languageN contain the addresses of routines that deal with text highlighting
and the caret. These routines pass parameters in registers; if you replace these routines,
your application must save and restore the registersQrontents.
If you store the address of a routine in teHiHook, that routine is used instead of the
QuickDraw procedure InvertRect, which is called by default, whenever a selection

range is to be highlighted. Your routine can destroy the contents of registers AO, A1, DO,
D1, and D2. On entry, A3 is a pointer to a locked edit record; the stack contains the

rectangle enclosing the text being highlighted. (Use of the A3 register is equivalent to the
InvertRect r parameter of type RECT. See the QuickDraw chapters in Inside Macintosh:
Imaging for more information about the InvertRect procedure.) For example, if you
store the address of the following routine in teHiHook, selection range is underlined
instead of inverted.

2-70

TextEdit Reference

CHAPTER

2

TextEdit

UnderHigh
MOVE.L

4(SP)

,A0

MOVE

bottom

(AO)

SUBQ

#1, top

(A0)

;get

address

of

rectangle

to

be

;highlighted
,top

(A0)

_InverRect

;make

the

;the

bottom

;invert

top

the

coordinate

equal

to

coordinate

minus

resulting

rectangle

1

RTS

The routine whose address is stored in teCarHook acts exactly the same way as the
teHiHook routine, but on the caret instead of the selection range, allowing you to change
the appearance of the caret. The routine is called with the stack containing the rectangle
address that encloses the caret.

The Style Record
The style record stores the character attribute information for the text of a multistyled
edit record. If an edit record has associated character attribute information, its txFont

and txFace elds combine to hold a style handle, of type TESt yleHand1e, to its style
record. The text is divided into style runs, summarized in the style run table, of type
StyleRun, which is part of the style record. Each entry in the style run table gives the
starting character position of a run and an index into the style table, of type
TEStyleTable.

The style table element pointed to by the style run index describes the character
attributes for that run.
To determine the length of a run, you subtract its start position from that of the next entry
in the style run table. A dummy entry at the end of the style run table delimits the length
of the last run; its start position is equal to the overall number of characters in the text,
plus 1. The TEStyleRec data type de nes the style record.
TYPE

TEStyleRec

=

RECORD

nRuns:
nStyles:
styleTab:
lhTab:
teRefCon:
nullStyle:

Integer;
Integer;
STHandle;
LHHandle;
LongInt ;
NullStHandle;

{number of style runs}
{size of style table}
{handle to style table}
{handle to line-height table}
{reserved for application use}
{handle to style set at }
{ null selection}

runs:

ARRAY

OF

[0..8000]

StyleRun;

END ;

TEStylePtr = “TEStyleRec;
TEStyleHandle = “TEStylePtr;

TextEdit Reference

2-71

CHAPTER

2

TextEdit

StyleRun

=

RECORD

startChar:

Integer;

styleIndex:

Integer;

{starting
{index in

character position}
style table}

END;

Field descriptions

nRuns

The number of style runs in the text.

nStyles

The number of distinct sets of character attributes used in the text;

styleTab
lhTab

A handle to the style table.
A handle to the line height table.

teRefCon

A reference constant for use by applications. The application can use
this 32-bit eld to suit its needs.
A handle to the style scrap record used to store the character
attribute information for a null selection.

this forms the size of the style table.

nullstyle
runs

A table of style runs that is of inde nite length.

TEStylePtr = “TEStyleRec;
TEStyleHandle = *“TEStylePtr;
StyleRun

=

RECORD

startChar:

Integer;

styleIndex:

Integer;

{starting
{index in

character position}
style table}

END;

The Style Table
The style table contains one entry for each distinct set of character attributes used in the
text of an edit record. Each entry is de ned ina style element record. The size of the table
is givenbythenStyles eld of the style record. There is no duplication; each set of
character attributes appears exactly once in the table. A reference count tells how many
times each set of attributes is used in the table. The TEStyleTable data type de nes the
style table. The STElement data type de nes the style element record.
TYPE

STElement

=

RECORD

stCount:

Integer;

{number

stHeight:
stAscent :
stFont:
stFace:
stSize:
stColor:

Integer;
Integer;
Integer;
Style;
Integer;
RGBColor ;

{line height}
{font ascent}
{font family ID}
{character style}
{size in points}
{absolute RGB color}

END;

2-72

TextEdit Reference

of

runs

in

this

style}

CHAPTER

2

TextEdit

STHandle

=

STPtr

= “TEStyleTable;

“STPtr;

TEStyleTable

=

ARRAY

[0..1776]

OF

STElement;

Field descriptions
stCount

A reference count of character runs using this set of character
attributes.

stHeight

The line height for this run, in points.

stAscent

The font ascent for this run, in points.

stFont

The font family ID.

stFace

The character style (bold, italic, and so forth). This

stSize

The text size, in points.

stColor

The RGB (red, green, blue) color.

eld consists of

two bytes. The low-order byte contains the character style. TextEdit
uses the high bit (bit 15) of the high-order byte to store the style run
direction: it uses 0 for left-to-right text, and 1 for right-to-left text.

The Line Height Table
The line height table holds vertical spacing information for the text of an edit record. This
table parallels the lineStarts array in the edit record itself. Its length equals the edit
record@nLines eld plus 1 fora dummy entry at the end, just as the lineStarts array
ends with a dummy entry that has the same value as the length of the text. The table@
contents are recalculated whenever the line starting values are themselves recalculated
with the TECalText routine or whenever an editing action causes recalibration.
The line height table is used only if the

lineHeight and

record are negative; positive values in those

elds specify

fontAscent

elds in the edit

xed vertical spacing,

overriding the information in the table. The line height table is of type LHTable, which is

an array of elements of LHElement.
TYPE

LHElement

RECORD

lhHeight:
lhAscent:

Integer;
Integer;

{maximum
{maximum

height
ascent

in
in

line}
line}

END ;

LHPtr = “LHTable;
LHHandle = “LHPtr;
LHTable

=

ARRAY

TextEdit Reference

[0..8000]

OF

LHElement;

2-73

CHAPTER

2

TextEdit

Field descriptions

lhHeight

The line height in points. This is the maximum value for any
individual character attribute in the line.

lhAscent

The font ascent in points; this is the maximum value for any
individual character attribute in a line.

The Null Style Record
The null style record contains the null scrap, which is used to store the character attribute
information for a null selection (insertion point). A number of routines either write this

character attribute information to the null scrap or read it from this scrap (to be applied
to inserted text). The null scrap is created and initialized when an application calls
TEStyleNew to create a multistyled edit record. The null scrap is retained for the life of
the edit record; it is destroyed when TEDispose destroys the edit record and releases the
memory allocated for it.
The Nul1STRec data type de nes the null style record.
TYPE

NullStRec

=

RECORD

teReserved:

LongInt;

{reserved

nullScrap:

StScrpHandle;

for

future

{handle to
{ record}

the

expansion}

style

scrap

}

END;

NullstPtr

=

“*NullStRec;

NullStHandle

=

“NullStPtr;

Field descriptions

teReserved
nullScrap

This eld is reserved for future expansion.
A handle to the style scrap record.

The Style Scrap Record
The style scrap is used for storing character attribute information associated with the
current text selection or insertion point, character attribute information to be applied to
text, or multistyled text that is cut or copied. When multistyled text is cut or copied, the
character attribute information is written to both the style scrap and the desk scrap.
In most cases, the style scrap is created dynamically as needed by routines. However, a
style scrap record can be created directly without using the TEGet Sty leScrapHandle
function; the character attribute information written to it can be applied to inserted text
through TEStyleInsert or to existing text through TEUseStyleScrap.
The format of the style scrap is de ned by a style scrap record of type STScrpRec.

2-74

TextEdit Reference

CHAPTER

2

TextEdit

TYPE

StScrpRec

=

RECORD

scrpNStyles:

Integer;

scrpStyleTab:

{number of sets of }
{ character attributes in scrap}
ScrpSTTable;
{table of attributes for }
{ scrap}

END ;

StSerpPtr

=

StScerpHandle

“StScrpRec;
=

“StSerpPtr;

Field descriptions

scrpNStyles

The number

of style runs used in the text. This determines

the size

of the style table. When character attribute information is written to

the null scrap, this eld is set to 1; when the character attribute
information is removed, this eld is set to 0.

scrpStyleTab

The scrap style table containing an element for each style run.

The Scrap Style Table
The style scrap record contains the scrap style table. Unlike the main style table for an
edit record, the scrap style table may contain duplicate elements; the entries in the table
correspond one-to-one with the style runs in the text. The scrpStartChar eld of each
entry gives the starting position for the run.
The scrpStyleTab data type de nes the scrap style table data structure, which is an
array of scrap style element records. The ScrpSTElement data type de nes each scrap
style element record.
TYPE

ScrpSTElement

=

RECORD

serpStartChar:
scrpHeight:
scrpAscent :
scrpFont:
scrpFace:
scrpSize:
scrpColor:

LongInt;
Integer;
Integer;
Integer;
Style;
Integer;
RGBColor;

{offset to start of style}
{line height }
{font ascent}
{font family ID }
{character style}
{size in points}
{absolute (RGB) color}

END ;

ScrpSTTable

= ARRAY[0..1600]

OF

ScrpSTElement ;

Field descriptions

scrpStartChar

TextEdit Reference

The offset to the beginning of a style record in the scrap.

2-75

CHAPTER

2

TextEdit

scrpHeight

The line height. You can determine the line height and the font

scrpAscent

The font ascent. See scrpHeight.

scrpFont

The font family ID.

scrpFace

The style (such as plain, bold, underline).

scrpSize

The size in points.

scrpColor

The RGB (red, green, blue) color for the style scrap.

ascent using the QuickDraw routine Get Font Info
chapter GQuickDraw TextOin this book.

described in the

Text Style Record
Text style records are used for communicating character attribute information between
the application and several TextEdit routines, such as TECont inuousStyle and
TEReplaceStyle. They carry the same information as the style element records in the
style table, but without the reference count, line height, and font ascent.
The Text Style data type de nes a text style record.
TYPE

TextStyle

=

tsFont:

Integer;

tsFace:

Style;

tsSize:

Integer;

aoa

tsColor:

RGBColor;

~_a

RECORD

font

family

character

number}

style}

size in points}
absolute RGB color}

END;

TextStylePtr = *“TextStyle;
TextStyleHandle = “TextStylePtr;
Field descriptions

tsFont

The font family number.

tsFace

The character style (bold, italic, plain, and so forth).

tsSize

The text size in points.

tsColor

The RGB (red, green, blue) color.

Routines
This section describes the TextEdit routines that an application can call to
m initialize TextEdit and create an edit record
m activate and deactivate an edit record
m set and get the text and character attribute information of an edit record

2-76

TextEdit Reference

CHAPTER

2

TextEdit

m set the caret and selection range
m display and scroll text
m modify the text of an edit record
m manage the TextEdit private scrap
m

check, set, and replace character attributes

m use byte offsets and corresponding points
m toggle automatic scrolling, outline highlighting, and text buffering on and off
m customize TextEdit
Each routine description de nes a Pascal interface, provides related assembly-language
information, and lists possible result codes, if any are returned.

Initializing TextEdit, Creating an Edit Record, and Disposing of an Edit Record
Preparation of a window for text editing involves setting up TextEdit@ internal data
structures by calling the TEInit procedure and creating an edit record for the window
with the TESt yleNew function or the TENew function.

The TESt yleNew function creates a new multistyled edit record. A multistyled edit
record contains text whose attributes, including font, size, and style, can vary from

character to character. The TENew function creates a new monostyled edit record. A
monostyled edit record contains text that is set in a single font, size, and style. Before
either of these functions is called, the window must be in the current graphics port.
The TEDi spose procedure destroys an edit record and releases the memory used for it.
For a complete description of the edit record and its elds, see OAn Overview of the
TextEdit Data StructuresOon page 2-16 and (Data StructuresOon page 2-64.

TEInit
The TEInit

procedure initializes TextEdit.

PROCEDURE

TEInit;

DESCRIPTION

In addition to initialization of miscellaneous global variables, such as TEDoText and

TERecal, the TEInit procedure sets up the private scrap and allocates a handle to it.

Call TEInit

at the beginning of your program after you initialize QuickDraw, the Font

Manager, and the Window Manager, in that order, and before you initialize the Dialog

Manager. You should call TEInit even if your application doesn@®use TextEdit, so that
desk accessories and dialog and alert boxes, which use TextEdit routines, work correctly.

TextEdit Reference

2-77

CHAPTER

2

TextEdit

TEStyleNew
The

TESt yl eNew function creates a multistyled edit record and allocates a handle to it.

FUNCTION

TEStyleNew

(destRect:

Rect;

viewRect:

Rect):

TEHandle;

destRect

The destination rectangle for the new edit record, speci ed in the local
coordinates of the current graphics port. This is the area in which text is
laid out.

viewRect

The view rectangle for the new edit record, speci ed in the local
coordinates of the current graphics port. This is the area of the window in
which text is actually displayed.

DESCRIPTION

Always use the TESt yleNew function to create an edit record for text that uses varying
character attributes. The TESty1eNew function sets the txSize,
lineHeight, and
fontAscent
elds of the edit record to 1, allocates a style record, and stores a handle to

the style record in the txFont and txFace elds. The TEStyl eNew function creates and
initializes a null scrap that is used by TextEdit routines throughout the life of the edit
record.

Call TESt yleNew once for every edit record you want allocated. Your application needs
to store the handle to the edit record that is returned; many routines require it as an input
parameter.

If your application contains more than one window where text editing occurs, you need
to create an edit record for each window.

TENew

The TENew function creates and initializes a monostyled edit record and allocates a
handle to it.
FUNCTION

2-78

TENew

(destRect,viewRect:

Rect):

TEHandle;

destRect

The destination rectangle for the new edit record, speci ed in the local
coordinates of the current graphics port. This is the area in which text is
laid out.

viewRect

The view, or visible, rectangle for the new edit record, speci ed in the local
coordinates of the current graphics port. This is the area of the window in
which text is actually displayed.

TextEdit Reference

CHAPTER

2

TextEdit

DESCRIPTION

A monostyled edit record is one in which all text is restricted to a single font, size, and

style. Use TENew when the text is to be rendered in attributes that are consistent from

character to character. Otherwise, use TEStyleNew.

Call TENew once for every edit record you want allocated. Your application should store
the handle to the edit record that is returned; many routines require it as an input
parameter. The edit record assumes the drawing environment of the graphics port.
If your application contains more than one window where text editing occurs, you need
to create an edit record for each window.

TEDispose
The TEDispose procedure removes a speci
associated with it.
(hTE:

ed edit record and releases all memory

PROCEDURE

TEDispose

TEHandle) ;

hTE

A handle to the edit record for which the allocated memory should be
released.

DESCRIPTION

Call the TEDispose procedure only when youGe completely through with an
edit record.
Note that if your program retains a handle to text associated with the edit record that you
are destroying with TEDispose, the handle becomes invalid because the TEDispose
procedure disposes of it, as well as the dispatch record handle. If the record is
multistyled, TEDispose also disposes all of the style-related handles: STHandle,
LHHandle,

STScrpHandle,

nul1STHandle,

and TEStyleHandle.

To continue to refer to the text after youWe destroyed the edit record, you need to make a
copy of the handle in the hText eld of the edit record using the Operating System
Utilities HandToHand function before you call TEDi spose. (See Inside Macintosh:
Operating System Utilities for more information.)
In addition to disposing of the edit record, the edit record handle, and the dispatch record

handle, the TEDispose procedure destroys the null scrap associated with the edit record
and releases the memory used for it.

TextEdit Reference

2-79

CHAPTER

2

TextEdit

Activating and Deactivating an Edit Record
When your application receives noti cation of an activate event, it can call the
TEActivate procedure, which activates an edit record and highlights the selection
range or displays a caret at the insertion point. When the activate event fag is set to
deactivate the window, your application can call the TEDeactivate procedure, which
changes an edit record@ status from active to inactive and removes the selection range
highlighting or the caret. (When outline highlighting is on, TEDeact ivate frames the

text or displays a dimmed caret.)

TEActivate
The TEActivate procedure activates the speci

ed edit record.

PROCEDURE

;

hTE

TEActivate

(hTE:

A handle to the speci

TEHandle)

ed edit record.

DESCRIPTION

When you call TEAct ivate for an edit record, the selection range is highlighted. If the
selection range is an insertion point, TEActivate displays a caret there.
Call this procedure every time the Event Manager function WaitNext Event reports that
the window containing the edit record has become active.
If you do not call TEAct ivate before you call TEClick,

TEI dle, or

TESet Select,

the

selection range is not highlighted, or, if the selection range is set to an insertion point, a
caret is not displayed at the insertion point. However, if you have turned on outline
highlighting through the TEFeatureFlag function for the edit record, the text of the
selection range is framed or a dimmed or an unblinking caret is displayed at the insertion
point.

SEE ALSO
For a description of the WaitNextEvent function, see the chapter Event ManagerOin
Inside Macintosh: Macintosh Toolbox Essentials.

TEDeactivate
The TEDeactivate procedure deactivates an edit record.
PROCEDURE

hTE

2-80

TEDeactivate

(hTE:

A handle to the speci

TextEdit Reference

TEHandle) ;

ed edit record.

CHAPTER

2

TextEdit

DESCRIPTION

When you call TEDeactivate for an edit record, the highlighted selection range is no
longer displayed. If the selection range is an insertion point, TEDeactivate no longer
displays the caret. However, if you turned on outline highlighting through the
TEFeatureFlag function for the edit record, the text of the selection range is framed

or a dimmed or an unblinking caret is displayed at the insertion point when the record
is deactivated.
Call this procedure every time the Event Manager function WaitNextEvent reports that
the window containing the edit record has become inactive.

SEE ALSO

For a description of the WaitNext Event function, see the chapter GEvent ManagerOin
Inside Macintosh: Macintosh Toolbox Essentials.

Setting and Getting an Edit Record@ Text and Character Attribute Information
The TextEdit procedure TEKey allows you to handle key-down events and enter text
input through the keyboard. The procedure TESet Text lets you incorporate existing text
into the text buffer of an edit record. Once an edit record contains text, you can use the
TEGet Text function to get a handle to the text itself. For a multistyled edit record, you
can get a handle to the style record by calling Get StyleHand1le. You can set the handle
to the style record using the TESet Styl eHandl1le procedure. This section describes these
routines.

TEKey
The TEKey procedure replaces the selection range in the text of the speci ed edit record
with the input character and positions the insertion point just past the inserted character.
PROCEDURE

TEKey

(key:

Char;

hTE:

TEHandle)

;

key

The input character.

hTE

A handle to the edit record in whose text the character is to be entered.

DESCRIPTION
If the selection range is an insertion point, TEKey inserts the character. (ITwo-byte
characters are passed one byte at a time.) If the key parameter contains a backspace
character, the selection range or the character immediately before the insertion point is
deleted. When the primary line direction is right-to-left, the character to the right of the
insertion point is deleted. When the primary line direction is left-to-right, the character to
the left of the insertion point is deleted.

TextEdit Reference

2-81

CHAPTER

2

TextEdit

When the user deletes text up to the beginning of a set of character attributes, TEKey
saves the attributes in the null scrap@ style scrap record. The attributes are saved
temporarily to be applied to characters inserted after the deletion. As soon as the user
clicks in another area of the text, TEKey removes the attributes. TEKey redraws the text

as necessary.

Call TEKey every time the Event Manager function WaitNextEvent reports a keyboard
event that your application determines should be handled by TextEdit.
Because TEKey inserts every character passed in the key parameter, your application
must lter all characters which aren@actual text, such as keys typed in conjunction with
the Command key.
SEE ALSO
For a description of the WaitNextEvent function, see the chapter Event ManagerOin
Inside Macintosh: Macintosh Toolbox Essentials.

TESetText
The TESet Text procedure incorporates a copy of the speci
edit record.
PROCEDURE

TESetText

(text:

Ptr;

length:

ed text into the designated

LongInt;

hTE:

TEHandle) ;

text

A pointer to the text to be copied and incorporated.

length

The number of characters in the text to be incorporated.

hTE

A handle to the edit record into which the text is to be copied.

DESCRIPTION
The TESet Text procedure copies the speci ed text into the existing hText handle of the
edit record, resizing the buffer, if necessary; it doesn®bring in the original text. The
copied text is wrapped to the destination rectangle, and its lineStarts and nLines
elds are calculated accordingly. The selection range is set to an insertion point at the end
of the incorporated text. The TESet Text procedure does not display the copied text on
the screen. To do this, call TEUpdate.

2-82

TextEdit Reference

CHAPTER

2

TextEdit

TEGetText
The

TEGet Text function returns a handle to the text of the speci

FUNCTION

TEGetText

hTE

(hTE:

TEHandle):

ed edit record.

CharsHandle;

A handle to the edit record containing the text whose handle you want
returned. You pass this handle as an input parameter.

CharsHandle

A handle to the text of the edit record.

DESCRIPTION

The TEGet Text function doesn®make a copy of the text. Rather, it returns the handle to
the text which is stored as a packed array of characters. (This handle belongs to TextEdit;
your application must not destroy it.) The teLength eld of the edit record contains the
length of the text whose handle is returned.
The handle of type CharsHand1e that is returned by TEGet Text corresponds to the
hText eld of the edit record, but the data type is de ned as follows:
TYPE

CharsHandle

=

“CharsPtr;

CharsPtr

=

“Chars;

Chars

PACKED

ARRAY[0..32000]

OF

CHAR;

TESetStyleHandle
The TESet
St
yleHandle procedure sets an edit record@ style handle, which is stored in
the txFont andtxFace elds.
PROCEDURE

TESetStyleHandle

(theHandle:
hTE:

TEStyleHandle;

TEHand1le) ;

theHandle

The style handle to be set in the combined txFont and txFace
the speci ed edit record.

hTE

A handle to the edit record.

elds of

DESCRIPTION

The TESet
St

yleHandle procedure has no effect on monostyled edit records.

Your application should always use
elds of the edit record directly.

TextEdit Reference

TESet Styl eHand1e rather than manipulate the

2-83

CHAPTER

2

TextEdit

TEGetStyleHandle
The TEGet Styl eHand1le function returns the style handle stored in the designated
edit record@ txFont and txFace elds. The style handle points to the associated
style record.
FUNCTION

hTE

TEGetStyleHandle

(hTE:

TEHandle):

TEStyleHandle;

A handle to the multistyled edit record containing the style handle to
be returned.

DESCRIPTION

The TEGet Styl eHand1le function returns a handle to the style record (of type
TEStyleRec), not a copy of it. Because only multistyled edit records have style records,
TEGet StyleHand1le returns NIL when used with a monostyled edit record. To ensure
future compatibility, your application should always use this function rather than
manipulate the elds of the edit record directly.

Setting the Caret and Selection Range
Your application can call TEI dle to blink a caret at an insertion point during idle
processing, the TEClick procedure to control the placement and highlighting of the text
selection range in response to mouse-down events generated when a user clicks the
mouse button, and the TESet Select procedure to set the text selection range to be
edited next or denote the insertion point. This section describes these routines.

TEIdle
When called repeatedly, the TEIdle procedure displays a blinking caret at the insertion
point, if any exists, in the text of the speci ed edit record of an active window.
PROCEDURE

hTE

TEIdle

(hTE:

TEHandle)

;

A handle to the edit record.

DESCRIPTION
You need to call TEIdle only when the window containing the text is active; the caret is
blinked only then. TextEdit observes a minimum blink interval, initially set to 32 ticks.
No matter how often you call TEI dle, the time between blinks is never less than the

minimum interval. (The user can adjust the minimum interval setting with the General
Controls control panel.)

2-84

TextEdit Reference

CHAPTER

2

TextEdit

To maintain a constant frequency of blinking, you need to call TEId1le at least once each
time through your main event loop. Call it more than once if your application does an
unusually large amount of processing each time through the loop.
Call the Event Manager@ Get Caret Time function to get the blink rate. (See the chapter
CEvent ManagerOin Inside Macintosh: Macintosh Toolbox Essentials.)

TEClick
The TEClick procedure controls placement and highlighting of the selection range as
determined by mouse events.
PROCEDURE

TEClick

pt

extend

(pt:

Point;

extend:

Boolean;

hTE:

TEHandle) ;

The mouse location in local coordinates at the time the mouse button was

pressed, obtainable from the event record (in global coordinates).

A Sag denoting the state of the Shift key at the time of the click as
indicated by the Event Manager. If the Shift key was held down at the
time of the click to extend the selection, pass a value of TRUE.

hTE

A handle to the edit record whose text is displayed in the view rectangle
where the click occurred.

DESCRIPTION

Call TEC1lick whenever a mouse-down event occurs in the view rectangle of the edit
record and the window associated with that edit record is active. The TEClLick
procedure keeps control until the mouse button is released. Use the QuickDraw
procedure GlobalToLocal to convert the global coordinates of the mouse location
given in the event record to the local coordinate system for pt.
The TEClick procedure removes highlighting of the old selection range unless the
selection range is being extended. If the mouse moves, meaning that a drag is occurring,
TEC1ick expands or shortens the selection range accordingly a character at a time. In the
case of a double-click, the word where the cursor is positioned becomes the

selection range.

SEE ALSO

For more information about the Global ToLocal

chapters in Inside Macintosh: Imaging.

TextEdit Reference

procedure, see the QuickDraw

2-85

CHAPTER

2

TextEdit

TESetSelect
The TESet Select
edit record.
PROCEDURE

procedure sets the selection range within the text of the speci

TESetSelect

(selStart,

selEnd:

LongInt;

selStart

The byte offset at the start of the text selection range.

selEnd

The byte offset at the end of the text selection range.

hTE

A handle to the edit record.

hTE:

ed

TEHandle) ;

DESCRIPTION

The TESet Select procedure removes highlighting of the old selection range and
highlights the new one. If selStart equals selEnd, the new selection range is an
insertion point, and a caret is displayed. If sel End is anywhere beyond the last character
of the text, TESet Select uses the rst position past the last character. The selEnd and
selStart elds can range from 0 to 32767.

SPECIAL CONSIDERATIONS

When only the Roman script system is used, the selection range is always displayed and
highlighted as a continuous range of text. However, when one or more script systems
requiring mixed-directional display of text are installed, a continuous sequence of
characters in memory may appear as a discontinuous selection when displayed.
Displaying and Scrolling Text
The routines that this section describes let you control how text is displayed.
TESetAlignment lets you specify whether text is to be right aligned, left aligned, or
centered. TEUpdate draws the text, updating the text editing window. TEText
Box lets
you draw static text in a box, such as a dialog box, without requiring that you rst create
an edit record. TECal Text recalculates line breaks. TEGet Height returns the height of
all the lines of text between two lines. TEScro11 scrolls the text by the amount you
specify. TEPinScrol1 scrolls the text, automatically stopping when it scrolls the last line
into view. TEAut oView lets you turn automatic scrolling on or off. TESel View
automatically scrolls the text into view, if automatic scrolling is turned on through
TEAutoView.

2-86

TextEdit Reference

CHAPTER

2

TextEdit

TESetAlignment
The TESetAlignment procedure sets the alignment of the speci ed text in an edit
record so that it is centered, right aligned, or left aligned, or aligned according to the
line direction.
PROCEDURE

TESetAlignment

(align:

Integer;

hTE:

align

The alignment for the speci

hTE

A handle to the edit record containing the text.

TEHandle) ;

ed text.

DESCRIPTION
You can use the following constants to specify the text alignment through the
align parameter.

Constant

Value

Description

teFlushDefault

0

Align according to primary line direction

teCenter

1

Centered for all scripts

teFlushRight

1

Right aligned for all scripts

teFlushLeft

2

Left aligned for all scripts

For compatibility, the previous names of these constants are still supported. They are
teJustLeft,

teJustCenter,

The default value of the just

teJustRight,

and teForceLeft.

eld of the edit record is teFlushDefault. This means

that text alignment is based on the primary line direction which is set by default
according to the system script.

For languages that are read from right to left, text is right aligned by default. For
languages that are read from left to right, text is left aligned by default. If you change the
alignment, call the InvalRect procedure after TESetAlignment to redraw the text
with the new alignment.
TextEdit does not support justi ed alignment. To draw justi ed text, use the QuickDraw
‘Text routines.
SEE ALSO
For more information about the InvalRect procedure, see the chapter Window
ManagerOin Inside Macintosh: Macintosh Toolbox Essentials. For more information about
drawing justi ed text, see the chapter GQQuickDraw TextOin this book.

TextEdit Reference

2-87

CHAPTER

2

TextEdit

TEUpdate
The TEUpdate procedure draws the speci
(rUpdate:

ed text within a given update rectangle.

PROCEDURE

TEUpdate

Rect;

hTE:

TEHandle) ;

rUpdate

The update rectangle, given in the coordinates of the current graphics
port, where the speci ed text is to be drawn.

hTE

A handle to the edit record containing the text to be drawn.

DESCRIPTION

Call TEUpdate every time the Event Manager function WaitNextEvent reports an
update event for a text editing windowN after you call the Window Manager procedure
BeginUpdate, and before you call the EndUpdate procedure. You also need to erase the
update region with the EraseRect procedure. If you don@the caret can sometimes
remain visible when the window is deactivated.

SEE ALSO

For a description of the WaitNextEvent function, see the chapter Event ManagerOin
Inside Macintosh: Macintosh Toolbox Essentials. For more information about the
BeginUpdate and EndUpdate procedures, see the chapter OWindow ManagerOin Inside
Macintosh: Macintosh Toolbox Essentials.

TETextBox

The TEText Box procedure draws the indicated text in a given rectangle with the
speci ed alignment.
PROCEDURE

TETextBox

(text:
align:

2-88

Ptr;

length:

LongInt;

box:

Rect;

Integer) ;

text

A pointer to the text to be drawn.

length

The number of bytes comprising the text.

box

The rectangle where the text is to be drawn. The rectangle is speci ed in
local coordinates (of the current graphics port) and must be at least as
wide as the rst character drawn. (A good rule of thumb is to make the
rectangle at least 20 pixels wide.)

align

The kind of alignment for the speci ed text.

TextEdit Reference

CHAPTER

2

TextEdit

DESCRIPTION
The

TEText Box procedure provides you with an easy way to display static text to a user.

It creates its own monostyled edit record, which it deletes when

nished with it, so you

cannot edit the text it draws. The TEText Box procedure breaks a line of text correctly.
You can specify how text is aligned in the box using any of the following alignment
constants:
Constant

Description

teFlushDefault

Aligned according to primary line direction

teCenter

Centered for all scripts

teFlushRight

Right aligned for all scripts

teFlushLeft

Left aligned for all scripts

TECalText
The TECalText procedure recalculates the beginnings of all lines of text in the speci
edit record.
PROCEDURE

TECalText

(hTE:

TEHandle)

hTE

A handle to the edit record whose text lines are to be recalculated.

ed

;

DESCRIPTION
The TECal Text procedure updates elements of the 1ineStarts array in an edit record.
Call TECal Text if youe changed the destination rectangle, the hText eld, or any
other property of the edit record that pertains to line breaks and the number of characters
per lineN for example, font, size, style, and so on.

ASSEMBLY-LANGUAGE

INFORMATION

The low-memory global variable TERecal contains the address of the routine called by
TECalText to recalculate the line starts and set the rst and last characters that need to
be redrawn. The TERecal default hook routine calls the Text Utilities
StyledLineBreak function. If you replace the default TERecal hook routine with a
customized version and your application supports non-Roman script systems, make sure
that your customized hook routine is script-aware. The registers on entry and exit for this
hook routine are:
Registers on entry
A3

Pointer to the locked edit record

D7

Change in the length of the record (word)

TextEdit Reference

2-89

CHAPTER

2

TextEdit

Registers on exit

D2

Line start of the line containing the

rst character to be redrawn (word)

D4

Position of last character to be redrawn (word)

TextEdit uses the low-memory global variable WordRedraw widely, but primarily for line
calculations and to determine how much of a line to redraw after the user types ina
character. TextEdit sets the correct value for WordRedraw in TEInit based upon the
installed script systems. If a 2-byte script is installed, TEInit performs an OR operation
on WordRedraw

with a 1; if a right-to-left script is installed, TEInit

performs an OR

operation on WordRedraw with an $FF. The size of this global is one byte.
TextEdit interprets the
Value

nal value of WordRedraw as follows:

Description

0

Redraws the character before the entered character.

1

Redraws the word before the entered character.

$FF

Redraws the whole line.

TEGetHeight
The TEGetHeight function returns the total height of all of the lines in the text between
and including the speci ed starting and ending lines.
FUNCTION

TEGetHeight

(endLine,
hTE:

startLine:

TEHandle):

LONGINT;

INTEGER;

endLine

The number of the last line of text whose height is to be included in the
total height. You can specify a value that is greater than or equal to 1 for
this parameter.

startLine

Thenumber ofthe rst line of text whose height is to be included in the
total height. You can specify a value that is greater than or equal to 1 for
this parameter.

hTE

A handle to the edit record containing the lines of text whose height is to
be returned.

DESCRIPTION

For monostyled text, the TEGetHeight function uses the value of the edit record@
lineHeight

eld. For multistyled text, it uses the line height element (LHElement) of

the line height table (LHTable). Note that TEGetHeight does not take into account
the height of any blank lines at the end of the text. You need to consider this
when scrolling text.

2-90

TextEdit Reference

CHAPTER

2

TextEdit

TEScroll
The TEScrol11 procedure scrolls the text within the view rectangle of the speci
record by the designated number of pixels.
(dh,dv:

Integer;

hTE:

ed edit

PROCEDURE

TEScroll

TEHandle) ;

dh

The distance in pixels that the text is to be scrolled horizontally. A positive
value moves the text to the right; a negative value moves the text to
the left.

dv

The distance in pixels that the text is to be scrolled vertically. A positive
value moves the text down; a negative value moves the text up.

hTE

A handle to the edit record whose text is to be scrolled.

DESCRIPTION
The TEScrol1 procedure updates the text on the screen automatically to refsect the new
scroll position. The destination rectangle is offset by the amount scrolled. The TEScrol11
and TEPinScrol1 procedures behave the same, except that TEPinScrol11 stops
scrolling when the last line of text is scrolled into view.

TEPinScroll
The TEPinScrol1 procedure scrolls the text within the view rectangle of the speci ed
edit record by the designated number of pixels. Scrolling stops when the last line of text
is scrolled into view.
PROCEDURE

TEPinScroll

(dh:

Integer;

dv:

Integer;

hTE:

TEHandle) ;

dh

The distance in pixels that the text is to be scrolled horizontally. A positive
value moves the text to the right; a negative value moves the text to
the left.

dv

The distance in pixels that the text is to be scrolled vertically. A positive
value moves the text down; a negative value moves the text up.

hTE

A handle to the edit record whose text is to be scrolled.

DESCRIPTION
The TEPinScrol1l procedure updates the text on the screen automatically to refSect the
new scroll position, as does the TEScrol1 procedure. The destination rectangle is offset
by the amount scrolled. When the edit record is longer than the text it contains,
TEPinScrol1 displays up to the last line of text inclusive, and not beyond it.

TextEdit Reference

2-91

CHAPTER

2

TextEdit

TEAutoView
The TEAutoView procedure enables and disables automatic scrolling of the text in the
speci ed edit record.
PROCEDURE

TEAutoView

(fAuto:

Boolean;

hTE:

TEHandle) ;

fAuto

A Sag indicating whether to enable or disable automatic scrolling. A value
of TRUE enables automatic scrolling. A value of FALSE disables automatic
scrolling.

hTE

A handle to the edit record for which automatic scrolling is to be enabled
or disabled.

DESCRIPTION

The TEAut oView procedure does not actually scroll the text automatically:

TESel View

does. However, when fAuto is set to FALSE, a call to TESe1View has no effect.

If there is a scroll bar associated with the edit record, your application must manage
scrolling of it. You can replace the default click loop routine, which scrolls the text only,
with a customized version that also updates the scroll bar.
You can also enable or disable automatic scrolling for an edit record through the
teFAutoScrol1

feature of the TEFeatureFlag function.

SEE ALSO
For more information, see (fEFeatureFlagOon page 2-107.

TESelView
Once automatic scrolling has been enabled by a call to the TEAut oView procedure or
through the TEFeatureFlag function, the TESe1View procedure ensures that the

selection range is visible and scrolls it into the view rectangle if necessary.
PROCEDURE

hTE

TESelView

(hTE:

TEHandle)

;

A handle to the edit record containing the text selection range.

DESCRIPTION
The top left part of the selection range is scrolled into view. If the text is displayed ina
rectangle that is not high enough, automatic scrolling can cause text to appear to fSicker. If
automatic scrolling is disabled, TESe1View has no effect.

2-92

TextEdit Reference

CHAPTER

2

TextEdit

SEE ALSO

For more information, see OfEFeatureFlagOon page 2-107.

Modifying the Text of an Edit Record
Although all of the TextEdit routines provide and support editing capabilities, the set of
routines described in this section implement the standard Macintosh editing features. An
application can use these routines to delete, insert, cut, copy, or paste multistyled or
monostyled text. The routines that you use for these purposes are TEDelete to remove a
selected range of text, TEInsert to insert text, TECut to remove the text, but save it to be

inserted, TECopy to copy the selected text with affecting the selection range, TEPaste to
replace the selected text with the text in the private scrap, without applying character
attribute information, TEStylePaste to replace the selected text with text and its
character attribute information from the desk scrap, and TEToScrap and TEFromScrap

to move monostyled text across applications or between applications and a desk
accessory.

TEDelete
The TEDelete procedure removes the selected range of text from the text of the
designated edit record and redraws the remaining text as necessary.
PROCEDURE

TEDelete

(hTE:

TEHandle) ;

hTE

A handle to the edit record containing the text to be deleted.

DESCRIPTION

When the TEDelete procedure deletes a selected range of text, it does not transfer the
text to either the private scrap or the Scrap Manager@ desk scrap.
For multistyled records, when you use TEDelete to delete a selected range of text, the
associated character attributes are saved in the null scrap to be applied to characters
entered after the text is deleted. When the user clicks in some other area of the text, the

character attributes are removed from the null scrap. You can use TEDelete to
implement the Clear command. The TEDelete procedure recalculates line starts and
line heights.

TextEdit Reference

2-93

CHAPTER

2

TextEdit

TEInsert

The TEInsert procedure inserts the speci ed text immediately before the selection
range or the insertion point in the text of the designated edit record, redrawing the
text as necessary.
PROCEDURE

TEInsert

(text:

Ptr;

length:

LongInt;

hTE:

TEHandle) ;

text

A pointer to the text to be inserted.

length

The number of characters to be inserted.

hTE

A handle to the edit record containing the text buffer into which the new
text is to be inserted.

DESCRIPTION

When you call the TEInsert procedure and a range of text is selected, TEInsert
doesn@affect the selection range. The TEInsert procedure does not check for a 32 KB
limit, so your application must ensure that the inserted text does not exceed this text size
limit of 32 KB. The TEInsert procedure recalculates line starts and line heights to adjust
for the inserted text.

TECut
The TECut procedure removes the current selection range from the text of the designated
edit record, redrawing the text as necessary.
PROCEDURE

hTE

TECut

(hTE:

TEHandle) ;

A handle to the edit record containing the text to be cut.

DESCRIPTION

For monostyled text, the TECut procedure writes the cut text to the private scrap.
For multistyled text, TECut writes the cut text to the private scrap and its character
attributes to the style scrap; it also writes both to the Scrap ManagerG@ desk scrap. For
multistyled text, the TECut procedure removes the character attributes from the style
record@ style table when the text is cut.
For both monostyled and multistyled text, if the selection range is an insertion point,
TextEdit deletes everything from the private scrap. When the selection range is an
insertion point and the text is multistyled, TECut has no effect on the style scrap or the
Scrap Manager@ desk scrap.

2-94

TextEdit Reference

CHAPTER

2

TextEdit

SEE ALSO

For more information about the desk scrap, see the chapter crap ManagerOin

Inside Macintosh: More Macintosh Toolbox.

TECopy
The TECopy procedure copies the text selection range from the edit record, leaving the
selection range intact.

PROCEDURE

TECopy

(hTE:

TEHandle) ;

hTE

A handle to the edit record containing the text to be copied.

DESCRIPTION

The TECopy procedure copies the text to the private scrap. For text of a monostyled edit
record, the text is written to the private scrap only. For text of a multistyled edit record,
the text is written to the TextEdit private scrap, the character attribute information is
written to the TextEdit style scrap, and both are written to the Scrap Manager@ desk
scrap. Anything previously in the private scrap is deleted before the copied text is written
to it.
For both multistyled and monostyled text, if the selection range is an insertion point,
TECopy empties the TextEdit private scrap. When the selection range is an insertion
point and the text is multistyled, TECopy has no effect on the null scrap, the style scrap,
or the Scrap Manager@ desk scrap.

SEE ALSO

For more information about the desk scrap, see the chapter Scrap ManagerOin
Inside Macintosh: More Macintosh Toolbox.

TEPaste

The TEPaste procedure replaces the edit record@ selected text with the contents of the
private scrap and leaves an insertion point after the inserted text. If the selection range is
an insertion point, TEPaste inserts the contents of the private scrap there.
PROCEDURE

TEPaste

hTE

A handle to the edit record into which the text is to be pasted.

TextEdit Reference

(hTE:

TEHandle) ;

2-95

CHAPTER

2

TextEdit

DESCRIPTION

When you call TEPaste, after it pastes the text from the private scrap, it redraws all
of the text as necessary. If the private scrap is empty, TEPaste deletes the selection range.
If you call TEPaste for a multistyled edit record, it pastes only the text in the private
scrap. In this case, TEPaste ignores any associated character attribute information stored
in the style scrap; instead, it applies the character attributes of the rst character of the
selection range being replaced to the text. If the selection range is an insertion point,
TEPaste applies the character attributes of the character preceding
the insertion point.

TEStylePaste
The TEStylePaste procedure pastes text and its associated character attribute
information from the desk scrap into the edit record@ text at the insertion pointN if the
current selection range is an insertion pointN or it replaces the current selection range.
PROCEDURE

TEStylePaste

hTE

(hTE:

TEHandle) ;

A handle to the edit record into which the text is to be pasted.

DESCRIPTION

When you call TEStylePaste and there is no character attribute information associated
with text in the desk scrap, TEStylePaste rst checks the null scrap. If the null scrap
contains character attribute information, this is used. If the null scrap is empty,
TEStylePaste gives the text the same attributes as those of the rst character of
the replaced selection range or that of the preceding character if the selection is an
insertion point.
For a monostyled edit record, TEStylePaste pastes the text only; there is no associated
character attribute information because all the text uses the same attributes.

2-96

TextEdit Reference

CHAPTER

2

TextEdit

TEToScrap
The TEToScrap function copies the contents of the TextEdit private scrap to the
desk scrap.
FUNCTION

TEToScrap:

OSErr;

DESCRIPTION
You use the TEToScrap function to move monostyled text across applications or
between an application and a desk accessory. Call the Scrap Manager function
ZeroScrap to initialize the desk scrap or clear its contents before calling TEToScrap.
ASSEMBLY-LANGUAGE INFORMATION
Copy the contents of the private scrap to the desk scrap by calling the Scrap Manager
function Put Scrap; you can get the values you need from the global variables
TEScrpHandle
and TEScrpLength.

RESULT CODES
noErr
noScrapErr

0
100

No error
.
Desk scrap isn@initialized

SEE ALSO
For more information about the

Put Scrap

function, the ZeroScrap function, and the

desk scrap, see the chapter Scrap ManagerOin Inside Macintosh: More Macintosh Toolbox.

TEFromScrap
The TEFromScrap function copies the contents of the desk scrap to the TextEdit
private scrap.
FUNCTION

TEFromScrap:

OSErr;

DESCRIPTION
You use this function to move monostyled text across applications or between an
application and a desk accessory.

TextEdit Reference

2-97

CHAPTER

2

TextEdit

ASSEMBLY-LANGUAGE

INFORMATION

You can store a handle to the desk scrap in the global variable TEScrpHandle and the
size of the desk scrap in the global variable TEScrpLength; get the desk scrap@ handle
and size by calling the Scrap Manager@ InfoScrap function.

RESULT CODE

noErr

0

No error

SEE ALSO

For more information about the InfoScrap function and the desk scrap, see the chapter
(Scrap ManagerOin Inside Macintosh: More Macintosh Toolbox.

Managing the TextEdit Private Scrap
This section describes the routines that you use to manage the private scrap. You use the
TEScrapHand1e function get a handle to the private scrap, the TEGet ScrapLength
function to determine its size, and the

TESet

ScrapLength

procedure to set its size.

TEScrapHandle
The TEScrapHandl1e function returns a handle to the TextEdit private scrap.
FUNCTION

TEScrapHandle:

Handle;

ASSEMBLY-LANGUAGE INFORMATION
You can get the handle to the private scrap from the global variable TEScrpHandle.

TEGetScrapLength
The

TEGet ScrapLength

FUNCTION

ASSEMBLY-LANGUAGE

function returns the size of the TextEdit private scrap in bytes.

TEGetScrapLength:

LongInt;

INFORMATION

You can get the size of the private scrap in bytes from the global
variable TEScrpLength.

2-98

TextEdit Reference

CHAPTER

2

TextEdit

TESetScrapLength
The TESet ScrapLength procedure sets the size of the TextEdit private scrap
to the speci ed number of bytes.
PROCEDURE

TESetScrapLength

length

The size of the private scrap in bytes.

ASSEMBLY-LANGUAGE

(length:

LongInt) ;

INFORMATION

You can set the global variable TEScrpLength to the size of the private scrap.

Checking, Setting, and Replacing Styles
The routines described in this section let you manipulate the character attribute
information associated with a range of text. You can use the following routines to set,
replace, or copy character attribute information, or to check aspects of the text@ character
attributes. These routines are
TEStylelInsert,

TESet Style, TEReplaceStyle, TEContinuousStyle,

TEGetStyleScrapHandle,

TEUseStyleScrap,

and

TENumStyles.

Note
In the original Inside Macintosh documentation the term style was used to
refer to the text font, size, style (face), and color. In this chapter the term

character attributes is used instead. This is so that the term style can be
used consistently throughout all of the documentation to refer to the

following text style attributes: bold, italic, underline, outline, condense,
extend, and shadow. In the past, the term face, which is now obsolete,

was used to refer to these attributes instead of style.

TESetStyle
The TESet Style procedure sets new character attributes for the current selection range
in the speci ed edit record.
PROCEDURE

TESetStyle

(mode:
redraw:

mode

Integer;
Boolean;

newStyle:
hTE:

TextStyle;

TEHandle) ;

A selector that speci es which character attributes are to be changed. The
value for mode can be any additive combination of the mode constants for
font, style, type size, color, and so forth.

newStyle

Arecord of type TextStyle that speci es the new attributes to be set.
This record contains the character attributes to be applied to the current
selection range based on the value of mode.

TextEdit Reference

2-99

CHAPTER

2

TextEdit

redraw

A Sag that speci es whether or not TextEdit should immediately redraw
the affected text to refSect the new character attribute changes. A value of
TRUE causes the text to be redrawn immediately. Line breaks, line heights,
and line ascents are recalculated. A value of FALSE delays redrawing until
another event forces the update.

hTE

A handle to the multistyled edit record containing the selected text.

DESCRIPTION

The TESet Style procedure has no effect on a monostyled record. You can use any
combination of the following constants to specify a value for the mode parameter. The
value of mode speci es which existing character attributes are to be changed to the new
character attributes speci ed by newStyle.
Constant

Value

Description

doFont

1

Sets the font family ID

doFace

2

Sets the character style

doSize

4

Sets the type size

doColor

8

Sets the color

doAll

15

Sets all attributes

addSize

16

Increases or decreases the current type size

doToggle

32

Modi

es the mode

If doToggle is speci ed along with doFace and if an attribute speci ed in the given
newStyle parameter exists across the entire selected range of text, then TESet Style
removes that attribute. Otherwise, if the attribute doesn@exist across the entire selection

range, all of the selected text is set to include that character attribute.

If the redraw parameter is set to TRUE, TextEdit redraws the current selection range

using the new character attributes, recalculating line breaks, line heights, and line

ascents. If the redraw parameter is set to FALSE, TextEdit does not redraw the text or

recalculate line breaks, line heights, and line ascents. Consequently, when you call a
routine that uses any of this information, such as TEGet Height

height between two speci

(which returns a total

ed lines), it does not refSect the new character attributes set

with TESetSty1Le. Instead, the routine uses the information that was available before
TESet Style was called. To update this information, call the TECalText procedure. (See

(YECalTextOon page 2-89 for more information.) To be certain that the new information
is always refSected, call the TESet Style procedure with the redraw parameter set to
TRUE.

If you call the TESet Style routine when the value of the selStart eld of an edit
record equals the value of the selEnd_ eld (specifying an insertion point), TextEdit
stores the input character attributes in the null scrap record pointed to by the null
style handle.

2-100

TextEdit Reference

CHAPTER

2

TextEdit

TEReplaceStyle
The TEReplaceStyle procedure replaces any character attributes in the current
selection range that match the speci ed existing character attributes with the speci ed
new character attributes.
PROCEDURE

TEReplaceStyle

(mode:

INTEGER;

oldStyle,newStyle:
redraw:
mode

BOOLEAN;

TextStyle;
hTE:

TEHand1le);

A selector that speci es which attributes to replace. It corresponds to any
additive combination of the mode constants for font, character style, type
size, color, and so forth.

oldsStyle

A pointer to a text style record that speci es the current character
attributes to search for in the selected text.

newStyle

A pointer to a text style record that speci es the new attributes to be set.
This record contains the character attributes to be applied to the current
selection range based on the value of mode.

redraw

A Sag that speci es whether or not TextEdit should immediately redraw
the text to refSect the attribute changes. A value of FALSE delays
redrawing until another event forces the update. A value of TRUE causes
the text to be redrawn immediately using the new character attributes.

hTE

A handle to the multistyled edit record containing the text selection whose
character attributes are to be changed.

DESCRIPTION

The TEReplaceStyle procedure replaces any attribute in the current selection range
that matches the attribute speci ed by oldStyle with that given by newStyle. Only
the character attributes speci ed by mode are affected.
Attribute changes are made directly to the style elements (STE1lement) within the style
table itself (TEStyleTab1le). If you specify the value doA11 for the mode parameter,
newStyle replaces oldStyle outright. Possible values for the mode parameter are
de ned by the following constants. The TEReplaceStyle procedure has no effect on a
monostyled edit record.
Description

Constant

Value

doFont

1

Sets the font family ID

doFace

2

Sets the character style

doSize

4

Sets the type size

doColor

8

Sets the color

doAll

15

Sets all attributes

addSize

16

Increases or decreases the current type size

TextEdit Reference

2-101

CHAPTER

2

TextEdit

TEContinuousStyle
The TECont inuousStyle function determines whether a given character attribute is
continuous over the current selection range.
FUNCTION

TEContinuousStyle

(VAR

mode:

VAR

aStyle:

hTE:

Integer;
TextStyle;

TEHandle):

Boolean;

mode

On input, a selector specifying the attributes to be checked. On output,
mode identi es only those attributes determined to be continuous over the
selection range.

aStyle

On input, a text style record. On output, this record contains the values for
the mode attributes determined to be continuous over the selection.

hTE

A handle to the edit record containing the selected text whose attributes
are to be checked.

DESCRIPTION

This function does not modify the text selection. Possible values for the mode parameter
are de ned by the following constants.
Constant

Value

doFont

1

Speci

es the font family ID

doFace

2

Speci

es the character style

doSize

4

Speci

_es the type size

doColor

8

Speci

es the color

doAll

15

Speci

es all the attributes

The

inuousStyle

TECont

Description

function returns TRUE if all of the attributes to be checked are

continuous and returns FALSE

if none or some are continuous.

If the current selection range is an insertion point, TEContinuousStyle

rst checks the

null scrap. If the null scrap contains character attributes, then they are used based on the
value of the mode parameter. Otherwise, if the null scrap is empty,
TECont inuousStyl1e returns the attributes of the character preceding the insertion
point. The TECont inuousStyle function always returns TRUE in this case, and each

eld of the text style record is set if the corresponding bit in the mode parameter is set.

If the value of hTE is a handle to a monostyled edit record, TEContinuousStyle
returns the set of character attributes that are consistent for the entire record.

Note that elds in the text style record speci ed by aStyle are only valid if the
corresponding bits are set in the mode variable.
How the tsFace eld of the aStyle record is used requires some consideration. For
example, if TECont inuousStyle returns a mode parameter that contains doFace and
the text style record tsFace_

2-102

TextEdit Reference

eld is bold, it means that the selected text is all bold, but

CHAPTER

2

TextEdit

may contain other text styles, such as italic, as well. Italic does not apply to all of the
selected text, or it would have been included inthe tsFace eld. Ifthe tsFace eld is
an empty set, then all of the selected text is plain.

TEStyleInsert
The TEStyleInsert procedure inserts the speci ed text immediately before the
selection range or the insertion point in the edit record@ text and applies the speci

ed

character attributes to the text, redrawing the text if necessary.
PROCEDURE

TEStyleInsert

(text:
hST:

Ptr;

length:

STScrpHandle;

LongInt;
hHTE:

TEHandle) ;

text

A pointer to the text to be inserted.

length

The length in bytes of the text to be inserted.

hstT

A handle to the style scrap record containing the character attribute
information to be applied to the inserted text.

hTE

A handle to the edit record into which the text is to be inserted.

DESCRIPTION

You should create your own style scrap record, specifying the character attributes to be
inserted and applied to the text, and pass its handle to TESt yleInsert as the value of
the hST parameter. The character attributes are copied directly into the style record@
(TEStyleRec) style table.

The TEStyleInsert procedure does not affects the current selection range.

TEGetStyleScrapHandle
The TEGetStyleScrapHand1le function creates a style scrap record, copies the
character attributes associated with the current selection range into it, and returns a
handle to it.
FUNCTION

hTE

TEGetStyleScrapHandle

(hTE:

TEHandle):

STScrpHandle;

The handle to the edit record containing the text selection range whose
character attributes are to be copied.

DESCRIPTION

The TEGet StyleScrapHandl1le function creates a style scrap record of type
StScrpRec and copies the character attributes associated with the current selection

TextEdit Reference

2-103

CHAPTER

2

TextEdit

range of the designated edit record into it. If the current selection range is an insertion
point, TEGet StyleScrapHandle rst checks the null scrap. If the null scrap contains
character attributes, they are written to the newly created style scrap record. If the null
scrap is empty, the attributes associated with the character preceding the insertion point
are copied to the style scrap record.
The TEGet StyleScrapHandle function has no impact on the Scrap Manager@ desk
scrap. The

TEGet

Sty leScrapHand1e function returns a NIL value if called with a

handle to a monostyled record.

TEUseStyleScrap
The TEUseStyleScrap procedure assigns new character attributes to the speci
range of text in the designated edit record.
PROCEDURE

TEUseStyleScrap

(rangeStart:
newStyles:
hTE:

LongInt;

STScrpHandle;

rangeEnd:
redraw:

ed

LongInt;
Boolean;

TEHand1le) ;

rangeStart
The offset of the

rst character in the text of the edit record to which the

character attributes are to be applied.
rangeEnd

The offset of the last character in the text of the edit record to which the

newStyles

Ahandle toa style scrap record. The style scrap record contains the
attributes to be applied to the speci ed range of text. If the value of

character attributes are to be applied.

newStyles

is NIL, no action is performed.

redraw

A Sag that speci es whether TextEdit should immediately redraw the
selection range using the new character attributes.

hTE

A handle to the edit record containing the range of text to which the
character attributes are to be applied. If the handle points to a monostyled
edit record (created using TENew), no action is performed.

DESCRIPTION

The TEUseStyleScrap procedure writes the character attribute information into

the style record@ style table and updates the style run table. If the redraw parameter
is set to TRUE, the attributes are applied immediately to the speci ed range of text, and
line breaks, line heights, and line ascents are recalculated. If redraw is set to FALSE, the

new character attributes are not refSected in the view rectangle until the next update
event occurs.

Regardless of whether the text is redrawn, the current selection range is not changed; if
characters are highlighted before TEUseStyleScrap is called, they remain highlighted
after it is called. However, if characters within the current selection range also fall within

2-104

TextEdit Reference

CHAPTER

2

TextEdit

the speci ed range of text, they are rendered in the new character attributes when the text
is redrawn.
Each element in the style scrap record contains a_
the element@ character attributes. This

for the scrap@ style runs.

eld that is the offset of the beginning of

eld (scrpStartChar) de

nes the boundaries

The TEUseStyleScrap procedure applies the

rst element@ attributes to the characters

from rangeStart up to the scrpStartChar

eld of the next element. The

TEUseStyleScrap procedure terminates without error if it prematurely reaches the end
of the range or if there are not enough scrap style elements to cover the whole range. In
the latter case, TEUseSt yleScrap applies the last set of character attributes in the style
scrap record to the remainder of the range.
Depending on the requirements of your application, you can create a style scrap record
directly and pass its handle to TEUseStyleScrap as the value of newStyles or you

can use a style scrap record created by

TEGet Sty leScrapHandle.

TENumStyles
The TENumStyles function returns the number of character attribute changes contained
in the speci ed range, counting one for the start of the range.
FUNCTION

TENumStyles

(rangeStart:
hTE:

rangeStart

rangeEnd

hTE

LongInt;

TEHandle):

rangeEnd:

LongInt;

LongInt;

The beginning of the range of text for which the number of style runs (sets
of character attributes) or changes is counted and returned.
Theend of the range of text for which the number of style runs (sets of

character attributes) or changes is counted and returned.
A handle to the edit record containing the range of text.

DESCRIPTION

The number of character attribute changes that TENumSt yles returns does not
necessarily represent the number of unique sets of attributes for the range because
some sets of attributes may be repeated. For monostyled edit records, TENumStyles
always returns 1.

Using Byte Offsets and Corresponding Points
You can use the TEGet Offset function to convert a point to its corresponding byte
offset and the TEGet Point function to convert a byte offset to its corresponding point.
These functions are discussed in this section.

TextEdit Reference

2-105

CHAPTER

2

TextEdit

TEGetOffset
The TEGet Offset function
that corresponds to the speci

nds the byte offset of a character in an edit record@ text
ed point.

FUNCTION

(pt:

TEGetOffset

Point;

hTE:

TEHandle):

pt

A point in the displayed text of the speci

hTE

A handle to the edit record containing the text.

Integer;

ed edit record.

DESCRIPTION

The TEGet Offset function works for both monostyled and multistyled edit
records. The TEGet Offset function returns the byte offset of the rst byte fora
2-byte character.

TEGetPoint
The TEGet Point function determines the point that corresponds to the speci
offset of a character and returns the coordinates of that point.
FUNCTION

TEGetPoint

(offset:

Integer;

hTE:

TEHandle):

offset

A byte offset into the text buffer of an edit record.

hTE

A handle to the edit record containing the text.

ed byte

Point;

DESCRIPTION

The TEGet Point function returns a valid result even when the edit record does not
contain any text. The point returned is based on the values in the record@ destination
rectangle. In the case of an offset being equal to a line end, which is also the start of the
next line, TEGet Point returns a point corresponding to the line start of the next line. In
the case of a dual caret, the primary caret position, the one corresponding to the primary
line direction, is returned.

The line height, taken either from the

lineHeight

eld for a monostyled edit record or

from the line-height array, LHElement, for a multistyled edit record, is also used to

determine the vertical component. Both the text direction and the primary line direction
are used to determine the horizontal component.

The TEGet Point function works for both monostyled and multistyled edit records.

2-106

TextEdit Reference

CHAPTER

2

TextEdit

Additional TextEdit Features
The TEFeatureFlag function lets you check the status of additional TextEdit features
and enable or disable them. It is described in this section.

TEFeatureFlag
The TEFeatureFlag function turns a speci ed feature on or off or returns the current
status of that feature. Features supported are automatic scrolling, text buffering, outline
highlighting, inline input, and text services.
FUNCTION

TEFeatureFlag

(feature:
hTE:

feature
action

hTE

Integer;

TEHandle):

action:

Integer;

Integer;

The feature for which the action is to be performed.
A selector stipulating that the feature, speci

ed by the

feature

parameter, is to be turned on or off, or that the current status of the feature
is to be returned.

A handle to the edit record for which the action should be performed.

DESCRIPTION

You can use the TEFeatureFlag function to check the status of additional TextEdit

featuresN automatic scrolling, outline highlighting, and text bufferingN and to enable or
disable the feature. You can also use this function to disable inline input in a particular
edit record and to enable several features that have been provided so that inline input
works correctly with TextEdit.
To identify a feature, you specify one of the following constants as the value of the
feature parameter.
Constant

Value

Description

teFAutoScroll

0

Automatic scrolling

teFTextBuffering

1

Text buffering

teFOutlineHilite

2

Outline highlighting

teFInlineInput

3

Inline input

teFUseTextServices

4

Use inline input service

You specify the act ion to be performed on a feature through the following constants.
Constant

Value

Description

teBitClear

0

Disables the speci

teBitSet

1

Enables the speci ed feature

teBitTest

1

Returns the current setting of the speci

TextEdit Reference

ed feature
ed feature

2-107

CHAPTER

2

TextEdit

If teBitTest returns teBitSet, the feature is enabled; if it returns teBitClear,
it is disabled.

You can use the TEFeatureFlag function to turn automatic scrolling on and off as an
alternative to calling TEAut oView. The effect is the same.
The teFOutlineHilite selector speci es outline highlighting as the feature for which
an action is to be performed. If a highlighted region exists in an edit record and the
window is inactive, then the highlighted region is outlined or framed.

In the case that outline highlighting is enabled and the current selection range is an
insertion point, the caret is then drawn in a gray pattern so that it appears dimmed. To do
the framing and caret dimming, TextEdit temporarily replaces the current address in the
highHook and caretHook elds of the edit record, redraws the caret or the highlighted
region, and then immediately restores the hooks to their previous addresses.
The teFTextBuf fering selector enables or disables text buffering for performance
improvements of 2-byte scripts. This is a global buffer, as opposed to the TEKey
procedure@ internal 2-byte buffer, and it is used across all active edit records. When
using text buffering, take the following precautions:
m Exercise care when you enable the text-buffering capability in more than one active
record; otherwise, the bytes that are buffered from one edit record may appear in
another edit record.
m Ensure that buffering is not turned off in the middle of processing a 2-byte character.
To guarantee the integrity of your record, it is important that you wait for an idle event
before you disable buffering or enable buffering in a second edit record.
mw When text buffering is enabled, ensure that TEI dle is called before any pause of more
than a few ticksN for example, before the Event Manager procedure WaitNextEvent.
A possibility of a long delay before characters appear on the screen exists, especially in
non-Roman systems. If you do not call TEId1e, the characters can end up in the edit
record of another application. For more information, see CTEIdleOon page 2-84.
If text buffering is enabled on a non-Roman script system and the keyboard has changed,
TextEdit fSushes the text of the current script from the buffer before bringing characters of
the new script into the buffer.
If your application follows the guidelines for inline input available from Macintosh
Developer Technical Support, then you should set the useTextEditServices fag in
the Size resource in your application. This allows inline input to work with your
application. Inline input is a keyboard input method (often used for double-byte script
systems) in which conversion from a phonetic to an ideographic representation of a
character takes place at the current line position where the text is intended to appear. This
allows the user to type text directly in the line as opposed to a special conversion
window. If inline input is installed and the useTextEdit Services fag in the Size
resource is set, inline input sets TextEdit@ teFUseText

an edit record is created. TextEdit does not use this bit.

2-108

TextEdit Reference

Services

feature bit whenever

CHAPTER

2

TextEdit

Inline input checks the teFUseText Services bit during text editing to determine if an
inline session should begin. If you want to disable inline input for a particular edit
record, your application can clear this bit after the edit record is created. You can also
clear this bit to disable inline input temporarily and then restore it, but the edit record
must always be deactivated before the state of the bit is changed.
IMPORTANT

You must deactivate an edit record (using TEDeactivate) before
changing the state of the feature bits or any elds in the edit record. a
In the future, other text services may use this same mechanism. If you follow the

guidelines speci ed here, your application should also work with future text services.
When an inline edit session begins, inline input also sets the teFInlineInput bit to
provide the following features so that inline input works correctly with TextEdit:
m disabling font and keyboard synchronization
m forcing a multiple-line selection to be highlighted line by line using a separate
rectangle for each line rather than using a minimum number of rectangles for
optimization
m highlighting a line only to the edge of the text rather than beyond the text to the edge
of the view rectangle
IMPORTANT

The teFInlineInput bit is cleared by inline input when an inline
session ends. Use the teFInlineInput constant in the feature

parameter of TEFeatureFlag to include these features in your
application even when inline input is not installed. Be careful about
changing the state of this bit if the teFUseTextServices bit is set.
Again, the edit record should always be deactivated before you change
the state of the teFInlineInput bit. If you clear the
teFUseText Services bit and you set the teFInlineInput bit, inline
input is disabled, but your application retains the features
listed above. A
To test for the availability of these features, you can call the Gestalt function with the
gestaltTextEditVersion selector. A result of gestalt
TE4

or greater returned in the

response parameter indicates that outline highlighting and text buffering are available. A
result of gestaltTES5 or greater returned in the response parameter indicates that the
two inline input features are available.
The inline input features are also available on version 6.0.7 systems with
non-Roman script systems installed. However, there is no Gestalt constant that indicates
this availability.

SEE ALSO

For a description of the WaitNext Event function, see the chapter GEvent ManagerOin
Inside Macintosh: Macintosh Toolbox Essentials.

TextEdit Reference

2-109

CHAPTER

2

TextEdit

Customizing TextEdit
The TextEdit TECustomHook,

TESetWordBreak,

and TESetClickLoop

routines

described in this section let you customize the behavior of TextEdit. You can use these
routines to replace the default hook routines with your customized versions.
However, if you use any of the TextEdit hooks to override default TextEdit behavior, the
results may no longer be Script Manager compatible. Before replacing TextEdit routines,
you should determine whether more than one script system is installed, and, if so, ensure
that the replacement routine you provide is script-aware.

TECustomHook
The TECustomHook procedure replaces a default TextEdit hook routine with a
customized routine and returns the address of the replaced routine.
PROCEDURE

TECustomHook

(which:
hTE:

TEIntHook;

VAR

addr:

ProcPtr;

TEHand1le) ;

which

The hook whose default routine is to be replaced.

addr

On input, the address of your customized procedure.
On output, the addr parameter contains the address of the routine that
was previously installed inthe eld identi ed by the which parameter.
This address is returned so that you can daisy-chain routines.

hTE

A handle to the edit record to be modi

ed.

DESCRIPTION

The TECustomHook procedure lets you alter the behavior of TextEdit to better suit your
application@® requirements and those of the script systems installed. If you replace a
default hook routine with a customized version that you write in a high-level language,
such as Pascal or C, you need to provide assembly-language glue code that utilizes the
registers for your high-level language routine. The register contents for each of the hook
routines are described in this section under OAssembly-Language Information.O

2-110

TextEdit Reference

CHAPTER

2

TextEdit

The end-of-line hook, width measurement hook, new width measurement hook, text
width measurement hook, draw hook. and hit test hook elds are hook elds in

the TextEdit dispatch record. The which parameter identi es the hook whose
default routine is to be replaced; you use the following constants to specify a value
for this parameter.
Constant

Value

Description

int EOLHook

0

End-of-line hook

int DrawHook

1

Draw hook

intWidthHook

2

Width measurement hook

intHitTestHook

3

Hit test hook

intNWidthHook

6

New width measurement hook

int TextWidthHook

7

Text width measurement hook

ASSEMBLY-LANGUAGE

(low-memory global width measurement hook)

INFORMATION

The end-of-line hook, width measurement hook, new width measurement hook, text
width measurement hook, draw hook, and hit test hook elds are hook elds in the

TextEdit dispatch record. When you use TECustomHook to replace the default routines
installed in these hook

elds with customized ones, remember that the replacement

routine must preserve all registers except those speci

ed as containing return values.

End-of-Line Hook Registers

You specify the int EOLHook constant as the value of the which parameter to identify
the end-of-line hook routine as the one you want to replace. This hook routine
determines whether an incoming character is an end-of-line character. It tests the
character, sets the appropriate status {sags in the status register, and returns. The default
action is to compare the character with $0D (a carriage return).
Registers on entry

DO

Character to compare (byte)

A3

Pointer to the edit record

A4

Locked handle to the edit record

Registers on exit

Z

(Zero) fag in the status register clear if end-of-line character; set otherwise.

TextEdit Reference

2-111

CHAPTER

2

TextEdit

Draw Hook Registers

You specify the intDrawHook constant as the value of the which parameter to identify
the drawing hook routine as the one you want to replace. The draw hook routine is called
any time the components of a line are drawn. The appropriate font, style, and size
characteristics have already been set into the current port by the time this routine is
called. By default, the address of the QuickDraw DrawText procedure is stored in the
draw hook eld.
If your application is using outline (TrueType) fonts, TextEdit has also set the
preserveGlyph parameter of the Font Manager@ Set PreserveGlyph procedure to

FALSE, So your customized hook procedure may need to reset this parameter if your
application depends on it.
Registers on entry

DO

Offset into text (word)

D1

Length of text to draw (word)

AO

Pointer to text to draw

A3

Pointer to the edit record

A4

Locked handle to the edit record

Width Measurement

Hook Registers

You specify the intWidthHook constant as the value of the which parameter to identify
the width measurement hook routine as the one you want to replace. The width
measurement hook routine measures portions of a line of text. It is used when only the
Roman script system is installed and the eld contains the address of a customized
routine. It is supported for backward compatibility. In all other cases, when more than
one script system is installed or when the width measurement hook eld has not been
customized, TextEdit calls the routine whose address is installed in the new width

measurement hook

eld.

Registers on entry
DO

Length (in bytes) of text to measure (word)

D1

First byte of text to measure (word)

AO

Pointer to text buffer

A3

Pointer to the edit record

A4

Locked handle to the edit record

Registers on exit

D1

2-112

Pixel width of measured text (word)

TextEdit Reference

CHAPTER

2

TextEdit

Hit Test Hook Registers

You specify the int Hit TestHook constant as the value of the which parameter to
identify the hit test hook routine as the one you want to replace. The hit test hook routine
determines the glyph position in a line given the pixel width from the left edge of the
view rectangle. For system software before System 7, the default action is to call the
QuickDraw TextWidth function to determine if the pixel width of the measured text is
greater than the input width. If it is, then the hit test hook routine calls the QuickDraw
PixelToChar function and returns. For System 7, the default action is to call the
QuickDraw PixelToChar function.
Registers on entry
DO

Length of text block (style run) to measure (word)

D1

Pixel width from start of text block (word)

D2

Slop (should equal 0) (word)

AO

Pointer to start of text block

A3

Pointer to the edit record

A4

Locked handle to the edit record

Registers on exit

DO

Pixel width to character offset in text block (low word)

A Boolean that is TRUE if a character offset corresponding to the given pixel width
was found (high word). Otherwise, FALSE.
D1

Character offset (word)

D2

A Boolean that is TRUE if the pixel width falls within the leading edge of the
character (low word). Otherwise, FALSE.
TextEdit also uses the least signi cant bit of the high word. If the hit test hook
routine calls

Pixel ToChar, TextEdit sets this bit. If it uses

Text Width, TextEdit

clears this bit. Your customized routine needs to do the same if you call either
PixelToChar or TextWidth (high word). See the chapter GQQuickDraw TextOin
this book for more about these routines.
Note
In earlier versions of TextEdit, the value in register D2 on entry was not
always used. If you daisy-chain in a routine and then call the hit test
hook routine, D2 must be 0 (on entry). #
New Width Measurement

Hook Registers

You specify the int NWidthHook constant as the value of the which parameter to
identify the new width measurement hook routine as the one you want to replace. The
new width measurement hook routine measures portions of a line of text when a
non-Roman script system is installed. It is also used when only a Roman script system is
installed and the width hook eld does not contain the address of a customized routine.

TextEdit Reference

2-113

CHAPTER

2

TextEdit

The default procedure calls CharToPixel or TextWidth, depending on the primary
line direction. The appropriate font, style, and size characteristics have already been set
into the current graphics port by the time this routine is called.
The new width measurement hook routine is called to measure text for both Roman and

non-Roman script systems, so make sure that your customized routine is script-aware.
Registers on entry

DO

Overall style run length, bounded by the line end (word)

D1

Offset position within style run on the current line (word)

D2

Slop (low word); direction Sag (high word)

AO

Pointer to text buffer

A2

Pointer to current line start (from TextEdit@ lineStarts array)

A3

Pointer to the edit record

A4

Locked handle to the edit record

Registers on exit

D1

Pixel width of measured text (word)

Text Width Measurement

Hook Registers

You specify the int TextWidthHook constant as the value of the which parameter to
identify the low-memory global text width measurement hook routine as the one you
want to replace. By default, this hook eld contains the address of the QuickDraw
TextWidth function and provides a way to replace TextEdit@ use of Text Width. The
new width measurement hook routine uses the routine whose address is installed in
this eld.
Registers on entry
DO

Length (in bytes) of text to be measured (word)

D1

Offset in text of

AO

Pointer to text to measure

A3

Pointer to the edit record

A4

Locked handle to the edit record

rst byte to measure (word)

Registers on exit

D1

Pixel width of measured text (word)

SEE ALSO

For more information about the Set PreserveGlyph procedure, see the chapter Font
ManagerOin this book. For more information about DrawText, TextWidth,
Pixel ToChar, and CharToPixel, see the chapter CQQuickDraw TextOin this book.

2-114

TextEdit Reference

CHAPTER

2

TextEdit

SPECIAL CONSIDERATIONS

Take the following precautions if you replace a default routine:
m Before placing the address of your routine in the TextEdit dispatch record, strip the
addresses, using the Operating System Utilities StripAddress function, to guarantee
that your application is 32-bit clean. For more information, see Inside Macintosh:
Operating System Utilities.
m Before replacing a TextEdit routine with a customized one, determine whether more
than one script system is installed, and, if so, ensure that your customized routine

accommodates all of the installed script systems. This avoids the problem of your
customized routine producing results that are incompatible with the Script Manager.
m When you use assembly language, note that all registers must be preserved except
those speci ed as containing return values. Registers A3 contains a pointer to the edit
record and Register A4 contains a handle to it. You can obtain line start positions from
the lineStarts array in the edit record. Register A5 is always valid. Refer to
TECustomHook in the lextEdit ReferenceOsection for complete coverage of the
register content requirements for all hook routines.

TESetWordBreak
The TESetWordBreak procedure installs the address of a customized word-selection
break routine in the wordBreak eld of the speci ed edit record.
PROCEDURE

TESetWordBreak

(wBrkProc:

ProcPtr;

hTE:

TEHandle) ;

wBrkProc

Apointer to the customized word-selection break routine.

hTE

A handle to the edit record containing the wordBreak
be modi ed.

eld to

DESCRIPTION

A word break routine determines which word is highlighted when the user double-clicks
in the text. It also determines where TextEdit breaks the text at the end of a line. You can
use TESet WordBreak to replace the default routine in the wordBreak eld that is used
for word selection and line breaking under certain circumstances. Whether or not
TextEdit uses the word-selection break routine referenced by this eld is determined by
the algorithm implemented in the default TEFindWord routine. For a description of this
algorithm, see Customizing Word SelectionOon page 2-60; this section also describes
what to consider if you replace the TEFindWord hook routine.
When you replace the wordBreak eld hook routine, your customized word break
routine is used instead of the default one. The default routine breaks words at any
character with an ASCII value of $20 or less (the space character or nonprinting
control characters). Your routine can use a different value.

Before non-Roman script systems were supported, TextEdit used the word break hook
routine installed in the wordBreak eld for all word selection and line breaking.

TextEdit Reference

2-115

CHAPTER

2

TextEdit

However, in order to support both Roman and non-Roman script systems, TextEdit now
uses the routine installed in the low-memory global variable TEFindWord. The default
TEFindWord hook routine determines which hook TextEdit should use for word
selection and line breakingN the wordBreak hook or the Text Utilities
FindWordBreaks procedureN based on what script systems are installed and some
other factors. You can replace the TEFindWord hook routine with a customized version.

ASSEMBLY-LANGUAGE

INFORMATION

You must directly set the wordBreak eld to point to your own word break routine; do
not use the TESet WordBreak procedure.The registers for the word break routine must
contain the following values.
Registers on entry
AO

Pointer to text

DO

Character position (word)

Register on exit

Z bit (zero fag)

Condition code:

status register

0 to break at speci

ed character

1 not to break there
If you replace TEF indWord, be careful to set the correct values in the appropriate
registers. For TEFindWord, the registers are set on entry as speci ed below, and TextEdit
depends on the registers being set at exit as speci ed below.
Registers on entry
DO

Current position (the value of selStart

D2

Identi

eld in edit record) (word)

er of routine that called FindWordBreaks (word)

Identifier

Value

Explanation

teWordSelect

4

called for word selection

teWordDrag

8

called for extending word selection

teFromFind

12

called for determining new line breaks

teFromRecal

16

called for word breaking in line recalculation

A3

Pointer to the edit record

A4

Locked handle to the edit record

Registers on exit

DO

Word start (word)

D1

Word end (word)

SEE ALSO

For more information about the FindWordBreaks procedure, see the chapter Ofext
UtilitiesOin this book.
2-116

TextEdit Reference

CHAPTER

2

TextEdit

TESetClickLoop
The TESetClickLoop procedure installs in the clikLoop
address of the application-supplied click loop routine.

eld of the edit record the

PROCEDURE

TESetClickLoop

hTE:

clickProc

A pointer to the customized click loop routine.

hTE

A handle to the edit record whose clikLoop

(clickProc:

ProcPtr;

TEHandle) ;

eldis tobe modi

ed.

DESCRIPTION

The TESetClickLoop procedure lets you replace the default click loop routine. The
TEClick procedure repeatedly calls the routine that the click loop eld points to as long
as the user holds down the mouse button within the text of the view rectangle. The
default click loop routine scrolls only the text. However, you can provide a customized
click loop procedure that scrolls the text and the scroll bars in tandem.
If automatic scrolling is enabled, the default click loop routine checks to see if the mouse

has been dragged out of the view rectangle; if it has, the routine scrolls the text using
TEPinScrol1. (For more information, see C(FEPinScrollOon page 2-91.) The amount by
which TEPinScro11 scrolls the text vertically is determined by the lineHeight eld of
the edit record for monostyled text and the LHTable for multistyled text.

ASSEMBLY-LANGUAGE

INFORMATION

You can directly set the click loop (clikLoop) eld; you don@need to use the
TESetClickLoop procedure. Your routine should set register DO to 1 and preserve
register D2. Returning 0 in register DO terminates TECLick.

TextEdit Reference

2-117

CHAPTER

2

TextEdit

Sumunary of TextEdit
Pascal Summary
Constants
CONST

{Gestalt

returned

values}

gestaltUndefSelectorErr
gestaltTE1

=

gestaltTE2

= 2;

{Systems before 6.0.4, multistyled TextEdit
{ on all hardware}
{System 6.0.4 Roman script system on }
{ IIci-family hardware}
{Script Manager-compatible. System 6.0.4 }
{ non-Roman script systems on all }

1;

{

family

hardware.New

gestaltTE3

= 3;

gestaltTE4

= 4;

gestaltTES

= 5;

{alignment

styles:

new

constant

hook

names

for

=

-1;

{flush

right

teFlushLeft

=

-2;

{flush

left

styles;

old

constant

{ backward-compatibility}
teJustLeft

=

0;

teJustCenter

=

1;

teJustRight

=

-1;

teForceLeft

=

-2;

Summary of TextEdit

the

align

parameter

}

}

TETextBox}
{flush according to system direction
{centered for all scripts }

teFlushRight

{alignment

measuring

{ nWIDTHHook. }
{Script Manager-compatible. System 6.0.4 }
{ non-Roman script systems on all non-IIci }
{ family hardware.}
{Script Manager-compatible. System 6.0.5 on }
{ all hardware. New TEFeatureFlag function. }
{Script Manager-compatible. System 7.0 on all
{ hardware}

{ of TESetAlignment and
teFlushDefault =
0;
teCenter
=
1;

2-118

IIci

}

names

for
for

supported

all
all

scripts}
scripts}

for

}

}

}

CHAPTER

2

TextEdit

for

TEFeatureFlag
Oo

teFAutoscr
teFTextBuffering
teFOutlineHilite
teFUseTextServices
for

f

~e

teFInlineInput

{values

feature

QO;
BPW
NY
FP

{values

teFAutoScroll

TEFeatureFlag

teBitClear

action

teBitSet
teBitTest

{selectors

for

identifying
4;

teWordDrag

8;

teFromFind
teFromRecal

{ automatic scrolling
{ old constant for automatic
{ text buffering}
{ outline highlighting}
{ inline input}
{ use inline input service}

scrolling}

parameter}

{clear TEFeatureFlag features}
{set TEFeatureFlag features}
{test TEFeatureFlag features: return
{ the current setting}

QO;

teWordSelect

parameter}

the

routine

that

called

TEFindWord

{called for determining
{ line breaks}

}

new

{ called

for

extending

12;

{called

for

word

selection}

16;

{called

for

word

breaking

word

}

}
selection}

in

line

}

{ recalculation}
{values

for

doToggle

TESetStyle/TEContinuousStyle/TEReplaceStyle modes}
{set font family number}
1;
{set character style}
2;
{set type size}
4;
{set color}
8;
15;
{set all attributes}
16;
{adjust type size }
32;
{toggle mode for TESetStyle}

{selectors

for

doFont
doFace
doSize
doColor
doAll
addSize

TECustomHook }

int EOLHook

0;

intDrawHook

1;

intWidthHook

2;

intHitTestHook

3;

intNWidthHook

6;

intTextWidthHook

7 f

Summary
of TextEdit

{end-of-line hook}
{drawing hook}
{width measurement hook}
{hit-test hook}
{nWIDTHHook measurement hook}
{TextWidth measurement hook}

2-119

CHAPTER

2

TextEdit

Data Types
TYPE

TERec

=

RECORD

destRect:

Rect ;

viewRect:

Rect ;

selRect:

Rect;

lineHeight:

Integer;

fontAscent:

Integer;

selPoint:

Point;

selStart:

Integer;

selEnd:

Integer;

active:

Integer;

wordBreak:

ProcPtr;

clikLoop:

ProcPtr;

clickTime:

lLongInt;

clickLoc:

Integer;

caretTime:

LongInt;

caretState:

Integer;

just:

Integer;

teLength:

Integer;

hText:

Handle;

hDispatchRec:

LongInt;

clikStuff:

Integer;

crOnly:

Integer;

txFont:

Integer;

txFace:

Style;

txMode:

Integer;

txSize:

Integer;

{ destination rectangle}
{ view rectangle}
{ the selection rectangle}
{ used for vertical spacing of lines}
{ used for caret/highlighting position}
{ point selected with the mouse}
{ start of selection range}
{ end of selection range}
{ set when record is }
{ activated/deactivated}
{ word break hook}
{ click loop hook
{ used internally
{ used internally}
{ used internally}
{ used internally}
{ alignment of text}
{ length of text}
{ handle to text to be edited}
{ handle to TextEdit }
{ dispatch record}
{ used internally}
{ if <0, new line at Return only}
{ text font}
{ character style; unpacked byte}
{ pen mode}
{ value indicates either a multistyled }
{ edit record or a font size}

inPort:

GrafPtr;

{a

to

the

grafPort

for

highHook:

ProcPtr;

{used

pointer

for

text

highlighting

}

for

the

caret

caretHook:

ProcPtr;

{used

nLines:

Integer;

{number

lineStarts:

ARRAY[0..16000]

OF

of

Integer;

{positions
END;

TEPtr
TEHandle

2-120

=

“TERec;
“TEPtr;

Summary
of TextEdit

appearance}

lines}

of

line

starts}

this

TERec}

CHAPTER

2

TextEdit

Chars=

PACKED

CharsHandle
CharsPtr

TEStyleRec

ARRAY[0..32000]

=
=

OF

CHAR;

“CharsPtr;
“Chars;

=

RECORD

nRuns:
nStyles:
styleTab:
lhTab:
teRefCon:
nullStyle:

Integer;
Integer;
STHandle;
LHHandle;
LongInt ;
NullStHandle;

{number of style runs}
{size of style table}
{handle to style table}
{handle to line-height table}
{reserved for application use}
{handle to style set at }
{ null selection}

runs:

ARRAY

OF

[0..8000]

StyleRun;

{ARRAY

[0..8000]

OF

StyleRun}

position}

END;

TEStylePtr

= “TEStyleRec;

TEStyleHandle
StyleRun

= “TEStylePtr;

=

RECORD

END;

startChar:

Integer;

{starting

character

styleIndex:

Integer;

{index

in

style

table}

stCount:

Integer;

{number

of

runs

in

stHeight:
stAscent :
stFont:
stFace:
stSize:
stColor:

Integer;
Integer;
Integer;
Style;
Integer;
RGBColor ;

{line height}
{font ascent}
{font (family) number}
{character style}
{size in points}
{absolute RGB color}

STElement

=

RECORD

this

style}

END;

STPtr

=

“TEStyleTable;

STHandle

=

“STPtr;

TEStyleTable

=

ARRAY

Summary
of TextEdit

[0..1776]

OF

STElement;

2-121

CHAPTER

2

TextEdit

LHElement

=

RECORD

lhHeight :
lhAscent:

Integer;
Integer;

{maximum
{maximum

height
ascent

in
in

line}
line}

END;

LHPtr

=

“LHTable;

LHHandle
LHTable

=
=

“LHPtr;
ARRAY

ScrpSTElement

[0..8000]

OF

LHElement;

=

RECORD

scrpStartChar:
scrpHeight :
scrpAscent :
scrpFont:
scrpFace:
scrpSize:
scrpColor:

LongInt ;
Integer;
Integer;
Integer;
Style;
Integer;
RGBColor;

{offset to start of style}
{line height}
{font ascent}
{font (family) number}
{character style}
{size in points}
{absolute (RGB) color}

END;

ScrpStyl2Tab
StScrpRec

= ARRAY[0..1600]

OF

ScrpSTElement ;

=

RECORD

scrpNStyles:
scerpStyleTab:

Integer;
ScrpSTTable;

{number of styles in
{table of styles for

scrap}
scrap}

END;

StSerpPtr

= “StScrpRec;

StScrpHandle
NullStRec

=

“StScrpPtr;

=

RECORD

teReserved:

LongInt ;

nullScrap:

StScrpHandle;

END;

NullstPtr

=

NullStHandle
TextStyle

“*NullStRec;
=

*NullStPtr;

=

RECORD

2-122

Summary
of TextEdit

{reserved

for

future

expansion}

{handle

to

scrap

style

table}

CHAPTER

2

TextEdit

tsFont:
tsFace:
tsSize:
tsColor:

Integer;
Style;
Integer;
RGBColor;

{font (family) number}
{character Style}
{size in points}
{absolute (RGB) color}

END;

TextStylePtr = *“TextStyle;
TextStyleHandle = “TextStylePtr;
TEIntHook

=

Integer;

Routines
Initializing TextEdit, Creating an Edit Record, and Disposing of an Edit Record
PROCEDURE

TEInit;

FUNCTION

TEStyleNew

(destRect:

Rect;

FUNCTION

TENew

(destRect,

viewRect:

PROCEDURE

TEDispose

(hTE:

viewRect:

Rect):

Rect):

TEHandle;

TEHandle;

TEHandle) ;

Activating and Deactivating an Edit Record
PROCEDURE

TEActivate

(hTE:

TEHandle) ;

PROCEDURE

TEDeactivate

(hTE:

TEHandle) ;

Setting and Getting an Edit Record’s Text and Character Attribute Information
PROCEDURE

TEKey

PROCEDURE

TESet

FUNCTION
PROCEDURE

FUNCTION

TEGet

Text
Text

TESetStyleHandle

TEGetStyleHandle

( key:

Char;

( text:

Ptr;

(hTE:

hTE:

TEHandle) ;

length:

TEHandle) :

( theHandle:
( hTE:

LongInt;

hTE:

TEHandle) ;

CharsHandle;

TEStyleHandle;

TEHandle):

hTE:

TEHandle) ;

TEStyleHandle;

Setting the Caret and Selection Range
PROCEDURE

TEIdle

(hTE:

TEHandle) ;

PROCEDURE

TEClick

(pt:

Point;

PROCEDURE

TESetSelect

(selStart,

extend:
selEnd:

Boolean;
LongInt;

hTE:
hTE:

TEHand1le) ;
TEHandl1le);

Displaying and Scrolling Text
PROCEDURE

TESetAlignment

(align:

PROCEDURE

TEUpdate

(rUpdate:

Summary
of TextEdit

Integer;
Rect;

hTE:
hTE:

TEHandle) ;
TEHandle) ;

2-123

CHAPTER

2

TextEdit

PROCEDURE

TETextBox

PROCEDURE

TECalText

FUNCTION

TEGetHeight

(text:

Ptr;

box:

Rect;

(hTE:

TEHandle) ;

(endLine,
hTE:

length:
just:

startLine:LONGINT;

TEHandle):

PROCEDURE

TEScroll

( dh,dv:

PROCEDURE

TEPinScroll

( dh:

PROCEDURE

TEAutoView

( fAuto:

PROCEDURE

TESelView

( hTE:

LongInt;
Integer) ;

INTEGER;

Integer;

INTEGER;

hTE:

dv:

TEHandle) ;

INTEGER;

Boolean;

hTE:

hTE:

TEHandle) ;

TEHandle);

TEHand1le) ;

Modifying the Text of an Edit Record
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE

TEDelete
TEInsert
TECut
TECopy

hTE:

PROCEDURE
PROCEDURE

TEHand1le) ;

text:

Ptr;

length:

hTE:

TEHandle )

f

hTE:

TEHandle )

f

TEPaste

hTE:

TEHandle )

f

TEStylePaste

hTE:

TEHandle )

f

FUNCTION

TEToScrap:

FUNCTION

TEFromScrap:

LongInt;

hTE:

TEHandle) ;

OSErr;
OSErr;

Managing the TextEdit Private Scrap
FUNCTION

TEScrapHandle:

Handle;

FUNCTION

TEGetScrapLength:

LongiInt;

PROCEDURE

TESetScrapLength

(length:

LongInt) ;

Checking, Setting, and Replacing Styles
PROCEDURE

TESetStyle

(mode:

Integer;

redraw:
PROCEDURE

TEReplaceStyle

(mode:

INTEGER;

redraw:
FUNCTION

TEContinuousStyle

(VAR
hTE:

PROCEDURE
FUNCTION
PROCEDURE

TEStyleInsert

(text:

hTE:

mode:
Ptr;

hTE:

Integer;

TEHandle)

TextStyle;

TEHandle) ;

oldStyle,

BOOLEAN;

:

newStyle:

TextStyle;

TEHand1le);

VAR

aStyle:

TextStyle;

Boolean;

length:

hST:

STScrpHandle;

(hTE:

TEHandle):

LongInt;
hTE:

TEHandle) ;

TEGetStyleScrapHandle
TEUseStyleScrap

(rangeStart:
newStyles:
hTE:

2-124

newStyle:

Boolean;

Summary
of TextEdit

StyleScrpHandle;

LongInt;

rangeEnd:

STScrpHandle;

TEHand1le) ;

redraw:

LongInt;
Boolean;

CHAPTER

2

TextEdit

FUNCTION

TENumStyles

(rangeStart:
hTE:

LongInt;

TEHandle):

rangeEnd:

LongInt;

LongInt;

Using Byte Offsets and Corresponding Points
FUNCTION

TEGetOffset

(pt:

FUNCTION

TEGet

(offset:

Integer;

(feature:

Integer;

Point

Point;

hTE:

TEHandle):

hTE:

Integer;

TEHandle):

Point;

Additional TextEdit Features
FUNCTION

TEFeatureFlag

hTE:

TEHandle)

action:

:

Integer;

Integer;

Customizing TextEdit
PROCEDURE

TECustomHook

(which:
hTE:

TEIntHook;

VAR

addr:

ProcPtr;

TEHandle) ;

PROCEDURE

TESetWordBreak

(wBrkProc:

PROCEDURE

TESetClickLoop

(clickProc:

ProcPtr;

hTE:

ProcPtr;

TEHandle);

hTE:

TEHandle);

C Summary
Constants

enum

{

/*alignment

styles

of

TESetAlignment

and

=

teCenter

=

/*centered

teFlushRight

=

/*flush

right

for

all

scripts*/

teFlushLeft

=

/*flush

left

for

all

script*/

/*alignment

styles;

0,

old

teJustLeft

=

0,

teJustCenter

=

1,

teJustRight

-1,

teForceLeft

-2,

/*feature

or

bit

/*flush

TETextBox*/

teFlushDefault

names

definitions

according

supported

for

for

for

all

TEFeatureFlag

direction*/

scripts*/

feature

0,

teFAutoscr

=

0,

/*old

constant

teFTextBuffering

=

1,

/*text

buffering*/

teFOutlineHilite

=

2 i

/*outline

Summary
of TextEdit

system

backward-compatibility*/

/*automatic

teFAutoScroll

to

parameter*/

scrolling*/
for

automatic

scrolling*/

highlighting*/

2-125

CHAPTER

2

TextEdit

teFInlineInput

=

3,

/*

action

for

the

new
=

0,

teBitSet

-

1,

bi

4,

/*use

bit

teBitClear

enum

/*inline

=

teFUseTextServices

(un)set

input*/

inline

input

service*/

interface,TEFeatureFlag

/*set

the

selector

*/

bit*/

{
-1,

/*no

teBitSet

1,

/*set

the

teBitTest

-1,

/*no

change;

teBitTest

change;

just

return

the

current

setting*/

the

current

setting*/

teBitClear

/*constants

for

identifying

bit*/

just

routine

return

that

called

TEFindWord

teWordSelect

=

4,

/*clickExpand

to

select

teWordDrag

=

8,

/*clickExpand

for

extending

teFromFind

=

12,

/*FindLine

teFromRecal

=

16,

/*called

for

/*values

for

doFont

=

doFace
doSize

word

breaking

in

called

line

/*set

font

=

2,

/*set

character

=

4,

/*set

type

doColor

=

8,

/*set

color*/

doAll

=

15,

/*set

all

addSize

=

16,

/*adjust

type

size*/

=

32,

/*toggle

mode

for

bi

family

/*selectors

for

EOLHook

=

number*/

style*/

size*/
attributes*/

intWidthHook
intHitTestHook
intNWidthHook
intTextWidthHook

TESetStyle*/

=

0 ;

/*end-of-line

1 ,

/*drawing

2 ;

/*width

3 ;

/*hit-test

6 ,
=-

Summary
of TextEdit

hook*/

hook*/

measurement

/*nWIDTHHook
7,

/*TextWidth

selection*/

recalculation*/

TECustomHook*/

intDrawHook

word

(S0C)*/

{

doToggle

int

it

hook*/

hook*/
measurement
measurement

*/

word*/

TESetStyle/TEContinuousStyle/TEReplaceStyle

1,

enum

2-126

the

selector

hook*/
hook*/

modes*/

CHAPTER

2

TextEdit

Types
typedef

pascal

Boolean

(*WordBreakProcPtr)
(Ptr

typedef

pascal

Boolean

(*ClikLoopProcPtr)
(void) ;

TERec

struct

text,

destRect;

/*destination

Rect

viewRect;

/*view

Rect

selRect;

/*the

rectangle*/

rectangle*/
selection

rectangle*/

short

lineHeight;

/*used

for

vertical

short

fontAscent ;

/*used

for

caret/highlighting

Point

selPoint;

/*point

selected

short

selStart;

/*start

short

selEnd;

/*end

of

short

active;

/*set

when

WordBreakProcPtr

wordBreak;

ClikLoopProcPtr

clikLoop;

of

spacing

with

selection

selection
record

is

/*click

loop

hook*/

internally*/

short

clickLoc;

/*used

internally*/

long

caretTime;

/*used

internally*/
internally*/

short

caretState;

/*used

short

just;

/*alignment

of

short

teLength;

/*length

of

text*/

Handle

hText;

/*handle

to

text

to

TextEdit

hDispatchRec;
clikStuff;

/*used

short

ecroOnly;

/*if

short

txFont ;

/*text

txFace;

/*character

char

activated/deactivated*/

hook*/

short

position*/

range*/

break

long

lines*/

mouse*/

/*word

/*used

/*handle

the

of

range*/

clickTime;

Style

charPos) ;

{

Rect

long

short

text*/
to

be

edited*/

dispatch

record*/

internally*/

<0,

new

line

at

Return

only*/

style;

unpacked

byte*/

font*/

filler;

short

txMode;

short

txSize;

/*value

/*pen

indicates

mode*/

either

a

multistyled

pointer

to

edit

record

or

for

this

inPort;

/*a

ProcPtr

highHook;

/*used

for

ProcPts

caretHook;

/*used

from

assembly

/*number

of

lines*/

text

short

nbines;

short

lineStarts[16000];/*positions

the

grafPort

GrafPtr

highlighting

of

and

the

a

font

sgize*/

TERec*/
caret

appearance*/

language*/
line

starts*/

bi
typedef

struct

TERec

typedef

TERec

*TEPtr,

TERec;
**TEHandle;

Summary
of TextEdit

2-127

CHAPTER

2

TextEdit

typedef

char

Chars[32001];

typedef

char

*CharsPtr,

struct

StyleRun

**CharsHandle;

{

short

startChar;

/*starting

character

short

styleIndex;

/*index

style

in

position*/

table*/

hi
typedef

struct

struct

STElement

short

stCount;

/*number

short

stHeight;

/*line

height*/

short

stAscent;

/*font

ascent*/

short

stFont;

/*font

family

Style

stFace;

/*character

char
short

StyleRun

{

filler;

/*size

stColor;

typedef

struct

typedef

STElement

struct

of

/*stFace

stSize;

RGBColor

StyleRun;

is
in

in

this

number*/

unpacked

byte*/

points*/
Red

Green

Blue

TEStyleTable[1777],

*STPtr,

lhHeight;

/*maximum

height

in

line*/

lhAscent;

/*maximum

ascent

in

line*/

typedef

struct

typedef

LHElement

LHElement

LHElement ;

LHTable[8001],

[0..8000]

struct

ScrpSTElement

long

scrpStartChar;

short

scrpHeight ;

short

scrpAscent;

short

scrpFont;

OF

*LHPtr,

LHElement

{
/*starting

character

/*line

height*/

scrpFace;

/*unpacked

byte*/

char

filler;

/*scrpFace

is

2-128

**LHHandle;

*/

Style
short

**STHandle;

{

short

ARRAY

color*/

STElement;

short

/*

style*/

style*/

/*absolute

STElement

LHElement

runs

scrpSize;

Summary
of TextEdit

unpacked

position*/

byte*/

CHAPTER

2

TextEdit

RGBColor

scrpColor;

typedef

struct

ScrpSTElement

typedef

ScrpSTElement

ScrpSTElement ;

ScrpSTTable[1601];

/*ARRAY

[0..1600]

OF

ScrpSTElement*/

struct
short

bi

STScrpRec

{

scrpNStyle;

ScrpSTTable

scrpStyleTab;

typedef

struct

typedef

StScrpRec

struct
long

bi

StScrpRec

of

styles

/*table

of

style

for

nullScrap;

NullStRec

/*handle

struct

typedef

NullStRec

*NullStPtr,

struct

TEStyleRec

{

for

to

future

scrap

nRuns;

/*number

nStyles;

/*size

of
of

style

style

table*/

runs*/
table*/

STHandle

styleTab;

/*handle

to

style

LHHandle

lhTab;

/*handle

to

line-height

runs

style

**NullStHandle;

short

teRefCon;

expansion*/

NullStTRec;

short

StyleRun

scrap*/

**StScrpHandle;

/*reserved

typedef

long

scrap*/

{

teReserved;

NullSTHandle

in

StScrpRec;

*StScrpPtr,

NullSTRec

StScrpHandle

/*number

/*reserved

table*/
table*/

for

application

nullStyle;

/*handle

to

style

[8001];

/*ARRAY

[0..8000]

set
OF

use*/
at

null

selection*/

StyleRun*/

bi
typedef

struct

typedef

TEStyleRec

struct
short
Style

char
short

TextStyle

TEStyleRec

TEStyleRec;

*TEStylePtr,

**TEStyleHandle;

{

tsFont;

/*font

tsFace;

/*character

Style*/

/*tsFace

unpacked

filler;
tsSize;

RGBColor

tsColor;

/*size

family

is
in

/*absolute

Summary
of TextEdit

number*/

byte*/

points*/
red,

green,

and

blue

color*/

2-129

CHAPTER

2

TextEdit

typedef

struct

typedef

TextStyle

TextStyle

typedef

short

TextStyle;

*TextStylePtr,

**TextStyleHandle;

TEIntHook;

Routines

Initializing TextEdit, Creating an Edit Record, and Disposing of an Edit Record
pascal

void

TEInit

(void) ;

pascal

TEHandle

TEStyleNew

(const

Rect

*destRect,const

Rect

*viewRect) ;

pascal

TEHandle

TENew

(const

Rect

*destRect,

Rect

*viewRect) ;

pascal

void

(TEHandle

TEDispose

const

hTE) ;

Activating and Deactivating an Edit Record
pascal

void

TEActivate

(TEHandle

hTE) ;

pascal

void

TEDeactivate

(TEHandle

hTE) ;

Setting and Getting an Edit Record’s Text and Character Attribute Information
pascal

void

TEKey

(short

key,

TEHandle

pascal

void

TESetText

(const

void

*text,

pascal

CharsHandle

void

length,

TEHandle

hTE) ;

hTE) ;

TESetStyleHandle
(TEStyleHandle

pascal

long

TEGetText
(TEHandle

pascal

hTE) ;

TEStyleHandle

theHandle,

TEHandle

hTE);

TEGetStyleHandle
(TEHandle

hTE) ;

Setting the Caret and Selection Range
pascal

void

TEIdle

(TEHandle

hTE) ;

pascal

void

TEClick

(Point

pt,

pascal

void

TESetSelect

(long

selStart,

Boolean

fExtend,

long

selEnd,

TEHandle

hTE) ;

TEHandle

hTE);

Displaying and Scrolling Text
pascal

void

TESetAlignment

(short

just,

TEHandle

hTE) ;

pascal

void

TEUpdate

(const

Rect

*rUpdate,

TEHandle

pascal

void

TETextBox

(const

void

*text,

short

just) ;

pascal

void

TECalText

(TEHandle

pascal

long

TEGetHeight

(long

2-130

Summary
of TextEdit

long

length,

hTE);
const

Rect

*box,

hTE) ;

endLine,

long

startLine,

TEHandle

hTE) ;

CHAPTER

2

TextEdit

pascal

void

TEScroll

( short

dh,

short

dv,

TEHandle

hTE) ;

pascal

void

TEPinScroll

( short

dh,

short

dv,

TEHandle

hTE);

pascal

void

TEAutoView

( Boolean

fAuto,

pascal

void

TESelView

( TEHandle

hTE);

TEHandle

hTE);

Modifying the Text of an Edit Record
pascal

void

TEDelete

( TEHandle

hTE) ;

pascal

void

TEInsert

( const

pascal

void

TECut

( TEHandle

hTE )

pascal

void

TECopy

( TEHandle

hTE ) f;

pascal

void

TEPaste

( TEHandle

hTE ) f

pascal

void

TEStylePaste

( TEHandle

hTE )

pascal

OSErr

TEToScrap

( void);

pascal

OSErr

TEFromScrap

( void);

void

*text,

long

length,

TEHandle

hTE) ;

f

Managing the TextEdit Private Scrap
#define

TEScrapHand1le()

(*

#define

TEGetScrapLength()

((long)

pascal

void

(Handle*)
*

OxAB4)

(unsigned

short

*)

Ox0ABO)

TESetScrapLength
(long

length) ;

Checking, Setting, and Replacing Styles
pascal

void

TESetStyle

(short

mode,

fRedraw,
pascal

void

TEReplaceStyle

pascal

Boolean

void

mode,

const

TextStyle

onst

TEStyleInsert

StScrpHandle
void

(short

*mode,

(const

void

long

hTE);
TextStyle

*oldStyle,

*newStyle,

Boolean

fRedraw,

TextStyle

*text,

TEUseStyleScrap
TENumStyles

Summary

hSt,

long

*aStyle,

TEHandle

hTE) ;

length,

TEHandle

hTE) ;

TEGetStyleScrapHandle
(long

of TextEdit

(long

hTE);

rangeStart,

newStyles,
pascal

Boolean

TEContinuousStyle

(TEHandle
pascal

*newStyle,

hTE);

STScrpHandle
pascal

TextStyle

TEHandle

(short

TEHandle
pascal

const

Boolean

rangeStart,

long

rangeEnd,

fRedraw,
long

StScrpHandle

TEHandle

rangeEnd,

hTE) ;

TEHandle

htTE);

2-131

CHAPTER

2

TextEdit

Using Byte Offsets and Corresponding Points
pascal

short

TEGetOffset

(Point

pt,

TEHandle

htTE);

pascal

Point

TEGetPoint

(short

offset,

TEHandle

(short

feature,

short

hTE);

Additional TextEdit Features
pascal

short

TEFeatureFlag

action,

TEHandle

hTE) ;

Customizing TextEdit
pascal

void

TECustomHook

(TEIntHook

which,

pascal

void

TESetWordBreak

(WordBreakProcPtr

wBrkProc,

TEHandle

hTE) ;

pascal

void

TESetClickLoop

(ClikLoopProcPtr

clickProc,

TEHandle

hTE) ;

Assembly-Language Summary
Trap Macros
Trap Macro Names
Pascal name

Trap macro name

TEContinuousStyle

_TEContinuousStyle

TEUseStyleScrap

_TEUseStyleScrap

TECustomHook

_TECustomHook

TENumStyles

_TENumStyles

TEFeatureFlag

_TEFeatureFlag

TEStylePaste

_TEStylePaste

TEReplaceStyle

_TEReplaceStyle

TEGetStyleHandle

_TEGetStyleHandle

TESetStyleHandle

_TESetStyleHandle

TEReplaceStyle

_TEReplaceStyle

TEGetStyleScrap

_TEGetStyleScrap

TEGetStyleHandle

_TEGetStyleHandle

TEGetStyleScrapHandle

_TEGetStyleScrapHandle

TEStyleInsert

_TEStyleInsert

TEGet

Point

_TEGet Point

TEGetHeight

_TEGetHeight

2-132

Summary
of TextEdit

ProcPtr

*addr,

TEHandle

hTE);

CHAPTER

2

TextEdit

Global Variables
WordRedraw
TEFindWord
TERecal
TEDoText
TEScrpHandle
TEScrapLength

Used for line calculations to determine how much of a line must be redrawn after
a character is entered.
TextEdit@ word selection and line breaking routine.
The address of the routine called by TECal Text to recalculate the line starts
and set the rst and last characters that need to be redrawn.
The address of a multi-purpose text editing routine used to display, highlight,
and hit-test characters, and position the pen to draw the caret.
A handle to the TextEdit private scrap.
The size of the TextEdit scrap in bytes.

Summary of TextEdit

2-133

C

HAPTER 3

QuickDraw Text

Contents
About QuickDraw Text

3-4

Graphics Ports and Text Drawing

= 3-4

Font, Font Style, and Font Size

3-5

Transfer Modes
3-8
QuickDraw Text, Script Systems, and Other Managers
Text Formatting and Justi cation
3-13
Scaling
3-15
Carets and Highlighting
3-16
Using QuickDraw Text
3-17
Preparing to Use QuickDraw
3-17
Determining the Version and Initializing QuickDraw

Setting Up the Text-Drawing Environment
3-19
Specifying Text Characteristics
3-19
Setting the Font
3-20
Modifying the Text Style
3-21
Changing the Font Size
3-22
Changing the Width of Characters
3-22
Using Fractional Glyph Widths — 3-23
Specifying the Transfer Mode
3-24
Basic Transfer Mode Operations
3-24
Arithmetic Transfer Mode Operations
3-25
The grayishTextOr Transfer Mode — 3-26
Text Mask Mode
3-26
Transparent Transfer Mode
3-27
Transfer Modes and Multibit Fonts
3-27
Measuring and Drawing Single Segments of Text
= 3-27
Individual Glyphs
3-28
Pascal Strings
3-28
Text Segments
3-29

Contents

3-10

3-18

3-1

CHAPTER

3

Measuring and Drawing Lines of Text = 3-29
Determining Where to Break the Line
—3-30
Determining the Display Order for Style Runs — 3-33
Eliminating Trailing Spaces (for Justi ed Text)
3-36
Calculating the Slop Value (for Justi ed Text)
3-39
Allocating the Slop to Each Style Run (for Justi ed Text)
3-39
Drawing the Line of Text
3-42
Using Scaled Text
3-44
Drawing Carets and Highlighting
3-47
Converting an Onscreen Pixel Location to a Byte Offset
3-49
Finding a Caret Position and Drawing a Caret
3-49
Synchronizing the Caret With the Keyboard Script
3-59
Highlighting a Text Selection
3-60
Customizing QuickDraw@ Text Handling
3-62
Text in QuickDraw Pictures

Fonts
3-63
Text With Multiple Style Runs

QuickDraw Text Reference

3-63

3-65

3-65

Data Structures
3-66
The Font Information Record
3-66
The Style Data Type
3-66
Routines
3-67
Setting Text Characteristics
3-68
Drawing Text
3-76
Measuring Text
3-81
Laying Outa Line of Text
3-87
Determining the Caret Position, and Selecting and Highlighting
Text
3-91
Low-Level QuickDraw Text Routines

Application-Supplied Routine
3-100
Summary of QuickDraw Text
3-102
Pascal Summary
3-102
Constants
3-102
Data Types
3-102
Routines
3-103
C Summary
3-105
Constants
3-105
Types
3-105
Routines
3-106
Assembly-Language Summary — 3-107
‘Trap Macros
3-107
Global Variables
3-108

3-2

Contents

3-98

CHAPTER

3

QuickDraw Text

This chapter describes the text-handling components of QuickDraw. You can use the
QuickDraw text routines to measure and draw text ranging in complexity from a single
glyph to a line of justi ed text containing multiple languages and styles. In addition to
measuring and drawing text, the QuickDraw text routines also help you to determine
which characters to highlight and where to position the caret to mark the insertion point.
These routines translate pixel locations into byte offsets and vice versa.
Read this chapter if you are writing an application that draws static text in a box, such as
a dialog box, or draws and manipulates text of any length in one or more languages.
Before you use the routines described in this chapter, read the chapter Gntroduction to
Text on the MacintoshOin this book. To understand the concepts and routines described
in this chapter, you must be familiar with the other parts of QuickDraw described in
Inside Macintosh: Imaging.
Read this chapter along with the chapter (Font Manager,Oin this book, because of the
close relationship between QuickDraw and the Font Manager. For help in understanding
the tasks involved in text layout, refer to the chapters (fext UtilitiesOand CScript
Manager,Oalso in this book.

This chapter explains how to set up the text-drawing environment and lay out and draw
text, including how to
m

draw and measure a single character, a text segment, or a line of text

m

determine where to break a line of text

m determine the order in which to draw text segments for a line of text containing
multiple styles and mixed directions
m eliminate trailing space characters
m distribute extra space throughout a line of text to justify it appropriately for the
script system
m

draw and measure scaled text

m

identify caret positions for marking an insertion point and highlighting text

3-3

CHAPTER

3

QuickDraw Text

About QuickDraw Text
Text on the Macintosh is graphical. This section provides an overview of how to draw
text using the text-handling components of QuickDraw. These routines let you direct how
the text is to be rendered and drawn, while insulating your application from the
low-level implementation details.
Whether for onscreen display or to be printed, you always draw text in the context of a
graphics port. To draw the text, QuickDraw displays the bitmap of each glyph on the
display device. Although QuickDraw displays the text, you de ne how the text is to be
rendered by setting the text-drawing parameters in the graphics port record. Text
rendering is the process of portraying the text according to its character attributes, such
as the font, font size, and style. You use the character attribute information associated

with the text to set up the drawing environment each time you draw a segment of text
that begins a new style run. A style run is a sequence of text that is all in the same script
system, font, size, and style.

QuickDraw routines let you accept keyboard input or gain access to existing text stored
in memory. In general, the tasks that you need to perform to draw text on the Macintosh
are easier if your store the text as a simple sequence of character codes separate from all
the character attribute information that describes how QuickDraw is to render the stored

text. (For an example of how to de ne data structures to store the character attribute
information, you can look at the TextEdit data structures used for this purpose; see the
chapter (fextEditOin this book.)

Graphics Ports and Text Drawing
You draw text on the Macintosh in the current graphics port according to the graphics
environment de ned by the graphics port record. A graphics port de nes where and
how graphic and text drawing operations are to take place. QuickDraw treats the
graphics port information as its primary set of global information.
You can de ne many graphics ports on the screen, each with its own complete drawing
environment, and easily switch between them. Because QuickDraw always draws in the
current graphics port, it is essential that you keep track of which one this is.
Each graphics port is tied to a window. To draw in the graphics port of a window, you
rst need to make the port the current one. (You do this using the Set Port procedure,
described in Inside Macintosh: Imaging.) The window whose port you want to draw in
does not have to be active or the frontmost window. QuickDraw draws to the current

graphics port identi ed by Set Port. You can draw to a background window or an
inactive window by making its port the current one.

There are two types of graphics ports: the original version (Graf Port) that supports
mainly black-and-white drawing with some rudimentary color capabilities and the color
graphics port (CGrafPort), which supports all of the characteristics of the
original graphics port, plus additional features including color facilities.

3-4

About QuickDraw Text

CHAPTER

3

QuickDraw Text

Both types of graphics port records contain elds that specify the colors to be used for the
foreground (£gColor) and the background (bkColor) of a glyph. You can think
of the foreground as the pixels that constitute the glyph, and the background as
the pixels that surround the glyph. In terms of a black-and-white screen, the foreground
pixels of a glyph are black, and the surrounding background pixels are white.
The original graphics port provides eight colorsN black, white, red, green, blue, cyan,
magenta, and yellow; however, on a black-and-white screen nonwhite colors appear as

black. A color graphics port provides a wide range of possible colors that allow you to
portray all aspects of the user interface in color, including the representation of text. Both
types of graphics ports maintain the fractional horizontal pen position, so that a series
of text-drawing calls accumulates the fractional position. For the color graphics port, this
value is maintained in a graphics port record eld. For the original graphics port,
this value is maintained in a grafGlobal, which is reset whenever you reposition
the pen.
There is only one QuickDraw text-handling procedure that requires a color graphics port,
CharExtra. (Although you can call CharExtra for an original graphics port without

causing the system to crash, CharExt ra produces no result.) You can use all
the other QuickDraw text routines with either an original graphics port or a color
graphics port.

Fields in the graphics port record determine which font QuickDraw is to use to portray
the text, the font style, the font size, and how the bits forming the glyph are to be placed
in the bit image. You control how the text is to be rendered by setting each of these elds
before you measure or draw a segment of text that begins a new style run. QuickDraw
provides procedures that let you set each _ eld. To ensure future compatibility, you
should always use these procedures rather than directly modify a eld. You use the
appropriate QuickDraw procedure to set the graphics port eld for the style run to
be drawn, if the current value of a eld differs from the characteristic that you
want QuickDraw to use. The following sections describe what each of these eld
values represents.

Font, Font Style, and Font Size
This section provides an overview of how QuickDraw and the Font Manager interact to
provide the font that you specify in the graphics port to be used to render the text.
The Font Manager keeps track of detailed font information, such as the glyphsCtharacter
codes, whether fonts are xed-width or proportional, and which fonts are related to each
other by name. When you make a call to QuickDraw to measure or draw text,
QuickDraw passes the font request, including the font@ size and style that you have set
in the current graphics port, to the Font Manager, and the Font Manager satis es the
request as best as possible, returning to QuickDraw a bitmap of the glyph of the font,
along with some information that QuickDraw uses for stylistic variation and layout.
When QuickDraw receives the bitmap, it transfers the bitmap to the screen. If necessary,
QuickDraw rst scales the bitmap, or applies stylistic variation to it if the requested style
was not intrinsic to the font.

About QuickDraw Text

3-5

CHAPTER

3

QuickDraw Text

The Macintosh supports two types of fonts: bitmapped and outline. A font is a complete
set of glyphs ina speci c typeface and styleN and in the case of bitmapped fonts, a
speci c size. Outline fonts consist of outline glyphs in a particular typeface and style with
no size restriction. The Font Manager can generate thousands of point sizes from the
same TrueType outline font. For example, a single outline Courier font can produce
Courier 10-point, Courier 12-point, and Courier 200-point. (You can read more about
these two types of fonts and the relationship between QuickDraw and the Font Manager
in the chapter (Font ManagerOin this book. How the Font Manager responds to a
QuickDraw font request is also explained in detail in the chapter Font Manager,Oand
summarized later in this chapter.)
When multiple fonts of the same typeface are present in system software, the Font
Manager groups them into font families. Each font in a font family can be bitmapped or
outline. Bitmapped fonts in the same family can be different styles or sizes.
A font has a name and a font family ID number. A font name is usually the same as the
typeface from which it is derived, such as Courier. If an intrinsic font is not in plain style,
its style becomes part of the font@ name, for example, Courier Bold. A font family ID is a

resource ID for a font family that identi es the font and also reveals the script system to
which the font belongs. When you set the graphics port font eld (txFont) fora style
run, you specify the font family ID. The font family ID identi es to the Font Manager
both the font and the script system to be used.

Some fonts are designed and supplied with stylistic variations integral to the font. If the
Font Manager does not return a font with the requested style integral to the font design,
QuickDraw applies the style. A font designer can design a font in a speci c style, such as
Courier Bold, or QuickDraw can add styles, such as bold or italic, to bitmaps.

A style is aspeci c variation in the appearance of a glyph that can be applied
consistently to all the glyphs in a typeface. A font is described as plain when no styles are
speci ed for it. The styles that QuickDraw supports include bold, italic, underline,
outline, shadow, extend, and condense.

When QuickDraw requests a font in a speci c style, such as Courier Bold, if the Font
Manager has the font whose design includes the style, the Font Manager returns that font
to QuickDraw; QuickDraw does not need to apply the stylistic variation when drawing
the font, in this case. If the Font Manager does not have the font with the stylistic
variation intrinsic to it, the Font Manager returns the plain font to QuickDraw, and

QuickDraw applies the style when drawing the glyphs. When QuickDraw requests a font
with multiple styles, if the Font Manager does not have a font with all of the styles
intrinsic to it, but it has a font with one intrinsic style, the Font Manager returns that font,
and QuickDraw applies the additional style or styles when drawing the glyphs. The Font
Manager does not apply stylistic variations to a font.
Figure 3-1 illustrates the styles that QuickDraw supports as applied to the Helvetica font.
There are many other stylistic variations not explicitly supported by QuickDraw, such as
strikethrough, that you can implement.

3-6

About QuickDraw Text

CHAPTER

3

QuickDraw Text

Figure 3-1

Stylistic variations

Plain characters
Bold characters
Italic characters

Underlined characters xyz
Outlined characters
Condensed characters
Extended characters
Bold italic characters

Bole outlined underlined characters
You can specify stylistic variations alone or in combination. (Certain styles may be
disabled in some script systems.) Most combinations usually look good only for large
font sizes. Here are the results of specifying any of the styles that QuickDraw supports:
Bold increases the thickness of a glyph. It causes each glyph to be repeatedly drawn
one bit to the right for extra thickness.
Italic adds an italic slant to the glyphs. Glyph bits above the base line are skewed right;
bits below the base line are skewed left.
Underline draws a line below the base line of the glyphs. If part of a glyph descends
below the base line (as does the y shown in the fourth line of text in Figure 3-1),
generally, the underline isn®@drawn through the pixel on either side of the descending
part. However, when printing to a PostScript

through the descenders.

LaserWriter printer, the line is drawn

Outline makes a hollow, outlined glyph rather than a solid one. If you specify bold
along with outline, the hollow part of the glyph is widened.

Shadow also makes an outlined glyph, but the outline is thickened below and to the
right of the glyph to achieve the effect of a shadow. If you specify bold along with
shadow, the hollow part of the glyph is widened.
Condense affects the horizontal distance between all glyphs, including spaces.
Condense decreases the distance between glyphs by the amount that the Font
Manager determines is appropriate.
Extend affects the horizontal distance between all glyphs, including spaces. Extend
increases the distance between glyphs by the amount that the Font Manager
determines is appropriate.

About QuickDraw Text

3-7

CHAPTER

3

QuickDraw Text

The style underline draws the underline through the entire text line, from the pen
starting position through the ending position, plus any offsets from the font or italic
kerning. QuickDraw text clips the right edge of the underline to the ending pen position,
causing outlined or shadowed underlines to match imperfectly when you draw text in
sections. If the underlined text is outlined or shadowed, the ends aren®capped, that is,
consecutively drawn pieces of text maintain a continuous underline.
Note that the outline and shadow styles cause the outline and shadow of the glyph to be
drawn in the foreground color. The inside of the glyph, if drawn at all, is drawn in the

background color.

Transfer Modes
A transfer mode speci

es the interaction between what is to be drawn with what already

exists on the screen. When you draw text, QuickDraw uses the foreground and
background colors to determine how the text to be drawn, called the source, interacts

with text already drawn in the current graphics port, called the destination. You de ne
how this interplay is to occur by specifying a transfer mode, which is a value consisting
of two parts. The rst part is the kind of transfer mode. It speci es whether the graphic to
be drawn is a pattern or text. The second part is the operation. It is a Boolean value that
de nes the type of interaction that is to occur, resulting in the text display.
There are two basic kinds of transfer modes in QuickDraw: pattern (pat), which is used
to draw lines or shapes in a pattern, and source (src), which is used to draw text. There

are four basic types of operations, totaling eight including their opposites. They are:

Copy, Or, Xor, and Bic. In addition to the basic operations, there are arithmetic drawing

mode operations designed speci

cally for use with color.

When you draw text, for each bit in the text, the corresponding bit in the destination
bitmap is identi ed, the speci ed Boolean operation is performed on the pair of bits, and
the resulting bit is stored into the destination bit image. The basic operations produce the
following results.
The Copy operation replaces the pixels in the destination with the pixels in the source,
painting over the destination.
For black-and-white images, the Or, Xor, and Bic operations leave the destination pixels

under the white part of the source unchanged. These operations differ in how they affect
the pixels under the black part.
m Or replaces those pixels with black pixels, overlaying the destination with the black
part of the source; it combines the destination with the source.

m Xor inverts the pixels under the black part. (The Xor mode inverts black in the source
image at all destination depths, including 16-bit and 32-bit direct pixels.)
m Bic (bit clear) erases the pixels under the black part, leaving it white.

3-8

About QuickDraw Text

CHAPTER

3

QuickDraw Text

Figure 3-2 shows how each of the basic transfer modes affects the source and destination
images resulting in what is displayed on the screen.
Figure 3-2

Effect of the basic transfer modes for black-and-white images

S,

Yj

Source
“Paint”

Destination

“Overlay”

OlO4,

(Ma:

(4 4h

srcOr

srcXor

srcBic

Yn

\ fr

notSreXor

notSrcBic

fy

“Wn
notSrcCopy

“Erase”

47%

Jr4“¢
srcCopy

“Invert”

notSrcOr

va

4

GA

7]

lg

\r%4

These transfer modes work with color images as follows:
m

Copy replaces the destination with the colored source.

m Or mode results in the source image, regardless of the destination depth.
m™ Bic mode causes the foreground color in the source image to erase, resulting in the
background color in the destination image.
m Xor inverts the foreground color in the source image, but not the background color, at
all destination depths, including 16-bit and 32-bit direct pixels. (Inversion is not well
de ned for color pixels.)
The initial transfer mode for drawing text is srcOr. This text drawing mode is
recommended for all applications because it uses the least memory and draws the entire
glyph in all cases. The srcOr mode only affects other parts of existing glyphs if the
glyphs overlap.
Note
The center of shadowed or outlined text is drawn in a graphics port in
srcBic transfer mode if text mode is srcOr, for compatibility with old
applications. (For color graphics ports, the center isn®drawn at all.) This
allows black text with a white outline on an arbitrary background. #

About QuickDraw Text

3-9

CHAPTER

3

QuickDraw Text

QuickDraw Text, Script Systems, and Other Managers
Although QuickDraw provides the routines that are pivotal to drawing text on the
Macintosh, it uses the services of other managers including the Font Manager and the
Script Manager. To draw text consisting of multiple lines and mixed directions, you also
need to use routines that belong to these managers, as well as some Text Utilities services.
This section describes the relationship between QuickDraw and the Script Manager. It
also provides an overview of the line-layout and text-drawing processes. For speci c
discussion of the routines that you use to perform the tasks inherent in these processes,
see (Measuring and Drawing Lines of TextOon page 3-29.
When you draw text using QuickDraw, the Script Manager interacts with QuickDraw to
provide the script-speci c support. To do this, the Script Manager needs to know which
script you are using. It determines this from the font that you specify in the graphics port
txFont eld. For example, if the font is Geneva, the font script is Roman. The script
speci ed by the current graphics port font is referred to as the font script.
Although you can use most QuickDraw routines with all script systems, some
QuickDraw routines entail restrictions. For example, you use one QuickDraw procedure
to draw the glyph of a single character in a 1-byte script system, but you must use a
different procedure to draw the glyph of a single character in a 2-byte script or a script
system that contains zero-width characters. Some script systems contain fonts that have
only 1-byte characters and some script systems contain fonts that have a mix of 1-byte
and 2-byte characters. Some fonts have zero-width characters; these are usually

overlapping diacritical marks which typically follow the base character in memory.
With 2-byte characters, all but the rst (high-order, low-address) byte are measured
as zero width.
Most fonts, whatever script system they belong to, contain Roman characters, typically
consisting of the 128 low-ASCII character set. The inclusion of Roman characters within
another script system allows the user to enter Roman text without having to switch script
systems. For script systems whose text has a left-to-right direction, such as Roman and
Japanese, the direction of the text is uniform within a single style run. However, a single
script system that portrays text read from right to left, such as Hebrew or Arabic, can also
contain left-to-right text, such as numbers within the language of the script system or
Roman-based text such as English. A single style run can also contain bidirectional text.
Some script systems that include the 128 low-ASCII character set include an associated
font that is used to portray these characters. Use of an associated font is handled by the
script management system without requiring any action on the part of your application.
The way QuickDraw treats Roman space characters within a script system that supports
bidirectional text differs from how it handles them otherwise. This behavior is explained
later in this chapter in relation to eliminating trailing spaces from the end of a line.

3-10

About QuickDraw Text

CHAPTER

3

QuickDraw Text

For those script systems that support it, the existence of bidirectional text in a text range
does not violate the concept of a single style run because QuickDraw uses the same
text-related values in the graphics port record elds to draw all the glyphs of the entire
segment of text; you do not need to change any of these values in order to draw the
complete segment of bidirectional text as a single style run.
Figure 3-3 shows mixed Hebrew and Chinese text on a single line. There are three style
runs. Only the rst style run includes bidirectional text.
Figure 3-3

Byte

offsets

Multiple style runs on a single line

Character

codes

Characters

O|

$41

A)

1

$42

B

2}

gaa

=} seo

IC

3

$E0

N

5

E2

i

ga473

| IL

gA4r4

| 7K

$A4EC

| 7X

6
7
8
9

A

$

B

Primary line direction
Style

runs

$E0

D

$E1

4

E

$E2

B]

——_§_|_—__—_.

—_——_

—_—_§_—__—_.

N
=<

_,

Cc

a

ABCXINWKAIIN
JDL
JDL
)
——_——_r

Style runs

[eh]

N |

-

For all script systems, you measure and draw text a single style run at a time, whether the
text consists of a single character, a Pascal string, or a segment of characters. A text

segment, as used in this chapter, means the portion of a style run that you may pass toa
single QuickDraw call. It may be a complete style run or any portion of a style run, as
long asit ts ona single line. If a style run extends across a line break, you must make
separate calls for the separate segments of the style run.

About QuickDraw Text

3-11

CHAPTER

3

QuickDraw Text

Whether you draw the glyph of a single character or a line of text, it is up to you to track
where the text begins, both in terms of vertical and horizontal screen position and offset
into your text stream. With the help of either a Font Manager function
(Out

LineMet rics) or a QuickDraw procedure (Get Font

Info), you can assess the line

height based on the measurements of the script system font, and the associated font, if
one exists, used to render the text, then determine the vertical screen position.

In most cases, you also need to know the width of the display area where the text is to be
drawn. For a line of text, you can think of this area as the display line. A display line is
the horizontal length in pixels of the screen area where you draw a line of text; the left
and right ends of the display line constitute its left and right margins. You de ne the
display line length in pixels and uses this value to determine how much text will ton
the display line.
You specify where QuickDraw is to begin drawing by setting the current pen location of
the graphics port. Within a single line of text, QuickDraw takes care of correctly
advancing the pen position after it draws each glyph or text segment.
For text that exceeds a single display line, you must control where a line ends and the
next one begins. For unidirectional text, this task essentially constitutes the line layout
process. For mixed-directional text, the order in which you display the style runs may be
different from their storage order. In this case, you also need to determine the drawing
order in the line layout process.
To draw a line of text, you can loop through the text, laying it out rst, then loop through
the drawing process. A line-layout loop measures the text and determines where to break
it. In most cases, you can use a Text Utilities function (StyledLineBreak) for this
purpose.
To lay out justi ed text, a loop needs to include several additional steps that determine
how to distribute the extra space among the text of the line. This process entails
eliminating trailing spaces from the end of the line, then distributing the remaining extra

space among the text. How the distribution of extra space is expressed throughout a line
of text is dependent on the script system. For example, some script systems add
additional width to space characters that are used as word delimiters; some script
systems, which use connecting glyphs, stretch certain glyphs to encompass the additional
width. See the next section, Ofext Formatting and Justi

cation,Ofor more information.

Before you call a QuickDraw measuring routine, you need to set the graphics port
text-related elds to those of the style run that the text is part of. You set these elds only
for each new style run.
Once you have laid out a line of text, drawing it is fairly simple. An application can have
a text-drawing loop that positions the pen at the beginning of a new line, sets the
text-related elds of the current graphics port to the text characteristics for that style run
if the text string begins a new style run, then draws the text, using one of the QuickDraw
drawing routines to draw aligned text, justi

3-12

About QuickDraw Text

ed text, or scaled text.

CHAPTER

3

QuickDraw Text

Text Formatting and Justification
When you lay out text, you can change its width and its alignment. You change the width
of text to format it for special purposes, or to justify the text to ta display area or a given
line. To justify text, you spread or condensed it so that any white space is distributed
evenly throughout the display area or line.
You can draw text that is aligned with either the right margin of the display area or line,
which produces ragged-left text, or the left margin, which produces ragged-right text.
You align text by positioning the pen appropriately so that the rst glyph of the text line
is fSush against the margin.
There are several ways to change the width of text. You can
m use the QuickDraw justi cation routines that measure and draw text, automatically
changing the width of the text appropriately for each script system
m set the graphics port txFace

eld to condense or extend the text

m set the graphics port spExtra and chExtra_ elds to narrow or widen space and
nonspace characters by a speci c number of pixels
You can even justify text that includes special formatting. For example, you can extend or
condense the width of space and nonspace characters, while justifying the text
line overall.
Of these methods, the easiest way to justify text for all script systems is to use the
QuickDraw justi cation routines. These routines handle the script system requirements
for your application. For example, because the text of some script systems, such as Arabic
and Devanagari, is drawn as connected glyphs, the justi cation routines do not add
width to or remove it from nonspace characters.
The justi cation routines assume that a slop value speci ed in pixels is to be distributed
throughout the text. The slop value is the difference between the width of the text and
the width of the display area or line. You can pass the justi cation routines a positive or
negative slop value. To extend text to t the display area or line, you specify a positive
slop value. To justify a line of text more smoothly by condensing it when it only slightly
exceeds the display area or line length, you can use a negative slop value.
How the justi cation routines distribute this extra space within a style run depends on
the script system.
m= For Roman script systems, text justi cation is performed by altering the size of the
space characters. You can think of this as interword spacing. (Every space in a style

run is allocated the same amount of extra width and thus is the same size, whether or

not it is at the beginning or end of the line or the style run.)

m For Arabic, the justi cation routines insert extension bar glyphs between joined glyphs
and widen space characters to Il any remaining gaps.
= For scripts that don®use spaces to delimit words, these routines usually modify the
intercharacter spacing to achieve justi cation.

About QuickDraw Text

3-13

CHAPTER

3

QuickDraw Text

Figure 3-4 shows a line of text in the Roman script system containing three style runs and
how extra space is distributed among the space characters within a style run.
Figure 3-4

Justification of Roman text

Beginning of line
Style
runs

|

Style run 1

-_ 2)

width

End of line

|

ppBAB

Style run 2

sees)

Style run 3

|

Se AB

To correctly handle spacing between multiple style runs on a line, the justi cation
routines take a parameter that speci es the position of the style run on the line. The style
run position parameter is meaningful only for those script systems that use intercharacter
spacing for justi cation. For all other script systems, the parameter exists for future
extensibility. Although the style run position parameter is not used, for example, for
justifying text in the Roman script system, to allow for future compatibility, you should
always specify the appropriate value for it for all calls that take it.
For those script systems that do use intercharacter spacing, space between styles is
allocated differently depending upon whether the style is leftmost, rightmost, or between
two other style runs. For example, if a style run occurs at the beginning or end of a line,
extra space is not added to the outer edge of the outermost glyph, whereas if a style run is
interior to a line, all of the glyphs of the text are treated the same: extra space is allocated
to both sides of every glyph including those at either end of the style run.
Note
The text justi cation routines do not automatically eliminate trailing
spaces from the last style run on the line. However, QuickDraw provides
a routine (VisibleLength) that does not include trailing spaces in the
byte count of the last style run on the line. #
If you do not want to justify a range of text, you can change the width of the text for
onscreen display, for example, to format an advertisement by setting the graphics port
SpExtra and chExtra_ elds to an amount by which space and nonspace characters are
to be widened or narrowed. If you use SpaceExt ra and CharExtra to widen or
narrow text, you are responsible for handling them properly for the script system.
The original graphics port does not have a chExtra_ eld, so you can only change the
width of nonspace characters if you use a color graphics port. Although line breaks are
maintained, spacing de ned by these values is not preserved when you print to a
LaserWriter printer.

3-14

About QuickDraw Text

CHAPTER

3

QuickDraw Text

Scaling
Text scaling is the process of changing glyphs from one size or shape to another. This
section discusses two kinds of scaling: implicit and explicit. This section also summarizes
how the Font Manager handles scaling requirements when scaling is disabled. The
chapter (Font ManagerOin this book describes disabling scaling in greater detail.
Implicit scaling is performed automatically by QuickDraw when the Font Manager
cannot supply a bitmapped font in the size that you request. In this case, the Font
Manager returns to QuickDraw a bitmapped font that is the closest approximation, along
with scaling factors. QuickDraw uses these values to scale the text when drawing it. This
process is transparent to your application. Because the Font Manager can always satisfy a
font request completely when outline fonts are installed, no scaling is necessary.
Explicit scaling is performed in essentially the same way as implicit scaling, but you
specify how the text is to be scaled. Several QuickDraw routines include parameters that
let your application specify (explicitly) how text is to be scaled. You might want to scale
text explicitly, for example, to create unusual glyph shapes, or to increase or decrease the
size of text when a user clicks in a zoom box. You can use the high-level QuickDraw
justi cation routines to explicitly scale text. Alternatively, you can use the low-level
standard measuring and drawing routines, referred to as bottleneck routines. See QUsing
Scaled TextOon page 3-44. To explicitly scale text, you specify values that let you stretch
or shrink a glyph horizontally or vertically. You can change a glyph from a familiar point
size to one that is unusualN for example, a glyph that is 12 points high but as wide as
the entire page.
The same rules apply to the interaction between the Font Manager and QuickDraw
whether scaling is implicit or explicit. However, for explicit scaling, QuickDraw passes
the scaling factors that you specify as routine parameters to the Font Manager in an input
record (FMInput) along with the standard information, which includes the font family
ID number, the size, and the stylistic variation of the font request. Taking the requested
scaling factors into account, the Font Manager follows a standard path looking for an
available font that best satis es the request, and returns the bitmap information to
QuickDraw via an output record (FMOut put), which contains a handle to the requested

font resource and, among other information, the scaling factors that now apply, if any.
The returned scaling factors describe how QuickDraw is to draw the text to ful ll the
input scaling factors request.

If you use the low-level bottleneck procedure or the higher-level justi cation procedure
to draw the scaled text and the Font Manager returns scaling factors to be applied to the
text, QuickDraw applies the additional scaling.
The low-level bottleneck measuring function lets you specify scaling factors in reference
parameters. If only bitmapped fonts are installed and a font does not exist that matches
the scale you specify, the Font Manager uses the font that best approximates the request,
and measures the text using that font. The Font Manager returns scaling factors in the
reference parameters, along with the width of the text based on the supplied font. In this
case, QuickDraw does not apply the necessary additional scaling to the text to give you
the correct text measurement including scaling. To measure the text correctly, you need to
apply the additional scaling to the text width of the font that the Font Manager returns.

About QuickDraw Text

3-15

CHAPTER

3

QuickDraw Text

For example, suppose only bitmapped fonts are installed and you request a point size of
24 with a horizontal scaling factor of 2/1 and a vertical scaling factor of 1/1. The Font
Manager returns the most optimal matching font that it has, which is 12, say, with a
horizontal scaling factor of 4/1 and a vertical scaling factor of 2/1. Now, you must apply
these scaling factors to the text width and height metrics in the 12-point font to get the
correct text measurement.

You can use the Font Manager Set FScaleDisable procedure to enable or disable font
scaling of bitmapped glyphs. When you disable scaling, the Font Manager nds the
closest, smaller-sized font to the one that you request, and adjusts the width table
associated with the font to match the requested size. As a result, the height of the glyphs
is smaller than you requested, but the spacing compensates for it. When scaling is
disabled, the Font Manager returns 1/1 scaling in response to the request.
For a complete discussion of how the Font Manager determines which font to return to
QuickDraw to satisfy a font request, see the chapter Font ManagerOin this book. This
chapter also describes the Set FScaleDisable procedure and the width table.

Carets and Highlighting
Highlighting a selection range and marking the insertion point with a caret both involve
converting offsets of characters in a text buffer to pixel locations on a display screen. This
task is prerequisite to both drawing a caret and highlighting text. See the chapter
Ontroduction to Text on the MacintoshOin this book for a discussion of the conventions
underlying the relationship of a character at a byte offset to a caret position for
unidirectional text and text at a direction boundary.
When the text is unidirectional, performing these tasks is uncomplicated because storage
order and display order are the same. For unidirectional text, a caret position always falls
between the corresponding glyphs of these charactersN on the leading edge of one and
the trailing edge of the other. When the text is bidirectional, it can contain characters that
occur on direction boundaries; although the characters are stored contiguously in
memory, the leading edge of one character@ glyph does not constitute the trailing edge of
the other in display order. Consequently, two physically separate caret positions exist on
the display screen, one associated with each glyph.
There are a number of situations in which you need to know a caret position, and they
fall within two categories: drawing a caret to mark the insertion point, and using a caret
position to denote an endpoint for highlighting a text selection. For a discussion of
marking an insertion point with either a single caret or a dual caret, and caret movement
with arrow keys, see the chapter introduction to Text on the Macintosh.O

3-16

About QuickDraw Text

CHAPTER

3

QuickDraw Text

You need to know the caret positions marking the endpoints of a text selection to
highlight it when the user selects either a word or a range of text, and for other features
that the application supports, such as a search operation. Generally, you know the byte
offsets of the characters that begin and end a selection range for tasks such as search
operations. However, when the user clicks in or selects a range of text to be highlighted,
usually you rst need to convert the pixel locations marking the cursor locations to the
corresponding charactersCbyte offsets in memory, and then convert the charactersChyte
offsets to caret positions.To encompass all of the characters within the text segment to be
highlighted, you use caret positions that mark endpoints which include the beginning
and ending characters of the text.
On a black-and-white screen, highlighting a selection is simple; white pixels turn black
and vice versa. In a color environment, the inversion of multibit pixel values usually
yields many different colors, which is unsuitable for highlighting text. To highlight text

rendered in color, QuickDraw lets you specify a highlight value that it uses instead of the
current graphics ports background color. Generally the user sets the highlighting color,
but your application can change the color. When you use highlight mode, all pixel values
of the current background color are replaced with the value of the highlighting color.

Using QuickDraw Text
This section describes how to
m

initialize QuickDraw

m set up the text drawing environment
m

specify the text characteristics, such as the font, style, spacing, and transfer mode

m™ measure and draw text ranging from a single character to a line containing multiple
styles and mixed directions

Preparing to Use QuickDraw
The QuickDraw text-handling routines rely on both QuickDraw and the Script Manager.
Therefore, before you call any of these routines, you need to determine what versions of
QuickDraw and the Script Manager are installed, and initialize QuickDraw. For more
information about determining the version of the Script Manager, see the chapter CScript
ManagerOin this book.

Using QuickDraw Text

3-17

CHAPTER

3

QuickDraw Text

Determining the Version and Initializing QuickDraw
To determine the current version of QuickDraw, you call the Gestalt function with the
gestaltQuickdrawVersion selector. The gestaltQuickdrawVersion selector

returns a 2-byte value indicating the version of QuickDraw currently present. The
high-order byte of that number represents the major revision number, and the low-order
byte represents the minor revision number. These are the currently de ned values for the
QuickDraw selector.
Constant

Value

gestaltOriginalQD

$000

gestaltOriginalQD1

S001

gestalt8BitQD

S100

gestalt32BitQD

S200

gestalt32BitQD11

$210

gestalt32BitQD12

$220

gestalt32BitQD13

$230

Gestalt returns a 4-byte value in its response parameter; the low-order word contains
QuickDraw version data. In that low-order word, the high-order byte gives the major
revision number and the low-order byte the minor revision. Major revisions currently
de ned are the original QuickDraw, the original Color QuickDraw, and the current 32-Bit
QuickDraw with direct-pixel capability.

Values having a major revision number of 1 or 2 indicate that Color QuickDraw is
available in either the 8-bit or 32-bit version. These results do not, however, indicate

whether a color monitor is attached to the system. You need to use high-level QuickDraw
routines to obtain that information.
Many Macintosh applications don@care what version of QuickDraw is available on the
user@ system: they don@®use color at all, use only the basic QuickDraw color model, or
specify all their colors abstractly, in RGB form. If your application does depend on a
speci c version of QuickDraw, you can check the version at run time and adapt to make
best use of the available hardware (or at least inform the user gracefully that your
program@ graphics needs aren®being met).
For more information about the Gestalt function, see the chapter Gestalt ManagerOin

Inside Macintosh: Operating System Utilities.

Initialize QuickDraw at the beginning of your program before any other parts of the
Toolbox. To do so, call the InitGraf procedure. For more information about the
InitGraf procedure, see Inside Macintosh: Imaging.

3-18

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Setting Up the Text-Drawing Environment
You draw text in the current graphics port. You create a distinct graphical environment
for every window on the screen by specifying values for the graphics port. Each graphics
port has its own complete drawing environmentN including its own coordinate system,
drawing location, font set, and character attributes.

Because your application can have more than one window open at the same time,
QuickDraw routines access the data structures within the current graphics port only. You
must keep track of the current graphics port and identify it to QuickDraw when you
change windows.
You can use the QuickDraw Set Port procedure, which operates on both types of
graphics ports (Graf Port and CGrafPort), to identify the current graphics port. You
use the global variable thePort to indicate the current port. In the following example,
Set Port identi es the port pointed to by thePort as the current one.
SetPort

(thePort)

;

For more information about the Set Port procedure, see Inside Macintosh: Imaging.
Each time you draw text in a window@ graphics port, you need to set the text-related
elds of the graphics port to the characteristics of the text that you want to draw, if they
differ from the current ones. A graphics port record contains three elds that determine
how text is drawnN the font, style, and size of glyphsN and one that speci es how it will
be placed in the bit image, the transfer mode. In addition to these elds, a graphics port
record contains two elds that let you specify character widths to de ne how text is to be
formatted on a line.

Specifying Text Characteristics
Each time you measure or draw text that begins a new style run and whose
characteristics differ from those of the current graphics port, rst you need to set the
graphics port text-related elds to match those of the text. Here is how the text-related
graphic port elds are initialized:
Field

Value

Explanation

txFont

0

System font

txFace

[]

Plain style of the current font

txSize

0

Size of the system font used to draw text

SspExtra

0

Standard width of the space character for the font

chExtra

0

Standard width of nonspace characters for the font

txMode

srcOr

Combines the destination with the source

Using QuickDraw Text

3-19

CHAPTER

3

QuickDraw Text

Do not modify any of these
change their values:

elds directly. Instead, always use the QuickDraw routines to

Text Face,

Text Font, TextMode,

Text Size, SpaceExtra, and

CharExtra. Using these routines ensures that your application will bene
future improvements to QuickDraw.

t from any

Listing 3-1 shows a simple sequence of QuickDraw calls. These routines set the current
port, set the graphics port text elds, then draw a text string. The calls render the text in
12-point Geneva font using the styles bold and italic, and widen the spaces between
words by 3 pixels to format the text. QuickDraw text-handling procedures that set these
elds are discussed later in this section.
Listing 3-1

Using QuickDraw to set the graphics port text-related fields

SetPort

(thePort)

;

TextFont

(geneva)

;

TextFace([bold,
TextSize

italic]);

(12);

SpaceExtra
(3) ;

If you must directly change the values of any of the graphics port elds, call the
QuickDraw PortChanged procedure to notify QuickDraw of the change after you
modify the

eld. For more information about

chapters in Inside Macintosh: Imaging.

Port Changed,

see the QuickDraw

Setting the Font
You use the Text Font procedure to set the font for the text. The value that you specify
for this eld is either the font family ID or a prede ned constant.
If you know the font name, you can get the font family ID by calling the Get FNum
procedure, passing it the font name. You can get a font@ name if it has a font family ID by
calling the Font Manager Get Font Name procedure. For more information about these
procedures and the prede ned font constants, see the chapter (Font ManagerOin this
book.
If you do not know either the font family ID or the name of the font, you can use the
Resource Manager@ Get IndResource function followed by the GetResInfo
procedure to determine the fonts that are available and what their names and IDs
are. See the chapter (Resource ManagerOin Inside Macintosh: More Macintosh Toolbox
for more information.
The values 0 and 1 have special signi cance. When a graphics port is created, the
txFont eld is initialized to 0, which speci es the system font. This is the font that the
system uses to draw text in system menus and system dialog boxes. You can use a font
that is de ned by the systemN to do so, it sets this eld to 1; 1 always speci es the
application font.

3-20

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Note

Do not use the font family ID 0 or the constant 'chicago' to specify the
Chicago font because the ID can vary on localized systems. To specify the
Chicago font, use the following calls.
Get FNum('Chicago',

TextFont

theNum) ;

(theNum) ;

The variable theNum is an integer.
Storing a font name in a document

Always store a font name, rather than its font family ID, in a document

to avoid problems that can arise because IDs are not uniqueN many font
families share the same font family IDN or because one font family may
have different IDs on different computer systems. @
You use Text Font to set the txFont

eld of the current graphics port for a new style

run that uses a font different from the current one, and in response to a user@ actions, for

example, when a user selects a new font from a menu.

Note
Whenever a user changes the keyboard script, you are responsible for
setting the txFont eld to the new font, so that the keyboard script and
the font script are synchronized. #

Modifying the Text Style
When you create a graphics port, the txFace eld value is initially an empty set ([]),
which speci es the plain style of the current font.
To change the text style, you call Text Face, using any combination of the following
constants to specify the text style: bold, italic, underline, outline, shadow,
condense, and extend. In Pascal, you specify the value or values within square
brackets. For example:
TextFace([bold]);
TextFace([bold,italic] );

{bold}
{bold and

italic}

You can also add another style to the current text style, or remove a style. For example:
TextFace (thePort*.txFace+[bold]);
TextFace(thePort*.txFace-[bold]);

{existing
{existing

style
style

plus bold}
minus bold}

To reset the style to plain, you specify an empty set. For example:
TextFace([]);

{plain

text}

If you want to restore the existing value after you draw the text in another style, save it
before you call Text Face. For a description of how QuickDraw renders text in each of
these styles, see (Font, Font Style, and Font SizeOon page 3-5.

Using QuickDraw Text

3-21

CHAPTER

3

QuickDraw Text

Changing the Font Size
When you create a graphics port, the value of the txSize eld is 0, which speci es the
size of the font to be used to draw system text, such as menus. The size of the system font
is usually 12 points. You use the Text Size procedure to set the txSize eld of the
current graphics port to the font@ point size. Text drawn on the QuickDraw coordinate
plane can range from 1 point to 32,767 points.

Changing the Width of Characters
When you create a graphics port, the spExtra and chExtra_ elds are set to 0, which
speci es the standard width for space and nonspace characters in the font. You change
the width of space characters and nonspace characters using the SpaceExt ra and
CharExtra procedures, respectively.
Widening or narrowing space and nonspace characters lets you meet special formatting
requirements that are not satis ed by simply justifying the text. If you want to change
only the width of the space characters in a line of text for onscreen typographical
formatting, you can set the spExtra_ eld value before you draw each style run,
narrowing spaces in some style runs and widening those in others. To change the width
of nonspace characters, either extending them or narrowing them, you set the chExtra
eld value before you draw a style run.
You use the SpaceExt ra procedure to set the spExtra_ eld of the current graphics port
to the number of pixels to be added to or subtracted from the standard width of the space
character in the style run. (A value speci ed inthe spExtra_ eld is ignored by script
systems that do not use space characters, so don@to set it for 2-byte script systems that
use only intercharacter spacing.) The text measuring and drawing routines apply the
spExtra_ eld pixel value to every space in the text string, regardless of whether the
space occurs at the beginning or the end of a style run or between words within a style
run. You can use the SpaceExt ra procedure, for both a color graphics port
(CGraf Port) and an original graphics port (Graf Port).
You use the CharExtra procedure to set the chExtra_ eld of the current graphics port
to the number of extra pixels to be added to or subtracted from the width of all nonspace
characters in a style run. Because only the color graphics port record has a chExtra_ eld,
use of CharExt ra is limited to color graphics ports. The measuring and drawing
routines apply the pixel value that you set in the chExtra_ eld to the right side of the
glyph of each nonspace character.
You can use SpaceExtra and CharExtra together, for example, to format text

consisting of multiple style runs with different fonts in order to create a smooth visual
effect by causing the fonts to measure the same or proportionally.
Note
Although printing on a LaserWriter preserves the line@ endpoints, it
alters the line layout in between. Any formatting internal to the line that
you set through SpaceExt ra and CharExtra is lost when you print.

3-22

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

If you do not want to use the justi cation routines to draw justi ed text, you can justify a
line of text using SpaceExt ra and CharExtra to widen each glyph (space and
nonspace characters) by the same amount of pixels for onscreen display. Here is how
you do this:
1. Determine the slop value to be applied to the text to justify it.
O Measure the width in pixels of each style run in the line of text using

Text Width.

4 Sum the values.
4 Subtract the total from the display line length.
2. Count the total number of characters (both space characters and nonspace characters)
that the text contains.
3. Divide the slop value by the number of characters minus 1. Round the slop value to a
whole number.
4. Call the SpaceExtra procedure, passing it the result of step 3.
5. Call the CharExtra procedure, passing it the result of step 3.
6. Call DrawText or DrawString to draw each style run on the line.

Use of CharExtra entails some restrictions. You cannot use intercharacter spacing for
1-byte complex script systems or 1-byte simple script systems that include zero-width
characters, such as diacritical marks, because of the way extra width is applied to a
glyph. For example, for 1-byte simple script systems with diacritical marks,
intercharacter space is added to all glyphs separating the diacritical mark from the glyph
of the character.

Using Fractional Glyph Widths
Fractional glyph widths are measurements of a glyph@ width that can include fractions of a
pixel. Using fractional glyph widths allows QuickDraw to place glyphs on the screen
in a manner that will closely match the eventual placement of glyphs on a page printed
by a LaserWriter. Fractional glyph widths make it possible for the LaserWriter printer to
print with better spacing. You can use the Font Manager@ Set FractEnable procedure
to turn the use of fractional glyph widths on or off.
Because screen glyphs are made up of whole pixels, QuickDraw cannot draw a fractional
glyph. To compensate, QuickDraw rounds off the fractional parts resulting in uneven
spacing between glyphs and words. Although the text is somewhat distorted on the
screen, it is correctly proportioned and shows no distortion when printed on a page using
a LaserWriter.
However, to avoid screen distortion, your application can disable the use of fractional
widths. A consequence of this it that placement of text on the printed page is less than
optimal. For more information about fractional glyph widths, see the chapter (Font
ManagerOin this book.

Using QuickDraw Text

3-23

CHAPTER

3

QuickDraw Text

Specifying the Transfer Mode
The value of the current graphics port transfer mode (txMode) eld determines the way
glyphs are placed in the bit image and how the text is to appear. It de nes the way text to
be drawn interacts with text and graphics already drawn. (When a glyph is drawn,
QuickDraw does a bit-by-bit comparison based on the mode and stores the resulting bits
into the bit image.) You set the text mode by calling the TextMode procedure.
By default, the transfer mode _ eld is set to srcOr, which speci

es that text to be drawn

should overlay the existing graphics. The srcOr transfer mode produces the best results
for drawing text because it writes only those bits that make up the actual glyph. In most
situations, when drawing text with the basic transfer modes, you should use only srcOr
or srcBic; all other modes can result in clipping of glyphs by adjacent glyphs. For
example, the Copy operation paints over what already exists on the destination,
replacing it entirely.

Basic Transfer Mode Operations
For each type of drawing mode, there are four basic kinds of operations: Copy, Or, Xor,
and Bic (bit clear). For Color QuickDraw, there are additional arithmetic drawing mode

operations designed speci cally for use with color. They are discussed later in this
section, and fully in Inside Macintosh: Imaging.

The transfer mode operation determines how the text is to be displayed: for each bit in
the item to be drawn, the corresponding bit in the destination bitmap is identi ed, the
speci ed Boolean operation is performed on the pair of bits, and the resulting bit is
stored into the destination bit image. When you work with color pixels, transfer modes
produce different results on indexed and direct devices.
In addition to drawing the entire glyph in all cases, the srcOr mode is recommended for
all applications because it uses the least memory. The srcOr mode only affects other
parts of existing glyphs if the glyphs overlap. In srcOr mode the color of the glyph is
determined by the foreground color.
The maximum stack space required for a text drawing operation can be considerable.
Text drawing uses a minimum amount of stack if the following conditions are true:
m

The transfer mode is srcOr.

m The foreground color is black.
m The destination of the text is contained within a rectangular portion of the region of
the graphics port that is actually visible on the screen.

3-24

m

The text is not scaled.

m

The text does not have to be italicized, outlined, or shadowed by QuickDraw.

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Otherwise, the amount of stack space required to draw all of the text at once depends
most on the size and the width of the text and the depth of the destination.
If QuickDraw can@get enough stack space to draw an entire text segment at once, it
draws the segment in pieces. This can produce unusual results in modes other than
srcOr or srcBic if some of the glyphs overlap because of kerning or italicizing. If the
mode is srcCopy, overlapping glyphs are clipped by the last drawn glyph. If the mode is
srcXor, pixels where the glyphs overlap are not drawn at all. If the mode is one of the
arithmetic modes, the arithmetic rules are followed, ignoring that the destination may
include part of the text being drawn.
The stack space required for a drawing operation in Color QuickDraw is roughly
estimated by the following calculation.
(text

width)

*

(text

height)

*

(font

depth)

/

(8

bits

per

byte)

+

3K

Pixel depth normally equals the screen depth. If the amount of stack space available is
small (less than 3.5K), QuickDraw instead uses a pixel depth of 1, which is slow, but uses
less stack space.
For the original QuickDraw, the required stack space is roughly estimated by the
following calculation.
(text

width)

*

(text

height)

/

(8

bits

per

byte)

+

2K

Arithmetic Transfer Mode Operations
Arithmetic transfer modes calculate pixel values by adding, subtracting, or
averaging the RGB components of the source and destination pixels. The arithmetic
modes change the destination pixels by performing arithmetic operations on the source
and destination pixels.
Each drawing routine converts the source and destination pixels to their RGB (red, green,
and blue) components, performs an operation on each pair of components to produce a
new RGB value for the destination, and then assigns the destination to a pixel value close
to the calculated RGB value. The arithmetic drawing modes are addOver, addPin,
subOver, subPin, adMax, adMin, and blend. To specify an arithmetic mode, you pass

the operation to be used to the TextMode procedure. For example, the following calls
save the current state of the text mode

transfer mode blend.
oldTextMode
TextMode

:=

(blend)

Using QuickDraw Text

eld, then set it to the

theport.*txMode;
;

3-25

CHAPTER

3

QuickDraw Text

The arithmetic modes were designed for use with color. They are most useful for 8-bit
color, but they work on 4-bit and 2-bit color also. When the destination bitmap is one bit
deep, the mode reverts to the basic transfer mode that best approximates the arithmetic
mode requested. For more information about arithmetic mode operations, see the
QuickDraw chapters in Inside Macintosh: Imaging.
Note
To help make color work well on different screen depths, Color

QuickDraw does some validity checking of the foreground and
background colors. If your application is drawing to a CGraf Port with
a depth equal to 1 or 2, and if the RGB values of the foreground and
background colors aren@the same, but both of them map to the same
pixel value, then the foreground color is inverted. This ensures that, for
instance, red text drawn on a green background doesn@map to black
on black. @

The grayishTextOr Transfer Mode
You can use the text drawing mode, grayishTextOr, to draw dimmed text on the

screen. It is especially useful for displaying disabled user interface items. If the

destination device is color and grayishTextOr is the transfer mode, QuickDraw draws

with a blend of the foreground and background colors. If the destination device is black

and white, the grayishTextOr mode dithers black and white. Dithering is a technique
that creates the effect of additional colors, if the destination device is color. If the

destination device is black-and-white, dithering creates the effect of levels of gray.

Note that grayishTextOr is not considered a standard transfer mode because currently

it is not stored in pictures, and printing with it is unde ned. (It does not
pass through the QuickDraw bottleneck procedure.) The following calls show how

to use grayishTextoOr. They save the current state of the text mode _ eld, then set it to
grayishTextoOr.

oldTextMode
TextMode

:=

theport.*txMode;

(grayishTextor)

;

Text Mask Mode
You can add the mask constant to another transfer mode to cause only the glyph portion
of the text to be applied in the current transfer mode to the destination. If the text font
contains more than one color or if the drawing mode is an arithmetic mode, the mask

mode causes only the portion of the glyphs not equal to the background to be drawn.
The arithmetic transfer modes apply the glyph@ background to the destination; this
can lead to undesirable results if you draw the text in pieces. QuickDraw draws the
leftmost part of a piece of text on top of a previous piece if the font kerns to the left.
Using maskMode in addition to these modes causes only the foreground part of the
glyph to be drawn.

3-26

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Because the rightmost glyph is clipped, to kern to the right in text mask mode, you
should use srcor, or add trailing spaces. The following call sets the transfer mode to
blend with mask mode.
TextMode

(blend

+

mask) ;

Transparent Transfer Mode
The transparent mode replaces the destination pixel with the source pixel when the
source pixel isn®equal to the background color. For a complete description of the
transparent mode, see the QuickDraw chapters in Inside Macintosh: Imaging.
The arithmetic transfer modes apply the glyph@ background to the destination; this can
produce undesirable results if you draw the text in pieces. QuickDraw draws the leftmost
part of a piece of text on top of a previous piece if the font kerns to the left. If you use the
mask mode (maskMode) in addition to these modes, QuickDraw draws only the

foreground part of the glyph. Because the rightmost glyph is clipped, to kern to the right
in text mask mode, you should use srcOr. For an explanation of kerning, see the chapter
(Font ManagerOin this book.
Transfer Modes

and Multibit Fonts

Multibit fonts can have a speci

c color. Some transfer modes may not produce the

desired results with a multibit font. However, the arithmetic mode and transparent mode
work equally well with single bit and multibit fonts.

Unlike single bit fonts, multibit fonts draw quickly in srcOr mode only if the foreground
is white. Single bit fonts draw quickly in srcOr mode only if the foreground is black.
Grayscale fonts produce a spectrum of colors, rather than just the foreground and
background colors.

Measuring and Drawing Single Segments of Text
This section describes how to draw a single glyph or a series of glyphs that
share the same font and character attributes. Because you usually measure text
before you draw it to determine if it ts on the display area, this section describes
the measuring and drawing routines in pairs. These pairs are CharWidth and
DrawChar to measure and draw the glyph of a single character, StringWidth
and

DrawSt ring

to measure and draw Pascal strings, and

to measure and draw text segments.

Text Width

and DrawText

You are responsible for tracking and specifying the memory location and the character
attributes of the text to be drawn. This is true whether you are working with a single
glyph, a Pascal string, or a text string. For a single glyph, you pass the character code to
the procedure; for a Pascal string, you pass the string.
Note

Before you call a QuickDraw measuring or drawing routine, you need to
set the graphics port text-related elds to those of the character.

Using QuickDraw Text

3-27

CHAPTER

3

QuickDraw Text

Individual Glyphs
You measure text a character at a time by calling the CharWidth function, and you draw
text a character at a time by calling the DrawChar procedure. These routines only work
with 1-byte simple script systems.
Although this section describes how to use these routines, you should understand their
limitations, and avoid using CharWidth and DrawChar for applications drawing
sequences of more than one character. Nevertheless, you may want to use DrawChar for
special purposes, such as including a glyph in a book@ index, to show a single glyph as it
exists apart from contextual transformations.
The CharWidth function takes into account all of the text characteristics de ned in the
current graphics port, so make sure these values refSect the attributes that you intend to
draw with. You can draw a sequence of individual glyphs by placing the pen at the
beginning of the leftmost glyph, and making a succession of calls to DrawChar.
Always use CharWidth to measure the width of a sequence of glyphs that you intend to
draw using DrawChar, instead of using StringWidth; StringWidth and
DrawString accumulate fractional portions, while CharWidth and DrawChar do not.

Making successive calls to CharWidth to measure a segment of text and calling
StringWidth to measure the same segment of text produce different results.

In general, you should measure and draw text in segments, rather than as individual
glyphs. In Roman fonts, if you measure fractional-width glyphs singly using

CharWidth, you can get incorrect results, because CharWidth doesn®accumulate
fractional-width positions. Also, it takes longer to measure the widths of several glyphs
one at a time than it does to measure them together using Text Width.
For contextual 1-byte fonts, CharWidth and DrawChar do not correctly measure or
draw ligatures, reversals, or other contextual forms. You cannot use CharWidth and

DrawChar for 2-byte fonts, because they take a 1-byte character code as a parameter.

Pascal Strings
You can call the StringWidth function to measure the screen pixel width of a Pascal
string to determine how many glyphs will ton the screen, and you can call the
DrawString procedure to draw a Pascal string with the text characteristics of the
current graphics port. The DrawSt ring procedure accumulates the fractional portion as
it draws each glyph and positions the next glyph correctly.
You cannot use the DrawString and StringWidth routines to draw or measure a

Pascal string that is justi ed or explicitly scaled. If you want to do this, you must separate
the string from its length byte, and call MeasuredJustified or StdTxMeas to measure
it, and then DrawJust ified to draw it, passing the text and the text length separately.
Note that a Pascal string is limited to 255 characters. The following code fragment shows
how to adjust for the length byte.
myTextPtr

:=

myTextLength

3-28

Ptr(Ord(@myString)
:=

Using QuickDraw Text

+

Ord(myString[0]) ;

1);

CHAPTER

3

QuickDraw Text

Text Segments
You can call the Text Width function to measure a segment of text to see ifit
single line; if it does, then you can the DrawText procedure to draw it.

tsona

You pass DrawText a pointer to the text buffer, the byte offset into the text buffer of the
rst character to be drawn, and the length of the text segment you want to draw.
QuickDraw draws the text at the current pen position with the text characteristics of the
current graphics port.

Measuring and Drawing Lines of Text
This section describes how to lay out and draw a line of text consisting of a single style
run or multiple style runs. A line of text all in the same font, script, and character

attributes constitutes a single style run. A new style run begins when any of these textual
characteristics change. QuickDraw relies on the construct of style runs to track these text
attribute changes throughout a line of text. Before you measure or draw a text segment
that constitutes a new style run, you need to set the text-related graphics port elds
for that style run.
This section also describes how to draw text lines that are right or left aligned, or
justi ed. Finally, it explains how to draw explicitly scaled text, whether the lines of text
are justi ed or not.
To draw a line of text, you rst need to lay it out. If the text does not contain mixed
directions, the text layout process consists of a single step: determining where to break
the line. If the text contains mixed directions, the order in which you display the style
runs may be different from their storage order, so you also need to determine the
drawing order.
Moreover, if you want to draw a line of justi ed text, the process entails additional
steps: you need to determine the total amount of extra pixels that remains to be
distributed throughout the line of text and how to distribute these extra pixels
throughout the style runs.
If you want to draw a line of text that is not justi ed, you can position the pen according
to its alignment. You align text by positioning the pen appropriately so that the rst
glyph of the text line is 8ush against the display line@ margin: at the left margin for
left-aligned text, or at the right margin for right-aligned text.
Your application loops through these steps for each style run and each line of text that it
measures and draws, and it needs to track the text in memory as it proceeds through each
loop. Each time you measure or draw a text segment, you need to pass the beginning
byte offset and its length to the QuickDraw routine. Before you call a QuickDraw
measuring or drawing routine, you need to set the graphics port text-related elds to
reBect the new style run@ values.

Using QuickDraw Text

3-29

CHAPTER

3

QuickDraw Text

These steps summarize the line layout and drawing process:
1 . Determine where to break the line.
2 . Determine the display order of the style runs (mixed-directional text).
3 . Eliminate trailing spaces (justi ed text).
4. Calculate the slop value (justi ed text).
5. Distribute the slop (justi ed text).
6. Position the pen.
7 . Draw

the text.

Each step covers the basics, plus any additional information you need to know to
perform the step for justi ed or scaled text. The following sections elaborate these steps.

Determining Where to Break the Line
For text that spans multiple lines, you are responsible for controlling where a text line
starts and ends. To determine where to break a line of text, rst you need to know
the screen pixel width of the display line. Then, taking into account all the text
characteristics, you need to assess how much of the text you can display on the line,
and the appropriate point to break the text.
You should always break a line on a word boundary. To allow for text in different
languages, use the QuickDraw and the Text Utilities routines that identify the
appropriate place to break a line in any script system.
The two routines you use for unscaled text are the StyledLineBreak and TextWidth
functions; StyledLineBreak is described in the chapter Text Utilities in this book. Each

time you call StyledLineBreak forastylerun,
text characteristics for that style run.

rst you need to set the graphics port

Saving the screen pixel width of each style run

To draw justi ed text, you need to determine the amount of extra pixels
to allocate to each style run in the text line. To determine this value, you
need to know the screen pixel width of each style run. You can avoid
having to measure the width of each style run twice in the text-layout
process by using the textWidth parameter of the StyledLineBreak
function to get and save the screen pixel width of each style run. The
StyledLineBreak function maintains the value of the textWidth

parameter, which you initially set to the length of the display line. When
you call StyledLineBreak for each style run in the script run, it
decrements this value by the width of the style run. You can calculate the
screen pixel width of a style run by subtracting the current value of
textWidth from the display line length each time through your
StyledLineBreak loop, and save the value to be used later.

3-30

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

If you do not want

to use

Sty ledLineBreak,

you can use the

Text Width function to

measure each style run, adding the returned values until the sum exceeds the display line
length. You can next use the Text Utilities FindWordBreaks procedure on the last style
run to identify the ending location of the appropriate word in the style run, then break
the text accordingly.
If a space character occurs at a line@ end, and more space characters follow it in memory,
StyledLineBreak breaks the line after the nal space character in memory. This
obviates the need for you to check for space characters in memory, when you lay out the
next line of text. However, if you do not use

Sty ledLineBreak,

you need to check for

space characters at the beginning of a line of text, and increment the memory pointer
beyond these space characters. You can use the CharacterType function to identify
space characters. For more information about CharacterType, see the chapter CScript
ManagerOin this book.

Listing 3-2 calculates line breaks using StyledLineBreak. The procedure sets the local
variables, the display line length, and a value to control the line-breaking loop. Then it
iterates through the text for each style run, setting the graphics port text elds for the
style run and calling StyledLineBreak to identify where to break the line.
Listing 3-2
PROCEDURE

Calling StyledLineBreak to identify where to break the text line

MyBreakTextIntoLines

(window:

WindowPtr) ;

VAR

thetextPtr:

Ptr;

thetextLength:

LongInt;

pixelWidth:

Fixed;

textOffset:

LONGINT;

StartOfLine:

Point;

index:

Integer;

tempRect:

Rect;

lineData:

myLineArray;

lineIndex:

Integer;

theBreakCode:

StyledLineBreakCode ;

theStartOffset:

Integer;

BEGIN

thetextPtr
index

:=

SetPort

:=

gText.textPtr;

0;

(window)

;

tempRect

:= window~.portRect;

InsetRect

(tempRect,

SetPt

(StartOfLine,

4,

4);

10,

4);

MoveTo(StartOfLine.h,

StartOfLine.v) ;

{Set up our local flags
lineIndex := 0;
{This is

Using QuickDraw Text

and
the

variables. }
index into the

line

data.}

3-31

CHAPTER

3

QuickDraw Text

index
WITH

:=

0;

{This

is

gText.runData[index]

the

index

into

the

style

data.}

DO

BEGIN

thetextPtr

:=

Ptr(ORD(gText.textPtr)

thetextLength

:=

+

runStart) ;

gText.textLength;

theStartOffset

:=

0;

{Start

through

END;

walking

the

textblock. }

run

in

REPEAT

{For

the

first

textOffset

:=

style

{smBreakOverFlow
{

line

a

with

means

space

{ control

the

theBreakCode

:=

that

the

remaining.

The

:=

WITH

DO

gText

textOffset

must

be

non-zero. }

whole

style

routine

run

uses

fits

that

on

the

}

condition

to

loop.}
smBreakOverflow;

{StyledLineBreak expects the
{ to be expressed as a fixed
pixelWidth

line,

-1;

width of
value. }

BSL((tempRect.right

-

the

display

tempRect.left),

area

}

16);

BEGIN

WHILE

(theBreakCode

BEGIN

WITH

=

smBreakOverflow)

gText.runData[index]

DO

DO

BEGIN

{set

the

port}

TextFont

(font) ;

TextFace

(face) ;

TextSize(size) ;

{call

StyledLineBreak

theBreakCode

:=

to

break

StyledLineBreak
thetextLength,
runEnd,

{now
lineData

[lineIndex]

{remember
{and

the

the

length

the

style

{ the

index

to

:=

lineIndex

Using QuickDraw Text

of

this

.styleIndex

{since
lineIndex

3-32

beginning
.textLength

[lineIndex]

END;

the

of

this
:=

length}

:=

index;

+

is

1;

returned}

run}

textOffset

information}

textOffset);

theStartOffset;

run

information

that

:=

line}

theStartOffset,

pixelWidth,

information

.textStartOffset

lineData[lineIndex]
lineData

remember

0,

the

(thetextPtr,

global,

-

theStartOffset;

just

remember

}

}

CHAPTER

3

QuickDraw Text

{ If

textoffset

==

the

end

of

the

run,

increment

the

{ rundata index and set theStartOffset to be the
{of the next run.}
[index] .runend)
THEN
( (textOffset = gText.runData

IF

}

beginning

}

BEGIN

index

:=

index

+

1;

theStartOffset

:=

gText.runData[index]

.runStart;

{If

<>

the

the

END
ELSE

textOffset

so

set

theStartOffset

{ a run,

:=

{If
IF

there

is

{ returned

by

textOffset

=

end

of

the

theStartOffset
theStartOffset

more

text,

reset

run,

routine

splits

}

appropriately}
+

(textOffset

the

offset

-

theStartOffset);

value

}

StyledLineBreak }
thetextLength

THEN

LEAVE

{if textOffset == the textLength
{ text, so jump out of the loop}

there

is

no

more}

ELSE

textOffset

{we
{

END;

{of

while

:=

haven't

textOffset

{ the
loop}

first

0;

found

the

line

break

must

be

zero

for

in

all

yet,
runs

}
after

}

a line}

END;

If the text is explicitly scaled, you cannot use StyledLineBreak to determine where to
break the line. This is because the StyledLineBreak function does not accept scaling
factors. To determine where to break a line of scaled text, you can directly call the
routines that StyledLineBreak uses. The section Using Scaled TextOon page 3-44
describes these steps.

Determining the Display Order for Style Runs
Now that you know where to break the line, you need to determine the display order of
the style runs that constitute the line when the text contains mixed directions; if your text
does not contain mixed directions, you can skip this step.
You draw style runs in their display order, which may be different from how the text is
stored if it contains mixed directions. (For more information about storage order and
display order, see the chapter Gntroduction to Text on the MacintoshOin this book.) To
determine the correct order, use Get Format Order; this procedure returns the order,
from left to right, in which to draw the style runs on a line.

To use Get FormatOrder, you must have organized your style runs sequentially in
storage order. You pass Get Format Order the numbers of the rst and last style runs on
the line, and the primary line direction of the text to be drawn. If you do not explicitly
de ne the primary line direction, you can base it on the value of the SysDirection
Using QuickDraw Text

3-33

CHAPTER

3

QuickDraw Text

global variable. (The SysDirection global variable is set to
right to left, and 0 if the system direction is left to right.)

1 if the system direction is

You pass Get Format Order a pointer to an application-de ned Boolean function that
calculates the correct direction for each style run and a pointer to an application-de ned
information block, containing font and script information, that the Boolean function uses

to determine the style run direction. The Get Format Order procedure calls your Boolean
function for each style run on the line.
Listing 3-3 shows an example Boolean function that calculates the line direction of a style
run. Here is the type declaration for the MyLineDrawingInfo

records, which are

created as the application calculates line breaks:
TYPE

MyLineDrawingInfo

=

RECORD
textPtr:

Ptr;

textLength:

Integer;

styleIndex:

Integer:

END;

MyLineArray

=

ARRAY[O

..MaxNumberofStyleRuns]

OF

MyLineDrawingInfo;
myLineDrawingInfoPtr

=

“MyLineDrawingInfo;

The styleIndex eld of each record of type MyLineDrawingInfo
points to an entry in
an array of style run records of type MyStyleRun. A style run record contains style
information including font, size, style, and scaling factors. The declaration for
MyStyleRun

follows:

MyStyleRun

=

RECORD
runStart:
runEnd:

Size:

Integer;
Integer;

Integer;

font:

Integer;

face:

Style;

numer:

Point;

denom:

Point;

END;
{This
{

{ data

3-34

sample

program

information.

uses

a

static

Typically,

a

program

structure. }

Using QuickDraw Text

array
would

to

store

use

a

style

dynamic

run
}

}

CHAPTER

3

QuickDraw Text

The MyDirectionProc function checks the font of the style run to determine if the font
belongs to a right-to-left script system. If it does, the function returns TRUE; otherwise it
returns FALSE. When Get FormatOrder calls MyDirectionProc, it passes an integer
identifying the style run and a pointer to an application-de ned parameter block. In
Listing 3-3, the pointer indicates the MyLineArray array. The MyDirectionProc
function uses the style run identi er and the size of aMyLineDrawingInfo
record to
nd the right MyLineDrawingInfo
record in the array. It uses the styleIndex eld of

the MyLineDrawingInfo
record to locate the right style run record in the array of
MyStyleRun records. The font

eld of the style run record contains a font family ID that

the function uses to determine the script code. The function calls the Script Manager with
the script code to determine the script direction
Listing 3-3
FUNCTION

An application-defined run direction function called by
MyDirectionProc(theFormat:

Get FormatOrder

Integer;

myDirectionParam:

Ptr)

:Boolean;

VAR

scriptCode:

Integer;

Pp:

myLineDrawingInfoPtr;

offset:

LongInt ;

BEGIN

offset
p

:=

:=

SIZEOF(MyLineDrawingInfo)

myLineDrawingInfoPtr

*

theFormat;

(ORD(myDirectionParam)

scriptCode

:=

IF

(GetScriptVariable(scriptCode,

Boolean
THEN

FontToScript

MyDirectionProc

(gText.runData

:=

+

offset);

[p*.styleIndex]

.font)

smScriptRight))

=

;

TRUE

TRUE

ELSE

MyDirectionProc

:=

FALSE;

END;

You reference the format order array to determine the display order when you draw the
text. To draw a line of text that is not justi ed, after you determine the display order of
the style runs, you can position the pen and draw the text. (To draw a line of text that is
not justi ed, see (Drawing the Line of TextOon page 3-42.) To draw text that is scaled,
you can skip ahead to Using Scaled TextOon page 3-44. If you are drawing a line of
justi ed text, you must complete some additional steps before positioning the pen and
actually drawing the text. These steps are described in the next three sections.

Using QuickDraw Text

3-35

CHAPTER

3

QuickDraw Text

Listing 3-4 shows an application-de ned procedure that declares a format order array; it
passes a pointer to that array when it calls Get FormatOrder for a line of text containing
style runs with mixed directions. Using the information that Get Format Order returns
in the format order array, the procedure iterates through the style runs in display order,
setting the graphics for each style run, then drawing the text.
Listing 3-4
PROCEDURE

Determining the style run display order and drawing the line

MyGetDisplayOrderAndDrawLine

(theLineData:
index:

myLineArray;

VAR

Integer) ;

VAR

FormatOrderArray:

I:

ARRAY[O..kMaximumNumberOfStyleRuns]

OF

Integer;

Integer;

BEGIN

Get FormatOrder

FOR

{we

know

I

:=

(FormatOrderPtr

the

(@FormatOrderArray),

0,

index,

Boolean(GetSysDirection),

@DirectionProc,

display

ready

order,

FormatOrderArray[0]

now
TO

we

are

to

FormatOrderArray

@theLineData) ;

draw}

[index]

DO

BEGIN

{Set

the

port. }

WITH

gText.runData[theLineData[i].styleIndex]

DO

BEGIN

TextFont

(font) ;

TextFace

(face) ;

TextSize(size) ;
END;

DrawText

(theTextPtr,

lineData[i]

theLineData[i]

.textStartOffset,

.textLength)

;

END;

index

{we

:=

0;

found

a

line,

so

bump

the

index

into

the

line

data}

END;

Eliminating Trailing Spaces (for Justified Text)
If you are justifying text, after you know the line break and display order for your text,
you must determine the total amount of extra pixels that remain to be distributed
throughout the line, and how to spread the extra pixels throughout the style runs. To get
the correct total number of extra pixels, rst you need to eliminate any trailing spaces
from the last style run in memory order.

3-36

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

The VisibleLength function returns the length in bytes of the style run minus any
trailing spaces; this is the byte length that you must use for the style run in any
calculations necessary to determine the line layout, and for drawing the text.
The VisibleLength function behaves differently for various script systems. For simple
script systems, such as Roman and Cyrillic, and 2-byte script systems, such as Japanese,
VisibleLength does not include in the byte count it returns trailing spaces that occur
at the display end of the text segment. For 2-byte script systems, VisibleLength does
not count them, whether they are 1-byte or 2-byte space characters.
Figure 3-5 shows that VisibleLength eliminates trailing spaces at the right end of
Roman text when the primary line direction is left to right. However, if you change the
primary line direction, VisibleLength assumes the left end as the display end of the
text, and does not eliminate the spaces on the right.
Figure 3-5

Byte
offsets

Calling VisibleLength for a Roman style run

Character
codes

Characters

O| $41
1|

$42

[A

2|

$43

|C

3)

$20 | Rs

4|

$20

| Rs

RS = Roman

space

|B

A

BC

0

1

2

_
_

ps

rs

3

4

Length =3

For 1-byte complex script systems, VisibleLength does not include in the byte count
that it returns spaces whose character direction is the same as the primary line direction.
The primary line direction is determined by the SysDirection global variable. By

default, the value of SysDirection is the direction of the system script. You can change
this value. Some word processors that allow users to change the primary line direction,
for example, to create a document entirely in English when the system script is Hebrew,
change the value of SysDirection. If you modify the SysDirection global value, be
sure to rst save the original value and restore it before your program terminates.
Figure 3-6 shows a Hebrew style run with trailing spaces at the left end, which
VisibleLength

eliminates. In this case, the primary line direction is right to left; if it

were left to right, VisibleLength would return 5.

Using QuickDraw Text

3-37

CHAPTER

3

QuickDraw Text

Figure 3-6

Calling VisibleLength for a Hebrew style run

Character

Byte

codes

offsets

Characters

_

__

0) SEO

|X

HS

HS

ol

13

4

3

1)

$E1

742

3|

$A0_ | Hs

se2

4|

$A0

}

1

2

N
1

0

Length = 3

| HS

HS = Hebrew space

For those 1-byte complex script systems that support bidirectional text, Roman spaces
take on a character direction based on the primary line direction. If the Roman spaces
then fall at the end of the text, VisibleLength does not include them in the returned

byte count. Figure 3-7 shows Roman spaces following Hebrew text in storage order. In
the rst part of the example, the Roman spaces take on the primary line direction of right
to left, and follow the Hebrew text in display order also. Because they fall at the end of
the display line, VisibleLength does not count them. The second part of the example
shows what happens when the primary line direction is changed to left to right: the
Roman spaces fall at the end of the line again and are not counted.
Figure 3-7

Byte
offsets

Calling VigibleLength for Hebrew text with Roman space characters

Character
codes

Characters

_
_

0| SEO

|X

RS

RS}

o|

|)

4

3

1|

$E1

3|

$20 | RAs

4|

$20

1
2

N
1

0

Length = 3

| Rs

y

ge2

[42

1
2

12

N

RS

RS

1

0

3

4

Lo)
Length = 3
RS = Roman space

3-38

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Calculating the Slop Value (for Justified Text)
To draw justi ed text, after you eliminate trailing spaces from the line@ last style run in
memory order, you need to determine the amount of remaining extra space to be
distributed throughout the line. This is called the slop value; it is measured in pixels, and
is the difference between the width of the text and the width of the display line. After you
add the widths of all the style runs on the line to get the total width of the text, you can
use the following statement to determine the slop value. Be sure to use the value returned
by VisibleLength for the last style run in memory order when you add the style run
widths.
TotalSlop

:=

DisplayLineLength

—

SumofStyleRunWidths

If you saved the screen pixel width of each style run when you called
StyledLineBreak, then all you need to do is sum the total of the style run widths and
subtract that total from the display line length to get the total slop value.
If you did not use StyledLineBreak or you did not save the screen pixel width of each
style run when you called StyledLineBreak, rst measure the width of each style run,
using Text Width, then add the widths to get the total. (Remember that each time you
measure a style run, rst you need to set the text-related graphics port elds for
that style run.)
The Text Width function returns the width in pixels of a style run. You pass TextWidth
the number of bytes of the text to be measured. For script systems containing 2-byte
characters, be certain that you pass the correct number of bytes; 2-byte script systems can
contain a mix of one-byte and two-byte characters.
For scaled text, you cannot use the Text Width function to get the screen pixel width of a
style run. Instead, you can call the StdTxMeas function, which accepts and returns

scaling parameters. Whenever you call StdTxMeas directly, rst you must check the
graphics port grafProc eld to determine if the bottleneck routines have been
customized, and if so, use the customized version. See CLow-Level QuickDraw Text

RoutinesOon page 3-98 for more information.

Using a negative slop value
You can pass the justi cation routines a positive or negative slop value.
Word processing programs can use a negative slop value to justify a line
of text more smoothly by condensing it, when it only slightly exceeds the
display line length.

Allocating the Slop to Each Style Run (for Justified Text)
Once you have assessed the total amount of slop to be distributed throughout the line of
text, you need to determine the portion to apply to each style run. When you draw a
style run that is part of a line of justi ed text, you pass this number as the value of the
slop parameter.

Using QuickDraw Text

3-39

CHAPTER

3

QuickDraw Text

To determine the actual number of pixels for each style run, rst you determine the
percentage of slop to attribute to the style run, and then apply that percentage to the total
slop to get the number of pixels. To get the percentage of slop for a style run, you
compute what percentage each portion is of the sum of all portions.
The following steps summarize this process:
1. Call PortionLine for each style run on the line. The PortionLine function
returns a Qnagic numberOwhich is the correct proportion of extra space to apply to
a style run.
2. Add the returned values together.
3. For each style run, divide the value returned by PortionLine for that style run by
the sum of the values returned for all of the style runs on the line.
4. For each style run, multiply the result of step 3 by the total slop value for the line.
For example, suppose that there are three style runs on a line: style run A, style run B,
and style run C. The total slop = 11; the line needs to be widened by 11 pixels to be
justi ed. If you call Port ionLine for each of the style runs, it produces the
following results:
Style

Value returned by

A

5.4

B

7.3

C

8.2

run

PortionLine

Summing the three values together produces a total of 20.9. Now you need to
convert the values into percentages by dividing each by the total. This produces the
following results:
Style

Proportion

A

5.4/20.9

25.84%

B

7.3/20.9

34.93%

C

8.2/20.9

39.23%

run

Percentage

of total

The nal step is to multiply the total slop valueN 11 pixelsN by each percentage and
round off to compute the actual number of pixels (slop) allocated to each style run. (To
correct for the roundoff error, add the remainder to the pixels for the nal style run.) This
produces these results:
Style

Amount of slop

A

3

B

4

C

4

run

3-40

(in pixels)

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Listing 3-5 provides a code fragment that illustrates how you can use the PortionLine
function to do this. The application-de ned MyCalcJustAmount
routine expects an
array of the following type of records.
Type

RunRecord

=

Record

tPtr:
tLength:
tFace:
tFont :
tSize:

Ptr;
LongInt ;
style;
Integer;
Integer;

{ptr to the text}
{length of run}
{txFace of run}
{font family ID}
{pt size}

tPlaceOnLine:

JustStyleCode;

tnumer,tdenom:
tJustAmount :

Point;
Fixed;

{scaling factors}
{this value }
{ calculated here}

END;

RunArray

=

ARRAY[1..MaxRuns]

OF

RunRecord;

The MyCalcJustAmount routine also takes as a parameter a count of the total number
of records that the array contains. Finally, the extra screen pixel width to be distributed is
passed in as the TotalPixelSlop parameter. The routine calculates the amount of slop
to be allocated to each run, and assigns that value tothe

Listing 3-5

Distributing slop value among

PROCEDURE

MyCalcJustAmount

eld tUustAmount.

style runs

(rArray:

RunArray;

TotalPixelSlop:

NRuns:

Integer;

Integer) ;

VAR
I:

Integer;

TotalSlopProportion:

Fixed;

PixelSlopRemainder:

Fixed;

BEGIN

{Find

the

proportion

for

each

run,

temporarily

{ it in the tJustAmount field, and sum the
{ returned values in TotalSlopProportion. }
TotalSlopProportion

:=

FOR

DO

I

:=

WITH

1

TO

NRuns

rArray[I]
{Set

the

{ to

this

DO

storing}

}

0;

BEGIN

graphics

style

TextFace

(tFace) ;

TextFont

(tFont) ;

port’s

fields

for

each

style

run}

run}

TextSize(tSize) ;

Using QuickDraw Text

3-41

CHAPTER

3

QuickDraw Text

tJustAmount
PortionLine

:=

(tPtr,tLength,tstyleRunPosition,tnumer,tdenom) ;

TotalSlopProportion

:=

TotalSlopProportion

+

tJustAmount ;

END;

{

Normalize

{

( runportion

the

{ UnRounded
{

slop
/

to

Pixels:

(runportion

/

NRuns
FOR

allocated

>
I

1

:=

WITH

and

to

each

then

convert

run

}
that

value

to

this

value.}

}

}

totalportion)

PixelSlopRemainder
IF

be

totalportion),

:=

*

TotalPixelSlop

).}

Fixed(TotalPixelSlop) ;

THEN
1

TO

NRuns-1

DO

rArray[I] DO BEGIN
{Use the FixRound routine

tJustAmount

:=

FixMul

to

round

(FixDiv(tJustAmount,

TotalSlopProportion)
, TotalPixelSlop) ;
PixelSlopRemainder

:=

PixelSlopRemainder

-

tJustAmount ;
END;

rArray

[NRuns]

.tJustAmount

:=

PixelSlopRemainder;

END;

Drawing the Line of Text
Once you have laid out a line of text, drawing it is fairly simple. Your application@
text-drawing routine needs to loop through the text, following these steps:
1. To position the pen correctly at the beginning of a new line, set the pnLoc graphics
port eld to the local coordinates representing the point where you want to begin
drawing the text. You use the QuickDraw MoveTo or Move procedure to reposition the
pen. (For more information about Move or MoveTo, see the QuickDraw chapters in

Inside Macintosh: Imaging.) Within a line of text, after you draw a text segment,
QuickDraw increments the pen location for you and positions the pen appropriately
for the next text segment.
2. Before you draw each text run, set the text-related elds of the current graphics port to
the text characteristics for that style run, if the text segment begins a new style run.
3. Draw the text segment.
O If your text is not justi ed, use DrawText or StdText to draw it. The StdText
procedure also allows you to draw scaled text that is not justi ed. If you use
StdText, rst you must determine whether the standard routine has been

customized. If so, you must use the customized version. For more information, see

CLow-Level QuickDraw Text RoutinesOon page 3-98.

3-42

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Listing 3-4 on page 3-36 shows how to draw the text using DrawText after
determining the display order.
O If your text is justi ed, use the DrawJust ified procedure to draw it. This
procedure takes a parameter, styleRunPosition, that identi

es the location of

the style run in the line of text. You must specify the same value for this parameter
that you used for it when you called the PortionLine function for this style run.
The DrawJustified and PortionLine routines also take numer and denom
parameters for scaling factors. For unscaled text, specify values of 1, 1 for both of
these parameters.
4. After you draw each text segment, increment the pointer in memory to the beginning
of the next text segment to be drawn.
To position the pen horizontally, remember that QuickDraw always draws text from left
to right:
m For left-aligned text, position the pen at the left margin of the display line.
m For right-aligned text, indent the pen from the left margin by the difference between
the display line length and the total width of all the style runs. If you have set a
CharExt ra value, after you sum the total width of all the style runs, subtract the

value that you passed to CharExt ra from the total so that the rightmost character will
be fSush against the right margin.
m For justi ed text, set the pen at the left margin.
To determine the vertical coordinate of the pen position when you draw lines of text
rendered in varying fonts and styles, you need to assess the required line height for each
new style. You base this on the style run that requires the greatest number of vertical
pixels. You can use the Get Font
Info procedure, which lls a record with information
describing the current font@ ascent, descent, and the width measurements of the largest

glyph in the font, and leading. You can determine the line height by adding the values of
these elds. For outline fonts, you can use the Out lineMetrics function to get the font
measurements. For more information about Out lineMet rics, see the chapter (Font
ManagerOin this book. Listing 3-6 shows how to call Get Font Info, and use the

information it returns in the font information record to determine the line height.
Listing 3-6
FUNCTION

Calling

Get Font Info

MyGetMaximumLineHeight

(VAR

to determine the line height
mylineData:

myLineArray;

lastStyleIndex:

Integer):

Integer;

VAR

info:

I:

fontInfo;

Integer;

ignore:

Integer;

maxHeight:

Integer;

BEGIN

maxHeight
FOR

1

:=

WITH

:=
0

TO

0;
lastStyleIndex

DO

gText.rundata[mylineDatal[li].styleIndex]

Using QuickDraw Text

DO

3-43

CHAPTER

3

QuickDraw Text

BEGIN

{set

the

grafport

TextFont

(font) ;

TextFace

(face) ;

up}

TextSize(size) ;

{Get

the

vertical

metrics}

GetFontInfo(info) ;

{If

this

style

{ remember
WITH

the

info

IF

run

is

taller

than

any

others

measured,

}

height. }

DO

(ascent

+

maxHeight

leading
:=

ascent

>

maxHeight)
+

THEN

leading;

END;

MyGetMaximumLineHeight

:=

maxHeight;

Using Scaled Text
This section describes how to determine where to break a line of scaled text. Then it

describes how to draw scaled text, whether aligned or justi ed.
You cannot call StyledLineBreak for scaled text. To determine where to break a

line of scaled text, you can directly call the routines that StyledLineBreak uses. The
StyledLinedBreak function uses the Pixel ToChar function to locate the byte offset
that corresponds to the pixel location marking the end of the display line.

The primary use of Pixe1lToChar is to locate a caret position associated with a
mouse-down event. For this purpose, the Pixe1ToChar function reorders the text
when the text belongs to a right-to-left script system; this ensures that Pixel ToChar
returns the correct byte offset associated with the pixel location of a mouse-down event.
If right-to-left text is reordered when you use PixelToChar to determine where to break
a line, it returns the wrong byte offset. For right-to-left text, the end of a line in memory
order can occur either at the left end of a display line or in the middle of one. To get the
correct result, StyledLineBreak turns off reordering before it calls

application must also do this.

Pixel ToChar. Your

You can de nea routine that turns off reordering if the font@ script system is right to left,
and call your routine just before you call PixelToChar. Remember to restore reordering
after you have determined where to break the line.
Listing 3-7 shows an application-de ned routine that turns off reordering of text ina
right-to-left script system. It tests to determine whether the reordering bit is on or off so
that the application can restore it to its current state, then it clears the reordering bit
(smsfReverse), and sets the script fag with the Set Script Variable function. See the
chapter Script ManagerOin this book for more information.

3-44

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Listing 3-7

Turning off reordering of right-to-left text before calling
for line-breaking

FUNCTION

MySetReordering(font:

integer):

Pixel ToChar

Boolean

VAR
flags:
err:

LongInt;
OSErr;

BEGIN

flags

:=

GetScriptVariable(smCurrentScript,

MySetReordering
BCLR(flags,
err

:=

:=

BTST(flags,

smScriptFlags) ;

smsfReverse) ;

smsfReverse) ;

SetScriptVariable(smCurrentScript,

smScriptFlags,

flags);
END ;

Here are the steps you take to determine where to break a line of scaled text:
1. Call PixelToChar to determine the byte offset that corresponds to the pixel location
where you want to break the line. You pass the pixel location of the end of the display
line to

Pixel ToChar

as the value of the pixe1Width parameter. The

Pixel ToChar

function returns the byte offset corresponding to the pixel location of the end of the
display line, if the corresponding byte offset falls with the style run that you call
PixelToChar for.
If the byte offset corresponding to this pixel location does not fall within the style run,
on return the widthRemaining parameter contains the number of pixels from the

right edge of the text string for which you called Pixe1ToChar to the end of the
display line. You can loop through your text, calling Pixel ToChar for each style run
until you encounter the byte offset that corresponds to the pixel location of the end of
the display line.
2. Call the Text Utilities FindWordBreaks procedure with an nbreaks parameter of 1
to determine the boundaries of the word containing the byte offset that corresponds to
the pixel location of the end of the display line. If the byte offset that PixelToChar
returns is the beginning boundary or interior to the word, you should break the text
before this word, or after the preceding word.
3. If the byte offset that falls at the end of the display line is a space character, you should
check to determine if there are succeeding space characters in memory;
Sty ledLineBreak does this. You can use the Script Manager@ CharType function

for this purpose. If there are additional space characters, increment the text pointer
beyond them in memory to determine the starting offset for the next line of text.

Using QuickDraw Text

3-45

CHAPTER

3

QuickDraw Text

The steps that you follow to draw scaled text are the same as those for unscaled text,
described under (Drawing the Line of TextOon page 3-42. However, you perform some
steps differently for scaled text. The steps are summarized here, and the differences are
elaborated.
1. Set the pnLoc graphics port

eld to the local coordinates representing the point to
begin drawing the text. You use StdTxMeas to get the font metrics for scaled text in
order to determine the line height, instead of using

Get Font Info, which doesn@

support scaling. Using the information that StdTxMeas returns, you can scale the
vertical metrics. Listing 3-8 shows one way to do this.
. Before you draw each style run, set the text-related elds of the current graphics port
to the text characteristics for that style run. This step is the same as for drawing
unscaled text.
. Use DrawJust ified or StdText to draw the scaled text a style run at a time.
To draw scaled text that is not justi ed, you call StdText or you can call
DrawJustified and pass in onlyStyleRun for the styleRunPosition
parameter.

Listing 3-8 shows how to measure scaled text using St dTxMeas, and use the information
returned in the font information (font Info) record to determine the line height. The

gText global variable is initialized before the routine is called.

The application of which this routine is a part stores style runs in a text block, which is
de ned by the Text Block data type.
TextBlock

=

textPtr:

RECORD
Ptr;

textLength:
runData:

Integer;

StyleRunArray;

END;

Listing 3-8

FUNCTION

Using StdTxMeas to get the font metrics for determining the line height

of scaled text

MyGetMaximumLineHeight
(VAR
lastStyleIndex:

VAR

info:
i:

fontInfo;

Integer;

ignore:

Integer;

MaxHeight
: Integer;

3-46

localNumer,

localDenom:

size,

font:

Integer;

face:

Style;

Using QuickDraw Text

Point;

lineData:
Integer):

LineArray;
Integer;

CHAPTER

3

QuickDraw Text

BEGIN

MaxHeight
FOR

1

:=

WITH

{Set

:=
0

0;

TO

lastStyleIndex

DO

gText.runData[lineData[i]

up

the

graphics

TextFont

(font) ;

TextFace

(face)

.styleIndex]

DO

BEGIN

port}

;

TextSize(size) ;

{measure

the

text}

localNumer
localDenom

ignore

:=

:=

numer;

:=

denom;

StdTxMeas(lineData[i]

lineData[i].textPtr,

{scale

.textlength,

localNumer,

localDenom,

the vertical metrics based on
{ returned values of numer and

info.ascent

:=

FixRound(FixMul

FixRatio(localNumer.v,
info.leading
WITH

info

IF

:=

info);

the StdTxMeas
denom}

(BSL(info.ascent,

}
16),

localDenom.v)));

FixRound(FixMul

(BSL(info.leading,

FixRatio(localNumer.v,

localDenom.v)));

16),

DO

(ascent
maxHeight

+

leading
:=

> maxHeight)

ascent

+

THEN

leading;

END ;

Drawing Carets and Highlighting
This section discusses how to determine a caret position to be used to mark an insertion
point or endpoint for highlighting a range of text. This section describes how to
m determine the byte offset of a character whose glyph is closest to an onscreen
pixel location where a mouse-down event occurred
m

determine a caret position from a byte offset, and draw a caret to mark an
insertion point

m locate the endpoints for a selection range in order to highlight it, using the byte
offsets at characters that begin and end the segment of text to be highlighted
For a discussion of the conventions underlying the relationship of a character at a byte
offset to a caret position for unidirectional text and text at a direction boundary, see the
treatment of caret handling and highlighting in the chapter Gntroduction to Text on the
MacintoshOin this book.
Generally, an application draws and blinks the caret in an active document window
from its idle-processing procedure in response to a null event. If your application uses
TextEdit, you can call the TEI dle procedure to do this. If your application does not
use TextEdit, you are responsible for drawing and blinking the caret.

Using QuickDraw Text

3-47

CHAPTER

3

QuickDraw Text

You should check the keyboard script and change the onscreen pixel location where you
draw the caret, if necessary, to synchronize the caret with the keyboard script. The caret
marks the insertion point where the next character is to be entered, and when the user

changes the keyboard script, the caret location can change. (For more information, see
(Synchronizing the Caret With the Keyboard ScriptOon page 3-59.)

You call PixelToChar from within a loop that iterates through the style runs on a line of
text until you locate the byte offset of the character associated with the input pixel
location. Once you have the byte offset, you call CharToPixel to get the pixel location
of the caret position. If you already have the byte offset, you do not need to call
Pixel ToChar. The CharToPixel function returns the length in pixels from the left
edge of the text segment to the caret position corresponding to that character. (The text
segment that you pass to CharToPixel can be a complete style run or the portion of a
style run that ts on the line.)
Once you have the pixel location of the caret position within the context of the text
segment, you must convert it to a pixel location relative to the entire display line@ left
margin. To get the correct display line pixel location, you lay out the line of text,
measuring the screen pixel width of each style run from left to right up to the text
segment that contains the caret position, then add the screen pixel width of the caret
position to the sum of all the preceding style runs. Once you have the pixel location
relative to the display line@ left margin, you can draw the caret. Figure 3-8 shows
Hebrew text between two runs of English text on a line. CharToPixel and
Pixel ToChar recognize the pixel location in the Hebrew text relative to the left edge of
the Hebrew style run, although the left margin of the display line begins with the English
text.

Figure 3-8

What pixel position means for CharToPixel and PixelToChar

Pixel position
a

ABC? 93/9 IIDEF
.<a— Text segment —-».
(<= 1 style run)

3-48

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Converting an Onscreen Pixel Location to a Byte Offset
You need to nd the byte offset and the text direction of the character that corresponds to
a glyph onscreen in order to display the caret correctly. You need this information to
mark an insertion point with a caret, select words, determine the endpoints for

highlighting a range of text, and determine where to break a line of text. You can use the
PixelToChar function to get this information.
The PixelToChar function returns a byte offset and a Boolean value. The Boolean fag
tells you whether the input pixel location is on the leading edge or the trailing edge of the
glyph.
m When the input pixel location is on the leading edge of the glyph, PixelToChar
returns the byte offset of that glyph@ character and a leadingEdge fag of TRUE. (If
the glyph represents multiple characters, it returns the byte offset of the rst of these
characters in memory.)
mg When the input pixel location is on the trailing edge of the glyph,

Pixel ToChar

returns the byte offset of the rst character in memory following the character or
characters represented by the glyph, and a leadingEdge fag of FALSE.

mw When the input pixel location is before the leading edge of the rst glyph in the
displayed text segment, PixelToChar returns the byte offset of the rst character in
the text segment and a leadingEdge fag of FALSE.
mw When the input pixel location is after the trailing edge of the last glyph in the
displayed text segment, Pixel ToChar returns the next byte offset in memory, the one
after the last character in the text segment, and a leadingEdge fag of TRUE.

If the primary line direction is left to right, before means to the left of all the glyphs for the
characters in the text segment, and after means to the right of all these glyphs. If the
primary line direction is right to left, before and after hold the opposite meanings.

Finding a Caret Position and Drawing a Caret
Once you have a byte offset, you need to convert it to a caret position. The PixelToChar
and CharToPixel functions work together to help you determine a caret position. You
use the byte offset that Pixel ToChar returns as input to CharToPixel. The
CharToPixel function requires a direction parameter to determine whether to place
the caret for text with a left-to-right or right-to-left direction. You base the value of the
direction parameter on the leadingEdge fag that PixelToChar returns.

Using QuickDraw Text

3-49

CHAPTER

3

QuickDraw Text

When a mouse-down event in text occurs, if Pixel ToChar

returns a leadingEdge fag

of TRUE, you pass CharToPixel the text direction of the character whose byte offset
PixelToChar returns. Figure 3-9 illustrates a simple case. The user clicks on the leading
edge of the glyph of character D; Pixe1ToChar returns byte offset 3 and a
leadingEdge fsag of TRUE. You then call CharToPixel, passing it byte offset 3 and a
direction parameter of leftCaret, based on the text direction of the character D.

The CharToPixel function returns the pixel location equivalent to the caret position;
now you can draw the caret as shown, on the leading edge of D.
Figure 3-9

Byte
offsets

Caret position for a leading-edge mouse-down

Character
codes

Primary line direction
Characters

JEac
$43 |c

O|

2/
3|

$41

$

$44

event

-

Mouse-down event:

ABC, ann

|A

—

|D——

Result from PixelToChar:

Offset
= 3 (D)

Leading edge flag = TRUE

Input to CharToPixel:
Offset = 3 (D)
Direction = left Caret

(direction of D)

Caret as drawn:

A BCID

If

Pixel ToChar

returns a leadingEdge fag of FALSE, it returns the next byte offset in

memory, not the one on whose trailing edge the mouse-down event occurred. You still
base the value of the direction parameter on the character of the glyph at whose
trailing edge the mouse-down event occurred, but this character is the one in memory
that is before the byte offset that Pixel ToChar returned.

3-50

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Figure 3-10 illustrates this for the same simple case. The user clicks on the trailing edge of
the glyph of character C; PixelToChar returns byte offset 3, the byte offset of the next
character (D) in memory, and a leadingEdge fsag of FALSE. You then call
CharToPixel, passing it byte offset 3 and a direction parameter of left Caret, based
on the text direction of the character C. The CharToPixel function returns the pixel
location equivalent to the caret position; now the application can draw the caret as
shown, on the trailing edge of C, which is the same position as the leading edge of D.
Caret position for a trailing-edge mouse-down event

Primary line direction

irae

0]

$41

2|

$4

$43

$44

|A

| C

|D——

Mouse-down

|

Figure 3-10

event:

ABCD
ne |

~~

Result from PixelToChar:

need

Offset = 3 (D)

Leading edge flag = FALSE

Input to CharToPixel:
Offset = 3 (D)
Direction = left Caret

(direction of C)

Caret as drawn:

A BCID

When a character falls on a direction boundary, the case is more complicated. In display
order, a direction boundary can occur on the trailing edges of two glyphs, the leading
edges of two glyphs, or at the beginning or end of a text segment. The same rules apply
for calling PixelToChar and CharToPixel, but the results can be different.

Using QuickDraw Text

3-51

CHAPTER

3

QuickDraw Text

Figure 3-11 shows what happens when the user clicks on the leading edge of the
glyph x, whose character falls on a direction boundary; Pixel ToChar returns a
leadingEdge fsag of TRUE and a byte offset of 3. You pass this byte offset and a
direction of right Caret, the text direction for Hebrew, to CharToPixel. The

CharToPixel function returns the caret position on the leading edge of N, and you
draw the caret there.

st

Caret position for a leading-edge mouse-down

Primary line direction

$43

3|

SEO

|N ——

5|

$E2

|)

$E1

ABCIVIN

Mouse-down

2|
4|

event at a direction boundary

|1

y

Figure 3-11

event:

;
Result from PixelToChar:

Offset = 3 (N)

Leading edge flag = TRUE

Input to CharToPixel:
Offset = 3 (N)
Direction = rightCaret

(direction of &)

Caret as drawn:

ABC)AIAN

Figure 3-12 shows what happens when the user clicks on the trailing edge of the glyph C
(byte offset 2). The Pixel ToChar function returns byte offset 3 (the Hebrew character N)
and a leadingEdge Sag of FALSE. You pass this byte offset and a direction
parameter of left Caret, the text direction for English, to CharToPixel. In this case,

CharToPixel returns a caret position on the trailing edge of C, which is where you
draw the caret.

3-52

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Caret position for a trailing-edge mouse-down

event at a direction boundary

Primary line direction

=
2|

$4
$43

Cc

3|

SEO

[N=

5|

$E2

|)

4|

$E1

ABQ

Mouse-down

[2

event:

Result from PixelToChar:

y

Figure 3-12

IAN

Offset = 3 (N)

Leading edge flag = FALSE

Input to CharToPixel:
Offset = 3 (N)
Direction = Left Caret

(direction of C)

Caret as drawn:

ABCIA1I®N

Using a dual caret
If your application is con gured to use a dual caret, you must call
CharToPixel twice to draw the caret. For example, in Figure 3-12, you
would call it once with a left Caret direction and again with a
rightCaret direction, both times for byte offset 3. You always draw the
high (primary) caret at the caret position obtained when the direction
parameter equals the primary line direction. For more information, see
the discussion of caret positions at direction boundaries in the chapter
Ontroduction to Text on the MacintoshOin this book.
Figure 3-11 and Figure 3-12 show how one offset can yield two caret positions.
Figure 3-13, when compared with Figure 3-12, shows how two offsets can yield one
caret position. In Figure 3-13, the user clicks on the trailing edge of the glyph 4. The
PixelToChar function returns byte offset 6 and a leadingEdge fsag of FALSE.
(Although there is no character code associated with byte offset 6, it is the memory
position of the next character to be entered.) You then call CharToPixel, passing it byte
offset 6 and a direction parameter of right Caret, the text direction for Hebrew. The
CharToPixel function returns the pixel location on the trailing edge of the glyph).

Using QuickDraw Text

3-53

CHAPTER

3

QuickDraw Text

Caret position for a trailing-edge mouse-down event at a direction boundary

Primary line direction
Mouse-down

0}

$41

JA

$43

|C

3|

$EO

|X

5|
6

$E2

|)

| se 2

2}
4|

$

$E1

Ja

<—

y

Figure 3-13

event:

ABCy

Result from PixelToChar:

_—<
Sls

a

1h

Offset = 6 (after 3)

Leading edge flag = FALSE

Input to CharToPixel:
Offset = 6 (after 3)
Direction = rightCaret

(direction of 3)

Caret as drawn:

ABCIA1I®N

There is one additional complication that occurs at the ends of a text segment that is the
only style run on a line, and at the outer end of a text segment that is the rightmost
or leftmost style run on a line. Again, the rules for calling Pixel ToChar and
CharToPixel are the same. Here is how they are interpreted for these cases. If a user
clicks the mouse before the text segment that is at the beginning of a line, Pixel ToChar
returns a leading edge value of FALSE and a byte offset of 0. (The rst character of a text
segment that you pass to PixelToChar is always at byte offset 0.)
If a user clicks the mouse after the text segment that is at the end of a line, Pixe1lToChar
returns a leading edge value of TRUE and the next byte offset in memory, following the
last character in the text segment.
Figure 3-14 shows what happens when a mouse-down event occurs beyond the last
glyph of the text segment. The Pixe1lToChar function returns byte offset 3 and a
leadingEdge fsag of TRUE. You pass this byte offset and a direction parameter of
leftCaret to CharToPixel. In this case, the direction parameter is based on the

value of SysDirection because there isn@a character in memory associated with byte
offset 3. The CharToPixel function returns a caret position on the trailing edge of C,
which also marks the insertion point of the next character to be entered. This is where
you draw the caret.

3-54

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

Figure 3-14

Caret position for

a mouse-down event beyond the last glyph of the text segment

Primary line direction

=f

0|

$41

JA

2

$43

C

ABCs

Mouse-down

event:

Result from PixelToChar:
Offset = 3 (after C)
Leading edge flag = TRUE

3

Input to CharToPixel:
Offset = 3 (after C)

Direction = leftCaret

——
hk.

(based on SysDirection)

Caret as drawn:

ABC

Listing 3-9 is a sample routine that converts mouse clicks to caret positions for drawing
the caret or for highlighting a selection range. It determines a text offset (charLoc) from
a mouse-down position and turns it into caret positions or ends of highlighting rectangles
(leftSide, rightSide). It tracks the mouse and dynamically draws highlighting as the
cursor is moved across the text. The routine calls HiliteText to determine selection
ranges. It calls CharacterType to determine the primary and secondary caret positions
for mixed-directional text. It draws the caret or highlighting rectangles by calling the
application routine MyAddSelectionArea.
Listing 3-9

Drawing the caret and highlighting a selection range

PROCEDURE

MyDoTextClick(w:

WindowPtr;

cmdKeyIsDown,

where:

POINT;

shiftKeyIsDown,

optionKeyIsDown:

BOOLEAN) ;

VAR

txLineH:

TextLineHandle;

horizontalPosition:

FIXED;

leadingEdge:

BOOLEAN ;

widthRemaining:

FIXED;

charLoc:

INTEGER;

selectionoOffsets:

OffsetTable;

Cc:

INTEGER;

leftSide,

Using QuickDraw Text

rightSide:

INTEGER;

3-55

CHAPTER

3

QuickDraw Text

prevMouseLoc:

POINT;

direction:

INTEGER;

BEGIN

txLineH
IF

:=

txLineH

TextLineHandle (GetWRefCon
<>

NIL

THEN

(txLineH)

WITH

DO BEGIN
character

IF

NOT

:=
:=

{initialize

mouse

offsets

mouse

to

invalid

values}

THEN

-1;

position

(prevMouseLoc,

{track

text}

-1;

rightOffset

SetPt

the

;

shiftKeyIsDown

leftOffset

{get

BEGIN

LockHandleHigh

txLineH**
{initialize

(w) ) ;

and

to

invalid

kMaxInteger,

display

text

values}

kMaxInteger) ;

selection

or

caret

}

<>

0

THEN

BEGIN

to

lineStart,

REPEAT

IF

DeltaPoint

(where,

{mouse

moved: }

has

prevMouseLoc)

prevMouseLoc

:=

{adjust

position

{

mouse

convert

mouse

where;

relative

position's

INTEGER

to

}

FIXED,

}

{ assume
{ assume

style run position doesn’t
no scaling (1: 1 ratio) }

matter,

charLoc

:=

textLength,

PixelToChar(@textBuffer,

BitShift

(where.h

leadingEdge,

-

lineStart.h,

}
0,

16),

widthRemaining,

smOnlyStyleRun,

IF

charLoc

(kOneToOneScaling),

POINT

(kOneToOneScaling)
) ;

<>

{character
IF

POINT

rightOffset

location

leftoffset
{anchor

=

-1

position

THEN

has

BEGIN

changed: }

THEN
hasn't

leftOffset := charLoc;
rightOffset := charLoc;

been

set

yet: }

{set anchor position}
{save new caret pos. }

{erase previous selection; note that it }
{would be more optimal to erase only the }
{ difference between old and new selection}
MyDeleteSelectionAreas(w,

3-56

Using QuickDraw Text

txLineH) ;

CHAPTER

3

QuickDraw Text

{now

get

the

HiliteText

selection

ranges

(@textBuffer,
rightOffset,

{check

{ or
IF

whether

a

range

it’s

only

an

if

to

highlight}

textLength,

leftoOffset,

selectionOffsets) ;

of

text

is

insertion

selected,

}

point}

selectionOffsets[0].offFirst

<>

selectionOffsets[0].offSecond

THEN

BEGIN

{it’s a selection range: }
c := 0;
{offsetPairs

are

zero-based}

REPEAT
leftSide

:=

CharToPixel

textLength,

(@textBuffer,

0,

selectionOffsets[c]
smHilite,
POINT
:=

smOnlyStyleRun,

(kOneToOneScaling),

POINT
rightSide

.offFirst,

(kKOneToOneScaling)
) ;
CharToPixel

textLength,

(@textBuffer,

0,

selectionoffsets[c]
smHilite,

{put
IF

smOnlyStyleRun,

POINT

(kOneToOneScaling),

POINT

(kKOneToOneScaling)
) ;

rectangle

rightSide

ends
<

in

right

leftSide

THEN

SwapIntegers(leftSide,

{now

draw

.offSecond,

the

order}

rightSide) ;

rectangle}

MyAddSelectionArea(txLineH,
lineStart.v

leftSide,
-

caretHeight,

rightSide,lineStart.v,
TRUE) ;
ec

:=

UNTIL

c

+

1;

(selectionOffsets[c].offFirst

selectionOffsets[c]

.offSecond)

OR

=
(c

=

3);

END
ELSE

BEGIN

{it’s a caret position, not a range:}
{ calculate caret and draw it}
{position of
{ direction;

Using QuickDraw Text

caret depends on character's }
call CharacterType to find it}

3-57

CHAPTER

3

QuickDraw Text

IF

BAND

(CharacterType

(@textBuffer,

selectionoffsets[0].offFirst),
smCharRight)

<>

0

direction

:=

smRightCaret

THEN

:=

smbLeftCaret;

ELSE

direction
leftSide

:=

CharToPixel

(@textBuffer,

textLength,

0,

selectionOffsets[0].offFirst,
direction,

smOnlyStyleRun,

POINT

(kOneToOneScaling),

POINT

(kOneToOneScaling)
) ;

{if user has specified dual caret, call
{ CharToPixel again with the opposite }
{

value

IF

for

the

direction

parameter}

documentSettings.useDualCaret
IF

}

direction

=

smRightCaret

direction

:=

smLeftCaret

:=

smRightCaret;

THEN

BEGIN

THEN

ELSE

direction
rightSide

:=

CharToPixel
textLength,

(@textBuffer,
0,

selectionoOffsets[0].offFirst,
direction,

smOnlyStyleRun,

POINT

(kOneToOneScaling),

POINT

(kOneToOneScaling)
) ;

END
ELSE

rightSide
IF

leftSide

{it’s

:=
=

only

leftSide;

rightSide

THEN

a single

caret: }

MyAddSelectionArea(txLineH,
lineStart.v

leftSide

+

lineStart.v,
ELSE

-

leftSide,
caretHeight,

kCaretWidth,
TRUE)

BEGIN

{it’s

a split-caret:

{

left-to-right

is

{ right-to-left
IF

direction

=

assume
text,

upper

lower

caret

caret

text}
smRightCaret

THEN

BEGIN

{rightSide is right-to-left:
}
{ use upper caret for leftSide}

3-58

Using QuickDraw Text

is

}

CHAPTER

3

QuickDraw Text

MyAddSelectionArea(txLineH,
lineStart.v

leftSide

-

+

leftSide,
caretHeight,

kCaretWidth,

lineStart.v

-

(caretHeight

DIV

MyAddSelectionArea(txLineH,
lineStart.v

TRUE) ;

-

(caretHeight

rightSide

2),

rightSide,

+

DIV

2),

kCaretWidth,

lineStart.v,

TRUE);

END
ELSE

BEGIN

{rightSide is left-to-right:
}
{ use lower caret for leftSide}
MyAddSelectionArea(txLineH,
lineStart.v

rightSide

-

+

lineStart.v

rightSide,
caretHeight,

kCaretWidth,
-

(caretHeight

DIV

MyAddSelectionArea(txLineH,
lineStart.v
(caretHeight
leftSide

+

lineStart.v,

2),

TRUE) ;

leftSide,

DIV

2),

kCaretWidth,
TRUE);

END ;
END ;
END
END ;
END ;

GetMouse
UNTIL

NOT

(where)

;

WaitMouseUp;

END ;

HUnlock

(Handle

END
END ;

(txLineH}

) ;

{MyDoTextClick}

synchronizing the Caret With the Keyboard Script
If the user changes the keyboard script, you can call the CharToPixel function to
determine the caret position, specifying the direction parameter based on the
keyboard script. However, the user may change the keyboard script between the time

Using QuickDraw Text

3-59

CHAPTER

3

QuickDraw Text

you draw and erase the caret. You can save the position where you drew the caret, then
invert (erase) at that position again. To do this, save the direction of the keyboard script,
the screen pixel width, or even the whole rectangle.

Highlighting a Text Selection
To display a selection range, you typically highlight the text. This process entails
converting the offsets to their display screen pixel locations, and then calling the
InvertRect procedure to display the text selection in inverse video or with a colored or
outlined background.
When a range of text to be highlighted is unidirectional, it is contiguous in both memory
order and display order; the highlighted text constitutes a single range. When the text is
bidirectional, however, it can contain characters that occur on direction boundaries.

Although the characters are stored contiguously in memory, the leading edge of
one character@ glyph does not constitute the trailing edge of the other in display
order. A range of mixed-directional text that is contiguous in memory can produce up to
three physically separate ranges of displayed text to be highlighted. For example,
Figure 3-15 shows two separate ranges of highlighted text whose characters are
contiguous in memory.
Figure 3-15

Character
codes

OO
©

2
Ca

=

$61
$62
$69

ee

$72

>a

oO

$41

oo

BR

$28

Pr

=

=
YM
OO

$E3

ON

$D1

OD

$E5
$C7

Selection
range

DY

$CF

WO

$EA

FB

$29

$E1
$D3

;
;
a
Primary line direction = right to left

ef
abi BRC
_

$63

on

soCn
Cn
Cro

3-60

Characters

0

GOG&e~re

Byte
offsets

Highlighting mixed-directional text

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

To highlight a selection range, you need the beginning and ending byte offsets of the
selected text. From these offsets, you determine one or more pairs of offsets of the
displayed text. Once you have the pairs of offsets, you determine the pixel locations that
mark the beginning and the end of the displayed text of each pair. You can include the
following steps in the inner loop of your highlighting routine to determine these values.
1. You call HiliteText to get the individual pairs of byte offsets that encompass the
onscreen ranges of text to be highlighted. The HiliteText procedure always returns
three pairs of offsets. This is because if a text selection contains mixed-directional text,
it can consist of up to three distinct ranges of text when displayed. For unidirectional
text, HiliteText returns one pair that contains the beginning and ending byte offsets
whose text is to be highlighted, and two pairs that each include the same numbers.
You can ignore any pair of duplicate numbers.
2. Using the offset pairs that HiliteText returns, you convert each byte offset of a pair
to its equivalent onscreen pixel location. You call CharToPixel once each for the
beginning and ending offsets of a pair. You might call CharToPixel up to 6 times.
You must pass the CharToPixel function a direction parameter of hilite, which
signals it to use the primary line direction to determine the correct caret position.
When you specify hilite, CharToPixel returns the correct caret position for the
glyph based on the text direction of its character.
Once you have the pixel locations corresponding to the ends of each range of text, you
must convert them to display line pixel locations that are relative to the line@ left margin.
(The CharToPixel function returns the pixel location relative to the left edge of the text
range for which you called it.) If you saved the line layout information and you have the
screen pixel widths of the preceding style runs in display order, you can sum the widths
of these style runs and add the screen pixel width that CharToPixel returns to the total.
You must do this for the beginning and ending pixel locations that mark the text. If you
did not save the screen pixel widths of the preceding style runs on the display line, you
must lay out the text line again to get these values. When you have the pixel locations
relative to left margin of the display line, you can highlight the text.

For text that is rendered in black and white, you call the InvertRect procedure to
highlight each distinct text range; the background color is exchanged with the foreground
color. For text that is rendered in color, all pixel values of the current background color
are replaced with the value of the highlighting color.
Generally, the user chooses the highlighting color from the Color control panel, and the
application uses this color. However, you can reset this color using the QuickDraw
HiliteColor procedure. If a monitor is black-and-white and a highlighting color is
speci ed, the highlighting color reverts to black.
Before you call InvertRect for colored text,

rst you must clear the HiliteMode

low-memory global. By default the highlight mode bit of the low-memory global variable
is set to 1. You clear it by setting it to 0. After you highlight the text, you don®need to
reset the bit; InvertRect resets it automatically.

Using QuickDraw Text

3-61

CHAPTER

3

QuickDraw Text

The easiest way to clear the highlight mode bit is to call the Toolbox UtilitiesQ3itclr
procedure, for example:
BitClr(Ptr(HiliteMode),

pHiliteBit)

;

just before calling InvertRect using srcXor mode. (Do not alter the other bits
in HiliteMode.)

Note
Routines that formerly used Xor inversion, such as InvertRect

and the text drawing routines, will use highlight mode if the hilite
bit is clear.
From assembly language, you must call the pHiliteBit selector for highlight mode
when you use the BitClear trap: BCLR must use the assembly-language equate
hiliteBit. For example:
BCLR

#hiliteBit,

hiliteMode

Customizing QuickDraw’s Text Handling
The QuickDraw bottleneck routines are procedures that perform the fundamental tasks
associated with QuickDraw drawing operations. For each type of object that QuickDraw
can draw, including text, there is a low-level routine which the higher-level routines call

that actually performs the operation. These low-level routines, called bottlenecks because
so many of the higher-level routines use them, carry out the actual work of measuring
and drawing text.
The QuickDraw text routines use two of the bottleneck routines extensivelyN one to
measure text (StdTxMeas) and one to draw it (StdText). Most of the high-level
QuickDraw text routines call the low-level routines. The use of bottleneck routines

provides fSexibility to QuickDraw and applications that need to alter or augment the
basic behavior of QuickDraw.

The graphics port record contains a eld (grafProcs) which is set by default to
NIL, indicating that QuickDraw should use the standard low-level bottleneck
routines. You can modify this eld to point to a record, QDProcs, which holds the
addresses of customized routines for QuickDraw to use instead of the standard ones.
For more information about the QDProcs record, see the QuickDraw chapters in

Inside Macintosh: Imaging.

You can set some of the elds of this record to point to the standard bottleneck routines,
and some to point to your customized routines. Your customized bottleneck routine can
augment the standard bottleneck routine by calling it directly, either before or after
performing its own operations, or it can replace a standard routine. If you replace either
of the two standard bottleneck routines used for measuring (StdTxtMeas) and drawing

3-62

Using QuickDraw Text

CHAPTER

3

QuickDraw Text

(StdText) text, the routines you install must have the same calling sequences as the
standard routines. See C_ow-Level QuickDraw Text RoutinesOon page 3-98 for these
routines and their parameters. For the major discussion of how to customize the
QuickDraw bottleneck routines, see Inside Macintosh: Imaging.
Note
Before replacing a bottleneck routine, consider the possibility that to do
so could jeopardize the future compatibility of the application. If you
replace either StdTxMeas or StdText, you change the behavior of the
high-level routines that call them. #
You can also customize QuickDrawG text drawing and measuring capabilities by
writing high-level routines that do additional processing, but call the standard bottleneck
routines.
Note

If you need to call either StdText or StdTxMeas directly, you must
check the graphics port grafProc eld to determine whether the

rst

bottleneck routines have been customized, and if so, you must call the
customized routine instead of the standard one. The bottleneck routines

are always customized for printing.

Text in QuickDraw Pictures
This section describes aspects of how text is stored in picture

les, including related

limitations and restrictions, such as the following:

m The grayishTextOr transfer mode is not stored in pictures
cannot use it for printing.

les, and therefore you

m Inside a picture de nition, DrawText cannot have a byteCount greater than 255.
Fonts
Whenever you record text ina picture le, QuickDraw stores the name of the current font
and uses it when playing back the picture. This is true for pictures drawn in both the
original and color graphics ports. The opcode that QuickDraw uses to save this
information is $002C. Here is its data type:
PictFontInfo

=

Record

length:
fontID:

Integer;
Integer;

{length of
{ID in the

data in bytes}
source system}

fontName:STR255;
End;

Using QuickDraw Text

3-63

CHAPTER

3

QuickDraw Text

QuickDraw saves this information only one time for each font used in a picture.
The code in Listing 3-10 generates a picture le containing
the font information that
Listing 3-11 shows.
Listing 3-10
GetFNum

Generating a picture file with font information
(‘Venice’,

theFontID);

TextFont

(theFontID) ;

pHand2

:=

OpenPicture

MoveTo

{Set

a

font

before

opening

PICT}

(pictRect) ;

(20,20);

DrawString(‘

Better

be

Venice’);

GetFNum(‘Geneva’,

theFontID) ;

TextFont

;

MoveTo

(theFontID)

(20,40)

DrawString

;

(‘Geneva’) ;

GetFNum(‘Geneva’,

theFontID) ;

TextFont

;

MoveTo

(theFontID)

(20,60)

DrawString

;

(‘Geneva’) ;

ClosePicture;

When QuickDraw plays back a picture, it uses the font family ID (font ID) as a reference
into the list of font names which are used to set the correct font on the target system.
Listing 3-11

OpCode
“0005
TxFont

0x002C

{9,

0656

656E

6963

{20,

OpCode

0x002C

20,

“ Better

be

6576

61”

}

/*

ditto

656E

‘geneva’

{20, “Geneva” }
0x002c {11,

DVText

save

current

font

*/

O084F

6577

2059

‘geneva’

{20,

“Geneva” }

Using QuickDraw Text

Venice” }
/*

TxFont

TxFont

/*

{9,

0647

DVText
OpCode
“0002

65”}

‘venice’

DHDVText
“0003

3-64

A picture file with font information

6F72

save

next

font

name

*/

*/

6B” }

/*

second

Geneva

does

another

$002C

*/

not

need

CHAPTER

3

QuickDraw Text

Text With Multiple Style Runs
If you used the Get Format Order procedure to determine the correct order in which to
draw text consisting of multiple style runs, the style runs are stored in display order
when you record the text in a picture le. To reconstruct the storage order of the text from
the picture le, an application that reads the style runs into memory from the picture le
must then use the Get FormatOrder procedure to reverse the display order to storage
order. Finally, the application must write the text into memory again, following the order

that

Get Format Order

returns.

For example, suppose you have a a text string consisting of three style runs with different
text directionsN A (right-to-left), B (left-to-right), and C
You number them: A=1, B=2, C=3.

(left-to-right)N in storage order.

You call Get Format Order for these style runs with a line direction of right to left, and it
returns 2, 3, 1. When you draw the style runs in display order and record them in a
picture le, they are written to the picture le in display order. Suppose that after you
record the picture le, an application cuts and pastes the text. Now the style runs are
written to memory in display order: B, C, A.

To get the proper storage order, you call Get Format Order again, with the same line
direction that you used the rst time you called Get FormatOrder to determine the
display order, and it produces the original storage order: A, B, C.

QuickDraw Text Reference
This section describes the data structures, routines, and an application-de

that provide the text-handling components of QuickDraw.

ned routine

In addition to the graphics port record, which all of the routines use and which is de ned
in the QuickDraw chapters of Inside Macintosh: Imaging, these routines use two additional
data structures: the font information record and the Style data type. They are described
in the Data StructuresOsection.
The CRoutinesOsection describes the QuickDraw routines that you use to de ne the text
drawing environment, measure and draw text, and identify what glyphs to highlight and

where to position the cursor in a range of text.
The constants that you use to identify the text direction and to specify where a style run
occurs within a line of text are listed in the Gummary of QuickDraw Text.OThe constants
that you use to identify a font are listed in the chapter Font ManagerOin this book.
Equivalent declarations in the C language for the declarations and routines described in
this section are listed in the CC Summary.O

QuickDraw Text Reference

3-65

CHAPTER

3

QuickDraw Text

Data Structures
This section describes the data structures that you use to provide information to the
text-handling routines of QuickDraw. The font information record returns measurement
information about the font or fonts used. The Style data type de nes the styles that you
use to set the text style.
For more information about QuickDraw pictures, see the QuickDraw chapters in Inside
Macintosh: Imaging.
The Font Information Record
The Get Font Info procedure uses the font information record to return measurement
information based on the font of the current graphics port. If the current font has an
associated font, as do Arabic and Hebrew, Get Font Info returns information based on
both fonts. The font information record contains the ascent, the descent, the width of the

largest glyph, and the leading for a given font. The StdTxtMeas function also uses a
record of type Font Info to return information about the current font. The Font Info
data type de nes a font information record.
TYPE

FontInfo

ascent:
descent:
widMax:
leading:

=

RECORD

Integer;
Integer;
Integer;
Integer;

{ascent}
{descent}
{maximum glyph
{leading}

width}

END;
Field descriptions

ascent

The measurement in pixels from the baseline to the ascent
line of the font.

descent

The measurement in pixels from the baseline to the descent line
of the font.
The width in pixels of the largest glyph in the font.
The measurement in pixels from the descent line to the ascent

widMax
leading

line below it.

The Style Data Type
The Style data type de nes the styles that you specify as values to the Text Face
procedure to set the text style in the current graphics port@txFace eld. QuickDraw
draws the glyph in this style.
StyleItem

=

(bold,
shadow,

Style

3-66

= SET

QuickDraw Text Reference

OF

italic,

underline,

condense,

StylelItem;

extend);

outline,

CHAPTER

3

QuickDraw Text

Routines
This section describes the routines that you use to set the text characteristics of the
graphics port drawing environment, measure and draw text, lay out lines of text, and
determine where to position the caret and which glyphs to highlight in a range of text. It
also describes two low-level routines that you can use to measure and draw text.
Four parameters that are common to a number of routines are described in detail here.
These parameters are also listed and de ned briefsy in the each routine.
The slop Parameter
The DrawJustified, MeasureJustified, PixelToChar, and CharToPixel routines

take a slop parameter. The value of this parameter is the number of pixels by which the
width of the text segment is to be changed, after the text has been scaled. The slop is a

signed value that speci es how much the text is to be extended or condensed. The slop
is derived from the calculations made using the proportion returned from the
PortionLine function for a style run. To measure or draw text that is not to be extended
or condensed, pass a slop value of 0.

The styleRunPosition Parameter
The PortionLine,

MeasureJustified,

DrawJustified,

PixelToChar,

and

CharToPixel routines take a styleRunPosition parameter. This parameter speci
the position of the style run on the display line, and is used to

es

m determine the proportion of total slop to apply to a style run
m measure or draw a line of justi ed text
identify where to break a line of text
m determine the caret position to mark an insertion point or highlight text.
The style run position parameter is meaningful only for those script systems that use
intercharacter spacing for justi cation. For all other script systems, the parameter exists
for future extensibility. Although the style run position parameter is not used, for
example, for justifying text in the Roman script system, to allow for future compatibility,
you should always specify the appropriate value for it for all calls that take it.
For those script systems that do use intercharacter spacing, space between style runs may
be allocated differently depending upon whether the style run is leftmost, rightmost, or
between two other style runs. For example, depending on the script system, if a style run
occurs at the beginning or end of a line, extra space may not be added to the outer edge of
the outermost glyph, whereas if a style run is interior to a line, all of the glyphs of the text
may be treated the same: extra space is allocated to both sides of every glyph including
those at either end of the style run.

QuickDraw Text Reference

3-67

CHAPTER

3

QuickDraw Text

Note
The current implementations of simple script systems such as Roman
and Cyrillic do not justify a line of text by changing the width of
nonspace characters. Instead, they rely solely on the use of space

characters: the same amount of extra width is added to (or subtracted

from) every space whether the space is at the beginning or end of the line
or interior to it.
Use one of the following constants (de ned as type
the styleRunPosition parameter.
Constant

Value

JustStyleCode) in

Meaning

onlyStyleRun

0

Only style run on the line

leftStyleRun

1

Leftmost of multiple style runs on the line

rightStyleRun

2

Rightmost of multiple style runs on the line

middleStyleRun

3

Interior style run: neither leftmost nor rightmost

The

numer

and

denom

The PortionLine,

Parameters

DrawJustified,

MeasureJustified,

PixelToChar,

CharToPixel, StdText, and StdTxMeas routines take numer and denom parameters.

Both numer and denom are point values: numer speci es the numerator for the
horizontal and vertical scaling factors, and denom speci es the denominator for
the horizontal and vertical scaling factors. Together, these values specify the scaling
factors for the text: numer .v over denom. v gives the vertical scaling (height), and
numer .h over denom.h

gives the horizontal scaling factors (width). For routines that

take these parameters, you need to specify values for numer and denom even if you are
not scaling the text. For unscaled text, you can specify scaling factors of 1, 1.
For all routines except StdTxtMeas that take these parameters, numer and denom are
input parameters only. For StdTxtMeas, numer and denom are reference parameters.
On output, these parameters contain additional scaling to be applied to the text. Use of
the output values is explained in the description of tdTxMeasOon page 3-99.

Setting Text Characteristics
The routines in this section set values in the text-related elds of the current graphics port
(Graf Port or CGrafPort). You also use these routines to set text characteristics that
vary from style run to style run. You use these routines to set the graphics port elds to
values equivalent to a new style run@ text characteristics before you call other
QuickDraw routines to measure and draw the text.

3-68

m The Text Font procedure speci

es the font to be used.

m The Text Face procedure speci

es the glyph style.

m The TextMode procedure speci

es the transfer mode.

m The Text Size procedure speci

es the font size.

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

m The CharExtra procedure speci es the amount of pixels by which to widen or
narrow each space character in a range of text.
m The SpaceExtra procedure speci es the amount of pixels by which to widen or
narrow each glyph other than the space characters in a range of text (CharExt ra).
Note
To ensure future compatibility and bene t from any future
enhancements, always use these routines to modify the text elds of the
graphics port record, rather than directly change the eld values.

TextFont
The Text Font procedure sets the font of the current graphics port in which the text is
to be rendered.
PROCEDURE

TextFont

(font:

font

The font family ID.

Integer) ;

DESCRIPTION
The Text Font procedure sets the value of the graphics port text font (txFont) eld. The
initial font family ID is 0, which represents the system font. The value that you specify
for this eld is either an integer or a constant. The range of integers currently de ned are
from 0 to 32767. Currently, negative font family IDs are not supported, although they
may be supported in the future.
For more information about Text Font, see Getting the FontOon page 3-20.

SPECIAL CONSIDERATIONS

The system font and application font have different font IDs and sizes on various script
systems. However, the special designators 0 and 1 always map to the system font and the
application font for the system script, respectively.

TextFace

The Text Face procedure sets the style of the font in which the text is to be drawn in the
current graphics port.
PROCEDURE

TextFace

face

The style for text to be drawn in the current graphics port.

QuickDraw Text Reference

(face:

Style);

3-69

CHAPTER

3

QuickDraw Text

DESCRIPTION

The Text Face procedure sets the value for the style of the font in the text face (txFace)
eld of the current graphics port. The Style data type allows you to specify a set of one
or more of the following prede

ned constants: bold, italic, underline, outline,

shadow, condense, and extend. In Pascal, you specify the constants within square
brackets. For example:
TextFace
TextFace

([bold]) ;
([bold,italic])

;

{bold}
{bold and

italic}

The style is set to the empty set ([]) by default, which speci
information, see (Modifying the Text StyleOon page 3-21.

ASSEMBLY-LANGUAGE

es plain. For more

INFORMATION

In assembly language, the style set is stored as a word whose low-order byte contains bits
representing the style. The bit numbers are speci ed by the following global constants.
Constant

Bit

Meaning

bold

0

Bold style

italicBit

1

Italic style

ulineBit

2

Underlined style

outlineBit

3

Outlined style

shadowBit

4

Shadowed style

condense

5

Condensed style

extendBit

6

Extended style

If all bits are 0, the low-order byte represents the plain glyph style.

TextMode
The TextMode procedure sets the transfer mode for drawing text in the current
graphics port.
PROCEDURE
mode

TextMode

(mode:

Integer) ;

The transfer mode to be used to draw the text.

DESCRIPTION

The TextMode procedure sets the transfer mode in the graphics port txMode_ eld. The
transfer mode determines the interplay between what an application is drawing (the
source) and what already exists on the display device (the destination), resulting in the
text display.

3-70

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

There are two basic kinds of modes: pattern (pat) and source (src). Source is the kind
that you use for drawing text. There are four basic Boolean operations: Copy, Or, Xor,

and Bic (bit clear), each of which has an inverse variant in which the source is inverted
before the transfer, yielding eight operations in all. Original QuickDraw supports these
eight transfer modes. Color QuickDraw enables your application to achieve color effects
within those basic transfer modes, and offers an additional set of transfer modes that

perform arithmetic operations on the RGB values of the source and destination pixels.
See the chapter CColor QuickDrawOin Inside Macintosh: Imaging for a complete discussion
of the arithmetic transfer modes. Other transfer modes are grayishTextoOr,
transparent mode, and text mask mode.

Table 3-1 shows the eight basic transfer modes and their effects on the destination pixels.
Table 3-1
Source

Effects of the basic transfer modes
Action on the destination pixel
If black source

If white source

srcCopy

Force black

Force white

srcor

Force black

Leave alone

srcexOr

Invert

Leave alone

srcBic

Force white

Leave alone

Not SrceCopy

Force white

Force black

NotSrcOr

Leave alone

Force black

Not Srcexor

Leave alone

Invert

NotSrcBic

Leave alone

Force white

This is how color affects these transfer modes when the source pixels are either all black
(all 18) or white (all 06).

Copy
The Copy mode applies the foreground color to the black part of the source (the part
containing 1) and the background color to the white part of the source (the part
containing 0G), and replaces the destination with the colored source.
Or

The Or mode applies the foreground color to the black part of the source and replaces the
destination with the colored source. The white part of the source isn@®transferred
to the destination. If the foreground is black, the drawing will be faster. Copying to a
white background always reproduces the source image, regardless of the pixel depth.

QuickDraw Text Reference

3-71

CHAPTER

3

QuickDraw Text

Xor

The Xor mode complements the bits in the destination corresponding to the bits equal to
1 in the source. When used on a colored destination, the color of the inverted destination
isn@de ned.

Bic
The Bic mode applies the background color to the black part of the source and
replaces the destination with the colored source. The white part of the source isn®
transferred to the destination. The black part of the source is erased, resulting in white
in the destination.
NotCopy
The Not Copy mode applies the foreground color to the white part of the source and the
background color to the black part of the source, and replaces the destination with the
colored source. It thus has the effect of reversing the foreground and background colors.
NotOr

The NotOr mode applies the foreground color to the white part of the source and
replaces the destination with the colored source. The black part of the source isn@®
transferred to the destination. If the foreground is black, the drawing will be faster.
NotXor
The

Not Xor mode inverts the bits that are 0 in the source. When used on a colored

destination, the color of the inverted destination isn@de

ned.

NotBic

The Not Bic mode applies the background color to the white part of the source and
replaces the destination with the colored source. The black part of the source isn@®
transferred to the destination.
The arithmetic transfer modes are addOver, addPin, subOver, subPin, adMax, adMin,
and blend. For color, the arithmetic modes change the destination pixels

by performing arithmetic operations on the source and destination pixels. Arithmetic
transfer modes calculate pixel values by adding, subtracting, or averaging the RGB
components of the source and destination pixels. They are most useful for 8-bit color,
but they work on 4-bit and 2-bit color also. When the destination bitmap is one bit
deep, the mode reverts to the basic transfer mode that best approximates the arithmetic
mode requested.
The grayishTextOr transfer mode draws dimmed text on the screen. You can

use it for black-and-white or color graphics ports. The grayishTextoOr transfer
mode is not considered a standard transfer mode because currently it is not stored in
pictures, and printing with it is unde ned. (It does not pass through the QuickDraw
bottleneck routines.)

3-72

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

The transparent mode replaces the destination pixel with the source pixel if the source
pixel isn®equal to the background color. This mode is most useful in 8-bit, 4-bit, or
2-bit color modes.
Note
Multibit fonts may have a speci c color. Some transfer modes may not
produce the desired results with a multibit font. However, the arithmetic
modes, transparent mode, and hilite mode work equally well with single
bit and multibit fonts. Multibit fonts draw quickly in srcOr mode only if
the foreground is white. Single bit fonts draw quickly in srcOr mode
only if the foreground is black. Grayscale fonts produce a spectrum of
colors, rather than just the foreground and background colors. The
following table shows transfer mode constants and
their selectors. @
Table 3-2

Transfer mode constants and selectors

Transfer mode

Selector

Transfer mode

Selector

srcCopy

0

addPin

33

srcor

1

addOver

34

srcXor

2

subPin

35

srcBic

3

transparent

36

notSrcCopy

4

adMax

37

notSrcor

5

subOver

38

notSrcXor

6

adMin

39

notSrcBic

7

grayishTextoOr

49

blend

32

mask

64

For more information about transfer modes, see the chapters GQuickDraw DrawingOand
olor QuickDrawOin Inside Macintosh: Imaging.

TextSize
The Text Size procedure sets the font size for text drawn in the current graphics port to
the speci ed number of points.
PROCEDURE

TextSize

size

The font size in points. If you specify 0, the system font size (normally
12 points) is used.

QuickDraw Text Reference

(size:

Integer) ;

3-73

CHAPTER

3

QuickDraw Text

DESCRIPTION

The Text Size procedure sets the font size in the text size (txSize)

eld of the current

graphics port record. The initial setting is 0, which speci es that the font size of the
system font is to be used. You may specify a value from 0 up to 32,767. For more
information, see Changing the Font SizeOon page 3-22.

SpaceExtra
The SpaceExt ra procedure speci es the number of pixels by which to widen
(or narrow) each space in a style run to be drawn in the current graphics port.
PROCEDURE

SpaceExtra

(extra:

Fixed);

extra

The amount (in pixels or binary fractions of a pixel) to widen (or narrow)

each space in a style run ona

line.

DESCRIPTION

The SpaceExt ra procedure sets the value of the extra space (spExtra) eld in the
current graphics port record. The initial setting is 0. You can pass a negative value for the
extra parameter, but be careful not to narrow spaces so much that the text is
unreadable. The value you specify is added to the width of each space character in the
style run. For those script systems that do not use spaces, any value set in the extra space
eld is ignored. For those script systems that use spaces as delimiters, if you do not want
to justify a line of text using DrawJust ified, you can use the SpaceExtra procedure
to seta xed number of pixels to be added to each space character, then call DrawText or
DrawString.

When you use the justi cation routines (MeasureJustified, DrawJustified) to
measure or draw justi ed text, they temporarily reset the extra space value. They add to
the current value of the eld, if any, the amount of extra space to be added to space
characters in the speci ed text in order to justify the text, based on calculations that take
into account the slop value for the range of text and all of the text characteristics. On exit,
these routines restore the original value.
For more information about SpaceExt ra, see CChanging the Width of CharactersOon
page 3-22.

SPECIAL CONSIDERATIONS

For a color graphics port (CGrafPort), you can use SpaceExt
ra by itself or in
conjunction with the CharExt ra procedure to format a line of text in the 1-byte
simple or 2-byte script systems. You should not use CharExtra for 1-byte complex
script systems.

3-74

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

CharExtra
For a color graphics port (CGrafPort), the CharExt ra procedure speci es the
number of pixels by which to widen (or narrow) the glyphs of each nonspace character in
a style run.
PROCEDURE

CharExtra

(extra:

Fixed);

extra

The amount (in pixels or decimal fractions of a pixel) to widen (or narrow)
each glyph other than the space character in a range of text.

DESCRIPTION
The CharExtra procedure sets the value of the chExtra_ eld of the color graphics
port record. This eld contains a number that is in 4.12 fractional notation: four bits of
signed integer followed by 12 bits of fraction. The CharExt ra procedure uses the value
of the txSize eld,so you must call Text Size to set the font size of the text before you
call CharExt
ra.
The initial setting is 0. You can pass a negative value for the ext ra parameter, but be
careful not to narrow glyphs so much that the text is unreadable. The measuring and
drawing routines use the value in this eld when an application calls them to measure or
draw text. The CharExtra procedure is available only for color graphic ports.

SPECIAL CONSIDERATIONS

Do not use CharExt ra for script systems that include zero-width characters, such as
diacritical marks, because intercharacter space is added to all glyphs, separating the
diacritical mark from the glyph of the character. Do not use it for script systems that
include contextual forms, such as ligatures or conjunct characters, which would not be
represented properly were intercharacter space added to these glyphs. For example, you
should not use CharExt ra for the Devanagari or Arabic languages, whose text is drawn
as connected glyphs, or with the Sonata font because it includes zero-width characters.
The 2-byte script systems use the chExtra_

eld value properly.

GetFontInfo
The Get Font Info procedure returns information about the current graphics port@ font,
taking into account the style and size in which the glyphs are to be drawn.
PROCEDURE

info

GetFontInfo

(VAR

info:

FontInfo);

A font information record that contains the font measurement

information, in integer values.

QuickDraw Text Reference

3-75

CHAPTER

3

QuickDraw Text

DESCRIPTION

The

Get Font

Info procedure returns the ascent, descent, leading, and width of the

largest glyph of the font in the text font, size, and style speci ed in the current graphics
port. If the script system speci ed by the current graphics port txFont eld has an
associated font, as do Hebrew and Arabic,

Get Font

Info returns combined information

based on both fonts. This is to accommodate text written in the Roman script when the
primary script system is non-Roman.

However, even if all of the text is written in a

non-Roman script, if there is an associated font,

Get Font Info always bases its

information on the combined fonts. You can determine the line height, in pixels, by
adding the values of the ascent, descent, and leading

elds.

The Get Font Info procedure is similar to the Font Manager@ FontMet rics procedure,
except that the Get Font Info procedure returns integer values. See (Lhe Font
Information RecordOon page 3-66 for a description of the record and its elds.
Drawing Text
QuickDraw provides routines that allow you to draw a single character, a Pascal string,
or an arbitrary sequence of text. You can also draw a text sequence made narrower or
wider using these routines; this technique is commonly used to justify a line of text.
These routines draw text in the font, style, and size of the current graphics port.
Consequently, you can draw only a single style run at a time using these routines.
m The DrawChar procedure draws the glyph of a single 1-byte character.
mw The DrawString procedure draws the text of a Pascal string.
m The DrawText procedure draws the glyphs of a sequence of characters.
m The DrawJustified procedure draws a sequence of text that is widened or
narrowed by a speci ed number of pixels.
Whether the text to be drawn has a left-to-right direction, a right-to-left direction, or is

bidirectional, QuickDraw always draws text starting at the current pen location and
always advances the pen to the right by the width of the glyph or glyphs it has just
drawn. Before drawing text that has a right-to-left direction, QuickDraw reorders

the glyphs for display so that they can be read correctly, even though it draws them from
left to right.

DrawChar
The DrawChar procedure draws the glyph for the speci
location in the current graphics port.
PROCEDURE

ch

3-76

DrawChar

(ch:

CHAR)

ed character at the current pen

;

The character code whose glyph is to be drawn.

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

DESCRIPTION

The DrawChar procedure draws a single character@ glyph and then advances the pen by
the width of the glyph. If the glyph isn@in the font, the font@ missing symbol is drawn.

For more information, see Andividual GlyphsOon page 3-28.
Note
If you@e drawing more than one character, it@ faster to make
one DrawString or DrawText call rather than a series of

DrawChar calls. @

SPECIAL CONSIDERATIONS

Because it takes a single-byte value as the ch parameter, DrawChar works only for 1-byte
script systems. If you want to draw the glyph of a single character in a 2-byte script, call
either DrawText, DrawString, or DrawJustified.

However, a series of calls to DrawChar in a 1-byte complex script system can give
incorrect results because a text string is not always a simple concatenation of a series
of characters. In a contextual script, two different glyphs may be used to represent a
single character in its contextual form and alone. To draw a sequence of text in a 1-byte
complex script system, use DrawText, DrawString, or DrawJustified instead.
However, for 1-byte complex scripts, you can use DrawChar for special purposes, such
as to include the isolated glyph of a character in a book@ index, for example, to show a
single glyph as it exists apart from contextual transformations.

DrawString
The DrawString procedure draws the speci ed Pascal string at the pen location in the
current graphics port (Graf Port or CGraf Port).
PROCEDURE

Ss

DrawString

(s:

Str255) ;

A Pascal string consisting of the text to be drawn.

DESCRIPTION

The DrawString procedure draws the string with its left edge at the current pen
location, extending right. The nal position of the pen location, after the text is drawn, is
to the right of the rightmost glyph in the string. QuickDraw does not do any formatting,
such as handling of carriage returns or line feeds.
Note that you can use

QuickDraw Text Reference

DrawSt ring

only for a Pascal string containing a single style run.

3-77

CHAPTER

3

QuickDraw Text

Drawing text visible on the screen
QuickDraw temporarily stores on the stack all of the text you ask it to
draw, even if the text is to be clipped. When drawing large font sizes or
complex style variations, draw only what is visible on the screen. You
can determine the number of characters whose corresponding glyphs
actually ton the screen by calling the StringWidth function to
determine the length of the string before calling DrawString. @
If you specify values in the graphics port spExtra or chExtra_ elds to change the
width of space or nonspace characters, DrawSt ring takes these values into account.

SPECIAL CONSIDERATIONS

For right-to-left text, such as Hebrew or Arabic, QuickDraw draws the nal (leftmost)
glyph rst, then moves to the right through all the glyphs, drawing the initial (rightmost)
glyph last.

Note that you should not change the width of nonspace characters for 1-byte simple
script systems with zero-width characters or 1-byte complex script systems. For more
information, see CCharExtraOon page 3-75.
For contextual script systems, DrawSt ring substitutes the proper ligatures, reversals,
and compound characters as needed.
Note
Inside a picture de nition, DrawString can@have a byteCount
greater than 255. @

Draw

Text

The DrawText procedure draws the speci
current graphics port.
PROCEDURE

DrawText

(textBuf:

Ptr;

ed text at the current pen location in the

firstByte,

byteCount:

textBuf

A pointer to a buffer containing the text to be drawn.

firstByte

An offset from the start of the text buffer (textBuf) to the
text to be drawn.

byteCount

The number of bytes of text to be drawn.

Integer) ;

rst byte of the

DESCRIPTION

The DrawText procedure draws the text with the leftmost glyph at the current pen
location, extending right. After QuickDraw draws the text, it sets the pen location to the
right of the rightmost glyph. For more information, see Olext SegmentsOon page 3-29.

3-78

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

Drawing text visible on the screen
QuickDraw temporarily stores on the stack all of the text you ask it to
draw, even if the text is to be clipped. When drawing a range of text, it@
best to draw only what is visible on the screen. If an entire text string
does not tona line, truncate the text at a word boundary. If possible,
avoid truncating within a style run. You can determine the number of
characters whose glyphs actually ton the screen by calling the
TextWidth function before calling DrawText. @
If you specify values in the graphics port spExtra and chExtra_ elds to change the
width of nonspace and space characters, both TextWidth and DrawText take these
values into account.

SPECIAL CONSIDERATIONS

For 1-byte complex script systems, DrawText substitutes the proper ligatures, reversals,
and compound characters as needed.
For right-to-left text, such as Hebrew or Arabic, QuickDraw draws the

nal (leftmost)

glyph rst, then moves to the right through all the characters, drawing the initial
(rightmost) glyph last.

For 2-byte script systems, note that byteCount is the number of bytes to be drawn, not
the number of glyphs. Because 2-byte script systems also include characters consisting of
only 1 byte, do not simply multiply the number of characters by 2 to determine this
value; you must determine and specify the correct number of bytes.
Note
Inside a picture de
than 255.

nition, DrawText cannot have a byteCount greater

Draw] ustified
The DrawJustified procedure draws the speci ed text at the current pen location in
the current graphics port, taking into account the adjustment necessary to condense or
extend the text by the slop value, appropriately for the script system.
PROCEDURE

DrawJustified

(textPtr:
slop:

Ptr;

textLength:

styleRunPosition:
numer,

textPtr
textLength

LongInt;

Fixed;
denom:

JustStyleCode;

Point);

A pointer to the memory location of the beginning of the text to be drawn.
The number of bytes of text to be drawn.

QuickDraw Text Reference

3-79

CHAPTER

3

QuickDraw Text

slop

The amount of slop for the text to be drawn. A positive value extends the
text segment; a negative value condenses the text segment.

styleRunPosition

The position on the line of this style run. The style run can be the only one
on the line, the leftmost on the line, the rightmost on the line, or one

between two other style runs.
numer
denom

A point giving the numerator for the horizontal and vertical

scaling factors.

A point giving the denominator for the horizontal and

vertical scaling factors.

DESCRIPTION

The DrawJustified procedure is similar to the DrawText procedure, except that you
use it to draw text that is expanded or condensed by the number of pixels speci ed by
slop. The DrawJustified procedure is most commonly used to draw a line of justi ed
text.
The DrawJustified procedure draws the speci

ed text in the font, size, and style of the

current graphics port, taking into account any scaling factors, and it distributes the slop
appropriately for the script system. Regardless of the line direction of the text to be
drawn, you place the pen at the left edge of the line before calling DrawJustified for
the rst style run. For all subsequent style runs on that line, QuickDraw advances the pen
appropriately.
If DrawJust ified changes the width of spaces, it temporarily resets the space extra
(spExtra) value. It adds to the current value of the

eld, if any, the amount of extra

space to be applied to each space character within the range of text in order to justify the
text, based on calculations that take into account the slop value and all of the text
characteristics. On exit, DrawJust ified restores the original value.

For the slop parameter, pass DrawJust ified the value assessed for this style run based
on the proportion returned for it from

Port ionLine.

For more information, see (The

numer and denom ParametersOon page 3-68.
Note
Be sure to pass the same values for sty leRunPosition and the scaling
factors (numer and denom) to DrawJust ified that you pass to
PortionLine.

@

See (he styleRunPosition ParameterOon page 3-67 for a description of this parameter
and the values it takes. See
he slop ParameterOon page 3-67 for more information
about the slop parameter.
For more information about how to use DrawJustified in conjunction with the other
routines used to prepare to draw a line of justi ed text, seeQveasuring and Drawing
Lines of Text,Obeginning on page 3-29.

3-80

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

SPECIAL CONSIDERATIONS

The DrawJustified procedure works with text in all script systems. For example, to
depict justi ed Arabic text, DrawJust ified uses extension bars to create the additional
width that is distributed as slop within a style run.
For 1-byte complex script systems, DrawJust ified substitutes the proper ligatures,
reversals, and compound characters as needed.

For 2-byte script systems that do not use space characters to delimit words,
DrawJustified distributes the slop value in a manner appropriate to the script system.
For script systems, such as Japanese, that use ideographic characters, DrawJustified
distributes the additional screen pixel width appropriately for the text representation.
Note that text Length is the number of bytes to be drawn, not the number of characters.
Because 2-byte script systems also include characters consisting of only 1 byte, do not
simply multiply the number of characters by 2 to determine this value; you must
determine and specify the correct number of bytes.
The DrawJustified procedure may move memory; do not call this procedure at
interrupt time.

Measuring Text
Laying out text to determine how much of it ts on the display line entails measuring the
text. QuickDraw provides ve high-level routines that let you do this:
mw

The CharWidth

function returns the horizontal extension of a single glyph.

mw The StringWidth function returns the width of a Pascal string.
m The TextWidth function returns the width of the glyphs of a text segment.
m The MeasureText procedure lls an array with an entry for each character
identifying the width of each character@ glyph as measured from the left side of the
entire text segment.
m The MeasureJustified procedure Ils an array with an entry for each character ina
style run identifying the width of each character@ glyph as measured from the left
side of the text segment.
These routines measure text in the font, style, and size of the current graphics port.
Consequently, you need to call them once for each individual style run in any line of text
that contains multiple style runs.

CharWidth
The CharWidth function returns the width in pixels of the speci
FUNCTION
ch

CharWidth

(ch:

CHAR):

ed character.

Integer;

The character whose width is to be measured.

QuickDraw Text Reference

3-81

CHAPTER

3

QuickDraw Text

DESCRIPTION

The CharWidth function includes the effects of the stylistic variations for the text set in
the current graphics port. If you change any of these attributes after determining the
glyph width but before actually drawing it, the predetermined width may not be correct.
For a space character, CharWidth also includes the effect of SpaceExtra. Fora
nonspace character, CharWidth includes the effect of CharExt ra. For more

information, see Gndividual GlyphsOon page 3-28.

SPECIAL CONSIDERATIONS

Because it takes a single-byte value as the ch parameter, CharWidth works only for
1-byte simple script systems.
A series of calls to CharWidth in a contextual 1-byte font may give incorrect results,
because the width of a text segment may be different from the sum of its individual
character widths. In that case, to measure a line of text you should call

Text Width.

Do not use the CharWidth function for 2-byte script systems. If you want to measure the
width of a single glyph in a 2-byte font, you should use Text Width.

StringWidth
The St ringWidth function returns the length in pixels of the speci
FUNCTION

Ss

StringWidth

(s:

Str255):

ed Pascal string.

Integer;

A pascal string containing the text to be measured.

DESCRIPTION

You should not call StringWidth to measure scaled text. Although StringWidth takes
into account the graphics port record settings, it does not accept scaling parameters, and
therefore cannot determine the correct text width result for text to be drawn using scaling
factor parameters. For more information, see (Pascal StringsOon page 3-28.
If you specify values in the graphics port spExtra or chExtra_ elds to change the
width of space or nonspace characters, StringWidth takes these values into account.
The St ringWidth function works with all script systems.

3-82

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

TextWidth
The Text Width function returns the length in pixels of the speci
FUNCTION

TextWidth

(textBuf:
firstByte,

ed text.

Ptr;
byteCount:

Integer):

Integer;

textBuf

A pointer to a buffer that contains the text to be measured.

firstByte

Anoffset from textBuf tothe

byteCount

The number of bytes of text to be measured.

rst byte of the text to be measured.

DESCRIPTION
You can use Text Width to measure the screen pixel width of any text segment that has
uniform character attributes. You can use it to measure the style runs in a line of text,
whether you intend to draw the line using DrawText or DrawJustified. The
TextWidth function takes into account the character attributes set in the graphics
port. If you change any of these attributes after determining the text width but before
actually drawing the text, the predetermined width may not be correct. For a space
character, Text Width also includes the effect of SpaceExt ra. For a nonspace character,
TextWidth includes the effect of CharExtra.
The Text Width function works with text in all script systems because the script
management system modi es the routine if necessary to give the proper results.
Note
To draw justi ed lines of text that include multiple style runs, you
calculate the amount of extra pixels, or slop, that remains to be

distributed throughout the line. This process entails measuring the
screen pixel width of each style run on the line: you can use Text Width
for this purpose. For a complete discussion of how to use Text Width to
prepare to draw a line of justi ed text, refer to OMeasuring and Drawing
Lines of TextObeginning page 3-29.

SPECIAL CONSIDERATIONS

For 1-byte complex script systems, Text Width calculates the widths of any ligatures,
reversals, and compound characters that need to be drawn.
Note that byteCount is the number of bytes to be measured, not the number of

characters. Because 2-byte script systems also include characters consisting of only one
byte, you should not simply multiply the number of characters by 2 to determine this
value; you must determine and specify the correct number of bytes.

QuickDraw Text Reference

3-83

CHAPTER

3

QuickDraw Text

Measurelext

The MeasureText procedure provides an array version of the Text Width
each character in the speci

function. For

ed text, MeasureText calculates the width of the character@

glyph in pixels from the left edge of the text segment.
PROCEDURE

MeasureText

(count:

Integer;

textAddr,

charLocs:

Ptr);

count

The number of bytes to be measured.

textAddr

A pointer to the memory location of the beginning of the text to be
measured. The value of textAddr must point directly to the rst
character whose glyph is to be measured.

charLocs

A pointer to anapplication-de

ned array of count + 1 integers.

DESCRIPTION

The MeasureText procedure calculates the onscreen pixel width of the glyph of each
character beginning from the left edge of the text segment. On return, the rst element in
the charLocs array contains 0 and the last element contains the total width of the text
segment, when the primary line direction is left to right and the text is unidirectional.
When the primary line direction is right to left and the text is unidirectional, the rst
element in the array contains the total width of the text segment, and the last element in
the array contains 0. When the text is bidirectional, at a direction boundary,

MeasureText selects the character whose direction maps to that of the primary
line direction.
The MeasureText procedure returns the same results that an application would get if it
called CharToPixel for each character with a direction parameter value of hilite.
Using MeasureText to nd the pixel location of a character@ glyph is less ef cient than
using the CharToPixel function because the application must de ne the array pointed
to by charLocs, and then walk the array after MeasureText returns the results.
For more information about MeasureText, contact Developer Technical Support.

SPECIAL CONSIDERATIONS

Some fonts in 1-byte script systems may have zero-width characters, which are usually
overlapping diacritical marks that typically follow the base character in memory. In this
case, MeasureText measures both the glyph of the base character (the high-order,
low-address byte) and the width of the diacritical mark. The charLoc array includes an
entry for each, but both entries contain the same value.

For 1-byte complex script systems, MeasureText calculates the widths of any ligatures,
reversals, compound characters, and character clusters that need to be drawn. For

example, for an Arabic ligature, the entry that corresponds to the trailing edge of each
character that is part of the ligature is the trailing edge of the entire ligature.

3-84

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

Note that count is the number of bytes to be measured, not the number of characters.

Because 2-byte script systems also include characters consisting of only one byte, do not
simply multiply the number of characters by 2 to determine this value; you must
determine and specify the correct number of bytes. For 2-byte characters, the charLocs
array contains two entriesN one corresponding to each byteN but both entries contain the
same pixel-width value.

MeasureJustified
For text that is expanded, condensed, or scaled, the MeasureJustified procedure

calculates the onscreen width in pixels from the left edge of the text segment to the glyph
of the character.
PROCEDURE

MeasureJustified

(textPtr:
slop:

Ptr;

Fixed;

textLength:
charLocs:

styleRunPosition:
numer,

textPtr
textLength

denom:

LongInt;

Ptr;

JustStyleCode;

Point);

A pointer to the memory location of the beginning of the text to
be measured.
The number of bytes of text to be measured. The text length should equal
the entire visible part of the text on a line, including trailing spaces if and
only if they are displayed. Otherwise, the results for the last glyph on the
line may be invalid.

slop

The amount of slop for the text to be drawn. A positive value extends the
text segment; a negative value condenses the text segment.

charLocs

Apointer to an application-de

ned array of textLength + 1 integers.

styleRunPosition

The position on the line of this style run. The style run can be the only one
on the line, the leftmost on the line, the rightmost on the line, or one

between two other style runs.
numer

A point giving the numerator for the horizontal and vertical

denom

A point giving the denominator for the horizontal and vertical

scaling factors.
scaling factors.

DESCRIPTION

The MeasureJustified procedure is similar to the MeasureText procedure, except
that it is used to nd the pixel location of a character@ glyph in text that is expanded or
condensed.

QuickDraw Text Reference

3-85

CHAPTER

3

QuickDraw Text

The MeasureJustified procedure calculates the onscreen pixel width of the glyph of
each character beginning from the left edge of the text segment, taking into account slop
value, scaling, and style run position.

On return, the rst element in the charLocs array contains 0 and the last element
contains the total width of the text segment, when the primary line direction is left to
right and the text is unidirectional. When the primary line direction is right to left and the
text is unidirectional, the rst element in the array contains the total width of the text
segment, and the last element in the array contains 0. When the text is bidirectional, at a
direction boundary, MeasureJust ified selects the character whose direction maps to
that of the primary line direction.
The MeasureJustified procedure returns the same results that an application would
get if it called CharToPixel for each character with a direction parameter value of
hilite. Using Measuredustifiedto nd the pixel location of a character@ glyph is
less ef cient than using the CharToPixel function because the application must de ne
the array pointed to by charLocs, and then walk the array after MeasureText returns
the results.
The MeasureJustified procedure temporarily resets the space extra (SpExt ra) value,
adding to the current value of the eld, if any, the amount of extra space to be added to
space characters in order to fully justify the text, based on calculations that take into
account the slop value and all the text characteristics. On exit, MeasureJustified

restores the original value.

Because MeasureJustified measures text in only the current font, style, and size, you
need to call it once for each individual style run.
For more information about the scaling factors, see (The numer and denom ParametersO

on page 3-68. See (Lhe styleRunPosition ParameterOon page 3-67 for a description of the
styleRunPosition parameter and the values it takes. See
he slop ParameterOon
page 3-67 for more information about the slop parameter.
For additional information about MeasureJust ified, contact Developer

Technical Support.

SPECIAL CONSIDERATIONS

The MeasureJustified procedure works properly for text in all script systems. For
1-byte complex script systems, MeasureJustified calculates the widths of any
ligatures, reversals, and compound characters that would need to be drawn.
Note that text Length is the number of bytes to be drawn, not the number of characters.
Because 2-byte script systems also include characters consisting of only one byte, you
should not simply multiply the number of characters by 2 to determine this value; the
application must determine and specify the correct number of bytes.
Some 1-byte script system fonts may have zero-width characters, which are usually
overlapping diacritical marks that typically follow the base character in memory. In this
case, MeasureJustified measures both the glyph of the base character (the high-order,
low-address byte) and the width of the diacritical mark. The charLoc array includes an
entry for each, but both entries contain the same value.

3-86

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

For 1-byte complex script systems, MeasureJustified calculates the widths of any
ligatures, reversals, compound characters, and character clusters that need to be drawn.
For example, for an Arabic ligature, the entry that corresponds to the trailing edge of each
character that is part of the ligature is the trailing edge of the entire ligature.
The MeasureJustified procedure may move memory; do not call this procedure at
interrupt time.

Laying Out a Line of Text
In addition to the routines that measure text, QuickDraw text provides additional

routines that help you perform the tasks involved in laying out a line of text.

m The GetFormatOrder procedure determines the display order of style runs for a line
of text containing multiple style runs with mixed directions.
m The VisibleLength function eliminates trailing spaces from the last style run
on the line.
m The PortionLine function determines how to distribute the total slop value for
a line among the style runs on that line.

GetFormatOrder
The Get Format Order procedure determines the display order of multiple style runs
with mixed directions.
PROCEDURE

GetFormatOrder

(ordering:

FormatOrderPtr;

firstFormat:
lastFormat:

ordering

Integer;
Integer;

lineRight:

Boolean;

rlDirProc:

Ptr;

dirParam:

Ptr);

Apointer toa format order array. Upon completion of the call, the format
order array contains the numbers identifying the style runs in display
order. This is its type declaration:
TYPE

FormatOrder

=

FormatOrderPtr
firstFormat

ARRAY

=

[0..0]

OF

Integer;

“FormatOrder;

A number greater than or equal to 0 identifying the rst style run in
storage order that is part of the line for which you are calling
Get FormatOrder.

lastFormat

A number greater than or equal to 0 identifying the last style run in
storage order that is part of the line for which you are calling
Get FormatOrder.

QuickDraw Text Reference

3-87

CHAPTER

3

QuickDraw Text

lineRight

A %ag that you set to TRUE if the primary line direction is right-to-left.

rlDirProc

A pointer to an application-supplied function that calculates the correct
direction, given the style run identi er. The Get Format Order procedure
calls the application-de ned r1DirProc function for each identi er from
firstFormat to lastFormat. The interface to this function looks
like this:
FUNCTION

MyR1lDirProc(theFormat:
Integer;
dirParam:
Ptr
}: Boolean;

This function returns TRUE for right-to-left text direction and FALSE for
left-to-right. Given dirParam and a style run identi er, the
application-de ned r1DirProc routine should be able to determine the
style run direction.
theFormat

Anumber identifying the style run and its associated attribute
information in the information block pointed to by dirParam.

dirParam

A pointer to a parameter block that contains the font and script
information for each style run in the text. This parameter block is used by
the application-supplied routine.

DESCRIPTION

The Get Format Order procedure helps you determine how to draw text that contains
multiple style runs with mixed directions. For mixed-directional text, after you determine
where to break the line, you need to call Get Format Order to determine the display
order. When you call Get FormatOrder, you supply a Boolean function, and reference it
using the r1DirProc parameter. This function calculates the direction of each style run
identi ed by number. Do not call Get Format Order if there is only one style run on the
line.
You must index the style runs in storage order. You pass Get Format Order numbers
identifying the rst and last style runs of the line in storage order and the primary line
direction. The Get Format Order procedure returns to you an equivalent sequence in
display order.
If you do not explicitly de ne the primary line direction of the text, base the lineRight
parameter on the value of the SysDirection global variable. (The SysDirection
global variable is set to -1 if the system direction is right to left, and 0 if the system
direction is left to right.)
The ordering parameter points to an array of integers, with (lastFormat firstFormat + 1) entries. The GetFormatOrder procedure Ils an array (the size of
the number of the style runs) with the display order of each style run. On exit, the array
contains a permuted list of the numbers from firstFormat to lastFormat. The rst
entry in the array is the number of the style run to draw rst; this is the leftmost style run
in display order. The last entry in the array is the number of the entry to draw last, the
rightmost style run in display order. For more information about how to use the
Get Format Order procedure, see (Determining the Display Order for Style Runs,O
which begins on page 3-33. For more information about the r1DirProc function, see
OApplication-Supplied RoutineOon page 3-100.

3-88

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

VisibleLength
The VisibleLength function calculates the length in bytes of a given text segment,
excluding trailing white space.
FUNCTION

VisibleLength

(textPtr:

Ptr;

textLength:

textPtr
textLength

LongInt):

LongInt;

A pointer to a text string.
The number of bytes in the text segment.

DESCRIPTION

The VisibleLength function determines how much of a style run to display, without
displaying trailing spaces. You call VisibleLength for the last style run of a line in
memory order. The last style run in memory order of the text constituting the line is not
always the last style run in display order. For a line of unidirectional left-to-right text, the
last style run in memory order is the rightmost style run in display order. For a line of
unidirectional right-to-left text, the last style run in memory order is the leftmost style
run in display order. However, if the text contains mixed directions, the last style run in
memory order may be an interior style run in display order.
The text justi cation routines do not automatically exclude trailing spaces, so you pass
them the value that VisibleLength returns as the length of the last style run in
memory order.
The VisibleLength function behaves differently for various script systems.
m For simple script systems, such as Roman and Cryllic, and for 2-byte script systems,
VisibleLength does not include in the byte count it returns trailing spaces that
occur at the display end of the text segment. For 2-byte script systems,
VisibleLength does not count them, whether they are 1-byte or 2-byte
space characters.
m For 1-byte complex script systems, VisibleLength does not include in the byte
count that it returns spaces whose character direction is the same as the primary line
direction. For 1-byte complex script systems that support bidirectional text, Roman
spaces take on a character direction based on the primary line direction. If the Roman
spaces then fall at the end of the text, VisibleLength does not include them in the

returned byte count.

Advancing the pointer in memory in response to VisibleLength
The purpose of VisibleLength is to trim off white space at the display
end of the line. The VisibleLength function does not eliminate the

white space by removing its character code from memory. Rather, it does
not include white space characters in the count that it returns as the
length of the range of text for which you call it.

QuickDraw Text Reference

3-89

CHAPTER

3

QuickDraw Text

For more information about VisibleLength, see the task description Eliminating
Trailing Spaces (for Justi ed Text)Oon page 3-36.

PortionLine
The PortionLine function determines the correct proportion of extra space to apply to
the speci ed style run ina line of justi ed text.
FUNCTION

PortionLine(textPtr:

Ptr;

textLen:

styleRunPosition:

numer:

Point;

LongInt;
JustStyleCode;

denom:

Point)

textPtr

A pointer to the style run.

textLen

The number of bytes in the text of the style run.

:

Fixed;

styleRunPosition

The position on the line of this style run. The style run can be the only one
on the line, the leftmost on the line, the rightmost on the line, or one

between two other style runs.
numer

A point giving the numerator for the horizontal and vertical

denom

A point giving the denominator for the horizontal and vertical

scaling factors.
scaling factors.

DESCRIPTION

You use PortionLine in formatting a line of justi ed text. It helps you determine how
to distribute the slop for a line among its style runs. When you know the total slop for a
line of text, you need to determine what portion of it to attribute to each style run. To do
this, you call the PortionLine function once for each style run on the line. The

PortionLine function computes the portion of extra space for a style run, taking into

account the font, size, style, and scaling factors of the style run. It returns a number that

represents the portion of the slop to be applied to the style run for which it is called. You
use the value that PortionLine returns to determine the percentage of slop that you
should attribute to a style run.
To determine the percentage of slop to allocate to each style run, you compute what
percentage each portion is of the sum of all portions. To determine the actual slop value
in pixels for each style run, you apply the percentage to the total slop value. The
following steps summarize this process:
1. Call

Port ionLine

for each style run on the line.

2. Add the returned values together.
3. Calculate the percentage of the slop value for each style run using the ratio of the
value returned by PortionLine for that style run and the total of the values returned
for all of the style runs on the line.

3-90

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

4. Calculate the number of pixels to be added to each style run by multiplying the
percentage of the slop for each style run by the total number of pixels.
For more information about the scaling factors, see Othe numer and denom ParametersO

on page 3-68. See (The styleRunPosition ParameterOon page 3-67 for a description of the
styleRunPosition parameter and the values it takes.
Note
Be sure to pass the same values for styleRunPosition and the scaling
factors (numer and denom) to PortionLine that you pass to any of the
other justi cation routines for this style run. @

Determining the Caret Position, and Selecting and Highlighting Text
To mark an insertion point you need to know where to draw the caret. To highlight text,
you need to know the caret positions that begin and end the text range. This section
describes routines that you use to locate a caret position for marking an insertion point or
highlighting text. You can also use the Pixel ToChar function to determine where to
break a line, and the CharToPixel function to
segment.

nd the screen pixel width of a text

m The Pixel ToChar function converts a pixel location associated with a glyph ina
range of text to a byte offset within the style run.
m The CharToPixel function converts a byte offset to a pixel location. The pixel location
is measured from the left edge of the style run.
m The HiliteText procedure returns three pairs of offsets marking the endpoints of
ranges of text to be highlighted.

PixelToChar
The PixelToChar function returns the byte offset of a character in a style run, or part of
a style run, whose onscreen glyph is nearest the place where the user clicked the mouse.
FUNCTION

PixelToChar

(textBuf:
Slop:

Ptr;

Fixed;

textLen:

VAR

leadingEdge:

VAR

widthRemaining:

styleRunPosition:
numer:

Point;

LongInt;

pixelWidth:

Fixed;

Boolean;
Fixed;
JustStyleCode;

denom:

Point):

Integer;

textBuf

A pointer to the start of the text segment.

textLen

The length in bytes of the entire text segment pointed to by text Buf. The
PixelToChar function requires the context of the complete text segment
in order to determine the correct value.

QuickDraw Text Reference

3-91

CHAPTER

3

QuickDraw Text

slop
pixelWidth

leadingEdge

The amount of slop for the text to be drawn. A positive value extends the
text segment; a negative value condenses the text segment.
The screen location of the glyph associated with the character whose byte
offset is to be returned. The screen location is measured in pixels
beginning from the left edge of the text segment for which you
call PixelToChar.
A Boolean Sag that, upon completion of the call, is set to TRUE if the pixel
location is on the leading edge of the glyph, and FALSE if the pixel
location is on the trailing edge of the glyph. The leading edge is the left
side if the direction of the character that the glyph represents is

left-to-right (such as a Roman character), and the right side if the character

direction is right-to-left (such as an Arabic or a Hebrew letter).

widthRemaining

Upon completion of the call, contains 1 if the pixel location (speci ed by
the pixelWidth parameter) falls within the style run (represented by the
textLen bytes starting at text Buf). Otherwise, contains the amount of
pixels by which the input pixel location (pixe1lWidth) extends beyond
the right edge of the text for which you called PixelToChar.

styleRunPosition

The position on the line of this style run. The style run can be the only one
on the line, the leftmost on the line, the rightmost on the line, or one

between two other style runs.
numer

A point giving the numerator for the horizontal and vertical

denom

A point giving the denominator for the horizontal and vertical

scaling factors.
scaling factors.

DESCRIPTION

You can use the information that PixelToChar returns for highlighting, word selection,
and identifying the caret position. The Pixel ToChar function returns a byte offset and a
Boolean value that describes whether the pixel location is on the leading edge or trailing
edge of the glyph where the mouse-down event occurred. When the pixel location falls
on a glyph that corresponds to one or more characters that are part of the text segment,
the Pixel ToChar function uses the direction of the character or characters to determine
which side of the glyph is the leading edge. (A glyph can represent more than one
character, for example, for a ligature. Generally, if a glyph represents more than one
character, all of the characters have the same text direction.)

If the pixel location is on the leading edge, Pixel ToChar returns the byte offset
of the character whose glyph is at the pixel location. (If the glyph represents multiple
characters, it returns the byte offset of the rst of these characters in memory.) If the pixel
location is on the trailing edge, Pixel ToChar returns the byte offset of the rst

3-92

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

character in memory following the character or characters represented by the glyph. If the
pixel location is on the trailing edge of the glyph that corresponds to the last character
in the text segment, Pixel ToChar returns a byte offset equal to the length of the
text segment.

When the pixel location is before the leading edge of the rst glyph in the displayed text
segment, PixelToChar returns a leading edge value of FALSE and the byte offset of the
rst character. When the pixel location is after the trailing edge of the last glyph in the
displayed text segment, PixelToChar returns a leading edge value of TRUE and the
next byte offset in memory, the one after the last character in the text segment. If the
primary line direction is left to right, before means to the left of all of the glyphs for the
characters in the text segment, and after means to the right of all these glyphs. If the
primary line direction is right to left, before and after hold the opposite meanings.
You also use the value of the leadingEdge fag to help determine the value of the

direction parameter to pass to CharToPixel, which you call to get the caret position.
If the leadingEdge fsag is FALSE, you base the value of the direction parameter on
the direction of the character at the byte offset in memory that precedes the one that
PixelToChar returns; if leadingEdge is TRUE, you base the value of the direction

parameter on the direction of the character at the byte offset that Pixel ToChar returns.
If there isn@a character at the byte offset, you base the value of the direction
parameter on the primary line direction as determined by the SysDirection
global variable.
You specify a value for text Len that is equal to the entire visible part of the style run on
a line and includes trailing spaces if and only if they are displayed. They may not be
displayed, for example, for the last style run in memory order that is part of the
current line.
For more information about the scaling factors, see (The numer and denom ParametersO

on page 3-68. See (The styleRunPosition ParameterOon page 3-67 for a description of the
styleRunPosition parameter and the values it takes. See
he slop ParameterOon
page 3-67 for more information about the slop parameter.
Note
Be sure to pass the same values for styleRunPosition and the scaling
factors (numer and denom) to PixelToChar that you pass to any of the
other justi cation routines for this style run. @
You pass PixelToChar a pointer to the byte offset of the character in the text buffer that
begins the text segment or style run containing the character whose glyph is at the pixel
location. If you do not know which style run on the display line contains the character
whose glyph is at the pixel location, you can loop through the style runs until you nd
the one that contains the pixel location. If the style run contains the character,
PixelToChar returns its byte offset. If it doesn@® you can use the widthRemaining
parameter value to help determine which style run contains the glyph at the pixel
location.

QuickDraw Text Reference

3-93

CHAPTER

3

QuickDraw Text

If you pass PixelToChar the pixel width of the display line, you can use the returned
value of widthRemaining to calculate the length of a style run. The widthRemaining
parameter contains the length in pixels from the end of the style run for which you call
PixelToChar to the end of the display line, in this case, if the style run for which you
call it does not include the byte offset whose glyph corresponds to the pixel location. You
subtract the returned widthRemaining value from the screen pixel width of the display
line to get the style run@ length.
To truncate a line of text, you can use Pixel ToChar to nd the byte offset of the
character where the line should be broken. To return the correct byte offset associated
with the pixel location of a mouse-down event when the text belongs to a right-to-left
script system, the Pixel ToChar function reorders the text. If right-to-left text is
reordered when you use PixelToChar to determine where to break a line, it returns the

wrong byte offset. To get the correct result, you must turn off reordering before you call
PixelToChar. Remember to restore reordering after you have determined where to
break the line. See CUsing Scaled TextObeginning on page 3-44 for more information.

SPECIAL CONSIDERATIONS

The PixelToChar function works with text in all script systems, and for text that is
justi ed or not. For contextual script systems, Pixel ToChar takes into account the
widths of any ligatures, reversals, and compound characters that were created when the
text was drawn.
Because 2-byte script systems also include characters consisting of only one byte, you
should not simply multiply the number of characters by 2 to determine this value; you
must determine and specify the correct number of bytes.
The PixelToChar function may move memory; do not call this procedure at
interrupt time.

CharToPixel
The CharToPixel function returns the screen pixel width from the left edge of a text
segment to the glyph of the character whose byte offset you specify.
FUNCTION

CharToPixel

(textBuf:
slop:

Ptr;

Fixed;

direction:

textLen:
offset:

textBuf

3-94

LongInt;

Integer;

styleRunPosition:

numer:

LongInt;

Point;

JustStyleCode;

denom:

Point):

A pointer to the beginning of the text segment.

QuickDraw Text Reference

Integer;

CHAPTER

3

QuickDraw Text

textLen

The length in bytes of the entire text segment pointed to by text Buf. The
CharToPixel function requires the context of the complete text in order
to determine the correct value.

slop

The amount of slop for the text to be drawn. A positive value extends the
text segment; a negative value condenses the text segment.

offset

The offset from text Buf to the character within the text segment whose
display pixel location is to be measured. For 2-byte script systems, if the
character whose position is to be measured is 2 bytes long, this is the offset
of the rst byte.

direction

This parameter speci es whether CharToPixel is to return the caret
position for a character with a direction of left-to-right or right-to-left. A
direction value of hilite indicates that CharToPixel is to use the caret
position for the character direction that matches the primary line direction
as speci ed by the SysDirection global variable.

styleRunPosition

The position on the line of this style run. The style run can be the only one
on the line, the leftmost on the line, the rightmost on the line, or one

between two other style runs.
numer

A point giving the numerator for the horizontal and vertical

denom

A point giving the denominator for the horizontal and vertical

scaling factors.
scaling factors.

DESCRIPTION

You use CharToPixel to nd the onscreen pixel location at which to draw a caret and to
identify the selection points for highlighting. The CharToPixel function returns the
horizontal distance in pixels from the start of the range of text beginning with the byte
offset at text Buf to the glyph corresponding to the character whose byte offset is
speci ed by the offset parameter. The pixel location is relative to the beginning of the
text segment, not the left margin of the display line. To get the actual display line pixel
location of the glyph relative to the left margin, you add the pixel value that
CharToPixel returns to the pixel location at the end of the previous style run (on the
left) in display order. In other words, you need to know the length of the text in pixels on
the display line up to the beginning of the range of text that you call CharToPixel for,
and then you add in the screen pixel width that CharToPixel returns.
You specify a value for text Len that is equal to the entire visible part of the style run on
a line and includes trailing spaces if and only if they are displayed. They may not be
displayed, for example, for the last style run in memory order, which is part of the line.
Do not confuse the

text Len parameter with the offset, which is the byte offset of the

character within the text segment whose pixel location CharToPixel is to return.

If you use CharToPixel to get a caret position to mark the insertion point, you
specify a value of leftCaret or rightCaret for the direction parameter. You
can use the value of the PixelToChar leadingEdge fag to determine the direction
parameter value.

QuickDraw Text Reference

3-95

CHAPTER

3

QuickDraw Text

If the leadingEdge fsag is FALSE, you base the value of the direction parameter on
the direction of the character at the byte offset in memory that precedes the one that
PixelToChar returns; if leadingEdge is TRUE, you base the value of the direction

parameter on the direction of the character at the byte offset that Pixel ToChar returns.
If there isn@a character at the byte offset, you base the value of the direction
parameter on the primary line direction as determined by the SysDirection
global variable.
You can use the following constants to specify a value for direction.
Constant

Value

Meaning

leftCaret

Q

Place caret for left-to-right text direction.

rightCaret

1

Place caret for right-to-left text direction.

hilite

1

Speci es that the caret position should be determined
according to the primary line direction, based on the

value of SysDirection.

For more information about the scaling factors, see (The numer and denom ParametersO

on page 3-68. See (Lhe styleRunPosition ParameterOon page 3-67 for a description of the
styleRunPosition parameter and the values it takes. See
he slop ParameterOon
page 3-67 for more information about the slop parameter.
Note

Be sure to pass the same values for sty leRunPosition and the scaling
factors (numer and denom) to CharToPixel that you pass to any of the
other justi cation routines for this style run. @
For more information about CharToPixel

see (Drawing Carets and HighlightingOon

page 3-47.

SPECIAL CONSIDERATIONS

The CharToPixel function works with text in all script systems. For 1-byte contextual
script systems, CharToPixel calculates the widths of any ligatures, reversals, and
compound characters that need to be drawn.
Note that text Len is the number of bytes to be drawn, not the number of characters.
Because 2-byte script systems also include characters consisting of only one byte, do not
simply multiply the number of characters by 2 to determine this value; you must
determine and specify the correct number of bytes.
The CharToPixel function may move memory; do not call this procedure at
interrupt time.

3-96

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

HiliteText
The HiliteText procedure nds all the characters between two byte offsets in a text
segment whose glyphs are to be highlighted.
PROCEDURE

HiliteText

(textPtr:

Ptr;

textLen,

firstOffset,

VAR

offsets:

secondOffset:

Integer;

OffsetTable) ;

textPtr

A pointer to a buffer that contains the text to be highlighted.

textLen

The length in bytes of the entire text segment pointed to by text Ptr.

firstOffset
secondoffset

offsets

The byte offset from text Ptr tothe

rst character to be highlighted.

The byte offset from text Ptr to the last character to be highlighted.
A table that, upon completion of the call, speci
text to be highlighted.

es the boundaries of the

DESCRIPTION
The HiliteText procedure returns three pairs of byte offsets that mark the onscreen
ranges of text to be highlighted. This is because for bidirectional text, although the
characters are contiguous in memory, their displayed glyphs can include up to three
separate ranges of text.

The HiliteText procedure takes into account the fact that to highlight the complete
range of text whose beginning and ending byte offsets you pass it, it must return byte
offsets that encompass the glyphs of the rst and last characters in the text segment. To
determine the correct offset pairs, HiliteText relies on the primary line direction as
speci ed by the SysDirection global variable.
Before calling HiliteText, you must set up an offset table (of type Of fset Table)
in your application to hold the results. You can consider the offset table a set of
three offset pairs:
TYPE

OffPair

=

RECORD
offFirst:

Integer;

offSecond:

Integer;

END;
OffsetTable

=

ARRAY

[0..2]

of

OffPair;

If the two offsets in any pair are equal, the pair is empty and you can ignore it.
Otherwise the pair identi es a run of characters whose glyphs are to be highlighted.

QuickDraw Text Reference

3-97

CHAPTER

3

QuickDraw Text

SPECIAL CONSIDERATIONS

The offsets that HiliteText returns depend on the primary line direction as de ned by
the SysDirection global variable. If you change the value of SysDirection,
HiliteText returns the offset that is meaningful according to the primary line direction
for ambiguous offsets on the boundary of right-to-left and left-to-right text.
The HiliteText procedure may move memory; do not call this procedure at interrupt
time. For more information, see Highlighting a Text SelectionOon page 3-60.

Low-Level QuickDraw Text Routines
The QuickDraw text routines use two bottleneck routines extensivelyN one to draw text,
and one to measure it. This section describes the StdText procedure that is used to draw
text and the StdTxMeas function that is used to measure text. Although the high-level
QuickDraw text routines provide most of the functionality needed to measure and draw
text under most circumstances, you can call these low-level routines directly when

necessary. However, if you need to call either StdText or StdTxMeas directly, you must
rst check the graphics port grafProc eld to determine whether the bottleneck
routines have been customized, and if so, you must call the customized routine instead of

the standard one. The bottleneck routines are always customized
for printing.

If the grafProcs
eld contains NIL, the standard bottleneck routines have not been
customized. If the grafProcs
eld contains a pointer, the standard bottleneck routines

have been replaced by customized ones. A pointer (of type QDProcsPtr) in the
grafProc eld points toa QDProc record. This record contains elds that point to the
bottleneck routine to be used for a speci c drawing function. If the standard bottleneck
routine has been customized, your application needs to use the customized routine
indicated by the QDProcs record eld.
The QuickDraw standard low-level bottleneck routines work properly for all script
systems. For more information about replacing or customizing the bottleneck routines,
see (Customizing QuickDraw@ Text HandlingOon page 3-62 and the QuickDraw
chapters in Inside Macintosh: Imaging.

StdText
The StdText procedure is the standard low-level routine for drawing text. It draws text
from an arbitrary structure in memory speci ed by text Buf, starting from the rst byte
and continuing for count bytes.
PROCEDURE

3-98

StdText

(count:

Integer;

numer,

denom:

textBuf:

Ptr;

Point) ;

count

The number of bytes to be counted.

textBuf

A pointer to the beginning of the text in memory.

QuickDraw Text Reference

CHAPTER

3

QuickDraw Text

numer

A point giving the numerator for the horizontal and vertical

denom

A point giving the denominator for the horizontal and vertical

scaling factors.
scaling factors.

DESCRIPTION

The StdText procedure is a QuickDraw bottleneck routine that the QuickDraw text
drawing routines use extensively. However, you can call the StdText routine directly to
draw text that is scaled or unscaled. For more information about the scaling factors, see
(The numer and denom ParametersOon page 3-68.

SPECIAL CONSIDERATIONS

The StdText procedure gives the correct results for all script systems. The count
parameter is the number of bytes of the text to be drawn, not characters. When specifying
this value, consider that 2-byte script systems also include characters consisting of only
one byte.

StdTxMeas
The StdTxMeas
FUNCTION

function measures the width of scaled or unscaled text.

StdTxMeas

(byteCount:

Integer;

VAR

numer,

denom:

VAR

info:

textAddr:

Ptr;

Point;

FontInfo):

Integer;

byteCount

The number of bytes to be counted.

textAddr

A pointer to the beginning of the text in memory.

numer

A point giving the numerator for the horizontal and vertical

denom

A point giving the denominator for the horizontal and vertical

scaling factors.
scaling factors.

info

A font information record that describes the current font.

DESCRIPTION

The StdTxMeas function is a QuickDraw bottleneck routine that the QuickDraw

text-measuring routines use extensively. The StdTxMeas function returns the width of
the text stored in memory beginning with the rst character at textAddr and continuing
for byteCount bytes. You can call the StdTxMeas function directly, for example, to
measure text that you want to explicitly scale, but not justify. You can also use
StdTxMeas to get the font metrics for scaled text in order to determine the line height,
instead of using Get Font Info, which doesn@support scaling.

QuickDraw Text Reference

3-99

CHAPTER

3

QuickDraw Text

On input, you need to specify values for numer and denom, even if you are not scaling
the text. You can specify 1,1 scaling factors, in this case, so that no scaling is applied. On
return, numer and denom contain the additional scaling to be applied to the text. For
more information about the input scaling factors, see
(fhe numer and denom
ParametersOon page 3-68.
The StdTxtMeas function returns output scaling factors that you need to apply to the
text to get the right measurement if the Font Manager was not able to fully satisfy the
scaling request. You can use the Toolbox UtilitiesOQ#ixRound and FixRatio functions to
help with this process. For more information, see (Using Scaled TextOon page 3-44.

SPECIAL CONSIDERATIONS

The StdTxMeas routine gives the correct results for all script systems. The byteCount
parameter is the number of bytes of the text to be drawn, not characters. When specifying
this value, consider that 2-byte script systems also include characters consisting of only
one byte.

Application-Supplied Routine
One of the QuickDraw text routines,

Get Format Order, requires an application-supplied

routine, which is described in this section.

MyRI1DirProc
The MyR1DirProc function is a callback routine that you supply for use by the
Get FormatOrder procedure. The MyR1DirProc function is a Boolean function that
calculates, for a style run identi

ed by number, the direction of that style run. Your

routine returns TRUE for right-to-left text direction, FALSE for left-to-right.
MyR1DirProc is pointed to by the r1DirProc parameter of Get FormatOrder.
FUNCTION

MyR1DirProc

(theFormat:
dirParam:

3-100

Integer;
Ptr):

Boolean;

theFormat

Avalue that identi

dirParam

Apointer to an application-de ned parameter block that contains the font
and script information for each style run in the text. The contents of this
parameter block are used to determine the direction of the style run.
Because of the relationship between the font family ID and the script code,
the font family ID can be used to determine the text direction.

QuickDraw Text Reference

es the style run whose direction is needed.

CHAPTER

3

QuickDraw Text

DESCRIPTION

To ll the ordering array (type FormatOrder) for style runs on a line, the
Get Format Order procedure calls MyR1DirProc for each style run numbered from
firstFormat to lastFormat. GetFormatOrder passes MyR1DirProc a number
identifying the style run in storage order, and a pointer to the parameter information
block, dirParam, that contains the font and style information for the style run. Given

dirParam and a style run identi er, the application-de
should be able to determine the style run direction.

ned MyR1DirProc routine

You should store your style run information in a way that makes it convenient for
MyRLDirProc. One obvious way to do this is to declare a record type for style runs that
allows you to save things like font style, font family ID, script number, and so forth. You
then can store these records in an array. When the time comes for Get FormatOrder to
ll the ordering array, MyR1DirProc can consult the style run array for direction
information for each of the numbered style runs in turn.
For more information, see GGetFormatOrderOon page 3-87.

QuickDraw Text Reference

3-101

CHAPTER

3

QuickDraw Text

Summary of QuickDraw Text
Pascal Summary
Constants
CONST

{CharToPixel directions}
leftCaret
=
0;
{Place caret for left block}
rightCaret
=
-1;
{Place caret for right block}
hilite
=
1;
{Direction is SysDirection}
{constants

for

styleRunPosition

parameter

in

PortionLine,

DrawJustified,

{ MeasureJustified, CharToPixel, and
onlyStyleRun
=
0;
{This is the
leftStyleRun
=
1;
{This is the
{ the line. }

PixelToChar}
only style run on the line. }
leftmost of multiple style runs

rightStyleRun

rightmost

=

middleStyleRun

=

2;

3;

{This

is

the

of

multiple

TYPE

{Type

declaration
=

for

GetFontInfo

RECORD

ascent:

Integer;

descent:

Integer;

widMax:

Integer;

leading:

Integer;

END;

3-102

runs

{
on the line. }
{There are multiple style runs on the line
{
and this one ig interior; neither }
leftmost nor rightmost. }
{

Data Types

FontInfo

style

Summary of QuickDraw Text

info

VAR

parameter}

on

}

}

}

}

CHAPTER

3

QuickDraw Text

{GetFormatOrder
FormatOrder

ordering

array}

ARRAY

[0..0]

FormatOrderPtr

=

“FormatOrder;

FormatStatus

=

Integer;

{Type

=

declaration

StyleItem

=

Style

for

OF

Integer;

TextFace

face

parameter}

(bold,italic,underline,
outline, shadow, condense, extend)

SET

OF

;

StyleItem;

Routines

Setting Text Characteristics
PROCEDURE

TextFont

( font:

Integer) ;

PROCEDURE

TextFace

( face:

Style);

PROCEDURE

TextMode

( mode:

Integer) ;

PROCEDURE

TextSize

(size:

Integer) ;

PROCEDURE

SpaceExtra

( extra:

Fixed);

PROCEDURE

CharExtra

(extra:

Fixed) ;

PROCEDURE

GetFontiInfo

( VAR

info:

FontInfo) ;

Drawing Text
PROCEDURE

DrawChar

( ch:

CHAR) ;

PROCEDURE

DrawString

( Ss:

Str255) ;

PROCEDURE

DrawText

(textBuf:

Ptr;

firstByte,

PROCEDURE

DrawJustified

( textPtr:

Ptr;

textLength:

styleRunPosition:
numer:

Point;

byteCount:

Integer) ;

LongInt;slop:

Fixed;

JustStyleCode;

denom:

Point);

Measuring Text
FUNCTION

CharWidth

(ch:

CHAR):

FUNCTION

StringWidth

(s:

Str255)

FUNCTION

TextWidth

(textBuf:

Integer;

:
Ptr;

firstByte,
PROCEDURE

MeasureText

(count:

PROCEDURE

MeasureJustified

(textPtr:
slop:

Integer;

byteCount:

Integer;
Ptr;

Fixed;

textAddr,
textLength:

charLocs:

styleRunPosition:
numer:

Summary of QuickDraw Text

Point;

Integer):

Integer;

charLocs:

Ptr);

LongInt;

Ptr;

JustStyleCode;

denom:

Point);

3-103

CHAPTER

3

QuickDraw Text

Laying Out a Line of Text
PROCEDURE

GetFormatOrder

(ordering:

FormatOrderPtr;

lastFormat:

Integer;

rlDirProc:

lineRight:

Ptr;dirParam:

VisibleLength

(textPtr:

Ptr;

textLength:

FUNCTION

PortionLine

(textPtr:

Ptr;

textLen:

numer:

Point;

Integer;

Boolean;

Ptr);

FUNCTION

styleRunPosition:

firstFormat:

LongInt):

LongInt;

LongInt;

JustStyleCode;

denom:

Point):

Fixed;

Determining the Caret Position, and Selecting and Highlighting Text
FUNCTION

PixelToChar

(textBuf:
Slop:

Ptr;

Fixed;

textLen:

VAR

leadingEdge:

VAR

widthRemaining:

FUNCTION

CharToPixel

denom:

(textBuf:
slop:

direction:

JustStyleCode;

PROCEDURE

HiliteText

textLen:

JustStyleCode;

denom:

Point):

Ptr;textLength,

secondOffset:

VAR

LongInt;
LongInt;

Integer;

Point;

(textPtr:

Integer;

offset:

styleRunPosition:

numer:

Fixed;

Point):

Ptr;

Fixed;

Fixed;

Boolean;

styleRunPosition:

numer,

LongInt;

pixelWidth:

offsets:

Integer;

firstOffset,

Integer;

OffsetTable) ;

Low-Level QuickDraw Text Routines
PROCEDURE
FUNCTION

StdText
StdTxMeas

(count:

Integer;

numer,

denom:

textAddr:

Ptr;

Point) ;

(byteCount:

Integer;

VAR

numer,

denom:

textAddr:

VAR

info:

FontInfo):

Integer;

(theFormat:

Integer;

dirParam:

Ptr;

Point;

Application-Supplied Routine
FUNCTION

3-104

MyR1DirProc

Summary of QuickDraw Text

Ptr)

Boolean;

CHAPTER

3

QuickDraw Text

C Summary
Constants
enum {
/*CharToPixel

directions*/

leftCaret

=

QO,

/*Place

caret

for

left

rightCaret

=

-1,

/*Place

caret

for

right

hilite

=

1,

/*Direction

/*constants

for

is

styleRunPosition

/*DrawJustified,

block*/

SysDirection*/

parameter

MeasureJustified,

block*/

in

PortionLine,*/

CharToPixel,

onlyStyleRun

=

0,

/*This

is

the

only

leftStyleRun

=

1,

/*This

is

the

leftmost

/*runs

on

the

line.*/

rightStyleRun

=

2,

/*This

is

the

rightmost

middleStyleRun

=

3,

/*

on

the

and

style

PixelToChar*/

run

of

on

the

multiple

of

multiple

line.*/
style

*/

style

runs

*/

line.*/

/*There

are

multiple

style

/*

and

this

one

is

/*

leftmost

nor

rightmost.*/

info

VAR

interior:

runs

on

neither

the

line

*/

*/

Types
TYPE

/*Type

declaration

struct

FontInfo

for

GetFontInfo

parameter®*/

{

short

ascent;

short

descent;

short

widMax;

short

leading;

hi
typedef

struct

FontInfo

/*GetFormatOrder

ordering

typedef

short

typedef

FormatOrder

typedef

short

/*Type

FontInfo;

array*/

FormatOrder
[1];
*FormatOrderPtr;

FormatStatus;

declaration

for

TextFace

face

parameter*/

??StyleItem

=

(bold,italic,underline,
outline, shadow, condense, extend)

Style

=

SET

OF

;

StylelItem;??

Summary of QuickDraw Text

3-105

CHAPTER

3

QuickDraw Text

Routines

Setting Text Characteristics
pascal

void

TextFont

( short

font)

) ;

pascal

void

TextFace

( short

face)

) ;

pascal

void

TextMode

( short

mode)

) ;

pascal

void

TextSize

(short

size

)

pascal

void

SpaceExtra

( extra:

pascal

void

CharExtra

( Fixed

pascal

void

GetFontInfo

( FontInfo

f

Fixed);
extra);
*info);

Drawing Text
pascal

void

DrawChar

(short

pascal

void

DrawString

(ConstStr255Param

pascal

void

DrawText

(const

void

short

byteCount) ;

pascal

void

DrawJustified

(Ptr

ch) ;

*textBuf,

textPtr,

long

JustStyleCode
Point

numer,

ch) ;

s);
short

firstByte,

textLength,

Fixed

slop,

styleRunPosition,
Point

denom) ;

Measuring Text
pascal

short

CharWidth

(short

pascal

short

StringWidth

(ConstStr255Param

pascal

short

TextWidth

(const

void

short

byteCount) ;

pascal
pascal

void

MeasureText

void

s);

*textBuf,

(short

count,

void

*charLocs) ;

const

short
void

firstByte,

*textAddr,

MeasureJustified
(Ptr

textPtr,

Ptr

charLocs,

Point

numer,

long

textLength,

JustStyleCode
Point

Fixed

slop,

styleRunPosition,

denom) ;

Laying Out a Line of Text
pascal

void

GetFormatOrder

(FormatOrderPtr
short

ordering,

firstFormat,

Boolean
Ptr

rlDirProc,

Ptr

pascal

long

VisibleLength

(Ptr

textPtr,long

pascal

Fixed

PortionLine

(Ptr

textPtr,

long

styleRunPosition,

3-106

Summary of QuickDraw Text

short

lastFormat,

lineRight,
dirParam) ;

textLen) ;
textLen,
Point

JustStyleCode

numer,

Point

denom) ;

CHAPTER

3

QuickDraw Text

Determining the Caret Position, and Selecting and Highlighting Text
pascal

pascal

short

PixelToChar

short

CharToPixel

(Ptr

textBuf,

long

textLen,

Fixed

Fixed

pixelWidth,

Boolean

*leadingEdge,

Fixed

*widthRemaining,

pascal

void

HiliteText

JustStyleCode

styleRunPosition,

Point

(Ptr

textBuf,

long

textLen,

long

offset,

Short

(Ptr

textPtr,

Short

Point

short

Point

Fixed

denom) ;

slop,

JustStyleCode

numer,

Point

denom) ;

textLength,

firstOffset,

OffsetTable

numer,

direction,

styleRunPosition,

slop,

short

secondoffset,

offsets);

Low-Level QuickDraw Text Routines
pascal
pascal

void

StdText

short

StdTxMeas

(short

count,

const

void

Point

numer,

Point

denom) ;

(short

byteCount,

Point

*numer,

(short

theFormat,
Ptr

const

Point

*textAddr,
void

*denom,

*textAddr,
FontInfo

*info);

Application-Supplied Routine
pascal

Boolean

MyR1DirProc

dirParam) ;

Assembly-Language Summary
Trap Macros
Trap Macro Names
Pascal name

Trap macro name

DrawJustified

_DrawJustified

MeasureJustified

_MeasureJustified

Get FormatOrder

_GetFormatOrder

VisibleLength

_VisibleLength

PortionLine

_PortionLine

CharToPixel

_CharToPixel

Pixel ToChar

_PixelToChar

HiliteText

_HiliteText

Summary of QuickDraw Text

3-107

CHAPTER

3

QuickDraw Text

Trap Macros With Trap Words
Trap macro name

Trap word

_MeasureText

$A837

_StdText

$A882

_DrawChar

$A883

_DrawString

$A884

_DrawText

$A885

_TextWidth

$A886

_TextFont

$A887

_TextFace

$A888

_TextMode

$A889

_TextSize

$A88A

_GetFontInfo

$A88B

_StringWidth

$A88C

_CharWidth

$A88D

_SpaceExtra

$A88E

_StdTxMeas

$A8ED

_CharExtra

$AA23

Global Variables
HiliteMode
SysDirection
thePort

3-108

Flag used for color highlighting
| System direction; the primary line direction and alignment for text
The currently active graphics port

Summary of QuickDraw Text

CHAPTER 4

Font Manager

Contents
About Fonts

4-6

Characters, Character Codes, and Glyphs

4-6

Kinds of Fonts
4-7
Identifying Fonts
4-8
Font Measurements
4-8
About Font Resources
4-12
Font Resource Types
4-13
A Brief History of Font Resource Use
4-13
Font Family IDs
4-14
Restrictions on the Use of "FONT" Resources
4-15
Font Resource Tables
4-16
About the Font Manager
4-16
How QuickDraw Requests a Font
4-16
How the Font Manager Responds to a Font Request
4-17
How the Font Manager Scales Fonts
4-19
The Scaling Process for a Bitmapped Font
4-22
The Scaling Process for an Outline Font
= 4-23
How the Font Manager Calculates Glyph Widths
= 4-23
Synthetic Fonts
= 4-25
How the Font Manager Renders Outline Fonts
4-25
Using the Font Manager
= 4-31
Adding Font Sizes and Names totheMenu = 4-32
Storing a Font Name in a Document
4-33
Getting Font Measurement Information
4-34
Favoring Outline or Bitmapped Fonts
4-35
Preserving the Shapes of Glyphs = 4-35
Using Width Tables
4-36
Getting the System or Application FontID
4-38
Using Fractional Glyph Widths and Font Scaling
4-38

Contents

4-1

CHAPTER

4

Font Manager Reference
Data Structures

4-39

The Font Input Record
The Font Output Record
The
The
The
The

4-39
4-40
4-4]

Global Width Table
4-43
Font Record
4-46
Font Family Record
4-47
Font Association Table Record

4-47

The Family Glyph-Width Table Record
The Style-Mapping Table Record
4-49
The Font Family Kerning Table Record
Routines
4-50

4-48
4-49

Initializing the Font Manager
— 4-50
Getting Font Information
4-51
Using the Current, System, and Application Fonts
Getting the Characteristics of aFont
4-54
Enabling Fractional Glyph Widths

4-58

Disabling Font Scaling
4-59
Favoring Outline Fonts Over Bitmapped Fonts
Scaling Outline Fonts
= 4-62
Accessing Information About a Font
4-64
Handling Fontsin Memory = 4-65
The Bitmapped Font (NFNT") Resource
4-66
The Font Type Element
4-70
The Offset to the Width/Offset Table
The Outline Font ('sfnt') Resource
4-72
The Font Directory
4-74

The Character-Code Mapping Table
The
The
The
The
The
The
The
The
The
The

Control-Value Table
4-77
Font Program Table
4-77
Glyph Data Table
4-77
Horizontal Device Metrics Table
Font Header Table
4-79
Horizontal Header Table
4-83
Horizontal Metrics Table
4-83
Kerning Table
4-84
Location Table
4-84
Maximum Pro le Table
4-84

4-7]

4-76

4-78

The Font Naming Table
4-85
The PostScript Table
4-89
The Preprogram Table

4-89

The Font Family ("FOND") Resource
The Font StyleCode
4-94
The
The
The
The

Contents

= 4-53

— 4-90

Font Association Table
4-95
Offset Table
4-96
Bounding-Box Table
4-97
Family Glyph-Width Table
4-98

4-60

CHAPTER

4

The Style-Mapping Table
4-99
The Font Family Kerning Table
4-106
Summary of the Font Manager
4-108
PascalSummary
4-108
Constants
4-108
Data Types
4-108
Routines
4-112
CSummary
4113
Constants
4-113
Data Types
4-114
Routines
4-118
Assembly-Language Summary
4-119
Trap Macros
4-119
Global Variables
4-120

Contents

4-3

CHAPTER

4

Font Manager

The Font Manager is a collection of routines and data structures that you can use to
manage the fonts your application uses to display and print text. The Font Manager takes
care of reading font data from font resources and creating the bitmap images that
QuickDraw uses to display text.
This chapter describes how your application can use the Font Manager to nd speci c
fonts and to get font display information, such as the size of the letters, the amount of
space between letters, and how sizing and spacing change if the user decides to apply a
style such as bold or italic. It also describes how the Font Manager keeps track of fonts
and font families.
You need to read this chapter if you are designing a font or if your application uses
different font families or allows the user to choose from a variety of fonts. Two types
of fonts can be used on the Macintosh computer: bitmapped fonts and TrueType outline
fonts. Your application should be able to handle both types. The information in this
chapter about outline fonts applies only to TrueType fonts on the Macintosh, and not
to other kinds of outline fonts or to TrueType fonts on any other platform.
Almost half of the information in this chapter describes the tables that make up the
resources that are used to de ne fonts on the Macintosh. Unless you are writing an
application, such as a font editor, that needs access to these details, you can skip over
most of the material in the
he Bitmapped Font ('NFNT’) Resource,OCLhe Outline Font
(‘sfnt') Resource,Oand (rhe Font Family (‘FOND"') ResourceOsections of the Reference

portion of the chapter.

Before reading this chapter, read the chapter Ontroduction to Text on the MacintoshOin
this book. General font-related information and programming suggestions are found in
the discussion of font handling in that chapter. You should also be familiar with the
information in the chapter GQQuickDraw TextOin this book. If you are writing a font editor
for TrueType fonts, you also need to read the TrueType Font Format Specification, available
from APDA.
This chapter begins with an overview of the terminology used throughout
Inside Macintosh to describe fonts and basic Font Manager concepts, including
m characters, character codes, and glyphs
m bitmapped and outline fonts
m

font families, font names, and font IDs

m system and application font usage
m

font measurements such as left-side bearing, advance width, base line, leading,
and kerning

CHAPTER

4

Font Manager

The chapter then describes
m how font resources are used to store fonts
m how the Font Manager

nds the information your application or QuickDraw requests

m how the Font Manager and QuickDraw work together to create or alter glyph bitmaps
for displaying and printing
m how to use the Font Manager routines to manipulate information about fonts
m the data structures and font resources used by the Font Manager

About Fonts
This section describes the terminology used throughout this chapter to refer to the
individual elements of a font, different types of fonts, and the different functions a font
can have. Even if you are already familiar with the basic terminology of fonts and
typography, you need to know the speci c Font Manager concepts described in this
section in order to understand the functions of all the Font Manager resources, data
structures, and routines.

Characters, Character Codes, and Glyphs
The smallest element in any character set is a character, which is a symbol that represents
the concept of, for example, a lowercase ChO the number C2O or the arithmetic operator

+O You do not ever see a character on a display device. What you actually see ona
display device is a glyph, the visual representation of the character. One glyph can

represent one character, such as a lowercase ChO more than one character, such as the

ligature, which is a single glyph that could represent two characters; or a nonprinting
character, such as the space character.

O O

When you want to print or display text, you generally refer to characters rather than
glyphs. The Font Manager identi es an individual character by a character code and
provides the glyph for that character to QuickDraw. Character codes for most character
sets are single byte values between $00 and $FF; however, the character codes for some

large character sets, such as the Japanese character set, are two bytes long. A font
designer must supply a missing-character glyphN usually an empty rectangle (11 )N for
characters that are not included in the font. QuickDraw displays this glyph whenever the
user presses a key for a character that is not in the font. The Font Manager does not use
the missing-character glyph for nonprinting characters, such as the space character, that
are included in the 'FONT', bitmapped font, and outline font resources.

4-6

About Fonts

CHAPTER

4

Font Manager

Although most fonts assign the same glyphs to character code values $00 to $7F, there are
differences in which glyphs are assigned to the remaining character codes. For example,
the glyph assigned to byte value $FO (@) in the Apple Standard Roman character set is
not typically included in a font de ned for anon-Apple software system. And different
regions of the world require different glyphs for their typography, which makes it
impossible for any one standard to be complete.
The character-encoding scheme was developed to manage the assignment of different
glyphs to character codes in different fonts. It names each character and then maps that
name into a character code in each font. PostScript fonts that use an encoding scheme
that differs from the standard Apple encoding scheme can specify their glyph
assignments in the encoding table of the font family resource, which is described in the
section
he Style-Mapping Table,Obeginning on page 4-99. This table contains a
collection of assignments of glyph names to character codes. For example, the PostScript
name of the character O-Ois ChtildeQ a font designer can specify in the encoding table
that this character is assigned to character code $B9.
The Font Manager uses two types of glyphs: bitmapped glyphs and glyphs from outline
fonts. A bitmapped glyph is a bitmapN a collection of bits arranged in rows and
columnsN designed at a xed point size for a particular display device, such as a monitor
or a printer. For example, after deciding that a glyph for a screen font should
be so many pixels tall and so many pixels wide, a font designer carefully chooses the
individual pixels that constitute the bitmapped glyph. A pixel is the smallest dot
the screen can display. The font stores the bitmapped glyph as a picture for the
display device.
A glyph from an outline font is a model of how a glyph should look. A font designer uses
lines and curves rather than pixels to draw the glyph. The outline, a mathematical
description of a glyph from an outline font, has no designated point size or display
device characteristic (such as the size of a pixel) attached to it. The Font Manager uses the
outline as a pattern to create bitmaps at any size for any display device.

Kinds of Fonts
Each glyph has some characteristics that distinguish it from other glyphs that represent
the same character: for example, the shape of the oval, the design of the stem, or whether

or not the glyph has a serif. If all the glyphs for a particular character set share certain
characteristics, they form a typeface, which is a distinctly designed collection of glyphs.
Each typeface has its own name, such as New York, Geneva, or Symbol. The same

typeface can be used with different hardware, such as typesetting machines, monitors, or
laser printers.
A style is a speci c variation in the appearance of a glyph that can be applied
consistently to all the glyphs in a typeface. Styles available on the Macintosh computer
include plain, bold, italic, underline, outline, shadow, condensed, and extended.

QuickDraw can add styles such as bold or italic to bitmaps, or a font designer can design
a font ina speci c style (for instance, Courier Bold).

About Fonts

4-7

CHAPTER

4

Font Manager

A font refers to a complete set of glyphs in a speci _c typeface and styleN and, in the case
of bitmapped fonts, a speci c size. Bitmapped fonts are fonts of the bitmapped font
('NFNT') resource type or 'FONT' resource type that provide an individual bitmap for
each glyph in each size and style. Courier plain 10-point, Courier bold 10-point, and
Courier plain 12-point, for example, are considered three different fonts. If the user
requests a font that is not available in a particular size, QuickDraw can alter a bitmapped
font at a different size to create the required glyphs. However, this generated bitmap
often appears to be irregular in some way.
Outline fonts are fonts of the outline font ('sfnt') resource type that consist of glyphs
in a particular typeface and style with no size restriction. TrueType outline fonts are
outline fonts that use the Apple TrueType format. The Font Manager can generate
thousands of point sizes from the same TrueType outline font: a single outline Courier
font can produce Courier 10-point, Courier 12-point, and Courier 200-point.

Identifying Fonts
When multiple fonts of the same typeface are present in system software, the Font
Manager groups them into font families of the font family (' FOND ') resource type. Each
font in a font family can be bitmapped or outline. Bitmapped fonts in the same family can
be different styles or sizes. For example, an outline plain font for Geneva and two
bitmapped fonts for Geneva plain 12-point and Geneva italic 12-point might make
up one font family named Geneva, to which a user could subsequently add other sizes
or styles.
A font has a font name, which is stored as a string such as GGenevaOor CNew YorkO The
font name is usually the same name as the typeface from which it was derived. If a font is
not in plain style, its style becomes part of the font name and distinguishes it from the
plain style of that font: for example, (PalatinoOand (Palatino BoldO
A font family ID is the resource ID for a font family. Because there are so many font
families available for the Macintosh, many families have the same font ID. Therefore, to
avoid confusion, when your application stores font references in a document, it should
refer to fonts by name and not by number.

Font Measurements
Font designers use speci c terms for the measurements of different parts of a glyph,
whether outline or bitmapped. Figure 4-1 shows the terms used for the most frequently

used measurements.

4-8

About Fonts

CHAPTER

4

Font Manager

Figure 4-1

Terms for font measurements

Ascent line —

Bounding box ——

Glyph origin

HK

Left-side bearing

Base line

=

Descent line ——
|
Advance width

Note

The terms given here are based on the characteristics of the Roman script
system, which is associated with most European languages and uses
fonts that are meant to be read from left to right. Some other script
systems use different de nitions for some of these terms. However,
QuickDraw always draws glyphs using the glyph origin and advance
width measurement, even if the font is read from right to left.
As shown in Figure 4-1, the bounding box of a glyph is the smallest rectangle that
entirely encloses the pixels of the bitmap. The glyph origin is where QuickDraw begins
drawing the glyph. Notice that there is some white space between the glyph origin and
the visible beginning of the glyph: this is the left-side bearing of the glyph. The left-side
bearing value can be negative, which lessens the spacing between adjacent characters.
The advance width is the full horizontal measurement of the glyph as measured from its
glyph origin to the glyph origin of the next glyph on the line, including the white space
on both sides.

About Fonts

4-9

CHAPTER

4

Font Manager

If all of the glyph images in the font were superimposed using a common glyph origin,

the smallest rectangle that would enclose the resulting image is the font rectangle.

The glyphs of a fixed-width font all have the same advance width. Fixed-width fonts are
also known as monospaced fonts. In Courier,a

xed-width font, the uppercase (MOhas

the same width as the lowercase GO In a proportional font, different glyphs may have
different widths, so the uppercase OMOis wider than the lowercase GO For example, the
proportionally spaced text QMaGeOhas a different appearance from the xed-width
version of the same string Q.MaGeO
Most glyphs in a font appear to sit on the base line, an imaginary horizontal line.
The ascent line is an imaginary horizontal line chosen by the font@ designer that
corresponds approximately with the tops of the uppercase letters in the font, because
these are generally the tallest commonly used glyphs in a font. The ascent line is
the same distance from the base line for all glyphs in the font. The descent line is
an imaginary horizontal line that usually corresponds with the bottoms of descenders
(the tails on glyphs like Q@Oor @O, and it@ the same distance from the base line
for every glyph in the font. The ascent and descent lines are part of the font designer@
recommendations about line spacing as measured from base line to base line. All of
these lines are horizontal because Roman text is read from left to right, in a straight
horizontal line.
For bitmapped fonts, the ascent line marks the maximum y-value and the descent line
marks the minimum y-value used for the font. The y-value is the location on the vertical
axis of each indicated line: the minimum y-value is the lowest location on the vertical axis
and the maximum y-value is the highest location on the vertical axis. For outline fonts, a
font designer can create individual glyphs that extend above the ascent line or below the
descent line. The integral sign in Figure 4-2, for example, is much taller than the

uppercase CMO In this case, the maximum y-value is more important than the ascent line
for determining the proper line spacing for a line containing both of these glyphs. You
can have the Font Manager reduce such oversized glyphs so that they t between the
ascent and descent lines. See (Preserving the Shapes of Glyphs,Owhich begins on
page 4-35, for details.

4-10

About Fonts

CHAPTER

4

Font Manager

Figure 4-2

The ascent line and maximum y-value

Maximum y-value

Ascent line

Base line

9 ———-j——-—

— — — — —— ——

— ~~~

— — — ————

—

_

Font size (or point size) indicates the size of a font@ glyphs as measured from the base
line of one line of text to the base line of the next line of single-spaced text. In the United
States, font size is traditionally measured in points, and there are 72.27 traditional points

per inch. However, QuickDraw and the PostScript language de ne 1 point to be '§ of an
inch, so there are exactly 72 points per inch on the Macintosh.
Previously, the Font Manager required fonts to be less than or equal to 127 points in size,
but this restriction no longer applies to any type of font. All bitmaps must ton the
QuickDraw coordinate plane; on a 72-dpi display device, fonts have an upper size limit
of 32,767 points.

There is no strict typographical standard for de ning a point size: it is often, but not
always, the sum of the ascent, descent, and leading values for a font. Point size is used by

a font designer to indicate the size of a font relative to other fonts in the same family.
Glyphs from fonts with the same point size are not necessarily of the same height. This
means that a 12-point font can exceed the measurement of 12 points from the base line of
one line of text to the base line of the next.
Note
The Font Manager does not force fonts that are speci ed as having a
certain point size to be of that size. This can have an impact when laying
out text in your application, so you need to take it into account. You may
need to determine the actual height of the text that you are displaying by
using the QuickDraw routine MeasureText (which is described in the
chapter GQuickDraw TextOin this book) rather than relying on the point
size of the font.

About Fonts

4-11

CHAPTER

4

Font Manager

Leading (pronounced CLED-ingQ is the amount of blank vertical space between the
descent line of one line of text drawn using a font and the ascent line of the next line
of single-spaced text drawn in the same font. The Font Manager returns the font@
suggested leading, which is in pixels, in the FontMet rics procedure for both outline
and bitmapped fonts. QuickDraw returns similar information in the Get Font Info
procedure. Although the designer speci es a recommended leading value for each font,
you can always change that value if you need more or less space between the lines of text
in your application. The line spacing for a font can be calculated by adding
the value of the leading to the distance from the ascent line to the descent line of a single
line of text.
Although each glyph has a speci c advance width and left-side bearing measurement
assigned to it, you can change the amount of white space that appears between glyphs.
Kerning is the process of drawing part of a glyph so that it overlaps another glyph. The
period in the top portion of Figure 4-3 stands apart from the uppercase OYQ In the
bottom portion of the gure, the word and the period have been kerned: the period has
been moved under the right arm of the O/Oand the glyphs of the word are closer.
Kerning dataN the distances by which pairs of speci ed glyphs should be moved closer
togetherN is stored in the kerning tables of the different font resources. The kerning table
of the outline font resource is described on page 4-84. The kerning table of the font family
resource is described on page 4-106.
Figure 4-3

Unkerned text (top) and kerned text (bottom)

AWAY.
AWAY.
About Font Resources
This section provides a general description of the resources used for font management on
the Macintosh, including

m an overview of each of the font resource types
m a brief history of the evolution of font resource use on the Macintosh
m

4-12

information about font family IDs

About Font Resources

CHAPTER

4

Font Manager

Font Resource Types
Although the display of different fonts has always been an important aspect of using the
Macintosh computer, the need for increased font availability and Sexibility has expanded
signi cantly since the introduction of the Macintosh. The built-in font management
software has increased in power and complexity to accommodate the expanded needs of
users. There used to be only one font resource type, of type 'FONT', but it is now out of
date. There are now three additional font resource types.
m= Bitmapped font ('NFNT') resources describe bitmapped fonts. These bitmapped font
resources have an identical structure to the earlier 'FONT' resources, which they have
replaced, but the bitmapped font resources add a more fexible font ID number
scheme. This chapter assumes that you are working with bitmapped font resources
rather than 'FONT' resources. The elds of the bitmapped font resource are described
in the section (he Bitmapped Font ('NFNT') Resource,Owhich begins on page 4-66.
mw Outline font ('sfnt') resources describe outline fonts. The

elds and tables of the

outline font resource are described in the section Othe Outline Font (‘sfnt') Resource,O
which begins on page 4-72.

m Font family (' FOND') resources describe font families, including information such as
which fonts are included in the family and the recommended width for a glyph at a
given point size. The elds and tables of the font family resource are described in the
section (he Font Family (‘FOND’) Resource,Owhich begins on page 4-90.
Each font that you use is represented by either a bitmapped font or outline font resource
(ora

'FONT'

resource, in some cases), and each is part of a font family. A single font

family can contain a mixture of bitmapped and outline fonts. The font association table in
the font family resource refers to the font resources that the family includes.
Handles to font resources, found in data structures such as the global width table and the
FMOutput record, can point to either kind of font.

A Brief History of Font Resource Use
The use of font resources has evolved considerably since the early days of the Macintosh
computer. Knowing how the changes have evolved can help you understand their use
in current software.
The earliest versions of Macintosh system software stored and created all font data in
'FONT' resources. Font families were created by storing a unique family ID in bits 7 14
of the resource ID of each font in the family. To name a font family, a designer included a
'FONT' resource with a point size of zero. This method severely restricted the range of
both family IDs and point sizes.
With the introduction of the 128K ROM, there were two new resource types: the font
family (' FOND ') resource, which stores size-independent information for a font family,

and the bitmapped font ('NFNT') resource, which has the same internal format as
the 'FONT' resource, but can use any resource ID. Each font family resource names the
family and contains a font association table, which consists of a number of individual
font entries. Each entry contains a word for the font style, a word for the font size, and a

About Font Resources

4-13

CHAPTER

4

Font Manager

word for the 'FONT' resource ID or bitmapped font resource ID of the font. This new
scheme expanded the range of both font sizes and font family IDs to allow values from
0 to 32,767.
When TrueType outline font support was added for System 7, a new font resource type
was added: the outline font resource, the internal format of which is substantially

different from that of the bitmapped font resources.

Note
Because of the way that 'FONT' resources were originally constructed, a
'FONT' resource can exist independently of a font family resource. This
is not true of bitmapped font and outline font resources, each of which
must be associated with a font family resource. #

Font Family IDs
Several of the Font Manager routines and data structures make use of a font ID value,
which is actually a font family ID value. The valid values for font family IDs, like the

resource IDs of all script-speci_c resources, are subdivided into ranges for each script
system, with half of the total range allocated for Roman font families and 512 IDs
allocated for each other script system. The ranges for each non-Roman script system are
listed in the appendix Gnternational ResourcesOin this book.
The system software keeps track of two font family IDs. It uses the system font for
drawing items such as system menus and system dialog boxes. The application font is
the font that your application will use for text unless speci ed otherwise by you or the
user. In Roman script systems, the system font is Chicago, the system font size is 12
points, and the application font is Geneva. In other script systems, the system and
application fonts are de ned in the international resources. The Script Manager variables
smScriptSysFond,

smScriptAppFond,

smScriptSysFondSize,

and

smScriptAppFondSsize, which de ne the system and application fonts and font sizes
for each script system, are described in the Script ManagerOchapter in this book.
Font family ID values 0 and 1 are reserved. The system software always maps the system
font to font 0 and the application font to font 1. The Roman font family ID range is itself
subdivided as shown in Table 4-1.
Table 4-1
ID range

Use

2 255

Mostly older font families that use the 'FONT' resource numbering
method. Do not use these IDs.

256 1023

Reserved numbers that should not be used for family IDs. The Font/DA
Mover program uses this range of IDs to resolve font confsicts.

1024

Commercial fonts. This is the range of IDs that all Roman

16383

4-14

Subdivisions of Roman font family IDs

16382

should use.

Reserved. Do not use.

About Font Resources

font families

CHAPTER

4

Font Manager

The Font Manager de nes constants for the system font and the application font, as well
as for several of the older font IDs in the range from 2 to 255. These constants are
presented here; however, you need to use the older font ID constants with caution, since

most of them have become obsolete.
CONST

systemFont

=

applFont

= 1;

newYork

=

i

=

venice

=

london

=

athens

=

sanFran
toronto
cairo

BS
OW
IA

monaco

=
=
=

4;
5;
f

i

8;

11;

9

losAngeles

times

=

12;

20;

helvetica
courier

=
=

symbol
mobile

f

=

21;

22;
23;

=

system

font}

{ the application font}
{ hard-coded New York font ID}
{ hard-coded Geneva font ID}
{ hard-coded Monaco font ID}
{ hard-coded Venice font ID}
{ hard-coded London font ID}
{ hard-coded Athens font ID}
{hard-coded San Francisco font ID}
{ hard-coded Toronto font ID}
{ hard-coded Cairo font ID}
{ hard-coded Los Angeles font ID}
{ hard-coded Times Roman font ID}
{ hard-coded Helvetica font ID}
{ hard-coded Courier font ID}
{ hard-coded Symbol font ID}
{ hard-coded Mobile font ID}

2;
W

geneva

{ the

0;

24;

The Script Manager provides functions that allow you to determine which script a font
belongs to. For more information, see the chapter Script ManagerOin this book.

Restrictions on the Use of ‘FONT' Resources
Since some older applications only work with! FONT' resources, you might need to
create a 'FONT' resource to retain compatibility. If this is necessary, you need to follow
these restrictions on 'FONT' resources that are part of a font family.
m The font name and family name must be identical.
m The font ID and font family ID must be identical.
m The resource ID of the font must equal the number produced by concatenating the font
ID times 128 with the font size. Remember that fonts stored in 'FONT' resources are
restricted to a point size of less than 128 and to a font ID in the range 0 to 255. The
resource ID is computed by the following formula:
resourceID

:=

(font

ID

*

128)

+

font

size;

These restrictions ensure that both the 64K ROM found in older Macintosh computers
and the newer 128K ROM versions of the Font Manager will associate the font family
ID and point size with the proper corresponding 'FONT!' resource ID, whether or not
there is a family resource.

About

Font

Resources

4-15

CHAPTER

4

Font Manager

Font Resource Tables
The Font Manager takes care of the details of how fonts are stored in resources, reading
the resource les when required and building internal representations of the data stored
in them. The Font Manager provides routines to interact with fonts, meeting the
font-manipulation needs of most application developers.
However, if you are developing an application that requires you to work directly with
font resource data, you may need to understand how the font data is stored in resource
les. Each font resource consists of a number of tables, each of which has a speci

c

structure. Some of these tables are described in the section Font Manager ReferenceO
beginning on page 4-39, while others are described in the TrueType Font Format
Specification.

About the Font Manager
QuickDraw draws text to the screen and, sometimes, to a printer. For its purposes,

the glyphs that make up text are simply little images that make up a large, albeit

well-ordered, image. QuickDraw uses size information, such as height and width,
as it might use that information when arranging any graphic image.

The Font Manager, by contrast, keeps track of detailed font information such as the
elyphsCrharacter codes, whether fonts are xed-width or proportional, and which fonts
are related to each other by name.
When QuickDraw needs to draw some text in a particular font, it sends a request for that
font to the Font Manager. The Font Manager nds the font or the closest match to it that
is available, and sends the font back to QuickDraw with some information that

QuickDraw uses for stylistic variations and layout.

Note
Although the terms glyph and character code have different
meanings, QuickDraw routines and data structure elds often use the
word character for both. Review the purpose of the routine or data
structure youGe using before deciding whether it handles character
codes or glyphs. @

How QuickDraw Requests a Font
When your application calls a QuickDraw routine that does anything with text (for
example, DrawText or Text Font), QuickDraw gets information from the Font Manager
about the font speci ed in the current graphics port record and the individual glyphs of
that font. The Font Manager performs any necessary calculations and returns the
requested information to QuickDraw.

4-16

About the Font Manager

CHAPTER

4

Font Manager

QuickDraw makes its request for font information using a font input record (of data type
FMInput), which is described on page 4-40. This record contains the font family ID, the

size, the style, and the scaling factors of the font request.
QuickDraw makes a font request by lling in a font input record and calling the
FMSwapFont function. If your application needs to make a font request in the same way
that QuickDraw does, you can call FMSwapFont. Since responding to a font request can
be a lot of work, FMSwapFont has been optimized to return as quickly as possible if the
request is for the same font as was most recently requested. Building the global width
table, which is described in CHow the Font Manager Calculates Glyph WidthsOon
page 4-23, is one of the more time-consuming tasks in this process, which is why the Font
Manager maintains a cache of up to 12 width tables.
The Font Manager looks for the font family resource of the requested font and from that
determines information about which font it can use to meet the request. If necessary, the
Font Manager calls the Resource Manager to read the font.
For certain types of devices, such as a screen or the ImageWriter printer, the Font
Manager uses the font characterization table from the device driver to determine any
additional information that QuickDraw may need. The font characterization table
contains information about the dots per vertical inch and dots per horizontal inch for that
device, along with information about the different styles that the device can produce.
Non-QuickDraw devices, such as the LaserWriter printer, return an error when the Font

Manager requests their font characterization table.
WARNING

Never assume that the font resource is a bitmapped font resource or
outline font resource. If you need to read information from the resource,
you should rst call the Resource Manager Get ResInfo procedure with
the handle to the resource. The GetResInfo procedure is described in
the Resource Manager chapter in Inside Macintosh: More Macintosh
Toolbox. &

How the Font Manager Responds to a Font Request
The Font Manager returns the needed information to QuickDraw in a font output record
(of data type FMOut put), which is described on page 4-41. This record contains a handle
to the font resource that the FMInput record requested, information on how different
stylistic variations affect the display of the font@ glyphs, and the scaling factors.
When the Font Manager gets a request for a font in a font input record, it attempts to
a font family resource for the requested font family by following these steps:
1. The Font Manager checks the global variable
the last font family resource used.

nd

Last FOND, which contains a handle to

2. If the last font family resource used is not the one requested, the Font Manager checks
its memory cache, in which it keeps the last 12 width tables used.

3. If the font family resource is not in the cache, the Font Manager calls the Resource

Manager GetResource function to get the resource.

About the Font Manager

4-17

CHAPTER

4

Font Manager

If the font family resource is available, the Font Manager looks in the font family resource
for the ID of the appropriate font resource to match the request. If a font
family resource isn®available, the Font Manager follows these steps:
1. The Font Manager looks for a 'FONT'

resource, since such resources can exist without

being associated with a font family resource.

2. Ifitcan®

nda

'FONT'

resource, the Font Manager looks for the application font.

3. If it can® nd the application font, the Font Manager looks for a neighborhood base
font, which is the font with the lowest font ID for that script system. For fonts
numbered below 16384, this is font 0. For fonts above 16384, the Font Manager

looks for the nearest font resource that is a multiple of 512 and less than the
speci ed font value.

4. If itcan®

nda

neighborhood font, the Font Manager gets the system font.

5. Ifit can®

nd the system font, the Font Manager always uses Chicago 12.

When responding to a font request, the Font Manager rst looks for a font family
resource of the speci ed size. It then looks for the stylistic variation that was requested. It
does this by assigning weights to the various styles (for example, a weight of 8 for italic, 4
for bold) and then choosing the font whose style weight most closely matches the weight
of the requested style.
If the Font Manager cannot nd the exact font style that QuickDraw has requested, it
uses the closest font style that it does nd for that font and QuickDraw then applies the
correct style to that font. For example, if an italic version of the requested font cannot be
found, the Font Manager returns the plain version of the font and QuickDraw will slant
the characters as it draws them. The QuickDraw styles are given in the QuickDraw data
type Style, which includes the values bold, italic, underline, outline, shadow,
condense, and extend.

With the additional complication of having both outline and bitmapped fonts available,
this process can sometimes produce results other than those that you expected. The Font
Manager can be set to favor either outline or bitmapped fonts when both are available to
meet a request, as described in CFavoring Outline or Bitmapped FontsOon page 4-35. The
following scenario is one example of how the font that is selected can be a surprise:
1. You have speci ed that bitmapped fonts are to be preferred over outline fonts when
both are available in a speci c size.
2. The system software on which your application is running has the bitmap font Times
12 and the outline fonts Times, Times Italic, and Times Bold.

3. The user requests Times Bold 12.
4. The Font Manager chooses the bitmapped version of Times 12 and QuickDraw
algorithmically smears it to create the bold effect.
There® not much that you can do about such situations except to be aware that telling the
Font Manager to prefer one kind of a font over another has implications beyond what
you might initially expect.

4-18

About the Font Manager

CHAPTER

4

Font Manager

How the Font Manager Scales Fonts
Font scaling is the process of changing a glyph from one size or shape to another. The
Font Manager and QuickDraw can scale bitmapped and outline fonts in three ways:
changing a glyph@ point size, modifying the glyph (but not its point size) for display on
a different device, and altering the shape of the glyph.
For bitmapped fonts, the Font Manager does not actually perform scaling of the glyph
bitmaps. Instead, the Font Manager nds an appropriate font and computes the
horizontal and vertical scaling factors that QuickDraw must apply to scale the bitmaps.
QuickDraw performs all modi cations of bitmapped font glyphs.
The simplest form of scaling occurs when the Font Manager returns scaling factors for
QuickDraw to change a glyph from one point size to another on the same display device.
If the glyph is bitmapped and the requested font size is not available, there are certain
rules the Font Manager follows to create a new bitmapped glyph from an existing one
(see
he Scaling Process for a Bitmapped FontOon page 4-22). If the glyph is from an
outline font, the Font Manager uses the outline for that glyph to create a bitmap.
Figure 4-4 shows how the Font Manager and QuickDraw scale a bitmapped font and an
outline font from 9 points to 40 points for screen display. The sizes of the bitmapped fonts
available to the Font Manager to create all 32 sizes were 9, 10, 12, 14, 18, and 24 points. A

single glyph outline produces a smoother bitmap in all point sizes.
Figure 4-4

A comparison of scaled bitmapped and outline fonts

Bitmapped screen font scaled from 9 points to 40 points

wasdd adddddddddddddddddddddddd
Outline screen font scaled from 9 points to 40 points

sadddddddddddddddd dddddddddddddd
The Font Manager produces better results by scaling glyphs from outline fonts, because it
changes the font@ original outline to the new size or shape, and then makes the bitmap.
Outlines give better results than bitmaps when scaled, because the outlines are intended
for use at all point sizes, whereas the bitmaps are not.

About the Font Manager

4-19

CHAPTER

4

Font Manager

The Font Manager also determines that a glyph must be scaled when moving it from one
device to another device with a different resolution: for instance, from the screen to a

printer. A bitmap that is 72 pixels high on a 72-dpi screen measures one inch, but on a
144-dpi printer it measures a half inch. In order to printa gure the same size as the
original screen bitmap, QuickDraw needs a bitmap twice the size of the original. If there
are no bitmaps available in twice the point size of the bitmap that appears on the screen,
the Font Manager returns the proper scaling factors, and QuickDraw scales the original
bitmap to twice its original size in order to draw it on the printer.
With some QuickDraw calls, your application can also use the Font Manager to explicitly
scale a glyph by stretching or shrinking it, which changes the glyph from a familiar point
size to something a little strangerN for example, a glyph that is 12 points high but as wide
as a whole page of text. Your application tells the Font Manager how to scale a glyph
using font scaling factors, which are represented as proportions or fractions that indicate
how the Font Manager should scale the glyph in the vertical and horizontal directions.
The ratio given by the font scaling factors determines whether the glyph grows or
shrinks: if the ratio is greater than one, the glyph increases in size, and if it is less than
one, the glyph decreases in size. If the font scaling factors are 1-to-1 (1/1) for both
horizontal and vertical scaling, the glyph does not change size.
In some circumstances, the Font Manager

nds a font and returns different scaling factors

to QuickDraw. The scaling factors in a QuickDraw font request tell the Font Manager
how much QuickDraw wants to scale the font, and the scaling factors returned by the
Font Manager tell QuickDraw how much to actually scale the glyphs before drawing
them.

In Figure 4-5, the font scaling factors are 2/1 in the horizontal direction and 1/1 in the

vertical direction. The glyph stays the same height, but grows twice as large in width.
Figure 4-5

4-20

A glyph stretched horizontally

About the Font Manager

CHAPTER

4

Font Manager

In Figure 4-6, the font scaling factors are 2/1 in the vertical direction and 1/1 in

the horizontal direction. The glyph stays the same width, but grows to twice its
original height.

Figure 4-6

A glyph stretched vertically

In Figure 4-7, the font scaling factors are 1/1

in the vertical direction and 1/2 in the

horizontal direction. The glyph stays the same height but retains only half its width.
Figure 4-7

x)

A glyph condensed horizontally

4/2x

If the font scaling factors are 2/1 in both directions and the font is an outline font, then
the Font Manager computes the size of the glyph as twice the speci ed size and
QuickDraw draws the glyph. With bitmapped fonts, QuickDraw rst looks for a bitmap
at twice the size of the original before redrawing the glyph at the new point size.
Many routines use the value of the font scaling factors in order to calculate the best
measurements for text in the current graphics port record. You can nd the current
horizontal and vertical scaling factors in the global variables FScaleHFact and
FScalevFact. The exact value of the font output scaling factors can be found by
multiplying the value of the global width table@ houtput and voutput elds by the
values of the hFactor and vFactor elds, also of the global width table, respectively.
The description of the global width table begins on page 4-43.

About the Font Manager

4-21

CHAPTER

4

Font Manager

The Scaling Process for a Bitmapped Font
Although the Font Manager does not scale the glyph bitmaps of a bitmapped font, it does
compute the scaling factors that QuickDraw uses to perform the scaling. The Font
Manager computes scaling factors other than 1/1 when the exact point size requested is
not available. Font scaling is the default behavior; however, you can disable it, as

described below. When the Font Manager cannot nd the proper bitmapped font that
QuickDraw has requested and font scaling is enabled, it uses the following procedure:
1. The Font Manager looks for a font of the same font family that is twice the size of the
font requested. If it nds that font, the Font Manager computes and returns to
QuickDraw factors to scale it down to the requested size.
2. The Font Manager looks for a font of the same font family that is half the size of the
font requested. If it nds that font, the Font Manager computes and returns to
QuickDraw factors to scale it up to the requested size.
3. The Font Manager looks for a font of the same font family that is the next larger size of
the font requested. If it nds that font, the Font Manager computes and returns to
QuickDraw factors to scale it down to the requested size.
4, The Font Manager looks for a font of the same font family that is the next smaller size
of the font requested. If it nds that font, the Font Manager computes and returns to
QuickDraw factors to scale it up to the requested size.
5. If the Font Manager cannot

nd any size of that font family, it returns the application

font, system font, or neighborhood base font, as described in the section CHow the

Font Manager Responds to a Font RequestObeginning on page 4-17. The Font
Manager computes and returns to QuickDraw the factors to scale that font to the
requested size.

You can disable the scaling of bitmapped fonts in your programs by calling the
SetFScaleDisable procedure. When the Font Manager cannot nd the proper
bitmapped font that QuickDraw has requested and font scaling is disabled, the Font
Manager looks for a different font to substitute instead of scaling. The
Set FScaleDisable procedure is described on page 4-59.
With scaling disabled, the Font Manager looks for a font with characters with the correct
width, which may mean that their height is smaller than the requested size. The Font
Manager returns this font and returns scaling factors of 1/1, so that QuickDraw does not

scale the bitmaps. QuickDraw draws the smaller font, the widths of which produce the
spacing of the requested font. This is faster than font scaling and accurately mirrors the
word spacing and line breaks that the document will have when printed, especially if
fractional character widths are used. Disabling and enabling of font scaling are described
in the section QUsing Fractional Glyph Widths and Font ScalingOon page 4-38.

4-22

About the Font Manager

CHAPTER

4

Font Manager

Note
A font request made with scaling disabled does not necessarily return
the same result as an identical request with scaling enabled. The widths
are sure to be the same only if fractional widths are enabled, the font
does not have a glyph-width table, and the font is a member of a family
record with a family character-width table. Fractional widths and width
tables are discussed in CHow the Font Manager Calculates Glyph
WidthsOon page 4-23.

The Scaling Process for an Outline Font
The Font Manager always scales an outline font in order to produce a bitmapped glyph
in the requested size, regardless of whether font scaling for bitmapped fonts is enabled or
disabled. An outline font is considered to be the model for all possible point sizes, so the
Font Manager is not scaling it from one QealOsize to a QreatedOsize, the way it does
with a bitmapped font; it is drawing the outline in the requested point size, so that it can
then create the bitmapped glyph.

How the Font Manager Calculates Glyph Widths
Integer glyph widths are measurements of a glyph@ width that are in whole pixels.
Fractional glyph widths are measurements that can include fractions of a pixel. For
instance, instead of a glyph measuring exactly 5 pixels across, it may be 5.5 pixels across.
Fractional glyph widths allow the sizes of glyphs as stored by the Font Manager to be
closer in proportion to the original glyphs of the font than integer widths allow.
Fractional widths also make it possible for high-resolution printers to print with
better spacing.
You can enable or disable the use of fractional glyph widths in your application, as
described in QUsing Fractional Glyph Widths and Font ScalingOon page 4-38. Asa
default, fractional widths are disabled to retain compatibility with older applications.
When using fractional glyph widths, the Font Manager stores the locations of
glyphs more accurately than any actual screen can display: since screen glyphs are made
up of whole pixels, QuickDraw cannot draw a glyph that is 5.5 pixels wide. The
placement of glyphs on the screen matches the eventual placement of glyphs on a page
printed by the high-resolution printers more closely, but the spacing between glyphs and
words is uneven as QuickDraw rounds off the fractional parts. The extent of the
distortion that is visible on the screen depends on the font point size relative to the
resolution of the screen.

About the Font Manager

4-23

CHAPTER

4

Font Manager

The Font Manager communicates fractional glyph widths to QuickDraw through the
global width table, which is a data structure that is allocated in the system heap. The
Font Manager lls in this table by accessing data from one of several places:
m Integer glyph widths are taken from the width/offset table of the bitmapped font
resource and the horizontal device metrics table of the outline font resource.

m Fractional glyph widths are taken from the glyph-width table in the bitmapped font
resource, the horizontal metrics table in the outline font resource, and the family

glyph-width table in the font family resource.

The Font Manager looks for width data in the following sequence:
1. For a bitmapped font, it rst looks for a font glyph-width table in the font record,
which is the record used to represent in memory the data in a bitmapped font
resource. For an outline font, it

rst looks for data in the horizontal metrics table. The

width table for bitmapped fonts is described in the section (he Bitmapped Font
(‘NENT’) Resource,Owhich begins on page 4-66. The width table for outline fonts is
described in
he Horizontal Device Metrics TableOon page 4-78.
2. If it doesn@® nd this table, the Font Manager looks in the font family record for
a family glyph-width table. The font family record is used to represent in memory
the data in a font family resource. This is described in
Phe Family Glyph-Width
TableOon page 4-98.
3. If the Font Manager doesn@® nd a family glyph-width table, it derives the
global character widths from the integer widths contained in the width/ offset table
in the bitmapped font record, as described in (fhe Bitmapped Font (‘NFNT’)
ResourceOon page 4-66.
Note
If you need to use different widths than those returned by the global
width table, you should change the values in the global width table only.
You should never change any values in the font resources themselves. @

To use fractional glyph widths effectively, your application must get accurate widths
when laying out text. Your application should obtain glyph widths either from the
QuickDraw procedure MeasureText or by looking in the global width table. The
MeasureText procedure is described in the chapter GQQuickDraw TextOin this book. You
can get a handle to the global width table by calling the FontMet rics procedure, which
is described on page 4-54.

4-24

About the Font Manager

CHAPTER

4

Font Manager

Synthetic Fonts
You may want your application to handle fonts that have a font depth greater than the
normal 1-bit depth. (The font depth is the number of bits per pixel; it is speci ed in bits 2
and 3 of the fontType eld of the bitmapped font resource, which is described
beginning on page 4-70. The Font Manager supports font depths of 1, 2, 4, and 8 bits.) An
advantage of using fonts with a larger font depth is that the Font Manager draws
bitmapped fonts to the screen considerably faster if the font depth matches the screen
depth speci ed by the user in the Monitors control panel.
The Font Manager can create a synthetic font from a 'FONT' or bitmapped font resource
(but not from an outline font resource) by expanding the 1-bit font into a
font that matches the current screen depth. The Font Manager creates and maintains
synthetic fonts internally, for performance reasons. However, if there is not enough
memory to support synthetic fonts, the Font Manager displays a font at 1-bit depth, no
matter what the current screen depth is. Font manufacturers can specify that the Font
Manager should not expand a font by setting bit 14 of the fontType_ eld of the
bitmapped font resource.

How the Font Manager Renders Outline Fonts
Outline fonts are stored in an outline font ('sfnt ') resource as a collection of outline

points. (Don@confuse these outline points with the points that determine point size, or
the Point data type, which speci es a location in the QuickDraw coordinate plane.) The
Font Manager calculates lines and curves between the points, sets the bits that make the

bitmap, and then sends the bitmap to QuickDraw for display.

There are two types of outline points: on-curve points de ne the endpoints of lines, and
off-curve points determine the curve of the line between the on-curve points. Two
consecutive on-curve points de nea straight line. To draw a curve, the Font Manager
needs a third point that is off the curve and between the two on-curve points.
The Font Manager uses this parametric B zier equation to draw the curves of the glyph
from an outline font:
F(t)

=

(1

- t)*

*

A+

2t(1

—-t)

*

Bet?

*ec

where t ranges between 0 and 1 as the curve moves from point A to point C. A and C are
on-curve points; B is an off-curve point.

About the Font Manager

4-25

CHAPTER

4

Font Manager

Figure 4-8 shows two B zier curves. The positions of on-curve points A and C remain
constant, while off-curve point B shifts. The curve changes in relation to the position
of point B.
Figure 4-8

The effect of an off-curve point on two Bézier curves

m= on-curve point

O = off-curve point

A font designer can use any number of outline points to create a glyph outline.
These points must be numbered in a logical order, because the Font Manager draws
lines and curves sequentially. This process produces a glyph such as the lowercase ChO
in Figure 4-9.

4-26

About the Font Manager

CHAPTER

4

Font Manager

Figure 4-9

17

An outline with points on and off the curve

0

m = on-curve point

O = off-curve point

About the Font Manager

4-27

CHAPTER

4

Font Manager

There are several groups of points in Figure 4-9 that include two consecutive off-curve
points. For instance, points 2 and 3 are both off-curve. In this case, the Font Manager
interpolates an on-curve point midway between the two off-curve points, thereby
de ning two B zier curves, as shown in Figure 4-10. Note that this additional on-curve
point is used for creation of the glyph only; the Font Manager does not alter the outline
font resource@ list of points.
A curve with consecutive off-curve points

m@ = on-curve point
O = off-curve point

eos

eee

ee

eee

=

=

=O

Figure 4-10

When the Font Manager has nished drawing a closed loop, it has completed one
contour of the outline. The font designer groups the points in the outline font resource
into contours. In Figure 4-9, the Font Manager draws the rst contour in the glyph from
point 0 to point 17, and the second contour from point 18 to the end, creating the glyph in
Figure 4-11.

4-28

About the Font Manager

CHAPTER

4

Font Manager

Figure 4-11

A glyph from an outline font

Contour 1
(outside)

Contour 2

(inside)

At this stage, the glyph does not havea xed point size. Remember that point size is
measured as the distance from the base line of one line of text to the base line of the next
line of single-spaced text. Because the Font Manager has the measurements of the outline
relative to the base line and ascent line, it can correlate the measurements with the

requested point size and calculate how large the outline should be for that point size.
The Font Manager uses the contours to determine the boundaries of the bitmap for this
glyph when it is displayed. For example, the Macintosh computer@ screen is a grid made
of pixels. The Font Manager ts the glyph, scaled for the correct size, to this grid. If the
center of one section of this gridN comparable to a pixel or a printer dotN falls on a
contour or within two contours, the Font Manager sets this bit for the bitmap.

Because there are two contours for the glyph in Figure 4-11, the Font Manager begins
with pixels at the boundary marked by contour 1 and stops when it gets to contour 2.
Some glyphs need only one contour, such as the uppercase (Oin some fonts. Others have
three or more contours, such as the 40 glyph from the ITC Zapf Dingbats font.
If the pixels (or dots) are tiny in proportion to the outline (when resolution is high or the
point size of the glyph is large), they Il out the outline smoothly, and any pixels that jut
out from the contours are not noticeable. If the display device has a low resolution or the
point size is small, the pixels are large in relation to the outline. You can see in Figure 4-12
that the outline has produced an unattractive bitmap. There are gaps and blocky areas
that would not be found in the high-resolution versions of the same glyph.

About the Font Manager

4-29

CHAPTER

4

Font Manager

Figure 4-12

An unmodified glyph from an outline font at a small point size

Because the size of the pixels or dots used by the display device cannot change, the
outline should adapt in order to produce a better bitmap. To achieve this end, font
designers include instructions in the outline font resource that indicate how to change the
shape of the outline under various conditions, such as low resolution or small point size.

The lowercase QhOoutline in Figure 4-13 is the same one depicted in Figure 4-12, except
that the Font Manager has applied the instructions to the gure and produced a better
bitmapped glyph. These instructions are equivalent to Qnove these points hereOor
@hange the angle formed by these points.OA font designer includes programs consisting
of these instructions in certain outline font resource tables, where the Font Manager nds
them and executes them under speci ed conditions. Most applications do not need to use
instructions; however, if you want to know more about them, see the book TrueType Font
Format Specification.
Once the Font Manager has produced the outline according to the design and
instructions, it creates a bitmap and sends the bitmap to QuickDraw, which draws it on
the screen. The Font Manager then saves the bitmapped glyph in memory (caches it) and
uses it the next time the user requests this glyph in this font at this point size.

4-30

About the Font Manager

CHAPTER

4

Font Manager

Figure 4-13

An instructed glyph from an outline font

Using the Font Manager
You can use the Font Manager to take full advantage of the information that fonts contain
about their widths and scaling possibilities and present this information to the user. The
Font Manager provides routines that give your application control over selecting fonts
and measuring the individual glyphs of the font. It also helps you to handle the
coexistence of bitmapped and outline versions of fonts.
This section describes how to use the capabilities of the Font Manager in your program to
handle tasks, including

initializing the Font Manager
adding font names and sizes to the Font menu
storing font names in your documents
getting font measurement information
setting the Font Manager to favor outline or bitmapped fonts
preserving or scaling the shapes of glyphs
using the font tables
getting the system or application font ID
enabling and disabling font scaling and fractional width use

Using the Font Manager

4-31

CHAPTER

4

Font Manager

To initialize the Font Manager, you must call the Init Fonts procedure. Before calling
InitFonts, you need to initialize QuickDraw by calling the InitGraf procedure,
which is described in Inside Macintosh: Imaging.

Adding Font Sizes and Names to the Menu
When you use the Menu Manager to add font sizes to a menu, make sure that you
construct the menu so that it displays appropriate sizes for both bitmapped and outline
fonts. Keep the following guidelines in mind:
= Support all possible font sizes. The maximum point size on the QuickDraw coordinate
plane is 32,767 points.

m Provide a short list of the most useful font sizes. For the menu that your application
uses to display font sizes, you shouldn@prede ne a static list of sizes available to the
user or allow the default to be every possible font size, because outline fonts can
produce thousands of sizes.
m Provide a method of increasing or decreasing the font size by one point at a time. You
can add Larger and Smaller commands, which make choosing slightly different sizes
for outline fonts easier for the user. Also, the user should be able to choose any

possible point size at any time in a simple manner.
m

Place a check next to the current size.

m Display available font sizes in outline style. For a bitmapped font, the RealFont
function returns TRUE if the font is available in the requested point size and FALSE if
the font is not; you can thereby determine which bitmapped fonts are available. For
outline fonts, the RealFont function returns TRUE for almost any size. The font@

designer may decide that there is a lower limit to the point sizes at which the font
looks acceptable. The RealFont function returns FALSE for an outline font if the size
requested is smaller than this lower limit.
Figure 4-14 shows one possible method for accomplishing these goals in a menu.
Figure 4-14

A sample Size menu and font size dialog box

Size |
10
12

19
va4

310)

Font

Size:

3)

.

The quick
brown fox

Larger

Smaller

os

To create a menu that displays font names, use the AddResMenu procedure. This
procedure ensures that any changes to the Font Manager do not affect your application
4-32

Using the Font Manager

CHAPTER

4

Font Manager

and that the menu that displays font names is not dependent on how fonts are stored in
system software. The AddResMenu procedure is documented in the chapter Menu
ManagerOin Inside Macintosh: Macintosh Toolbox Essentials.

Storing a Font Name in a Document
When presenting a font to a user, you should always refer to a font by name rather than
by font family ID; this prevents several problems that can arise if you use the font family
ID. One problem with identifying fonts by font family ID rather than by name is the
plethora of font families available for the Macintosh computer. Many share the same font
family ID, and even though the font the user wants is present in the System le, another
font with the same ID may appear in a font menu. Another problem is that one font
family may have different IDs on different computer systems, so that when the
application opens the document using this font family on a different computer system, it
can@

nd the proper font, even though it is available, and substitutes another.

If youe stored the name of the font in the document, you can nd its font family ID by
calling the Get FNum procedure, which is described on page 4-52. However, if the font
isn@®present in the system software when the user opens the document, Get FNum returns
0 for the ID. Since 0 is also the system font ID (or the neighborhood base font for the
active script system), you need to double-check the name of the font from the document
against the name of the system font, as illustrated in Listing 4-1.
Listing 4-1
FUNCTION

Checking a font name against the system font name

MyGetFontNumber

(fontName:

Str255;

VAR

fontNum:

Integer):

{MyGetFontNumber

returns

in

{

the

font

the

font

name.

If

there’s

no

such

{

it

returns

FALSE. }

systemFontName:

Str255;

not

found,

or

it

the

system

with

given

the

fontNum

Boolean;

parameter

the

number

for

font,

}

}

VAR

BEGIN

GetFNum(fontName,
IF

fontNum

BEGIN

=

0

fontNum) ;

THEN

{either

the

font

was

GetFontName
(0,

systemFontName) ;

GetFontNumber

:=

END{

was

if

theNum

EqualString(fontName,

not

0,

the

font

is

is

systemFontName,

available

font}

FALSE,

FALSE) ;

}

ELSE

GetFontNumber

:=

TRUE;

END;

Using the Font Manager

4-33

CHAPTER

4

Font Manager

Storing a font@ name rather than its ID is a more reliable method of nding a font,
because the name, unlike the font family ID, does not change from one computer system
to another. You may also want to store the checksum of a font (the sum of the values of
the bytes in the font data) with its name, to be sure that the version of the font is the same

on different computer systems. Listing 4-2 on page 4-76 provides a function for
computing a checksum.

If the font versions are differentN that is, if the checksums don®matchN you should offer

users the option of substituting for the font temporarily (until they can nd the proper
version of the font) or permanently (with another font that is currently available).

If you are developing software for use with non-Roman fonts and the font is not found
(by a function such as MyGet FontNumber above), you can use the neighborhood base
font rather than the system font. The neighborhood base font is the lowest font ID for a
particular script.

Getting Font Measurement Information
You sometimes need to get font measurement information for the text font in the
current graphics port. The Font Manager provides two routines for this purpose:
FontMetrics and OutlineMetrics. In addition, QuickDraw provides font
measurement information in the Get Font Info procedure. You can use this information
when arranging the glyphs of one font or several fonts on a line or to calculate
adjustments needed when font size or style changes.
The FontMetrics procedure can be used on any kind of font, whether bitmapped or
outline. It returns the ascent and descent measurements, the width of the largest glyph in
the font, and the leading measurements. The FontMetrics procedure returns these
measurements in a font metrics record (of data type FMet ricRec), which allows
fractional widths, whereas QuickDraw@ Get Font Info procedure returns a font
information record (of data type Font Info), which uses integer widths. In addition to
these four measurements, the font metrics record includes a handle to the global width
table, which in turn contains a handle to the font family resource for the current

text font. The Get Font Info procedure and the font information record are described
in the chapter QQuickDraw TextOin this book. The global width table is
described on page 4-36. The FontMet rics procedure and the font metrics record
are described on page 4-54.

The Out lineMet rics function returns measurements for glyphs to be displayed in an
outline font. The function returns an error if the text font in the current graphics port is
any other kind of font. These measurements include the maximum y-values, minimum
y-values, advance widths, left-side bearings, and bounding boxes. (For the de

of these terms, see the section OAbout Fonts,Owhich begins on page 4-6.) The
OutlineMetrics function is described beginning on page 4-56.

nitions

For a font of a non-Roman script system that uses an associated font, the font
measurements refsect combined values from the current font and the associated font.
This is to accommodate the script system@ automatic display of Roman characters in the

4-34

Using the Font Manager

CHAPTER

4

Font Manager

associated font instead of the current font. See the discussion of associated fonts in the

chapter Ontroduction to Text on the MacintoshOin this book.

Favoring Outline or Bitmapped Fonts
When a document uses a font that is available as both an outline font and a bitmapped
font, the Font Manager has to decide which kind of font to use. Its default behavior is to
use the bitmapped font when your application opens the document. This behavior avoids
problems with documents that were created on a computer system on which outline
fonts were not available. See CHow the Font Manager Responds to a Font RequestOon
page 4-17 for more information.
You can change this default behavior by calling the SetOut linePreferred procedure.
If you call SetOut linePreferred with the out linePreferred parameter set
to TRUE, the Font Manager chooses outline fonts over bitmapped fonts when both
are available.
The GetOut linePreferred function returns a Boolean value that indicates which kind

of font the Font Manager has been set to favor. You should call this function and save the

value that it returns with your documents. Then, when the user opens a document in

your application, you can call SetOut linePreferred with that value to ensure that
the same fonts are used.

If only one kind of font is available, the Font Manager chooses that kind of font to use in
the document, no matter which kind of font is favored. You can determine whether the

font being used in the current graphics port is an outline font by using the
function, which is described on page 4-61.

IsOutline

Preserving the Shapes of Glyphs
Most glyphs in an alphabetic font t between the ascent line and the descent line, which
roughly mark (respectively) the tops of the lowercase ascenders and the bottoms of the
descenders. Bitmapped fonts always t between the ascent line and descent line. One aim
of outline fonts is to provide glyphs that are more accurate renditions of the original
typeface design, and there are glyphs in some typefaces that exceed the ascent or descent
line (or both). An example of this type of glyph is an uppercase letter with a diacritical
mark: CNOwith a tilde produces Q, O Many languages use glyphs that extend beyond
the ascent line or descent line.
However, these glyphs may disturb the line spacing in a line or a paragraph. The glyph
that exceeds the ascent line on one line may cross the descent line of the line above it,
where it may overwrite a glyph that has a descender. You can determine whether glyphs
from outline fonts exceed the ascent and descent lines by using the Out lineMetrics
function. Out lineMet rics returns the maximum and minimum y-values for whatever
glyphs you choose. You can get the values of the ascent and descent lines using the
FontMetrics

procedure. Ifa elyph@ maximum

or minimum

y-value is greater than,

respectively, the ascent or descent line, you can opt for one of two paths of action: you
can change the way that your application handles line spacing to accommodate the
glyph, or you can change the height of the glyph.
Using the Font Manager

4-35

CHAPTER

4

Font Manager

The Font Manager@ default behavior is to change the height of the glyph, providing
compatibility with bitmapped fonts, which are scaled between the ascent and descent
lines. Figure 4-15 shows the difference between an QO, Oscaled to

tin the same amount

of space as an ONOand a preserved Q, O The tilde on the preserved Q, Oclearly exceeds
the ascent line.
Figure 4-15

The difference between a scaled glyph and a preserved glyph

Scaled glyph

Preserved glyph

You can change this default behavior by calling the Set PreserveGlyph procedure. If
you call

Set PreserveGlyph with the preserveGlyph parameter set to TRUE, the Font

Manager preserves the shape of the glyph intended by the font@ designer.

The Get PreserveGlyph function returns a Boolean value that indicates whether or not

the Font Manager has been set to preserve the shapes of glyphs from outline fonts. You
should call this function and save the value that it returns with your documents. Then,
when the user opens a document in your application, you can call Set PreserveGlyph
with that value to ensure that glyphs are scaled appropriately.

Using Width Tables
When the Font Manager responds to a request to make a font available, the font resource
is loaded into memory and the Font Manager allocates memory for various tables that are
needed to use the font. To make font usage more ef cient, the Font Manager maintains a
cache of the tables for the most recently used fonts, so that it does not have to reread the

resources and rebuild the tables more often than necessary. The Font Manager can cache

the tables for up to 12 fonts. For outline fonts, the cached information includes the width

tables and any bitmaps that have been created from the outlines.

The global width table contains the widths of all the glyphs of one font. If you are
measuring text to be displayed on the screen, you can use the QuickDraw procedure
MeasureText to determine glyph widths; however, if you are printing text and need to
determine glyph widths, you have to use widths from the global width table. The
OutlineMetrics function returns the individual widths of glyphs for an outline font

4-36

Using the Font Manager

CHAPTER

4

Font Manager

and the FontMetrics procedure returns the width of the largest glyph in a bitmapped
font. You can also directly access the global width table, which is de ned by the
WidthTable data type. This data type is described in the section
he Global Width
TableObeginning on page 4-43.
To use the global width table, you can get a handle to it from the FontMetrics
procedure, or you can use the handle stored in the global variable WidthTabHandle.
The global variable WidthPtr contains a pointer to the global width table; however,
this variable is reliable only immediately after a call to FMSwapFont. Like all pointers to
data in handles, WidthPtr may become invalid after a call to the Memory Manager.
In general, use the WidthTabHand1e global variable instead of the WidthPtr
global variable.
The global variable WidthListHand is a handle to a list of up to 12 handles to recently
used width tables. You can scan this list and look for width tables that match the
font family ID, size, and style of the font you wish to measure. If you reach a width-table
handle that contains

linthe tabFont,

fID,and aFID

elds, that width table

is invalid. When you reach a handle that is equal to NIL, you have reached the end of
the list.
IMPORTANT

Do not use the values from the global width table if your application is
running on a computer on which non-Roman script systems are
installed. You can check to see if a non-Roman script system is present by
calling the Get ScriptManagerVariable function with a selector of
smEnab1led; if the function returns a value greater than 0, at least one

non-Roman script system is present and you need to call MeasureText
to measure text that is displayed on the screen. Measuring text from a
non-Roman script system for printing is handled by the printer driver. a
If your application directly manipulates data in a font resource (for example, if your
application edits fonts), you may need to Sush the Font Manager@ cache, so that the
cached information refsects any changes that your application makes. The FlushFonts
function, which is described on page 4-66, erases all of the Font Manager@ caches. The
Font Manager then rebuilds the cache as new fonts are called into use again.
Normally, fonts are purgeable, which means that the space used for each font@ resource
information can be released from memory. You can temporarily prevent a font from being
purged by locking it with a call to the Set Font Lock procedure. A subsequent call to
Set FontLock unlocks the font, allowing the Font Manager to purge it from memory.
The Set Font Lock procedure is described on page 4-65.
If you are calculating the amount of extra width that is added to a glyph as a result of
adding a font style, you can choose how you want the Font Manager to determine the
extra pixels needed. It can nd the information in the style property eld of the font
family resource or from the style extra eld in the Font Manager@ internal tables. If
the value of the global variable FDevDisab1e is 0, the Font Manager uses the style extra
value from its internal tables; if FDevDisabl1le is any other value, the Font Manager uses
the value from the style property eld, which is described on page 4-93.

Using the Font Manager

4-37

CHAPTER

4

Font Manager

Getting the System or Application Font ID
When your application does not allow the user to change the font, your application has
to tell the Font Manager to use either the system font or the application font. You do this
by passing either the systemFont constant or the appl Font constant to the Text Font
procedure, which is described in the chapter GQuickDraw TextOin this book. The Font
Manager maps fonts with other resource IDs to these values, as described in the chapter
(Script ManagerOin this book.
If you need to know the true font family ID of the system font, you can call the
GetSysFont function, which checks the global variable SysFont Fam and returns that
resource ID. Similarly, if you want to know the true font family ID of the application font,
you can call the Get AppFont function or check the global variable ApFont ID.

The global variable SysFont Size contains the point size of the current system font. If
you call the Text Size procedure (which is described in the chapter GQQuickDraw TextO
in this book) with a value of 0, the default application font size is used. You can nd the
default system font size value by calling the Get Def Font Size function. If the default
system font point size is set to 0, the Font Manager uses 12 as its value.
You can read more about the system and application fonts in the chapter Ontroduction to
Text on the MacintoshOin this book.

Using Fractional Glyph Widths and Font Scaling
Using fractional glyph widths allows the Font Manager to place glyphs on the screen
in a manner that closely matches the eventual placement of glyphs on a page printer
by high-resolution printers. (See CHow the Font Manager Calculates Glyph WidthsOon
page 4-23.)
You can enable the use of fractional glyph widths with the Set FractEnable procedure.
If you set the parameter fractEnable to TRUE, the Font Manager uses fractional glyph
widths. If you set it to FALSE, the Font Manager uses integer glyph widths. The Font
Manager sets the global variable Fract Enable to FALSE by default. Youcan nd out
whether the Font Manager has used fractional widths in the calculations for the global
width table or other tables by checking the value of the UsedFWidths global variable; if
the value is nonzero, the Font Manager used fractional widths.

When a bitmapped font is not available in a speci c size, the Font Manager can compute
scaling factors for QuickDraw to use to create a bitmap of the requested size. You can set
the Font Manager to compute scaling factors for bitmapped fonts by using the
Set FScaleDisable procedure, which sets the value of the FScaleDisable global

variable. If you set the font ScaleDisable parameter of this procedure to TRUE, the
Font Manager disables font scaling.
When font scaling is disabled, the Font Manager responds to a request for a font size that
is not available by returning a bitmapped font with the requested widths, which may
mean that their height is smaller than the requested size. If you set it to FALSE, the Font
Manager computes scaling factors for bitmapped fonts and QuickDraw scales the glyph
bitmaps. The Font Manager sets the global variable FScaleDisable to FALSE by

4-38

Using the Font Manager

CHAPTER

4

Font Manager

default. If the value of this global variable is FALSE, scaling is enabled. (See Lhe Scaling
Process for a Bitmapped FontOon page 4-22.) If scaling is enabled, you can get the current
horizontal and vertical scaling factors from the global variable FScaleHFact and
FScaleVFact, respectively.
The Font Manager always scales an outline font, regardless of the value of the
FScaleDisable global variable.
Fractional glyph widths and font scaling are also described in the chapter GQQuickDraw
TextOin this book.

Font Manager Reference
This section describes the data structures, routines, and resources provided by
the Font Manager.
The (Data StructuresOsection shows the Pascal data structures used by the bitmapped
font resource, the font family resource, and the Font Manager routines. Many, but not all

of the tables in these resources have corresponding high-level data structures and
detailed descriptions of the tables in each resource type are found in the sections
dedicated to each resource.

The CRoutinesOsection describes the routines you can use to get information about the
font in the current graphics port recordN such as its name, ID, and measurements for
layoutN or to get a handle to a speci c font.
The resources sections describe the resources used by the Font Manager: the bitmapped
font ('NFNT') resource, the outline font ('sfnt') resource, and the font family (' FOND ')

resource. You only need to understand most of the information in this section if you are
writing an appliction, such as a font editor, that works directly with font resource data.

Equivalent declarations in the C language for the data structures and routines presented
here can be found in the Gummary of the Font ManagerOsection at the end of this
chapter.

Data Structures
This section describes the data structures that you use to provide information to the
Font Manager.
You use the font input record to request a font that matches the speci ed characteristics.
The actual characteristics of the font that the Font Manager chooses for the request are
returned in a font output record.
You use the global width table record to

Font Manager Reference

nd the widths of all glyphs in a font.

4-39

CHAPTER

4

Font Manager

You use the font record to access the contents of a bitmapped font ('NFNT') resource and
a font family record to access the contents of a font family (' FOND ') resource.
The font family resource includes a number of other tables, each of which has a

corresponding data structure, including the font association table record, the
bounding-box table record, the family glyph-width table record, the style-mapping
table record, and the family kerning table record.
Although some of the resource tables have corresponding data types, many of them
do not. If you need to de nea data type for a table that does not yet have one de ned
for it, the resources sections contain pictures of each table, including the length of each
table element.

The Font Input Record
The font input record, of data type FMInput, is used by QuickDraw to request a font
from the Font Manager, as described in the section CHow QuickDraw Requests a FontO
on page 4-16. You can also use this data type to request a font with the FMSwapFont
function, which is described on page 4-64.
TYPE

FMInput

PACKED

=

RECORD

family:
size:
face:
needBits:
device:
numer :
denom:

Integer;
Integer;
Style;
Boolean;
Integer;
Point ;
Point;

{font family ID}
{requested point size}
{requested font style}
{if bitmaps need to be constructed}
{device driver ID}
{scaling factor numerators}
{scaling factor denominators}

END;

Field descriptions

4-40

family

The font family ID of the requested font.

size

The point size of the requested font.

face

The requested font style. The de ned QuickDraw styles are bold,

needBits

Indicates whether QuickDraw draws the glyphs. If QuickDraw does
not draw the glyphs, as is the case for measurement routines such as
MeasureText, then the glyph bitmaps do not have to be read or
constructed. If QuickDraw draws the glyphs and the font is
contained in a bitmapped font resource, all of the information
describing the font, including the bit image, is read into memory.

device

The high-order byte contains the device driver reference number.
The low-order byte is reserved.

italic, underline, outline, shadow, condense, and extend.

Font Manager Reference

CHAPTER

4

Font Manager

numer

The numerators of the vertical and horizontal scaling factors. (For
more information about font scaling, see How the Font Manager
Scales FontsOon page 4-19.) The numer eld is of type Point and
contains two integers: the rst is the numerator of the ratio for
vertical scaling and the second is the numerator of the ratio for
horizontal scaling.
The denominators of the vertical and horizontal scaling factors. (For
more information about font scaling, see How the Font Manager
Scales FontsOon page 4-19.) The denom eld is of type Point and
contains two integers: the rst is the denominator of the ratio for
vertical scaling and the second is the denominator of the ratio for
horizontal scaling.

denom

The Font Output Record
The font output record, of data type

FMOut put,

contains a handle to a font and

information about font measurements. It is lled in by the Font Manager upon
responding to a font request. You can request a font using the FMSwapFont function,
which is described on page 4-64.
TYPE

FMOutput

PACKED

=

RECORD

errNum:
fontHandle:
bold:
italic:
ulOffset:
ulShadow:

Integer;
Handle;
Byte;
Byte;
Byte;
Byte;

{reserved for internal use}
{handle to font}
{for drawing of bold style}
{for drawing of italic style}
{for drawing of underline style}
{for drawing of underline shadow

ulThick:

Byte;

{for

shadow:
extra:
ascent:
descent:

Byte;
SignedByte;
Byte;
Byte;

{for drawing of shadow style}
{# of pixels added for styles}
{ascent measurement of font}
{descent measurement of font}

widMax:

Byte;

{maximum

width

of

glyphs

leading:

SignedByte;

{leading

value

for

font}

Byte;
Point;
Point;

{actual output font style}
{scaling factor numerators}
{scaling factor denominators }

drawing

of

underline

style}

thickness}

in

font}

fOutCurStyle:

numer :
denom:
END;

Field descriptions

errNum

Reserved for use by Apple Computer, Inc.

Font Manager Reference

4-41

CHAPTER

4

Font Manager

fontHandle

A handle to the font resource requested by the font input record,
which may either be a bitmapped font or outline font resource.
The bitmapped font is described in the section
he Bitmapped Font
(‘NENT’) Resource,Owhich begins on page 4-66. The outline font is
described in the section (fhe Outline Font (‘sfnt') Resource, Owhich
begins on page 4-72.

bold

Modi es how QuickDraw applies the bold style on the screen
and on raster printers. Other display devices may handle
styles differently.

italic

Modi es how QuickDraw applies the italic style on the screen
and on raster printers. Other display devices may handle
styles differently.

uloffset

Modi es how QuickDraw applies the underline style on the
screen and on raster printers. Other display devices may handle
styles differently.

ulShadow

Modi es how QuickDraw applies the underline shadow style on the
screen and on raster printers. Other display devices may handle
styles differently.

ulThick

Modi es how QuickDraw applies the thickness of the underline
style on the screen and on raster printers. Other display devices may
handle styles differently.

shadow

Modi es how QuickDraw applies the shadow style on the screen
and on raster printers. Other display devices may handle styles
differently.
The number of pixels by which the styles have widened each glyph.
The ascent measurement of the font. Any algorithmic styles or
stretching that may be applied to the font are not taken into account
for this value.
The descent measurement of the font. Any algorithmic styles or
stretching that may be applied to the font are not taken into account
for this value.

extra
ascent

descent

widMax

The maximum width of the font. Any algorithmic styles or
stretching that may be applied to the font are not taken into account
for this value.

leading

The leading assigned to the font. Any algorithmic styles or
stretching that may be applied to the font are not taken into account
for this value.
The actual style being made available for QuickDraw@ text drawing,
as opposed to the requested style.
The numerators of the vertical and horizontal scaling factors. (For
more information about font scaling, see CHow the Font Manager
Scales FontsOon page 4-19.) The numer eld is of type Point and
contains two integers: the rst is the numerator of the ratio for
vertical scaling and the second is the numerator of the ratio for
horizontal scaling.

fOutCurStyle
numer

4-42

Font Manager Reference

CHAPTER

4

Font Manager

denom

The denominators of the vertical and horizontal scaling factors. (For
more information about font scaling, see GHow the Font Manager
Scales FontsOon page 4-19.) The denom eld is of type Point and
contains two integers: the rst is the denominator of the ratio for
vertical scaling and the second is the denominator of the ratio for
horizontal scaling.

The bold, italic, ulOffset, ulShadow,

ul Thick, and shadow values are all used to

communicate to QuickDraw how to modify the way it renders each stylistic variation.
Each byte value is taken from the font characterization table of the printer driver and is
used by QuickDraw when it draws to a screen or raster printer.
The ascent, descent, widMax, and leading values can all be different in this record

than the corresponding values in the Font Info

record that is produced by the

Get Font Info function in QuickDraw. This is because Get Font Info takes into account

any algorithmic styles or stretching that QuickDraw performs, while the Font Manager
routines do not.

The numer and denom values are used to designate how font scaling is to be done. The
values for these elds in the font output record can be different than the values speci ed
in the font input record. For more information about font scaling, see the section CHow

the Font Manager Scales Fonts, Owhich begins on page 4-19.
The Global Width Table

The global width table record, of data type WidthTab1le, contains the widths of all the
glyphs of one font. The font family, point size, and style of this font are speci ed in this
table. Your application should use the widths found in the global width table for
placement of glyphs and words both on the screen and on the printed page. You can use
the FontMetrics procedure, described on page 4-54, to get a handle to the global width
table. However, you should not assume that the table is the same size as shown in the
record declaration; it may be larger because of some private system-speci c information
that is attached to it.
Type

WidthTable

PACKED

=

RECORD

tabData:

ARRAY

[1..256]

OF

Fixed;

tabFont :

Handle;

{character widths}
{font record used to

build

table}

sExtra:

LongiInt;

{extra

style:
fID:
fSize:
face:
device:
inNumer:
inDenom:
aFID:

LongInt;
Integer;
Integer;
Integer;
Integer;
Point;
Point;
Integer;

{extra line spacing due to
{font family ID}
{font size request}
{style (face) request}
{device requested}
{scale factors requested}
{scale factors requested}
{actual font family ID for

style}

Font Manager Reference

line

spacing}

table}

4-43

CHAPTER

4

Font Manager

fHand:
usedFam:
aFace:

vOutput:
houtput :
vFactor:
hFactor:
aSize:
tabSize:

Handle;
Boolean;
Byte;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;

{family record used to build up table}
{used fixed-point family widths}
{actual face produced}
{vertical scale output value}
{horizontal scale output value}
{vertical scale output value}
{horizontal scale output value}
{size of actual font used}
{total size of table}

END;
Field descriptions
tabData

The widths for the glyphs in the font, in standard 32-bit xed-point
format. If a glyph is missing in the font, its entry contains the width
of the missing-character glyph.

tabFont

A handle to the font resource used to build this table.

skxtra

The average number of pixels by which QuickDraw widens each
space in a line of text.

style

The average number of pixels by which QuickDraw widens a line of

fID

text after applying a style.
The font family ID of the font represented by this table. This is the
ID that was used in the request to build the table. It may be different
from the ID of the font family that was used, which is indicated by

the aFID
fSize
face

device
inNumer

inDenom

aFID

fHand

4-44

eld.

The point size that was originally requested for the font represented
by this table. The actual size used is speci ed in the aSize eld.
The font style that was originally requested for the font represented
by this table. The actual style used is speci edinthe aFace eld.
The device ID of the device on which these widths may be used.
The numerators of the vertical and horizontal scaling factors. The
numer eld is of type Point and contains two integers: the rstis
the numerator of the ratio for vertical scaling and the second is the
numerator of the ratio for horizontal scaling.
The denominators of the vertical and horizontal scaling factors. The
denom eld is of type Point and contains two integers: the rst is
the denominator of the ratio for vertical scaling and the second is the
denominator of the ratio for horizontal scaling.
The font family ID of the font family actually used to build this
table. If the Font Manager could not nd the font requested, this
value may be different from the value of the fID_ eld.
The handle to the font family resource used to build this table.

usedFam

Set to TRUE if the xed-point family glyph widths were used rather
than integer glyph widths.

aFace

The font style of the font whose widths are contained in this table.

Font Manager Reference

CHAPTER

4

Font Manager

vOutput

The factor by which glyphs are to be expanded vertically in the
current graphics port. This is a 16-bit xed-point number, with the
integer part in the high-order byte and a fractional part in the
low-order byte.

houtput

The factor by which glyphs are to be expanded horizontally in the
current graphics port. This is a 16-bit xed-point number, with the
integer part in the high-order byte and a fractional part in the
low-order byte.

vFactor

The factor by which widths of the chosen font, after a style has been

hFactor

applied, have been increased vertically in the current graphics port.
This is a 16-bit xed-point number, with the integer part in the
high-order byte and a fractional part in the low-order byte. The
value of the vFactor eld is not used by the Font Manager.

The factor by which widths of the chosen font, after a style has been

applied, have been increased horizontally in the current graphics
port. This is a 16-bit xed-point number, with the integer part in the
high-order byte and a fractional part in the low-order byte.

aSize

The size of the font actually used to build this table. Both the point
size and the font used to build this table may be different from the
requested point size and font. If font scaling is disabled, the Font
Manager may use a size different from the size requested and add
more or less space to approximate the appearance of the font
requested. See (Lhe Scaling Process for a Bitmapped FontOon
page 4-22 for more information.

tabSize

The total size of the global width table.

Multiplying the values of the houtput and vOutput elds by the values of the
hFactorandvFactor
elds, respectively, gives the font scaling. (Because the value of
the vFactor eld is ignored, the Font Manager multiplies the value of the vOutput eld
by 1.) The product of the value of the hoOutput eld and an entry in the global width
table is the scaled width for that glyph.
The Font Manager gathers data for the global width table from one of three
data structures:
1. The Font Manager looks in the font resource for a table that stores fractional glyph

widths. For bitmapped fonts, the Font Manager uses the glyph-width table of the
bitmapped font resource (described on page 4-70). For outline fonts, the Font Manager
uses the advance width and left-side bearing values in the horizontal metrics table of
the outline font (described on page 4-83). In both cases, the values are stored in 16-bit
xed format, with the integer part in the high-order byte and the fractional part in the
low-order byte.

. If there is no glyph-width table in the font resource, the Font Manager looks for the
font family@ glyph-width table in the font family resource, which contains fractional
widths for a hypothetical 1-point font. The Font Manager calculates the actual values
by multiplying these widths by the requested font size. The font family@ glyph-width
table is described in (Phe Family Glyph-Width TableOon page 4-98.
. If there is no glyph-width table in the font family resource, and if the font is contained
in a bitmapped font resource, the Font Manager derives the glyph widths from the

Font Manager Reference

4-45

CHAPTER

4

Font Manager

integer widths contained in the glyph-width table of the bitmapped font resource,
which is described on page 4-70. There is no corresponding table for the outline font
resource.
Your application should obtain glyph widths either from the global width table or from
the QuickDraw procedure MeasureText. The MeasureText procedure works only
with text to be displayed on the screen, not with text to be printed. You can get the
individual widths of glyphs of an outline font using the Out lineMet rics function.
The FontMetrics procedure returns only the width of the largest glyph in a font
contained in a bitmapped font resource.
IMPORTANT

Do not use the values from the global width table if your application is
running on a computer on which non-Roman script systems are
installed. You can check to see if anon-Roman script system is present by
calling the Get ScriptManagerVariable function with a selector of
smEnabled; if the function returns a value greater than 0, at least one

non-Roman script system is present and you need to call MeasureText
to measure text that is displayed on the screen. Measuring text from a
non-Roman script system for printing is handled by the printer driver. a
For more information about the MeasureText procedure, see the chapter GQQuickDraw
TextOin this book. The FontMet rics procedure is described on page 4-54 and the
OutlineMetrics function is described on page 4-56.
The Font Record
The font record, of data type FontRec, describes the format of the bitmapped font
('NFNT') resource (and, likewise, the 'FONT' resource). It is shown here as a
guide to the format of the resource. The font record is not used directly by any
Font Manager routines.
TYPE

FontRec

=

RECORD

fontType:
Integer;
firstChar:
Integer;
lastChar:
Integer;
widMax:
Integer;
kernMax:
Integer;
nDescent:
Integer;
fRectWidth: Integer;
fRectHeight :Integer;
owTLoc:
Integer;
ascent:
Integer;
descent:
Integer;
leading:
Integer;

{font type}
{character code of first glyph}
{character code of last glyph}
{maximum glyph width}
{maximum glyph kern}
{negative of descent}
{width of font rectangle}
{height of font rectangle}
{offset to width/offset table}
{maximum ascent measurement }
{maximum descent measurement }
{leading measurement }

rowWords:

{row

Integer;

END;

4-46

Font Manager Reference

width

of

bit

image

in

16-bit

wds}

CHAPTER

4

Font Manager

The elds of the font record are described in the section (he Bitmapped Font (‘NENT’)
Resource,Obeginning on page 4-66.

The Font Family Record
The font family record, of data type FamRec, describes the format of the font family
(‘FOND ') resource. It is shown here as a guide to the format of the resource. The font
family record is not used directly by any Font Manager routines.
TYPE

FamRec

=

RECORD

ffFlags:

Integer;

ffFamID:

Integer;

ffFirstChar:

Integer;

ffLastChar:

Integer;

ffAscent:

Integer;

ffDescent:

Integer;

ffLeading:

Integer;

ffWidMax:

Integer;

ffwlaboff:

LongInt;

ffKernoff:

LongInt;

ffStyloff:

LongInt;

ffProperty:

ARRAY

[1..9]

{ flags for family}
{ family ID number}
{ ASCII code of first character}
{ ASCII code of last character}
{ maximum ascent for 1-pt font}

descent for 1-pt font}
leading for 1-pt font}
{maximum glyph width for 1-pt font}
{ offset to family glyph-width table}
{ offset to kerning table}
{offset to style-mapping table}
{maximum
{maximum

OF Integer;

{style
ffIntl:
ffVersion:

ARRAY

[1..2]

Integer;

properties

info}

{for international
{version number}

use}

OF Integer;

END;

The elds of the font family record are described in the section (fhe Font Family
(‘FOND’) Resource,Obeginning on page 4-90.
The Font Association Table Record
The font association table record, which is part of the font family resource, maps a point
size and style to a speci c font that is part of the family. The table record, of data type
FontAssoc, consists of a count of the entries in the table and is followed by the
entry records.
TYPE

FontAssoc

=

RECORD
numAssoc:

Integer;

{number

{entries:

ARRAY[O..n]

of

of

entries

- 1}

AsscEntry; }

END ;

Font Manager Reference

4-47

CHAPTER

4

Font Manager

Each entry in the font association table is a font association entry record, of data type
Assckntry.
TYPE

Assckntry

=

RECORD

fontSize:
fontStyle:
fontID:

Integer;
Integer;
Integer;

{point size of font}
{style of font}
{font resource ID}

END;

The elds of the font association table and font association table entry record are
described in the section (fhe Font Association Table Obeginning on page 4-95.

The Family Glyph-Width Table Record
The font family glyph-width table record, which is part of the font family resource, is
used to specify glyph widths for the font family on a per-style basis. The table record, of
data type WidTab1e, consists of a count of the entries in the table and is followed by the
entry records.
TYPE

WidTable

=

RECORD

numWidths:

Integer;

{number

of

entries

-

1}

END;

Each entry in the family glyph-width table is a family glyph-width table entry record, of
data type WidEntry, which speci esa style and a variable length array of glyph-width
values.

TYPE

WidEntry

=

RECORD

widStyle:
{widths:

Integer;
ARRAY [0..n]

{style code}
of Fixed; }

END;

The elds of the family glyph-width table and family glyph-width table entry records are
described in the section (he Family Glyph-Width Table,Obeginning on page 4-98.

4-48

Font Manager Reference

CHAPTER

4

Font Manager

The Style-Mapping Table Record
The style-mapping table record, which is part of the font family resource, provides
information that is used by printer drivers to implement font styles. Each font family can
have its own character encoding and its own set of font suf x names for style
designations. Each style of a font has its own name, typically created by adding a style
suf x to the base name of the font, as described in the section (fhe Style-Mapping TableO
beginning on page 4-99. The table record, of data type StyleTable, provides
information about the font class and is followed by the font name suf x subtable and the
font glyph-encoding subtable.
TYPE

StyleTable

=

RECORD

fontClass:

Integer;

{font

offset:
reserved:

LongInt;
LongInt ;

{offset to
{reserved}

indexes:

PACKED

ARRAY

[0..47]

class

OF

of

this

font

glyph-encoding

family}

subtable}

SignedByte;

{indexes into the font suffix name
{ table that follows this table}

}

END;

The font suf

x name subtable record, of data type NameTab1le, contains the base name

and suf xes for a font family.
TYPE

NameTable

=

RECORD

stringCount :
Integer;
baseFontName:
Str255;
{suffix strings}

{string count}
{base font name}
{strings}

END;

The elds of the style-mapping table and font suf x name subtable are described in the
section (Lhe Style-Mapping Table Obeginning on page 4-99.

The Font Family Kerning Table Record
The font family kerning table record, which is part of the font family resource, contains a
number of kerning subtable entries, with different subtables for different stylistic
variations. The table record, of data type KernTab1e, consists of a count of the entries in

the table and is followed by the entry records.
TYPE

KernTable

=

RECORD

numKerns:
{kernPairs:

Integer;
ARRAY[0..n]

{number of subtable
of KernEntry}

entries}

END;

Font Manager Reference

4-49

CHAPTER

4

Font Manager

Each kerning subtable record entry, of data type KernEnt ry, contains kerning pair
records for a speci c stylistic variation of the font family. It is followed by the kerning
pair records.
TYPE

KernkEntry

=

RECORD

kernStyle:
kernLength:
{kernRec:

Integer; {kern style}
Integer; {entry length}
ARRAY [0..n] of kernPair}
{the kerning data

records}

END;

Each kerning pair record, of data type KernPair, speci es a kerning value for a pair of
glyphs. Each glyph in the pair is speci ed by its ASCII character code.
TYPE

KernPair

=

RECORD

kernFirst:

CHAR;

{Code

of

1st

character

of

kerned

pair}

kernSecond:

CHAR;

{Code

of

2nd

character

of

kerned

pair}

kernWidth:

Integer;

{kerning

value

in

lpt

fixed

format}

END;

The elds of the kerning table, kerning subtable entry, and kerning pair records are
described in the section (fhe Font Family Kerning Table, Obeginning on page 4-106.

Routines
This section describes the routines you use to initialize the Font Manager and to get
information about a font, such as its name, ID, or measurements. It also describes the

routines you use to get a handle to a font and to control aspects of the way the Font
Manager manipulates fonts, such as font scaling and fractional widths.
A

WARNING

Do not change any data in a font or in any of the font data structures or
global variables (except where expressly noted). &

Initializing the Font Manager
Typically, the Font Manager has already been initialized when your application opens.
However, you should call the Init Fonts procedure before you call any Font Manager
or QuickDraw text routines, just to be sure.

4-50

Font Manager Reference

CHAPTER

4

Font Manager

InitFonts
The Init Fonts procedure initializes the Font Manager.
PROCEDURE

InitFonts;

DESCRIPTION

If the system font isn@already in memory, the Init Fonts procedure reads it into
memory. Call this procedure once, after calling the InitGrafs procedure and before
calling any other Font Manager routines or any Toolbox routine that calls the
Font Manager.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the InitFonts procedure is
Trap macro

_InitFonts

Getting Font Information
The Font Manager provides three routines that allow you to get basic information about a
font. The Get Font Name procedure gets the name of a font family with a speci ed ID,
and the Get FNum procedure gets the font family ID for a font with a speci ed name. The
RealFont function tells you whether a font is available in a speci c point size.

GetFontName
The Get Font Name
ID number.
PROCEDURE

procedure gets the name of a font family that has a speci

GetFontName

(familyID:

Integer;

VAR

theName:

ed family

Str255);

familyID

The font family ID.

theName

On output, this parameter contains the font family name for the font
family speci

ed in

familyID.

DESCRIPTION

Given a font family ID, the Get Font Name procedure returns, in the parameter theName,
the name of the font family. If the font speci ed in the familyID parameter does not
exist, theName contains an empty string.

Font Manager Reference

4-51

CHAPTER

4

Font Manager

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the

Get Font Name procedure is

Trap macro
_GetFontName

GetFNum
The Get FNum procedure gets the font family ID for a speci ed font family name.
PROCEDURE

GetFNum

(theName:

Str255;

VAR

familyID:

Integer) ;

theName

The font family name.

familyID

On output, this parameter contains the font family ID for the font family

speci

ed in theName.

DESCRIPTION

Given a font name, the

Get FNum procedure returns, in the

family ID for the font family. If the font speci
exist,

ASSEMBLY-LANGUAGE

familyID parameter, the font

ed in the parameter theName does not

familyID contains 0.

INFORMATION

The trap macro for the

Get FNum procedure is

Trap macro
_GetFNum

RealFont
The RealFont

speci

FUNCTION

4-52

function determines whether a font is available or is intended for use ina

ed size.
RealFont

(fontNum:

fontNum

The font family ID.

size

The font size requested.

Font Manager Reference

Integer;

size:

Integer):

Boolean;

CHAPTER

4

Font Manager

DESCRIPTION

The RealFont function returns TRUE if the requested size of a font is available.
RealFont rst checks for a bitmapped font from the speci ed family. If one is not
available, RealFont checks next for an outline font. If neither kind of font is available,
RealFont returns FALSE.

If an outline font exists for the requested font family, RealFont normally considers the
font to be available in any requested size; however, the font designer can include

instructions in the font that outlines should not be used at certain point sizes, in which
case the RealFont function will consider the font unavailable and return FALSE. The
Font Manager determines whether the size is valid by testing the value of the smallest
readable size element of the font family header table, which is described in (fhe Font
Header Table,Obeginning on page 4-79.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the RealFont function is
Trap macro

_RealFont

Using the Current, System, and Application Fonts
The GetDefFont Size, GetSysFont, and GetAppFont functions return the current

values of the global variables that contain the default size of the system font, the ID
number of the system font, and the ID number of the application font.

GetDefFontSize
The GetDef Font Size function determines the default size of the system font.
FUNCTION

GetDefFontSize:

Integer;

DESCRIPTION

The Get Def Font Size

function returns the current value of the global variable

SysFontSi ze if that value is not 0. If the value of SysFontSize is 0,
GetDefFontSize returns 12 as the default font size.
At system startup, the value of SysFont$ize is set to 0.

SEE ALSO

You can determine the preferred size for either the system font or the application font of
any enabled script system by calling the Get ScriptManagerVariable
function. See
the chapter CScript ManagerOin this book.

Font Manager Reference

4-53

CHAPTER

4

Font Manager

GetSysFont
The Get SysFont function determines the font family ID of the current system font.
FUNCTION

GetSysFont:

Integer;

DESCRIPTION

The Get SysFont function returns the current value of the global variable SysFont Fam,
which is the font family ID of the current system font. This is the font family ID that has
been mapped to 0 by the system software.

GetAppFont
The GetAppFont function returns the font family ID of the current application font.
FUNCTION

GetAppFont:

Integer;

DESCRIPTION

The GetAppFont function returns the current value of the global variable ApFont ID,
which is the font family ID of the current application font. This is the font family ID that

has been mapped to 1 by the system software.

Getting the Characteristics of a Font
The FontMetrics procedure and the Out lineMetrics function both return font
measurement information. The FontMet rics procedure returns the ascent and descent
measurements, width of the largest glyph, and leading measurements for either a
bitmapped or an outline font. The Out lineMet rics function returns measurements for
text to be written in an outline font.

FontMetrics
The FontMetrics procedure gets fractional measurements for the font, size, and style
speci ed in the current graphics port.
PROCEDURE

FontMetrics

(VAR

theMetrics:

FMetricRec);

theMetrics

A font metrics record that contains the font measurement information, in
fractional values.

4-54

Font Manager Reference

CHAPTER

4

Font Manager

DESCRIPTION

The FontMetrics procedure returns measurements for the ascent, descent, leading, and

width of the largest glyph in the font for the font, size, and style speci ed in the current
graphics port. FontMet rics returns this information in a font metrics record.

The font metrics record (of data type FMet ricRec) contains a handle to the global width
table, which in turn contains a handle to the associated font family resource for the
current font (the font in the current graphics port). It also contains the values of four
measurements for the current font.
Type

FMetricRec

=

RECORD

ascent:

Fixed;

descent:

Fixed;

leading:

Fixed;

widMax:

Fixed;

wlabHandle:

{ baseline to top}
{ baseline to bottom}
{ leading between lines}
{maximum

Handle;

{handle

glyph

to

width}

global

width

table}

END ;
Field descriptions

ascent

The measurement from the baseline to the ascent line of the font.

descent

The measurement from the baseline to the descent line of the font.

leading

The measurement from the descent line to the ascent line below it.

widMax

The width of the largest glyph in the font.

wlabHandle

A handle to the global width table.

You can determine the line height, in pixels, by adding the values of the ascent,
descent, and leading

elds of the font metrics record.

The FontMet rics procedure is similar to QuickDraw@ Get Font Info procedure,
except that FontMetrics returns fractional values for greater accuracy in
high-resolution printing. FontMetrics also does not take into account any additional
widths that are added by QuickDraw when it applies styles to the glyphs in a font.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the FontMetrics procedure is
Trap macro

_FontMetrics

SEE ALSO

The Get Font Info

procedure is described in the chapter GQQuickDraw TextOin this book.

Font Manager Reference

4-55

CHAPTER

4

Font Manager

OutlineMetrics
The Out lineMetrics function gets font measurements for a block of text to be drawn
ina speci ed outline font.
FUNCTION

OutlineMetrics

(byteCount:

Integer;

numer,denom:
VAR

yMax:

awArray:

UNIV

Ptr;

Point;

Integer;
FixedPtr;

boundsArray:

textPtr:
VAR

yMin:

lsbArray:

RectPtr):

Integer;
FixedPtr;

OSErr;

byteCount

The number of bytes in the block of text that you want measured.

textPtr

A pointer to the block of text that you want measured.

numer

The numerators of the vertical and horizontal scaling factors. The numer
parameter is of type Point, and contains two integers: the rst is the

numerator of the ratio for vertical scaling, and the second is the numerator

of the ratio for horizontal scaling. The Font Manager applies these scaling
factors to the current font in order to calculate the measurements for
glyphs in the block of text.

denom

The denominators of the vertical and horizontal scaling factors. The
denom parameter is of type Point, and contains two integers: the rst is
the denominator of the ratio for vertical scaling, and the second is the

denominator of the ratio for horizontal scaling. The Font Manager applies
these scaling factors to the current font in order to calculate the
measurements for glyphs in the block of text.
yMax
yMin
awArray

On output, this is the maximum y-value for the text. Pass NIL in this

parameter if you don@want this value returned.

On output, this is the minimum y-value for the text. Pass NIL in this

parameter if you don@want this value returned.
A pointer to an array that, on output, is

lled with the advance width

measurements for the glyphs being measured. These measurements are in
pixels, based on the point size and font scaling factors of the current font.
There is an entry in this array for each glyph that is being measured.
The awArray parameter is of type FixedPtr. The FixedPtr data type is

a pointer to an array, and each entry in the array is of type Fixed, which
is 4 bytes in length. Multiply byt eCount by 4 to calculate the memory
you need in bytes.
If the FractEnable global variable has been set to TRUE through the
Set FractEnabl1le procedure, the values in awArray have fractional
character widths. If FractEnable has been set to FALSE, the Font

Manager returns integer values for the advance widths, with 0 in the
decimal part of the values.

4-56

Font Manager Reference

CHAPTER

4

Font Manager

lsbArray

A pointer to an array that is,on output, led with the left-side bearing
measurements for the glyphs being measured. The measurements are in
pixels, based on the point size of the current font. There is an entry in this
array for each glyph that is being measured.
The lsbArray parameter is of type FixedPtr. The FixedPtr data type
is a pointer to an array, and each entry in the array is of type Fixed,
which is 4 bytes in length. Multiply byteCount by 4 to calculate the
memory you need in bytes.
Left-side bearing values are not rounded.

boundsArray

A pointer to an array that is, on output, lled with the bounding boxes for
the glyphs being measured. Bounding boxes are the smallest rectangles
that t around the pixels of the glyph. There is an entry in this array for
each glyph that is being measured.
The coordinate system used to describe the bounding boxes is in pixel
units, centered at the glyph origin, and with a vertical positive direction
upwards, which is the opposite of the QuickDraw vertical orientation.
The boundsArray parameter is of type Rect Ptr. The Rect Ptr data
type is a pointer to QuickDraw@ Rect data type, which is 8 bytes in
length. Multiply byteCount by 8 to calculate the memory you need in
bytes. Allocate the memory needed for the array and pass a pointer to the
array in the boundsArray parameter.

DESCRIPTION

The Out lineMet rics function computes the maximum y-value, minimum y-value,
advance widths, left-side bearings, and bounding boxes for a block of text. It uses the
font, size, and style speci ed in the current graphics port. You can use these
measurements when laying out text. You may need to adjust line spacing to
accommodate exceptionally large glyphs.
The Out lineMetrics function works for outline fonts only and is the preferred method
for measuring text that is drawn with an outline font.
When you are using Out lineMet rics to compute advance width values, left-side
bearing values, or bounding boxes, you need to bear in mind that when a text block
contains 2-byte characters, not every byte in the awArray, lsbArray, and boundsArray
structures is used. Each of these arrays is indexed by the glyph index; thus, if you have
ve characters in a string and two of them are 2-byte characters, only the rst ve entries
in each array contains a value. Call the CharByte function (described in the chapter
(Script ManagerOin this book) to determine how many characters there are in the text
block, and ignore the unused array entries (which occur at the end of each array).
If you don®@want Out lineMetrics to compute one of these three values, pass NIL in
the applicable parameter. Otherwise, allocate the amount of memory needed for the array
and pass a pointer to it in this parameter.

Font Manager Reference

4-57

CHAPTER

4

Font Manager

ASSEMBLY-LANGUAGE INFORMATION
The trap macro and selector for the Out
Trap macro

Selector

_FontDispatch

$7008

lineMetrics procedure are

SEE ALSO
The terms used for measuring text, including advance width, left-side bearing, and
bounding box, are described in the section CFont Measurements,Owhich begins on
page 4-8. Scaling of fonts and the use of the font scaling factors are described in the
section CHow the Font Manager Scales Fonts,Owhich begins on page 4-19.
Enabling Fractional Glyph Widths
The Set FractEnable procedure enables or disables fractional glyph widths. When
fractional glyph widths are enabled, the Font Manager can determine the locations of
glyphs more accurately than is possible with integer widths, as described in the section
CHow the Font Manager Calculates Glyph WidthsOon page 4-23.

SetFractEnable
The Set FractEnable procedure enables or disables fractional glyph widths.
PROCEDURE
fractEnable

SetFractEnable

(fractEnable:

Boolean) ;

Speci es whether fractional widths or integer widths are to be used to
determine glyph measurements. A value of TRUE indicates fractional
glyph widths; a value of FALSE indicates integer glyph widths.

DESCRIPTION

The Set FractEnable procedure establishes whether or not the Font Manager provides
fractional glyph widths to QuickDraw, which then uses them for advancing the pen
during text drawing. If you set the fract Enable parameter to TRUE, the Font Manager
provides fractional glyph widths. If you set it to FALSE, the Font Manager provides
integer glyph widths.
The Set FractEnable procedure assigns the value that you specify in the
fractEnable parameter to the global variable FractEnable.
The Font Manager defaults to integer widths to ensure compatibility with existing
applications.

4-58

Font Manager Reference

CHAPTER

4

Font Manager

Disabling Font Scaling
The Set FScaleDisable procedure enables or disables font scaling of bitmapped
glyphs. When font scaling is enabled, the Font Manager can scale a bitmapped glyph that
is present in the System le to imitate the appearance of a bitmapped glyph in another
point size that is not present. For more information about scaling of bitmapped fonts, see
(Lhe Scaling Process for a Bitmapped FontOon page 4-22.

SetFScaleDisable
The Set FScaleDisable procedure enables or disables the computation of font scaling
factors by the Font Manager for bitmapped glyphs.
PROCEDURE

SetFScaleDisable

fontScaleDisable

Speci

(fontScaleDisable:

Boolean);

es whether bitmapped fonts are to be scaled. A value of TRUE

indicates that font scaling is disabled; a value of FALSE indicates that font

scaling is enabled.

DESCRIPTION

The Set FScaleDisable procedure establishes whether or not the Font Manager
computes font scaling factors for bitmapped fonts. If you set the fontScaleDisable
parameter to TRUE, the Font Manager disables font scaling, which means it responds to a
request for a font size that is not available by computing font scaling factors of 1/1 and
returning a smaller, unscaled bitmapped font with the widths of the requested size. If you
set the fontScaleDisable parameter to FALSE, the Font Manager computes scaling
factors for bitmapped fonts.
QuickDraw performs the actual scaling of glyph bitmaps for bitmapped fonts by using
the font scaling factors computed and returned by the Font Manager.
As a default, the Font Manager scales fonts to ensure compatibility with existing
applications.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the

Set FScaleDisable procedure is

Trap macro

_SetFScaleDisable

Font Manager Reference

4-59

CHAPTER

4

Font Manager

Favoring Outline Fonts Over Bitmapped Fonts
The SetOut linePreferred procedure causes either outline fonts or bitmapped fonts
to be favored when the Font Manager receives a font request. You can use the
GetOutlinePreferred function to nd out whether outline or bitmapped fonts are
currently favored. You can use the IsOut line function to nd out if the font used in the
current graphics port is an outline font.

SetOutlinePreferred
The SetOut linePreferred procedure sets the preference for whether to use
bitmapped or outline fonts when both kinds of fonts are available.
PROCEDURE

SetOutlinePreferred

(outlinePreferred:

Boolean) ;

outlinePreferred

Speci es whether the Font Manager chooses an outline font or a
bitmapped font when both are available to ll a font request. A value
of TRUE indicates an outline font; a value of FALSE indicates a

bitmapped font.

DESCRIPTION

If an outline font and a bitmapped font are both available for a font request, the default
behavior for the Font Manager is to choose the bitmapped font, in order to maintain
compatibility with documents that were created on computer systems on which outline
fonts were not available. The SetOut linePreferred procedure sets the Font
Manager@ current preference for either bitmapped or outline fonts when both are
available. If you want the Font Manager to choose outline fonts over any bitmapped font
counterparts, set the out linePreferred parameter to TRUE; if you want it to choose
bitmapped fonts, set the out LinePreferred parameter to FALSE.
If only outline fonts are available, the Font Manager chooses them regardless of the
setting of out linePreferred; if only bitmapped fonts are available, they are
chosen. The Font Manager chooses bitmapped versus outline fonts on a size basis,
before it takes stylistic variations into account, which can lead to unexpected results.

For further information, see CHow the Font Manager Responds to a Font Request,O
beginning on page 4-17.

The preference you set is valid only during the current session with your application. The
outlinePreferred parameter does not set a global variable.

4-60

Font Manager Reference

CHAPTER

4

Font Manager

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the SetOut linePreferred procedure are
Trap macro

Routine selector

_FontDispatch

$7001

GetOutlinePreferred
The GetOut linePreferred function determines whether outline or bitmapped fonts
are to be favored when the Font Manager receives a font request.
FUNCTION

GetOutlinePreferred:

Boolean;

DESCRIPTION

The GetOut linePreferred function returns the value of the Font Manager@
current preference for outline or bitmapped fonts. If GetOut linePreferred returns
TRUE, then the Font Manager chooses the outline font when both an outline font and a
bitmapped font are available for a particular request. If GetOut linePreferred
returns FALSE, then the Font Manager chooses the bitmapped font when both types
are available.
Use the SetOut

ASSEMBLY-LANGUAGE

linePreferred procedure to change this preference.

INFORMATION

The trap macro and routine selector for the GetOut linePreferred function are
Trap macro

Routine selector

_FontDispatch

$7009

IsOutline
The IsOut line function determines if the Font Manager chooses an outline font for the
current graphics port to meet the speci ed scaling factors.
FUNCTION

numer

IsOutline

(numer:

Point;

denom:

Point):

Boolean;

The numerators of the vertical and horizontal scaling factors. The numer
parameter is of type Point, and contains two integers: the rst is the

numerator of the ratio for vertical scaling, and the second is the numerator
of the ratio for horizontal scaling.

Font Manager Reference

4-61

CHAPTER

4

Font Manager

denom

The denominators of the vertical and horizontal scaling factors. The
denom parameter is of type Point, and contains two integers: the rst is
the denominator of the ratio for vertical scaling, and the second is the

denominator of the ratio for horizontal scaling.

DESCRIPTION

The IsOutline function returns TRUE if the Font Manager would choose an outline font
for the current graphics port. The Font Manager uses the font scaling factors speci ed in
the numer and denom parameters, as well as the current preference (as set by the
SetOutlinePreferred procedure) to make a decision as to which font to use.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the
Trap macro

Routine selector

_FontDispatch

$7000

IsOut 1 ine function are

Scaling Outline Fonts
The Set PreserveGlyph procedure determines whether a glyph from an outline font is
displayed as designed or whether the Font Manager scales the glyph tot between the
ascent and descent lines. These two behaviors are discussed in (Preserving the Shapes of
GlyphsOon page 4-35. You can use the Get PreserveGlyph function to nd out whether
glyphs from outline fonts are to be scaled.

SetPreserveGlyph
The default behavior for the Font Manager is to scale a glyph from an outline font so that
it

ts between the ascent and descent lines; however, this alters the appearance of the

glyph. The Set PreserveGlyph procedure changes this behavior temporarily so that the
Font Manager does not scale oversized glyphs.
PROCEDURE

SetPreserveGlyph

preserveGlyph

(preserveGlyph:

Boolean) ;

Speci es whether or not glyphs from an outline font are scaled to
between the ascent and descent lines.

4-62

Font Manager Reference

t

CHAPTER

4

Font Manager

DESCRIPTION

The Set PreserveGlyph procedure establishes how the Font Manager treats glyphs that
donot t between the ascent and descent lines for the current font. If you set the value of
the preserveGlyph parameter to TRUE, the measurements of all glyphs are preserved,
which means that your application may have to alter the leading between lines in a
document if some of the glyphs extend beyond the ascent or descent lines. If you set the
value of the preserveGlyph parameter to FALSE, all glyphs are scaled to t between
the ascent and descent lines.
You can determine the current behavior of the Font Manager in this regard by calling the
Get PreserveGlyph function. To ensure that documents have the same appearance
whenever they are opened, you need to call Get PreserveGlyph and save the value that
it returns with your documents and restore it each time a document is displayed by your
application.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the
Trap macro

Routine selector

_FontDispatch

S700A

Set PreserveGlyph procedure are

GetPreserveGlyph
The Get PreserveGlyph function determines whether the Font Manager preserves the
shapes of glyphs from outline fonts.
FUNCTION

GetPreserveGlyph:

Boolean;

DESCRIPTION

The

Get PreserveGlyph function returns a Boolean value indicating whether the Font

Manager preserves the shapes of glyphs from outline fonts. Your application can set the
value of this variable with the Set PreserveGlyph procedure. If Get PreserveGlyph

returns TRUE, the Font Manager preserves glyph shapes; if Get PreserveGlyph returns
FALSE, then the Font Manager scales glyphs tot between the ascent and descent lines
for the font in use.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the
Trap macro

Routine selector

_FontDispatch

S700B

Font Manager Reference

Get PreserveGlyph function are

4-63

CHAPTER

4

Font Manager

Accessing Information About a Font
The FMSwapFont function gets a handle to a font, and some information about that font.

It is used extensively by system software to access fonts.

FMSwapFont
The FMSwapFont function returns a handle to a font and information about that font.

This function is used by QuickDraw and other parts of the system software to access
font handles.
FUNCTION

inRec

FMSwapFont

(inRec:

FMInput):

FMOutPtr;

A font input record, which contains the font family ID, the style requested,
scaling factors, and other information.

DESCRIPTION

The FMSwapFont function takes a font request and returns a pointer to a font output
record. FMSwapFont is the heart of the Font Manager: it does all of the hard work of
preparing font data for text measuring and text drawing.
The inRec parameter speci es the characteristics of the font that is requested.
QuickDraw Ilsinthe elds of the CurFmInput global variable and passes that record in
this parameter.
The font output record contains a handle to a font resource that ful lls the font request,
along with information about the font, such as the ascent, descent, and leading

measurements. You supply the FMSwapFont function with the font request in the inRec
parameter, using a font input record, and the Font Manager returns the font handle and
the other information in a font output record.
QuickDraw calls the FMSwapFont function every time a QuickDraw text routine is used.
If you want to call the FMSwapFont function in order to get a handle to a font resource or
information about that font, you must build a font input record and then use the pointer
returned to access the resulting font output record.
You cannot assume that the font resource pointed to by the fontHandle eld of the font
output record returned by this function is of any particular type, such as 'NFNT' or
'sfnt'. If you need to access speci

Manager procedure GetResInfo
determine the font resource type.

c information in the font resource, call the Resource

with the handle returned in the font output record to

IMPORTANT

The pointer to the font output record returned as the value of
FMSwapFont points to a record allocated in low memory by the Font
Manager. The same record is reused for each call made to FMSwapFont.
Do not free the memory allocated for this record. «

4-64

Font Manager Reference

CHAPTER

4

Font Manager

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the FMSwapFont function is
Trap macro
_FMSwapFont

SEE ALSO

For more information about the font input record, see How QuickDraw Requests a
FontOon page 4-16. For more information about the font output record, see
CHow the Font Manager Responds to a Font RequestOon page 4-17. For descriptions
of the records themselves, see (The Font Input RecordOon page 4-40 and (Ihe Font
Output RecordOon page 4-41.
The Get ResInfo

procedure is described in the Resource Manager chapter in

Inside Macintosh: More Macintosh Toolbox.

Handling Fonts in Memory
The Font Manager provides two routines that allow you to manipulate fonts in memory.
The Set Font Lock procedure makes a font resource, which is normally purgeable data
in memory, unpurgeable. The FlushFonts function erases the Font Manager@ memory
caches, including resource data and any width tables the Font Manager may have built.

SetFontLock
The Set Font Lock procedure makes the most recently used font unpurgeable. You can
use this procedure when you want a font to remain in memory for the sake of ef ciency.
PROCEDURE

SetFontLock

lockFlag

Speci

(lockFlag:

Boolean) ;

es whether or not the current font is considered purgeable.

DESCRIPTION

If you set the lockFlag parameter to TRUE, the Set Font Lock procedure makes the
most recently used font resource unpurgeable, and reads it into memory if it isn®already
there. If you set the lockFlag parameter to FALSE, the Set Font Lock procedure
releases the memory occupied by the most recently used font by calling the
ReleaseResource procedure.
The font considered to be the most recently used is the one referenced by the font output
record in low memory, whichis Iled in by the FMSwapFont function. This is often, but
not always, the font in which text has most recently been drawn. Since both QuickDraw
and your application program can call FMSwapFont, you have to be careful about which

Font Manager Reference

4-65

CHAPTER

4

Font Manager

font has most recently been used in a call to that function. To ensure that you are locking
the font that you want to lock, explicitly call FMSwapFont immediately before calling
SetFontLock.

ASSEMBLY-LANGUAGE INFORMATION
The trap macro for the

Set Font Lock procedure is

Trap macro

_SetFontLock

SEE ALSO

The ReleaseResource procedure is described in the chapter CResource ManagerOin
Inside Macintosh: More Macintosh Toolbox.

FlushFonts
The FlushFonts function erases the Font Manager@ memory caches.
FUNCTION

FlushFonts:

OSErr;

DESCRIPTION

The FlushFonts function erases all of the Font Manager@ memory caches. Your
application doesn@need this function unless it directly manipulates data in the outline
font resource. Font Manager caches include the width tables, the bitmaps created from
the outlines of the outline font resource, the calculations for the outlines, and a small

cache of font family resources that have been read into memory.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the FlushFonts function are
Trap macro

Routine selector

_FontDispatch

S$700C

The Bitmapped Font (‘NFNT') Resource
The bitmapped font ('NFNT') resource describes a bitmapped fontN a font whose glyphs
are represented by bit images. The structure of the bitmapped font resource is identical to
that of the older 'FONT' resource, which can be used for bitmapped fonts as well;
however, the bitmapped font resource has a more fSexible ID numbering scheme and is
preferred over the 'FONT' resource.

4-66

Font Manager Reference

CHAPTER

4

Font Manager

The bitmapped font resource consists of a header component, which describes the font,
and a glyph data information component, which contains the de nitions of the glyphs in
the font. The header component of this resource is represented by the FontRec data
type, the declaration of which is shown in the section rhe Font Record,Obeginning on
page 4-46. The structure of this resource is shown in Figure 4-16.
Figure 4-16

The bitmapped font ('NFNT')

Bytes

—

Font header —
component

Font type

2

First character code

2

Last character code

2

Maximum width

2

Maximum kerning

2

Negated descent value

2

Font rectangle width

2

Font rectangle height

2

Offset to width/oftset table

2

Maximum

QN
(

Glyph data +

component

resource

ascent

2

Maximum descent

2

Leading

2

Bit image row width

2

Z

Bit image table

/ Variable

Z

Bitmap location table

/ Variable

Z

Width offset table

/ Variable

Z

Glyph-width table

/ Vatiable

4

Image height table

4 Variable

QQ

Font Manager Reference

4-67

CHAPTER

4

Font Manager

The bitmapped font header component consists of the elements listed below, each of
which corresponds toa _ eldin the FontRec data type.
m Font type. An integer value that is used to specify the general characteristics of the
font, such as whether it is xed-width or proportional, whether the optional
image-height and glyph-width tables are attached to the font, and information about
the font depth and colors. This value is represented by the fontType eld inthe
FontRec data type. For the meaning of the bits in this eld, see
he Font Type
ElementOon page 4-70.
m First character code. An integer value that speci es the ASCII character code of the
rst glyph in the font. This value is represented by the firstChar eld in the
FontRec data type.
m Last character code. An integer value that speci es the ASCII character code of
the last glyph in the font. This value is represented by the lastChar eld in the
FontRec data type.
mw Maximum width. An integer value that speci

es the maximum width of the widest

glyph in the font, in pixels. This value is represented by the widMax

FontRec data type.

eld in the

mw Maximum kerning. An integer value that speci es the distance from the font
rectangle@ glyph origin to the left edge of the font rectangle, in pixels. If a glyph in the
font kerns to the left, the amount is represented as a negative number. If the glyph
origin lies on the left edge of the font rectangle, the value of the kernMax eld is 0.
This value is represented by the kernMax eld in the FontRec data type.
m Negated descent value. If this font has very large tables and this value is positive, this
value is the high word of the offset to the width/ offset table. For more information, see
(The Offset to the Width/Offset TableOon page 4-71. If this value is negative, it is the
negative of the descent and is not used by the Font Manager. This value is represented
by the nDescent eld inthe FontRec data type.
m Font rectangle width. An integer value that speci es the width, in pixels, of the image
created if all the glyphs in the font were superimposed at their glyph origins. This
value is represented by the fRectWidth eld inthe FontRec data type.
m Font rectangle height. An integer value that speci es the height, in pixels, of the image
created if all the glyphs in the font were superimposed at their glyph origins. This
value equals the sum of the maximum ascent and maximum descent measurements
for the font. This value is represented by the fRectHeight eldinthe FontRec
data type.
m Offset to width/offset table. An integer value that speci

es the offset to the offset/

width table from this point in the font record, in words. If this font has very large

tables, this value is only the low word of the offset and the negated descent value is
the high word, as explained in the section (rhe Offset to the Width/ Offset TableOon
page 4-71. This value is represented by the owI[Loc_ eld in the FontRec data type.

4-68

Font Manager Reference

CHAPTER

4

Font Manager

Maximum ascent. An integer value that speci es the maximum ascent measurement
for the entire font, in pixels. The ascent is the distance from the glyph origin to the top
of the font rectangle. This value is represented by the ascent eld in the FontRec
data type.
Maximum descent. An integer value that speci es the maximum descent measurement
for the entire font, in pixels. The descent is the distance from the glyph origin to the
bottom of the font rectangle. This value is represented by the descent eld in the
FontRec data type.
Leading. An integer value that speci es the leading measurement for the entire font, in
pixels. Leading is the distance from the descent line of one line of single-spaced text to
the ascent line of the next line of text. This value is represented by the leading eld
in the FontRec data type.
Bit image row width. An integer value that speci es the width of the bit image, in
words. This is the width of each glyph@ bit image as a number of words. This value is
represented by the rowWords eld in the FontRec data type.
The glyph data component of the bitmapped font resource consists of
describe the glyphs in the font.

ve tables that

Bit image table. The bit image of the glyphs in the font. The glyph images of every
de ned glyph in the font are placed sequentially in order of increasing ASCII code.
The bit image is one pixel image with no unde _ ned stretches that has a height given
by the value of the font rectangle element and a width given by the value of the bit
image row width element. The image is padded at the end with extra pixels to make
its length a multiple of 16.
Bitmap location table. For every glyph in the font, this table contains a word that
speci es the bit offset to the location of the bitmap for that glyph in the bit image table.
If a glyph is missing from the font, its entry contains the same value for its location as
the entry for the next glyph. The missing glyph is the last glyph of the bit image for
that font. The last word of the table contains the offset to one bit beyond the end of the
bit image. You can determine the image width of each glyph from the bitmap location
table by subtracting the bit offset to that glyph from the bit offset to the next glyph in
the table.
Width/

offset table. For every glyph in the font, this table contains a word with

the glyph offset in the high-order byte and the elyph@ width, in integer form, in the
low-order byte. The value of the offset, when added to the maximum kerning

value for the font, determines the horizontal distance from the glyph origin to the left
edge of the bit image of the glyph, in pixels. If this sum is negative, the glyph origin
is to the right of the glyph image@ left edge, meaning the glyph kerns to the left.
If the sum is positive, the origin is to the left of the image@ left edge. If the sum equals
zero, the glyph origin corresponds with the left edge of the bit image. Missing glyphs
are represented by a word value of 1. The last word of this table is also 1,
representing the end.

Font Manager Reference

4-69

CHAPTER

4

Font Manager

m Glyph-width table. For every glyph in the font, this table contains a word that speci
the elyph@

xed-point glyph width at the given point size and font style, in pixels.

es

The Font Manager gives precedence to the values in this table over those in the font
family glyph-width table. There is an unsigned integer in the high-order byte and a
fractional part in the low-order byte. This table is optional.
m Image height table. For every glyph in the font, this table contains a word that speci

the image height of the glyph, in pixels. The image height is the height of the glyph

es

image and is less than or equal to the font height. QuickDraw uses the image height
for improved character plotting, because it only draws the visible part of the glyph.
The high-order byte of the word is the offset from the top of the font rectangle of the
rst non-blank (or nonwhite) row in the glyph, and the low-order byte is the number
of rows that must be drawn. The Font Manager creates this table.

The Font Type Element
The font type element of the bitmapped font resource is represented as the font Type
eld in the FontRec data type. This integer eld de nes the general characteristics of the
font and records whether certain tables are present. Its bits are used as follows.
Bit

Meaning

0

This bit is set to 1 if the font resource contains an image height table.

1

This bit is set to 1 if the font resource contains a glyph-width table.

23

These two bits de ne the depth of the font. Each of the four possible values
indicates the number of bits (and therefore, the number of colors) used to

represent each pixel in the glyph images.
Value

Font depth

Number of colors

0

1-bit

1

1

2-bit

4

2

4-bit

16

3

8-bit

256

Normally the font depth is 0 and the glyphs are speci ed as monochrome
images. If bit 7 of this eld is set to 1, a resource of type 'fctb' with the same
ID as the font can optionally be provided to assign RGB colors to speci c
pixel values.
If this font resource is a member of a font family, the settings of bits 8 and 9 of
the fontStyle eld in this font@ association table entry should be the same as
the settings of bits 2 and 3in the

fontType

(The Font Association TableOon page 4-95.
46

eld. For more information, see

Reserved. Should be set to 0.
This bit is set to 1 if the font has a font color table ('fctb') resource. The font

is for color Macintosh computers only if this bit is set to 1.

4-70

Font Manager Reference

CHAPTER

4

Font Manager

Bit

Meaning

8

This bit is set to 1 if the font is a synthetic font, created dynamically
from the available font resources in response to a certain color and screen depth
combination. The font is for color Macintosh computers only if this bit
is set to 1.

9

This bit is set to 1 if the font contains colors other than black. This font is for

10 11

Reserved. Should be set to 0.

12

Reserved. Should be set to 1.

13

This bit is set to 1 if the font describes a

14

This bit is set to 1 if the font is not to be expanded to match the screen depth.
The font is for color Macintosh computers only if this bit is set to 1. This is for
some fonts, such as Kanji, which are too large for synthetic fonts to be effective
or meaningful, or bitmapped fonts that are larger than 50 points.

15

Reserved. Should be set to 0.

color Macintosh computers only if this bit is set to 1.

xed-width font, and is set to 0 if the

font describes a proportional font. The Font Manager does not check the setting
of this bit.

The Offset to the Width/Offset Table
The offset to the width/ offset table element of the bitmapped font resource is represented
as the owtLoc_ eldin the FontRec data type. This eld de nes the offset from the
beginning of the resource to the beginning of the width/offset table.
The value of nDescent, when positive, is used as the high-order 16 bits in the 32-bit

value that is used to store the offset of the width table from the beginning of the resource.
To compute the actual offset, the Font Manager uses this computation:
actualoOffsetWord

:=

BSHL(nDescent,

16)

+

owTLoc;

If the value of nDescent is negative, it is still the negative of the descent measurement,
as it was in the original usage of these values; however, the Font Manager no longer
uses this value.
Note
This eld was originally de ned as an integer value, because it was not
foreseen that this value could exceed 32 KB. The negated descent
element, represented in the nDescent eld of the Font Rec data type,
was created purely for the convenience of the Font Manager. It stored the
negative of the value of the descent eld, which is always positive by

QuickDraw convention. When the depth of fonts increased, the values of
the owTLoc.
eld had to increase, and the extra bits needed to be stored

somewhere. Since the nDescent eld was created as a convenience, it
was a handy place to store more information. @

Font Manager Reference

4-71

CHAPTER

4

Font Manager

The Outline Font ('sfnt') Resource
The outline font ('sfnt') resource, which describes a TrueType outline font, consists of a
sequence of tables that contain the data necessary for drawing the glyphs of the font,
measurement information about the font, and any instructions that the font designer
might include. These tables can appear in any order in the resource. Some of the tables
are required, such as the description of the font@ glyphs, and others are optional, such as
kerning information. TrueType outline fonts are available on platforms other than the
Macintosh computer, and some tables refsect the variety of information needed for these
different operating systems. A table directory at the beginning of the outline font resource
contains a version number and keys to access the tables.
Note
There are no data type de nitions of the outline font resource tables and
there areno_ elds, although the divisions of the tables are referred to as
fields in this chapter. You must access the data using the routines and
data structures that are described in this chapter or write table-speci c
code. Listing 4-2 beginning on page 4-76 shows how to read the contents
of the various tables.
The Font Manager uses some of the tables de ned for the outline font resource to
construct the font@ glyphs or to store the font designer@ information about creating
bitmaps from the font data. Developers of general-purpose applications do not need
these tables; consequently, the internal speci cations of these tables are not provided in
this chapter, although descriptions of their functions are. The needs of platforms other
than the Macintosh computer are also not discussed.
Some of the terms used in descriptions of these tables pertain solely to the font designer@
creation of the font. The em square is the imaginary area on which the glyphs of the font
are rst designed. The term units per em describes the resolution of the grid; the greater
the number of units per em, the ner the detail of design that the designer can achieve.
Apple@ TrueType fonts use a resolution of 2048 units per em. The measurement pixels
per em describes the relationship of the point size to the em square; the units per em
measurements of the font are translated, using this pixels per em measurement, into
bitmaps. The Font Manager handles this translation for you.
Similarly, the instruction set is for the use of the font designer only and cannot be used or
altered by the Font Manager routines, and so is not included in this chapter. If you want
the complete description of all of the tables in the outline font resource, consult the
TrueType Font Format Specification.

4-72

Font Manager Reference

CHAPTER

4

Font Manager

Each table in the outline font resource is aligned on a longword boundary in memory
(long-aligned) and may have been padded when necessary to make it long-aligned. Each
table is named with a four character identi er known as its tag name. The only table that
does not have a tag name is the font directory table. This table is a guide to the contents
of the resource and is mandatory in all outline font resources.
Note
Detailed descriptions of many of the values in the outline font resource
tables are found in the TrueType Font Format Specification and are not
repeated in this chapter. If you are designing a font editor or similar
application that requires detailed knowledge of these tables, please refer
to that book. @
These are the required tables in the outline font resource:
Tag name

Table

(none)

Font directory

'cmap'

Character code mapping table

'glyf'

Glyph data table

'head'

Font header table

'hhea'

Horizontal header table

'hmtx'!

Horizontal metrics table

'loca'

Location table

'maxp'

Maximum pro

'name!

Font-naming table

'post!

PostScript table

le table

Some of the optional tables in the 'sfnt' resource are
Tag

'oevt

Table

'

Control-value table

'fpgm'

Font program table

"hdmx'

Horizontal device metrics table

'kern!

Kerning table

'prep'

Preprogram (control value program) table

Font designers can de ne additional tables for the outline font resource to support other
platforms where outline fonts are available or to provide for future expansion of a font.
Tag names consisting of all lowercase letters are reserved for use by Apple Computer, Inc.

Font Manager Reference

4-73

CHAPTER

4

Font Manager

The Font Directory
The font directory is a guide to the tables in the outline font resource. It provides you
with the information that is needed to ef ciently nd the other parts of the resource. Each
table in the resource has a tag name, a checksum, a location that is de

ned as an offset in

bytes from the rst byte of the resource, and a length in bytes. To use the data in a table,
you rst nd the table@ tag name in the font directory and then access its data starting at
the speci ed location.
The font directory consists of an offset component and a variable length array of
directory entries, as shown in Figure 4-17.

Figure 4-17

The font directory

Bytes
Version

Number of tables

Offset —
component

Search range
Entry selector

nia

Range shift
Tag name

Checksum

First —
directory
component

Oftset

Length

4

4-74

Font Manager Reference

CHAPTER

4

Font Manager

The font directory offset component speci es the number of tables in the resource (and
thus in the directory component). It contains several values that you can use to optimize
searching through the directory components for a tag name:
m Version. The version number of the font, given as a 32-bit
version 1.0 of any font, this number is $00010000.

=

xed point number. For

Number of tables. The number of tables in the outline font resource, not counting the

font directory or any subtables in the font. This is an unsigned integer value.

m Search range. An unsigned integer value that is used, along with the entry selector and
range shift values, to optimize a binary search through the directory.
m Entry selector. An unsigned integer value that is used, along with the search range and
range shift values, to optimize a binary search through the directory.
m Range shift. An unsigned integer value that is used, along with the search range and
entry selector values, to optimize a binary search through the directory.
The search range, entry selector, and range shift values are used together to construct a
binary search through the directory if it is too large for an ef cient sequential search.
Note, however, that most programs that access kerning data use a linear search and do
not make use of these values.
If a font does contain a large number of tables, you can perform a binary search
of the directory components. You use the range shift value as the initial position in the
directory to examine. Compare the tag name of the component at this position with
the one you are searching for. If the target tag name comes before the one you are
searching for, search from the beginning of the directory to the range shift position. If the
target name comes after the one you are searching for, search from that position to
the end of the directory.
The font directory table entries are sorted alphabetically by tag name. Each component
consists of the following elements:
m Tag name. The identifying name for this table, such as 'cmap'.
m Checksum. The checksum for this table, which is the unsigned sum of the long values
in the table. This number can be used to verify the integrity of the data in the table.
m Offset. The offset from the beginning of the outline font resource to the beginning of
this table, in bytes.

m Length. The length of this table, in bytes.

Font Manager Reference

4-75

CHAPTER

4

Font Manager

Listing 4-2 shows a function that determines the checksum of a given table.
Listing 4-2

Calculating the checksum of a given table

TYPE

LongPtr
FUNCTION

=

“LongInt;

MyCalcTableChecksum

(table:

LongPtr;

Ingth:

LongInt):

LongInt;

VAR
sum

:

mask:

LongInt;
LongInt;

BEGIN
sum

:=

0;

WHILE

Ingth

>

0

DO

IF

Ingth

>

3

THEN

sum

+

sum
ELSE

:=

BEGIN

table*

BEGIN

mask

sum

:=

:=

BitShift(SFFFFFFFF,

8

sum

mask) ;

+

BitAnd(table*,

table

:=

LongPtr(ord(table)

Ingth

:=

Ilngth

-

4;

:=

sum;

+

*

(4

-

Ingth));

4);

END;
END;

MyCalcTableChecksum
END;

The Character-Code Mapping Table
The character-code mapping table, with a tag name of 'cmap', maps character codes
(like ASCII codes) to glyph indexes. The glyph repertoire of an outline font is indexed
consecutively from zero to the number of glyphs in the font. The encoding method
selected by the font designer depends on the conventions used by the intended platform
and sometimes on other platform-speci c selectors, such as which script system is in use.
A font intended for use on multiple platforms with different conventions requires
multiple encoding tables; however, double-byte fonts require various special formats for
ef cient encoding. As a result, the 'cmap' table may contain multiple encoding
components, one for each supported encoding scheme, often in different formats.

4-76

Font Manager Reference

CHAPTER

4

Font Manager

Character codes that do not correspond to any glyph in the font should be mapped to
glyph index 0. At this location in the font there should be a special glyph representing a
missing character, which typically is a box (11). For more information on requirements for
character-to-glyph mapping, see the TrueType Font Format Specification.
In the simplest case, the character-code mapping table consists of a header component
and only one character-mapping format component, which includes an array of glyph
indexes. In other cases, there are several character-mapping components in the table.
The Control-Value Table
The control-value table, with a tag name of 'cvt

',is an optional table that can be used

by fonts that contain instructions. This table contains data (control values) used by the

instructions. Each entry in this table is 4 bytes long. The number of values in the table can
be computed by dividing the length of the table by 4. The length of the table is found in
the directory component for this table in the outline font resource directory.
The font directory is described in

he Font Directory,Obeginning on page 4-74.

The control-value program, which uses these values, is contained in the preprogram
table, which is described on page 4-89.
The Font Program Table
The font program table, with a tag name of 'fpgm', is an optional table that contains the
font program, a list of instructions that the Font Manager executes once, when it loads the
font into memory. The font program is a variable length sequence of bytes that are
interpreted by the Font Manager. The length of this table is found in the directory
component for this table in the outline font resource directory.
The font directory is described in

he Font Directory,Obeginning on page 4-74.

The Glyph Data Table
The glyph data table, with a tag name of 'glyf ', contains the data that de nes the
appearance of the glyphs in the font: the speci cation of points that make up the contours
of a glyph and the instructions that help change the shape of the glyph under various
conditions. Glyphs can be stored in any character-code mapping order, since the location
of the data for each is speci ed separately, through the character-code mapping table,
which is described beginning on page 4-76, and the location table, which is described on
page 4-84.

Font Manager Reference

4-77

CHAPTER

4

Font Manager

The data for each glyph consists of some descriptive information, as shown in
Figure 4-18, followed by the actual instructions and coordinate values that de ne the
glyph. The format of the de nition data for glyphs is described in the TrueType Font
Format Specification. Note that the glyph data is compressed.
Figure 4-18

A glyph description

Bytes

4

Number of contours

2

xMin

2

yMin

2

xMax

2

yMax

2

Glyph definition data

4

= Number of contours. If this integer value is positive, it speci es the number of closed
curves de ned in the outline data for the glyph. If itis 1, it indicates that the glyph is
composed of other simple glyphs (see the explanation of component glyphs in the
section (Phe Maximum Pro le TableObeginning on page 4-84).
m xMin. The left edge of the glyph@ bounding box, speci

ed in units per em.

m yMin. The top edge of the glyph@ bounding box, speci

ed in units per em.

m xMax. The right edge of the glyph@ bounding box, speci

ed in units per em.

m yMax. The bottom edge of the glyph@ bounding box, speci

ed in units per em.

m Glyph de nition data. The data that de nes the appearance of the glyph, as described
in the TrueType Font Format Specification.
The Horizontal Device Metrics Table
The horizontal device metrics table, with a tag name of 'hdmx', is an optional table that
stores integer advance widths scaled to pixel-per-em sizes for the Macintosh computer@
screen. The horizontal device metrics table is used only for certain screen sizes that are
determined by the font@ designer and only when fractional widths are disabled (as
described in GSetFractEnableOon page 4-58). This table contains ne-tuned integer
widths for the glyphs at low pixel-per-em values. These values can be used to reduce the
unpleasant consequences of rounding the widths for small point sizes at low resolution.

4-78

Font Manager Reference

CHAPTER

4

Font Manager

The Font Header Table
The font header table, with a tag name of 'head', is shown in Figure 4-19. This table
contains global information about the font: the font version number; creation and

modi cation dates; revision number; basic typographic data that applies to the font as a
whole, such as the direction in which the font@ glyphs are most likely to be written; and
other information about the placement of glyphs in the em square.
Figure 4-19

The font header table

Bytes
Version

Font revision

Checksum adjustment

Magic number
Flags

Units per em
Creation date

Modification date

xMin

yMin
xMax

yMax
Style
Smallest readable size
Font direction
Location table format

Glyph data format

Font Manager Reference

4-79

CHAPTER

4

Font Manager

For a complete description of the individual elds in this table, see the TrueType Font
Format Specification. Application developers may be interested in the following elds:
Version. The version number of the table, asa
$00010000 if the version number is 1.0.

Font revision.

xed-point value. This value is

A xed-point value set by the font designer.

Checksum adjustment. The checksum of the font, as an unsigned long integer.
Units per em. This unsigned integer value represents a power of 2 that ranges from
64 to 16,384. Apple@ TrueType fonts use the value 2048.
Creation date. The date this font was created. This is a long date-time value of data
type LongDateTime, which is a 64-bit, signed representation of the number of
seconds since Jan. 1, 1904.

Modi

cation date. The date this font was last modi

ed. This is a long date-time value

of data type LongDateTime, which is a 64-bit, signed representation of the number of
seconds since Jan. 1, 1904.

Smallest readable size. The smallest readable size for the font, in pixels per em.
The RealFont function, which is described in the section CRealFontObeginning on
page 4-52, returns FALSE for a TrueType font if the requested size is smaller than
this value.
Location table format. The format of the location table (tag name: 'loca'), as an
signed integer value. The table has two formats: if the value is 0, the table uses the

short offset format; if the value is 1, the table uses the long offset format. The location

table is described in the section (Lhe Location TableOon page 4-84.

You can use the value of the checksum adjustment element to verify the integrity of the
data in the font, to con rm that no data has been changed, or to compare two similar
fonts. This value is the designer@ checksum value for the font. The checksum value is an
unsigned long word that you compute as follows:
1. Set the value of the checksum word to 0 (so that it does not factor into the value that

you are computing).

. Calculate the checksum for each table in the outline font resource and store the table@

checksum in the table directory.

. Now sum the entire font as an unsigned, 32-bit value.
. Subtract the sum from $B1BOAFBA, which is a magic number for this checksum

computation. Store the result.

Listing 4-2 provides an example of a function to compute the checksum of a font. This
example includes type declarations for the outline font header information and uses the
MyCalcTableChecksum function (from Listing 4-2 on page 4-76) to compute the
checksum for each table.

4-80

Font Manager Reference

CHAPTER

4

Font Manager

Listing 4-3

Calculating the checksum of a font

TYPE

DirectoryEntry

=

RECORD

tag:

OSType;

checksum:
offset:

LongInt;
LongInt;

Ingth:

LongInt;

END ;

OffsetTable

=

RECORD
version:

LongInt;

numTables:

Integer;

searchRange:

Integer;

entrySelector:
rangeShift:
tableDir:

Integer;

Integer;
ARRAY[1..1]

OF

DirectoryEntry;

{ actually

1..numTables

}

END;

SfntPtr

=

“OffsetTable;

SfntHandle

=

HeaderTable

“SfntPtr;
=

RECORD

version:

LongInt;

fontRevision:

LongInt;

checkSumAdjustment:

magicNumber:
flags:

LongInt;

LongInt;

Integer;

unitsPerEm:

created:
modified:

Integer;

LongDateTime;

in

Script.p

}

LongDateTime;

xMin:

Integer;

yMin:

Integer;

xMax:

Integer;

yMax:

Integer;

macStyle:

{ defined

Integer;

Font Manager Reference

4-81

CHAPTER

4

Font Manager

lowestRecPPEM:

Integer;

fontDirectionHint:

Integer;

indexToLocFormat:
glyphDataFormat:

Integer;
Integer;

END;

HeaderTablePtr

FUNCTION

=

“HeaderTable;

CalcSfntChecksum

(sp:

SfntPtr):

LongInt;

CONST
checkSumMagic

=

$B1BOAFBA;

VAR

i:

Integer;

cs,

sum,

htp:

HeaderTableptr;

size:

LongInt;

BEGIN
sum

:=

0;

FOR

i

:=

IF

1

TO

sp*.numTables

sp*.tableDir[i].tag

DO

=

BEGIN

'head'

THEN

BEGIN

htp

:=

HeaderTablePtr(ord(sp)

+

sp*.tableDir[i]
htp*.checkSumAdjustment := 0;
cs

:=

.offset) ;

CalcTableChecksum(LongPtr(htp),

SizeOf

(HeaderTable)

) ;

END
ELSE

cs

:=

MyCalcTableChecksum (

LongPtr(ord(sp)

sp*.tableDir[i]
sp*.tableDir[i].checksum
sum

:=

sum

+

+

sp*.tableDir
[i] .offset),

.lngth) ;

:=

cs;

CS;

END;

Size

:=

SizeOf(OffsetTable)

(sp*.numTables
sum

:=

sum

+

be

written

END;

4-82

+

1)

* SizeOf(DirectoryEntry) ;

CalcTableChecksum(LongPtr(sp),

CalcSfntChecksum

{ to

-

Font Manager Reference

:=

into

checkSumMagic

-

size) ;

sum;

htp*.checkSumAdjustment

}

CHAPTER

4

Font Manager

The Horizontal Header Table
The horizontal header table, with a tag name of 'hhea', contains information needed to

lay out fonts whose glyphs are written horizontally (either left to right or right to left)
across a page. This table contains information that pertains to the font as a whole.
Information that pertains to speci c glyphs is given in the horizontal metrics table, which
is described in the next section
he Horizontal Metrics Table.O
The Horizontal Metrics Table
The horizontal metrics table, with a tag name of 'hmtx', consists of arrays that contain

metrics informationN the advance widths and left-side bearingsN for the horizontal
layout of each glyph in the font. The horizontal metrics table structure is shown in
Figure 4-20.

Figure 4-20

The horizontal metrics table

Bytes

First

horizontal
metrics
component

Advance width

2

Left-side bearing

2

7

Monospaced

left-side
bearing

7

Left-side bearings

variable

The rst component of the horizontal metrics table contains two values for each entry:
the advance width and the left-side bearing for the associated glyph. The number of
value pairs in this component is speci ed in the number of advance widths element of
the horizontal header table, which is described in the preceding section, (Phe Horizontal
Header Table.O
The horizontal metrics table may have a second component that is used for xed-width
glyphs. It contains the left-side bearings only. The advance width is the same as the last
entry inthe rst component of this table.

Font Manager Reference

4-83

CHAPTER

4

Font Manager

The Kerning Table
The kerning table, with a tag name of 'kern', is an optional table that contains the
values you can use to adjust the spacing between glyphs in a font. Kerning can be
parallel to the Sow of text or perpendicular to the Sow of text. For example, if you specify
perpendicular kerning and if text is normally read horizontally, the glyphs are kerned
vertically. Kerning is always applied to pairs of glyphs.
The kerning table in the outline font resource consists of a header and a series
of subtables. The TrueType Font Format Specification documents a basic set of kerning
subtables.
The Location Table
The location table, with a tag name of 'loca', stores the offsets to the locations of actual

glyph data in the outline font resource relative to the beginning of the glyph table. It
provides quick access to the data for a particular glyph. The location table is an array of
offset values, one for each glyph in the font, including the Oth or missing character glyph.
Offsets are stored in one of two forms: in the short format, each offset is a 16-bit

unsigned integer value that speci es the number of words from the beginning of the
glyph data table to the data for the glyph. In the long format, each offset is a 32-bit
unsigned integer value that speci es the number of bytes from the beginning of the
glyph data table to the data for the glyph. The format that is used for a font is speci ed
in the location table format element of the font header table, whose description begins on
page 4-79.
The Maximum

Pro

le Table

The maximum pro le table, with a tag name of 'maxp', establishes the memory
requirements for a font. Most of the information in this table is for the use of the
font@ designer, a font editor that may alter the makeup of the resource, or the
Font Manager itself.
Some of the elements in the maximum pro le table refer to simple versus component
glyphs. A simple glyph is one that is de ned asa single equation, such as an @O A
component glyph is a design that the font designer builds by adding a simple glyph to
another equation or by adding two glyphs together. For example, the glyph O»Ocan be
created as a single entity or as a component glyph: the simple glyph @Oplus the simple
glyph O’O In this way, a small set of simple glyphs can create a much larger set of
component glyphs. The font designer could also design the glyph O»Oas a simple glyph.
However, this leads to separate designs for O%&) GOO and so on. Some fonts distributed by

Apple use component glyphs and some do not.

For more information about this table, see the TrueType Font Format Specification.

4-84

Font Manager Reference

CHAPTER

4

Font Manager

The Font Naming Table
The font naming table, with a tag name of

'name', is shown in Figure 4-21. This table

contains multilingual strings associated with the outline font resource. These strings can
represent copyright notices, font names, style names, and so on, and each string is stored
in a separate record with some information about what kind of string it is. You may want
to provide this information in your application for the user, or you may want to use it to
check one version of a font against another.
Figure 4-21

The naming table

Bytes

Ve

Header —
component

First name —4
record

Format selector

2

Number of names

2

String area offset

2

Platform ID

2

Platform-specific ID

2

Language ID

2

Name ID

2

Length

2

Offset

2

Storage area

4

variable

The header component of the font naming table consists of the following elements:
m Format selector. The format selector (set to 0). This is an unsigned integer.
=

Number

of names. The number

unsigned integer.

of name records that follow. This is an

m String area offset. The offset from the start of the table to the start of string storage, in
bytes. This is an unsigned integer.

Font Manager Reference

4-85

CHAPTER

4

Font Manager

Each name record contains information about the platform and language of the strings
stored in the naming table.
m Platform ID. The platform identi
m Platform-speci

er.

c ID. The platform-speci

c encoding identi

er.

m Language ID. The language identi er.
m Name ID. The name identi

er.

m Length. The length of the string, in bytes.
m Offset. The offset from the start of storage area, in bytes.
The storage area at the end of the naming table contains the actual string data.
There is no length limit for the strings contained in a name record, but font designers
should not include empty strings (of byte length 0). The Font Manager sorts the entries in
the naming table rst by platform identi er, next by platform-speci c identi er, next by
language identi er, and last by name identi er.
To keep the size of this table small, a font designer may make a limited set of name
records in a small set of languages, because the font can be localized and the existing
strings translated or new strings added. Other parts of the outline font resource that need
these strings can refer to them by their index number, and applications that need a
particular string can look it up by its platform identi er, language identi er, and font
name identi er. Platform IDs are shown in Table 4-2, language identi
Table 4-4, and font name identi ers are shown in Table 4-5.

ers are shown in

TrueType outline fonts are available on other platforms besides the Macintosh computer,
which is why the font designer must specify the platform. There are only four prede ned
platform identi

Table 4-2

4-86

ers, listed in Table 4-2, and they use values 0 through 3.

Platform identifiers

ID

Platform

Specific encoding

0

Unicode

Reserved (set to 0)

1

Macintosh

The Script Manager code

2

ISO

ISO encoding

3

Microsoft

Microsoft encoding

240 255

User-de

ned

Font Manager Reference

Reserved for all nonregistered platforms

CHAPTER

4

Font Manager

When the platform used is the Macintosh computer, the platform-speci c identi er
names the speci c script code for this name record. The script codes de ned for the
Macintosh system software are listed in the chapter CScript ManagerOin this book.
The platform-speci
Table 4-3

c identi

er encodings for the ISO platform are listed in Table 4-3.

ISO platform-specific identifiers

Code

ISO encoding scheme

0

7-bit ASCII

1

ISO 10646

2

ISO 8859-1

The value of the language identi er speci es the language in which a particular
string is written. The language identi ers available on the Macintosh platform are
listed in Table 4-4.

Table 4-4

ISO language codes

Code

Language

Code

Language

0

English

12

Arabic

1

French

13

Finnish

2

German

14

Greek

3

Italian

15

Icelandic

4

Dutch

16

Maltese

5

Swedish

17

Turkish

6

Spanish

18

Yugoslavian

7

Danish

19

Chinese

8

Portuguese

20

Urdu

9

Norwegian

21

Hindi

10

Hebrew

22

Thai

11

Japanese

Font Manager Reference

4-87

CHAPTER

4

Font Manager

The font name identi
about the font.

Table 4-5

er values, listed in Table 4-5, contain the strings with information

Font name identifiers

Code

Meaning

Description

0

Copyright notice

The copyright notice of the fontN for example,
Copyright Apple Computer, Inc. 19920

1

Font family name

The font family name, such as New

2

Font style

The style of the font, such as CBoldO

3

Font
identi

A unique identi cation string for the fontN for example,
OApple Computer New York Bold version 1.00

4

Full font name

The font family name combined with the font style
nameN for example, ONew York BoldO

5

Version string

The version of the font, or when it was createdN for

6

PostScript name
of the font

Aname of this font that the PostScript printer driver can
recognizeN for example, CLimes-BoldO

7

Trademark

The trademark notice of the designer

8

Designer

Corporate name of the designer

cation

YorkO

example, August 10, 1991, 1.08d210

The full font name for a font family, given in string 4 of Table 4-5, is most often the same
as the family name, given in string 1. The default style for a family or the only font ina

family should have CRegularOin the font style string. (Font designers use the term
(RegularOto denote the plain style for a font, so as to reBect typographic terminology
more accurately.) One exception, based on historical convention, is when the full name of
a font includes the word CRomanO(e.g. Times Roman). In all other cases, the full name
should be made up of the family name and the style name, as in Bookman Bold.
The unique font identi cation consists of the designer@ name, followed by a space
serving as a separator, followed by the full name of the font. For example, though there
might be many Symbol fonts, the name OApple Computer SymbolOis unique. The use of
unique names allows applications to determine if the current system software has the
fonts used in the original document.

4-88

Font Manager Reference

CHAPTER

4

Font Manager

The PostScript Table
The PostScript table, with a tag name of 'post ', contains information needed to use an
outline font on a PostScript printer. It contains the PostScript names for all of the glyphs
in the font. It also contains memory information needed by the PostScript driver for
memory management. The PostScript table consists of a header component and an
optional format component, which is used only for two of the possible four PostScript
format types.
The header component of the PostScript table contains the memory requirements.
PostScript drivers can make better use of the Memory Manager if the virtual memory
requirements of an outline font that can be downloaded to the printer are known
beforehand. If the font designer does not know the virtual memory requirements, the
values for the memory use requirements of this font are set to zero.
The memory use of a downloaded outline font varies depending on whether it is de ned
as a TrueType or Adobe Type 1 font on the printer. You can compute the minimum
memory required for a font as follows:
1. Send the PostScript VMStatus call to the printer and store the result.
2. Download the font to the printer.
3. Send the VMStatus call again.
4. Subtract the rst result from the second to calculate the amount of memory that the
font requires.
The maximum memory required for a font is computed by adding the maximum
run-time memory use to the minimum memory value. The maximum run-time memory
use depends on the maximum band size of any bitmap that the outline font scaler might
have to create from an outline description.
The Preprogram Table
The preprogram table, with a tag name of 'prep', is an optional table that stores the
control value program. This is a set of outline font instructions that the Font Manager
executes before it creates any glyph and again whenever the user changes the point size,
the angle at which the font is being displayed, or the font itself. This table consists of an
ordered list of instruction opcodes, each of which is one byte long. Control values for the
instructions in the preprogram are found in the 'cvt ' table, which is described in
fhe
Control-Value TableOon page 4-77.

Font Manager Reference

4-89

CHAPTER

4

Font Manager

The Font Family (FOND') Resource
A font family contains references to the fonts (which can be bitmapped font
['NFNT'

], outline font ['sfnt'], or 'FONT'

resources) that make up the family

and information that describes the family as a whole, such as a global width table
for each available style.
The font family (' FOND ') resource contains general information about the font family,

the font association table, and a collection of optional tables: the family glyph-width
table, the style-mapping table, the kerning table, the offset table, and the bounding-box
table. Several data structures and routines use the font family resource. For example, the
global width table can use the font family information to nd the recommended glyph
widths and the LaserWriter printer driver can use tables that contain information about
kerning pairs and mapping of styles to printer fonts.
The font family resource consists of a header component, which contains general
information about the font family, and a font family tables component, which consists of
the font association table and some number (possibly zero) of the optional tables that
provide measurement and naming information about the font family. The header
component of this resource is represented by the FamRec data type, the declaration of
which is shown in the section (he Font Family RecordOon page 4-47. The structure of
this resource is shown in Figure 4-22.

4-90

Font Manager Reference

CHAPTER

4

Font Manager

Figure 4-22

The font family

('FOND')

resource

Bytes

—

Font family flags

2

Font family ID

2

Font family first character

2

Font family last character

2

Font family maximum ascent

2

Font family maximum descent

2

Font family maximum leading

2

Font family maximum glyph width

2

Offset to family glyph-width table

4

Offset to family kerning table

4

Offset to style-mapping table

4

Style properties

/ 18

Font family —
header
component

Z

4
International information
Version

a
=

Font family —
tables

component

2

Z

Font association table

/ vatiable

Z

Offset table

/ variable

Z

Bounding-box table

Z variable

Z

Family glyph-width table

/ Variable

Z

Style-mapping table

/ vatiable

4

Kerning table

4 variable

QL

Font Manager Reference

4-91

CHAPTER

4

Font Manager

The header component of the font family resource consists of a number of elements that
describe characteristics of the family. Each of the elements in this component is
represented by a eld in the FamRec data type.
Font family fags. An integer value, the bits of which specify general characteristics of
the font family. This value is represented by the f£Flags eld inthe FamRec data
type. The bits inthe

£fFlags_

eld have the following meanings:

Bit

Meaning

0

This bit is reserved by Apple and should be cleared to 0.

1

This bit is set to 1 if the resource contains a glyph-width table.

2 11

These bits are reserved by Apple and should be cleared to 0.

12

This bit is set to 1 if the font family ignores the value of the FractEnable
global variable when deciding whether to use xed-point values for stylistic
variations; the value of bit 13 is then the deciding factor. The value of the
FractEnable global variable is set by the Set FractEnable procedure.

13

This bit is set to 1 if the font family should use integer extra width for stylistic
variations. If not set, the font family should compute the xed-point extra
width from the family style-mapping table, but only if the FractEnable

global variable has a value of TRUE.

14

This bit is set to 1 if the family fractional-width table is not used, and is
cleared to 0 if the table is used.

15

This bit is set to 1 if the font family describes

to 0 if the font describes proportional fonts.

Font family ID. An integer value that speci

xed-width fonts, and is cleared

es the 'FOND' resource ID number

for this font family. This value is represented by the

ffFamID

eld in the FamRec

data

type.

Font family rst character. An integer value that speci es the ASCII character code of
the rst glyph in the font family. This value is represented by the ff£FirstChar eld
in the FamRec data type.
Font family last character. An integer value that speci es the ASCII character code of
the last glyph in the font family. This value is represented by the ffLastChar eldin
the FamRec data type.
Font family maximum ascent. The maximum ascent measurement for a one-point font
of the font family. This value is ina 16-bit xed-point format with an integer part in
the high-order 4 bits and a fractional part in the low-order 12 bits. This value is
represented by the ffAscent eld in the FamRec data type.
Font family maximum descent. The maximum descent measurement for a one-point
font of the font family. This value is in a 16-bit xed-point format with an integer part
in the high-order 4 bits and a fractional part in the low-order 12 bits. This value is
represented by the ffDescent eld inthe FamRec data type.

4-92

Font Manager Reference

CHAPTER

4

Font Manager

m

Font family maximum leading. The maximum leading for a 1-point font of the font

family. This value isin a 16-bit

xed-point format with an integer part in the

represented by the

eld in the FamRec data type.

high-order 4 bits and a fractional part in the low-order 12 bits. This value is
m

ffLeading

Font family maximum glyph width. The maximum glyph width of any glyph ina
one-point font of the font family. This value is in a 16-bit xed-point format with an

integer part in the high-order 4 bits and a fractional part in the low-order 12 bits. This
value is represented by the ffWidMax eld in the FamRec data type.
m Offset to family glyph-width table. The offset to the family glyph-width table from the
beginning of the font family resource to the beginning of the table, in bytes. The family
glyph-width table is described in the section
Phe Family Glyph-Width Table,O
beginning on page 4-98. This value is represented by the ff£TabOff eld inthe
FamRec data type.
m Offset to family kerning table. The offset to the beginning of the kerning table from the
beginning of the 'FOND' resource, in bytes. The kerning table is described in the
section Ohe Font Family Kerning Table,Obeginning on page 4-106. This value is

represented by the

ffKernOff

eld in the FamRec data type.

m Offset to family style-mapping table. The offset to the style-mapping table from
the beginning of the font family resource to the beginning of the table, in bytes. The
style-mapping table is described in the section (rhe Style-Mapping Table,Obeginning
on page 4-99. This value is represented by the ff£StyleOff eld inthe FamRec
data type.
m Style properties. An array of 9 integers, each indicating the extra width, in pixels, that
would be added to the glyphs of a 1-point font in this font family after a stylistic
variation has been applied. This value is represented by the ffProperty eldin the
FamRec data type, which is an array with nine values. The Font Manager multiplies
these values by the requested point size to get the correct width. Each value is ina
16-bit xed-point format with an integer part in the high-order 4 bits and a fractional
part in the low-order 12 bits. If the font with a given stylistic variation already exists as
an intrinsic font, the Font Manager ignores the value inthe ffProperty eld for that
style. The values in this array are used as follows:
Property

Meaning

1

Extra width for plain text. Should be set to 0.

NY
WD

Extra width for italic text.

SF

Extra width for underline text.

FF

Extra width for outline text.
Extra width for shadow text.

Oo

AN

Extra width for bold text.

BD

index

Extra width for condensed text.
Extra width for extended text.
Not used. Should be set to 0.

Font Manager Reference

4-93

CHAPTER

4

Font Manager

m International information. An array of 2 integers reserved for internal use by script
management software. This value is represented by the ffInt1l eld inthe FamRec
data type.
m Version. An integer value that speci es the version number of the font family resource,
which indicates whether certain tables are available. This value is represented by the
ff£Version eldinthe FamRec data type. Because this eld has been used
inconsistently in the system software, it is better to analyze the data in the resource
itself instead of relying on the version number. The possible values are
as follows:
Value

Meaning

$0000

Created by the Macintosh system software. The font family resource will not
have the glyph-width tables and the elds will contain 0.

$0001

Original format as designed by the font developer. This font family record
probably has the width tables and most of the elds are Iled.

$0002

This record may contain the offset and bounding-box tables.

$0003

= This record de nitely contains the offset and bounding-box tables.

The font family tables component of the font family resource contains a number of tables.
The font association table must be included in the resource, but the other tables are all

optional. You can determine whether or not the glyph-width, kerning, or style-mapping
tables are present by examining the offset value for each. Each offset value is a number of
bytes from the beginning of the resource to the table; an offset of 0 means that the table is
not present. For example, if the value of the ff£WTabOff eld is greater than 0, the
glyph-width table is present in the resource data.
Additional tables, including the bounding-box table, can be added to the font family

resource by a font designer. Whenever any table, including the glyph-width, kerning, and
style-mapping tables, is included in the resource data, an offset table is included. The
offset table contains a long integer offset value for each table that follows it.

The Font Style Code
A number of tables in the font family resource contain information that pertains only to a
certain style. Actually, a style can be a combination of styles. The style code data type,
which is used to represent a style in the tables in this resource, uses a single bit for each of
the seven Macintosh character styles. You can set any of these bits to 1 in the style code
element of a table to specify the unique style of the font to which that table applies.
Although each table that contains a font style code allocates 2 bytes for the value, only
the low-order byte of the value is used to specify the style code; the high-order byte is
used internally by the Font Manager. The values of the bits in a style code element are
shown in Figure 4-23.

4-94

Font Manager Reference

CHAPTER

4

Font Manager

Figure 4-23

Style codes

76543

LITT

210

tit]

ty

Ls

Bold

Italic
Underline
Outline
Shadow
Condense
Extend
(Reserved)

The Font Association Table
The font association table of the font family resource maps a point size and style into
aspeci c font that is part of the family. This table is represented by the fontAssoc eld
of the font family resource. This table, which is shown in Figure 4-24, matches a given

font size and style combination with the resource ID of a' FONT', bitmapped, or
outline resource.
Figure 4-24

The font association table

Bytes
Number of entries—1

2

Font size

2

First font

Font style

2

entry

Font ID

2

association

The font association table consists of an integer count and a variable number of font
association entries. The table is represented by the FontAssoc data type, which is shown
on page 4-47.
= Number of entries. An integer value that speci es the number of font association
records in this table minus 1. This value is represented by the numAssoc_ eld in the
FontAssoc data type.

Font Manager Reference

4-95

CHAPTER

4

Font Manager

Each font association entry is represented by the AsscEnt ry data type, which is shown
on page 4-48. The Font Manager looks rst for outline font resources, then bitmapped
font resources, then' FONT' resources. Entries are sorted according to point size, with the
smallest sizes coming rst in the table. The font size value for outline font resources is 0,
so they are always listed rst. Plain fonts are sorted before styled fonts. The elements of
each entry are:
m Font size. This integer value speci es the size of the font in points. This value is
represented by the fontSize eld of the AsscEntry data type.
m Font style. This integer value speci es the style code of the entry, as shown in Figure
4-23 on page 4-95. This value is represented by the fontStyle eld of the
AsscEntry data type.
m Font ID. This integer value speci es the resource ID of the related 'sfnt', 'NFNT', or
'FONT' resource. This value is represented by the fontID eld of the AsscEntry
data type.
Note
Bits 8 and 9 of the fontStyle eld of the font association table entry
specify the font depth. They need to contain the same values as bits 2
and 3 of the

describes. @

fontType

eld of the font resource that this entry

The Offset Table
The offset table is an optional table that is included in the font family resource whenever
any of the other optional tables are included. This table, which is shown in Figure 4-25,
allows the font designer to add more tables to the font family resource.
Figure 4-25

The offset table

Bytes

First offset

4-96

Font Manager Reference

Number of entries—1

2

Offset of table

4

CHAPTER

4

Font Manager

The offset table consists of an integer count and a variable number of table offset values,
each of which is 4 bytes long. There is no data type de ned for this table.
= Number of entries. An integer value that speci
table minus 1.

es the number of offset values in this

m Offset of table. A long integer value that speci
the offset table to the start of the table.

es the number of bytes from the start of

The Bounding-Box Table
The bounding-box table, shown in Figure 4-26, contains the bounding-box measurements
for a 1-point font. The bounding boxes used in this table are similar to
the font rectangle, since each describes the smallest rectangle that encloses the shape of
each glyph in a given font. There are separate bounding-box entries in the table
for different styles.
Figure 4-26

The bounding-box table

Bytes

_—

First —

bounding box

\Q

Number of entries—1

2

Bounding-box style

2

Bounding-box left

2

Bounding-box bottom

2

Bounding-box right

2

Bounding-box top

2

The bounding-box table consists of an integer count and a variable number of
bounding-box entries, each of which is 10 bytes long. There is no data type de ned
for this table.
m= Number of entries. An integer value that speci
in this table minus 1.

Font Manager Reference

es the number of bounding-box entries

4-97

CHAPTER

4

Font Manager

Each bounding-box entry consists of the following elements. There is no data type
de ned for these entries, each of which is 10 bytes long.
Bounding-box style. An integer value that speci es the style code for this
bounding-box entry. Style codes are shown in Figure 4-23 on page 4-95.
Bounding-box left. The coordinate value of the left edge of the bounding box, in 16-bit
xed-point format, with an integer part in the high-order 4 bits and a fractional part in
the low-order 12 bits.
Bounding-box bottom. The coordinate value of the bottom edge of the bounding box,
in 16-bit xed-point format, with an integer part in the high-order 4 bits and a
fractional part in the low-order 12 bits.
Bounding-box right. The coordinate value of the right edge of the bounding box, in
16-bit xed-point format, with an integer part in the high-order 4 bits and a fractional
part in the low-order 12 bits.
Bounding-box top. The coordinate value of the top edge of the bounding box, in 16-bit
xed-point format, with an integer part in the high-order 4 bits and a fractional part in
the low-order 12 bits.
The Family Glyph-Width Table
The font family glyph-width table is used to specify glyph widths for the font family on a
per-style basis. This table, which is shown in Figure 4-27, can contain a number of
glyph-width subtables, with one subtable for each style in the family.
Figure 4-27

The font family glyph-width table

Bytes

First

subtable

| /

{

4-98

Font Manager Reference

Number of entries—1

2

Style code

2

Style widths

/ variable

j

CHAPTER

4

Font Manager

The family glyph-width table consists of an integer count and a variable number of
glyph-width subtables. The table is represented by the WidTable data type, which is
shown on page 4-48.
m= Number of entries. An integer value that speci es the number of bounding-box entries
in this table minus 1. This value is represented by the numWidths_ eld in the
WidTable data type.
Each glyph-width subtable in the table is represented by the WidEntry data type, which
is shown on page 4-48. Each subtable consists of the following elements.
m Style code. An integer value that speci es the style code for this bounding-box entry.
Style codes are shown in Figure 4-23 on page 4-95. This value is represented by the
widStyle eld inthe WidEntry data type.
m

Style widths. A variable length array of integer values, with one entry in the array for

each glyph in the font. Each width is in 16-bit xed-point format, with the integer part
in the high-order 4 bits and the fractional part in the low-order 12 bits.

The Style-Mapping Table
The printer driver uses font classes to differentiate among the different methods
of implementing font styles. The style-mapping table provides a fSexible way to
assign font classes and to specify character-set encodings. The table contains the font
class, information about the character-encoding scheme that the font designer used,
and a mechanism for obtaining the name of the appropriate printer font. The
style-mapping table is primarily used by drivers for high-resolution printers such as
the LaserWriter.
The font name suf x subtable and the glyph-encoding subtable that are part of the
style-mapping table immediately follow it in the resource data. The font name suf x
subtable contains the base font name and the suf xes that can be added to the font
family@ name to produce a real PostScript name (one that is recognized by the PostScript
LaserWriter printer driver). The style-mapping table uses the suf x table to build a font
name for a PostScript printer. The glyph-encoding table allows character codes to
be mapped to PostScript glyph names. Figure 4-28 shows the structure of the
style-mapping table.

Font Manager Reference

4-99

CHAPTER

4

Font Manager

Figure 4-28

The style-mapping table

Bytes
{f

Header —4
component

Lo
=

Font name —

Z

Font class

2

Offset

4

Reserved

4

Index to suffix for style code 0
Index to suffix for style code 1

1
1

Index to suffix for style code 47

1

String count

2

Base font name

/ 256

AK,

suffix
subtable

Glyph-name —
encoding
subtable

Strings
String count
Strings

4

variable

The header component of the style-mapping table contains a list of indexes into the font
name suf x subtable, which is described below. The style-mapping table is represented
by the StyleTable data type, which is shown on page 4-49. The elements of this table
are as follows.

m Font class. An integer value that speci es a collection of fags that alert the printer
driver to what type of PostScript font this font family is. This value is represented by
the fontClass eld of the StyleTable data type. For more information about how
these Sags are used, see the LaserWriter Reference book.

4-100

Font Manager Reference

CHAPTER

4

Font Manager

The default font class de nition is 0, which has settings that indicate the printer driver

should derive the bold, italic, condense, and extend styles from the plain font. Intrinsic

fonts are assigned classes (bits 2 through 8) that prevent these derivations from
occurring. The meanings of the 16 bits of the fontClass word are as follows:
Bit

Meaning

0

This bit is set to 1 if the font name needs coordinating.

1

This bit is set to 1 if the Macintosh vector reencoding scheme is required.
Some glyphs in the Apple character set, such as the Apple glyph, do not
occur in the standard Adobe character set. This glyph must be mapped in

from a font that has it, such as the Symbol font, to a font that does not, like

Helvetica.
2

This bit is set to 1 if the font family creates the outline style by changing
PaintType, a PostScript variable, to 2.

3

This bit is set to 1 if the font family disallows simulating the outline style by
smearing the glyph and whiting out the middle.

4

This bit is set to 1 if the font family does not allow simulation of the bold
style by smearing the glyphs.

5

This bit is set to 1 if the font family simulates the bold style by increasing
point size.
This bit is set to 1 if the font family disallows simulating the italic style.
This bit is set to 1 if the font family disallows automatic simulation of the
condense style.

8

This bit is set to 1 if the font family disallows automatic simulation of the
extend style.

9

This bit is set to 1 if the font family requires reencoding other than
Macintosh vector encoding, in which case the glyph-encoding table is

present.

10

This bit is set to 1 if the font family should have no additional intercharacter
spacing other than the space character.

11 15

Reserved. Should be set to 0.

m Offset. A long integer value that speci es the offset from the start of this table to the
glyph-encoding subtable component. This value is represented by the offset eld of
the StyleTable data type.
m Reserved. A long integer element reserved for use by Apple Computer, Inc.
m Index to font name suf x subtable. This is an array of 48 integer index values, each of
which is a location in the naming table. The value of the rst element is an index into
the naming table for the string name for style code 0; the value of the forty-eighth
element is an index into the naming table for the string name for style code 47. This
array is represented by the indexes eld of the StyleTable data type.

Font Manager Reference

4-101

CHAPTER

4

Font Manager

The Font Name Suffix Subtable

The font name suf x subtable is part of the style-mapping table. This subtable contains
the base font name and the suf xes that can be added to the font family@ name to
produce a real PostScript name (that is, one that is recognized by the PostScript printer
driver). This subtable is represented by the NameTable data type, which is described on
page 4-49. It consists of the following elements:
m String count. An integer value that speci es the number of strings in the array of
suf xes. This value is represented by the stringCount eld of the NameTable
data type.
m

Base font name. The font family name in a 256 byte long Pascal string. This value is

represented by the baseFontName_

eld of the NameTable data type.

m Strings. A variable length array of Pascal strings, each of which contains the suf xes or
numbers specifying which suf xes to put together to produce the real PostScript name.
This array is represented by the strings eld of the NameTabl1le data type. This
section describes the format of these strings and provides an example of using this
subtable.
Each of the strings in the string list contains a sequence of one-byte values, the rst of
which speci es how many other bytes follow, and each of the following contains an
index value. To form the complete name of a font, the base name is concatenated with

each of the strings whose index is in the string.

For an example of how this table works, consider the PostScript name of the bold-italic

version of the font ExampleFont. Here are the strings of the font name suf x subtable
for this font:
Index

Contents
$02

$09

SOA

$02

$09

SOB

$03

$09

SOA

$02

$09

SOC

$04

$09

SOC

$09

SOA

$04

$09

SOC

$09

SOB

$05

$09

SOC

S09

SOA

Ee
N

—
i)

oOo

AN

HD

OFF

WN

'ExampleFont '

4-102

'Bold'
'Oblique'
'Narrow'!

Font Manager Reference

SOB

SOB

CHAPTER

4

Font Manager

QuickDraw has assigned the bold-italic style the number $03; since the base font name is

the rst entry in this array, you need to access the entry at +1, where / is the style value.
So, for the bold-italic style, you look at the fourth string. The rst byte in this string is
$03, which indicates that three string indexes follow.

m The

rst index is $09, which produces the string '-'.

m The second index is $0A, which produces the string

'Bold'.

m The third index is $0B, which produces the string

'Oblique'.

By concatenating them together with the base font name, you produce the font name
string CExampleFont-BoldObliqueQ If the LaserWriter printer driver cannot nd the font
on the printer, it looks for the font: in version 7.1 and later of system software, the driver
looks in the CFontsOfolder; in earlier versions of system software, it rst looks in the
folder where the driver code is located, then in the System Folder. If the font is there, the

driver sends it to the printer. If it is not, the driver sends a QuickDraw bitmap that has
already been scaled to the correct size.

Listing 4-4 provides a function for using the style table to build a full PostScript
font name.
Listing 4-4

Using the style-mapping table to build a PostScript font name

TYPE

IntegerPtr = “Integer;
FamRecPtr = “FamRec;
FamRecHdl

=

“FamRecPtr;

StyleTablePtr
FUNCTION
{A

=

“StyleTable;

MyCompressStyle

“Set

of

{assuming

(aStyle:

StyleItem”

that

is

condense

mapped

and

Style):
into

extend

are

Integer;
[0..47],}

mutually

exclusive}

VAR
styleCode:

Integer;

BEGIN

styleCode
IF
IF

bold

:=
IN

aStyle

THEN

styleCode

:=

styleCode

italic

aStyle

IN

styleCode
IF
IF

0;

outline

:=
IN

aStyle
:=

shadow

aStyle

IN

styleCode

Font Manager Reference

:=

1;

+

2;

+

4;

+

8;

THEN

styleCode

styleCode

+

THEN

styleCode
THEN

styleCode

4-103

CHAPTER

4

Font Manager

IF

condense

IN

styleCode
ELSE

IF

aStyle

:=

extend

styleCode

IN

:=

THEN

styleCode

+

16

aStyle

THEN

styleCode

+

MyCompressStyle

:=

32;

styleCode;

END;

FUNCTION

MyNthStyleName

(index:

Integer;

gq:

Ptr):

Str255;

VAR
s:

Str255;

BEGIN
WHILE

index

>

1

DO

BEGIN

gq

:=

Ptr(ord(q)

+

q*

+

1);

{ assumes
index

:=

index

-

q*

= stringlength

<

128

...}

q*

= stringlength

<

127

...}

1;

END;

BlockMove(g,

@s[0],

q*

+

1);

{ assumes
MyNthStyleName

:=

s;

END;

FUNCTION

MyPSFontName
(fh:

FamRecHdl;

aStyle:

Style):

VAR

stp:

q:

StyleTablePtr;

Ptr;

{ pointer
{ This is

PSName,

suffixIndices:

i,

nbofStrings,

to Style-name table. }
not a Pascal structure.
Str255;

offset,

BEGIN

PSName

:

ry

offset

:=

fh**.ffStyloff;

IF

4-104

offset

>

0

Font Manager Reference

THEN

whichIndex:

Integer;

}

Str255;

CHAPTER

4

Font Manager

BEGIN

stp
gq

:=
:=

StyleTablePtr(ord(fh*)

Ptr(ord(stp)
{

nbofStrings
{ for
gq

:=

(StyleTable)

table

follows

@PSName,
:=

to

g*~
of

>

}

basename

+

of

font

}

length

<

1);

font;

stp*.indexes

(whichIndex

);
style-mappingTable}

2);

pointing

basename

whichIndex
IF

+

now

BlockMove(gq,
{

SizeOf

:= IntegerPtr(q)%*;
range checking below

Ptr(ord(q)
{

+

style-name

+ offset);

assumes

128

}

[MyCompressStyle(aStyle)];

1)

AND

(whichIndex

:=

MyNthStyleName

<=

nbOfStrings)

BEGIN

suffixIndices

FOR

i

:=

1

PSName

(whichIndex,

TO

ord(suffixIndices[0])

:=

concat

q) ;

DO

(PSName,

MyNthStyleName
(ord (suffixIndices[i]),
END

ELSE

{ corrupted

FOND

};

END

ELSE

{ no

style

mapping

MyBuildPSFontName

:=

table

in

FOND

};

PSName;

END ;

The Glyph-Name Encoding Subtable
The glyph-name encoding subtable of the style-mapping table allows the font family
designer to map 8-bit character codes to PostScript glyph names. This subtable is
required when the font family character set is not the Standard Roman character set or
the standard Adobe character set. Each entry in this table is a Pascal string, the rst byte
of which is the character code that is being mapped, and the remaining bytes of which
specify the PostScript glyph name.
There is no data type de ned to represent the glyph-encoding subtable. The elements of
this subtable are as follows:

m String count. An integer value that speci es the number of entries in the
encoding subtable.
m Strings. A variable length array of Pascal strings. The rst byte of each string is an
eight-bit character code, and the remaining bytes are the name of a PostScript glyph.
This section beginning on page 4-105, provides an example of using this table.

Font Manager Reference

4-105

CHAPTER

4

Font Manager

The following example demonstrates the use of an encoding table in a font resource:
Byte sequence

Use

$0002

The number of entries in this encoding table.

SA8

The character code of the

'diamond'

The name of the PostScript character to be used for character
code $A8.

SA9

The character code of the second (and last) character that is being

"heart!

The name of the PostScript character to be used for character
code $A9.

rst character that is being remapped.

remapped.

The effect of this table is to assign the PostScript character named diamond to the
character code $A8 and to assign the PostScript character named heart to the character
code $A9. If either of these character codes has a character assigned to it in the font, that
character is replaced by the PostScript character named in the table.
For more information about the font name suf x subtable and the glyph-name encoding
table, please see the LaserWriter Reference.
The Font Family Kerning Table
The font family kerning table consists of a group of kerning subtable entries. Each
subtable contains the measurements of a hypothetical 1-point font of this family with a
different stylistic variation. The Font Manager multiplies these measurements by the
requested font size. The structure of the font family kerning table is shown in Figure 4-29.
Figure 4-29

The font family kerning table

Bytes

(—

First —

entry

Z

Number of entries—1

2

Kern style

2

Entry length

2

Kerning pairs

/ Natiable

\

{

4-106

Font Manager Reference

{

CHAPTER

4

Font Manager

The font family kerning table is represented by the KernTable data type, which is
shown on page 4-49. It consists of a count, followed by a variable number of kerning
subtable entries.
= Number of entries. This is an integer value that speci es the number of kerning
subtable entries in this table minus 1. This value is represented by the numKerns_
of the KernTabl1le data type.

eld

Each kerning subtable entry is represented by the KernEntry data type, which is
described on page 4-50. Each subtable pertains to a speci _c style code and contains a
variable number of kerning pair entries. The style code values are shown in Figure 4-23
on page 4-95. The elements of each subtable entry are as follows:
m Kern style. This is an integer value that speci es the style code to which the kerning
information in the subtable pertains. This value is represented by the kernStyle eld
of the KernEntry data type.
m Entry length. This is an integer value that speci es the number of bytes in this kerning
subtable. This value is represented by the kernLength eld of the KernEntry
data type.
Each kerning pair entry speci es a kerning distance in pixels for a pair of glyphs. Each
glyph is speci ed by its character code. The structure of the kerning pair entry is shown
in Figure 4-30.
Figure 4-30

A kerning pair entry

Bytes
First character code

1

Second character code

1

Kerning distance

2

Each kerning pair entry is represented by the KernPair
page 4-50. The elements of each entry are as follows:

data type, which is shown on

m First character code. The one-byte character code of the rst glyph of the kerning pair.
This value is represented by the kernFirst eld of the KernPair data type.
m Second character code. The one-byte character code of the second glyph of the kerning
pair. This value is represented by the kernSecond eld of the KernPair data type.
m Kerning distance. The kerning distance, in pixels, for the two glyphs at a point size of
1. This is a 16-bit xed point value, with the integer part in the high-order 4 bits, and
the fractional part in the low-order 12 bits. The Font Manager measures the distance in
pixels and then multiplies it by the requested point size. This value is represented by
the kernWidth eld of the KernPair data type.

Font Manager Reference

4-107

CHAPTER

4

Font Manager

Summary of the Font Manager
Pascal Summary
Constants
CONST
systemFont
newyork

=

=

applFon t

0;

1;

=

2;

=

8;

geneva
monaco
venice
london
athens
sanFran

toronto
cairo

9 f

=

11;

losAngeles
times

=

12;

20;

helvetica
courier

=
=

=

21;

22;

symbol

23;

mobile

24;

Data Types
TYPE

FMInput

PACKED

=

RECORD

family:

Integer;

{ font family ID}
{ requested point size}
{ requested font style}

size:

Integer;

face:

Style;

needBits:

Boolean;

{if

device:

Integer;

driver

numer:

Point;

{ device

{scaling

factor

numerators}

denom:

Point;

{ scaling

factor

denominators}

END;

4-108

Summary of the Font Manager

bitmaps

need

to

be

constructed}

ID}

CHAPTER

4

Font Manager

TYPE

FMOutput

PACKED

RECORD

extra:

SignedByte;

ascent:

Byte;

{reserved for internal use}
{handle to font}
{for drawing of bold style}
{for drawing of italic style}
{for drawing of underline style}
{for drawing of underline shadow style}
{for drawing of underline thickness}
{for drawing of shadow style}
{# of pixels added for styles}
{ascent measurement of font}

descent:

Byte;

{descent

widMax:

Byte;

{maximum width of glyphs in font}
{leading value for font}
{actual output font style}
{scaling factor numerators}
{scaling factor denominators}

errNum:

Integer;

fontHandle:

Handle;

bold:

Byte;

italic:

Byte;

ulOffset:

Byte;

ulShadow:

Byte;

ulThick:

Byte;

shadow:

Byte;

leading:

SignedByte;

fOutCurStyle:

Byte;

numer:

Point;

denom:

Point;

measurement

of

font}

END;

Type

WidthTable

PACKED

RECORD

tabData:

ARRAY

[1..256]

OF

Fixed;

tabFont:

Handle;

SExtra:

LongInt ;

{character widths}
{font record used to
{extra line spacing}

style:

LongInt ;

{extra

fID:

Integer;

fSize:

Integer;

face:

Integer;

{font family ID}
{font size request}
{style (face) request}
{device requested}
{scale factors requested}
{scale factors requested}
{actual font family ID for table}
{family record used to build up table}
{used fixed-point family widths}
{actual face produced}
{vertical scale output value}
{horizontal scale output value}
{vertical scale output value}
{horizontal scale output value}
{size of actual font used}
{total size of table}

device:

Integer;

inNumer:

Point;

inDenom:

Point;

aFID:

Integer;

fHand:

Handle;

usedFam:

Boolean;

aFace:

Byte;

vOutput:

Integer;

houtput :

Integer;

vFactor:

Integer;

hFactor:

Integer;

aSize:

Integer;

tabSize:

Integer;

END;

Summary of the Font Manager

line

spacing

build
due

to

table}
style}

CHAPTER

4

Font Manager

TYPE

FontRec

=

RECORD

fontType:
firstChar:
lastChar:
widMax:
kernMax :
nDescent:
fRectWidth:
fRectHeight:
owTLoc:
ascent:
descent :

Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;

{font type}
{character code of first glyph}
{character code of last glyph}
{maximum glyph width}
{negative of maximum glyph kern}
{negative of descent }
{width of font rectangle}
{height of font rectangle}
{location of width/offset table}
{ascent }
{descent }

leading:

Integer;

{leading}

rowWords:

Integer;

{row

ffFlags:
ffFamID:
ffFirstChar:
ffLastChar:
ffAscent:
ffDescent:
ffLeading:
ffWidMax:
ffWTabofet:
ffKernoft:
fEStylofef:

Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
LongInt ;
LongInt;
LongInt ;

{flags for family}
{family ID number}
{ASCII code of 1st character}
{ASCII code of last character}
{maximum ascent for 1 pt font}
{maximum descent for 1 pt font}
{maximum leading for 1 pt font}
{maximum widMax for 1 pt font}
{offset to width table}
{offset to kerning table}
{offset to style-mapping table}

ffProperty:

ARRAY

width

of

bit

image

/ 2

}

END;
TYPE

FamRec

=

RECORD

[1..9]

OF

Integer;

{style
fftintl:

ARRAY

[1..2]

OF

info}

Integer;

{for
f£fVersion:

property

international

Integer;

{version

number}

Integer;

{number

of

use}

END;

TYPE

FontAssoc

=

RECORD

numAssoc:
END;

4-110

Summary of the Font Manager

entries

-

1}

CHAPTER

4

Font Manager

TYPE

Assckntry

=

RECORD

fontSize:

Integer;

fontStyle:

Integer;

fontID:

Integer;

{point size of font}
{style of font}
{font resource ID}

Integer;

{number

of

entries

-

Integer;

{style

that

entry

applies

{the font class of this table}
{offset to glyph-encoding subtable}
{reserved}

END;
TYPE

WidTable

RECORD

numWidths:

1}

END;

TYPE

WidEntry

RECORD

widStyle:

to}

END;

TYPE

StyleTable

=

RECORD

fontClass:

Integer;

offset:

LongtInt;

reserved:

LongtInt;

indexes:

PACKED

[0..47]

ARRAY

OF

SignedByte;

{indexes into the font suffix name
{ table that follows this table}

}

END;
TYPE

NameTable

=

RECORD

stringCount

:

baseFontName:

{number of entries}
{font family name}

Integer;
Str255;

END;
TYPE

KernTable

RECORD
Integer;

{number

kernStyle:

Integer;

kernLength:

Integer;

{style the
{length of

numKerns:

of

subtable

entries}

END;
TYPE

KernkEntry

RECORD

entry applies
this entry}

to}

END;

Summary of the Font Manager

4-111

CHAPTER

4

Font Manager

TYPE

KernPair

=

RECORD

kernFirst:

Char;

{Code

of

1st

character

of

kerned

pair}

kernSecond:

Char;

{Code

of

2nd

character

of

kerned

pair}

kernWidth:

Integer;

{kerning

value

in

lpt

fixed

format}

END;

Type

FMetricRec

=

RECORD

ascent:
descent :
leading:

Fixed;
Fixed;
Fixed;

{baseline to top}
{baseline to bottom}
{leading between lines}

widMax:

Fixed;

{maximum

glyph

wTabHandle:

Handle;

{handle

to

width}

global

width

table}

END;

Routines
Initializing the Font Manager
PROCEDURE

InitFonts;

Getting Font Information
PROCEDURE

GetFontName

(familyID:

Integer;VAR

theName:

PROCEDURE

GetFNum

(theName:

Str255;VAR

FUNCTION

RealFont

(fontNum:

Integer;size:

familyID:

Str255);
Integer) ;

Integer):

Boolean;

Using the Current, System, and Application Fonts
FUNCTION

GetDefFontSize:

Integer;

FUNCTION

GetSysFont:

Integer;

FUNCTION

GetAppFont:

Integer;

Getting the Characteristics of a Font
PROCEDURE

FontMetrics

(theMetrics:

FMetricRec) ;

FUNCTION

OutlineMetrics

(byteCount:

Integer;

numer:
VAR

Point;

yMin:

FixedPtr;
OSErr;

4-112

Summary of the Font Manager

textPtr:

denom:

Integer;

Point;
awArray:

boundsArray:

UNIV
VAR

Ptr;

yMax:

Integer;

FixedPtr;

lsbArray:

RectPtr):

CHAPTER

4

Font Manager

Enabling Fractional Glyph Widths
PROCEDURE

SetFractEnable

(fractEnable:

Boolean);

Disabling Font Scaling
PROCEDURE

SetFScaleDisable

(fscaleDisable:

Boolean) ;

Favoring Outline Fonts Over Bitmapped Fonts
PROCEDURE

SetOutlinePreferred
(outlinePreferred:

FUNCTION

GetOutlinePreferred:

FUNCTION

IsOutline

Boolean);

Boolean;
(numer,denom:

Point)

:

Boolean;

Scaling Outline Fonts
PROCEDURE

SetPreserveGlyph

FUNCTION

GetPreserveGlyph:

(preserveGlyph:

Boolean) ;

Boolean;

Accessing Information About a Font
FUNCTION

FMSwapFont

(inRec:

FMInput):

FMOutPtr;

Handling Fonts in Memory
PROCEDURE
FUNCTION

SetFontLock
FlushFonts:

(lockFlag:

Boolean) ;

OSErr;

C Summary
Constants

enum

{

systemFont
applFont

=
=

newYork

=

0,

1,
2,

geneva

=

3

monaco

=

4

venice

=

5,

london

=

6

athens

=

7,

sanFran

=

8,

toronto

=

9

Summary of the Font Manager

4-113

CHAPTER

4

Font Manager

Cairo

=

11,

losAngeles
times

=

=

12,

20,

helvetica
courier

=
=

21,

22,

symbol

=

23,

mobile

=

24,

bi
Data Types
struct

FMInput

{

short

family;

/*font

short

size;

/*requested

family

point

size*/

Style

face;

/*requested

font

style*/

Boolean

needBits;

/*if

need

short

device;

/*device

Point

numer;

/*scaling

factor

numerators*/

Point

denom;

/*scaling

factor

denominators*/

errNum;

/*reserved

for

bitmaps

ID*/

driver

to

be

constructed*/

ID*/

bi
typedef

struct

struct

FMOutput

FMInput

FMInput;

{

short

internal

use*/

fontHandle;

/*handle

to

font*/

bold;

/*for

drawing

of

char

italic;

/*for

drawing

of

italic

char

ulOffset;

/*for

drawing

of

underline

unsigned

char

ulShadow;

/*for

drawing

of

underline

shadow

unsigned

char

ulThick;

/*for

drawing

of

underline

thickness*/

unsigned

char

drawing

of

shadow

Handle
unsigned

char

unsigned
unsigned

char

shadow;

/*for

extra;

/*#

of

pixels

bold

style*/
style*/
style*/

style*/

added

for

styles*/

measurement

of

font*/

unsigned

char

ascent;

/*ascent

unsigned

char

descent;

/*descent

measurement

unsigned

char

widMax;

/*maximum

width

of

glyphs

leading;

/*leading

value

for

font*/

char

fOutCurStyle;

/*actual

output

font

Point

numer;

/*scaling

factor

numerators*/

Point

denom;

/*scaling

factor

denominators*/

char

bi
typedef

4-114

struct

FMOutput

FMOutput;

Summary of the Font Manager

of

font*/

in

font*/

style*/

style*/

CHAPTER

4

Font Manager

struct

WidthTable

{

Fixed

tabData[256];

Handle

tabFont ;

/*font

record

used

long

sExtra;

/*extra

line

spacing*/

long

style;

/*extra

line

spacing

short

fID;

/*font

family

short

fSize;

/*font

size

short

face;

/*style

(face)

short

device;

/*device

requested*/

Point

inNumer;

/*scale

factors

requested*/

Point

inDenom;

/*scale

factors

requested*/

short

aFID;

/*actual

font

Handle

fHand;

/*family

record

usedFam;

/*used

fixed-point

aFace;

/*actual

short

vOutput ;

/*vertical

short

houtput ;

/*horizontal

short

vFactor;

/*vertical

short

hFactor;

/*horizontal

short

aSize;

/*size

short

tabSize;

/*total

/*character

Boolean
unsigned

char

widths*/

build

table*/

due

style*/

to

ID*/

request*/
request*/

face

family

ID

for

used

to

build

family

table*/

up

table*/

widths*/

produced*/

scale

output

scale
scale

of

to

output

scale

actual

size

value*/

value*/

output
font

of

value*/

output

value*/

used*/

table*/

bi
typedef

struct

struct

FontRec

WidthTable

WidthTable;

{

short

fontType;

/*font

type*/

short

firstChar;

/*character

code

of

first

short

lastChar;

/*character

code

of

last

short

widMax;

/*maximum

glyph

short

kernMax;

/*negative

of

maximum

short

nDescent;

/*negative

of

descent*/

short

fRectWidth;

/*width

of

font

rectangle*/

short

fRectHeight ;

/*height

of

font

rectangle*/

short

owTLoc;

/*location

short

ascent;

/*ascent*/

short

descent ;

/*descent*/

short

leading;

/*leading*/

short

rowWords;

/*row

width

of

of

glyph*/
glyph*/

width*/
glyph

width/offset

bit

image

kern*/

table*/

/

2

*/

bi
typedef

struct

FontRec

FontRec;

Summary of the Font Manager

4-115

CHAPTER

4

Font Manager

struct

FamRec

{

short

ffFlags;

/*flags

for

family*/

short

ffFamID;

short

ffFirstChar;

/*family

ID

number*/

/*ASCII

code

of

1st

short
short

ffLastChar;

/*ASCII

code

of

last

ffAscent;

/*maximum

ascent

for

short

ffDescent;

/*maximum

descent

for

1

pt

font*/

short

ffLeading;

/*maximum

leading

for

1

pt

font*/

short

ffWidMax;

/*maximum

widMax

long

f£WTaboff;

/*offset

to

width

long

ffKernOff;

/*offset

to

kerning

long

f£Styloff;

/*offset

to

style-mapping

short

ffProperty[9];

/*style

short

ffIntl

/*for

short

ffVersion;

typedef

struct

FamRec

struct

FontAssoc

{

short

[2];

struct

struct

AsscEntry

FontAssoc

/*number

of

table*/

info*/
use*/

-

1*/

FontAssoc;

{
/*point

size

fontStyle;

/*style

of

short

fontiID;

/*font

WidTable

font*/

table*/

entries

fontSize;

struct

pt

font*/

number*/

short

struct

1

pt

table*/

property

short

typedef

1

for

international

/*version

character*/

FamRec;

numAssoc;

typedef

character*/

AsscEntry

of

font*/

font*/

resource

ID*/

AsscEntry;

{

short

numWidths;

/*number

of

entries

/*style

that

entry

-

1*/

bi
typedef

struct

struct

WidEntry

bi

short

typedef

4-116

WidTable

WidTable;

{
widStyle;

struct

WidEntry

WidEntry;

Summary of the Font Manager

applies

to*/

CHAPTER

4

Font Manager

struct

StyleTable

{

short

fontClass;

/*the

long

offset;

/*offset

long

reserved;

/*reserved*/

char

indexes

/*indexes

[47] ;

font

class

to

of

this

table*/

glyph-encoding

into

the

font

subtable*/

suffix

name

table*/

hi
typedef

struct

struct

NameTable

StyleTable

StyleTable;

{

short

stringCount

;

Str255

baseFontName;

/*number

of

/*font

entries*/

family

name*/

hi
typedef

struct

NameTable

struct

KernTable{

short

NameTable;

numKerns;

/*number

of

subtable

entries*/

hi
typedef

struct

KernTable

struct

KernEntry

KernTable;

{

short

kernLength;

/*

length

of

this

short

kernStyle;

/*

style

this

entry

typedef

struct

struct

KernPair

KernEntry

entry*/
applies

to*/

KernEntry;

{

char

kernFirst;

/*Code

of

1st

character

of

kerned

pair*/

char

kernSecond;

/*Code

of

2nd

character

of

kerned

pair*/

short

kernWidth;

/*kerning

value

in

to

top*/

to

bottom*/

typedef

struct

struct

KernPair

FMetricRec

lpt

fixed

format*/

KernPair;

{

Fixed

ascent;

/*baseline

Fixed

descent;

/*baseline

Fixed

leading;

/*leading

Fixed

widMax;

/*maximum

glyph

Handle

wlabHandle;

/*handle

to

between

lines*/

width*/

global

width

table*/

bi
typedef

struct

FMetricRec

FMetricRec;

Summary of the Font Manager

4-117

CHAPTER

4

Font Manager

Routines

Initializing the Font Manager
pascal

void

InitFonts

(void) ;

Getting Font Information
pascal

void

GetFontName

(short

pascal

void

GetFNum

(ConstStr255Param

pascal

Boolean

RealFont

familyID,

(short

fontNum,

Str255

theName) ;

name,
short

short

*familyID) ;

size);

Using the Current, System, and Application Fonts
pascal

short

GetDefFontSize

(void);

pascal

short

GetSysFont

(void) ;

pascal

short

GetAppFont

(void);

Getting the Characteristics of a Font
pascal

void

FontMetrics

pascal

OSErr

OutlineMetrics

(const

FMetricRec

*theMetrics) ;

(short

byteCount,

const

Point

numer,

Point

short

*yMin,

FixedPtr

FixedPtr

lsbArray,

void

denom,

void

SetFractEnable

(Boolean

fractEnable) ;

(Boolean

fscaleDisable) ;

Disabling Font Scaling
pascal

void

SetFScaleDisable

Favoring Outline Fonts Over Bitmapped Fonts
pascal

void

SetOutlinePreferred

(Boolean
pascal

Boolean

pascal

4-118

Boolean

outlinePreferred) ;

GetOutlinePreferred
(vo1id)
IsOutline

(Point

Summary of the Font Manager

;
numer,

Point

*yMax,

awArray,

RectPtr

Enabling Fractional Glyph Widths
pascal

*textPtr,

short

denom);

boundsArray) ;

CHAPTER

4

Font Manager

Scaling Outline Fonts
pascal

void

SetPreserveGlyph
(Boolean

pascal

Boolean

preserveGlyph) ;

GetPreserveGlyph
(void)

;

Accessing Information About a Font
pascal

FMOutPtr

FMSwapFont

(const

FMInput

*inRec) ;

Handling Fonts in Memory
pascal

void

SetFontLock

(Boolean

pascal

OSErr

FlushFonts

(void) ;

lockFlag) ;

Assembly-Language Summary
Trap Macros
Trap Macros with Trap Words
Trap macro name

Trap word

_FMSwapFont

$A901

_FontMetrics

$A835

_GetFNum

$A900

_GetFontName

$A8FF

_InitFonts

$A8FE

_RealFont

$A902

_SetFont Lock

$A903

_SetFScaleDisable

$A834

Summary of the Font Manager

4-119

CHAPTER

4

Font Manager

Trap Macros Requiring Routine Selectors
_FontDispatch
Selector

Routine

$7000

TsOutline

$7001

SetOutlinePreferred

$7008

Out lineMetrics

$7009

GetOutlinePreferred

$700A

Set PreserveGlyph

$700B

Get PreserveGlyph

$700C

FlushFonts

Global Variables
ApFontID

Font ID of application
font.

CurFMInput

The

current

QuickDraw

FMInput

FMDefaultSize

Disables device-de ned extra spacing for styles.
The default point size.

FMgrOutRecc

The

current

FMOut put

record from FMSwapFont.

FDevDisable

record for

FMSwapFont.

FONDID

The resource ID of the last font family resource used.

FractEnable

If nonzero, fractional widths are enabled.

FScaleDisable
FScaleHFact
FScaleVFact
IntlSpec
Last FOND
LastSPExtra
ROMFont 0
SynListHandle
SysFontFam
SysFontSiz
UsedFWidths
WidthListHand
WidthPtr
WidthTabHandle

4-120

If nonzero, scaling is disabled.
The current horizontal scale factor.
The current vertical scale factor.
International software installed if the value of this is greater than zero.
Handle to last family record used.
The most recent value of extra spacing for styles.
Handle to font record for system font.
Handle to synthetic font list.
If nonzero, the font ID to use for the system font.
If nonzero, the size of the system font.
A Sag determining whether fractional widths were used for the most recent
font request.
Handle to a list of handles to recently used width tables (referred to in some
places
as j Font Info).
Pointer to global width table.
Handle to global width table.

Summary of the Font Manager

CHAPTER 5

Text Utilities

Contents
About the Text Utilities
5-3
The Text Utilities and the International Resources
5-4
Obtaining Resource Information
5-4
Pascal Strings and Text Strings
5-6
Using the Text Utilities
5-7
De ning Strings
5-8
Working With String Handles
—5-8
Working With String Resources — 5-9
Sorting Strings in Different Languages — 5-9
Sorting Strings in the Same Language
5-12
Primary and Secondary Sorting Order
5-12
Expansion and Contraction of Characters
5-14
Ignorable Characters
5-14
Converting and Stripping Characters
5-14
Special Cases for Sorting
5-14
Variations in Sorting Behavior
5-15
Choosing a Comparison Routine
5-15
Testing Two Strings for Equality
5-17
Comparing Two Strings for Ordering
5-18
Modifying Text
5-18
Converting Characters and Stripping Marks in Strings
Fitting a String Into a Screen Area
5-19
Replacing a Portion of a String
5-21
Finding Word, Line, and Script Run Boundaries

Finding Word Boundaries — 5-23
Finding Line Breaks
5-24
Finding Subscripts Within a Script Run

Contents

— 5-28

5-23

5-19

CHAPTER

5

Working With Date and Time Strings
—5-29
Converting Formatted Date and Time Strings
Into Internal Numeric Representations
5-31
Date and Time Value Representations
5-34
Converting Standard Date and Time Values Into Strings = 5-34
Working With Numeric Strings = 5-35
Converting Between Integers and Numeric Strings
5-38
Using Number Format Speci cation Strings
5-39
Converting Number Format Speci cation Strings Into Internal
Numeric Representations
5-43
Converting Between Floating-Point Numbers and Numeric
Strings
5-43
Text Utilities Reference
5-44
Data Structures
5-44
Routines
5-47
De ning and Specifying Strings
5-47
Comparing Strings for Equality
5-50
Determining Sorting Order for Strings in Different Languages
5-54
Determining Sorting Order for Strings in the Same Language
5-59
Modifying Characters and Diacritical Marks
5-64
‘Truncating Strings
5-71
Searching for and Replacing Strings
5-74
Working With Word, Script, and Line Boundaries

5-77

Converting Date and Time Strings Into Numeric Representations
5-82
Converting Numeric Representations Into Date and Time Strings
5-86
Converting Long Date and Time Values Into Strings
5-89
Converting Between Integers and Strings
5-91
Using Number Format Speci cation Strings for International Number
Formatting
5-94
Converting Between Strings and Floating-Point Numbers — 5-98
Summary of Text Utilities
5-102
Pascal Summary
5-102
Constants
5-102
Data Types
5-103
Routines
5-104
C Summary
5-107
Constants
5-107
Types
5-109
Routines
5-110
Assembly-Language Summary —_ 5-113
Trap Macros
5-113

5-2

Contents

CHAPTER

5

Text Utilities

The Text Utilities provide you with an integrated collection of routines for performing a
variety of operations on textual information, ranging from modifying the contents of a
string, to sorting strings from different languages, to converting times, dates, and
numbers from internal representations to formatted strings and back. These routines
work in conjunction with QuickDraw text drawing routines to help you display and
modify text in applications that are distributed to an international audience.
Many of the Text Utilities routines were previously located in other managers in the
Macintosh system software. Several of these have been replaced with new versions that
take a script code as a parameter and others have been renamed. The appendix
(Renamed and Relocated Text RoutinesOin this book shows the original names and
locations of all of the text-handling routines.
You need to read this chapter if you are working with text in your application. This
includes basic operations such as accessing a string resource and comparing two strings
for equality. If you have used Macintosh text-processing routines in the past, you need to
review the material in this chapter to understand the new capabilities that have been
added to many of the routines.
To understand the material in this chapter, you need to have a basic understanding of the
Macintosh script management system. Read this chapter after reading Gintroduction to
Text on the Macintosh.OFor parts that describe international resources, read the appendix
Onternational ResourcesOalong with this chapter. For parts that describe text layout,
read GQQuickDraw TextOalong with this chapter.
This chapter describes the resources and text strings with which the Text Utilities interact,
and discusses how to use the Text Utilities to compare, sort, modify, and
text strings, and to convert and format date, time, and numeric strings.

nd breaks in

About the Text Utilities
The Text Utilities routines are used for numerous text-handling tasks, including
m de ning stringsN including functions for allocating strings in the heap and for loading
strings from resources
m™ comparing and sorting stringsN including functions for testing whether two strings
are equal and functions for nding the sorting relationship between two strings
m modifying the contents of stringsN including routines for converting the case of
characters, stripping diacritical marks, replacing substrings, and truncating strings
m

nding breaks and boundaries in textN including routines for

breaks, and for

About the Text Utilities

nding different script runs in a line of text

nding word and line

5-3

CHAPTER

5

Text Utilities

m converting and formatting date and time stringsN including routines that convert
numeric and string representations of dates and times into record format, and routines
that convert numeric and record representations of dates and times
into strings
m converting and formatting numeric stringsN including routines that convert string
representations of numbers into numeric representations, and routines that convert
from numeric representations into formatted strings

The Text Utilities and the International Resources
Many of the Text Utilities routines script-aware, which means that you need to
understand script systems and the international resources to use the routines properly.
Each script system contains a collection of these resources, which contain data and
routines that de ne how regional differences are handled. In particular, the international
resources contain tables that de ne how different text elements are represented.
The resources used by the Text Utilities are
m the script-sorting ('it1lm') resource, which de nes the sorting order among scripts
m
m

the numeric-format ('it10') resource, which describes details of how time,

numbers, and short dates are presented

the long-date-format ('it11') resource, which describes how long dates

are presented

m the string-manipulation ('it12') resource, which contains tables that de ne how
strings are sorted and which characters cause breaks between words
m the tokens ('it14') resource, which contains tables that de ne which sequences of
characters create which tokens
The appendix Cinternational ResourcesOin this book describes each international
resource in detail.

Obtaining Resource Information
Many Text Utilities routines perform operationsN such as modifying text or sorting
stringsN that require information from resources. Some routines determine which
resources to use by checking a resource parameter; others check a script code parameter.
For a Text Utilities routine that uses a resource parameter, you can explicitly specify
the resource you want to use, or you can specify NIL. The value NIL causes the routine to
use the resources associated with the current script. The current script is either
the system script (the script associated with the currently running version of Macintosh
system software) or the font script (the script of the current font in the current graphics
port), and is determined by the value of the international resources selection Sag, which
is represented by the global variable Int 1Force. If the value of this Sag is TRUE, the
current script is the system script; if the value of the Sag is FALSE, the current script is
the font script. (See Figure 5-1.)

5-4

About the Text Utilities

CHAPTER

5

Text Utilities

Figure 5-1

Determining the current script

Get current font

U

Map special fonts 0 and 1 to
their true font ID’s

U

Get font’s
script code

IntlForce
=TRUE?

Script enabled?
Yes

Vv
System script

Vv
Font script

Vv
System script

The international resources selection Sag is initialized at startup from the system script
con guration ('itlc') resource. For most system scripts, the international resources
selection Sag has a default value of TRUE. If you want to change its value, you can use
the Set SMVariable function with the smInt 1Force selector. If you want to test its
values, you can use the Get SMVariable function with the same selector. The
Get SMVariable and Set SMVariable functions are described in the chapter GScript
ManagerOin this book.
The value of the international resources selection Sag actually controls the operation of
the Get Int lResource function, which is used by other routines to access the

international resources. The operation of Get Int lResource is described in detail in the
chapter Script ManagerOin this book.
Other Text Utilities routines use a script code parameter, in which you specify the unique
number that de nes the script system whose resources you want to use.

About the Text Utilities

5-5

CHAPTER

5

Text Utilities

Constants for all de ned script codes are listed in the chapter Script ManagerOin this
book. If you wish, you can specify the following two special constants in the script code
parameter: smSystemScript, which indicates that the routine should use the
international resources of the system script, and smCurrent Script, which indicates

that the routine should use the font script.

Pascal Strings and Text Strings
This chapter describes many routines, almost all of which operate on strings that are
speci ed in one of two forms: as Pascal strings or as text strings. These are two ways of
representing text characters, each of which has advantages and disadvantages relative to
the other.
A Pascal string is an array of characters, the rst byte of which de nes the number of
bytes that follow. This is the standard representation of strings used in Pascal
programming. Most of the Text Utilities routines that use Pascal strings use the Str255
or StringHandle type. An advantage of the Str255 type is that it can be passed
directly as a single parameter on the stack. A disadvantage is that a Str255 value can
hold only up to 255 bytes of character data. A typical Pascal string parameter declaration
is as follows:
PROCEDURE

MyUsePascalString

(str:

Str255);

The alternative representation for character data, a text string, can contain up to 32,767

bytes of character data and is speci ed by two parameters: a pointer to the rst byte of
character data and a 16-bit integer length value. A typical declaration of a routine that
uses a text string parameter declaration is as follows:
PROCEDURE

MyUseTextString

(textPtr:

Ptr;

textLen:

Integer) ;

Some of the Text Utilities routines have been modi ed to allow for even longer strings.
These routines allow a 32-bit integer length value, which means that they can operate on
text strings of up to approximately two billion bytes in length.
IMPORTANT

Length is speci

ed in bytes, not characters, for both Pascal strings and

text strings. In international text processing, two bytes are sometimes
required to represent a single character in certain fonts, as illustrated in
Figure 5-2. Because you have to accommodate both 1-byte and 2-byte
characters in the same string, the length of each string cannot be
speci ed as anumber of characters. A

About the Text Utilities

CHAPTER

5

Text Utilities

Figure 5-2

Character

>

$22

Dr

$E1
$E2

Displayed string —

A

B

C

D|

al

N

LL

7k

iN

“wu

$E0

— SSSSSSSSSSSSS_a_a_a___rE
fo

ZO

$21

ownn
mo
Mm
BR WO

$20

D

Characters

0}
—

codes

DPD

offsets

$A473 | LL
gA4r4 | 7K
$A4EC | AR
ali

»

Ika

Byte

A string containing 1-byte and 2-byte characters

Using the Text Utilities
This section provides you with general information about how to use each group of Text
Utilities routines. A description of the basic concepts that each group deals with is
provided so that you can learn how to choose the appropriate function to meet your
needs. The following areas are covered:
how to de ne strings
how to retrieve the values of string resources
how to compare and sort strings, including how to sort strings in a
multi-language environment
how to modify strings by converting between uppercase and lowercase and
stripping diacritical marks
how to truncate strings to

tin speci

ed screen areas

how to search for and replace portions of strings
how to

nd word, line, and script run boundaries in strings

Using the Text Utilities

5-7

CHAPTER

5

Text Utilities

m how to convert date and time values into strings, accommodating different
international formats for the strings
= how to convert date and time strings into internal numeric representations
m

how to convert numeric values into strings, accommodating different international
formats for the numbers

Defining Strings
Before you use a string in your application, you must de ne it in some way. You can use a
string variable to represent text characters, or you can allocate an object in the heap to
represent those text characters. Many strings, including error messages and lists of input
choices, originate in the resource fork of your application; you need access to these
string resources before using any of the Text Utilities routines with the strings. This
section describes several routines that you can use to allocate strings and to access
string resources.

Working With String Handles
When you need to modify a string, it is useful to create a version of the string as an object
in the heap. That way, you can increase or reduce the memory allocated for the string
object as necessary. String handles provide a means for you to work with heap-oriented
strings.
The Text Utilities include two routines that work with strings and string handles.
The NewSt ring function creates a copy of a speci ed string in the heap and returns a
handle to that string. The Set String procedure changes the contents of the string
referenced by a string handle by copying a speci ed string into its area of the heap.
If you pass Set String a string that is longer than the one originally referenced by the
handle, Set String automatically resizes the handle and copies in the contents of the
speci ed string.
For example, suppose that you want to write a routine that creates both an uppercase and
lowercase version of an input string. The MyUpperAndLower function shown in Listing

5-1 replaces the contents of the lowerStr parameter with a lowercase version of the str
parameter, and returns a new string handle to the uppercase version.
Listing 5-1
FUNCTION

Using the NewString and SetString routines

MyUpperAndLower

(str:

VAR

Str255;

lowerStr:

StringHandle):

StringHandle;

VAR

myStr:
len:

StringHandle;
Integer;

BEGIN

myStr

:=

NewString(str) ;

SetString(

5-8

lowerStr,

str);

Using the Text Utilities

{create
{set

string

string

handle

handle

to

to

be

be

converted

converted
to

to

upper}

lower}

CHAPTER

5

Text Utilities

len

:=

ord(str[0]);

HLock (Handle (myStr) ) ;
UppercaseText

(@myStr

HLock

(Handle (myStr)

HLock

(Handle (lowerStr)

LowercaseText
HLock

(Handle

{UppercaseText

AA

[1],

len,

can

move

memory}

smSystemScript) ;

) ;
) ;

(@lowerStr**

{LowercaseText
[1],

len,

can

move

memory}

smSystemScript) ;

(lowerStr)}) ) ;

MyUpperAndLower

:=

myStr;

END;

Working With String Resources
Since many of the strings in your Macintosh applications are speci ed in resource les,
you need access to those strings. Strings are de ned by two different resource types: the
string ('STR ') resource and the string list (' STR#') resource. To work with the string
resource, you use the Get String function, and to work with a string list resource, you
use the Get IndSt ring procedure.
The Get String function reads a string resource into memory and returns the handle to
the string resource as its result. Get
St ring does not copy the string, so you must create
your own copy if you are going to modify the string in your application. If the resource
has already been read into memory, Get String simply returns a handle to the string.
If you use a number of strings in your application, it is more ef cient to specify them ina
string list resource rather than as individual resources. This is because the system
software that reads in the resources can operate more ef ciently when reading a
collection of strings from a_ le than when reading and storing each individually.
To work with an element in a string list, use the Get

IndSt ring

procedure. It reads the

resource, locates the string, and copies the string into a Pascal string variable you supply.
You can then use the NewSt ring function to create a copy of the string in the heap,
if you wish.

Sorting Strings in Different Languages
Strings in the same language must be sorted according to that language@ sorting
rules; information about these rules is found in resources that belong to that language@
script system.
However, if the strings are in two different languages or writing systems, sorting order is
also governed by rules about the order among languages or writing systems. For
example, an application might need to sort names in English, French, and German, or it
might need to sort an index of English and Japanese names written in Roman and
Katakana characters.

Using the Text Utilities

5-9

CHAPTER

5

Text Utilities

If you only need to sort strings from a single language in your application, you don®
need to read this section or use the routines that are described here. You can skip ahead to
the section Gorting Strings in the Same Language,Owhich begins on page 5-12.
When you sort strings in different languages, you must use routines that work with
script-sorting and language-sorting information. The script-sorting ('it1lm') resource
contains tables that de ne the sorting order among the languages or writing systems in
each script system and among the different script systems that are available. It also shows
the parent script for each language, the parent language for each region, and the default
language for each script. The ScriptOrder function, which determines the sorting
relationship between two script systems, and the LanguageOrder function, which
determines the sorting relationship between two languages, use the tables
in the script-sorting resource to determine their results. For more information on the
script-sorting resource, see the appendix Cnternational ResourcesOin this book.
To sort two Pascal strings in different languages, you begin by calling the StringOrder
function. (You can use the Text Order function to compare two text strings; it operates in
the same way as does StringOrder.) The StringOrder function rst calls the
ScriptOrder function; if the script codes of the two strings are different, then

StringOrder returns a result indicating the sorting relationship between the two script
codes. For example, if the rst string is from a Japanese script system and the second is
from a Thai script system, then the second string comes before the rst according to the
tables in the script-sorting resource.
If both strings come from the same script system, StringOrder then compares their
language codes by calling the LanguageOrder function. If the language codes of the
two strings are different, then St ringOrder returns a result indicating the sorting
relationship between the two language codes. For example, if the rst string is in English
and the second is in German, then the rst string comes before the second according to
the tables in the script-sorting resource.
Finally, if the script codes and language codes for both strings are the same, then
StringOrder compares the two strings using one of the comparison functions
described in the next section, Sorting Strings in the Same Language.O
If you need to sort a collection of strings, you can choose to implement your sorting
algorithm so that it uses StringOrder or TextOrder, or you can build a list for each

language and/or for each script system and sort each list independently. If you want to
use StringOrder or TextOrder, you need to store each string so that you can easily
access its script code and language code during the sort.
It is usually desirable to sort all strings from a script system together, using the sorting
rules that are associated with the current language for that script on the machine (and
ignoring the different sorting rules for the different languages). For example, if you are
sorting German, French, and English strings together for a system in England, you
usually want the English sorting rules to be applied to all of those strings. In some cases,
it may be more ef cient to build a list for each language by using the language code of
each to determine to which list it belongs. After building a list for each language, you can
sort each with an algorithm that uses one of the comparison functions described in the
next section, Sorting Strings in the Same Language.O

5-10

Using the Text Utilities

CHAPTER

5

Text Utilities

Figure 5-3 shows a collection of strings from different languages that need to be sorted.
Figure 5-3

Script

Roman

Japanese

Roman

Japanese
Roman

Japanese

Strings in different languages in one list

Language

String

English

love

German

Liebe

Japanese

By

English

peace

German

Frieden

Japanese

WAFL

English

hope

German

Hoffnung

Japanese

4a tA

In Figure 5-4, the strings have been sorted into two lists: one for each script system. The
Roman script system strings have been sorted according to the sorting rules for English,
which is assumed to be the current language for the script in this example.
Figure 5-4

Strings in different languages sorted by script

Script

Strings

Roman

Frieden
Hoffnung
hope

Liebe
love

peace
Japanese

4

——

“Bi Re

YY

Fi

Using the Text Utilities

5-11

CHAPTER

5

Text Utilities

Figure 5-5 shows the same strings separated into three lists: one for each language.
Each list has been sorted independently by applying the sorting rules for a language. The
language lists in each script system have been ordered by calling the LanguageOrder
function.
Figure 5-5

Strings in different languages sorted by language within script

Script

Language

Sorted strings

Roman

English

hope
love
peace

German

Frieden
Hoffnung
Liebe

Japanese

Japanese

4a tA
BE

ail
Sorting Strings in the Same Language
The Text Utilities provide a number of routines that you can use to compare and sort
strings in the same language. Some of these routines perform a comparison that assumes
single-byte character codes in the strings; others take into account the sorting rules of the
current script system, and still others allow you to explicitly specify the script system
resource to use for sorting strings.

Comparing strings can be an extremely intricate operation, because in many languages
you may have to account for subtleties such as complex characters, ignorable characters,
and exceptional words. Even for a straightforward language such as English, you
can@®always determine the sorting order by a simple table lookup or character
value comparison.
This section provides an introduction to some of the principles of text comparison and
sorting used by the Macintosh script management system. It then describes the routines
you can use for different comparison tasks.

Primary and Secondary Sorting Order
Sorting consists of two steps: determining primary sorting order and determining
secondary sorting order.

5-12

Using the Text Utilities

CHAPTER

5

Text Utilities

What happens in primary sorting order and secondary sorting order depends on the
language of the strings that are being sorted; however, there are two levels of importance
in the sorting operation, with some sorting differences subordinate to others. In the
primary sorting order for many Roman script system languages, uppercase and
lowercase characters are equivalent and diacritical marks are ignored. Thus, after
primary sorting, the two strings OfheOand Qh Oare considered equivalent. In the
secondary sorting order, lowercase characters are ranked after uppercase characters and
characters with diacritical marks are ranked individually. Thus, after secondary sorting,
(LheOwould sort before Qh O
You can think of the character ranking that is used to determine sorting order as a
two-dimensional table. Each row of the table is a class of all characters such as all A@:
uppercase and lowercase, with and without diacritical marks. The characters are ordered
within each row to form a secondary sorting order, while the order within each column
determines primary sorting order. Table 5-1 shows an example of such a table.
Table 5-1

Excerpt from the Standard Roman script system sorting order

Primary sorting

Secondary sorting order

A

AEc A

B

Bb

C

C,

D

Dd

E

Eéfeéee

F

Ff

order

* @a*}t{%&

ce

e'

In primary sorting, each of the characters in the rst row would be considered equivalent
and sorted before characters in the second row. In secondary sorting, the order of the
characters in each row would be taken into consideration. Another way of saying this is
to say that primary sorting characteristics take precedence over secondary sorting
characteristics: if any primary differences are present, all secondary differences are
ignored. When the strings being compared are of different lengths, each character in the
longer string that does not correspond to a character in the shorter one results in a
Qomes afterOresult. This takes precedence over secondary sorting order.
For example, here is a list of strings that have not yet been sorted:
e abccacAb“*bAc

After primary sorting, the list appears as follows
e abAb*bccacAc

After secondary sorting, the list appears as follows
e Abab*bacccAc

Using the Text Utilities

5-13

CHAPTER

5

Text Utilities

Expansion and Contraction of Characters
In some languages, a single character may be expandedN that is, sorted as a sequence of
characters. First, the sorting routine expands the character, then it performs sorting on the
expanded version. Next, the sorting routine recombines the character and then performs
secondary sorting. For instance, the @ in German may be sorted as if it were the two
characters ae: Backer would come after Bad, but before Bahn.

A sequence of characters may also be contractedN that is, sorted as a single character. For
instance, ch in Spanish may be sorted as if it were one character that sorts after c but
before d: coche comes after coco but before codo.

Ignorable Characters
Certain characters need to be ignored unless the strings are otherwise equal; that is, these
characters have no effect on the primary sorting order, but they do infSuence the
secondary sorting order. In English, hyphens, apostrophes, and spaces are ignorable
characters. For instance, the hyphen is ignored in primary sorting order in English:
black-bird would come after blackbird, but before blackbirds.

Converting and Stripping Characters
Sometimes you may want to strip out certain characters (notably diacritical marks) or
convert the case of characters in a string to produce a different comparison result. For
example, you may want to convert all alphabetic characters in two strings into uppercase
before comparing the strings, rendering uppercase and lowercase characters equivalent.
The Text Utilities provide a number of routines for converting the case of characters and
for stripping diacritical marks. These routines are described in the section CModifying
Text, which begins on page 5-18.

Special Cases for Sorting
Sometimes the sorting order changes drastically for special cases. For instance, when
words are understood to be abbreviations, the strings should be sorted as if they were

spelled out in full, as in the following examples.
First string

Second string

Explanation

McDonald

Mary

McDonald is treated as MacDonald

St. James

Smith

St. is an abbreviation for Saint

Easy Step

Easy St.

St. is an abbreviation for Street

Cases such as these require a direct dictionary lookup and are not handled automatically
by the Macintosh script management system. Note that some abbreviations are
context-dependent, such as St., which may denote Saint or Street, depending on the

meaning of the adjacent text.

5-14

Using the Text Utilities

CHAPTER

5

Text Utilities

Variations in Sorting Behavior
Here are some examples of variations in sorting behavior in different writing systems
of the world.
m Sorting in Japanese depends upon the subscript. Kana and Romaji sorting are
complicated by the presence of both 1- and 2-byte character codes. Moreover, many
Katakana symbols have diacritical marks indicating a sound modi cation. For
example, the symbol for ga is formed from the symbol for ka. The secondary sorting
order for ga includes the four combinations of 1-byte or 2-byte ka with the 1-byte or
2-byte diacritical mark, plus a 2-byte character that combines the character and
diacritical into a single glyph.
In the Japanese script system, Kanji is currently sorted by character code, which
can produce unexpected results. Proper sorting in Kanji is commonly done using one
of three methods:
i First by a character@ primary radical, then by the number of remaining strokes.
O First by the number of total strokes, then by the primary radical.
4 By sound value.
m Sorting in Arabic is quite straightforward except that some characters are ignorable,
such as vowels and the extension bar (used to lengthen the cursive connection
between characters). Vowels in Arabic are also diacritical marks, overlapping over or
under the previous character (the character to the right).
m

The Thai script system currently provides for third-level sorting involving character

clusters. For more on character clusters, see the chapter Ontroduction to Text on the
MacintoshOin this book.

Note
If you need to modify a script system@ standard string comparison or
replace it with your own version, you have to create your own
string-manipulation ('1t12') resource by following the guidelines
described in the appendix Cinternational ResourcesOin this book.

Choosing a Comparison Routine
The Text Utilities include six different routines for comparing one string to another. Three
of these routines test two strings for equality and the other three determine the ordering
relationship between two strings. You can use these routines with Pascal strings and text
strings, and they allow you to work with information from various resources or to ignore
script and language information altogether.
Figure 5-6 provides you with convenient guidelines for choosing from among the
comparison routines included in the Text Utilities. You rst decide whether you are
comparing two Pascal strings or two text strings, and then decide whether to
unconditionally use the Macintosh le system string comparison rules or to explicitly
specify a string-manipulation resource that de nes such rules. If you use a routine that
requires a parameter for a string-manipulation resource handle, you can specify NIL for
the value of that parameter to indicate that you want the current script system@
string-manipulation resource.

Using the Text Utilities

5-15

CHAPTER

5

Text Utilities

The top routine names in the boxes in Figure 5-6 are used to test two strings for equality,
and the bottom routine names in the boxes are used to compare two strings and
determine their sorting order. The term script-aware is used in this gure to indicate that
you must explicitly specify a string-manipulation resource as a parameter to a routine,
rather than the routine automatically using the le system@ string-manipulation rules.
Figure 5-6

Choosing a string comparison routine

p

| stri
ascal strings

|

Are you
using text strings

l

or Pascal
strings?

.
Text strings
a)

Vv

Does this
comparison need to
be script-aware?

Use file system comparison

Script-aware

V7
EqualString
RelString

IdenticalText
CompareText

IdenticalString
CompareString

The Macintosh le system string comparison rules are a subset of the Roman script
system comparison rules. These rules are used when the Macintosh le system compares
lenames for sorting. Since the Macintosh character set only contains characters with codes
from $0 to $D8, the le system comparison rules only work correctly for
character codes through $D8. You should only use the routines that use these rules
when you are trying to emulate the way that the Macintosh le system compares strings.

5-16

Using the Text Utilities

CHAPTER

5

Text Utilities

Table 5-2 describes the sorting behavior implemented by the routines that use the
system comparison rules.
Table 5-2

le

Sorting features of the Macintosh file system

Reordering of ligatures

Stripping of diacritical marks

Ligature

Falls between

Marked character

®

e

anda

,*,£,l1

Uppercase conversion

Stripped to

Lower

Upper

A

az

AZ

Gand B

,

C

‘

E

j

and o

f

E

<

I

I

g and P

”

N

§

sand T

yl,

O

CE

e

t

U

t,*, % ,<, GE»

a

e

c
,

®,

e,

‘

e

ne

i

®

°

,
f

=

”

-

n

>

I

ae

O

é

:

u

I

j

y

Y

t

cee,

,Y

O

“All simple lowercase Roman characters are converted to their uppercase equivalents.

Testing Two Strings for Equality
To test whether two strings are equal, use
IdenticalText. You can use the
with text strings.

Equal String, IdenticalString, or

rst two functions with Pascal strings, and the last one

The functions that work with Pascal stringsN EqualString and IdenticalStringN

allow you to specify the kind of information you want to consider in your test. If you
want to test two Pascal strings using the Macintosh le system comparison rules, use
EqualString. If you want to consider the information from a string-manipulation

resource, use the Ident icalString function. You can explicitly specify the handle of a
string-manipulation resource or you can specify NIL as the value to indicate that you
want the current script@ string-manipulation resource used.

Using the Text Utilities

5-17

CHAPTER

5

Text Utilities

To test two text strings for equality, you use the IdenticalText function, which makes
use of the information in a string-manipulation resource. You can explicitly specify the
handle of a string-manipulation resource or you can specify NIL as the value to indicate
that you want the current script@ string-manipulation resource used.

Comparing Two Strings for Ordering
There are also three Text Utilities routines that compare two strings and return a value
that indicates whether the rst string is less than, equal to, or greater than the
second string. Two of these routines take Pascal string parameters and the other takes
text string parameters.

To compare one Pascal string to another, you have to choose either the Rel String
function or the CompareSt ring function. If you want to compare two Pascal strings
using the Macintosh le system comparison rules, use Rel String. If you want to
consider the information from a string-manipulation resource, use the CompareString
function. You can explicitly specify the handle of a string-manipulation resource or you
can specify NIL as the value to indicate that you want the current script@
string-manipulation resource used.
To compare one text string to another, you use the CompareText function, which makes
use of the information in a string-manipulation resource. You can explicitly specify the
handle of a string-manipulation resource or you can specify NIL as the value to indicate
that you want the current script@ string-manipulation resource used.

Modifying Text
The Text Utilities include a number of routines that you can use to modify the contents
of strings. Several of these routines operate on Pascal strings, while others operate
on text strings.
Several of the text modi cation routines also take a script code parameter, which is used
to indicate which script system@ resources should be used to de ne the results of various
character modi cations. Script codes are described in the chapter Script ManagerOin
this book.
There are three kinds of text modi

cation routines:

m routines that convert the case of characters and strip diacritical marks from characters
in a string

m routines that truncate a string to make it

t into aspeci

ed area on the screen

m routines that search for a character pattern in a string and replace it with a different
character pattern

5-18

Using the Text Utilities

CHAPTER

5

Text Utilities

Converting Characters and Stripping Marks in Strings
Several Text Utilities routines allow you to convert the case of characters and strip
diacritical marks from strings. They can be useful when you want to present strings
ina simpli ed form or to store strings in a form that can increase the ef ciency of
a comparison.
You can use the UpperSt ring

procedure to convert any lowercase letters in a Pascal

string into their uppercase equivalents; however, this procedure assumes that you are
using the Macintosh le system conversion rules and does not use any of the information
in the international resources to perform its conversion.

You can use the UppercaseText procedure to convert any lowercase letters in a text
string into their uppercase equivalents. This procedure takes a script code parameter and
uses the case conversion information in the string-manipulation resource for the
indicated script system to convert the characters.
The LowercaseText procedure converts any uppercase letters in a text string into their
lowercase equivalents. This procedure takes a script code parameter and uses the case
conversion information in the string-manipulation resource for the indicated script
system to convert the characters.
The StripDiacritics procedure removes any diacritical marks from a text string. This
procedure takes a script code parameter and uses the information in the
string-manipulation resource for the indicated script system to determine what character
results when a diacritical mark is stripped.
The UppercaseStripDiacritics procedure combines the effects of the
UppercaseText and StripDiacritics
procedures: it converts any lowercase letters

to their uppercase equivalents and strips any diacritical marks from characters in a text
string. This procedure also takes a script code parameter, which speci es which script
system@ resources are used to determine conversion results.

Certain other routines in Macintosh system software convert characters in a text string.
The TransliterateText function converts characters from one subscript into the
closest possible approximation in a different subscript within the same script system. The
Int1Tokenize function converts text into language-independent tokens, for further
processing by interpreters or compilers. TransliterateText and IntlTokenize are
documented in the chapter Script ManagerOin this book.

Fitting a String Into a Screen Area
When you want to ensure that a string ts in a certain area of the screen, you can use
either the TruncSt ring or TruncText routine. Each performs the same operation:
truncating the string (removing characters from it) so that it ts into aspeci ed pixel
width. The TruncString function truncates a Pascal string and the TruncText
function truncates a text string.
Both of the truncation functions use the current fontN the font currently in use in the
current graphics portN and its script to determine where the string should be truncated.
The font size is used to determine how many characters can completely t in the number
of pixels speci ed as a parameter to the function.
Using the Text Utilities

5-19

CHAPTER

5

Text Utilities

Both functions also take a parameter that speci es where any needed truncation is to
occur. You can specify that characters are to be truncated from the end or from the middle
of the string, as MPW

does with pathnames, for example.

A truncation indicator is inserted into a string after characters are truncated; in the U.S.
Roman script system, the ellipsis (E ) is used for this purpose. You should specify the
truncation indicator by token, rather than by speci c character code, so that the proper
indicator is applied to each script systemG@ text. Specify a token from the untoken table of
the tokens ('it14') resource of the script system of the current font. The untoken table is
described in the appendix Gnternational ResourcesOin this book.
Truncating a string in its middle is commonly used on pathnames, where you want the
user to see the beginning and end of the full path, but are willing to sacri ce some of the
information in the middle, as shown in Figure 5-7.

Figure 5-7

Truncating a pathname in its middle

Pathname string
Mymac:myfolder: mysubfolder: myownfolder: myfile

= File Edit

Window

DQ
Middle truncated to 480 pixels

eS

SSS
ES

Mymac:myfolder:mysubfolder:myownfolder:m...

mE

End truncated to 480 pixels

)

a

Mymac:myfolder:mysub...r:myownfolder:myfile

The code in Listing 5-2 performs the truncation that is illustrated in Figure 5-7. Assuming
that each character in the string requires 12 pixels, then 480 pixels will be wide enough to
hold 40 characters:

Listing 5-2
str

ans
ans

:=

“Mymac:myfolder:mysubfolder:myownfolder:myfile”

:= TruncString( 480, str, truncEnd );
{480 pixels available}
{str would be “Mymac:myfolder:mysubfolder:myownfolder:...” }
:=
{str

5-20

Truncating a pathname

TruncString(
would

now

480,
be

str,

truncMiddle

);

“Mymac:myfolder:mysub...:myownfolder:myfile” }

Using the Text Utilities

CHAPTER

5

Text Utilities

Since the truncation functions can alter the length and contents of the string that you pass
in, it is good practice to make a copy of a string before passing it to one of them.

Replacing a Portion of a String
The Text Utilities include two routines for replacing a portion of a string with another
string. Each of these routines searches through a string looking for the pattern string.
Whenever it nds an occurrence of the pattern string, the routine replaces it with
the new string.
The ReplaceText function takes information about the current script system into
account: it looks through the string character-by-character rather than byte-by-byte.
Speci cally, this means that ReplaceText properly examines strings that contain both
1-byte and 2-byte characters.
The Munger function searches for a sequence of bytes and replaces it with another
sequence of bytes that you specify. It provides the same capability as ReplaceText, but
searches for a byte pattern without regard to character length. In a string that contains a
mixture of 1-byte and 2-byte characters, Munger can, under some conditions, wrongly
nd a pattern string. This is because the second byte in some 2-byte characters can be
wrongly regarded as a 1-byte character.
For example, suppose that you want to search a string for the copyright (GOO character
and replace each occurrence with the string CRegisteredQ If you use Munger to search a
string with Japanese characters in it, Munger will mistakenly nd and replace the byte
with value AY, which is really part of a 2-byte character in the Japanese script system.
Figure 5-8 shows how the Japanese word for Qnorning sunOcould be incorrectly
identi ed as containing the copyright character.
Figure 5-8

Byte
offsets
0

1]

Replacing a portion of a string with 1-byte and 2-byte characters

Character
codes
$92

$a9

2|_ __SFA

3

;
In English

In Japanese

HA
$9249
$93FA

,

Ne

1©@1
$49 $93 $FA

$92

Munger provides a great deal of power, allowing you to perform many interesting
substitutions; however, you need to limit your use of Munger in applications that are

script-aware, or else do your own checking for 2-byte characters.

Using the Text Utilities

5-21

CHAPTER

5

Text Utilities

Listing 5-3 uses the ReplaceText and TruncText functions. It assumes that you have
Str255 strings containing base text and substitution text and that you want the result to
tin a speci ed number of pixels.
Listing 5-3

Substituting and truncating text

CONST
maxInt

=

32767;

VAR
baseString:

Str255;

subsString:

Str255;

baseHandle:

Handle;

subsHandle:

Handle;

keyStr:

Str15;

sizeL:

LongInt;

myWidth:

Integer;

length:

Integer;

result:

Integer;

mykrr:

OSErr;

BEG IN

baseString:

'abcdefghijklmnopgrstuvwxyzabcdefghijklmnopgqrstuvwxyz';

subsString

:=

'KILROY

WAS

HERE';

{insert

keyStr := 'mnop';
myWidth := 500;
SsizeL

:=

ord(baseString[0]
) ;

:=

PtrToHand(@baseString[1],

myErr

<>

THEN

ord(subsString[0]) ;

:=

PtrToHand(@subsString[1],
<>

IF

:=

THEN
SizeL
IF

<

length

subsHandle,

keyStr) ;

;

(baseHandle,

(result) ;

GetHandleSize(baseHand1le) ;

MemError

HLock

sizeL);

0

DoError
:=

THEN

(myErr)

ReplaceText

result

subsHandle,

nokrr

DoError

result

sizelL);

;

:=

THEN

5-22

(myErr)

sizeL

myErr

baseHandle,

nokrr

DoError

myErr
IF

<>

nokrr

DoError(MemError) ;
:=

into

sizelL;

(baseHandle)

baseString}

{replace this with subString}
{truncate string at this width}

myErr
IF

this

;

Using the Text Utilities

CHAPTER

5

Text Utilities

IF

MemError

THEN
result
IF

THEN
HUnlock
IF

:=

<

(MemError)

;

(myWidth,

{Memory
baseHandle*,

Manager

length,

error}

TruncEnd) ;

0

DoError

(result);

(baseHandle*,
(baseHandle)

MemError

THEN

nokErr

TruncText

result

DrawText

<>

DoError

<>

DoError

0,

length);

;

nokErr

(myErr)

;

{Memory

Manager

error}

END;

The code in Listing 5-3 rst calls the ReplaceText function to replace a portion of the
base string (the string initialized to contain the alphabet) with another string. Since two
of the parameters to ReplaceText

are string handles, the code

rst creates handles to

the two strings and veri es that no errors occurred. It then calls the TruncText function
to remove characters from the end of the modi ed base string so that the string can be
displayed, using the text font, size, and style settings in the current graphics port, in an
area 500 pixels wide. Once the string is truncated, the code calls the QuickDraw
procedure DrawText to draw the string in the current graphics port on the screen.

Finding Word, Line, and Script Run Boundaries
This section describes the Text Utilities routines that you can use to determine where the
boundaries of the current word in a text sequence are, where to break the line for

drawing text, and where the end of the current subscript text run is. These routines are
commonly used in word-processing applications.

Finding Word Boundaries
When working with text in your application, you sometimes need to process each word
in the text. You can use the FindWordBreaks procedure to determine the starting and
ending locations in a string of a word. You pass FindWordBreaks a string and a starting
position, and it searches backward for the start of the word, then searches forward for the

end of the word.

This procedure normally uses the string-manipulation ('it12') resource of the current
script system in determining where the word boundaries are. Most string-manipulation
resources include a word-selection break table of type NBreakTable that speci es what
constitutes a word boundary in that script; however, some string-manipulation resources
do not include such a table, in which case FindWordBreaks uses default de

nitions of

word boundaries. Some script systems provide a separate extension that allows

Using the Text Utilities

5-23

CHAPTER

5

Text Utilities

FindWordBreaks to nd word breaks in a more sophisticated fashion such as using a
dictionary lookup. The format of the word-selection break table is described in the
appendix Cnternational ResourcesOin this book.
This procedure returns the beginning and ending of a word in a string. Theses values are
returned in a table of type Of set Table, which contains values that indicate the
starting and ending positions in the string of the word. The Of fset Table data structure
is described in the section (Lhe Offset Table RecordOon page 5-44.
You can also use FindWordBreaks to break lines of text, although the procedure is more
complicated than using StyledLineBreak, as described in the next section.
For more information, see the discussion of text drawing in the chapter QQuickDraw
TextOin this book.

Finding Line Breaks
You display text on the Macintosh screen by calling the QuickDraw text routines. These
routines handle text in different fonts, styles, and sizes, and even draw text that is

displayed in different directions. However, the QuickDraw text display routines do not
break lines for youto tinto screen areas of your own designation, which means that you
have to display your text line-by-line. (The QuickDraw text routines are described in the
chapter CQuickDraw TextOin this book.)
To draw a string line-by-line, you need to use the StyledLineBreak function. What
you do is start atthe rst character in your text and use StyledLineBreak to search for
the

rst line break, draw that portion of the string, and then start up again with the

character that follows the line break. You continue this process until the remaining
characters all ton one line. The size and style of the glyphs are factors in determining
how many characters t onto a line, since they affect the number of pixels required for
each glyph on the line. Another factor in breaking lines is that it is desirable to break a
line on a word boundary whenever possible.
The StyledLineBreak function looks for the next line break in a string. It

accommodates different fonts, styles, and glyph sizes, and accounts for complications
such as the word boundary rules for the script system of the text. You usually call
StyledLineBreak to traverse a line in memory order, which is not necessarily the same
as display order for mixed-directional text. StyledLineBreak nds line breaks on
word boundaries whenever possible. StyledLineBreak always chooses a line break for
the last style run on the line as if all trailing whitespace in that style run would be
stripped.
The StyledLineBreak function works on one style run at a time. To use
StyledLineBreak, you must represent the text in your documents in a manner that
allows you to quickly iterate through script runs in your text and style runs within
each script run. Figure 5-9 shows an example of a line break in a text string with
multiscript text runs.

5-24

Using the Text Utilities

CHAPTER

5

Text Utilities

Finding line breaks in multiscript text

AS

$6D

3

$65

©

$61

»

$6E

5

[o_)

$73

s

—_—_—_—____L]===]_—]—5
Style

runs

Dwmeans peace or

hello

:

$61

)

11

$72

r

12

$20

13

$68

h

14

$65

e

15|

$6C

|

16|

$6C

|

17

$6F

‘)

$65

I>

oo

$6F

$63

fii]

le

$65

TD

$70

J

$20

OD

BR
DWN
Dan

eo

oT7mnmmooeoDOo

wWwPwo

SES

«(lw tC”
—_

$EC

Ve WO

runs

PD

Script

gro

©

o

Figure 5-9

$20

Use the StyledLineBreak function when you are displaying text in a screen area to
determine the best place to break each displayed line. You can only use this function
when you have organized your text in script runs and style runs within each script run.
This type of text organization used by most text-processing applications that allow for
multiscript text.

Using the Text Utilities

5-25

CHAPTER

5

Text Utilities

What you do is iterate through your text, a script run at a time, using
StyledLineBreak to check each style run in the script run until the function
determines that it has arrived at a line break. As you loop through each style run, before
calling StyledLineBreak, you must set the text values in the current graphics port that
are used by QuickDraw to measure the text. These include the font, font size, and font

style of the style run. For details on these parameters, see the chapter CQQuickDraw TextO
in this book.
Once StyledLineBreak has arrived at a line break, you can display the line, advance
the pointers into your text, and call the function again to nd the next line break. You
continue to follow this sequence until you@e reached the end of your text.
StyledLineBreak does not break on a space character, so a sequence of spaces of any
length remains with the previous line.
The StyledLineBreak function uses a number of parameters; the value of some of

these parameters must change for each style run, and the value of others must change for
each script run. Figure 5-10 illustrates how the parameters of the StyledLineBreak
function are used when nding a line break in text that contains a number of script
and style runs.
Figure 5-10

Relationships of the parameters of StyledLineBreak

Line
break

textWidth

|

D127 Wimeans peace or‘hello
textStart

(1)

—

(1 =|

textPtr

(1)

textStart

(2)

textStart

(3)

textLen (2 and 3)
textPtr

>

(2 and 3)

The text Ptr parameter points to the start of the script run, the text Start parameter is
the location of the start of the style run, and the text Len parameter is the number of

bytes in the style run. The textWidth parameter speci es the number of pixels in the
display line. Other parameters are textEnd, which speci es the number of bytes in the
script run, and

text Offset, in which the location of the break is returned. Declarations

and descriptions of these parameters are found in the section StyledLineBreakO
beginning on page 5-79.

Note that the style runs in StyledLineBreak must be traversed in memory order, not
in display order. For more information about this, read about the Get Format Order
routine in the chapter GQuickDraw TextOin this book. It is also important to remember
that word boundaries can extend across style runs, but cannot extend across script runs.

5-26

Using the Text Utilities

CHAPTER

5

Text Utilities

The StyledLineBreak function looks for a line break on a word boundary. The only
time it cannot nd sucha break is when a word spans across an entire line. If such a word
starts past the beginning of the line, StyledLineBreak determines that a break should
occur before the start of the word; otherwise, it breaks the line in the middle of the word,

at a character boundary instead of at a word boundary. StyledLineBreak uses the
value of the textOffset parameter to differentiate between these two cases. The
textOffset parameter must be nonzero for the rst call on a line and zero for each
subsequent call to the function on the line.
No matter which case occurs,

Sty ledLineBreak returns a code that speci

es whether

or not it found a break and what kind of break (word or character boundary) it is. This
value is one of the constantsde nes as the StyledLineBreakCode
type:
StyledLineBreak

Value

constant
BreakOverflow

Meaning

2

No break is necessary because the current style run

BreakChar

1

Line breaks on character boundary

BreakWord

0

Line breaks on word boundary

ts

on the line (within the width)

StyledLineBreak automatically decrements the text Width variable by the width of
the style run for use on the next call. You need to set the value of textWidth before
calling it to process a line. Listing 5-4 shows a basic loop structure that you can use to call
StyledLineBreak
in your application.

Listing 5-4

Using the StyledLineBreak function

REPEAT
textOffset

:=

textWidth

:=

done

:=

WHILE

not

{repeat

for

each

line}

pixels

available

for

1
number

of

display

line

FALSE;

done

DO

BEGIN

{for

each

textPtr

:= the

address

of

the

first

textLen

:=

the

number

of

bytes

in

done

DO

WHILE

not

BEGIN

{for

textStart

:=

byte
of

textEnd

:=

byte
of

{Set

up

ans

:=

Using the Text Utilities

the

the

offset
style

offset
the

QuickDraw

run}

of

the

script

run

style

script

run

run}

script

run

of

the

start

run

within

style

byte
the

each

within

script

script

run

of

the

end

style

run}

run

font

parameters

for

StyledLineBreak(textPtr,

textLen,

textEnd,

textWidth,

flags,

textStart,
textOffset);

5-27

CHAPTER

5

Text Utilities

if

ans

<>

smBreakOverflow

THEN

done

:=

TRUE;

ELSE

textOffset

:=

0;{always

0 after

first

call}

END;
END;

{Display the text that starts
{ for textOffset bytes}
UNTIL

at

{until

textPtr

& continues

no

text

more

to

}

process}

Finding Subscripts Within a Script Run
Some script systems include subscripts, which are character sets that are subsidiary to the
main character set. One useful subscript is the set of all character codes that have the
same meaning in Roman as they do in a non-Roman script. For other scripts such as
Japanese, there are additional useful subscripts. For example, a Japanese script system
might include some Hiragana characters that are useful for input methods.
When you are displaying or working with a string that contains subscript characters, it is
often convenient to identify the subscript text runs so that you can treat those characters
differently. You might, for instance, want to display the Roman subscript text in a
different font, or apply different rules to it when searching for word boundaries. In
Figure 5-11, the English words CHebrewOand CRussianQOare initially drawn in native

language fonts from their script systems. Each of these words is then extracted and
redrawn using a font from the Roman script system.
Figure 5-11

Extracting blocks of Roman text

may

Hebrew,
Ramat Gan 24

mry Hebrew
Ramat Gan 24

Helvetica 24

Pycckun

Russian

LatinskijBook 24

Pyccxui,

Russian

LatinskijBook 24

Helvetica24

The FindScriptRun function is used to identify blocks of subscript text in a string.
FindScriptRun searches a string for such a block, and sets a VAR parameter to the
length in bytes of the subscript run that begins with the rst character in the string.

5-28

Using the Text Utilities

CHAPTER

5

Text Utilities

FindScriptRun also returns a script-run status record, which speci es the script code
and subscript information for the block of text. The elds of the script-run status record
are described in the section CFindScriptRun,Obeginning on page 5-81.

Working With Date and Time Strings
Applications that address international audiences must work with how the
numeric-format ('it10') resource and long-date-format ('it11') resource handle the
differences in date and time formats used in different countries and regions of the world.
The numeric-format resource contains general conventions for formatting numeric
strings. It provides several different de nitions, including separators for decimals,
thousands, and lists; currency information; time values; and short date formats. Some of
the variations in date and time formats are shown in Table 5-3.

Table 5-3

Variations in time and short date formats

Morning

Afternoon

Short date

System software

1:02 AM

1:02 PM

2/1/90

United States

1:02

13:02

02/01/90

Canadian French

1:02 AM

1:02 PM

90.01.02

Chinese

1:02

13:02

02-01-1990

Dutch

1:02 Uhr

13:02 Uhr

2.1.1990

German

1:02

13:02

2-01-1990

Italian

01.02

13.02

90-02-01

Swedish

For time and date values, the numeric-format resource includes values that specify this
information:
m

the order of the month, day, and year values in short date formats

m which separator to use in the short date format (for example, : or / or -)
m

the trailing string to display for morning (for example, A.M.)

m

the trailing string to display for evening (for example, P.M.)

m up to 4 trailing bytes to display for 24-hour times before noon, and another 4 bytes
to display for 24-hour times at noon and after. For example, the German string Uhr
is used for both purposes.
mw whether or not to indicate leading zeros in each of the time elements (hours,
minutes, and seconds)

Using the Text Utilities

5-29

CHAPTER

5

Text Utilities

The long-date-format resource includes conventions for long date formats, abbreviated
date formats, and the regional version of the script the resource is associated with. Some
of the variations in long and abbreviated date formats are shown in Table 5-4.
Table 5-4

Variations in long and abbreviated date formats

Long date

Abbreviated date

System software

Tuesday, January 2, 1990

Tue, Jan 2, 1990

United States

Tuesday, 2 January 1990

Tue, 2 Jan 1990

Australian

Mardi 02 janvier 1990

Mard 02 janv 1990

Canadian French

tirsdag 2. januar 1990

tir 2. jan 1990

Danish

Mardi 2 Janvier 1990

Mar 2 Jan 1990

French

The long-date-format resource includes values that specify this information:
m the names of the days
m the names of the months
m@ which punctuation to use for abbreviated day names and month names
You can optionally add an extension to a long-date-format resource that adds a number
of other speci cation capabilities, including the following:
m acalendar code for the speci

cation of calendars other than the standard Gregorian

calendar, such as the Arabic calendar

m a list of extra day names for calendars with more than seven days
m a list of extra month names for calendars with more than twelve months
m alist of abbreviated day names
m alist of abbreviated month names
m alist of additional date separators
Many of the Apple-supplied long-date-format resources already include such extensions.
The Text Utilities routines that work with dates and times use the information in the
long-date-format and numeric-format resources to create different string representations
of date and time values. The Macintosh Operating System provides routines that return
the current date and time to you in numeric format; you can then use the Text Utilities
routines to convert those values into strings that can be presented in different
international formats.
The Text Utilities also include routines that can parse date and time strings as entered by
users and llinthe elds of a record with the components of the date and time, including
the month, day, year, hours, minutes, and seconds.

For more details on the numeric-format ('i1t10') and long-date-format ('it11')
resources, see the appendix Cinternational ResourcesOin this book. For information on

5-30

Using the Text Utilities

CHAPTER

5

Text Utilities

obtaining the current date and time values from the Macintosh Operating System, see
Inside Macintosh: Operating System Utilities.

Converting Formatted Date and Time Strings
Into Internal Numeric Representations
When your application works with date and time values, it must convert string versions
of dates and times into internal numeric representations that it can manipulate. You
might, for example, need to convert a date typed by the user into a numeric
representation so that you can compute another date some number of days ahead. You
can then format the new value for display as a formatted date string.
The Text Utilities contains two routines that you can use to parse formatted date and time
values from input strings and create an internal numeric representation of the
date and time. The StringToDate function parses an input string for a date, and
the StringToTime function parses an input string (possibly the same input string) for
time information.
Both of these functions pass a date cache record as one of the parameters. A date cache
record is a data structure of type DateCacheRec that you must declare in your
application. Because you must pass this record as a parameter, you must initialize it by
calling the InitDateCache function before calling StringToDate or StringToTime.

You need to call InitDateCache only onceN typically in your main program
initialization code. For more information about the date cache record and the
InitDateCache function, see the section GnitDateCacheOon page 5-83.
Both the StringToDate and the StringToTime functions

llin

elds ina long

date-time record, which is de ned by a LongDateRec data structure. This data type is
described in the book Inside Macintosh: Operating System Utilities.

You usually use StringToDate and StringToTime sequentially to parse the date and
time values from an input string and llin these elds. Listing 5-5 shows how to rst call
StringToDate to parse the date, then offset the starting address of the string, and
nally, call StringToTime to parse the time.
Listing 5-5
str

:=

Using StringToDate and StringToTime
"March

27,

1992

strPtr

:= ptr(ord(@str)

strLen

status

08:14

+

p.m.";

1);

{Pointer

to

lst

char

:=

length(str);

:=

StringToDate(strPtr,

strLen,

myDateCache,

strPtr

:=

ptr(ord(@str)+numBytes+1) ;

strLen

:=

strlen

status

:=

StringToTime(strPtr,

numBytes,
-

str}

lDateRec) ;

numBytes;

strLen,

myDateCache,
numBytes,

Using the Text Utilities

of

lDateRec) ;

5-31

CHAPTER

5

Text Utilities

StringToDate parses the text string untilithas nished nding all date information or
until it has examined the number of bytes speci ed by textLen. It returns a status value
that indicates the con dence level for the success of the conversion. StringToDate
recognizes date strings in many formats, including (September 1, 1987,00 Sept 1987,0

OL/9/1987,Oand OL 1987 sEpT.O

Note that StringToDate
Ils in only the year, month, day, and day of the week;
StringToTime
lls in the hour, minute, and second. You can use these two routines

sequentially to

ll in all of the values in a LongDateRec record.

StringToDate assigns to its 1engthUsed parameter the number of bytes that it uses to
parse the date; use this value to compute the starting location of the text that you can
pass to StringToTime.

StringToDate interprets the date and StringToTime interprets the time based on
values that are de ned in the long-date-format ('it11') resource. These values, which
include the tokens used for separators and the month and day names, are described in
the appendix Gnternational ResourcesOin this book.
StringToDate uses the Int 1Tokenize function, as described in the chapter CScript
ManagerOin this book, to separate the components of the strings. It assumes that the
names of the months and days, as speci ed in the international long-date-format
resource, are single alphanumeric tokens.
When one of the date components is missing, such as the year, the current date value is
used as a default. If the value of the input year is less than 100, StringToDate
determines the year as follows.
1. If (current year) MOD 100 is greater than or equal to 90 and the input year is less than
or equal to 10, the input year is assumed to be in the next century.
2. If (current year) MOD 100 is less than or equal to 10 and the input year is greater than
or equal to 90, the input year is assumed to be in the previous century.
3. Otherwise, the input year is assumed to be in the current century.
If the value of the input year is between 100 and 1000, then 1000 is added to it. Thus the
dates 1/9/87, 1/9/987, and 1/9/1987 are equivalent.

Both StringToDate and StringToTime return a value of type
StringToDateStatus, which is a set of bit values that indicate con

dence levels, with

higher numbers indicating low con dence in how closely the input string matched what
the routine expected. Each StringToDateStatus value can contain a number of the
possible bit values that have been OR@d together. For example, specifying a date with
nonstandard separators may work, but it returns a message indicating that the separator
was not standard.

5-32

Using the Text Utilities

CHAPTER

5

Text Utilities

The possible values of this type are described in Table 5-5.
Table 5-5

StringToDateStatus values and their meanings

StringToDateStatus

Result of the conversion

fatalDateTime

A fatal error occurred during the parse.

tokenFrr

The token processing software could not

cantReadUtilities

The resources needed to parse the date or time value could
not be read.

dateTimeNot

A valid date or time value could not be found in the string.

value

Found

nd a token.

dateTimeInvalid

The start of a valid date or time value was found, but a valid

longDateFound

A valid long date was found. This bit is not set when a short
date or time was found.

leftOverChars

A valid date or time value was found, and there were

sepNotIntlSep

A valid date or time value was found; however, one or more

fieldOrderNotIintl

A valid date or time value was found; however, the order of

extraneousStrings

A valid date or time value was found; however, one or more

tooManySeps

date or time value could not be parsed from the string.

characters remaining in the input string.

of the separator characters in the string was not an expected
separator character for the script system in use.

the elds did not match the expected order for the script
system in use.
unparsable strings was encountered and skipped while
parsing the string.

A valid date or time value was found; however, one or more

extra separator characters was encountered and skipped

while parsing the string.
sepNot Consistent

A valid date or time value was found; however, the separator

characters did not consistently match the expected separators
for the script system in use.

For example, if StringToDate and StringToTime successfully parse date and
time values from the input string and more characters remain in the string, then the
function result will be the constant leftOverChars. If StringToDate discovers two

separators in sequence, the parse will be successful and the return value will be the
constant tooManySeps. If StringToDate ndsa perfectly valid short date, it
returns the value noErr; if StringToDate ndsa perfectly valid long date, it returns
the value longDateFound.

Using the Text Utilities

5-33

CHAPTER

5

Text Utilities

Date and Time Value Representations
The Macintosh Operating System provides several different representations of date and
time values. One representation is the standard date-time value that is returned by the
Macintosh Operating system routine Get DateTime. This is a 32-bit integer that
represents the number of seconds between midnight, January 1, 1904 and the current
time. Another is the date-time record, which includes integer
time component value.

elds for each date and

The Macintosh Operating System also provides two data types that allow for longer
spans of time than do the standard date-time value and date-time record: the long
date-time value and the long-date record. The long date-time value, of data type
LongDateTime, is a 64-bit, signed representation of the number of seconds since Jan. 1,

1904, which allows for coverage of a much longer span of time (approximately 30,000
years) than does the standard date-time representation. The long date-time record, of
data type LongDateRec, is similar to the date-time record, except that it adds several
additional

the year.

elds, including integer values for the era, the day of the year, and the week of

The Macintosh Operating System provides four routines for converting among the
different date and time data types:
m

DateToSeconds, which converts a date-time record into a standard date-time value

m

SecondsToDate, which converts a standard date-time value into a date-time record

m LongDateToSeconds, which converts a long-date record into a long date-time value
m LongSecondsToDate, which converts a long date-time value into a long-date record
The standard date-time value, the long date-time value, and each of the data structures
and routines mentioned in this section are described in the book Inside Macintosh:

Operating System Utilities.

Converting Standard Date and Time Values Into Strings
When you want to present a date or time value as a string, you need to convert from one
of the numeric date-time representations into a formatted string. The Text Utilities
include the DateString and TimeString procedures for converting standard
date-time values into formatted strings, and the LongDateString and

LongTimeString procedures for converting long date-time values into formatted
strings. Each of these routines uses information from a long-date-format or
numeric-format resource that you specify as a parameter.
When you use the DateString and LongDateString procedures, you can request an

output format for the resulting date string. The output format can be one of the three
values of the DateForm enumerated data type:
DateForm

5-34

=

(shortDate,longDate,abbrevDate) ;

Using the Text Utilities

CHAPTER

5

Text Utilities

Here are examples of the date strings that these speci
Value

Date string produced

shortDate

1/31/92

abbrevDate

Fri, Jan 31, 1992

longDate

Friday, January 31, 1992

cations produce.

When you request a long or abbreviated date format, the formatting information in a
long-date-format resource is used. For short date formats, the information is found in a
numeric-format resource. The DateString and LongDateString procedures use the

long-date-format or numeric-format resource that you specify. If you request a long or
abbreviated date format, you must include the handle to a long-date-format resource,

and if you request a short date format, you must include the handle to a numeric-format
resource. If you specify NIL for the value of the resource handle parameter, both routines
uses the appropriate resource from the current script.
When you use the TimeString and LongTimeString procedures to produce a
formatted time string, you can request an output format for the resulting string. You
specify whether or not you want the time string to include the seconds by passing a
Boolean parameter to these procedures.
Value

Time string produced

FALSE

03:24 P.M.

TRUE

03:24:17 P.M.

The TimeString and LongTimeString procedures use the time formatting
information in the numeric-format resource that you specify. This information de nes
which separator to use between the elements of the time string, which suf x strings to
use, and whether or not to add leading zeros in each of the time elements. If you specify
NIL in place of a resource handle, these procedures use the numeric-format resource

from the current script.

Working With Numeric Strings
When you present numbers to the user, or when the user enters input numbers for your
application to use, you need to convert between the internal numeric representation of
the number and the output (or input) format of the number. The Text Utilities provide
several routines for performing these conversions. Some of these routines take into
account the many variations in numeric string formats (output formats) of numbers in
different regions of the world.
If you are converting integer values into numeric strings or numeric strings into integer
values, and you don@need to take international number formats into account, you can
use the two basic number conversion routines: NumToSt ring, which converts an integer
into a string, and StringToNum, which converts a string into an integer. These routines
are described in the section Converting Between Integers and Numeric Strings, Owhich
begins on page 5-38.

Using the Text Utilities

5-35

CHAPTER

5

Text Utilities

If you are working with Soating-point numbers, or if you want to accommodate the
possible differences in output formats for numbers in different countries and regions of
the world, you need to work with number format speci cation strings. These are strings
that specify the input and output formats for numbers and allow for a tremendous
amount of Sexibility in displaying numbers.
To use number format speci cation strings and convert numbers, you need to follow
these steps:
1. You. rst de ne the format of numbers with a number format speci cation string. An
example of such a string is ###, ### .##; -###, #H# .##; 0. This string speci es three
number formats: for positive number values, for negative number values, and for zero

values. The section (Using Number Format Speci
page 5-39, describes these de nitions in detail.

cation Strings,Owhich begins on

2. You must also de ne the syntactic components of numeric string formats using a
number parts table. This table is part of the tokens ('it14') resource for each script
system. It includes de nitions of which characters are used in numeric strings for
displaying the percent sign, the minus sign, the decimal separator, the less than or
equal sign, and other symbols. The number parts table is described with the tokens
resource in the appendix Cinternational ResourcesOin this book.
3. You then use Text Utilities routines to convert the number format speci cation string
into an internal representation that is stored in a NumFormatStringRec record. This
is a private data type that is used by the number conversion routines. You convert a
number format speci cation string into a NumFormat StringRec record with the
StringToFormatRec function, and you perform the opposite conversion with the
FormatRecToString function. Both of these functions are described in the section

(Converting Number Format Speci cation Strings Into Internal Numeric
Representations,
Owhich begins on page 5-43.

4. Once you have a NumFormatStringRec record that de nes the format of numbers
for a certain country or region, you can convert Soating-point numbers into numeric
strings and numeric strings into Soating-point numbers. The StringToExtended

and ExtendedToString functions perform these conversions; these are described in
the section QUsing Number Format Speci cation Strings,Owhich begins on page 5-39.
To accommodate all of the possibilities for the different number formats used in different
countries and regions, you need to work with numeric strings, number parts tables,
number format speci cation strings, and Soating-point numbers. The Text Utilities
include the routines shown in Figure 5-12 to make it possible for your application to
accept and display numeric strings in many different formats. You can accept an input
string in one format and create an output numeric string that is appropriate for an
entirely different area of the world. Figure 5-12 summarizes the relationships among the
different data and routines used for these conversions.

5-36

Using the Text Utilities

CHAPTER

5

Text Utilities

Figure 5-12

Using the number formatting routines

Number format specification string
“HEHE EH
FE"

StringToFormatRec

a

Input string
"123,456.78"

saris table

=>

| ¢

|

Internal numeric

Floating-point number

representation

y

F ormatRecToString
tRecToSt

|=

Number format specification string
“HEHE EH
FE"

The number format speci

StringToExtended

Number
parts
table

[==> |

a|

ExtendedToSt
ExtendedTostring

Output string
"123,456.78"

cation string in the upper left box in Figure 5-12 de nes how

input and output numeric strings are formatted; in this case, they are formatted in the

style most commonly used in the United States, with a comma as the thousand separator.
The StringToFormatRec format takes the number format speci cation string as input,
along with a number parts table, and creates an internal representation, which is stored in
a record of data type NumFormatStringRec.
If you later want to create a number format speci cation string from the internal
representation, you can call the FormatRecToString function. This function takes a
record of type NumFormat
St ringRec and a parts table, and creates a string that you can
display or edit.
Once you have an internal representation of your formatting speci cation, you can
use it for converting between strings and Soating-point numbers. The
StringToExt ended function takes an input string, a NumFormatStringRec, anda
number parts table, and creates a fSoating-point number. The Ext endedToSt ring
function takes a Soating-point number, a NumFormatStringRec, and a number parts
table, and creates a string.

Using the Text Utilities

5-37

CHAPTER

5

Text Utilities

Each of the four functions shown in Figure 5-12 returns a result of type FormatStatus,
which is an integer value. The low byte of the result is of type FormatResultType, the
values of which are summarized in Table 5-6.
Table 5-6

FormatResultType

FormatStatus

value

values for numeric conversion functions

Result of the conversion

fFormatoOK

The format of the input value is appropriate and the
conversion was successful.

fBestGuess

The format of the input value is questionable; the result of

fOutoOfSynch

The format of the input number string did not match the
format expected in the number format speci cation string.

fSpuriousChars

There are extra characters in the input string.

fMissingDelimiter

A delimiter is missing in the input string.

fExtraDecimal

An extra decimal was found in the input number string.

fMissingLiteral

The close of a literal is missing in the input number string.

fExtraExp

There is an extra exponent in the input number string.

fFormatOverflow

The number in the input string exceeded the magnitude
allowed for in the number format speci cation.

fFormStriIsNAN

The format speci

fBadPartsTable

The parts table is not valid.

fExtraPercent

There is an extra percentage symbol in the input
number string.

fExtraSeparator

There was an extra separator in the input number string.

fEmptyFormatString

The format speci

the conversion may or may not be correct.

cation string is not valid.

cation string was empty.

Converting Between Integers and Numeric Strings
The simplest number conversion tasks for your application involve integer values and do
not take international output format differences into account. Text Utilities provides one
routine to convert an integer value into a numeric string and another to convert a
numeric string into an integer value.
The NumToString procedure converts a long integer value into a string representation
of it as a base-10 value. The StringToNum procedure performs the opposite operation,
converting a string representation of a number into a long integer value. For example,
Listing 5-6 converts a number into a string and then back again.

5-38

Using the Text Utilities

CHAPTER

5

Text Utilities

Listing 5-6

Converting a long integer into

a numeric string

VAR

str:

Str255;

i,j:

LongInt;

BEGIN

1

:=

4329;

NumToString(i, str);
StringToNum(str, j);

{str is now “4329”}
{j is now 4329 }

END ;

Using Number Format Specification Strings
When you want to work with Soating-point values and numeric strings, you need to take
into account the different formats that are used for displaying numbers in different
countries and regions of the world. Table 5-7 shows some of the numeric string formats
that are used in different versions of system software.
Table 5-7

Numeric string formats

Numeric string

System software

1,234.56

All versions

1 234,56

French and others

1.234,56

Danish and others

1 234.56

Greek

1.234 56

Russian

1034.56

Swiss French, Swiss German

You use number format speci cation strings to de ne the appearance of numeric strings
in your application. Each number format speci cation string contains up to three parts:
the positive number format, the negative number format, and the zero number format.
Each format is applied to a numeric value of the corresponding type: when a positive
value is formatted, the positive format is used, when a negative value is formatted, the
negative format is used, and when a zero value is formatted, the zero format is used.

When a number format speci cation string contains only one part, that part is used for all
values. When a number format speci cation string contains two parts, the rst part is
used for positive and zero values, and the second part is used for negative values.

Using the Text Utilities

5-39

CHAPTER

5

Text Utilities

Table 5-8 shows several different number format speci cation strings, and the output
numeric string that is produced by applying each format to a numeric value.
Table 5-8

Examples of number format specification strings

Number format specification string

Numeric value

Output format

HHH, HHE

123456.78

123,456.78

HHH, HHH. O48, HHH

1234

1,234.0

HHH, HHH. O48, HHH

3.141592

3.141,592

###;

1

(001)

1.234999

1.235

#H#'CR'; ###'DB';'*zero’!

1

1CR

##H'CR'; ###'DB';'‘zero’!

0

‘zero’

HHS

0.1

10%

HH

HE; -HHH,

HE

HE; 0

(000) ;***
. HHH

The three portions of a number format speci cation string (positive, negative, and zero
formats) are separated by semicolons. If you do not specify a format for negative values,
negative numbers are formatted using the positive format and a minus sign is inserted at
the front of the output string. If you do not specify a format for zero values, they are
presented as a single OQligit.
These number format speci

cation strings contain different elements:

m™ number parts separators for specifying the decimal separator and the thousand
separator

m literals that you want included in the output formats
m digit placeholders
m™ quoting mechanisms for handling literals correctly
m= symbol and sign characters
Number parts separators come in two types: the decimal separator and the thousand
separator. In the U.S. localized version of the Roman script system, the decimal separator
is the (tharacter and the thousand separator is the @haracter. Some script systems use
other characters for these separators. The number conversion routines each take a
number parts table parameter that includes de nitions of the separator characters.

5-40

Using the Text Utilities

CHAPTER

5

Text Utilities

Literals in your format strings can add annotation to your numbers. Literals can be
strings or brackets, braces, and parentheses, and must be enclosed in quotation marks.

Table 5-9 shows some examples of using literals in number format speci
Table 5-9

cation strings.

Literals in number format strings

Number format specification string

Numeric

Output format

1

1CR

value

###'CR';###'DB';\‘“zero\’”
[###'

Million

'###'

Thousand

'###]

300

[300]

[###'

Million

'###'

Thousand

'###]

3210432

[3

Million

210

Thousand

432]

Digit placeholders that you want displayed in your numeric strings must be indicated by
digit symbols in your number format speci cation strings. There are three possible digit
symbols: zero digits (0), skipping digits (#), and padding digits (*). The format string in
line 4 of Table 5-8 contains examples of each. The actual characters used for denoting
each of these are de

ned in the tokens ('it14') resource number parts table.

m Zero digits add leading zeros wherever an input digit is not present. For example, 1
in line 4 of Table 5-8 produces (001) because the negative number format is speci ed as
000)O meaning that the output is enclosed in parentheses and leading zeros are
added to produce three digits.
mw Skipping digits only produce output characters when an input digit is present. For
example, if the positive number format is GH##Oand the input string is AQ then the
output format is AO(not O 10as you might expect. Each skipping digit in the number
format speci cation string is replaced by a digit character if one is present, and is not
replaced by anything (is skipped) if a digit character is not present.
m Padding digits are like zero digits except that a padding character such as a
nonbreaking space is used instead of leading zeros to G@adOthe output string. You
can use padding digits to align numbers in a column. The number conversion
routines each take a number parts table parameter that includes de nitions of
padding characters.
You must specify the maximum number of digits allowed in your formats, as the number
formatting routines do not allow extension beyond them. If the input string contains too
many digits, an error (formatOverf low) will be generated. If the input string contains
too many decimal places, the decimal portion is automatically rounded. For example,
given the format of ###.###, a value of 1234.56789 results in an error condition, and a
value of 1.234999 results in the rounded-off 1.235 value.

Using the Text Utilities

5-41

CHAPTER

5

Text Utilities

The number formatting routines always ll in integer digits from the right and decimal
places from the left. This can produce the results shown in Table 5-10, which includes a
literal in the middle of the format strings to demonstrate this behavior.
Table 5-10

Filling digits in

Number format
specification string

Numeric value

Output format

#H#'my

1

1

#H#'my HHH

123

123

##H#'my'#HH

1234

Imy234

O.###'my' ###

O.1

0.1

O.###'my' ###

0.123

1.123

O.##+#'my' ###

0.1234

0.123my4

HHH

Quoting mechanisms allow you to enclose most literals in single quotation marks in
your number format speci cation strings. If you need to include single quotation marks
as literals in your output formats, you can precede them with the escape character (\).
Table 5-11 shows several examples of using quoting mechanisms.
Table 5-11

Quoting mechanisms in number format strings

Number format specification string

Numeric
value

Output format

###'CR'; ##H#'DB';'‘zero’!

1

1CR

###'CR'; ##H#'DB';'‘zero’!

-1

1DB

##HH'CR'; ##H#'DB';'‘zero’!

0

‘zero’

Symbol and sign characters in your number format speci cation strings allow you to
display the percent sign, exponents, and numbersGsigns. The actual glyphs displayed for
these symbols depend on how they are de ned in the number parts table of a tokens
resource. The symbols that you can use and the characters used for them in the U.S.
Roman script system are shown in Table 5-12.

5-42

Using the Text Utilities

CHAPTER

5

Text Utilities

Table 5-12

Symbols in number format strings

Symbol

U.S.

Roman

string

Number format

Example

Plus sign

+

+#HH

+13

-#HH

243
14%

Minus sign
Percent sign

Yo

#HS

EPlus

E+

HH

EMinus

E

#.#E-#

.HHHHE+0

1.2344E+3
1.2E 3

For more information about these symbols and the tokens de ned for them, see the
section on number parts tables in the appendix Ginternational ResourcesOin this book.

Converting Number Format Specification Strings Into Internal
Numeric Representations

To use a number format speci cation string in your application, you must rst convert
the speci cation string into an internal numeric representation that is independent of
country, language, and other cultural considerations. This allows you to map the number
into different output formats. This internal representation is sometimes called a canonical
number format. The internal representation of format strings is stored in a
NumFormat StringRec

record.

You can use the StringToFormatRec function to convert a number format speci cation
string into a NumFormatStringRec record. To perform this conversion, you must also
specify a number parts table from a numeric-format resource. The
number parts table de nes which characters are used for certain purposes (such as
separating parts of anumber) in the format speci cation string.
You can use the FormatRecToString function to convert

a NumFormatStringRec

record back into a number format speci cation string, in which the three parts (positive,
negative, and zero) are separated by semicolons. This function also uses a number parts
table to de ne the components of numbers; by using a different table than was used in
the call to StringToFormatRec, you can produce a number format speci cation string
that speci es how numbers are formatted for a different region of the world. You use
Format RecToString when you want to display the number format speci cation string
to a user for perusal or modi cation.

Converting Between Floating-Point Numbers and Numeric Strings
Once you have a NumFormatStringRec record that de nes the format of numbers for a
certain region of the world, you can convert between Soating-point numbers and
numeric strings.
You can use the StringToExtended function to convert a numeric string into an 80-bit
Soating-point value. StringToExtended uses a NumFormat StringRec record and a
number parts table to examine and convert the numeric string into a Soating-point value.

Using the Text Utilities

5-43

CHAPTER

5

Text Utilities

The ExtendedToSt ring function performs the opposite conversion: it uses a
NumFormatStringRec record and a number parts table to convert an 80-bit
Soating-point value into a numeric string that is formatted for output.

Text Utilities Reference
This section describes the data structures and routines that comprise the Text Utilities.
The CData StructuresOsection provides a description of the data structures that are used
with certain of the Text Utilities routines. The CRoutinesOsection describes the routines
you can use in your applications to work with strings.

Data Structures
This section describes the data structures that are used with the Text Utilities routines.

Each is used with one or more of the Text Utilities routines to pass information into or to
receive information back from the routine.

The Offset Table Record
The FindWordBreaks procedure uses the offset table, which is de

ned by the

OffsetTable data type. You pass a record of this type by VAR to FindWordBreaks,
andit lIlsinthe elds to specify the location of the next word in the input string. The
FindWordBreaks procedure is described in the section (FindWordBreaks,Owhich
begins on page 5-77.
OffsetTable

OffPair

=

ARRAY

[0..2]

of

OffPair;

{offset
{offset

of
of

=

RECORD

offFirst: Integer;
offSecond: Integer;

first word boundary}
second word boundary}

END;
Field descriptions

offFirst

The offset in bytes from the beginning of the string to the
character of the word.

of

The offset in bytes from the beginning of the string to the last
character of the word.

fSecond

rst

Although the offset table contains three Of £Pair records, the FindWordBreaks
procedure Ilsin only the rst of these records with the offset values for the word

5-44

Text Utilities Reference

CHAPTER

5

Text Utilities

that it nds. The other two entries are for use by the HiliteText procedure, which is
described in the chapter QQuickDraw TextOin this book.

The Date Cache Record
The StringToDate and StringToTime functions use the date cache, de ned by the
DateCacheRecord data type, as an area to store date conversion data that is used by the
date conversion routines. This record must be initialized by a call to the InitDateCache
function, which is described in the section GnitDateCacheObeginning on page 5-83. The
data in this record is privateN you should not attempt to access it.
DateCachePtr

=

“DateCacheRecord;

DateCacheRecord
PACKED

=

RECORD

hidden:

ARRAY

[0..255]

OF

INTEGER;

{only

for

temporary

use}

END ;

Field descriptions

hidden

The storage used for converting dates and times.

The Number Format Specification Record
Four of the numeric string functions use the number formatting speci
the NumFormatStringRec

data type: StringToFormatRec,

cation, de ned by

FormatRecToString,

StringToExtended, and ExtendedToString. The number format speci cation
record contains the data that represents the internal number formatting speci cation
information. This data is stored in a private format.
NumFormatStringRec
PACKED

=

RECORD

flength:

Byte;

fVersion:
hidden:

Byte;
ARRAY

[0..253]

OF

INTEGER;

{only

for

temporary

use}

END;

Field descriptions

fLength

The number of bytes (plus 1) in the hidden data actually used for
this number formatting speci cation.

fVersion

The version number of the number formatting speci

cation.

hidden

The data that comprises the number formatting speci

cation.

Text Utilities Reference

5-45

CHAPTER

5

Text Utilities

The Triple Integer Array
The FormatRecToString function uses the triple-integer array, de ned by the
TripleInt data type, to return the starting position and length in a string of three
different portions of a formatted numeric string: the positive value string, the negative
value string, and the zero value string. Each element of the triple integer array is an
FVector record.
TripleiInt

=

ARRAY [0..2]
FVector

OF

FVector;

{indexed

by

fPositive..fZero}

=

RECORD
Start:

length:

Integer;

Integer;

END;

Field descriptions

start

The starting byte position in the string of the speci
information.

cation

length

The number of bytes used in the string for the speci
information.

cation

Each of the three FVector entries in the triple integer array is accessed by one of the
values of the FormatClass type.
FormatClass

=

(fPositive,fNegative,fZero) ;

The Script Run Status Record
The FindScriptRun function returns the script run status record, de ned by the
ScriptRunStatus data type, when it completes its processing, which is to nda run of
subscript text in a string. The FindScriptRun function is described in the section
(FindScriptRun,Owhich begins on page 5-81.
ScriptRunStatus

=

RECORD

script:

SignedByte;

{script

variant:

SignedByte;

{additional

END;

5-46

Text Utilities Reference

code

of

block}

CharacterType

information}

CHAPTER

5

Text Utilities

Field descriptions

The script code of the subscript run. Zero indicates the Roman script

script

system.

Script-speci

variant

c information about the run, in the same format as that

returned by the CharacterType function, described in the chapter

(Script ManagerOin this book. This information includes the type of
subscriptN for example, Kanji, Katakana, or Hiragana for a Japanese
script system.

Routines
This section describes the routines that you use to work with strings in your application,
including sorting strings, modifying the contents of strings, converting dates and times to
and from strings, and converting numbers to and from strings.
De

ning and Specifying Strings
This section describes two routines that you can use to work with string handles and two
routines for accessing string resources.
m The NewString function creates a copy of the speci
the heap.

ed string as a relocatable object in

m The SetString procedure changes the contents of a string that has already been
allocated in the heap.
m The GetString function loads a string from a resource of type
string from the resource le if necessary.

'STR_

', reading the

m The GetIndString procedure copies a string from a string list that is contained in a
resource of type 'STR#'.

NewsString
The NewSt ring function allocates memory in the heap for a string, copies its contents,
and produces a handle for the heap version of the string.
FUNCTION

theString

NewString

(theString:

Str255):

StringHandle;

A Pascal string that you want copied onto the heap.

Text Utilities Reference

5-47

CHAPTER

5

Text Utilities

DESCRIPTION

NewSt ring returns a handle to the newly allocated string. If the string cannot be
allocated, NewSt ring returns NIL. The size of the allocated string is based on the actual
length of theString, which may not be 255 bytes.

Note

Before using Pascal string functions that can change the length of the
string, it is a good idea to maximize the size of the string object on the
heap. You can call either the Set String procedure or the Memory
Manager procedure SetHandleSize to modify the string@ size.

SPECIAL CONSIDERATIONS

NewSt ring may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the

NewSt ring

function is

Trap macro

_NewString

SetString
The Set
St ring procedure changes the contents of a string referenced by a string handle,
replacing the previous contents by copying the speci ed string.
PROCEDURE

SetString

(h:

StringHandle;

theString:

Str255) ;

h

A handle to the string in memory whose contents you are replacing.

theString

A

Pascal string.

DESCRIPTION
The Set String procedure sets the string whose handle is passed in the h parameter to
the string speci ed by the parameter theSt ring. If the new string is larger than the
string originally referenced by h, Set String automatically resizes the handle and copies
in the contents of the speci ed string.

SPECIAL CONSIDERATIONS

SetString may move memory; your application should not call this procedure at
interrupt time.

5-48

Text Utilities Reference

CHAPTER

5

Text Utilities

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the

Set String procedure is

Trap macro

_SetString

GetString
The Get String function loads a string from a string ('STR ') resource into memory. It
returns a handle to the string with the speci ed resource ID, reading it from the resource
le if necessary.
FUNCTION

GetString

stringID

(stringID:

Integer):

The resource ID of the string ('STR_

StringHandle;

') resource containing the string.

DESCRIPTION
The Get String function returns a handle to a string with the speci ed resource ID. If
Get String

cannot read the resource, it returns NIL.

Get String calls the Get Resource function of the Resource Manager to access the
string. This means that if the speci ed resource is already in memory, Get String simply
returns its handle.
Like the NewSt ring function,
the actual length of the string.

Get String returns a handle whose size is based upon

Note
If your application uses a large number of strings, it is more ef cient to
store them in a string list

(' STR#') resource than as individual resources

in the resource le. You then use the Get IndSt ring procedure to access
each string in the list.

SPECIAL CONSIDERATIONS

Get String

does not create a copy of the string.

Get String may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the

Get String function is

Trap macro

_GetString

Text Utilities Reference

5-49

CHAPTER

5

Text Utilities

GetIndString
The Get IndSt ring

procedure loads a string from a string list

(' STR#') resource into

memory. It accesses the string by using the resource ID of the string list and the index of
the individual string in that list. The list is read from the resource le if necessary.
PROCEDURE

GetIndString

(VAR

theString:

index:

Str255;

strListID:

Integer;

Integer) ;

theString

On output, the Pascal string result.

strListID

The resource ID of the 'STR#' resource that contains the string list.

index

The index of the string in the list. This is a value from 1 to the number of
strings in the list that is referenced by the strList ID parameter.

DESCRIPTION
Get IndString returns in the parameter theSt ring a copy of the string from a string
list that has the resource ID provided in the st rList ID parameter. If the resource that
you specify cannot be read or the index that you specify is out of range for the string list,
GetIndString

sets theString

to an empty string.

If necessary, Get IndSt ring reads the string list from the resource le by calling the
Resource Manager function Get Resource. Get IndString accesses the string speci ed
by the index parameter and copies it into theString. The index can range from 1 to
the number of strings in the list.

SPECIAL CONSIDERATIONS

Get IndString may move memory; your application should not call this procedure at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

There is no trap macro for the Get IndSt ring procedure. Instead, you need to use the
_GetResource trap macro with the resource type ('STR#') and string index.
Comparing Strings for Equality
This section describes text routines that you can use to determine whether two strings are
equal.
Some of the routines operate on Pascal strings and others on text strings. Pascal strings
are stored using standard Pascal string representation, which precedes the text
characters with a length byte; these strings are limited to 255 bytes of data. Text strings
do not use a length byte and can be up to 32 KB in length. Pascal strings are passed
directly as parameters, while text strings are speci ed by an address value and an
integer length value.

5-50

Text Utilities Reference

CHAPTER

5

Text Utilities

m The EqualString function compares two Pascal strings using the comparison rules
of the Macintosh le system. This function does not make use of any script or
language information.
m The IdenticalString function compares two Pascal strings for equality, making
use of the string comparison information from a speci ed resource.
m The IdenticalText function compares two text strings for equality, making use of
the string comparison information from a speci ed resource.

EqualString
The EqualString function compares two Pascal strings for equality, using the
comparison rules of the Macintosh le system. The comparison performed by
EqualString is a simple, character-by-character value comparison. This function does
not make use of any script or language information; it assumes the use of a Roman script
system.
FUNCTION

EqualString

(aStr,

bStr:

caseSens,

Str255;
diacSens:

aStr

One of the Pascal strings to be compared.

bStr

The other Pascal string to be compared.

caseSens

diacSens

A

Boolean):

Boolean;

fag that indicates how to handle case-sensitive information during the
comparison. If the value of caseSens is TRUE, uppercase characters are
distinguished from the corresponding lowercase characters. If it is FALSE,
case information is ignored.
A fag that indicates how to handle information about diacritical marks
during the string comparison. If the value of diacSens is TRUE,
characters with diacritical marks are distinguished from the
corresponding characters without diacritical marks during the
comparison. If it is FALSE, diacritical marks are ignored.

DESCRIPTION

EqualString returns TRUE if the two strings are equal and FALSE if they are not equal.
If its value is TRUE, Equal String distinguishes uppercase characters from the
corresponding lowercase characters. If its value is FALSE, EqualString ignores diacritical
marks during the comparison.

SPECIAL CONSIDERATIONS

The EqualString function is not localizable.

Text Utilities Reference

5-51

CHAPTER

5

Text Utilities

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the EqualString function are
Trap macro

Selector

_CmpString

$A03C

This trap macro can take optional arguments, each of which changes the default setting
used by the macro when it is called without arguments. Each of these arguments
corresponds to the Boolean parameters that are used with the Pascal function call. The
various permutations of this trap macro are shown below; you must type each exactly as
it is shown. The syntax shown here applies to the MPW Assembler; if you are using
another development system, be sure to consult its documentation for the proper syntax.
Macro permutation
_CmpString

Value of
diacSen

Value of

s

caseSens

FALSE

FALSE

_CmpString

,MARKS

TRUE

FALSE

_CmpString

,CASE

FALSE

TRUE

_CmpString

,MARKS,CASE

TRUE

TRUE

The registers on entry and exit for this routine are
Registers on entry

AO

pointer to

rst character of the

rst string

Al

pointer to

rst character of the second string

DO

high-order word: number of bytes in the rst string
low-order word: number of bytes in the second string

Registers on exit

DO

long word result: 0 if strings are equal, 1 if strings are not equal

IdenticalString
The IdenticalString function compares two Pascal strings for equality, making use
of the string comparison information from a resource that you specify as a parameter.
Ident icalString uses only primary differences in its comparison.
FUNCTION

IdenticalString

(aStr,

bStr:

itl2Handle:

5-52

Str255;
Handle):

aStr

One of the Pascal strings to be compared.

bstr

The other Pascal string to be compared.

Text Utilities Reference

Integer;

CHAPTER

5

Text Utilities

itl2Handle

A handle to a string-manipulation ('it12') resource that contains string
comparison information.

DESCRIPTION

IdenticalString returns 0 if the two strings are equal and 1 if they are not equal.
It compares the two strings without regard for secondary sorting order, the meaning
of which depends on the language of the strings. For example, for the English language,
using only primary differences means that Ident icalString ignores diacritical
marks and does not distinguish between lowercase and uppercase. For example, if the
two strings are

returns 0.

'Rose'

and

'rosé', IdenticalString considers them equal and

The it 12Handle parameter is used to specify a string-manipulation resource. If the
value of this parameter is NIL, IdenticalString makes use of the resource for the
current script. The string-manipulation resource includes tables for modifying string
comparison and tables for case conversion and stripping of diacritical marks.
Specifying a resource as a parameter is described in the section CObtaining Resource
Information,Owhich begins on page 5-4.

SPECIAL CONSIDERATIONS

IdenticalString may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

There is no trap macro for the

IdenticalString function. Instead, you must convert

the Pascal string into a text string by creating a pointer toits rst character and nding its
length, and then use the same macro as you do for the IdenticalText function, which
is described next.

IdenticalText
The IdenticalText function compares two text strings for equality, making use of the
string comparison information from a resource that you specify as a parameter.
IdenticalText uses only primary sorting order in its comparison.
FUNCTION

IdenticalText

(aPtr,

bPtr:

itl2Handle:

Ptr;

aLen,

Handle):

bLen:
Integer;

aPtr

A pointer to the

rst character of the

bPtr

A pointer to the

rst character of the second text string.

aLen

The number of bytes inthe

Text Utilities Reference

Integer;

rst text string.

rst text string.

5-53

CHAPTER

5

Text Utilities

bLen

The number of bytes in the second text string.

itl2Handle

A handle to a string-manipulation ('i1t12') resource that contains string
comparison information.

DESCRIPTION

IdenticalText returns 0 if the two text strings are equal and 1 if they are not equal. It
compares the strings without regard for secondary sorting order, which means that it
ignores diacritical marks and does not distinguish between lowercase and uppercase. For
example, if the two text strings are 'Rose' and 'rosé', IdenticalText considers
them equal and returns 0.
The it12Handle parameter is used to specify a string-manipulation resource. If
the value of this parameter is NIL, IdenticalText makes use of the resource for

the current script. The string-manipulation resource includes routines and tables for
modifying string comparison and tables for case conversion and stripping of
diacritical marks.
Specifying a resource as a parameter is described in the section CObtaining Resource
Information,Owhich begins on page 5-4.

SPECIAL CONSIDERATIONS

IdenticalText may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the IdenticalText function are
Trap macro

Selector

_Pack6

$001C

Determining Sorting Order for Strings in Different Languages
This section describes the Text Utilities routines available to help you sort strings in
different languages. When strings from different languages occur in a single list, you
must separate the strings so that all strings from each script system are contained in their
own list. You then sort the list for each script system, using the sorting rules for that
language and script system. You can then concatenate the individual language lists
together, ordering the lists according to language and script ordering information that is
found in the international script-sorting ('it1m') resource.
m The ScriptOrder function indicates the order in which text from two different script
systems should be sorted.
mw The LanguageOrder function indicates the order in which text from two different

languages from the same script system should be sorted.

5-54

Text Utilities Reference

CHAPTER

5

Text Utilities

m The StringOrder function determines the appropriate sorting order for two Pascal
strings, taking into account the script and language codes of each.
m The TextOrder function determines the appropriate sorting order for two text
strings, taking into account the script and language codes of each.
Note
When determining the order in which text from two different script
systems should be sorted, the system script always sorts rst, and scripts
that are not enabled and installed always sort last. Invalid script or
language codes always sort after valid ones.
Script systems and the enabling and installing of scripts are described in the chapter
(Script ManagerOin this book and the script-sorting resource is described in the
appendix Cinternational ResourcesOin this book.
Pascal strings are stored using standard Pascal string representation, which precedes the
text characters with a length byte; these strings are limited to 255 characters. Text strings
do not use a length byte and can be up to 32 KB in length. Pascal strings are passed
directly as parameters, while text strings are speci ed by two parameters: an address
value and an integer length value.
The functions LanguageOrder,

StringOrder,

and TextOrder

accept as parameters

the implicit language codes listed in Table 5-13, as well as the explicit language codes
listed in the chapter Gcript Manager.O
Table 5-13

Implicit language codes

Constant

Value

Explanation

systemCurLang

2

Current language for system script (from 'it1lb')

systemDefLang

3

Default language for system script (from 'it1m')

currentCurLang

4

Current language for current script (from 'itlb')

currentDefLang

5

Default language for current script (from

scriptCurLang

6

Current language for speci ed script (from 'itlb')

scriptDefLang

7

Default language for speci

'it1m')

ed script (from 'itlm')

ScriptOrder
The ScriptOrder function determines the order in which strings in two different scripts
should be sorted.
FUNCTION

ScriptOrder

(scriptl,

script2:

scriptl

The script code of the

script2

The script code of the second script.

Text Utilities Reference

ScriptCode):

Integer;

rst script.

5-55

CHAPTER

5

Text Utilities

DESCRIPTION

ScriptOrder takes a pair of script codes and determines in which order strings from
the rst script system should be sorted relative to strings from the second script system.
It returns a value that indicates the sorting order: 1ifstringsin the rst script should be
sorted before strings in the second script are sorted, 1 if strings in the rst script should
be sorted after strings in the second script are sorted, or 0 if the sorting order does not
matter (that is, if the scripts are the same).

The script code values are listed in the chapter Gcript ManagerOin this book.
Note

Text of the system script is always
result returned by this function. #

rst ina

sorted list, regardless of the

SPECIAL CONSIDERATIONS

ScriptOrder may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the ScriptOrder function are
Trap macro

Selector

_Pack6é

$001E

LanguageOrder
The LanguageOrder function determines the order in which strings in two different

languages should be sorted.
FUNCTION

LanguageOrder

(languagel,

language2:

languagel

The language code of the

language2_

The language code of the second language.

LangCode):

Integer;

rst language.

DESCRIPTION

LanguageOrder takes a pair of language codes and determines in which order strings
from the rst language should be sorted relative to strings from the second language. It
returns a value that indicates the sorting order: 1lifstringsin the rst language should
be sorted before sorting text in the second language, 1 if strings in the rst language
should be sorted after sorting strings in the second language, or 0 if the sorting order
does not matter (that is, if the languages are the same).

5-56

Text Utilities Reference

CHAPTER

5

Text Utilities

Explicit language code values are listed in the chapter Script ManagerQ implicit
language codes are listed in Table 5-13 on page 5-55 of this chapter. The implicit
language codes scriptCurLang and scriptDefLang are not valid for

LanguageOrder because the script system being used is not speci
this function.

ed as a parameter to

SPECIAL CONSIDERATIONS

LanguageOrder may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the LanguageOrder function are
Trap macro

Selector

_Packé

$0020

StringOrder
The StringOrder function compares two Pascal strings, taking into account the script
system and language for each of the strings. It takes both primary and secondary sorting
orders into consideration and returns a value that indicates whether the rst string is less
than, equal to, or greater than the second string.
FUNCTION

StringOrder

(aStr,

bStr:

aScript,
aLang,

Str255;

bScript:
bLang:

ScriptCode;

LangCode):

aStr

One of the Pascal strings to be compared.

bStr

The other Pascal string to be compared.

aScript

The script code for the

bScript

The script code for the second string.

aLang

The language code for the

bLang

The language code for the second string.

Integer;

rst string.
rst string.

DESCRIPTION

StringOrder returns lifthe rst string is less than the second string, 0if the rst
string is equal to the second string, and 1ifthe rst string is greater than the second
string. The ordering of script and language codes, which is based on information in the
script-sorting resource, is considered in determining the relationship of the two strings.
Script code values and explicit language code values are listed in the chapter Script
ManagerQ implicit language codes are listed in Table 5-13 on page 5-55 of this chapter.

Text Utilities Reference

5-57

CHAPTER

5

Text Utilities

Most applications specify the language code script CurLang for both the aLang and
bLang values.
StringOrder

rstcalls ScriptOrder; if the result of ScriptOrder is not 0 (that is, if

the strings use different scripts), StringOrder returns the same result.

StringOrder next calls LanguageOrder; if the result of LanguageOrder is not 0

(that is, if the strings use different languages), StringOrder returns the same result.
At this point, StringOrder has two strings that are in the same script and language, so
it compares them by using the sorting rules for that script and language, applying both
the primary and secondary sorting orders. If that script is not installed and enabled (as
described in the chapter CScript ManagerOin this book), it uses the sorting rules speci ed
by the system script or the font script, depending on the state of the international
resources selection Bag. See the section CObtaining Resource Information,Obeginning on
page 5-4.
The StringOrder function is primarily used to insert Pascal strings in a sorted list; for
sorting, rather than using this function, it may be faster to sort rst by script and
language by using the ScriptOrder and LanguageOrder functions, and then to call
the

CompareSt ring

language group.

function, described on page 5-62, to sort strings within a script or

SPECIAL CONSIDERATIONS

StringOrder may move memory; your application should not call this function at
interrupt time.

TextOrder
The Text Order function compares two text strings, taking into account the script and
language for each of the strings. It takes both primary and secondary sorting orders into
consideration and returns a value that indicates whether the rst string is less than, equal
to, or greater than the second string.
FUNCTION

TextOrder

(aPtr,

bPtr:

aScript,
aLang,

5-58

Ptr;

aLen,

bScript:
bLang:

bLen:

Integer;

ScriptCode;

LangCode):

Integer;

aPtr

A pointer to the

rst character of the

bPtr

A pointer to the

rst character of the second text string.

aLen

The number of bytes in the

bLen

The number of bytes in the second text string.

aScript

The script code for the

bScript

The script code for the second text string.

aLang

The language code for the

Text Utilities Reference

rst text string.

rst text string.

rst text string.
rst text string.

CHAPTER

5

Text Utilities

bLang

The language code for the second text string.

DESCRIPTION

TextOrder returns lifthe rst string is less than the second string, 0ifthe rst string is
equal to the second string, and 1ifthe rst string is greater than the second string. The
ordering of script and language codes, which is based on information in the script-sorting
resource, is considered in determining the relationship of the two strings.
Script code values and explicit language code values are listed in the chapter Script
ManagerQ implicit language codes are listed in Table 5-13 on page 5-55 of this chapter.
Most applications specify the language code scriptCurLang for both the aLang and
bLang values.
TextOrder

rstcalls ScriptOrder; if the result of ScriptOrder is not 0 (that is, if the

strings use different scripts), TextOrder returns the same result.

TextOrder next calls LanguageOrder; if the result of LanguageOrder is not 0 (that is,

if the strings use different languages),

Text Order

returns the same result.

At this point, Text Order has two strings that are in the same script and language, so it
compares them by using the sorting rules for that script and language, applying both the
primary and secondary sorting orders. If that script is not installed and enabled (as
described in the chapter CScript ManagerOin this book), it uses the sorting rules speci ed
by the system script or the font script, depending on the state of the international
resources selection Sag. See the section CObtaining Resource Information,Obeginning on
page 5-4.
The Text Order function is primarily used to insert text strings in a sorted list; for
sorting, rather than using this function, it may be faster to sort rst by script and
language by using the ScriptOrder and LanguageOrder functions, and then to call
the CompareText function, described on page 5-63, to sort strings within a script or

language group.

SPECIAL CONSIDERATIONS

TextOrder may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the Text Order
Trap macro

Selector

_Pack6é

$0022

function are

Determining Sorting Order for Strings in the Same Language
This section describes text routines that you can use to determine the sorting order of two
strings.

Text Utilities Reference

5-59

CHAPTER

5

Text Utilities

Some of the routines operate on Pascal strings and others on text strings. Pascal strings
are stored using standard Pascal string representation, which precedes the text characters
with a length byte; these strings are limited to 255 bytes of data. Text strings do not use a
length byte and can be up to 32 KB in length. Pascal strings are passed directly as
parameters, while text strings are speci ed by an address value and an integer length
value.
m The RelString function compares two Pascal strings using the string comparison
rules of the Macintosh le system. This function does not make use of any script or
language information, assuming the use of a Roman script system.
mw The CompareString function compares two Pascal strings, making use of the string
comparison information from a speci ed resource.
m The CompareText function compares two text strings for equality, making use of the
string comparison information from a speci ed resource.

RelString
The RelString function compares two Pascal strings using the string comparison rules
of the Macintosh le system and returns a value that indicates the sorting order of the
rst string relative to the second string. This function does not make use of any script or
language information; it assumes the original Macintosh character set only. Rel String
uses the sorting rules that are described in Table 5-2 on page 5-17.
FUNCTION

RelString

(aStr,

bStr:

caseSens,

Str255;

diacSens:

Boolean):

Integer;

aStr

One of the Pascal strings to be compared.

bstr

The other Pascal string to be compared.

caseSens

A fag that indicates how to handle case-sensitive information during the
comparison. If the value of caseSens is TRUE, uppercase characters are
distinguished from the corresponding lowercase characters. If it is FALSE,
case information is ignored.

diacSens

A fag that indicates how to handle information about diacritical marks
during the string comparison. If the value of diacSens is TRUE,
characters with diacritical marks are distinguished from the
corresponding characters without diacritical marks during the
comparison. If it is FALSE, diacritical marks are ignored.

DESCRIPTION
RelStringreturns lifthe rst string is less than the second string, 0 if the two strings
are equal, and 1ifthe rst string is greater than the second string. It compares the two
strings in the same manner as does the Equal String function, by simply looking at the
ASCII values of their characters. However, Rel String provides more information

5-60

Text Utilities Reference

CHAPTER

5

Text Utilities

about the two stringsN it indicates their relationship to each other, rather than
determining if they are exactly equal.
If the value of the diacSens parameter is FALSE,

Rel String

ignores diacritical marks

and strips them as shown in the appendix Onternational ResourcesOin this book.

If the value of the caseSens parameter is FALSE, the comparison is not case-sensitive;

Rel String performs a conversion from lowercase to uppercase characters.

SPECIAL CONSIDERATIONS

The Rel String
script systems.

ASSEMBLY-LANGUAGE

function is not localizable and does not work properly with non-Roman

INFORMATION

The trap macro and routine selector for the Rel
St ring function are
Trap macro

Selector

_RelString

$A050

The trap macro for the Rel String function can take optional arguments, each of which
changes the default setting used by the macro when it is called without arguments. Each
of these arguments corresponds to the Boolean parameters that are used with the Pascal
function call. The various permutations of this trap macro are shown below; you must
type each exactly as it is shown. The syntax shown here applies to the MPW Assembler; if
you are using another development system, be sure to consult its documentation for the
proper syntax.
Macro permutation
_RelString

Value of
diacSen

Value of
caseSen

s

s

FALSE

FALSE

_RelString

,MARKS

TRUE

FALSE

_RelString

,CASE

FALSE

TRUE

_RelString

,MARKS,CASE

TRUE

TRUE

The registers on entry and exit for this routine are
Registers on entry

AO

pointer to

rst character of the

rst string

Al

pointer to

rst character of the second string

DO

high-order word: number of bytes in the rst string
low-order word: number of bytes in the second string

Registers on exit

DO

long word result: lif rst string is less than second,
Oif equal, 1if rst string is greater than second

Text Utilities Reference

5-61

CHAPTER

5

Text Utilities

CompareString
The CompareSt ring function compares two Pascal strings, making use of the string
comparison information from a resource that you specify as a parameter. It takes both
primary and secondary sorting orders into consideration and returns a value that
indicates the sorting order of the rst string relative to the second string.
FUNCTION

CompareString(aStr,

bStr:

itl2Handle:

Str255;
Handle):

aStr

One of the Pascal strings to be compared.

bstr

The other Pascal string to be compared.

it1l2Handle

Integer;

The handle to the string-manipulation resource that contains string
comparison information.

DESCRIPTION

CompareString returns

1lifthe

rst string is less than the second string, 0 if the

rst string is equal to the second string, and 1if the
the second string.

rst string is greater than

The it12Handle parameter is used to specify a string-manipulation resource. If the
value of this parameter is NIL, CompareString makes use of the resource for the

current script. The string-manipulation resource includes routines and tables for
modifying string comparison and tables for case conversion and stripping of
diacritical marks.

Specifying a resource as a parameter is described in the section CObtaining Resource
Information,Obeginning on page 5-4.

SPECIAL CONSIDERATIONS

CompareString may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE INFORMATION
There is no trap macro for the

CompareSt ring

function. Instead, you must convert the

Pascal string into a text string by creating a pointer to its rst character and nding its
length, and then use the same macro as you do for the CompareText function, which is
described next.

5-62

Text Utilities Reference

CHAPTER

5

Text Utilities

Compare

Text
The CompareText function compares two text strings, making use of the string
comparison information from a resource that you specify as a parameter. It takes both
primary and secondary sorting orders into consideration and returns a value that
indicates the sorting order of the rst string relative to the second string.
FUNCTION

CompareText

(aPtr,

bPtr:

itl2Handle:

Ptr;

aLen,

Handle):

bLen:

aPtr

A pointer to the

rst character of the

bPtr

A pointer to the

rst character of the second text string.

aLen

The number of bytes inthe

bLen

The number of bytes in the second text string.

itl2Handle

Integer;

Integer;

rst text string.

rst text string.

A handle to a string-manipulation ('it12') resource that contains string
comparison information.

DESCRIPTION

CompareText returns lifthe rst string is less than the second string, 0 if the
rst string is equal to the second string, and lif the rst string is greater than the
second string.
The it 12Handle parameter is used to specify a string-manipulation resource. If the
value of this parameter is NIL, CompareText makes use of the resource for the current
script. The string-manipulation resource includes routines and tables for modifying
string comparison and tables for case conversion and stripping of diacritical marks.
Specifying a resource as a parameter is described in the section CObtaining Resource
Information,Obeginning on page 5-4.

SPECIAL CONSIDERATIONS

CompareText may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the CompareText function are
Trap macro

Selector

_Pack6é

$001A

Text Utilities Reference

5-63

CHAPTER

5

Text Utilities

Modifying Characters and Diacritical Marks
This section provides details on text routines that you can use to modify the characters
in text:
m

The UpperSt ring

procedure converts any lowercase letters in a Pascal string to their

uppercase equivalents. UpperString uses the Macintosh

le system

string-manipulation rules, which means that it only works properly for Roman

characters with codes through $D8.

The following four routines use tables in the string-manipulation ('it12') resource to
perform their character-mapping operations. This allows you to customize their
operation for different countries.
m

The LowercaseText procedure converts any uppercase characters in a text string

into their lowercase equivalents, making use of the conversion rules for the speci
script system.

ed

m The UppercaseText procedure converts any lowercase characters in a text string into
their uppercase equivalents, making use of the conversion rules for the speci ed script
system.

m The StripDiacritics procedure strips diacritical characters from a text string,
making use of the conversion rules for the speci ed script system.
m

The UppercaseStripDiacritics

procedure strips diacritical marks and converts

lowercase characters into their uppercase equivalents in a text string, making use of
the conversion rules for the speci ed script system.

UpperString
The UpperString procedure converts any lowercase letters in a Pascal string to their

uppercase equivalents. This procedure converts characters using the Macintosh le
system rules, which means that only a subset of the Roman character set (character codes
with values through $D8) are converted. These rules are summarized in Table 5-2 on
page 5-17. Use this procedure to emulate the behavior of the Macintosh le system.
PROCEDURE

UpperString

(VAR

theString:

Str255;

diacSens:

Boolean) ;

theString

On input, this is the Pascal string to be converted. On output, this contains
the string resulting from the conversion.

diacSens

A fag that indicates whether the case conversion is to strip diacritical
marks. If the value of this parameter is FALSE, diacritical marks
are stripped.

DESCRIPTION

UpperString traverses the characters in theString and converts any lowercase

characters with character codes in the range $0 through $D8 into their uppercase
equivalents. If the diacSens fsag is TRUE, diacritical marks are considered in the

5-64

Text Utilities Reference

CHAPTER

5

Text Utilities

conversion; if it is FALSE, any diacritical marks are stripped. UpperString places the
converted characters in theString.

ASSEMBLY-LANGUAGE INFORMATION
The trap macro and routine selector for the UpperSt ring
Trap macro

Selector

_UprString

$A054

procedure are

The registers on entry and exit for this routine are
Registers on entry

AO

pointer to

rst character of string

DO

the length of the string (a word value)

Registers on exit

AO

pointer to

rst character of string

The trap macro for the UpperString procedure can take an optional argument, which

changes the default setting used by the macro when it is called without arguments. This
argument corresponds to the Boolean parameter diacSens that is used with the Pascal
function call. The permutations of this trap macro are shown below; you must type each
exactly as it is shown.
The syntax shown here applies to the MPW Assembler; if you are using another
development system, be sure to consult its documentation for the proper syntax.
Macro permutation

Value of
diacSens

_UprString
_UprString

Lowercase

TRUE
,MARKS

FALSE

Text

The LowercaseText procedure converts any uppercase characters in a text string into
their lowercase equivalents. The text string can be up to 32 KB in length.
PROCEDURE

LowercaseText

(textPtr:
script:

Ptr;

len:

Integer;

ScriptCode) ;

textPtr

A pointer to the text string to be converted.

len

The number of bytes in the text string.

script

The script code for the script system whose resources are used to
determine the results of converting characters.

Text Utilities Reference

5-65

CHAPTER

5

Text Utilities

DESCRIPTION

LowercaseText traverses the characters starting at the address speci ed by text Ptr
and continues for the number of characters speci ed in len. It converts any uppercase
characters in the text into lowercase.
The conversion uses tables in the string-manipulation ('it12') resource of the script
speci ed by the value of the script parameter. The possible values for script codes are
listed in the chapter Script ManagerOof this book. You can specify smSystemScript to
use the system script and smCurrent Script to use the script of the current font in the
current graphics port.
If LowercaseText cannot access the speci ed resource, it generates an error code and
does not modify the string. You need to call the ResError function to determine which,
if any, error occurred. ResError is described in the Resource Manager chapter of the
book Inside Macintosh: More Macintosh Toolbox.

SPECIAL CONSIDERATIONS

LowercaseText may move memory; your application should not call this procedure at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the LowercaseText procedure is
Trap macro
_LowerText

The registers on entry and exit for this routine are
Registers on entry

AO

pointer to

rst character of string

DO

length of string in bytes (word); must be less than 32 KB

Registers on exit

DO

result code

RESULT CODES

noErr
resNot Found

5-66

Text Utilities Reference

0
192

No error
Can@get correct '1t12' resource or resource is not in
current format

CHAPTER

5

Text Utilities

UppercaseText
The UppercaseText procedure converts any lowercase characters in a text string into
their uppercase equivalents. The text string can be up to 32 KB in length.
PROCEDURE

UppercaseText

(textPtr:
script:

Ptr;

len:

Integer;

ScriptCode) ;

textPtr

A pointer to the text string to be converted.

len

The number of bytes in the text string.

script

The script code of the script system whose case conversion rules are used
for determining uppercase character equivalents.

DESCRIPTION

UppercaseText traverses the characters starting at the address speci ed by text Ptr
and continues for the number of characters speci ed in len. It converts any lowercase
characters in the text into uppercase.
The conversion uses tables in the string-manipulation ('1t12') resource of the script
speci ed by the value of the script parameter. The possible values for script codes are
listed in the chapter Gcript ManagerOof this book. You can specify smSystemScript to
use the system script and smCurrent Script to use the script of the current font in the
current graphics port.
If UppercaseText cannot access the speci ed resource, it generates an error code and
does not modify the string. You need to call the ResError function to determine which,
if any, error occurred. ResError is described in the Resource Manager chapter of the
book Inside Macintosh: More Macintosh Toolbox.

SPECIAL CONSIDERATIONS

UppercaseText may move memory; your application should not call this procedure at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the UppercaseText procedure is
Trap macro
_UpperText

Text Utilities Reference

5-67

CHAPTER

5

Text Utilities

The registers on entry and exit for this routine are
Registers on entry

AO

pointer to

rst character of string

DO

length of string in bytes (word); must be less than 32 KB

Registers on exit

DO

result code

RESULT CODES
noErr
resNot Found

0
192

No error
Can@get correct '1t12' resource or resource is not in
current format

Strip Diacritics
The StripDiacritics procedure strips any diacritical marks from a text string. The
text string can be up to 32 KB in length.
PROCEDURE

StripDiacritics

(textPtr:
script:

Ptr;

len:

Integer;

ScriptCode) ;

textPtr

A pointer to the text string to be stripped.

len

The number of bytes in the text string.

script

The script code for the script system whose rules are used for determining
which character results from stripping a diacritical mark.

DESCRIPTION
StripDiacritics traverses the characters starting at the address speci ed by
text Ptr and continues for the number of characters speci ed in len. It strips any
diacritical marks from the text.
The conversion uses tables in the string-manipulation ('it12') resource of the script
speci ed by the value of the script parameter. The possible values for script codes are
listed in the chapter Script ManagerOof this book. You can specify smSystemScript to
use the system script and smCurrent Script to use the script of the current font in the
current graphics port.
If StripDiacritics cannot access the speci ed resource, it generates an error code and
does not modify the string. You need to call the ResError function to determine which,
if any, error occurred. ResError is described in the Resource Manager chapter of the
book Inside Macintosh: More Macintosh Toolbox.

5-68

Text Utilities Reference

CHAPTER

5

Text Utilities

SPECIAL CONSIDERATIONS

StripDiacritics may move memory;
at interrupt time.

your application should not call this procedure

ASSEMBLY-LANGUAGE INFORMATION
The trap macro for the

StripDiacritics procedure is

Trap macro

_StripText

The registers on entry and exit for this routine are
Registers on entry

AO

pointer to

rst character of string

DO

length of string in bytes (word); must be less than 32 KB

Registers on exit

DO

result code

RESULT CODES

noErr
resNot Found

0
192

No error
Can@ get correct 'it12' resource or resource is not in
current format

UppercaseStripDiacritics
The UppercaseStripDiacritics procedure converts any lowercase characters in a

text string into their uppercase equivalents and strips any diacritical marks from the text.
The text string can be up to 32 KB in length.
PROCEDURE

UppercaseStripDiacritics

(textPtr:
script:

Ptr;

len:

Integer;

ScriptCode) ;

textPtr

A pointer to the text string to be converted.

len

The number of bytes in the text string.

script

The script code of the script system whose resources are used to determine
the results of converting characters.

Text Utilities Reference

5-69

CHAPTER

5

Text Utilities

DESCRIPTION

UppercaseStripDiacritics

traverses the characters starting at the address speci

ed

by text Ptr and continues for the number of characters speci ed in len. It converts
lowercase characters in the text into their uppercase equivalents and also strips diacritical
marks from the text string. This procedure combines the effects of the UppercaseText

and StripDiacritics procedures.

The conversion uses tables in the string-manipulation ('it12') resource of the script
speci ed by the value of the script parameter. The possible values for script codes are
listed in the chapter Script ManagerOof this book. You can specify smSystemScript to
use the system script and smCurrent Script to use the script of the current font in the
current graphics port.
If UppercaseStripDiacritics

cannot access the speci

ed resource, it generates an

error code and does not modify the string. You need to call the ResError function to

determine which, if any, error occurred. ResError is described in the Resource Manager

chapter of the book Inside Macintosh: More Macintosh Toolbox.

SPECIAL CONSIDERATIONS

UppercaseStripDiacritics may move memory; your application should not call
this procedure at interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the UppercaseStripDiacritics

procedure is

Trap macro

_StripUpperText

The registers on entry and exit for this routine are
Registers on entry

AO

pointer to

rst character of string

DO

length of string in bytes (word); must be less than 32 KB

Registers on exit

DO

result code

RESULT CODES

noErr
resNot Found

5-70

Text Utilities Reference

0
192

No error
Can@get correct '1t12' resource or resource is not in
current format

CHAPTER

5

Text Utilities

Truncating Strings
This section describes two Text Utilities functions that you can use to truncate portions of
strings. Each of these function can truncate characters from different locations in a string,
and each makes use of the current script and font to perform its operation. The current
script is de ned on page 5-4. The current font is the font that is currently in use in the
current graphics port.
m The TruncString function ensures that a Pascal string
width, by truncating the string as necessary.
m The TruncText function ensures that a text string
by truncating the string as necessary.

ts into the speci

ts into the speci

ed pixel

ed pixel width,

TruncString
The TruncSt ring function ensures that a Pascal string ts into the speci ed pixel
width, by truncating the string as necessary. This function makes use of the current
script and font.
FUNCTION

TruncString

(width:

Integer;

truncWhere:

VAR

theString:

TruncCode):

Str255;

Integer;

width

The number of pixels in which the string must be displayed in the current
script and font.

theString

The Pascal string to be displayed. On output, contains a version of the
string that has been truncated (if necessary) to t in the number of pixels
speci ed by width.

truncWhere

A constant that indicates where the string should be truncated. You must
set this parameter to one of the constants truncEnd or truncMiddle.

DESCRIPTION

The TruncString function ensures that a Pascal string ts into the pixel width speci ed
by the width parameter by modifying the string, if necessary, through truncation.
TruncString uses the font script to determine how to perform truncation. If truncation
occurs, TruncString

inserts a truncation indicator, which is the

ellipsis (E ) in the Roman script system. You can specify which token to use for indicating
truncation as the tokenE11lipsis token type in the untoken table of a tokens
('1t14') resource.

The truncWhere parameter speci es where truncation is performed. If you supply the
truncEnd value, characters are truncated off the end of the string. If you supply the
truncMiddle value, characters are truncated from the middle of the string; this is useful

when displaying pathnames.

Text Utilities Reference

5-71

CHAPTER

5

Text Utilities

The TruncString function returns a result code that indicates whether the string
was truncated.

SPECIAL CONSIDERATIONS

TruncString may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the
Trap macro

Selector

_Seriptutil

$8208 FFEO

Truncated
NotTruncated
TruncErr

1
0
1

resNot Found

192

TruncSt ring function are

RESULT CODES

Truncation performed
No truncation necessary
Truncation necessary, but cannot be performed within the
speci ed width
Cannot get the correct 'it14' resource or resource is not
in current format

SEE ALSO

To determine the width of a string in the current font and script, use the QuickDraw

StringWidth function, which is described in the chapter GQQuickDraw TextO

in this book.

TruncText

The TruncText function ensures that a text string ts into the speci ed pixel width, by
truncating the string as necessary. This function makes use of the current script and font.
The text string can be up to 32 KB long.
You can use the TruncText function to ensure that a string de ned by a pointer and a
byte length ts into the speci ed pixel width, by truncating the string in a manner
dependent on the font script.
FUNCTION

TruncText

(width:
VAR

Integer;

length:

truncWhere:

5-72

Text Utilities Reference

textPtr:

Ptr;

Integer;
TruncCode):

Integer;

CHAPTER

5

Text Utilities

width

The number of pixels in which the text string must be displayed in the
current script and font.

textPtr

A pointer to the text string to be truncated.

length

On input, the number of bytes in the text string to be truncated. On
output, this value is updated to refsect the length of the (possibly)
truncated text.

truncWhere

A constant that indicates where the text string should be truncated.
You must set this parameter to one of the constants truncEnd
or truncMiddle.

DESCRIPTION

The TruncText function ensures that a text string ts into the pixel width speci ed by
the width parameter by modifying the string, if necessary, through truncation.
TruncText uses the font script to determine how to perform truncation. If truncation
occurs, TruncText inserts a truncation indicator which is the ellipsis (E ) in the Roman

script system. You can specify which token to use for indicating truncation as the
tokenE1llipsis token type in the untoken table of a tokens resource.

The truncWhere parameter speci es where truncation is performed. If you supply the
truncEnd value, characters are truncated off the end of the string. If you supply the
truncMiddle value, characters are truncated from the middle of the string; this is useful

when displaying pathnames.

The TruncText function returns a result code that indicates whether the string
was truncated.

SPECIAL CONSIDERATIONS

TruncText may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the TruncText function are
Trap macro

Selector

_Scriptutil

$820C FFDE

Text Utilities Reference

5-73

CHAPTER

5

Text Utilities

RESULT CODES

Truncated
NotTruncated
TruncErr

1
0
1

resNot Found

192

Truncation performed
No truncation necessary
Truncation necessary, but cannot be performed within the
speci ed width
Cannot get the correct 'it14' resource or resource is not
in current format

SEE ALSO

To determine the width of a string in the current font and script, use the QuickDraw
StringWidth function, which is described in the chapter CQuickDraw TextOin
this book.

Searching for and Replacing Strings
This section describes two Text Utilities routines that you can use to search for and
replace strings in larger strings:
m The ReplaceText function searches a text string and replaces all instances of a target
string with another string. ReplaceText uses the string-manipulation resource tables
and works properly for all script systems, including 2-byte script systems.
m The Munger function searches text for a speci ed target string and replaces it with
another string. This function operates on a byte-by-byte basis; thus, it does not always
work for 2-byte script systems.

ReplaceText
The ReplaceText function searches text, replacing all instances of a string in that text
with another string. ReplaceText

searches on a character-by-character basis (as

opposed to byte-by-byte), so it works properly for all script systems.
FUNCTION

ReplaceText

(baseText,
key:

baseText

substitutionText:

Str15):

Handle;

Integer;

Ahandle to the string in which ReplaceText is to substitute text.

substitutionText

A handle to the string that ReplaceText uses as substitute text.

key

A Pascal string of less than 16 bytes that ReplaceText searches for.

DESCRIPTION

ReplaceText searches the text speci ed by the baseText parameter for instances of
the string in the key parameter and replaces each instance with the text speci ed by the
substitutionText parameter. ReplaceText searches on a character-by-character

5-74

Text Utilities Reference

CHAPTER

5

Text Utilities

basis. It recognizes 2-byte characters in script systems that contain them and advances the
search appropriately after encountering a 2-byte character.
ReplaceText returns an integer value. If the returned value is positive, it indicates the
number of substitutions performed; if it is negative, it indicates an error. The constant

noErr is returned if there was no error and no substitutions were performed.

SPECIAL CONSIDERATIONS

ReplaceText may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the ReplaceText function are
Trap macro

Selector

_Seriptutil

$820C FFDC

RESULT CODES

nilHandleErr

109

GetHandleSize
fails on baseText or

memFullErr
memWZErr

108
111

SetHandleSize
fails on baseText
GetHandleSize
fails on baseText or

substitutionText

substitutionText

Munger
The Munger function searches text for a speci
another string.
FUNCTION

Munger

(h:

Handle;

lenl:

LongInt;

ed string pattern and replaces it with

offset:
ptr2:

LongInt;
Ptr;

len2:

ptril:

Ptr;

LongInt):

LongInt;

h

A handle to the text string that is being manipulated.

offset

The byte offset in the destination string at which Munger begins
its operation.

ptrl

A pointer to the

lenl

The number of bytes in the string for which Munger is searching.

ptr2

A pointer to the

len2

The number of bytes in the substitution string.

Text Utilities Reference

rst character in the string for which Munger is searching.
rst character in the substitution string.

5-75

CHAPTER

5

Text Utilities

DESCRIPTION

Munger manipulates bytes in a string to which you specify a handle in the h parameter.
The manipulation begins at a byte offset, speci ed in offset, in the string. Munger
searches for the string speci ed by ptr1 and len1; when it nds an instance of that
string, it replaces it with the substitution string, which is speci ed by ptr2 and len2.
IMPORTANT

Munger operates on a byte-by-byte basis, which can produce
inappropriate results for 2-byte script systems. The ReplaceText
function works properly for all languages. You are encouraged to use
ReplaceText instead of Munger whenever possible. a
Munger takes special action if either of the speci
the length values is 0.

ed pointer values is NIL or if either of

m If ptrl1 is NIL, Munger replaces characters without searching. It replaces len1
characters starting at the of fset location with the substitution string.
mw If ptriisNILand leni is negative, Munger replaces all of the characters from the
offset location to the end of the string with the substitution string.
m

m

If leni is 0, Munger inserts the substitution string without replacing anything.

Munger inserts the string at the of
past where the insertion occurred.

fset location and returns the offset of the

rst byte

If ptr2 is NIL, Munger searches but does not replace. In this case, Munger returns the

offset at which the string was found.

mw If len2 is O and ptr2 is not NIL, Munger searches and deletes. In this case, Munger
returns the offset at which it deleted.

m If the portion of the string from the of fset location to its end matches the beginning
of the string that Munger is searching for, Munger replaces that portion with the
substitution string.
Munger returns a negative value when it cannot

nd the designated string.

WARNING

Be careful not to specify an offset with a value that is greater than the
length of the destination string. Unpredictable results may occur. &
SPECIAL CONSIDERATIONS

Munger may move memory; your application should not call this function at
interrupt time.
The destination string must be in a relocatable block that was allocated by the
Memory Manager.

5-76

Text Utilities Reference

CHAPTER

5

Text Utilities

SEE ALSO

Munger calls the Get HandleSize and SetHandleSize routines to access or modify
the length of the string it is manipulating. These routines are described in the book Inside
Macintosh: Memory Manager.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro for the Munger function is
Trap macro
_Munger

Working With Word, Script, and Line Boundaries
This section describes the text routines that you can use to edit and display formatted
text. These functions all take into account script and language considerations, making use
of tables in the string-manipulation ('it12') resource in their computations.
m The FindWordBreaks procedure determines the beginning and ending boundaries of
a word in a text string.
m The StyledLineBreak function determines the proper location at which to break a
line of text that may contain multiple script runs, breaking it on a word boundary
if possible.
m The FindScriptRun function nds the next boundary between main text and a
speci ed subscript within a script run.

FindWord Breaks
The FindWordBreaks procedure determines the beginning and ending boundaries of a
word in a text string.
PROCEDURE

FindWordBreaks(textPtr:

textLength

offset

textLength:

offset:

Integer;

nbreaks:

BreakTablePtr;

VAR

textPtr

Ptr;

offsets:

leadingEdge:

OffsetTable;

Integer;

Boolean;

script:

ScriptCode) ;

A pointer to the text string to be examined.
The number of bytes in the text string.
A byte offset into the text. This parameter plus the leadingEdge
parameter determine the position of the character at which to start
the search.

Text Utilities Reference

5-77

CHAPTER

5

Text Utilities

leadingEdge

A Sag that speci

es which character should be used to start the search. If

leadingEdge is TRUE, the search starts with the character speci ed in the
offset parameter; if it is FALSE, the search starts with the character

previous to the offset.
nbreaks

A pointer to a word-break table of type NBreakTable or BreakTable.

If the value of this pointer is 0, the default word-break table of the script

system speci ed by the script parameter is used. If the value of
this pointer is 1, the default line-break table of the speci ed script
system is used.
offsets

On output, the values in this table indicate the boundaries of the word
that has been found.

script

The script code for the script system whose tables are used to determine
where word boundaries occur.

DESCRIPTION

FindWordBreaks searches for a word in a text string. The text Ptr and textLength
parameters specify the text string that you want searched. The of fset parameter and
leadingEdge parameter together indicate where the search begins.
If leadingEdge is TRUE, the search starts at the character at the offset. If

leadingEdge is FALSE, the search starts at the character preceding the offset
position.
FindWordBreaks searches backward through the text string for one of the word
boundaries and forward through the text string for its other boundary. It uses the
de nitions in the table speci ed by nbreaks to determine what constitutes the
boundaries of a word. Each script system@ word-break table is part of its
string-manipulation ('it12') resource. The format of the NBreakTable record is
described in the appendix Gnternational ResourcesOin this book.
FindWordBreaks returns its results in an Of

fSet Table

record, the format of which is

described in the section Lhe Offset Table RecordOon page 5-44. FindWordBreaks uses
only the rst element of this three-element table. Each element is a pair of integers:
of fFirst and of fSecond.
FindWordBreaks places the offset from the beginning of the text string to just before the
leading edge of the character of the word that it ndsintheoffFirst
eld.
FindWordBreaks places the offset from the beginning of the text string to just after the
trailing edge of the last character of the word thatit ndsin the of £Second eld. For
example, if the text (This is itOis passed with of fset set to 0 and leadingEdge set to
TRUE, then FindWordBreaks returns the offset pair (0,4).
If leadingEdge is TRUE and the value of offset is 0, then FindWordBreaks returns
the offset pair (0,0). If leadingEdge is FALSE and the value of of fset equals the value
of textLength, then FindWordBreaks returns the offset pair with values
(textLength, textLength).

5-78

Text Utilities Reference

CHAPTER

5

Text Utilities

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the FindWordBreaks procedure are
Trap macro

Selector

_Scriptutil

$C012 001A

StyledLineBreak
The StyledLineBreak function returns the proper location to break a line of text. It
breaks the line on a word boundary if possible and allows for multiscript runs and style
runs on a single line.
FUNCTION

StyledLineBreak(textPtr:
textStart,

Ptr;

textEnd,

VAR

textWidth:

VAR

textOffset:

textLen:
flags:

LongInt;

LongInt;

Fixed;

LongInt):

StyledLineBreakCode;

textPtr

A pointer to the beginning of a script run on the current line to be broken.

textLen

The number of bytes in the script run on the current line to be broken.

textStart

Abyte offset to the beginning of a style run within the script run.

textEnd

A byte offset to the end of the style run within the script run.

flags

Reserved for future expansion; must be 0.

textWidth

The maximum length of the displayed line in pixels. StyledLineBreak

textOffset

decrements this value for its own use. Your responsibility is to set it before
your rst call to StyledLineBreak for a line.
Must be nonzero on your rst call to StyledLineBreak for a line, and
zero for subsequent calls to StyledLineBreak for that line. This value
allows StyledLineBreak to differentiate between the

rst and

subsequent calls, which is important when a long word is found (as
described below).
On output, textOffset is the count of bytes from text Ptr to the
location in the text string where the line break is to occur.

DESCRIPTION

Use the StyledLineBreak function when you are laying out lines in an environment

that may include text from multiple scripts. To use this function, you need to

understand how QuickDraw draws text, which is described in the chapter CQuickDraw
TextOin this book.

Text Utilities Reference

5-79

CHAPTER

5

Text Utilities

You can only use the StyledLineBreak function when you have organized your text in
script runs and style runs within each script run. This type of text organization is used by
most text-processing applications that allow for multiscript text. Use this function when
you are displaying text in a screen area to determine the best place to break each
displayed line. For an overview of how to use this function, read the section Finding
Line BreaksObeginning on page 5-24.
What you do is iterate through your text, a script run at a time starting from the rst
character past the end of the previous line. Use StyledLineBreak to check each style
run in the script run (in memory order) until the function determines that it has arrived
at a line break. As you loop through each style run, before calling Sty ledLineBreak,
you must set the text values in the graphics port record that are used by QuickDraw to
measure the text. These include the font, font size, and font style of the style run. An
example of a loop that uses this function is found in Listing 5-4 on page 5-27.
When used with unformatted text, text Start can be 0, and text End is identical to
textLen. With styled text, the interval between textStart and textEnd speci es

a style run. The interval between text Ptr and textLen speci esa script run. Note
that the style runs in StyledLineBreak must be traversed in memory order, not in
display order.

If the current style run is included in a contiguous sequence of other style runs of the
same script, then text Ptr should point to the start of the rst style run of the same
script on the line, and text Len should include the last style run of the same script on the
line. This is because word boundaries can extend across style runs, but not across script
runs.
StyledLineBreak automatically decrements the text Width variable by the width of
the style run for use on the next call. You need to set the value of textWidth before
calling it to process a line.
The textOffset parameter must be nonzero for the rst call ona line and zero for each
call to the function on the line. This allows StyledLineBreak to act differently when a
long word is encountered: if the word is in the rst style run on the line,
StyledLineBreak breaks the line on a character boundary within the word; if the word
is in a subsequent style run on the line, StyledLineBreak breaks the line before the
start of the word.
When StyledLineBreak

nds a line break, it sets the value of textOffset to the

count of bytes that can be displayed starting at text Ptr.
IMPORTANT

When StyledLineBreak is called for the second or subsequent style
runs within a script run, the textOffset value at exit may be less than
the text Start parameter (that is, it may specify a line break before the
current style run). «A
Although the offsets are in long integer values and the widths are in xed values for
future extensions, in the current version the long integer values are restricted to the
integer range, and only the integer portion of the widths is used.

5-80

Text Utilities Reference

CHAPTER

5

Text Utilities

StyledLineBreak always chooses a line break for the last style run on the line in
memory order as if all whitespace in that style run would be stripped. The
VisibleLength function, which is a QuickDraw function used to eliminate trailing

spaces from a style run before drawing it, can be called for the style run that is at the
display end of a line. This leads to a potential confsict when both functions are used with
mixed-directional text: if the end of a line in memory order actually occurs in the middle
of the displayed line, StyledLineBreak assumes that the whitespace is stripped from
that run, but VisibleLength does not strip the characters. The VisibleLength

function is described in the chapter GQQuickDraw TextOin this book.

The StyledLineBreak result (de ned by the StyledLineBreakCode data type)
indicates whether the function broke on a word boundary or a character boundary, or if
the width extended beyond the edge of the text.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the StyledLineBreak function are
Trap macro

Selector

_Scriptutil

$821C FFFE

RESULT CODES
BreakOverflow

2

BreakChar
BreakWord

1
0

No line break is yet necessary, since the current style run
still ts on the line
Line breaks on character boundary
Line breaks on word boundary

SEE ALSO
For details on the VisibleLength, TextWidth, and PortionText functions, see the

chapter GQuickDraw TextOin this book.

FindScriptRun
The FindScriptRun function

nds the next block of subscript text within a script run.

FUNCTION

(textPtr:

Ptr;

textLen:

LongInt;

FindScriptRun

VAR

lenUsed:

LongInt):

ScriptRunStatus;

textPtr

A pointer to the text string to be analyzed.

textLen

The number of bytes in the text string.

lenUsed

On output, contains the length, in bytes, of the script run that begins with

the rst character in the string; this length is always greater than or equal
to 1, unless the string passed in is of length 0.

Text Utilities Reference

5-81

CHAPTER

5

Text Utilities

DESCRIPTION

The FindScriptRun function is used to identify blocks of subscript text in a string.
Some script systems include subscripts, which are character sets that are subsidiary to the
main character set. One useful subscript is the set of all character codes that have the
same meaning in Roman as they do in a non-Roman script. For other scripts such as
Japanese, there are additional useful subscripts. For example, a Japanese script system
might include some Hiragana characters that are useful for input methods.
FindScriptRun computes the length of the current run of subscript text in the text
string speci ed by text Ptr and textLen. It assigns the length, in bytes, to the
lenUsed parameter and returns a status code. You can advance the text pointer by the
value of lenUsed to make subsequent calls to this function. You can use this function to
identify runs of subscript characters so that you can treat them separately.
The function result identi

es the run as either native text, Roman, or one of the de

ned

subscripts of the script system and returns a record of type ScriptRunStatus. This
record is described in the section (Lhe Script Run Status RecordOon page 5-46.

Word processors and other applications can call FindScriptRun to separate style runs
of native text from non-native text. You can use this capability to extract those characters
and apply a different font to them. Figure 5-11 on page 5-28 provides an example of using
the FindScriptRun routine.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the FindScriptRun function are
Trap macro

Selector

_Scriptutil

$820C 0026

Converting Date and Time Strings Into Numeric Representations
This section describes the Text Utilities routines that you can use to convert date and time
strings into numeric representations:
m

The InitDateCache function initializes the date cache record, which is used by the
StringToDate and StringToTime functions.

m The StringToDate function parses text for a date speci

cation and

Ils in numeric

mw The StringToTime function parses text for a time speci cation and

lls in numeric

date information in a LongDateRec record.

time information in a LongDateRec record.

5-82

Text Utilities Reference

CHAPTER

5

Text Utilities

InitDateCache
The InitDateCache function initializes the date cache record, which is used to store

data for use by the StringToDate and StringToTime functions.
FUNCTION

InitDateCache

theCache

(theCache:

DateCachePtr):

OSErr;

A pointer toa record of type DateCacheRecord. This parameter can be a
local variable, a pointer, or a locked handle.

DESCRIPTION

You must call InitDateCache to initialize the date cache record before using either the
StringToDate or StringToTime functions. You must pass a pointer to a date cache
record. You have to declare the record as a variable or allocate it in the heap.
If you are writing an application that allows the use of global variables, you can make
your date cache record a global variable and initialize it once, when you perform other
global initialization.

SPECIAL CONSIDERATIONS

InitDateCache may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE INFORMATION
The trap macro and routine selector for the InitDateCache function are
Trap macro

Selector

_Scriptutil

$8204 FFF8

RESULT CODES
noErr

fatalDateTime

0

32768

No error

A miscellaneous fatal error occurred, usually a failure

in a call to get a resource

SEE ALSO

InitDateCache calls the GetResource and LoadResource routines and it can also
return the error codes they produce. These routines and their return values are described
in the book Inside Macintosh: Operating System Utilities.

Text Utilities Reference

5-83

CHAPTER

5

Text Utilities

StringToDate
The StringToDate function parses a string for a date and converts the date information
into values in a date-time record. It expects a date speci cation, in a format de ned by
the current script, at the beginning of the string. It returns a status value that indicates the
con dence level for the success of the conversion.
FUNCTION

StringToDate(textPtr:
theCache:

VAR

Ptr;

textLen:

DateCachePtr;

dateTime:

VAR

LongDateRec):

LongInt;
lengthUsed:

LongInt;

StringToDateStatus;

textPtr

A pointer to the text string to be parsed.

textLen

The number of bytes in the text string.

theCache

A pointer to the date cache record initialized by the InitDateCache
function with data that is used during the conversion process.

lengthUsed

dateTime

On output, contains the number of bytes of the string that were parsed for
the date.
On output, this LongDateRec record contains the year, month, day, and
day of the week parsed for the date.

DESCRIPTION

StringToDate parses the text string untilithas nished nding all date information or
until it has examined the number of bytes speci ed by textLen. It returns a status value
that indicates the con dence level for the success of the conversion. For an overview of
how this function operates, see the section CConverting Formatted Date and Time Strings
Into Internal Numeric RepresentationsObeginning on page 5-31.
Note that StringToDate
Ils in only the year, month, day, and day of the week;
StringToTime
lls in the hour, minute, and second. You can use these two routines

sequentially to

ll in all of the values in a LongDateRec record.

StringToDate assigns to its 1engthUsed parameter the number of bytes that it uses to
parse the date; use this value to compute the starting location of the text that you can
pass to StringToTime (or you can use them in reverse order).
When one of the date components is missing, such as the year, the current date value is
used as a default. If the value of the input year is less than 100, StringToDate
determines the year as described on page 5-32.
StringToDate returns a value of type StringToDateStatus, which is a set of bit
values that indicate con

dence levels, with higher numbers indicating low con

dence in

how closely the input string matched what the routine expected. For example, specifying
a date with nonstandard separators may work, but it returns a message indicating that
the separator was not standard. The possible values of this type are described in Table 5-5
on page 5-33.

5-84

Text Utilities Reference

CHAPTER

5

Text Utilities

SPECIAL CONSIDERATIONS

StringToDate may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the StringToDate function are
Trap macro

Selector

_ScriptUtil

$8214 FFF6

String ToTime
The StringToTime function parses a string for a time speci cation and converts the
date information into values in a date-time record. At the beginning of the string, it
expects a time speci cation in a format de ned by the current script. It returns a status
value that indicates the con dence level for the success of the conversion.
FUNCTION

StringToTime(textPtr:
theCache:

VAR

Ptr;

textLen:

DateCachePtr;

dateTime:

VAR

LongDateRec):

LongInt;
lengthUsed:

LongInt;

StringToDateStatus;

textPtr

A pointer to the text string to be parsed.

textLen

The number of bytes in the text string.

theCache

A pointer to the date cache record initialized by the InitDateCache
function with data that is used during the conversion process.

lengthUsed

dateTime

On output, contains the number of bytes of the string that were parsed for
the time.
On output, this LongDateRec record contains the hour, minute, and

second values that were parsed for the time.

DESCRIPTION

StringToTime parses the string until it has

until it has examined the number of bytes speci
that indicates the con

nished

nding all time information or

ed by textLen. It returns a status value

dence level for the success of the conversion.

Note that StringToTime

llsin only the hour, minute, and second; StringToDate

lls

in the year, month, day, and day of the week. You can use these two routines sequentially
to

llin all of the values in a LongDateRec record.

StringToTime assigns to its lengthUsed parameter the number of bytes that it used to
parse the date.

Text Utilities Reference

5-85

CHAPTER

5

Text Utilities

StringToTime returns the same status value indicator type as does StringToDate:a
set of bit values that indicate con dence levels, with higher numbers indicating low
con dence in how closely the input string matched what the routine expected. The
possible values of this type are described in Table 5-5 on page 5-33.

SPECIAL CONSIDERATIONS

StringToTime may move memory; your application should not call this function at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the StringToTime function are
Trap macro

Selector

_Seriptutil

$8214 FFF4

Converting Numeric Representations Into Date and Time Strings
This section describes the routines that you can use to convert numeric representations of
date and time values into formatted strings. The numeric representation used in these
routines is the standard date-time representation: a 32-bit integer value that is returned
by the GetDateTime routine. This is a long integer value that represents the number of
seconds between midnight, January 1, 1904, and the time at which

Get DateTime was

called, as described in the book Inside Macintosh: Operating System Utilities.

m The DateString procedure converts a date in the standard date-time representation
into a string, making use of the date formatting information from a speci ed resource.
If you specify NIL as the value of the resource handle parameter, DateSt ring uses
information from the current script.
mw The TimeString procedure converts a time in the standard date-time representation
into a string, making use of the time formatting information from a speci ed resource.
If you specify NIL as the value of the resource handle parameter, TimeSt ring uses
information from the current script.

DateString
The DateSt ring procedure converts a date in the standard date-time representation
into a Pascal string, making use of the date formatting information in the
speci ed resource.
PROCEDURE

DateString

(dateTime:

VAR

dateTime

5-86

result:

LongInt;

Str255;

longFlag:

Boolean;

intlParam:

— The date-time value in the representation returned by the
Get DateTime procedure.

Text Utilities Reference

Handle

);

CHAPTER

5

Text Utilities

longFlag

A

fag that indicates the desired format for the date string. This is one

of the three values de ned as the DateForm type.

result

On output, contains the string representation of the date in the format
indicated by the longFlag parameter.

intlParam

A handle to a numeric-format or a long-date-format resource that speci es
date formatting information for use in the conversion. The numeric-format
('it10') resource speci es the short date formats and the
long-date-format ('1t11"') resource speci es the long date formats.

DESCRIPTION

DateString converts the long integer representation of date and time in the dateTime
parameter into a Pascal string representation of the date. You can call the Get DateTime
function to get the date-time value. Get DateTime is described in the book Inside
Macintosh: Operating System Utilities.
The string produced by DateString is in one of three standard date formats used on the
Macintosh, depending on which of the three DateForm values that you specify for the
longFlag parameter: shortDate, abbrevDate, or longDate. The information in the

supplied resource de nes how month and day names are written and provides for
calendars with more than 7 days and more than 12 months. For the Roman script
system@ resource, the date January 31, 1991, produces the following three strings:
Dateform value

Date string produced

shortDate

1/31/92

abbrevDate

Fri, Jan 31, 1992

longDate

Friday, January 31, 1992

DateSt ring formats its data according to the information in the speci ed
numeric-format resource (for short date formats) or long-date-format resource (for long
date formats). If you specify shortDate, the int 1 Param value should be the handle to
a numeric-format resource; if you specify abbrevDate or longDate, it should be the
handle to a long-date-format resource. If the int 1 Param value is NIL, DateString uses

the appropriate resource from the current script.

SPECIAL CONSIDERATIONS

DateString may move memory; your application should not call this procedure at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the
Trap macro

Selector

_Packé

$000E

Text Utilities Reference

DateSt ring procedure are

5-87

CHAPTER

5

Text Utilities

TimeString
The TimeSt ring procedure converts a time in the standard date-time representation
into a string, making use of the time formatting information in the speci ed resource.
PROCEDURE

TimeString

(dateTime:

VAR

dateTime

result:

LongInt;

Str255;

wantSeconds:

Boolean;

intlParam:

Handle) ;

— The date-time value in the representation returned by the Operating
System procedure Get DateTime.

wantSeconds

A Sag that indicates whether the seconds are to be included in the
resulting string.

result

On output, contains the string representation of the time.

intlParam

A handle to a numeric-format ('it10') resource that speci

formatting information for use in the conversion.

es time

DESCRIPTION
TimeString converts the long integer representation of date and time in the dateTime
parameter into a Pascal string representation of the time. You can call the GetDateTime
function to get the date-time value. Get DateTime is described in the book Inside
Macintosh: Operating System Utilities.
TimeString produces a string that includes the seconds if you set the want Seconds
parameter to TRUE.

TimeString formats its data according to the information in the numeric-format
resource speci ed in the int 1Param parameter. If this value is NIL, TimeString
uses the numeric-format resource from the current script. The numeric-format resource
speci es whether or not to use leading zeros for the time values, whether to use a
12- or 24-hour time cycle, and how to specify morning or evening if a 12-hour time

cycle is used.

SPECIAL CONSIDERATIONS

TimeString may move memory; your application should not call this procedure at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the

5-88

Trap macro

Selector

_Pack6

$0010

Text Utilities Reference

TimeSt ring procedure are

CHAPTER

5

Text Utilities

Converting Long Date and Time Values Into Strings
This section describes two procedures that use the LongDateTime data type in their
conversions. This is a 64-bit, signed representation of the number of seconds since Jan. 1,
1904, which allows coverage of a much longer span of time (plus or minus approximately
30,000 years) than the standard, 32-bit representation. LongDat eTime values are
described in the book Inside Macintosh: Operating System Utilities.
m

The LongDateString procedure converts a date in LongDateTime representation

m

The LongTimeString procedure converts a time in LongDateTime representation

into a string, making use of the date formatting information from a speci ed resource.
If you specify NIL as the value of the resource handle parameter, LongDateString
uses information from the current script.
into a string, making use of the date formatting information from a speci ed resource.
If you specify NIL as the value of the resource handle parameter, LongTimeSt ring
uses information from the current script.

LongDateString
The LongDateString procedure converts a date that is speci ed as a LongDateTime
value into a Pascal string, making use of the date formatting information in the
speci ed resource.
PROCEDURE

LongDateString(VAR

dateTime:

longFlag:

VAR

dateTime
longFlag

LongDateTime;

DateForm;

result:

Str255;

intlParam:

Handle) ;

A 64-bit, signed representation of the number of seconds since Jan. 1, 1904.
A

fag that indicates the desired format for the date string. This is one of

the three values de ned as the

Dat eForm

type.

result

On output, contains the string representation of the date in the format
indicated by the longFlag parameter.

intlParam

A handle to a numeric-format or long-date-format resource that speci es
date formatting information for use in the conversion. The numeric-format
('it10') resource speci es the short date formats and the
long-date-format ('1t11"') resource speci es the long date formats.

DESCRIPTION

LongDateString converts the LongDateTime value in the dateTime parameter into a

Pascal string representation of the date. You can use the LongSecondsToDate and

LongDateToSeconds procedures, which are described in the book Inside Macintosh:

Operating System Utilities, to convert between the LongDateRec (as produced by the
StringToDate function) and LongDateTime data types.

Text Utilities Reference

5-89

CHAPTER

5

Text Utilities

The string produced by LongDateSt
ring is in one of three standard date formats used
on the Macintosh, depending on which of the three DateForm values that you specify for
the longFlag parameter: shortDate, abbrevDate, or longDate. The information in

the supplied resource de nes how month and day names are written and provides for
calendars with more than 7 days and more than 12 months. For the U.S. resource, the
date January 31, 1991, produces the following three strings:
DateForm value

Date string produced

shortDate

1/31/92

abbrevDate

Fri, Jan 31, 1992

longDate

Friday, January 31, 1992

LongDateString formats its data according to the information in the speci ed
numeric-format resource (for short date formats) or long-date-format resource (for long
date formats). If you specify short Date, the int 1Param value should be the handle to
a numeric-format resource; if you specify abbrevDate or longDate, it should be the
handle to a long-date-format resource. If the int 1 Param value is NIL,
LongDateString uses the resource from the current script.

SPECIAL CONSIDERATIONS

LongDateString may move memory; your application should not call this procedure
at interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the LongDateString procedure are
Trap macro

Selector

_Pack6é

$0014

Long TimeString
The LongTimeString procedure converts a time that is speci

ed as a LongDateTime

value into a Pascal string, making use of the time formatting information in the
speci ed resource.
PROCEDURE

LongTimeString
(VAR

dateTime:

wantSeconds:
VAR

dateTime
wantSeconds

5-90

result:

LongDateTime;
Boolean;
Str255;

intlParam:

Handle);

A 64-bit, signed representation of the number of seconds since Jan. 1, 1904.
A Sag that indicates whether the seconds are to be included in the
resulting string.

Text Utilities Reference

CHAPTER

5

Text Utilities

result

On output, contains the string representation of the time.

intlParam

A handle to a numeric-format ('1t10') resource that speci

es time

formatting information for use in the conversion.

DESCRIPTION
LongTimeString converts the LongDateTime value in the dateTime parameter into a

Pascal string representation of the time. You can use the LongSecondsToDate and

LongDateToSeconds procedures, which are described in the book Inside Macintosh:

Operating System Utilities, to convert between the LongDateRec (as produced by the
StringToTime function) and LongDateTime data types.
LongTimeString produces a string that includes the seconds if you set the
wantSeconds parameter to TRUE.
LongTimeString formats its data according to the information in the numeric-format

resource speci ed in the int 1 Param parameter. If this value is NIL, LongTimeString
uses the numeric-format resource from the current script. The numeric-format resource
speci es whether or not to use leading zeros for the time values, whether to use a 12- or
24-hour time cycle, and how to specify morning or evening if a 12-hour time cycle

is used.

SPECIAL CONSIDERATIONS

LongTimeString may move memory; your application should not call this procedure
at interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the LongTimeSt ring
Trap macro

Selector

_Packé

$0016

procedure are

Converting Between Integers and Strings
This section describes routines that allow you to convert between string and numeric
representations of numbers. Unless patched by a script system with different rules, these
two routines assume that you are using standard numeric token processing, meaning that
the Roman script system number processing rules are used.
mw The NumToString procedure converts a long integer value to a string representation

of it as a base-10 number.

mw The StringToNum procedure converts a string representation of a base-10 number
into a long integer value.

Text Utilities Reference

5-91

CHAPTER

5

Text Utilities

For routines that make use of the token-processing information that is found in the
tokens ('it14') resource of script systems for converting numbers, see the section
Using Number Format Speci cation Strings for International Number Formatting,O
which begins on page 5-94, and the section Converting Between Strings and
Floating-Point Numbers,Owhich begins on page 5-98.

NumToString
The

NumToSt ring procedure converts a long integer value into a Pascal string.

PROCEDURE

NumToString

(theNum:

LongInt;

VAR

theString:

Str255);

theNum

A long integer value.

theString

On output, contains the Pascal string representation of the number.

DESCRIPTION

NumToString creates a string representation of theNum as a base-10 value and returns
the result in

theSt ring.

If the value of the number in the parameter theNum is negative, the string begins with a
minus sign; otherwise, the sign is omitted. Leading zeros are suppressed, except that a
value of 0 produces the string MO NumToSt ring does not include thousand separators
or decimal points in its formatted output.

SPECIAL CONSIDERATIONS

NumToString may move memory; your application should not call this procedure at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the
Trap macro

Selector

_Pack7

$0000

NumToSt ring procedure are

The registers on entry and exit for this routine are
Registers on entry

AO
DO

pointer to the length byte that precedes theString
__ the long integer value to be converted

Registers on exit

DO

5-92

pointer to the length byte that precedes theString

Text Utilities Reference

CHAPTER

5

Text Utilities

StringToNum
The StringToNum procedure converts the Pascal string representation of a base-10
number into a long integer value.
PROCEDURE

StringToNum

(theString:

Str255;

VAR

theNum:

theString

A Pascal string representation of a base-10 number.

theNum

On output, contains the numeric value.

LongInt) ;

DESCRIPTION

StringToNum converts the base-10 numeric string in the theString parameter to the
corresponding long integer value and returns the result in the parameter theNum. The
numeric string can be padded with leading zeros or with a sign.
The 32-bit result is negated if the string begins with a minus sign. Integer overf$ow occurs
if the magnitude is greater than or equal to 2 raised to the 31st power. StringToNum
performs the negation using the two@ complement method: the state of each bit is
reversed and then 1 is added to the result. For example, here are possible results
produced by StringToNum:
Value of theString

Value returned
In theNum

O 230
O00
@)550

23
0
55

O 21474836480

2147483648

Q1294967295O0(magnitude is 232 1)

1

(21474836480(magnitude is 2431)

O 42949672950

2147483648

1

StringToNum does not check whether the characters in the string are between 0 and 9;
instead, it takes advantage of the fact that the ASCII values for these characters are $30
through $39, and masks the last four bits for use as a digit. For example, StringToNum
converts 2: to the number 30 since the character code for the colon (:) is $3A. Because

StringToNum operates this way, spaces are treated as zeros (the character code for a
space is $20), and other characters do get converted into numbers. For example, the

character codes for 'C’,'A’, and 'T" are $43, $41, and $54 respectively, producing

these results:
Value of

Value returned

theString

In theNum

‘CAT’

314

'+CAT"

314

" CAT

314

Text Utilities Reference

5-93

CHAPTER

5

Text Utilities

Note
One consequence of this conversion method is that StringToNum does

not ignore thousand separators (the QOcharacter in the United States),

which can lead to improper conversions. It is a good idea to ensure that
all characters in theSt ring are valid digits before you call
StringToNum.

SPECIAL CONSIDERATIONS

StringToNum may move memory; your application should not call this procedure at
interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the StringToNum procedure are
Trap macro

Routine selector

_Pack7

$0001

The registers on entry and exit for this routine are
Registers on entry

AO

pointer to the length byte that precedes theString

Registers on exit

DO

the long word value

Using Number Format Speci

cation Strings for International Number Formatting

To allow for all of the international variations in numeric presentation styles, you need to
include in your routine calls a number parts table from a tokens ('1t14') resource. You

can usually use the number parts table in the standard tokens resource that is supplied
with the system. You also need to de ne the format of input and output numeric strings,
including which characters (if any) to use as thousand separators, whether to indicate
negative values with a minus sign or by enclosing the number in parentheses, and how to
display zero values. These details are speci ed in number format speci cation strings, the
syntax of which is described in the section QUsing Number Format Speci cation Strings,O
beginning on page 5-39.
To make it possible to map a number that was formatted for one speci cation into
another format, the Macintosh Operating System de nes an internal numeric
representation that is independent of region, language, and other multicultural
considerations: the NumFormatStringRec

record. This record is created from a number

format speci cation string that de nes the appearance of numeric strings. Its use is
summarized in Figure 5-12 on page 5-37.

5-94

Text Utilities Reference

CHAPTER

5

Text Utilities

In brief, what you have to do is create a number format speci cation string that you want
to use and convert that string into a NumFormat StringRec record. The Text Utilities
include two routines for this purpose:
m The StringToFormatRec function converts a number format speci
into a NumFormat

StringRec

record.

cation string

m The FormatRecToString function converts the internal representation in a
NumFormatStringRec record into a number format speci cation string, which can
be viewed and modi ed.

String ToFormatRec
The StringToFormatRec function creates a number format speci cation string record
from a number format speci cation string that you supply in a Pascal string.
FUNCTION

StringToFormatRec(inString:
partsTable:

VAR

inString

A

Str255;

NumberParts;

outString:

NumFormatStringRec):

FormatStatus;

Pascal string that contains the number formatting speci

cation.

partsTable

A record usually obtained from the tokens ('it14') resource that shows

the correspondence between generic number part separators (tokens) and
their localized version (for example, a thousand separator is a comma in

the United States and a decimal point in France).
outString

On output, this NumFormatStringRec

record contains the values that

form the internal representation of the format speci
the data in this record is private.

cation. The format of

DESCRIPTION

StringToFormatRec converts a number format speci cation string into the internal
representation contained in a number format string record. It uses information in the
current script@ tokens resource to determine the components of the number.
StringToFormatRec checks the validity both of the input format string and of the
number parts table (since this table can be programmed by the application).
StringToFormatRec ignores spurious characters.
The inString parameter contains a number format speci cation string that speci es
how numbers appear. This string contains up to three speci cations, separated by
semicolons. The positive number format is speci ed_ rst, the negative number format is
second, and the zero number format is last. If the string contains only one part, that is the
format of all three types of numbers. If the string contains two parts, the rst part is the
format for positive and zero number values, and the second part is the format for

negative numbers. The syntax for the number format speci cation strings is described in
detail in QUsing Number Format Speci cation Strings,Owhich begins on page 5-39.

Text Utilities Reference

5-95

CHAPTER

5

Text Utilities

StringToFormatRec returns a value of type Format Status that denotes the
con dence level for the conversion that it performed. The low byte of the
FormatStatus value is of type FormatResultType, the values of which are described
in Table 5-6 on page 5-38.
IMPORTANT

Be sure to cast the result of StringToFormatRec to a type
FormatResultType before working with it. a

SPECIAL CONSIDERATIONS

StringToFormatRec may move memory; your application should not call this function
at interrupt time.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the StringToFormatRec function are
Trap macro

Selector

_Scriptutil

$820C FFEC

SEE ALSO

For comprehensive details on the number parts table, see the appendix Ginternational
ResourcesOin this book.
To obtain a handle to the number parts table from a tokens resource, use the
Get Int lResourceTable procedure, which is described in the chapter Gcript
ManagerOin this book.

FormatRecToString
The FormatRecToString function converts an internal representation of number
formatting information into a number format speci cation string, which can be displayed
and modi ed.
FUNCTION

FormatRecToString(myFormatRec:
partsTable:

VAR

NumFormatStringRec;

NumberParts;

positions:

TripleInt):

VAR

outString:

Str255;

FormatStatus;

myFormatRec

The internal representation of number formatting information, as created

by a previous call to the StringToFormatRec function.

5-96

Text Utilities Reference

CHAPTER

5

Text Utilities

partsTable

A record obtained from the tokens ('it14') resource that shows the

correspondence between generic number part separators (tokens) and

their localized version (for example, a thousand separator is a comma in

the United States and a decimal point in France).
outString

On output, contains the number format speci

cation string.

positions

Anarray that speci es the starting position and length of each of the three
possible format strings (positive, negative, or zero) in the number format
speci cation string. Semicolons are used as separators in the string.

DESCRIPTION

Format RecToString

is the inverse operation of StringToFormatRec. The internal

representation of the formatting information in myFormatRec must have been created
by a prior call to the StringToFormatRec

parts table speci

function. The information in the number

es how to build the string representation.

The output number format speci cation string in out String speci es how numbers
appear. This string contains three parts, which are separated by semicolons. The rst part
is the positive number format, the second is the negative number format, and the third

part is the zero number format. The syntax for this string is described in detail in QUsing
Number Format Speci cation Strings,Owhich begins on page 5-39.
The positions parameter is an array of three integers (a TripleInt value), which
speci es the starting position in out String of each of three formatting speci cations:
Array entry

What its value specifies

positions [fPositive]

the index in out String of the rst byte of the formatting
speci cation for positive number values

positions [fNegative]

the index in out String of the rst byte of the formatting
speci cation for negative number values

positions [fZero]

the index in out String of the rst byte of the formatting
speci cation for zero number values

Format RecToString returns a value of type Format Status that denotes the
con dence level for the conversion that it performed. The low byte of the
Format Status value is of type FormatResultType, the values of which are described
in Table 5-6 on page 5-38.
IMPORTANT

Be sure to cast the result of FormatRecToString toa type
FormatResult Type

ASSEMBLY-LANGUAGE

before working with it. a

INFORMATION

The trap macro and routine selector for the FormatRecToSt
ring
Trap macro

Selector

_Scriptutil

$8210 FFEA

Text Utilities Reference

function are

5-97

CHAPTER

5

Text Utilities

SEE

ALSO

For comprehensive details on the number parts table, see the appendix Ginternational
ResourcesOin this book.
To obtain a handle to the number parts table from a tokens resource, use the
Get Int lResourceTable procedure, which is described in the chapter Gcript
ManagerOin this book.

Converting Between Strings and Floating-Point Numbers
Once you have created a NumFormat StringRec record that speci es how numbers are
represented, as described in QUsing Number Format Speci cation Strings for
International Number Formatting, Owhich begins on page 5-94, you can use two other
Text Utilities routines to convert between string and Soating-point representations of
numbers. Floating-point numbers are stored in standard Apple (SANE) format.
m The StringToExtended function converts the string representation of a number into
a fSoating-point number, using a NumFormatStringRec record to specify how the
input number string is formatted.
m The ExtendedToString function converts a fSoating-point number into a string that
can be presented to the user, using a NumFormatStringRec record to specify how
the output number string is formatted.

String ToExtended
The StringToExtended function converts a string representation of a number into a
Soating-point number.
FUNCTION

StringToExtended(source:

Str255;

myFormatRec:
partsTable:

VAR

source

x:

NumFormatStringRec;
NumberParts;

Extended80):

FormatStatus;

A Pascal string that contains the string representation of a number.

myFormatRec

The internal representation of the formatting information for numbers, as

produced by the StringToFormatRec function.
partsTable

A record obtained from the tokens ('it14') resource that shows the

correspondence between generic number part separators (tokens) and

their localized version (for example, a thousand separator is a comma in

the United States and a decimal point in France).
x

5-98

On output, contains the 80-bit SANE representation of the
Soating-point number.

Text Utilities Reference

CHAPTER

5

Text Utilities

DESCRIPTION

StringToExt ended uses the internal representation of number formatting information
that was created by a prior call to StringToFormatRec to parse the input number
string. It uses the number parts table to determine the components of the number string
that is being converted. StringToExt ended parses the string and then converts the
string to a simple form, stripping nondigits and replacing the decimal point before
converting it into a Soating-point number. If the input string does not match any of the
patterns, then StringToExt ended parses the string as well as it can and returns a
con dence level result that indicates the parsing dif culties.
StringToFormatRec returns a value of type Format Status that denotes the
con dence level for the conversion that it performed. The low byte of the
Format Status value is of type FormatResultType, the values of which are described
in Table 5-6 on page 5-38.
IMPORTANT

Be sure to cast the result of StringToExt ended to a type
Format ResultType before working withit.

a

SPECIAL CONSIDERATIONS

StringToExtended returns an 80-bit, not a 96-bit, representation.

ASSEMBLY-LANGUAGE

INFORMATION

The trap macro and routine selector for the StringToExtended function are
Trap macro

Selector

_ScriptUtil

$8210 FFE6

SEE ALSO

For comprehensive details on the number parts table, see the description of the tokens
('it14') resource in the appendix Onternational ResourcesOin this book.
To obtain a handle to the number parts table from a tokens resource, use the
Get Int lResourceTable procedure, which is described in the chapter CScript
ManagerOin this book.

Text Utilities Reference

5-99

CHAPTER

5

Text Utilities

ExtendedToString
The ExtendedToString function converts an internal Soating-point representation of a
number into a string that can be presented to the user.
FUNCTION

ExtendedToString(x:

Extended80;

myFormatRec:
partsTable:

VAR

x

NumFormatStringRec;
NumberParts;

outString:

Str255):

FormatStatus;

A Soating-point value in 80-bit SANE representation.

myFormatRec

The internal representation of the formatting information for numbers, as

produced by the StringToFormatRec function.
partsTable

A record obtained from the tokens ('it14') resource that shows the

correspondence between generic number part separators (tokens) and

their localized version (for example, a thousand separator is a comma in

the United States and a decimal point in France).
outString

On output, contains the number formatted according to the information in
myFormatRec.

DESCRIPTION

ExtendedToString creates a string representation of a Soating-point number, using the
formatting information in the myFormat
Rec parameter (which was created by a
previous call to StringToFormatRec) to determine how the number should be
formatted for output. It uses the number parts table to determine the component parts of
the number string.
StringToFormatRec returns a value of type Format Status that denotes the
con dence level for the conversion that it performed. The low byte of the
FormatStatus value is of type FormatResultType, the values of which are described
in Table 5-6 on page 5-38.
IMPORTANT

Be sure to cast the result of ExtendedToString toa
FormatResultType before working with it. a

ASSEMBLY-LANGUAGE

type

INFORMATION

The trap macro and routine selector for the Ext endedToSt ring function are

5-100

Trap macro

Selector

_Seriptutil

$8210 FFE8

Text Utilities Reference

CHAPTER

5

Text Utilities

SEE ALSO
For comprehensive details on the number parts table, see the description of the tokens
('it14') resource in the appendix Onternational ResourcesOin this book.
To obtain a handle to the number parts table from a tokens resource, use the
Get Int lResourceTable procedure, which is described in the chapter CScript
ManagerOin this book.

Text Utilities Reference

5-101

CHAPTER

5

Text Utilities

Summary of Text Utilities
Pascal Summary
Constants
CONST
{StringToDate

and

StringToTime

status

values

}

longDateFound
leftOverChars

= 1;
= 2;

{mask
{mask

to
to

long
warn

date found}
of left over

sepNotIntlSep

=

4;

{mask

to

warn

of

chars}

non-standard

fieldOrderNotIntl

=

8;

{mask

to

warn

of

non-standard

extraneousStrings

=

16;

{mask

to

warn

of

unparsable

tooManySseps

=

32;

{mask

to

warn

of

too

sepNotConsistent

=

64;

{mask

to

warn

of

inconsistent

fatalDateTime

=

$8000;

{mask

to

a

{mask

for

tokenErr

=

$8100;

cantReadUtilities

=

dateTimeNotFound
=

{Constants

can’t

access

needed

for

date

or

not

$8800;

{mask

for

date/time

0;
$4000;
for
=

TrunckErr

=

=

-2;

systemDefLang

=

-3;

currentCurLang

=

-4;

currentDefLang

=

-5;

scriptCurLang

=

-6;

scriptDefLang

=

-7;

5-102

format

resource}

found}
not

TruncString

valid}

and

TruncText }

end}
middle}

TruncText

results}

{no truncation was necessary}
{truncation performed}
{general error}

language

systemCurLang

Language

Order}

current

language

for

system

script

(from

'itlb')

default

language

for

system

script

(from

'itlm')

current

language

for

current

script

(from

default

language

for

current

script

(from

current

lang

default

language

specified script (from 'itlb')}
for specified script (from 'itlm') }

{
asaes

{Special

0;
1;
-1;

and

in

time

as

=

Truncated

TruncString

at
in

separators}

_a

Not Truncated

argument

{truncate
{truncate

text}

encountered! }

for

truncMiddle

{Constants

err

{mask

truncWhere

in

error}

‘tokenizer

{mask

for

order}

separators}

$8200;

truncEnd

field
strings

$8400;

=

dateTimeInvalid

fatal

many

separators}

Summary of Text Utilities

code

values

for

for

}
}

'atl1b' ) }
'itim!' )

}

CHAPTER

5

Text Utilities

Data Types
TYPE

FormatStatus
TruncCode

=

=

DateForm

Integer;

Integer;

=

(shortDate,longDate,abbrevDate) ;

FormatResultType
(fFormatOK,

=

fBestGuess,

fOutofSynch,

fExtraDecimal,

fMissingLiteral,

fBadPartsTable,

fExtraPercent,

FormatClass

=

fFormatOverflow,

fExtraSeparator,

fFormStrIsNAN,

fEmptyFormatString) ;

(fPositive,fNegative,fZero) ;

StyledLineBreakCode
DateCacheRecord
PACKED

fSpuriousChars,fMissingDelimiter,
fExtraExp,

=

{BreakWord,

BreakChar,

BreakOverflow};

=

RECORD

hidden:

ARRAY

[0..255]

OF

Integer;{only

for

temporary

use}

{private

data}

END;

DateCachePtr

=

“DateCacheRecord;

NumFormatStringRec
PACKED

=

RECORD

flength:

Byte;

fVersion:

data:

Byte;

PACKED

ARRAY

[0..253]

OF

SignedByte;

END;

FVector

=

RECORD
Start:

Integer;

length:

Integer

END;

TripleInt

=

ARRAY[0..2]

OF

Summary
of Text Utilities

FVector;

{index

by

[fPositive..fZero]

}

5-103

CHAPTER

5

Text Utilities

OffPair

=

RECORD

offFirst:

Integer;

offSecond:

Integer;

END;

OffsetTable

=

ScriptRunStatus

ARRAY[0..2]

OF

OffPair;

=

RECORD

script:

SignedByte;

variant:

SignedByte;

END;

Routines
Defining and Specifying Strings
( theString:

Str255):

PROCEDURE SetString
FUNCTION GetString

( theString:

StringHandle;

PROCEDURE

( VAR

FUNCTION

NewString

GetIndString

(stringID:

StringHandle;

Integer) :

theString:

strNew:

Str255) ;

StringHandle;

Str255;

strListID:

Integer;

Integer) ;

index:

Comparing Strings for Equality
FUNCTION

EqualString

(aStr,

bStr:

diacSens:

caseSens,

FUNCTION

IdenticalString

(aStr,

Str255;

bStr:

itl2Handle:

FUNCTION

IdenticalText

(aPtr,

bPtr:

itl2Handle:

Boolean):

Boolean;

Str255;

Integer;

Handle):
Ptr;

aLen,

Handle):

bLen:

Integer;

Integer;

Determining Sorting Order for Strings in Different Languages
FUNCTION

ScriptOrder

(scriptl,

FUNCTION

LanguageOrder

(langl1,

FUNCTION

StringOrder

(aStr,

FUNCTION

TextOrder

lang2:
bStr:

(aPtr,

Ptr;

aLang,

Summary
of Text Utilities

Str255;
aLang,

bPtr:

bScript:
bLang:

ScriptCode):

LangCode):

ScriptCode;
aScript,

5-104

script2:

Integer;

aScript,
bLang:

aLen,

Integer;

bScript:

LangCode) :

bLen:

Integer;

ScriptCode;

LangCode) :

Integer;

Integer;

CHAPTER

5

Text Utilities

Determining Sorting Order for Strings in the Same Language
FUNCTION

RelString

(aStr,

bStr:

caseSens,
FUNCTION
FUNCTION

CompareString
CompareText

(aStr,

Str255;

diacSens:

bStr:

Boolean):

Integer;

Str255;

itl2Handle:

Handle):

(aPtr,

Ptr;

bPtr:

Integer;

aLen,

bLen:

Integer):

Integer;

Modifying Characters and Diacritical Marks
PROCEDURE

UpperString

(VAR

theString:

PROCEDURE

LowercaseText

(textPtr:

Ptr;

script:
PROCEDURE

UppercaseText
StripDiacritics

(textPtr:

Ptr;

Boolean) ;

Integer;

len:

Integer;

ScriptCode) ;

(textPtr:

Ptr;

script:

PROCEDURE

len:

diacSens:

ScriptCode) ;

script:
PROCEDURE

Str255;

len:

Integer;

ScriptCode) ;

UppercaseStripDiacritics
(textPtr:

Ptr;

len:

Integer;

script:

ScriptCode) ;

(width:

Integer;

Truncating Strings
FUNCTION

TruncString

truncWhere:
FUNCTION

TruncText

(width:
VAR

VAR

theString:

TruncCode):

Integer;

length:

Str255;

Integer;

textPtr:

Ptr;

Integer;

truncWhere:

TruncCode):

Integer;

Searching for and Replacing Strings
FUNCTION

ReplaceText

(baseText,
key:

FUNCTION

Munger

(h:

substitutionText:

Str15):
Handle;

Handle;

Integer;
offset:

LongInt;

ptrl:

Ptr;

lenl:

LongInt;

ptr2:

Ptr;

len2:

LongInt):

LongInt;

Working With Word, Subscript, and Line Boundaries
PROCEDURE

FindWordBreaks

(textPtr:

Ptr;

offset:

Integer;

textLength:

Integer;

leadingEdge:

Boolean;

nBreaks:

NBreakTablePtr;
VAR

Summary
of Text Utilities

offsets:OffsetTable

);

5-105

CHAPTER

5

Text Utilities

FUNCTION

StyledLineBreak

(textPtr:

Ptr;

textStart,

FUNCTION

FindScriptRun

textLen:

textEnd,

VAR

textWidth:

VAR

textOffset:

(textPtr:
VAR

LongInt;

flags:

Ptr;

LongInt):
textLen:

lenUsed:

LongInt;

Fixed;

StyledLineBreakCode;

LongInt;

LongInt):

ScriptRunStatus;

Converting Date and Time Strings Into Numeric Representations
FUNCTION

InitDateCache

(theCache:

DateCachePtr):

FUNCTION

StringToDate

(textPtr:

Ptr;

theCache:

DateCachePtr;

FUNCTION

StringToTime

textLen:

VAR

lengthUsed:

VAR

dateTime:

OSErr;
LongInt;

LongInt;
LongDateRec):

(textPtr:

Ptr;

theCache:

DateCachePtr;

textLen:

VAR

lengthUsed:

VAR

dateTime:

StringToDateStatus;

LongInt;

LongInt;
LongDateRec):

StringToDateStatus;

Converting Numeric Representations Into Date and Time Strings
PROCEDURE

DateString

(dateTime:

VAR
PROCEDURE

TimeString

LongInt;

result:

(dateTime:

VAR

longFlag:

Str255;
LongInt;

result:

DateForm;

intlHandle:

Handle) ;

wantSeconds:

Boolean;

intlHandle:

Handle) ;

Str255;

Converting Long Date and Time Values Into Strings
PROCEDURE
PROCEDURE

LongDateString
LongTimeString

(VAR

dateTime:

VAR

result:

(VAR

dateTime:

LongDateTime;

Str255;

DateForm;

Handle) ;

LongDateTime;

wantSeconds:Boolean;
intlHandle:

longFlag:

intlHandle:
VAR

result:

Str255;

Handle) ;

Converting Between Integers and Strings
PROCEDURE

NumToString

(theNum:

LongInt;

PROCEDURE

StringToNum

(theString:

VAR

Str255;

theString:

VAR

Str255);

theNum:

LongInt) ;

Using Number Format Specification Strings for International Number Formatting
FUNCTION

StringToFormatRec

(inString:
VAR

5-106

Summary of Text Utilities

Str255;

outString:

partsTable:

NumberParts;

NumFormatString):

FormatStatus;

CHAPTER

5

Text Utilities

FUNCTION

FormatRecToString

(myFormatRec:

NumFormatString;

partsTable:

NumberParts;

VAR

outString:

Str255;

VAR

positions:

TripleInt):

FormatStatus;

Converting Between Strings and Floating-Point Numbers
FUNCTION

StringToExtended

(source:

Str255;

partsTable:

FUNCTION

ExtendedToString

VAR

x:

(x:

Extended80):

Extended80;

partsTable:

VAR

myFormatRec:

NumFormatString;

NumberParts;

FormatStatus;

myFormatRec:

NumFormatString;

NumberParts;

outString:

Str255):

FormatStatus;

C Summary
Constants
enum

{

/*StringToDate

longDateFound

=

leftOverChars
sepNotIntlSep

and

StringToTime

status

values*/

1;

/*mask

to

long

date

found*/

=

2;

/*mask

to

warn

of

left

=

4;

/*mask

to

warn

of

non-standard

over

chars*/

fieldOrderNotIntl

=

8;

/*mask

to

warn

of

non-standard

extraneousStrings

=

16;

/*mask

to

warn

of

unparsable

tooManySeps

=

32;

/*mask

to

warn

of

too

/*mask

to

warn

of

inconsistent

fatalDateTime

tokenErr

=

=

0x8000;

/*mask

to

a

/*mask

for

0x8200;/*mask

=

0x8100;

cantReadUtilities

=

dateTimeNotFound
dateTimeInvalid

=
=

0x8400;
0x8800;

fatal

many

field
strings

64;

sepNotConsistent

separators*/
order*/
*/

separators*/
separators*/

error*/

'tokenizer

for

can’t

/*mask

for

date

/*mask

for

date/time

err

access
or

time

encountered'*/

needed
not

format

resource*/

found*/
not

valid*/

bi
enum

{

/*constants

truncEnd

=

truncMiddle

for

truncWhere

0,
=

0x4000,

argument

in

TruncString

/*truncate

at

end*/

/*truncate

in

middle*/

and

TruncText*/

bi

Summary of Text Utilities

5-107

CHAPTER

5

Text Utilities

enum

{

/*constants

notTruncated
truncated

}

truncErr

enum

{

=

=

=

for

TruncString

0,

/*no

and

1,

/*truncation

-1,

/*general

/*special

language

systemCurLang

=

SsystemDefLang

=

currentCurLang

results*/

necessary*/

performed*/

code

values

/*current

lang

for

-3,
=

was

error*/

-2,
=

currentDefLang

TruncText

truncation

for

Language

Order*/

system

script

(from

'itlb')*/

script

(from

'itlm')*/

/*default

lang

for

system

-4,

/*current

lang

for

current

script

(from

'itlb')*/

-5,

script

(from

'itlm')
*/

/*default

lang

for

current

scriptCurLang

=

-6,

/*current

lang

for

specified

script

(from

'itlb')*/

scriptDefLang

=

-7,

/*default

lang

for

specified

script

(from

'itlm')*/

bi
enum

{

BreakWord,
BreakChar,
BreakOverf
low

bi
enum

{

fPositive,

fNegative,
fZero

bi
enum {
fFormatoKk,
fBestGuess,
fOutOfSynch,

fSpuriousChars,
fMissingDelimiter,
fExtraDecimal,
fMissingLiteral,
fExtraExp,
fFormatOverflow,
fFormStriIsNAN,

fBadPartsTable,
fExtraPercent,
fExtraSeparator,

fEmptyFormatString

5-108

Summary of Text Utilities

CHAPTER

5

Text Utilities

enum

{

shortDate,
longDate,
abbrevDate

bi
Types
typedef

short

typedef

unsigned

char

StyledLineBreakCode;

typedef

unsigned

char

FormatClass;

typedef

short

typedef

unsigned

char

FormatResultType;

typedef

unsigned

char

DateForm;

struct

bi

StringToDateStatus;

TruncCode;

DateCacheRecord

short

struct

typedef

DateCacheRecord

DateCacheRecord

NumFormatString

char

/*only

hidden[256] ;

typedef

struct

{
for

temporary

use*/

DateCacheRecord;

*DateCachePtr;

{

fLength;

char

fVersion;

char

data[254];

/*private

data*/

bi
typedef

struct

struct

FVector

short

start;

short

length;

NumFormatString

NumFormatStringRec;

{

bi
typedef

struct

typedef

FVector

struct

ScriptRunStatus

char

script;

char

variant;

FVector

FVector;

TripleInt

[3];

/*

index

by

[fPositive

..fZero]

*/

{

Summary
of Text Utilities

5-109

CHAPTER

5

Text Utilities

typedef

struct

struct

OffPair

ScriptRunStatus

ScriptRunStatus;

{

Short

offFirst;

short

of fSecond;

bi
typedef

struct

OffPair

typedef

OffPair

OffPair;

OffsetTable
[3];

Routines

Defining and Specifying Strings
pascal

StringHandle

NewString
(ConstStr255Param

pascal

void

SetString

(StringHandle

theString,

ConstStr255Param
pascal

StringHandle
void

strNew) ;

GetString
(short

pascal

theString) ;

GetIndString

stringID) ;

(Str255

theString,

short

index) ;

short

strListID,

Comparing Strings for Equality
pascal

Boolean

EqualString

(ConstStr255Param
Boolean

pascal

short

Handle
short

ConstStr255Param

Boolean

diacSens

bStr,

);

IdenticalString
(ConstStr255Param

pascal

aStr,

caseSens,

IdenticallText

aStr,

ConstStr255Param

bStr,

itl2Handle) ;

(const

void

*aPtr,

const

void

short

aLen,

short

bLen,

Handle

*bPtr,
itl2Handle) ;

Determining Sorting Order for Strings in Different Languages
pascal

short

ScriptOrder

(ScriptCode

pascal

short

LanguageOrder

(LangCode

pascal

short

StringOrder

(ConstStr255Param
ScriptCode
LangCode

5-110

Summary of Text Utilities

scriptl1,
languagel,

LangCode

aStr,

aScript,
aLang,

ScriptCode

language2) ;

ConstStr255Param

ScriptCode

LangCode

script2);

bScript,

blLang) ;

bStr,

CHAPTER

5

Text Utilities

pascal

short

TextOrder

(const

void

*aPtr,

const

short

aLen,

short

blLen,

ScriptCode
LangCode

aScript,
aLang,

void

*bPtr,

ScriptCode

LangCode

bScript,

bLang) ;

Determining Sorting Order for Strings in the Same Language
pascal

short

RelString

(ConstStr255Param
Boolean

pascal

short

CompareString

short

CompareText

ConstStr255Param

Boolean

(ConstStr255Param

Handle
pascal

aStr,

caseSens,

aStr,

bStr,

diacSens) ;

ConstStr255Param

bStr,

itl2Hande) ;

(const

void

*aPtr,

const

void

short

aLen,

short

bLlLen,

Handle

*bPtr,
itl2Handle) ;

Modifying Characters and Diacritical Marks
pascal

void

UpperString

( Str255

pascal

void

LowercaseText

( Ptr

textPtr,

short

len,

ScriptCode

script) ;

pascal

void

UppercaseText

(Ptr

textPtr,

short

len,

ScriptCode

script) ;

pascal

void

StripDiacritics

( (Ptr

textPtr,

short

len,

ScriptCode

script) ;

pascal

void

UppercaseStripDiacritics
short

len,

ScriptCode

script) ;

(Ptr

theString,

textPtr,

Boolean

diacSens) ;

Truncating Strings
pascal

short

TruncString

(short

width,

TruncCode
pascal

short

TruncText

(short

Str255

theString,

truncWhere) ;

width,

TruncCode

Ptr

textPtr,

short

*textLen,

truncWhere) ;

Searching for and Replacing Strings
pascal

short

ReplaceText

(Handle

baseText,

Handle

substitutionText,

Str15

key) ;
pascal

long

Munger

(Handle

h,

long

lenl,

long

offset,

const

void

*ptrl1,

void

*ptr2,

long

len2);

short

offset,

const

Working With Word, Subscript, and Line Boundaries
pascal

void

FindWordBreaks

(Ptr

textPtr,

Boolean

OffsetTable
pascal

StyledLineBreakCode

textLen,

NBreakTablePtr

breaks,

offsets) ;

StyledLineBreak
(Ptr

Summary of Text Utilities

short

leadingEdge,

textPtr,

long

long

textEnd,

long

long

*textOffset) ;

textLen,

long

textStart,

flags,

Fixed

*textWidth,

5-111

CHAPTER

5

Text Utilities

pascal

ScriptRunStatus

FindScriptRun
(Ptr

textPtr,

long

textLen,

long

*lenUsed) ;

Converting Date and Time Strings Into Numeric Representations
pascal

OSErr

InitDateCache

pascal

StringToDateStatus

(DateCachePtr
StringtoDate
(Ptr

pascal

StringToDateStatus

theCache) ;

textPtr,

long

textLen,

DateCachePtr

theCache,

LongDateRec

*dateTime) ;

long

*lengthUsed,

StringToTime
(Ptr

textPtr,

long

textLen,

DateCachePtr

theCache,

long

LongDateRec

*dateTime) ;

*lengthUsed,

Converting Numeric Representations Into Date and Time Strings
pascal

void

DateString

(long

dateTime,

Str255
pascal

void

TimeString

(long

DateForm

result,

Handle

dateTime,

Str255

longFlag,

intlHandle) ;

Boolean

wantSeconds,

Handle

intlHandle) ;

*dateTime,

DateForm

Handle

intlHandle) ;

result,

Converting Long Date and Time Values Into Strings
pascal

void

LongDateString

(LongDateTime
Str255

pascal

void

LongTimeString

result,

(LongDateTime
Str255

longFlag,

*dateTime,

Boolean

Handle

intlHandle);

result,

wantSeconds,

Converting Between Integers and Strings
pascal

void

NumToString

(long

theNum,

Str255

pascal

void

StringToNum

(ConstStr255Param

theString) ;

theString,

long

*theNum) ;

Using Number Format Specification Strings for International Number Formatting
pascal

FormatStatus

StringToFormatRec
(ConstStr255Param
const

NumberParts

NumFormatString
pascal

5-112

FormatStatus

inString,
*partsTable,

*outString) ;

FormatRecToStr

Summary of Text Utilities

(const

NumFormatString

const

NumberParts

Str255

outString,

*myFormatRec,

*partsTable,

TripleInt

positions) ;

CHAPTER

5

Text Utilities

Converting Between Strings and Floating-Point Numbers
pascal

FormatStatus

StringToExtended
(ConstStr255Param

pascal

FormatStatus

source,

const

NumFormatString

const

NumberParts

*myFormatRec,

*partsTable,

extended80

*x) ;

ExtendedToString
(extended8s0

const
const

x,

NumFormatString *myFormatRec,
NumberParts *partsTable,

Str255

outString) ;

Assembly-Language Summary
Trap Macros
Trap Macro Names
Pascal name

Trap macro name

CompareText

_CompareText

DateString

_DateString

ExtendedToString

_ExtendedToString

FindScriptRun

_FindScriptRun

FindWordBreaks

_FindWordBreaks

FormatRecToString

_FormatRecToString

IdenticalText

_IdenticalText

InitDateCache

_InitDateCache

LanguageOrder

_LanguageOrder

LongDateString

_LongDateString

LongTimeString

_LongTimeString

NumToString

_NumToString

ReplaceText

_ReplaceText

ScriptOrder

_ScriptOrder

StringToDate

_StringToDate

StringToExt ended

_StringToExtended

StringToFormatRec

_StringToFormatRec

StringToNum

_StringToNum

StringToTime

_StringToTime

StyledLineBreak

_StyledLineBreak

Summary of Text Utilities

5-113

CHAPTER

5

Text Utilities

Pascal name

Trap macro name

TextOrder

_TextOrder

TimeString

_TimeString

Truncstring

_TruncString

TruncText

_TruncText

Trap Macros With Trap Words
Trap macro name

Trap word

_CmpString

SA03C

_GetString

SAIBA

_LowerText

SA056

_Munger

SAQEO

_NewString

SA906

_RelString

SA050

_SetString

SA907

_StripText

SA256

_StripUpperText

SA656

_UpperText

SA456

_UprString

SA054

Trap Macros Requiring Routine Selectors

_PACK6
Selector

Routine

$000E

DateString

$0010

TimeString

$0014

LongDateString

$0016

LongTimeString

$001A

CompareText

$001C

TdenticalText

$001E

ScriptOrder

$0020

LanguageOrder

$0022

TextOrder

_PACK7
Selector

Routine

$0000

NumToString

$0001

StringToNum

5-114

Summary of Text Utilities

CHAPTER

5

Text Utilities

_Seriptutil
Selector

Routine

$8204 FFF8

InitDateCache

$8208 FFEO

TruncString

$820C 0026

FindScriptRun

$820C FFDC

ReplaceText

$820C FFEC

StringToFormatRec

$820C FFDE

TruncText

$8210 FFE6

StringToExtended

$8210 FFE8

ExtendedToString

$8210 FFEA

FormatRecToString

$8214 FFF6

StringToDate

$8214 FFF4

StringToTime

$821C FFFE

StyledLineBreak

$C012 001A

FindWordBreaks

Summary of Text Utilities

5-115

C

HAPTER 6

script Manager

Contents
About the Script Manager
6-3
The Script Manager and the Script Management System
6-4
The Script Manager and Applications
6-4
Evolution of the Script Manager
6-6
Using the Script Manager
6-7
Testing for the Script Manager and Script Systems
6-8
Controlling Settings
6-10
Checking and Setting the System Direction
6-10
Checking and Setting Script Manager Variables
6-11
Checking and Setting Script Variables
6-13
Making Keyboard Settings
6-17
Synchronizing the Font Script and Keyboard Script
6-19
Obtaining Information
6-21
Determining Script Codes From Font Information
6-21
Analyzing Characters
6-26
Directly Accessing International Resources
6-31
Using Currency, Number, and Date Formats

6-33

Using Number Parts
6-34
Retrieving Text From Tokens
6-35
Using Word-Break Tables
6-37
Using Whitespace Information
6-37
Converting Text
6-37
Tokenization
6-38
Transliteration
6-43
Modifying Script Systems
6-48
Replacing a Script System@ Default International Resources
6-50
Replacing a Script System@ Default Routines
Script Manager Reference
6-52
Constants
6-52
Script Codes
6-52
Contents

6-48

6-1

CHAPTER

6

Language Codes
6-54
Region Codes
6-57
Token Codes
6-58
Selectors for Script Manager Variables
6-61
Selectors for Script Variables
6-65
Data Structures
6-73
Token Block Record
6-74
Token Record
6-74
Routines
6-75
Checking and Setting the System Direction
6-76
Checking and Setting Script Manager Variables
6-77
Checking and Setting Script Variables
6-78
Making Keyboard Settings
6-80
Determining Script Codes From Font Information

Analyzing Characters
6-84
Directly Accessing International Resources
Tokenization
Transliteration

6-92
6-98

Replacing a Script System@ Default Routines
Summary of the Script Manager —_ 6-107
Pascal Summary
6-107
Constants
6-107
Data Types
6-121
Routines
6-122
C Summary
6-124
Constants
6-124
Data Types
6-124
Routines
6-125
Assembly-Language Summary
6-127
Trap Macros
6-127
Global Variables
6-127

6-2

Contents

6-81

6-89

6-101

CHAPTER

6

Script Manager

This chapter describes the Script Manager, a core component of the Macintosh script
management system. The Script Manager oversees script systems and gives you access to
their features.
Read this chapter if you are writing a multiscript text-handling application and need
access to the general settings and script-speci c information provided by the Script
Manager. Read this chapter also if you are writing a specialized application that parses
source code or converts text among subscripts. Read this chapter also if you wish to
modify the features or functions of an individual script system.
Before reading this chapter, you should be familiar with the Macintosh script
management system, as described in the chapter Gintroduction to Text on the MacintoshO
in this book. Useful related information is found in the appendixes Cnternational
Resources,OCKeyboard Resources,Oand (Built-in Script Support.O
This chapterN and this bookN do not catalog the features of individual script systems.
More detailed information on the world@ writing systems and the Macintosh script
systems developed to support them can be found in Guide to Macintosh Software
Localization.
The chapter gives a brief introduction to the Script Manager, and then shows how you
can use the Script Manager to
m control default settings for text handling
m obtain information about a script system
m convert text through tokenization or transliteration
m modify a script system by replacing its resources orN in some casesN its routines

About the Script Manager
The Script Manager is at the center of the Macintosh script management system. It makes
script systems available. It coordinates the interaction between many parts of Macintosh
system software and those available script systems.
The Script Manager also provides several services directly to your application. Through
them you can get information about the current text environment, modify that
environment, and perform a variety of text-handling tasks.
The Script Manager has evolved through several versions. It started with sole
responsibility for all international-compatibility and multilanguage text issues, but as
more power and features have been added, many of its speci _c functions have been
moved to the other parts of system software.

About the Script Manager

6-3

CHAPTER

6

Script Manager

The Script Manager and the Script Management System
The Script Manager manages script systems. It monitors their initialization and maintains
variables and data structures that affect their functioning. It makes sure that all initialized
script systems are complete in terms of having the required international resources and
fonts. It gives applications as well as other parts of system software their principal access
to script systemsCfeatures.

The Script Manager works closely with the other managers that make up the Macintosh
script management system, in particular the Text Utilities and QuickDraw. The Text
Utilities include many script-aware routines that manipulate text, and QuickDraw
provides script-aware measuring and drawing routines for text. When your program or a
system routine makes a script-aware Text Utilities or QuickDraw call, it commonly
results in an internal call to the Script Manager, to access a global setting or the data of a
script system.
TextEdit also relies on the Script Manager, both directly and through the Text Utilities and
QuickDraw, to make sure that it handles text correctly in any script system. The Font
Manager, the Text Services Manager, and the Dictionary Manager use information
maintained and provided by the Script Manager.
Other components of Macintosh system software also interact with the Script Manager.
The Finder uses the Script Manager to correctly input, display, and sort le and folder
names across all localized versions of system software. The Menu Manager, the
Event Manager, the Process Manager, the Operating System Utilities, and the Component
Manager all work with the Script Manager, directly or indirectly, to obtain the
information necessary to properly handle multiscript text.

The Script Manager and Applications
The Script Manager is your application@ principal interfaceN either direct or indirectN
with any of the script systems that may be available on the user@ computer. For many
text-related tasks, the Script Manager@ role is transparent; when you make a script-aware
Text Utilities or QuickDraw call while processing text, that routine may get the
information it needs through the Script Manager. For example, when you call the
QuickDraw procedure DrawText to draw a line of text, DrawText in turn calls the
Script Manager to determine which script system your text belongs to before drawing it.
In other situations you may need to call the Script Manager explicitly, to properly
interpret the text you are processing. Those situations are the principal subject of
this chapter.
The Script Manager provides services that fall into four general categories: controlling
settings, obtaining information, modifying text, and modifying script systems. Any
text-handling application that you write, unless it relies solely on TextEdit, will need to
use some of those services. Almost any text application, for example, needs to call the

6-4

About the Script Manager

CHAPTER

6

Script Manager

Get ScriptManagerVariable function. Other calls are for specialized programs only.
The Int 1Tokenize function, for example, is only for specialized programs that parse
highly structured text such as source code, mathematical expressions, or formatted
numbers.
These are the services provided by the Script Manager in each of the four categories:
= Controlling settings. The routines in this category are of general interest and are used
by most text applications. With these routines you can
4 check and set the system direction, a global variable that controls the default
alignment of text and can affect the order in which blocks of mixed-directional
text are drawn.
4 check and set Script Manager variables, private variables used by the Script
Manager to keep track of information that is general to the text environment.
4 check and set script variables, private variables used by script systems to keep track
of their own con gurations.
4 make keyboard settings that affect text input, so that users can enter text in any
script system and you can display it properly.
mw Obtaining information. Many of the routines in this category are of general interest
and are used by most text applications. With these routines you can
41 determine script codes from font information. Most applications need this
information.
O analyze characters for size (in bytes) and type. Applications that work with 2-byte
script systems need size information, and many applications need character-type
information.
“i directly access a script system@ international resources. Most applications need this
information only to pass it to other routines. Some applications also use it to inspect
or modify individual tables or other data within a resource.
mw Converting text. The routines in this category are used by specialized applications
only. (Text-modi cation routines of general interest to applications are described in the
chapter Ofext UtilitiesOin this book.) With these routines you can
O tokenize text: convert source text from any script system into
script-independent tokens.
4 transliterate text: phonetically convert text from one subscript to another within a
script system.
m Modifying script systems. The routines in this category are used for specialized
purposes, such as providing regional variants to existing script systems or assigning
script-speci c features to individual documents or applications. With these
routines you can
O replace or modify the default international resources of a script system.
O replace individual text-handling routines in certain script systems.

About the Script Manager

6-5

CHAPTER

6

Script Manager

Evolution of the Script Manager
The Script Manager is only one of several system software managers that make up the
Macintosh script management system, but its position is central.That central position
stems from the fact that, in previous versions, the Script Manager alone (including the
International Utilities) was responsible for all international text processing.
The rst version of the Script Manager was released with Macintosh System 4.1.
Table 6-1 shows the routines and some of the features of Script Manager 1.0, and
the additional routines and features that have marked each successive version of the
Script Manager (and International Utilities). Some of the added routines rendered earlier
ones obsolete, whereas others brought new capabilities.
Table 6-1

Evolution of the Script Manager

Version

New routines, other additions and enhancements

1.0

Char2Pixel, CharByte, CharType, DrawJust, FindWord,
Font2Script, FontScript, GetAppFont, GetDefFontSize,
GetEnvirons, GetMBarHeight, GetScript, GetSysFont,
GetSysJust, HiliteText, IntlScript, KeyScript, MeasureJust,
Pixel2Char, SetEnvirons, SetScript, SetSysJust,

Transliterate

2.0

introduced. New international resources de

ned.

FindScriptRun,
Format2Str, FormatStr2X, FormatX2Str,
Get FormatOrder, InitDateCache, IntlTokenize, IULDateString,
IULTimeString, LongDate2Secs, LongSecs2Date, LwrString,
LwrText, ParseTable, PortionText, ReadLocation, Str2Format,

String2Date, String2Time, StyledLineBreak,
ToggleDate,
ValidDate, VisibleLength, WriteLocation added.

2.17/2.21

Enhanced 'it12' resource. Full support for Standard Roman character
set. New token types de ned.

7.0

IUClearCache, IUGetIt1lTable, IULangOrder, IUScriptOrder,
TUStringOrder, IUTextOrder, LowerText, NChar2Pixel,
NDrawJust, NFindWord, NMeasureJust,
NPixel2Char,
NPortionText,
StripText, StripUpperText, TruncString,

TruncText, UpperText added. Support for scaled justi ed text layout.
Implicit script codes, new selectors. New keyboard resources, enhanced
U.S.
7.1

'KCHR'

resource.

CharacterByteType, CharacterType, FillParseTable,
Get QDPatchAddress,
SetQDPatchAddress,

GetScriptUtilityAddress,
SetScriptUtilityAddress,

TransliterateText added to Script Manager; several existing
routines renamed. Many additional new and renamed routines moved
to other managers such as Text Utilities and QuickDraw. WorldScript
extensions created.

” In hexadecimal, 2.17 is $211, and 2.21 is $215. See Table 6-2 on page 6-9.

6-6

About the Script Manager

CHAPTER

6

Script Manager

The most extensive changes, in terms of how the Script Manager is documented, have
been the most recent. Many of the routines described throughout Inside Macintosh: Text
are previous Script Manager routines that have been relocated and possibly enhanced or
renamed. They were moved to be documented alongside routines of similar purpose in
other managers. Many of the early Script Manager routines listed in Table 6-1 are obsolete
and are no longer documented at all. See the appendix CRenamed and Relocated Text
RoutinesOin this book for information on the current status and location of any previous
Script Manager or International Utilities routines not found in
this chapter.

Using the Script Manager
This section explains how you can use the Script Manager in performing four types of
text-related tasks. Script Manager routines can help you with
m accessing and controlling the con

guration of the text-handling environment, by

Oo

OF

OF

OO

4 determining the version of the Script Manager and the number of active
script systems
checking and setting the system direction
checking and modifying Script Manager variables
checking and modifying script variables
making keyboard settings that affect text input

m obtaining script-related information to help you process text, by
4 determining script codes from font information
4 using character-type information for searching and analyzing text
“i directly accessing a script system@ international resources
Ci using speci c tables within a script system@ international resources
m converting text for specialized purposes, by
O converting source text from any script system into script-independent tokens
4 transliterating text from one subscript to another within a script system
m modifying the features of a script system, by
O replacing or modifying the default international resources of a script system
O replacing individual text-handling routines in 1-byte complex script systems

Using the Script Manager

6-7

CHAPTER

6

Script Manager

Testing for the Script Manager and Script Systems
This section describes how to use the Gestalt function to test for the current version of
the Script Manager and the number of active script systems. For details on the Gestalt
function, see the Gestalt Manager chapter of Inside Macintosh: Operating System Utilities.
The Operating System initializes the Script Manager at startup. The Script Manager then
initializes the Roman script system. Next the Script Manager initializes any other
installed 1-byte simple script system whose smsfAutoInit bit (see page 6-69) is set. The
Script Manager then allows the script extensions WorldScript I and WorldScript II (if
present) to initialize all installed 1-byte complex and 2-byte script systems.
When initializing a script system, the Script Manager or script extension rst checks to
make sure that there is enough memory for the script system, and then checks that an
international bundle resource is present in the System le and that at least one font in the
proper ID range for that script system is present in the System le or in the Fonts folder.
If these resources are present, the script system is considered to be enabled (available for
use by the Script Manager and applications). If the required resources are not available,
the script system remains disabled.
Note
The Script Manager is fully loaded and all script systems are enabled
before any les of type 'INIT' in the Extensions folder are launched.
Thus, all Script Manager routines can be called from system
extensions. @
Use Gestalt with the gestaltScriptMgrVersion selector to obtain a result in the

response parameter that identi

es the version number of the Script Manager. This is the

same value returned by a call to the

Get ScriptManagerVariable

function with the

selector constant smVersion. Table 6-1 on page 6-6 lists some of the routines and
features available with the principal versions of the Script Manager.
Table 6-2 gives more detail on the version numbers returned by Gestalt or by

GetScriptManagerVariable with the selector smVersion, for all versions of system

software and all versions of the Script Manager. It also shows the Roman script system
versions returned by the Get Script Variable function with the selector
smScriptVersion.

Using the Script Manager

CHAPTER

6

Script Manager

Table 6-2

Version numbers for the Script Manager and Roman script system

System software
version

Script Manager
(newer ROMs)

Script Manager
(older ROMs)

Roman
script system

6.0.3 and earlier

N.A.

<= $20F

<= $101

6.0.4 Roman

$215

$211

$101

6.0.4 non-Roman

$216

$212

$101

6.0.5 all

$217 ( = 2.23)

$213

$101

Above this line, minor version numbers are binary; below, they are BCD:
6.0.7 all

$231 ( = 2.3.1)

$230

$101

$231

$230

$101

6.0.8 all

$231

$230

$101

6.1 (non-Roman)

$241

$240

$101

7.0

$700

$700

$700

7.0.1 Roman

$700

$700

$700

7.0.1 non-Rman

$701

$701

$701

7.1

$710

$710

$710

J-6.0.7.1

(Japanese)*

-

* On Macintosh Plus, Macintosh SE, Macintosh II, Macintosh IIx, Macintosh IIcx,
Macintosh SE/30, Macintosh Classic. Other CPUs have newer ROMs.

Gestalt actually returns $606 as the system version for non-Roman versions of
_ system 6.0.7.
* Gestalt actually returns $609 as the system version for system J-6.0.7.1.

Note
In versions of system software earlier than 6.0.7, the major and minor

version numbers are each treated as if they were binary. Thus a result of
$217 from Gestalt means a Script Manager version of 2.23 (in decimal).
Starting with system 6.0.7, version numbers are returned as binary-coded
decimal numbers, so a result of $710 means a Script Manager version of

7.10 (or 7.1.0).

Use the Gestalt selector gestaltScriptCount

to obtain a result in the response

parameter that gives the number of active script systems. This is the same value returned
by a call to the

Get ScriptManagerVariable function with the smEnab1led selector.

Obtaining the number of active script systems is most useful for testing whether
more than a single script system is present. If the result is 1, only the Roman script system
is present and text-handling is simplest. If the result is greater than 1, at
least one non-Roman script system is present, and your application needs to be able to
handle its text.

Using the Script Manager

6-9

CHAPTER

6

Script Manager

Controlling Settings
The rst principal use for the Script Manager is in controlling the settings that determine
the current characteristics of the text-handling environment. The Script Manager gives
you access to many variables,

elds, fSags,and

les that affect how script systems

function and how text is manipulated and displayed. The routines described in this
section are of general interest and are used by most text applications. You can use these
Script Manager routines to
m set the system direction
m access Script Manager variables
m access script variables
m determine the keyboard script, keyboard layout, and input method

Checking and Setting the System Direction
The system direction is a global setting that is commonly used to de ne the primary line
direction for text display. The system direction is speci ed by the value of the global
variable SysDirection. The value of SysDirection is 0 for a left-to-right primary line

direction and 1 for a right-to-left primary line direction.

System direction always controls the alignment (right or left) of interface elements such
as menu items and dialog box items that are drawn by the system. It can also affect caret
placement and the order in which blocks of text are drawn or highlighted in bidirectional
script runs and in multiscript lines.
QuickDraw, TextEdit, and other parts of system software that use TextEdit set the system
direction before drawing text. Although applications can format and draw text
independently of the current value of system direction, applications that follow
suggested procedures for text layout typically set the system direction before laying out
and drawing any text. See, for example, the description of the Get FormatOrder
function in the chapter GQuickDraw TextOin this book.
The default value for SysDirection usually corresponds to the primary line direction
of the system script; it is initialized from the system@ international con guration
('itlc') resource at startup. The user can change the system direction from the Text
control panel if a bidirectional script system is present.
If your application uses Set SysDirection to change the system direction in order to
correctly order script runs in a line of text while drawing, be sure to rst call
GetSysDirection to save the original value. Then call Set SysDirection again at the
appropriate timeN such as when your application becomes inactiveN to restore
SysDirection to its original value.

6-10

Using the Script Manager

CHAPTER

6

Script Manager

Checking and Setting Script Manager Variables
The

Get ScriptManagerVariable

and SetScriptManagerVariable functions let

you check and set the values of the Script Manager variables, general environmental
settings that the Script Manager maintains for all script systems.

These functions give you access to a large variety of general script-related information,
including whether one or more bidirectional script systems is present, whether one or
more 2-byte script systems is present, and what the states of the font force and
international resources selection fsags are.
You specify the variable you want to access with a selector, an integer constant that
controls the function of a multipurpose routine. You pass a selector as a parameter to
GetScriptManagerVariable

or SetScriptManagerVariable.

(The variables

themselves are private and you cannot access them directly.) Table 6-3 lists the selector
constants and the Script Manager variables they affect. See electors for Script Manager
VariablesObeginning on page 6-61 for complete explanations of the selectors
and variables.

Table 6-3

Script Manager variables accessed through
GetScriptManagerVariable/SetScriptManagerVariable

Selector constant

Explanation

smVersion

Script Manager version number

smMunged

Modi

smEnabled

Script count (0 if Script Manager not enabled)

smBidirect

Bidirectional script present fag

smFont Force

Font force Sag

smintlForce

International resources selection Sag

smForced

Script-forced result fag

smDefault

Script-defaulted result Sag

smPrint

Print action vector

smSysScript

System script code

smLastScript

Previous keyboard script

smKeyScript

Current keyboard script

smSysRef

System Folder volume reference number

smKeyCache

(obsolete, not used)

smkKeySwap

Handle to keyboard-swap ('KSWP') resource

smGenFlags

Script Manager general fags

cation count

continued

Using the Script Manager

6-11

CHAPTER

6

Script Manager

Table 6-3

Script Manager variables accessed through
GetScriptManagerVariable/SetScriptManagerVariable
(continued)

Selector constant

Explanation

smOverride

Script override fags (reserved)

smCharPortion

Intercharacter/interword spacing proportion

smDoubleByte

2-byte script present Sag

smKCHRCache

Pointer to current keyboard-layout ('KCHR') data

smRegionCode

Region code for system script

smKeyDisableState

Current disable state for keyboards

The following code fragment shows how to use the Get ScriptManagerVariable
function to get the Script Manager version number. This is the same value as that
returned by the Gestalt function using the gestalt ScriptMgrVersion selector.
VAR

selectorValue:

LongInt;

BEGIN

selectorValue

:=

GetScriptManagerVariable(smVersion) ;

END;

The

Set ScriptManagerVariable

function allows you to change many text-related

settings, including

m the font force Sag
m the international resources selection fag
m the current keyboard script
m the Script Manager general fsags, which include control of the display of the keyboard
icon and the dual caret in TextEdit
m the proportion of intercharacter versus interword spacing, when laying out lines of
justi ed text (in non-Roman script systems)
Listing 6-1 shows how to use the Set ScriptManagerVariable function to specify the
display of a dual caret in mixed-directional text. You do this by setting the appropriate bit
of the Script Manager general fsags_ eld after retrieving it with the
GetScriptManagerVariable

6-12

Using the Script Manager

function.

CHAPTER

6

Script Manager

Listing 6-1
FUNCTION

Specifying a dual caret with
MySetDualCaret:

Set ScriptManagerVariable

OSErr;

VAR

myErr:

OSErr;

selectorValue:

LongInt;

flagValue:

LongInt ;

BEGIN

flagValue

:=

BitShift
($0001, smfDualCaret)

;

selectorValue

:=

GetScriptManagerVariable(smGenFlags) ;

selectorValue

:=

BitOr(selectorValue,

myErr

:=

flagValue) ;

SetScriptManagerVariable(smGenFlags,

MySetDualCaret

:=

selectorValue) ;

myErr;

END;

You can also use Set ScriptManagerVariable to change the settings of the font force
ag and the international resources selection Sag, two fags that affect which script
systems are used for text display and date/time/number formatting, respectively. See
(Determining Script Codes From Font InformationObeginning on page 6-21.
If you are using
speci

ctask,

Set ScriptManagerVariable to change the value of a variable for a

rst call GetScriptManagerVariable

to retrieve the variable@ original

value, and save that value. Then call Set ScriptManagerVariable and perform your
task. Finally, restore the original value of the Script Manager variable with another call to
SetScriptManagerVariable as soon as possible, so that other applications or
software components that use the Script Manager will nd the values they expect.

Checking and Setting Script Variables
The

Get ScriptVariable and SetScriptVariable functions let you retrieve and set

script variables, local variables maintained for each script system by the Script Manager.

These functions give you access to a large variety of script-speci c information,
including the primary line direction for the script system, the default alignment for text
in the script system, the script system@ preferred system font and size, and its preferred
application font and size.

Using the Script Manager

6-13

CHAPTER

6

Script Manager

You specify the script system whose variables you want to access with an explicit script
code, or with an implicit script code specifying the system script or the font script. You
specify the variable you want to access with a selector constant passed as a parameter to
GetScriptVariable

or SetScriptVariable. Table 6-3 lists the selector constants

and the script variables they affect. See electors for Script VariablesObeginning on
page 6-65 for complete explanations of the selectors and variables.
Table 6-4

6-14

Script variables accessed through

GetScriptVariable/SetScriptVariable

Selector constant

Explanation

smScriptVersion

Script-system version number

smScriptMunged

Modi

smScriptEnabled

Script-enabled fag

smScriptRight

Right-to-left line direction Sag

smScriptJust

Default alignment (left or right)

smScriptRedraw

Amount of line to redraw when changing a character

smScriptSysFond

Preferred system font

smScriptAppFond

Preferred application font

smScriptNumber

Numeric-format ('it10') resource ID

smScriptDate

Long-date-format ('it11') resource ID

smScriptSort

String-manipulation ('it12') resource ID

smScriptFlags

Script fags

smScriptToken

Tokens ('it14') resource ID

smScriptEncoding

Encoding/rendering ('it15') resource ID

smScriptLang

Language
code for script

smScriptNumDate

Current numeral code and calendar code

smScriptKeys

Keyboard-layout ('KCHR') resource ID

smScriptiIcon

Keyboard icon family ID

smScriptPrint

Print action routine for script

smScriptTrap

Pointer to script record dispatch routine entry point
(for internal use)

smScriptCreator

Creator name for script

smScriptFile

Filename for script

Using the Script Manager

cation count

le

le

CHAPTER

6

Script Manager

Table 6-4

Script variables accessed through
GetScriptVariable/SetScriptVariable
(continued)

Selector constant

Explanation

smScriptName

Name of script system

smScriptMonoFondSize

Preferred font and size for

smScriptPrefFondSize

(unused)

smScriptSmallFondSize

Preferred font family and size for small text

smScriptSysFondSize

Preferred system font family and size

smScriptAppFondSize

Preferred application font family and size

smScriptHelpFondSize

Preferred Balloon Help font family and size

smScriptValidstyles

Valid text styles for script

smScriptAliasStyle

Text styles to use for aliases

xed-width font

You can use the Get ScriptVariable function to get, for example, the default
application font family ('FOND') ID and size. In the following code fragment, the

application uses the constant smSystemScript to specify that it is the system script
whose font ID is needed. The ID is returned in the high-order word and the size is
returned in the low-order word. The application then sets the appropriate graphics port
elds to those values.
VAR
myAppFont:

LongInt;

BEGIN

myAppFont

:=

GetScriptVariable(smSystemScript,
smScriptAppFondSize) ;

TextFont
(HiWord (myAppFont) ) ;
TextSize
(LoWord (myAppFont ) ) ;
END ;

Listing 6-2 shows how to represent font names correctly using the proper script for that
font. First you call the Font Manager Get FNum procedure to get the font family ID using
the font name. You call the Font ToScript function using that font family ID to get the
value of the associated script code. You then call Get ScriptVariable with the
smScriptSysFond selector to determine the font family ID for the preferred system font
for the speci ed script. Finally, you call the QuickDraw Text Font procedure with that
font family ID to set the font ID of the current graphics port to the preferred system font
of the speci ed script.

Using the Script Manager

6-15

CHAPTER

6

Script Manager

Note
The Menu Manager AddResMenu procedure automatically represents
font names in their associated script for 'FOND' resources. If you need to
display font names elsewhere than in the Font menu (for instance, using
the List Manager), be sure to use a technique such as that shown in
Listing 6-2.

@

Listing 6-2
PROCEDURE

Representing font names correctly in the script for that font
MySetTextFont

(fontName:

Str255);

VAR

scriptFont:

LongInt;

scriptNum:

Integer;

theNum:

Integer;

BEGIN

GetFNum(fontName,

theNum);

{from

font

name,

get

font

ID}

{use

font

ID

get

script

code,

}

font

ID}

{
scriptNum

:=

scriptFont

FontToScript
:=

then

(theNum)

get

to

preferred

;

GetScriptVariable(scriptNum,

TextFont (scriptFont)

;

system

{now set the
{ font ID to

smScriptSysFond) ;

current grafPort's
that font}

END;

The Set Script Variable function allows you to change many script-speci c
settings, including the default con guration settings for the script system, which
are initialized from a script system@ international bundle (' it1b') resource. You
call Set Script Variable with the appropriate script constant and selector to
indicate the setting you want changed. Listing 6-3 shows how to use the
SetScriptVariable
function to set the size of the Balloon Help font to the size
passed in the parameter theSize:
Listing 6-3
PROCEDURE

Setting the size of the Balloon Help font
MySetHelpFontSize(theSize:

LongInt) ;

VAR
myErr:

OSEYrT;

myHelpFont

:

LongInt ;

BEGIN
theSize

6-16

:=

BitAnd(theSize,

Using the Script Manager

SOOOOFFFF) ;

}

CHAPTER

6

Script Manager

{keep

low

myHelpFont

:=

GetScriptVariable(smSystemScript,

myHelpFont

:=

BitAnd(myHelpFont,

word

only}

smScriptHelpFondSize) ;

SFFFFO0OO) ;

{keep
myErr

:=

high

word

only}

SetScriptVariable(smSystemScript,
smScriptHelpFondSize,
BitOr

IF

myErr

<>

noErr

THEN

DoError

(myHelpFont,theSize)
);

(myErr)

;

END;

If you are using Set Script Variable to change the value of a variable for a speci c
task, rst call GetScriptVariable to retrieve the variable@ original value, and save it.
Then call SetScriptVariable
and perform your task. Finally, restore the original
value of the script variable with another call to Set Script Variable as soon as
possible, so that other applications or software components using that script system will
nd the values they expect.

Making Keyboard Settings
The Script Manager KeyScript procedure lets you control the script system, keyboard
layout, and input method used for text input. It also lets you make other settings
related to text input.
You use the KeyScript procedure to change the keyboard script, the script system that
controls text input. You also use it to switch among different keyboard layouts, resources
that de ne the character sets and key positions for text input in a script system. You can
also use it to switch among input methods, software facilities that allow text input in
2-byte script systems. If your application supports multiple languages, use KeyScript
to change the keyboard script when the user changes the current font. For example, if the
user selects Geezah as the current font or clicks the cursor within a run of text that uses
the Geezah font, your application needs to set the keyboard script to Arabic. To do this,
use the

Font ToScript

set the keyboard.

function to

nd the script for the font, then use KeyScript to

In addition, your application can check the keyboard script (using the
Get ScriptManagerVariable function) in its main event loop; if the keyboard script
has changed, you can set the current font to the last-used font, application font, or system
font of the new keyboard script (determined by a call to the Get Script Variable
function). This action saves the user from having to set the font manually after changing
the keyboard script.
The system software performs the equivalent of calling KeyScript in response to the
user selecting a keyboard layout or input method from the Keyboard menu. It also does
the same when the user types Command Option Space bar (to select the next keyboard
layout or input method within the same script system), or Command Space bar (to select
the next script system in the Keyboard menu).

Using the Script Manager

6-17

CHAPTER

6

Script Manager

When you call KeyScript, you pass it a code parameter that can explicitly specify a
keyboard script by script code, or can implicitly specify a keyboard script, keyboard
layout, input method, or other setting. Values for code equal to or greater than zero are
interpreted as normal script codes. Several negative codes specify switching among
keyboard scripts, keyboard layout, or input methods. Others toggle line direction or
input method and are available only with certain script systems. Still others disable or
enable keyboard layouts or keyboard scripts. Table 6-5 lists the valid constants for the
code parameter.

Table 6-5

6-18

Constants for the code parameter in the KeyScript

Constant

Value

Expanation

(any script code)

OE 64

Switch to speci

procedure

ed script

smKeyNextScript

1

Switch to next script in Keyboard menu

smKeySysScript

2

Switch to the system script

smKeySwapScript

3

Switch to previously used script

smKeyNextKybd

4

Switch to next keyboard layout or input
method in Keyboard menu (within
current script)

smKeySwapkKybd

5

(not implemented)

smKeyDisableKybds

6

Disable keyboard layouts not in system
script or Roman script

smKeyEnableKybds

7

Enable keyboard layouts for all
enabled scripts

smKeyToggleInline

8

Toggle inline input for current script

smKeyToggleDirection

9

smKeyNext

InputMethod

10

(not implemented)

smKeySwapInputMethod

11

(not implemented)

smKeyDisableKybdSwitch

12

Disable switching out of current

smKeySetDirLeftRight

15

Set primary line direction to left-to-right
(available if bidirectional script present)

smKeySetDirRightLeft

16

Set primary line direction to right-to-left
(available if bidirectional script present)

smKeyRoman

17.

~— Set keyboard script to Roman (available only
if multiple scripts present)

Using the Script Manager

(available if 2-byte script present)

Toggle default line direction (available if

bidirectional script present)

keyboard layout

CHAPTER

6

Script Manager

The smKeyDisableKybds selector is available for your use, although it is primarily
used by the Finder or other parts of the system under special circumstances. For example,
when the user enters the name of a_le in a Standard-File dialog box, text input must be
restricted to scripts that display correctly in the Finder and in dialog boxes, menus, and
alert boxes. In that situation the system software calls KeyScript with the

smKeyDisableKybds selector to disable keyboard input temporarily in any script
system except Roman or the system script. Keyboards in other script systems then appear
disabled in the Keyboard menu. When the user completes the lename entry, the system
calls KeyScript

again with a selector of smKeyEnableKybds

input in all enabled script systems.

to reenable keyboard

The smKkeyDisableKybdSwitch selector is also available for your use, although it is
primarily used by the Finder. When keyboard layouts and script systems are being
moved into or out of the System le by the user, changing the current keyboard or
keyboard script may corrupt les or cause other unpredictable results. To prevent all
keyboard switching and to disable all the Keyboard menu items, the Finder calls
KeyScript with the selector smKeyDisableKybdSwitch. When the move has been
completed, the Finder again calls KeyScript with a selector of snmKeyEnableKybds to

reenable keyboard switching.

If you call KeyScript with code = smKeyRoman on a system in which only the

Roman script system is enabled, nothing happens. However, if you call KeyScript with
code = 0 (to select the Roman script system), it forces an update that selects the current
default Roman keyboard layout.
IMPORTANT

Although it is possible to change the keyboard script without changing
the keyboard layoutN by calling the Set ScriptManagerVariable
function with the smKeyScript

selectorN it violates the user interface

paradigm and creates problems for other script management routines. &

Synchronizing the Font Script and Keyboard Script
To keep the user from accidentally entering meaningless characters, you must always
keep the keyboard script synchronized with the font script, so that the glyphs displayed
on the screen match the characters entered at the keyboard. You can synchronize the
scripts in two ways: by setting the keyboard script when the font script changes, and by
setting the font script when the keyboard script changes.
Setting the Keyboard Script From the Font Script
Set the keyboard script from the font script when the user selects a new font or when the
user clicks in or selects text.
m

Ifthe user selects anew font from the Font menu, call Text Font to set the current font

m

Ifthe user clicks in or selects a text area, set the current font to be the font, size, and

to that font. Then set the keyboard script to the script system of that font.

style of the text where the click occurred. Then set the keyboard script to the script
system of that font.

Using the Script Manager

6-19

CHAPTER

6

Script Manager

Listing 6-4 is an example of code to use for setting the keyboard script from the font
script. Once you have obtained the script code value from the font family ID using the
Font ToScript function (see (Determining Script Codes From Font InformationO
beginning on page 6-21), you call the Get ScriptManagerVariable function with
the smKeyScript selector to determine the keyboard script. If the font script and
the keyboard script are not the same, call the KeyScript procedure to change the
keyboard script.
Listing 6-4
PROCEDURE

Setting the keyboard script from the font script
MySetKeyboardFromFont
(myFont:

Integer) ;

VAR

theFontScript:

Integer;

BEGIN

{get
theFontScript

:=

FontToScript

script

(myFont)

{compare
{ change
IF

code

from

with keyboard
if necessary}

script,

}

<>

theFontScript)
(theFontScript)

ID.}

;

(GetScriptManagerVariable(smKeyScript)
KeyScript

font

THEN

;

END;

Setting the Font Script From the Keyboard Script
Each time the user types a character other than a control character, your application
should check that the font script is still the same as the keyboard script. The user may
have, for example, switched keyboard scripts since entering the last character. If the font
script does not match the keyboard script, change the current font to correspond to the
new keyboard script before displaying the character. Follow these guidelines:
m If possible, set the current font to the previous font that was used for that script
(that is, the last font for that script preceding the current point in the document or
text buffer).
mw Otherwise, set the font to one of the preferred fonts for that script system. The
preferred fonts are the preferred application font, the preferred system font, the
preferred monospaced font, and the preferred small font. (The ID numbers of these
fonts can be obtained through the Get Script Variable function.)
Listing 6-5 is an example of setting the font (and therefore the font script) from the
keyboard script. It calls Get ScriptManagerVariable with the smKeyScript selector
to determine the current keyboard script. It then calls Font ToScript to determine
whether the keyboard script differs from the font script. If it does, the routine calls
GetScriptVariable with the smScriptAppFond selector to determine the

application font for the script. Then it sets the current font based on that result.

6-20

Using the Script Manager

CHAPTER

6

Script Manager

Listing 6-5
PROCEDURE

Setting the font (script) from the keyboard script
MySetFontFromKeyboard
(VAR

myFont:

Integer) ;

VAR

scriptNum:

LongInt;

BEGIN

scriptNum
IF

:=

GetScriptManagerVariable

(FontToScript
myFont

TextFont

:=

(myFont)

<>

scriptNum)

(smKeyScript)

;

THEN

GetScriptVariable(scriptNum,

smScriptAppFond) ;

(myFont )

END ;

You can also use this code if your application does not have an interface that lets users
change fonts but still needs to provide for different script systems.

Obtaining Information
The second principal use for the Script Manager is in obtaining script-speci c
information. Many of the routines described in this section are of general interest and are
used by most text applications. You can use these Script Manager routines to
m determine script codes for the current script system or any other available script
system, based on font information

m analyze characters in your text for size (in bytes) or other properties
m directly access the contents of a script system@ international resources, to pass that
information to other text-handling calls or to inspect or modify the information
Most text-processing applications need script-code information and character-type
information, and may need to pass speci c tables from international resources to some
script-aware text routines. If you format currencies, you need access to the
numeric-format resource. If you use special symbols or if you format numbers, you
need access to the untoken table and perhaps the number parts table of the tokens
resource. If your needs are more specialized, you can obtain the contents of other tables
and other resources.

Determining Script Codes From Font Information
The script management system asssociates a script system with a sequence of text by
examining the font of that text. Your application may also need the same informationN to
test for the presence of a particular script system, to load its resources, to pass its code as
a parameter to a script-aware routine, or to execute script-speci c conditional code. You
may need to determine what script system is currently active for displaying text, what
script system is being used to sort and format text, or what script system would be used
if text of a particular font were to be displayed or formatted. The Script Manager
provides three routines for that purpose: FontScript, FontToScript, and
IntlScript.

Using the Script Manager

6-21

CHAPTER

6

Script Manager

The Font Script function tells you which script system the font of the current graphics
port belongs to. The Font ToScript function tells you which (available) script system a
font of any ID number belongs to. The Int 1Script function tells you which script
system is used by the Text Utilities to determine the number, date, time, currency, and

sorting formats.
The

Font ToScript

function returns a script code for a speci

ed font family ID, but the

FontScript and IntlScript functions return the code for the current script, the

presently active script system for text manipulation. Many script-aware routines in
QuickDraw, Text Utilities, the Script Manager, and other parts of the Macintosh script
management system need not take an explicit script code or international resource
handle as a parameter; in that case they use the current script as the script system under
which they are to function.
The current script for text display is normally the font script. The current script for date
and time formatting and string sorting is by default the system script. However, the
settings of two BagsN the font force 8ag and the international resources selection SagN
can affect which script system is considered current at any one moment. Furthermore, if
the mapping from font to script results in a request for a script system that is not
available, the result defaults to the system script.
The next subsection lists the steps taken by Font Script, FontToScript, and
Int1Script to determine the script codes they return, and the following subsections
discuss the font force fag and the international resources selection Sag in more detail.
How a Script Code Is Determined
The

Font Script,

FontToScript,

and

IntlScript

functions all use a font family ID

to determine the script code they return. The formula they use is presented in the
discussion of resource ID numbers and script codes in the appendix Cinternational
ResourcesOin this book. Fonts with IDs below 16384 ($4000) are all Roman; starting with
16384 each non-Roman script system has a range of 512 ($200) font IDs available.
Nevertheless, you should always call the functions instead of hardcoding any formula,
because it may change in the future. Furthermore, the function results are infsuenced by
the states of the font force fag and the international resources selection Sag, and by the
availability of the determined script. Figure 6-1 shows the method the functions follow:
1. The three functions initialize two result Sags, the script-forced result flag and the

script-defaulted result flag, to FALSE. These Sags are Script Manager variables,
accessed through the
and smDefault.

Get ScriptManagerVariable function selectors smForced

2. The three functions map the two special font designations 0 and 1, meaning the system
and application fonts, to their true font family ID numbers.
3. FontScript and Int1Script calculate the script code from the font family ID of the
current font of the active port; Font ToScript calculates the script code from the
supplied font family ID. If the ID is in the range $4000 to $BFFF, it is a non-Roman
font; otherwise, it is Roman.

6-22

Using the Script Manager

CHAPTER

6

Script Manager

4. Once the initial determination of the script code has been made, the three functions
diverge:

O Ifthe font is Roman, FontScript and FontToScript examine the font force Gag,
which can be accessed through the

Get ScriptManagerVariable

function

selector smFont Force. If the Sag is TRUE, the two functions substitute the system
script for the font script, and set the script-forced result Sag to TRUE. If the font is
non-Roman, Font Script and FontToScript ignore the state of the font
force fag.
O Regardless of the font type (Roman or non-Roman), Int1Script examines the
international resources selection Sag, which can be accessed through the

GetScriptManagerVariable function selector smInt1Force. If the fsag is TRUE

and the font script does not equal the system script, Int 1Script substitutes the
system script for the font script and sets the script-forced result Sag to TRUE.
Figure 6-1

FontScript

Determining script code from font family ID

IntlSeript

FontToScript

JU

U

Ju

Map special fonts 0 and 1 to
their true font IDs

Map special fonts 0 and 1 to
their true font IDs

U

U

Get font’s
script code

Get font’s
script code

U
Roman font?

No
Ss:

ges

Yes

Font force flag
= TRUE?

Script enabled?

No

Script-forced = TRUE
Script-defaulted = FALSE

Script-forced = FALSE
Script-defaulted = TRUE

Script-forced = FALSE
Script-defaulted = FALSE
Vv
System script

Font script

Font script =
system script?

Yes

Script-forced = FALSE
Script-defaulted = TRUE

No

Script-forced = TRUE
Script-defaulted = FALSE
Script-forced = FALSE
Script-defaulted = FALSE

System script

Using the Script Manager

System script

Font script

Vv
System script

6-23

CHAPTER

6

Script Manager

5. A nal check is made to be sure that the resulting script is installed and enabled. If it is
not, the three functions substitute the system script for the script code previously
determined, set the script-forced result Sag to FALSE, and set the script-defaulted
result Sag to TRUE.
6. The functions return the resulting script code in their function results.
Call Font Script when you want to know which script system will be used for text
layout and display. The script code returned by Font Script tells you which script
system controls the functioning of such calls as CharToPixel, CharacterType,

FindWordBreaks, DrawText, and DrawJustified. Typically, FontScript returns
the script code for the font script; in most situations the font force fag is FALSE,
because applications usually expect to format and draw text according to the rules of the
font script.
Call Font ToScript when you want to know whether the script system for text of a
particular font is available, or when you wish to manipulate text of a certain script
system without setting the current font to that font@ ID.
Note

Because a user can set the value of the font force Sag from the Text

control panel, the result returned from the Font ToScript or
FontScript function for a font whose ID number is in the Roman range

can vary from call to call.

Call IntlScript when you want to know which script system will be used for
formatting dates and numbers, and for sorting strings. The script code returned by
IntlScript tells you which script system controls the functioning of such calls as
DateString, LongTimeString, and CompareText, when no explicit script code or

resource handle is supplied to those calls. In many localized versions of sysem software,
Int1lScript by default returns the script code for the system script, because the
international resources selection fSag is by default TRUE. The Finder and other parts of
system software usually expect to present dates, times, and lists of les according to the
rules of the system script.
Because the two fags are independent of each other, two different meanings for current
script can exist simultaneously. For example, your application might be sorting a set of
strings by one script@ rules, but displaying them by anotherG. If that is not appropriate,
set the fags as needed before formatting or drawing. See the following discussion.
Using the Font Force Flag

You access and control the font force Sag through the Get ScriptManagerVariable
and SetScriptManagerVariable

functions, with the selector smfontForce. This

Sag directly affects the results of the FontScript and FontToScript functions, and
indirectly affects the operation of script-aware text measuring and drawing routines.
At startup, the Script Manager sets the font force Sag to the value speci ed in the system
script@ international con guration ('it1lc') resource. Typically, that value is FALSE.

6-24

Using the Script Manager

CHAPTER

6

Script Manager

When the font force Sag is set to TRUE and the system script is non-Roman, the script
management system interprets font family ID numbers in the range of the Roman script
system ($0002 to $3FFF) as belonging to the system script instead. Character codes
representing non-Roman characters in the system script are drawn using the system font
instead of in the speci ed Roman font. This feature exists to allow users to enter and read
non-Roman text in those few applications that have hardcoded font numbers.
For example, an application may hardcode Geneva as its font; it may force the txFont
eld of its graphics ports to always have a value of 3. (Note that this is a violation of good
programming practice.) If the application is running on a system with Hebrew as the
system script, it would normally be impossible to write properly in Hebrew because the
hardcoded font ID would require the font script to be Roman. However, if the font force
ag is set to TRUE, the script management system notes that the current font has an ID
number in the Roman range and draws glyphs from the Hebrew system font for any
character codes that represent valid Hebrew characters.
Thus to enter or read non-Roman text in these applications, the user can set the font force
fag to TRUE from the Text control panel. Setting the font force fsag is only partially
effective, because it cannot give users full control over fonts. The user cannot choose, for
example, which font belonging to the system script is to be substituted for Roman.
The font force fsag has no effect on non-Roman fonts and has no effect if the system script
is Roman. It affects only Roman fonts when the system script is non-Roman.
You can determine the status of font forcing by inspecting the script-forced result fsag and
the script-defaulted result Sag immediately after calling FontScript or
FontToScript;

see Figure 6-1.

Although the font force Sag exists primarily to accommodate restrictions in certain
existing applications, it is a user-changeable setting that your application should be
aware of and accommodate. For example:
m If you are writing any application in which the user has control over fonts, you should
always set the font force Sag to FALSE. There is no need to force fonts if the user can
choose them.
m Ifthe user sets the font force Sag to TRUE, you will get the system script when you call
FontScript or FontToScript for fonts in the Roman range, even if your

application allows mixed text. To preserve Roman text, you can change the setting of
the font force Sag before calling Font Script or Font ToScript, or before calling
any other script-aware text routine. If you do that, be sure to save the previous value
and restore it when your application exits or becomes inactive.
Using the International Resources Selection Flag
You access and control the international resources selection Sag through the
GetScriptManagerVariable

and SetScriptManagerVariable

functions, with the

selector smInt 1Force. This Sag directly affects the results of the Int 1Script function,
and indirectly affects the operation of the Get Int lResource function and the
script-aware Text Utilities sorting and formatting routines.

Using the Script Manager

6-25

CHAPTER

6

Script Manager

At startup, the Script Manager sets the international resources selection Sag to the value
speci ed in the system script@ international con guration ('it1c') resource. Typically,

that value is TRUE.

The international resources selection Sag affects the results of the Get Int lResource
function (see page 6-90). Get Int lResource returns a handle to certain international
resources, and the state of the international resources selection fsag controls whether it is
the system script or the font script whose international resources are loaded. When the
Sag is set to TRUE, Get Int lResource fetches the resources for the system script. When
the Sag is set to FALSE, Get Int lResource uses the current font in the active port to

determine the script system whose resources will be fetched.

You can use the international resources selection Sag to make sure that date formats,
sorting, and so forth refSect the appropriate script in your application. Whenever you
change the setting of the international resources selection fsag, be sure to save the
previous value and restore it when your application exits or becomes inactive.

Analyzing Characters
The Script Manager provides routines that let you analyze the size and type of
individual characters. For example, with script systems that use 2-byte characters,
you may need to determine what part of a character a single byte represents. In either
1-byte or 2-byte script systems, you may need to know whether a particular character is
a letter or a punctuation mark, whether or not it is uppercase, or whether it is part of a
subscript (Roman within Cyrillic, Hiragana within Japanese, and so on).

Searching Text With Mixed Character Sizes
When searching for a single 1-byte character in text that may contain 2-byte characters,
your application must not mistake part of a 2-byte character for the character you are
seeking. The CharacterByteType

and FillParseTable

given character is 1-byte or whether it is the

functions tell you whether a

rst or second byte of a 2-byte character.

These functions use the fact that, in a 2-byte script system, only a restricted set of values
within the high-ASCI range are used as the rst bytes of 2-byte characters, and those
values are never used for 1-byte characters in that script system. All other byte values
represent single-byte characters, control characters, or the second bytes of 2-byte
characters. The ranges reserved for initial bytes of 2-byte characters vary from script
system to script system, but every font has a table that gives that information, and
CharacterByteType

and FillParseTable use those tables to perform their

calculations. For an illustration of this concept, see the discussion of character encoding
in the chapter Cintroduction to Text on the MacintoshOin this book.
Listing 6-6 shows a search procedure that accounts for 2-byte characters. This routine
uses the Text Utilities Munger function to nda match toa key string. Because Munger
might nda match beginning at the second byte of a 2-byte character, the routine checks
for this case (using the CharacterByteType function) and continues searching if

it occurs.

6-26

Using the Script Manager

CHAPTER

Script

6

Manager

The sample assumes

two application global variables:

gMainTextHandle, which is a

handle to the application@ text buffer, and gNewLocation, a long-integer offset into the

buffer at which to start searching. The parameters keyPtr and keySize specify the
string to be matched in the text buffer; scriptNum is an explicit script code. On return,
the routine updates gNewLocation to point to the location at which the search string
was found, or sets itto

Listing 6-6

1ifno match was found.

Handling 2-byte characters in a search procedure

PROCEDURE

MySearch

(keyPtr:

Ptr;

keySize:

LongInt;

scriptNum:

Integer) ;
VAR

byteType:

Integer;

BEGIN

HLock (gMainTextHandle)
REPEAT

;

{CharacterByteType

can

move

memory}

BEGIN

gNewLocation

:=

Munger

(gMainTextHandle,
keyPtr,

gNewLocation,

keySize,

NIL,

0);

{if we matched second byte of }
{ 2-byte char in text, continue}
IF

(gNewLocation
byteType

:=

>=

0)

AND

(scriptNum

CharacterByteType

>

0)

THEN

(gMainTextHandle”,

gNewLocation,

scriptNum)

ELSE

byteType
END

UNTIL

HUnlock

IF

:=

smSingleByte;

byteType

<>

(gMainTextHandle)

0)

smLastByte;

;

(gNewLocation

>=

(gNewLocation

+

keySize

AND

gNewLocation

:=

-1;

{range-check,
>

update

global}

GetHandleSize(gMainTextHandle) )

THEN

END;

The

Fill ParseTable

function is similar to CharacterByteType,

in that it helps you

nd 2-byte characters. However, you don@send FillParseTable the character code to

be analyzed. Instead, FillParseTable

Ils in an entire 256-byte table of information

for you, showing every byte value that is the rst byte of a 2-byte character for the
current font. You can use the table lIled out by FillParseTableto nd 2-byte
characters in a large body of text much more rapidly than you could by calling
CharacterByteType
for each byte value in the text.

Using the Script Manager

6-27

CHAPTER

6

Script Manager

Getting Character-Type Information
You may want to know more about a byte than whether it is part of a 2-byte character. If
you are simply searching for sequences of Roman text in a buffer, or if you wish to divide
a run of Japanese into Kanji, Katakana, Hiragana, and Romaji components, you can use
the FindScriptRun function described in the chapter (Text UtilitiesOin this book. But if
you have other reasons to isolate speci c types of characters, you can use
CharacterType.

The CharacterType function is similar to CharacterByteType, in that it tells you

what kind of character occurs at a given offset in a text buffer. But the kind of information
it returns is different. CharacterType tells you what the character@ line direction is,

whether it@ uppercase, whether it belongs to a subscript within its script, whether it@a
2-byte character, and what the character@ speci _c type and class areN letter or
punctuation, low-ASCII or high-ASCII Roman letter, Katakana or Hiragana, Jamo or
Hangul, and so on.

When you call the CharacterType function, you pass it a byte offset; it returns a
value that is an integer bit eld giving information about the character at that offset. See
Figure 6-2. The paragraphs following the gure describe the elds.
Figure 6-2

151413

Fields in the CharacterType

Lt | |

1211
|

8

7

4

class

return value

3

0
type

Size a
Case
Direction
Orientation

Bits 0 3 of the CharacterType function result describe the character type of the

character in question.

m The Roman script system recognizes three basic character types, de ned by the
following constants:

6-28

Character type

Hex. value

Explanation

smCharPunct

$0000

Punctuation (anything but a letter)

smCharAscii

$0001

ASCIT letter (not a number or symbol,

smCharExtAscii

$0007

High-ASCII Roman letter (not a number or

Using the Script Manager

character code <= $7F)

symbol, character code >= $80)

CHAPTER

6

Script Manager

m Additional character-type constants are provided for Japanese Katakana and
Hiragana; the ideographic subscripts such as Hanzi, Kanji, and Hanja; 2-byte Cyrillic
and Greek in 2-byte systems; bidirectional script systems such as Arabic and Hebrew;
and Korean Hangul and Jamo subscripts:
Character type

Hex. value

Explanation

smCharKatakana

$0002

Japanese Katakana

smCharHiragana

$0003

Japanese Hiragana

smCharIdeographic

$0004

Hanzi, Kanji, Hanja

smCharTwoByt eGreek

$0005

2-byte Greek in 2-byte scripts

smCharTwoByteRussian

$0006

2-byte Cyrillic in 2-byte scripts

smCharBidirect

$0008

Arabic, Hebrew

smCharContextualLR

$0009

Thai, Indic, etc.

smCharNonContextualLR

SOO0A

Cyrillic, Greek, etc.

smCharHangul

$000C

Korean Hangul

smCharJamo

$000D

Korean Jamo

smCharBopomofo

$000E

Chinese Bopomofo (Zhuyinfuhao)

Bits 8 11 of the CharacterType function result describe the character class of the

character in question. Character classes can be considered as subtypes of character types;
a given character type can have several classes that belong to it.
m Ifthe character type is smCharPunct, the following character classes are de ned that
include punctuation for both 1-byte and 2-byte script systems:
Character class

Hex. value

Explanation

smPunctNormal

$0000

Normal punctuation (such as ! , . ;?)

smPunctNumber

$0100

Number character (such as 0 9)

smPunctSymbol

$0200

Nonpunctuation symbol (such as # $ &)

smPunctBlank

$0300

Blank character (such as ASCII $00, $0D, $20)

smPunctRepeat

$0400

Repeat marker in 2-byte script

smPunctGraphic

$0500

Line graphics in 2-byte script

m Inthe Korean script system, if the character type is smCharJamo, the following
character classes are de ned. They determine whether a given byte contains a simple
or complex consonant or a simple or complex vowel:
Character class

Hex. value

Explanation

smJamoJaeum

$0000

Simple consonant character

smJamoBogJaeum

$0100

Complex consonant character

smJamoMoeum

$0200

Simple vowel character

smJamoBogMoeum

$0300

Complex vowel character

Using the Script Manager

6-29

CHAPTER

6

Script Manager

The Jamo and Hangul subscripts of Korean are discussed briefSy along with input
methods in the chapter Gntroduction to Text on the MacintoshOin this book.
In the Japanese script system, if the character type is smCharKatakana or
smCharHiragana, the following character classes are de

Character class

ned:

Hex. value

Explanation

$0000

(none of the following de ned classes)

smKanaSmall

$0001

Small Kana character

smKanaHardOK

$0002

Can have dakuten

smKanaSoftOK

$0003

Can have dakuten or han-dakuten

A small Kana character is a special form of Kana used to modify the pronunciation of a
previous (full-sized) Kana character. Dakuten and han-dakuten are pronunciation
marks that soften consonant sounds in Kana.
In 2-byte script systems, if the character type is smCharIdeographic, the following
character classes are de ned:
Character class

Hex. value

Explanation

smIdeographicLevell

$0000

Level 1 characters

smIdeographicLevel2

$0100

Level 2 characters

smIdeographicUser

$0200

User characters

The characters speci ed by the smIdeographicLevel1
constant are part of the
level 1 Han character set speci ed by Japanese, Chinese, and Korean government
standards. Approximately 90 percent of normal text consists of characters from the
level 1 set.
The characters speci

ed by the smIdeographicLevel2 constant are part of the

level 2 Han character set, which includes obscure characters. The level 1 and level 2

character sets combined contain 98 percent of the character set used in the Kanji
subscript.
The characters speci
created by the user.

ed by smIdeographicUser represent custom characters

Bits 12 15 of the CharacterType function result are the character modifiers of the

character in question. One bit describes each modi
m

Bit 12 speci

er.

es the orientation of the character: whether it is intended for horizontal or

vertical writing.

6-30

Character orientation

Hex. value

Explanation

smCharHorizontal

$0000

Character form is for horizontal writing, or
for both horizontal and vertical

smCharVertical

$1000

Character form is for vertical writing only

Using the Script Manager

CHAPTER

6

Script Manager

m Bit 13 speci es the direction of the character: whether its line direction is left-to-right or
right-to-left.
Character direction

Hex. value

Explanation

smCharLeft

$0000

Character with left-to-right line direction

smCharRight

$2000

Character with right-to-left line direction

m Bit 14 speci

es the case of the character: whether it is lowercase or uppercase.

Character case

Hex. value

Explanation

smCharLower

$0000

Lowercase character

smCharUpper

$4000

Uppercase character

m Bit 15 speci

es the size of the character: whether it is 1 or 2 bytes long.

Character size

Hex. value

Explanation

smCharlbyte

$0000

1-byte character

smChar2byte

$8000

2-byte character

You can describe individual characters with combinations of these constants. For

example, if the byte being examined by CharacterType is a 1-byte English uppercase
OCAQO then the value of the result could be expressed as smCharlByte + smCharUpper +

smCharLeft + smCharASCII. CharacterType indicates blank characters by a type
smCharPunct and a class smCharBlank.

Some values are meaningful only in certain subscripts or script systems. The value
smCharUpper is meaningless in a subscript that has no uppercase characters, for
example; the value smIdeographicLevel is meaningless in 1-byte script systems.
You can use CharacterType for a variety of purposesN to validate input in numeric
elds, to Iter non-phonetic characters in an input method, or to search for punctuation,
uppercase letters, and symbols. If you are breaking lines of text and are not using the Text
Utilities StyledLineBreak function, you can use CharacterType to locate and skip

whitespace characters at the ends of lines; see the description of text drawing in the
chapter QQuickDraw TextOin this book.
The CharacterType function is described further on page 6-85.

Directly Accessing International Resources
This section shows how you can directly access the international resources of a script
system. Such direct access can help you be more ef cient in creating bilingual
applications, formatting numbers in different scripts, accessing character information,
and using tokens. Several script-aware Text Utilities calls can take a handle to an
international resource as an input parameter; you can use the calls in this section to
obtain those handles.

Using the Script Manager

6-31

CHAPTER

6

Script Manager

Your application can examine the international resources that determine numeric
formats, date formats, string sorting, conversion to tokens, and character encoding or

rendering by making the calls described here. You can also retrieve individual tables from
some of the resources.
This access also helps you to provide your own versions or regional variations of certain
international resources. See CReplacing a Script System@ Default International
ResourcesObeginning on page 6-48 for more information.
Note
Although you can access the international resources independently
through the Resource Manager function Get Resource and related calls,
you can be sure to get the preferred resource of the current script system
by using the calls described here. @
The calls you make to access the international resources are
ClearIntlResourceCache,

GetIntlResource,

and GetIntlResourceTable.

With them, you have access to the contents of a script system@ numeric-format ('it10'),
long-date-format ('it11'), string-manipulation ('1t12'), tokens ('it14'), and
encoding /rendering ('it15') resources.
To access one of these resources for the current script, follow these steps:

1. Make sure the current script is the script system containing the international resource
you want to access. See (Determining Script Codes From Font InformationOon
page 6-21. You may need to verify the settingsof the font script, the system script, and
the international resources selection Sag. See Using the International Resources
Selection FlagOon page 6-25.
2. If you need access to any version of the current script@ string-manipulation or tokens
resources other than its default version, call ClearIntlResourceCache

(Replacing a Script System@ Default International ResourcesOon page 6-48.

rst. See

3. Call Get Int lResource, specifying the type of resource you need.
Get Int 1Resource returns a handle to the resource.
For an example of using Get Int lResource to extract information from an international
resource, see the next section, QU sing Currency, Number,

To access a speci
these steps:

and Date Formats.O

c table within a string-manipulation or tokens resource, follow

1. If you don@already have it, determine the script code of the script system containing
the international resource you want to access. See (Determining Script Codes From
Font InformationOon page 6-21.
2. If you need access to any other than the script@ default version of that resource, call
ClearIntlResourceCache
rst. See Replacing a Script System@ Default
International ResourcesOon page 6-48.

6-32

Using the Script Manager

CHAPTER

6

Script Manager

3. Call Get Int lResourceTabl1e to get the speci ed table within the speci ed resource
belonging to the speci ed script system. Depending on the resource, you can get its
number-parts, untoken, word-selection, line-break, or whitespace table.

For more information about these tables, see the following sections: CUsing Number
Parts,OCRetrieving Text From Tokens,O@Using Word-Break Tables,Oand QUsing
Whitespace Information.O
IMPORTANT

Any time you replace the default international resources for a script
system, whether or not you subsequently call Get Int lResource or

Get Int 1ResourceTable, you need to call
ClearInt1lResourceCache, to make sure that the replacements are

used by all script-aware calls. See (Replacing a Script System@ Default
International ResourcesObeginning on page 6-48. A

Using Currency, Number, and Date Formats
In general, you should use the Text Utilities routines for date, time, and number
formatting. See the chapter (ext UtilitiesOin this book. If, however, you need to directly
access elds in the numeric-format ('it10') and long-date-format ('it11') resources
to nd the characters, separators, strings, and orders for formatting numbers, dates, and

times, you can do so with Get Int l1Resource.

Listing 6-7 shows how to determine the decimal, thousands, and list separators for

number formatting in the current script. To access the numeric-format resource, the
routine speci es a resource selector of 0 (for '1t10') in the parameter theID of the
GetInt1lResource function. It then extracts the values it wants from the decimalPt,
thousSep,and listSep
elds.

Listing 6-7
PROCEDURE

Determining the number separators for the current script
MyGetNumberSeparators

(VAR

myDecimal:Char;

VAR

myThousands:

VAR

myListSep:Char) ;

Char;

VAR

myHandle:

IntloHndl ;

{make sure the desired script is
{ before calling this routine}

set

}

BEGIN

myHandle
myDecimal

:=

Intl0Hndl(GetIntlResource(0));{Get
:=

'itl0'

resource}

myHandle**.decimalPt;

{for

example,

1.234}

myThousands := myHandle**.thousSep;
myListSep := myHandle**.listSep;

{for
{for

example,
example,

1,234,567}
1;2;3}

END ;

Using the Script Manager

6-33

CHAPTER

6

Script Manager

IMPORTANT

Do not assume that the components of dates and times are always
ordered in a left-to-right direction when displayed. If you are drawing
individual time components, be careful not to simply draw them from

left to right in all cases. For instance, the AM/PM characters in an
English time string are on the right, whereas in an Arabic time string the

equivalent characters may be on the left or right, depending on the
primary line directionN even though in both cases these characters are at
the end of the time string in memory. &

Using Number Parts
You can access information on how separators and other parts of formatted numbers are
represented in a particular script system by examining the number parts table in the
script@ tokens ('it14') resource. Unlike the numeric-format resource, the number parts

table supports 2-byte characters; it also contains more information, especially for
complicated number formats such as scienti c notation.

Your most common reason for obtaining the number parts table may be to pass it as a
parameter to the Text Utilities functions StringToFormatRec,

FormatRecToString,

StringToExt ended, and ExtendedToString. But you can also examine its contents.
Listing 6-8 shows how to call the Get Int lResourceTable procedure, with a table
selector of snNumberPartsTab1e, to obtain the number parts table associated with a

given script. The routine obtains the character associated with the number part speci

ed

by thePart and saves it as a wide character, which is a character of either 1 or 2 bytes.

(See the discussion of the tokens resource in the appendix Onternational ResourcesOfor a
de nition of the WideChar data type.) To specify the system script, the parameter
theScript would have the value smSystemScript. The parameter thePart can have

such values as tokDecPoint and tokThousands. For a complete list of number-parts
constants, see the description of the tokens resource in the appendix Onternational
ResourcesOin this book.
Listing 6-8
PROCEDURE

Getting number parts from a script system’s number parts table
MyMapNumPartToWideChar(theScript:
thePart:

VAR
VAR
itlHandle:

numpartsOffset:

Longint;

numpartsLength:

LongInt;

numpartsPtr:

6-34

Handle;

NumberPartsPtr;

Using the Script Manager

ScriptCode;
Integer;

theWChar:

WideChar) ;

CHAPTER

6

Script Manager

BEGIN

GetIntlResourceTable(theScript,
itlHandle,

smNumberPartsTable,
numpartsOffset,

=

thewWChar.b

:=

THEN

0

BEGIN

_a

ELSE

NIL

oa

itlHandle

a

IF

ere

numpartsLength) ;

numpartsPtr

:=

handle errors,
}
return null WideChar}
make numpartsPtr point to }
beginning of number parts table}

NumberPartsPtr(LongInt

(itlHandle*)

+

numpartsOffset) ;

IF

thePart

>

tokMaxSymbols

theWChar.b
ELSE

:=

0

THEN

{invalid

number

{ handle
{ return

error, }
null WideChar}

part--

}

BEGIN

theWChar

:=

numpartsPtr*.data[thePart] ;

END ;
END ;
END ;

Retrieving Text From Tokens
Tokens are abstract entities that stand for classes of text items such as alphanumeric
strings, various symbols, and quoted literals. The Script Manager Int lTokenize
function converts programming-language text into script-independent tokens useful to
compilers or interpreters. See (okenizationOon page 6-38. The untoken table in a script
system@ tokens (' it 14') resource has the opposite purpose; it helps you convert
script-independent tokens into the text of a given script system.
The untoken table lists the characters associated with each
de

xed (invariant) token

ned by that script. (An invariant token is one that, like tokenColon, represents a

unique symbol. Other types of tokens, like tokenAlpha, represent an arbitrary
sequence of characters.) If you need to nd out, for example, how a given script system
represents the ess than or equal toOsymbol (is it the 1-byte character XO a 2-byte
encoding of the character <Q the 2-byte, 2-character sequence (x=Q or something else
altogether?), you can look up the values of tokenLessEquali1 and tokenLessEqual2
in that script@ untoken table.
The untoken table is most useful for obtaining script-speci c forms for individual
common symbols, such as the ellipsis or center dot. If you truncate strings with the
ellipsis character (E ) or use the center dot (¥) such as AppleShare does for echoing

passwords, don@®hardcode their character codes; they may not be valid in some script
systems. Instead, specify tokenEllipsis or tokenCenterDot, and use the untoken
table of the current script system to obtain the proper text for those tokens.

Using the Script Manager

6-35

CHAPTER

Script

6

Manager

Note
If a script system has no de ned character or string that corresponds to a

particular token, the untoken table contains either a null string or the

string @?Ofor that token.

You access the untoken table by calling the Get Int lResourceTable procedure with a
table selector of smNumberPartsTablLe.
Listing 6-9 provides an example of how to
access the untoken table in the tokens resource. This code sample extracts the canonical
string associated with a token. It sets the parameter theSt ring to the string that
corresponds to the token theToken. (Usually, this string is 4 bytes or less.) To specify the
system script, the parameter theScript would have the value smSystemScript. The
parameter

theToken

can have

such

values as tokenNoBreakSpace,
tokenEllipsis,

and tokenCenterDot.
For a complete list of de ned constants for tokens, see (foken
CodesObeginning on page 6-58.
Listing 6-9
PROCEDURE
Integer;

Getting a token string from the untoken table
MyMapTokenToString(theScript:
VAR

theString:

ScriptCode;

theToken:

Str255) ;

VAR

itlHandle:

Handle;

untokenOffset:

LongtInt;

untokenLength:

LongInt ;

untokenPtr:

UntokenTablePtr;

untokenStringPtr:

StringPtr;

BEGIN

GetIntlResourceTable(theScript,

smUnTokenTable,

untokenOffset,

IF

itlHandle

= NIL

theString

:=

ELSE

THEN

{handle

untokenLength) ;

errors,

return

null

untokenPtr

point

to

string}

'!

BEGIN

untokenPtr

itlHandle,

{make

the

}

{ beginning of the untoken table}
:= UntokenTablePtr(LongInt (itlHandle*) +
untokenOffset) ;

IF

theToken

theString
ELSE BEGIN

> untokenPtr*.lastToken
:=

untokenStringPtr

6-36

Using the Script Manager

{this token is }
{ not in table-- }
{ return null string}
{index[theToken]
is the offset }
{ of the desired string from the }
{ beginning of the untoken table}

''!

:=

THEN

StringPtr(LongInt

(untokenPtr)

+

CHAPTER

6

Script Manager

untokenPtr~*.
index [theToken] ) ;
theString

:=

untokenStringPtr“%;

END ;
END ;
END ;

Even though using the untoken table is conceptually the converse of calling the
Int1Tokenize function, their purposes are different. Int lTokenize is used asa_ rst
step toward compiling or interpreting programming-language source text, and its results
are rarely returned or reconverted to source text. The untoken table is most commonly
used to supply localized text for individual common tokens.

Using Word-Break Tables
If you use the Text Utilities FindWordBreaks procedure to determine the boundaries of
a word, you normally do not need to pass it an explicit pointer to a word-break table.
However, if you want to use a custom word-break table you can pass FindWordBreaks
a pointer to that table. Word-break tables are in a script system@ string-manipulation
('it12') resource; you can gain access to them by calling the Get Int lResourceTable
procedure with a table selector of snWordSelectTable or smWordWrapTable.
There are two possible table selectors because a script system may have different word
breaks for word selection than it does for line breaking. If you are using
FindWordBreaks to select an individual word, use smWordSelectTable when you

call

Get Int LResourceTabl1le to obtain the word-break table. If you are using

FindWordBreaks to nd line breaks, use smnWordWrapTable when you call
GetInt1lResourceTable.

Using Whitespace Information
Most applications that need whitespace information, such as when eliminating extra
spaces in text or searching for non-space characters, can get it by calling the
CharacterType function. However, if your application needs a listing of all valid
whitespace characters in a script system, you can call Get Int lLResourceTable witha
table selector of smWhiteSpaceList. GetIntlResourceTable returns the whitespace
table from the script system@ tokens resource.

Converting Text
The third principal use for the Script Manager is in converting text from one form to
another, for two speci _c purposes: tokenization and transliteration. The routines
described in this section are used by specialized applications only. You can use these
Script Manager routines to

Using the Script Manager

6-37

CHAPTER

6

Script Manager

m lexically convert text of the current script system into a series of language-independent
tokens (tokenization)
m phonetically convert text of one subscript into text of another subscript within the
same script system (transliteration)
Most text-processing applications have no need to perform either of these tasks.
However, if your program needs to evaluate programming statements or logical or
mathematical expressions in a script-independent fashion, you may want to use the
Script Manager@ tokenization facility. If your program performs phonetic conversion, for
text input or for any other purpose, you may want to use the Script Manager@

transliteration facility.
Tokenization

Programs that parse structured text expressions (such as compilers, assemblers, and
scripting-language interpreters) usually assign sequences of characters to categories
called tokens. Tokens are abstract entities that stand for names, operators, and quoted
literals without making assumptions that depend on a particular writing system.
The Script Manager provides support for this conversion, called tokenization. Each
script system@ international tokens resource (type 'it14') contains tables of token
information used by the Script Manager@ Int 1Tokenize function to identify the
elements in an arbitrary string of text and convert them to tokens. The token stream
created by Int 1Tokenize can be used as input to a compiler or interpreter, or to an
expression evaluator such as might be used by a spreadsheet or database program.
The Int 1Tokenize function allows your application to create a common set of tokens
from text in any script system. For example, a whitespace character might have different
character-code representations in different script systems. The Int l1Tokenize function
can assign the token tokenWhite to any whitespace character, thus removing
dependence on any character-encoding scheme.
When you call IntlTokenize, you pass it the source text to interpret. Int lTokenize
parses the text and returns a list of the tokens that make up the text. Among the token
types that it recognizes are whitespace characters; newline or return characters;
sequences of alphabetic, numeric, and decimal characters; the end of a stream of
characters; unknown characters; alternate digits and decimals; and many
xed token

symbols, such as open parentheses, plus and minus signs, commas, and periods. See
page 6-58 for a complete list of recognized tokens and their de ned constants.

Int1Tokenize can return not only a list of the token types found in your text but also a
normalized copy of the text of each of the tokens, so that the content of your source text is
preserved along with the tokens generated from it.
Figure 6-3 illustrates the process that occurs when Int1Tokenize converts text into a
sequence of tokens. It shows that very different text from two separate script systems can
result in the same set of tokens.

6-38

Using the Script Manager

CHAPTER

6

script Manager

Figure 6-3

The action of IntlTokenize

Macro Text

SH ==A(BSIZ HN) 3s //7ely |

total3=sum (A3 :B9) ;{yearly totals}
Tokens
('atl4')

resource

resource
Ww

Tokens
('atl4')

IntlTokenize

<

y

Tokens

(Internal representation)
tokenAlpha
tokenEqual
tokenAlpha
tokenLeftParen

tokenAlpha
tokenColon

tokenAlpha
tokenRightParen
tokenSemicolon
tokenLefttComment
tokenLiteral

tokenRightComment

Because it uses the tokens resource belonging to the script system of the text being
analyzed, Int1Tokenize works on only one script run at a time. However, one way to
process multiscript text is to make successive calls to Int lTokenize and append the
results of each to the token list, thus building a single token stream from multiple calls.
Note

The Int1Tokenize function does not provide complete lexical analysis;
it returns a simple, sequential list of tokens. If necessary, your application
can then process the output of Int 1Tokenize at a more sophisticated
lexical or syntactic level. @
The rest of this section introduces the data structures used by Int 1Tokenize, discusses
speci c features and how it handles speci c types of text, and gives an example.

Using the Script Manager

6-39

CHAPTER

6

Script Manager

Data Structures

When you call IntlTokenize, you supply it with a pointer to a token block record,
a data structure that you have allocated. The token block record has a pointer to your
source text and pointers to two other buffers you have allocatedN one to hold the list
of token records that Int 1Tokenize generates and the other to hold the string
representations of those tokens, if you choose to have strings generated. See Figure 6-4.
IntlTokenize

lls in the token list and the string list, updates information in the token

block record, and returns the information to you.

Figure 6-4

Int1Tokenize data structures (simplified)

=

(=>

IntlTokenize

Ca)

||
Source text

Token block
{I

ptr to source text
ptr to token list

Vv
| |

Token list

<y
;

ptr to token strings

—

Tok

ri

oken strings
string 1
string 2
string 3

6-40

[_]

Pointers

[_]

Information flow

Using the Script Manager

TokenRec

1

TokenRec

2

TokenRec

3

CHAPTER

6

Script Manager

Delimiters for Literals and Comments

Your application may specify up to two pairs of delimiters each for quoted literals
and for comments. Quoted literal delimiters consist of a single symbol, and comment
delimiters may be either one or two symbols (including the newline character for
notations whose comments automatically terminate at the end of a line). Each
delimiter is represented by a token, as is the entire literal between the opening and
closing delimitersN except when the literal contains an escape character; see CEscape
CharacterO(next).
Limited support exists for nested comments. Comments may be nested if so speci ed
by the doNest fsag, with one restriction that must be strictly observed to prevent
Int1Tokenize from malfunctioning: nesting is legal only if both the left and
right delimiters for the comment token are composed of two symbols each. If your
application speci es two different sets of comment delimiters, then the doNest Sag
always applies to both.
IMPORTANT

When using nested comments speci ed by the doNest fag,
test thoroughly to ensure that the requirements of
Int1Tokenize are met.

A

Escape Character
The characters that compose literals within quotations and comments are normally
de ned to have no syntactic signi cance; however, the escape character within a quoted
literal signals that the following character should not be treated as the closing delimiter.
Outside of the limits of a quoted literal, the escape character has no signi cance and is
not recognized as an escape character.
For example, if the backslash O\O(token type = tokenBackSlash) is de ned as the
escape character, the Int 1Tokenize function would consider it to be an escape
character in the following string, and would not consider the second quotation mark to
be a closing delimiter:
"This

igs

a

quote

\"

within

a

quoted

literal"

In the following string, however, Int 1Tokenize would not consider the backslash to be
an escape character, and therefore would consider the rst quotation mark to be an
opening delimiter:
This

is

a

backslash

Using the Script Manager

\"

preceding

a

quoted

literal"

6-41

CHAPTER

6

Script Manager

Alphanumeric Tokens
The Int 1Tokenize function allows you to specify that numeric characters do not have
to be considered numbers when mixed with alphabetic characters. If a Sag is set,
alphabetic sequences may include digits, as long as_ rst character is alphabetic. In that
case the sequence Highway61 would be converted to a single alphabetic token, instead
of the alphabetic token Highway followed by the number 61.
Alternate Numerals

Some script systems have not only Western digits (that is, the standard ASCII digits, the
numerals 0 through 9), but also their own numeral codes. Int 1Tokeni ze recognizes
these alternate numerals and constructs tokens from them, such as tokenAltNum and
tokenAltReal.

String Generation
To preserve the content of your source text as well as the tokens generated from it, your
application may instruct Int1Tokenize to generate null-terminated,
even-byte-boundaried Pascal strings corresponding to each token. Int 1Tokenize
constructs the strings according to these rules:
m If the token is anything but alphabetic or numeric,
the token verbatim into the Pascal string.

Int 1Tokenize copies the text of

m If the token represents non-Roman alphanumeric characters, Int 1Tokenize copies
the characters verbatim into the Pascal string.
m If the token represents Roman alphabetic characters, Int lTokenize normalizes them
to standard ASCII characters (such as by changing 2-byte Roman to 1-byte Roman)
and writes them into the Pascal string.
m If the token represents numeric charactersN even if the script system uses an alternate
set of digitsN Int lTokenize normalizes them into standard ASCII numerical digits,
with a period as the decimal separator, and creates a string from the result. This allows
users of other script systems to transparently use their own numerals or Roman
characters for numbers or keywords.
The tokens resource includes a string-copy routine that performs the necessary string
normalization.
Appending Results
You can make a series of calls to Int 1Tokenize and append the results of each call to
the results of previous calls. You can instruct Int 1Tokenize to use the output values for
certain parameters from each call as input values to the next call. At the end of your
sequence of calls you will haveN in orderN all the tokens and strings generated from the
calls to Int 1Tokenize.

6-42

Using the Script Manager

CHAPTER

6

Script Manager

Appending results is the only way to use Int 1Tokenize to parse a body of text that has
been written in two or more different script systems. Because Int 1Tokenize can
operate only on a single script run at a time, you must rst divide your text into script
runs and pass each script@ character stream separately to Int 1Tokenize.
Example

Here is an example of how the Int 1Tokenize function breaks text into segments that
that can be processed in a way that is meaningful in a particular script system. The source
text is identical to that shown in Figure 6-3 on page 6-39. Assume that you send this
programming-language statement to Int 1Tokenize:

total3=sum(A3:B9); {yearly

totals}

Int1lTokenize might convert that into the following sequence of tokens and
token strings:
Token

Token string

tokenAlpha

'total3'!

tokenEqual

‘=!

tokenAlpha

‘sum'

tokenLeftParen

rs

tokenAlpha

'A3!

tokenColon

rs)

tokenAlpha

'B9!

tokenRightParen

ry)

tokenSemicolon

rt

tokenLeftComment

rt!

tokenLiteral

'yearly

tokenRightComment

rhe

totals!

This token sequence could then be processed meaningfully by an expression evaluator. If
the statement had been created under a different script system, in which comment
delimiters, semicolons, or equality were represented with different character codes, the
resulting token sequence would still be the same and could be evaluated identicallyN
although the strings generated from the tokens would be different.
The Int 1Tokenize function is described further on page 6-92.
Transliteration
The Script Manager provides support for transliteration, the automatic conversion of text
from one form to another within a single script system. In the Roman script system,
transliteration simply means case conversion. In Japanese, Chinese, and Korean script

systems, it means the phonetic conversion of characters from one subscript to another.

Using the Script Manager

6-43

CHAPTER

6

Script Manager

The TransliterateText function performs the conversions. Tables that control
transliteration for a 1-byte script system are in its international string-manipulation
('it12') resource; the tables for a 2-byte script system are in the script@ transliteration
('trs1') resource. This illustrates the difference in the meaning of transliteration for the

two types of script systems: case conversion information is in the string-manipulation

resource, whereas information needed for phonetic conversion is in the transliteration

resource. The transliteration resource is available to all script systems, although currently
no 1-byte script systems make use of it.
Transliteration here does not mean translation; the Macintosh script management system
cannot translate text from one language to another. Nor does it include context-sensitive
conversion from one subscript to another; that can be accomplished with an input
method. See, for example, the discussions of input methods in the chapters Gntroduction
to Text on the MacintoshOand Cfext Services ManagerOin this book. Transliteration can,
however, be an initial step for those more complex conversions:

m Within the Japanese script system, you can transliterate from Hiragana to Romaji
(Roman) and from Romaji to Katakana, and vice versa. You cannot transliterate from
Hiragana to Kanji (Chinese characters). However, transliteration from Romaji to
Katakana or Hiragana could be an initial step for an input method that would
complete the context-sensitive conversion to Kanji.
m Within the (traditional) Chinese script system, you can transliterate from the
Bopomofo or Zhuyinfuhao (phonetic) subscript to Roman, and vice versa. You cannot

transliterate from Zhuyinfuhao to Hanzi (Chinese characters). However, transliteration

from Zhuyinfuhao to Pinyin could be an initial step for an input method that would
complete the context-sensitive conversion to Hanzi.

m Within the Korean script system, you can transliterate from Roman to Jamo, from Jamo
to Hangul, from Hangul to Jamo, and from Jamo to Roman. It is therefore possible to
transliterate from Hangul to Roman and from Roman to Hangul by a two-step process.
It is not possible to transliterate from Hangul into Hanja (Chinese characters).
Transliteration from Jamo to Hangul is used by the input method supplied with the
Korean script system; that transliteration is suf cient when Hanja characters are not
used. To include Hanja characters requires additional context-sensitive processing by
the input method.
The Script Manager de nes two basic types of transliteration you can perform:
conversion to Roman characters, and conversion to a native subscript within the same

non-Roman script system. Within those categories there are subtypes. For instance, in
Roman text, case conversion can be either to uppercase or to lowercase; in Japanese text,
native conversion can be to Romaji, Hiragana, or Katakana.

You can specify which types of text can undergo conversion. For example, in Japanese
text you can, if you want to, limit transliteration to Hiragana characters only. Or you can
restrict it to case conversion of Roman characters only.

6-44

Using the Script Manager

CHAPTER

6

Script Manager

Not all combinations of transliteration are possible, of course. Case conversion cannot
take place in scripts or subscripts that do not have case; transliteration from one subscript
to another cannot take place in scripts that do not have subscripts.
Transliteration is not perfect. Typically, it gives a unique result within a 2-byte script,
although it may not always be the most phonetic or natural result. Transliterations may
be incorrect in ambiguous situations; by analogy, in certain transliterations from English
QhOcould refer to the sound in the, the sound in thick, or the sounds in boathouse.

Figure 6-5 shows some of the possible effects of transliteration. Each string on the right
side of the gure is the transliterated result of its equivalent string on the left.
m= Roman characters can be transposed from uppercase to lowercase and vice versaN
even if they are embedded in text that also contains Kanji.
mw One-byte Roman characters can be converted to 2-byte Roman characters. (The glyphs
for 2-byte Roman characters are typically larger and spaced farther apart, for better
appearance when interspersed with ideographic glyphs.)
m Katakana can be converted to Hiragana.
m Hiragana can be converted to 1-byte Roman characters.
Figure 6-5

The effects of transliteration

to uppercase
TO LOWERCASE
Mixed #24

romaji
=KY
(ZIKAv

TO UPPERCASE
to lowercase
MIXED i+

romaji.
(CWEAY
nihonn

* 1-byte Romaji converted to 2-byte Romaji

When you call TransliterateText, you specify a source mask, a target format, and a
target modifier. The source mask speci es which subscript or subscripts represented in
the source text should be converted to the target format. The target modi er provides
additional formatting instructions. For example, in Japanese text that contains Roman,
Hiragana, Katakana, and Kanji characters, you could use the source mask to limit

transliteration to Hiragana characters only. You could then use the target format to
specify conversion to Roman, and you could use the target modi er to further specify
that the converted text become uppercase.

Using the Script Manager

6-45

CHAPTER

6

Script Manager

For all script systems, there are three currently de ned values for source mask, with the
following assigned constants:
Source mask constant

Value

Explanation

smMaskAscil

1

Convert from Roman text

smMaskNative

2

Convert from text native to current script

smMaskAl11

1

Convert from all text

To specify that you want to convert only Roman characters, use smMaskAscii. To
convert only native characters, use smMaskNat ive. Use the smMaskA11 constant to
specify that you want to transliterate all text. (Roman textOis de ned as any Roman
characters in the character set of a given script system. In most cases, this means the
low-ASCII Roman characters, butN depending on the script systemN it may also include
certain characters in the high-ASCII range whose codes are not used for the script
system@ native character set, and it may include 2-byte Roman characters in 2-byte script
systems. The de nition of Chative textOis also script-dependent.
The 2-byte script systems recognize the following additional values for source mask:
Source mask constant

Hex. value

Explanation

smMaskAsciil

$04

Convert from 1-byte Roman text

smMaskAscii2

$08

Convert from 2-byte Roman text

smMaskKanal

$10

Convert from 1-byte Katakana text

smMaskKana2

$20

Convert from 2-byte Katakana text

smMaskGana2

$80

Convert from 2-byte Hiragana text

smMaskHangul2

$100

Convert from 2-byte Hangul text

smMaskJamo2

$200

Convert from 2-byte Jamo text

$400

Convert from 2-byte Zhuyinfuhao text

All 2-byte scripts:

Japanese:

Korean:

Chinese:

smMaskBopomofo2

The low-order byte of the target parameter is the format; it determines what form the

text should be transliterated to. For all script systems, there are two currently supported
values for target format, with the following assigned constants:

6-46

Target format constant

Hex. value

Explanation

smTransAscii

$00

Convert to Roman

smTransNative

$01

Convert to a subscript native to current script

smTransCase

$FE

Convert case for all text (obsolete)

smTransSystem

$FF

Convert to system script (obsolete)

Using the Script Manager

CHAPTER

6

Script Manager

The 2-byte script systems recognize the following additional values for target format:
Target format constant

Value

Explanation

All 2-byte scripts:

smTransASCII1

2

Convert to 1-byte Roman text

smTransASCII2

3

Convert to 2-byte Roman text

smTransKanal

4

Convert to 1-byte Katakana text

smTransKana2

5

Convert to 2-byte Katakana text

smTransGana2

7

Convert to 2-byte Hiragana text

smTransHangul2

8

Convert to 2-byte Hangul text

smTransJamo2

9

Convert to 2-byte Jamo text

10

Convert to 2-byte Zhuyinfuhao text

Japanese:

Korean:

Chinese:

smTransBopomofo2

The high-order byte of the target parameter is the target modi er; it provides
additional formatting instructions. All script systems recognize these values for target
modi er, with the following assigned constants:
Target modifier constant

Hex. value

Explanation

smTransLower

$4000

Target becomes lowercase

smTransUpper

$8000

Target becomes uppercase

For example, for TransliterateText to convert all the characters in a block of text to
1-byte Roman uppercase, the value of srcMask is smMaskA11 and the target value is
smTransAsciil+smTransUpper. To convert only those characters that are already
(1-byte or 2-byte) Roman, the value of srcMask is smMaskAsciil+smMaskAscii2.
The TransliterateText function is described further on page 6-98.
Note
For uppercasing or lowercasing Roman text in general, use
UppercaseText

or LowercaseText. Because the performance of

TransliterateText is slower, you may rarely want to use its
case-changing capabilities in Roman text.

Using the Script Manager

6-47

CHAPTER

6

Script Manager

Modifying Script Systems
The fourth principal use for the Script Manager is in modifying the contents of script
systems themselves. The routines described in this section are for specialized purposes,
such as providing regional variants to existing script systems or assigning script-speci c
features to individual documents or applications. You can use these Script Manager
routines to
m replace one or more of a script systemG@ international resources (this replacement
occurs within the context of your application only)
m replace one or more of an individual script system@ routines (for 1-byte complex
scripts only)
Most text-processing applications need not perform either of these replacements.
However, if your program has special needs or if you are implementing a speci c
regional variation of a script system with unusual text-handling features, you can use
these Script Manager calls.

Replacing a Script System’s Default International Resources
In certain situations, you may want to replace the script-system-supplied international
resources with some of your own. For example, your application might create documents
containing currency amounts and get the currency format from the numeric-format
resource. You may then want the unit of currency to remain the same, even if the
document is displayed on a Macintosh with system software localized for another region.
You can store your own versions of some of the international resources in your
application@® or document@ resource le, to override those in the System le. In this case,
documents that your application creates could have their own copy of the
numeric-format resource that was used to create them.
To replace the numeric-format ('it10') or long-date-format ('it11"') resource, follow
these two steps:
1. When your application starts up or when your document is opened, call
the Get Script Variable function for your target script system to get the ID
number of the current default version of the resource you are replacing. Save that
ID number for later.
2. Call the Set ScriptVariable function to set the script@ default ID number to the ID
of the resource that you are supplying.
If your replacement resource is attached to your application or document, it will override
the script system@ default version. When a call for a resource is made,
the Resource Manager searches rst in the resource fork of the open document, then
in the resource fork of the active application, and then in the System le. This search
sequence is described in the chapter (Resource ManagerOin Inside Macintosh: More
Macintosh Toolbox.

6-48

Using the Script Manager

CHAPTER

6

Script Manager

To substitute the string-manipulation ('1t12') or tokens ('1t14') resources, you must

take an additional step. If you want to replace the default resource currently used by a
script system, you must rst clear your application@ international resources cache. The
cache is part of an application@ context as handled by the Process Manager; it is
initialized when the application is launched, and is switched in and out with the
application. It contains the resource ID numbers of the default string-manipulation and
tokens resources for all installed script systems. Once the cache is set up, access to
string-manipulation and tokens resources is exclusively through the ID numbers in
the cache.
Therefore, to replace a string-manipulation or tokens resource, it is not enough to attach
the resource to your document and call the Set Script Variable function; this alone
does not affect any cached ID numbers. In addition, add this third step:

3. After calling Set ScriptVariable as described in step 2, call
ClearInt1ResourceCache. That will cause the cache to be reloaded with the
current default resource ID numbers, including your override of the previous default,
as each resource is called.
In this case, when a call for a resource is made, the Script Manager looks rst in the cache
for the resource ID to use. If the cache has been cleared, the Script Manager gets the ID
from the script variables (and updates the cache with the new ID). The Script Manager
then calls the Resource Manager, requesting a resource with that ID. The Resource
Manager searches for the resource as described previously, taking it from your document
or application.
Because the system maintains a separate international resources cache for each
application® context, your application can provide its own string-manipulation and
tokens resources without affecting the use of those resources by other applications or by
the system. When the Process Manager switches in another application, that application®
international resources cache has the defaults needed by that application.
No matter which international resource you have replaced, there is one

nal step to take:

4, When your application exits or is switched out, be sure to call SetScriptVariable
once again to reset the script system@ default ID number to what it was before you
replaced it.
IMPORTANT

If the international resources selection fsag is TRUE when a call to access
your supplied resources is made, the ID numbers of your supplied
resources must be within the system script range; if it is FALSE, the IDs
must be in the range of the current script. Otherwise, your resources will
not be found. See the appendix Gnternational ResourcesOfor a list of
script codes and their resource ID ranges. A

Using the Script Manager

6-49

CHAPTER

6

Script Manager

Replacing a Script System’s Default Routines
Applications do not normally need to modify a script system@ text-handling routines.
For 1-byte complex script systems and for 2-byte script systems, most script-speci c
behavior is built into tables in the script@ international resources. Text-handling code is
in Macintosh system software: in ROM, in the System

le, or in one of two system

extensionsN WorldScript I and WorldScript II. WorldScript I and WorldScript II handle
text for 1-byte complex and 2-byte script systems, respectively. They are described in the
appendix (Built-in Script SupportOin this book. For most needs the table-driven behavior
is adequate, and you can access many of the tables through the Script Manager calls
described in the previous section.
Even so, for 1-byte complex script systems, the Script Manager offers you the ability to
modify or enhance the routines contained in WorldScript I. If you need speci c
script-based behavior that is not currently supported, you can replace one or more script
utilities (low-level text-handling routines that employ the ScriptUtil
trap) or
QuickDraw patches for your target script system. You can create a patch and install it
with a System extension le (type 'INIT') that is executed at system startup.
IMPORTANT

Because this capability affects WorldScript I only, it is available only for
1-byte complex script systems. A
In every script system that uses WorldScript I, the dispatch-table element for every script
utility and QuickDraw patch consists of two pointers: one to the WorldScript I
implementation of the routine and one to the original (built-in Roman) routine. In
all cases, the WorldScript I routine executes rst. In some cases, WorldScript I calls
the original routine after its own; in other cases, the pointer to the original routine is NIL
and the WorldScript I routine is all that executes. See Figure 6-6. This design allows
you to place a patched routine so that it executes before, in place of, or after the
WorldScript I routine.

6-50

Using the Script Manager

CHAPTER

6

Script Manager

Dispatch table entry for script utilities and QuickDraw patches

Address of script’s
patch to stdText

>

Figure 6-6

{

Address of
Joriginal stdText

[>

4

WorldScript |

==>

pascal

ScriptStdText

Original code

():

LE

pascal

StdText

():

The script-based dispatch table design gives you a simple, Sexible way to replace
individual routines without having to patch out all of ScriptUtil
or any of the
QuickDraw

low-level routines in their entirety. Furthermore, in a multiscript

environment each patch applies only to its own script system. You can, for example,
patch stdText for the Thai script system only, leaving it unchanged for all other
script systems.
To replace only the WorldScript I implementation of a routine, replace its pointer in the
dispatch table; to keep the WorldScript I routine while replacing or patching the original
routine, replace the original-routine pointer in the dispatch table. The four Script
Manager routines that allow you to make those patches are
GetScriptUtilityAddress,

SetScriptUtilityAddress,

GetScriptQDPatchAddress,

and SetScriptQDPatchAddress.

Hither pointer in the

dispatch table may be NIL, meaning that WorldScript I either (1) doesn@®patch the
original routine or (2) doesn@call the original routine.

For additional information on how to use these four Script Manager routines to
customize a script@ behavior, see the appendix (Built-in Script Support.O

Using the Script Manager

6-51

CHAPTER

6

Script Manager

Script Manager Reference
This section describes the constants, data structures, and routines that are speci

Script Manager.

c to the

Constants
The Script Manager de nes a large number of constants. This section lists and describes
the constants with which you can specify
m script codes, language codes, and region codes
m token codes
m selectors for Script Manager variables
m selectors for script variables
There are many other constants de ned for other purposes that are listed with the
routines that use them. In addition, all constants are listed in the section Gummary of the
Script ManagerObeginning on page 6-107.

Script Codes
You can specify script systems with implicit and explicit script code constants in the
script parameter of the

Get ScriptVariable and SetScriptVariable functions.

The implicit script codes smSystemScript and smCurrentScript are special negative
values for the system script and the font script, respectively.
Script constant

6-52

Value

Explanation

smSystemScript

1

System script

smCurrentScript

2

Font script

smRoman

0

Roman

smJapanese

1

Japanese

smTradChinese

2

Traditional Chinese

smKorean

3

Korean

smArabic

4

Arabic

smHebrew

5

Hebrew

smGreek

6

Greek

smCyrillic

7

Cyrillic

smRSymbol

8

Right-to-left symbols

smDevanagari

9

Devanagari

Script Manager Reference

CHAPTER

6

Script Manager

Script constant

Value

Explanation (continued)

smGurmukhi

10

Gurmukhi

smGujarati

11

Gujarati

smOriya

12

Oriya

smBengali

13

Bengali

smTamil

14

Tamil

smTelugu

15

Telugu

smKannada

16

Kannada/Kanarese

smMalayalam

17

Malayalam

smSinhalese

18

Sinhalese

smBurmese

19

Burmese

smKhmer

20

Khmer

smThai

21

Thai

smLaotian

22

Laotian

smGeorgian

23

Georgian

smArmenian

24

Armenian

smSimpChinese

25

Simpli

smTibetan

26

Tibetan

smMongolian

27

Mongolian

smGeez

28

Geez/Ethiopic

smEthiopic

28

= smGeez

smEastEurRoman

29

Extended Roman for Slavic and Baltic languages

smVietnamese

30

Extended Roman for Vietnamese

smExtArabic

31

Extended Arabic for Sindhi

smUninterp

32

Uninterpreted symbols

ed Chinese

Note
The script code represented by the constant smUninterp is available for
representation of special symbols, such as items in a tool palette, that
must not be considered as part of any actual script system. For
manipulating and drawing such symbols, the smUninterp constant
should be treated as if it indicated the Roman script system rather than
the system script; that is, the default behavior of uninterpreted symbols

should be Roman.

@

Note
The script code represented by the constant smRSymbol is available as
an alternative to smUninterp, for representation of special symbols that

have a right-to-left line direction. Note, however, that the script

management system provides no direct support for representation of text
with this script code.

Script Manager Reference

6-53

CHAPTER

6

Script Manager

Language Codes
Language codes have the following de ned values. Note that each language is associated
with a script code.

langJapanese

langArabic
langFinnish
langGreek

langIcelandic
langMaltese
langTurkish
langCroatian

langTradChinese
langUrdu
langHindi
langThai
langKorean
langLithuanian
langPolish
langHungarian
langEstonian
langLettish
langLatvian
langSaamisk
langLappish
langFaeroese

6-54

Script Manager Reference

©
KF
WN
FF
BD
AN

Dutch
Swedish

Spanish
Danish

Portuguese

Oo

langHebrew

Italian

Norwegian

CO

langNorwegian

(Script code)

German

Hebrew

Fe
KF

langPortuguese

Japanese

KF
KF
WN

langDanish

KF
FP

langSpanish

BR
DU

langSwedish

RP
BF
AN

langDutch

FY
N
TUDO

langItalian

YN
NY NY
WONFR

langGerman

French

NNN
DO
FP

langFrench

Language

English

NNN
MW
OMWON

langEnglish

Value

N
WN
Oo
OO

Language

constant

Arabic
Finnish
Greek
Icelandic
Maltese
Turkish
Croatian

Chinese (traditional chars.)
Urdu

Hindi

smDevanagari)

Thai

smThai)

Korean

smKorean)

Lithuanian

smbkastHurRoman )

Polish

smEastHurRoman

Hungarian

smEastEurRoman)

Estonian

smEastEurRoman)

Lettish

smEastHurRoman

=langLettish

(language
of Lapps/Sami)

(smRoman)

= langSaamisk
Faeroese

(smRoman)

)

)

CHAPTER

6

Script Manager

Language

constant

Value

Language

(Script code)
(continued)
(smArabic)

langFarsi

31

Farsi

langPersian

31

=langFarsi

langRussian

32

Russian

langSimpChinese

33

Chinese (simpli

langFlemish

34

Flemish

(

langIrish

35

Irish

(

langAlbanian

36

Albanian

(

langRomanian

37

Romanian

( smEastHurRoman

langCzech

38

Czech

( smEastHurRoman

langSlovak

39

Slovak

( smEastHurRoman

langSlovenian

40

Slovenian

( smEastHurRoman

langYiddish

4]

Yiddish

( smHebrew)

langSerbian

42

Serbian

( smCyrillic)

langMacedonian

43

Macedonian

( smCyrillic)

langBulgarian

44

Bulgarian

( smCyrillic)

langUkrainian

45

Ukrainian

( smCyrillic)

langByelorussian

46

Byelorussian

( smCyrillic)

langUzbek

47

Uzbek

( smCyrillic)

langKazakh

48

Kazakh

(smCyrillic )

langAzerbaijani

49

Azerbaijani

( smCyrillic)

langAzerbaijanAr

50

Azerbaijani

( smArabic)

langArmenian

51

Armenian

( smArmenian )

langGeorgian

52

Georgian

( smGeorgian )

langMoldovan

53

Moldovan

( smCyrillic )

langMoldavian

53

=

( smCyrillic)

langKirghiz

54

Kirghiz

( smCyrillic)

langTajiki

55

Tajiki

( smCyrillic)

langTurkmen

56

Turkmen

( smCyrillic)

langMongolian

57

Mongolian

( smMongolian)

langMongolianCyr

58

Mongolian

( smCyrillic)

langPashto

59

Pashto

( smArabic)

langKurdish

60

Kurdish

( smArabic)

langKashmiri

61

Kashmiri

( smArabic)

langSindhi

62

Sindhi

( smExtArabic)

langTibetan

63

Tibetan

( smTibetan)

( smCyrillic)

ed chars.)

langMoldovan

( smSimpChinese)

continued

Script Manager Reference

6-55

CHAPTER

Script

6

Manager

Language

constant

6-56

Value

Language

(Script code)
(continued)

langNepali

64

Nepali

(smDevanagar1)

langSanskrit

65

Sanskrit

( smDevanagari)

langMarathi

66

Marathi

( smDevanagari)

langBengali

67

Bengali

( smBengali)

langAssamese

68

Assamese

( smBengali)

langGujarati

69

Gujarati

( smGujarati)

langPunjabi

70

Punjabi

( smGurmukhi )

langOriya

71

Oriya

( smOriya)

langMalayalam

72

Malayalam

( smMalayalam)

langKannada

73

Kannada

( smKannada)

langTamil

74

Tamil

( smTamil)

langTelugu

75

Telugu

( smTelugu)

langSinhalese

76

Sinhalese

(smSinhalese)

langBurmese

77

Burmese

( smBurmese)

langKhmer

78

Khmer

( smKhmer)

langLao

79

Lao

( smLaotian)

langVietnamese

80

Vietnamese

( smVietnamese)

langIndonesian

81

Indonesian

( smRoman)

langTagalog

82

Tagalog

( smRoman)

langMalayRoman

83

Malay

( smRoman)

langMalayArabic

84

Malay

(

langAmharic

85

Amharic

(smEthiopic)

langTigrinya

86

Tigrinya

(smEthiopic)

langGalla

87

Galla

( smEthiopic)

langOromo

87

=

langSomali

88

Somali

langSwahili

89

Swahili

langRuanda

90

Ruanda

langRundi

91

Rundi

langChewa

92

Chewa

langMalagasy

93

Malagasy

langEsperanto

94

Esperanto

(mod.

langWelsh

128

Welsh

( smRoman )

langBasque

129

Basque

( smRoman )

langCatalan

130

Catalan

(smRoman)

langLatin

131

Latin

( smRoman )

Script Manager Reference

langGalla

smRoman)

CHAPTER

6

Script Manager

Value

Language

(Script code)

langQuechua

132

Quechua

(smRoman)

langGuarani

133

Guarani

(smRoman)

langAymara

134

Aymara

(smRoman)

langTatar

135

Tatar

(smCyrillic)

langUighur

136

Uighur

(smArabic)

langDzongkha

137

Bhutanese

(smTibetan)

langJavaneseRom

138

Javanese

(smRoman)

langSundaneseRom

139

Sundanese

(smRoman)

Language

constant

(continued)

Region Codes
Region codes have the following de ned values. Each region is associated with a
particular language code and script code (not shown). Note that the existence of a
de ned region code does not necessarily imply the existence of a version of Macintosh
system software localized for that region.

verFrBelgiumLux
verSweden
verDenmark
verPortugal

©
FF
WN

Italy
Netherlands

French for Belgium and Luxembourg

eh

Sweden
Denmark

Portugal
French Canada
Israel

Japan
Australia
the Arabic world

verGrSwiss

SR
ON

verFrSwiss

SRR

verFinland

Oo

verArabic

DBD

a

verArabia

BD

a

verAustralia

OF

a

verJapan

KF

verIsrael

WO

a

verFrCanada

FP

verNetherlands

Germany

FF

verlItaly

Great Britain

BD

verGermany

ON

verBritain

France

CO

verFrance

Explanation
United States

a

verUSs

Value

KF

Region constant

=

verArabia

Finland
French for Switzerland
German for Switzerland
continued

Script Manager Reference

6-57

CHAPTER

6

Script Manager

Region constant

Value

Explanation (continued)

verGreece

20

Greece

veriIceland

21

Iceland

verMalta

22

Malta

verCyprus

23

Cyprus

verTurkey

24

Turkey

verYugoCroatian

25

Croatian system for Yugoslavia

veriIndiaHindi

33

Hindi system for India

verPakistan

34

Pakistan

verLithuania

41

Lithuania

verPoland

42

Poland

verHungary

43

Hungary

verEstonia

44

Estonia

verLatvia

45

Latvia

verLapland

46

Lapland

verFaeroeIsl

47

Faeroe Islands

vertIran

48

Iran

verRussia

49

Russia

verIreland

50

Ireland

verkorea

51

Korea

verChina

52

People@ Republic of China

verTaiwan

53

Taiwan

verThailand

54

Thailand

minCountry

The lowestde ned region code
(for range-checking);
currently = verUS

maxCountry

The highestde ned region code
(for range-checking);
currently = verThailand

Token Codes
The following constants de ne the types of tokens recognized by the Int 1lTokenize
function
and speci edinthe eld theToken of the token record (type TokenRec):
Constant
delimPad

2

Explanation

Delimiter pad (special code)

tokenLeftLit

Script Manager Reference

Oo

tokenUnknown

Has no existing token type

FF

Empty Sag
Whitespace character

Ny

tokenEmpty

tokenWhite

6-58

Value

Opening literal marker

CHAPTER

Manager

tokenAlpha
tokenNumeric
tokenNewLine
tokenLeftComment

WH

Explanation (continued)

Closing literal marker

Alphabetic
Numeric

New line
Opening comment marker
Closing comment marker

tokenLiteral

Oo

tokenRightComment

FF

tokenRightLit

Value

HD

Constant

AN

Script

6

Literal

tokenEscape

10

Escape character

tokenAltNum

11

Alternate number (such as at $B0 $B9)

tokenRealNum

12

Real number

tokenAltReal

13

Alternate real number

tokenReservel

14

(reserved1)

tokenReserve2

15

(reserved 2)

tokenLeftParen

16

Opening parenthesis

tokenLeftBracket

18

Opening square bracket

tokenRightBracket

19

Closing square bracket

tokenLeftCurly

20

Opening curly bracket

tokenRightCurly

21

Closing curly bracket

tokenLeftEnclose

22

Opening European double quote

tokenRightEnclose

23

Closing European double quote

tokenPlus

24

Plus

tokenMinus

25

Minus

tokenAsterisk

26

Times /multiply

tokenDivide

27

Divide

tokenSlash

29

Slash

tokenBackSlash

30

Backslash

tokenLess

31

Less than

tokenGreat

32

Greater than

tokenEgqual

33

Equal

tokenLessEqual2

34

Less than or equal to (2 symbols)

tokenLessEquall

35

Less than or equal to (1 symbol)

tokenGreatEqual2

36

Greater than or equal to (2 symbols)

tokenGreatEquall

37

Greater than or equal to (1 symbol)

token2Equal

38

Double equal

tokenColonEqual

39

Colon equal
continued

Script Manager Reference

6-59

CHAPTER

6

Script Manager

Constant

6-60

Value

Explanation (continued)

tokenNotEqual

40

Not equal

tokenLessGreat

41

Less/ greater (not equal in Pascal)

tokenExclamEqual

42

Exclamation equal (not equal in C)

tokenExclam

43

Exclamation point

tokenTilde

44

Centered tilde

tokenComma

45

Comma

tokenPeriod

46

Period

tokenLeft2Quote

47

Opening double quote

tokenRight2Quote

48

Closing double quote

tokenLeft1Quote

49

Opening single quote

tokenRight1Quote

50

Closing single quote

token2Quote

51

Double quote

tokenlQuote

52

Single quote

tokenSemicolon

53

Semicolon

tokenPercent

54

Percent

tokenCaret

55

Caret

tokenUnderline

56

Underline

tokenAmpersand

57

Ampersand

tokenAtSign

58

At sign

tokenBar

59

Vertical bar

tokenQuestion

60

Question mark

tokenPi

61

Pi

tokenRoot

62

Square root

tokenSigma

63

Capital sigma

tokenIntegral

64

Integral

tokenMicro

65

Micro

tokenCapPi

66

Capital pi

tokenInfinity

67

In

tokenColon

68

Colon

tokenHash

69

Pound sign (U.S. weight)

tokenDollar

70

Dollar sign

tokenNoBreakSpace

71

Nonbreaking space

tokenFraction

72

Fraction

tokenInt1Currency

73

International currency

tokenLeftSingGuillemet

74

Opening single guillemet

tokenRightSingGuillemet

75

Closing single guillemet

Script Manager Reference

nity

CHAPTER

6

Script Manager

Constant

Value

Explanation (continued)

tokenPerThousand

76

Per thousands

tokenEllipsis

77

Ellipsis character

tokenCenterDot

78

Center

dot

Selectors for Script Manager Variables
This section lists and describes the selector constants for accessing the Script Manager
variables through

calls to the

Get ScriptManagerVariable
and

Set ScriptManagerVariable functions. In every case the variable parameter passed
to or from the function is a long integer (4 bytes); the column CSize of variableOindicates
how many of the 4 bytes are necessary to hold the input or return value for that variable.
If fewer than 4 bytes are needed, the low byte or low word contains the information.
Descriptions of all the variables accessed by these constants follow the list.
Selector constant

Value

Size of
variable (bytes)

smVersion

0

2

smMunged

2

2

smEnabled

4

1

smBidirect

6

1

smFont Force

8

1

smInt1lForce

10

1

smForced

12

1

smDefault

14

1

smPrint

16

4

smSysScript

18

2

smLastScript

20

2

smKeyScript

22

2

smSysRef

24

2

smKeyCache

26

4

smKeySwap

28

4

smGenFlags

30

4

smOverride

32

4

smCharPortion

34

2

smDoubleByte

36

1

smKCHRCache

38

4

smRegionCode

40

2

smKeyDisableState

42

1

Script Manager Reference

6-61

CHAPTER

6

Script Manager

Selector constant

Variable description

smVersion

The Script Manager version number. This variable has the same
format as the version number obtained from calling the Gestalt
function with the Gestalt selector gestaltScriptMgrVersion.

The high-order byte contains the major version number, and the
low-order byte contains the minor version number.
smMunged

The modi

cation count for Script Manager variables. At startup,

smMunged is initialized to 0, and it is incremented when the

KeyScript procedure changes the current keyboard script and

updates the variables accessed via smKeyScript and
smLastScript. The smMunged selector is also incremented when
the Set ScriptManagerVariable function is used to change a

smEnabled

Script Manager variable. You can check this variable at any time to
see whether any of your own data structures that may depend on
Script Manager variables need to be updated.
The script count; the number of currently enabled script systems. At
startup time, the Script Manager initializes the script count to 0, then
increments it for each installed and enabled script system (including
Roman). You can use smEnabled to determine whether more than

one script system is installedN that is, whether your application
needs to handle non-Roman text.
IMPORTANT

Never call

Set ScriptManagerVariable with the smEnabled

selector. It could result in inconsistency with other script
system values. A

smBidirect

smFontForce

The bidirectional fsag, which indicates when at least one
bidirectional script system is enabled. This fag is set to TRUE ($FF) if
the Arabic or Hebrew script system is enabled.
The font force fsag. At startup, the Script Manager sets its value from
the system script@ international con guration ('it1c"') resource.
The fsag returns 0 for FALSE and $FF for TRUE. If the system script is
non-Roman, the font force Sag controls whether a font with ID in the

Roman script range is interpreted as belonging to the Roman script
or to the system script. See Using the Font Force FlagOon
page 6-24.
IMPORTANT

When you call

Set ScriptManagerVariable with the

smFont Force selector, be sure to pass only the value 0 or $FF, or a

later call to
smintlForce

Get ScriptManagerVariable may return an

unrecognized value. A
The international resources selection Sag. At startup, the Script
Manager sets its value from the system script@ international
con

guration ('it1lc')

resource. The fsag returns 0 for FALSE and

SFF for TRUE. This fsag controls whether international resources of
the font script or the system script are used for string manipulation.
See (Using the International Resources Selection FlagOon page 6-25.

6-62

Script Manager Reference

CHAPTER

6

Script Manager

IMPORTANT

When you call

Set ScriptManagerVariable with the

smInt1Force selector, be sure to pass only the value 0 or $FF, or a

later call to
smForced

Get ScriptManagerVariable may return an

unrecognized value. A
The script-forced result fag. If the current script has been forced to
the system script, this Sag is set to TRUE. Use the smForced selector
to obtain reports of the actions of the FontScript,
FontToScript,

and Int1lScript

functions. This variable is for

information only; never set its value with
SetScriptManagerVariable.

smDefault

The script-defaulted result Sag. If the script system corresponding to
aspeci ed font is not available, this Sag is set to TRUE. Use this
selector to obtain reports of the actions of the FontScript,
FontToScript, and Int1lScript functions. This variable is for

information only; never set its value with
SetScriptManagerVariable.

smPrint

smSysScript

The print action routine vector, set up by the Script Manager at
startup. See Inside Macintosh: Devices for information on the print
action routine.
The system script code. At startup, the Script Manager initializes this
variable from the system script@ international con guration
('it1lc') resource. This variable is for information only; never set
its value with Set ScriptManagerVariable. Constants for all

smLastScript

de ned script codes are listed on page 6-52.
The previously used keyboard script. When you change keyboard
scripts with the KeyScript procedure, the Script Manager moves
the old value of smKeyScript into smLastScript. KeyScript

can also swap the current keyboard script with the previous
keyboard script, in which case the contents of smLast Script and
smKeyScript are swapped. Constants for all de ned script codes
are listed on page 6-52. Never set the value of this variable with
SetScriptManagerVariable.

smKeyScript

The current keyboard script. The KeyScript procedure tests and
updates this variable. When you change keyboard scripts with the
KeyScript procedure, the Script Manager moves the old value of

smKeyScript into smLastScript. KeyScript can also swap the

current keyboard script with the previous keyboard script, in which
case the contents of smLastScript

and smKeyScript are

swapped. The Script Manager also uses this variable to get the
proper keyboard icon and to retrieve the proper keyboard-layout
('KCHR') resource. Constants for all de ned script codes are listed
on page 6-52. Never set the value of this variable directly with
Set ScriptManagerVariable; call KeyScript to change

smSysRef

keyboard scripts.
The System Folder volume reference number. Its value is initialized
from the system global variable Boot Drive at startup.

Script Manager Reference

6-63

CHAPTER

6

Script Manager

smKeyCache

An obsolete variable. This variable at one time held a pointer to the
keyboard cache. The value it provided was not correct and should
not be used.

smKeySwap

A handle to the keyboard-swap ('KSWP')

resource. The Script

Manager initializes the handle at startup. The keyboard-swap
resource controls the key combinations with which the user can

invoke various actions with the KeyScript procedure, such as

switching among script systems. This resource is described in the
appendix (Keyboard ResourcesOin this book.

smGenFlags

The general fags used by the Script Manager. The Script Manager
general fags is a long word value; its high-order byte is set from the
Bags byte in the system script@ international con guration
('itlc') resource. The following constants are available to

designate bits in the variable accessed through
Constant

Value

smGenF lags:

Explanation

smfNameTagEnab

29

(reserved for internal use)

smfDualCaret

30

Use dual caret for
mixed-directional text.

smfShowIcon

31

Show keyboard menu even if only
one keyboard layout or one script
(Roman) is available. (This bit is

checked only at system startup.)
smOverride
smCharPortion

The script override Gags. At present, these fags are not set or used
by the Script Manager. They are, however, reserved for future use.
Avalue used by script systems to allocate intercharacter and
interword spacing when justifying text. It denotes the weight
allocated to intercharacter space versus interword space. The value
of this variable is initialized to 10 percent by the Script Manager,
although it currently has no effect on text of the Roman script
system. The variable is in 4.12

xed-point format, which is a 16-bit

signed number with 4 bits of integer and 12 bits of fraction. (In that

format, 10 percent has the hexadecimal value $0199.)

smDoubleByte
smKCHRCache

smRegionCode

The 2-byte fsag, a Boolean value that is TRUE if at least one 2-byte
script system is enabled.
A pointer to the cache that stores a copy of the current
keyboard-layout ('KCHR') resource. The keyboard-layout resource
is described in the appendix (Keyboard ResourcesOin this book.
The region code for this localized version of system software,
obtained from the system script@ international con guration
('itlc') resource. This variable identi es the localized version of
the system script. Constants for all de ned region codes are listed
starting on page 6-57.

smKeyDisableState

The current disable state for keyboards. The Script Manager disables
some keyboard scripts or keyboard switching when text input must
be restricted to certain script systems or when script systems are
being moved into or out of the System le.

6-64

Script Manager Reference

CHAPTER

6

Script Manager

See (Making Keyboard SettingsObeginning on page 6-17. These are
the possible values for the variable accessed through
smKeyDisableState:

Value

Explanation

0

All keyboards are enabled, switching is enabled

1

Keyboard switching is disabled

$FF

Keyboards for all non-Roman secondary scripts are
disabled

The script management system maintains the keyboard disable state
separately for each application. Never set the value of
this variable directly with

Set ScriptManagerVariable;

call KeyScript to change the keyboard disable state for
your application.

Selectors for Script Variables
This section lists and describes the selector constants for accessing script variables
through calls to the Get ScriptVariable and SetScriptVariable functions. In
every case the variable parameter passed to or from the function is a long integer (4
bytes); the column GSize of variableOindicates how many of the 4 bytes are necessary to
hold the input or return value for that variable. If fewer than 4 bytes are needed, the low
byte or low word contains the information.
In many cases the value of a script variable is taken from the script system@ international
bundle (' it1b') resource. See the appendix Ginternational ResourcesOfor a description
of the international bundle resource.
Descriptions of all the variables accessed by these constants follow the list.

16

smScriptDate

18

smScriptSort

20

smScriptFlags

22

NY

smScriptNumber

KF

14

KF

smScriptAppFond

KF

12

FP

smScriptSysFond

NY

10

smScriptRight

NY

smScriptRedraw

smScriptEnabled

2

NY

smScriptJust

on
FF
NY

smScriptMunged

Size of variable
(bytes)

NNN

smScriptVersion

Value
©

Selector constant

continued

Script Manager Reference

6-65

CHAPTER

6

Script Manager

Selector constant

Value

smScriptToken

24

2

smScriptEncoding

26

2

smScriptLang

28

2

smScriptNumDate

30

2

smScriptKeys

32

2

smScriptIcon

34

2

smScriptPrint

36

4

smScriptTrap

38

4

smScriptCreator

40

4

smScriptFile

42

4

smScriptName

44

4

smScriptMonoFondSize

78

4

smScript PrefFondSize

80

4

smScriptSmallFondSize

82

4

smScriptSysFondSize

84

4

smScriptAppFondSize

86

4

smScriptHelpFondSize

88

4

smScriptValidStyles

90

1

smScriptAliasStyle

92

1

Selector constant
smScriptVersion

Size of variable
(bytes) (continued)

Variable description

The script system@ version number. When the Script Manager loads
the script system, the script system puts its current version number
into this variable. The high-order byte contains the major version

number, and the low-order byte contains the minor version number.
smScriptMunged

The modi cation count for this script systemG@ script variables. The
Script Manager increments the variable accessed by the
smScriptMunged selector each time the SetScriptVariable

function is called for this script system. You can check this variable
at any time to see whether any of your own data structures that
depend on this script system@ script variables need to be updated.
smScriptEnabled

The script-enabled fag, a Boolean value that indicates whether the

script has been enabled. It is set to SFF when enabled and to 0 when
not enabled. Note that this variable is not equivalent to the Script
Manager variable accessed by the smEnabled selector, which is a
count of the total number of enabled script systems.

6-66

Script Manager Reference

CHAPTER

6

Script Manager

smScriptRight

smScriptJust

The right-to-left Sag, a Boolean value that indicates whether the
primary line direction for text in this script is right-to-left or
left-to-right. It is set to $FF for right-to-left text (used in Arabic and
Hebrew script systems) and to 0 for left-to-right (used in Roman and
other script systems).
The script alignment fag, a byte that speci es the default alignment
for text in this script system. It is set to $FF for right alignment
(common for Arabic and Hebrew), and it is set to 0 for left alignment

(common for Roman and other script systems). This Sag usually has
the same value as the smScriptRight fag.
smScriptRedraw

The script-redraw fag, a byte that provides redrawing
recommendations for text of this script system. It describes how
much of a line should be redrawn when a user adds, inserts, or

deletes text. It is set to 0 when only a character should be redrawn
(used by the Roman script system), to 1 when an entire word should
be redrawn (used by the Japanese script system), and to 1 when the
entire line should be redrawn (used by the Arabic and Hebrew script
systems). The following constants are available for the script-redraw
Gag:
Constant

smScriptSysFond

Value

Explanation

smRedrawChar

Q

Redraw character only

smRedrawWord

1

Redraw entire word

smRedrawLine

1

Redraw entire line

The preferred system font, the font family ID of the system font
preferred for this script. In the Roman script system, this variable
speci es Chicago font, whose font family ID is 0 if Roman is the
system script. The preferred system font in the Japanese script
system is 16384, the font family ID for Osaka.

This variable holds similar information to the variable accessed
through the smScriptSysFondSize
selector. However, changing
the value of this variable has no effect on the value accessed through
smScriptSysFondSize.

Note
Remember that in all localized versions of system software the
special value of 0 is remapped to the system font ID. Thus, if
an application running under Japanese system software speci es
a font family ID of 0 ina routine or inthe txFont eld of the
current graphics port, Osaka will be used. However, the variable
accessed by smScriptSysFond will still show the true ID for

Osaka (16384). @
smScriptAppFond

The preferred application font; the font family ID of the application

font preferred for this script. In the Roman script system, the value
of this variable is the font family ID for Geneva.

Script Manager Reference

6-67

CHAPTER

6

Script Manager

This variable holds similar information to the variable accessed
through the smScriptAppFondSi ze selector. However, changing

the value of this variable has no effect on the value accessed through
smScriptAppFondSize.

Note

Remember that in all localized versions of system software the
special value of 1 is remapped to the application font ID. For
example, if an application running under Arabic system software
speci es a font family ID of 1 ina routine, Nadeem will be used.
However, the variable accessed by smScriptSysFond will still

show the true ID for Nadeem (17926).

smScriptNumber

The resource ID of the script@ numeric-format ('it10') resource.

The numeric-format resource includes formatting information for

the correct display of numbers, times, and short dates. The value of

this variable is initialized from the script system@ international
bundle resource. See the appendix Onternational ResourcesOfor a
description of the numeric-format resource.
smScriptDate

smScriptSort

The resource ID of the script@ long-date-format ('it11') resource.

The long-date-format resource includes formatting information for
the correct display of long dates (dates that include month or day
names). The value of this variable is initialized from the script
system@ international bundle resource. See the appendix
Onternational ResourcesOfor a description of the long-date-format
resource.
The resource ID of the script@ string-manipulation ('it12')
resource. The string-manipulation resource contains routines for
sorting and tables for word selection, line breaks, character types,

smScriptFlags

and case conversion of text. The value of this variable is initialized
from the script system@ international bundle resource. See the
appendix Cinternational ResourcesOfor a description of the
string-manipulation resource.
The script Sags word, which contains bit Sags specifying attributes
of the script. The value of this variable is initialized from the script
systemG@ international bundle resource. The following constants are
available for examining attributes in the script fags word. Bits above
8 are nonstatic, meaning that they may change during program
execution. (Note that the constant values represent bit numbers in
the Sags word, not masks.)
Constant

smsfIntellcP

Value

0

Explanation

Can support intelligent cut
and paste (uses spaces as

word delimiters)

6-68

smsfSingByte

1

Has only 1-byte characters

smsfNatCase

2

Has both uppercase and

smsfContext

3

Is contextual

Script Manager Reference

lowercase native characters

CHAPTER

6

Script Manager

Constant

Value

Explanation (continued)

smsfNoForceFont

4

Does not support font
forcing (ignores the font
force Sag)

smsfBODigits

5

Has alternate digits at
$BO

$B9; Arabic and

Hebrew, for example, have

their native numeric forms
at this location in their
character sets

smsfAutoInit

6

Is intialized by the Script
Manager; 1-byte simple
script systems can set this
bit to avoid having to
initialize themselves

smsfUnivExt

7

Uses the WorldScript I
extension

smsfSynchUnstyledTE

8

Synchronizes keyboard
with font for monostyled
TextEdit

smsfForms

13

smsfLigatures

14.

~—_— Use contextual ligatures if

smsfReverse

15

Reverse right-to-left text to

Use contextual forms if this

bit is set; do not use them if
it is cleared
this bit is set; do not use
them if it is cleared
draw it in (left-to-right)

display order if this bit is
set; do not reorder text if
this bit is cleared
The smsfIntel1cP fag is set if this script system uses spaces as
word delimiters. In such a script system it is possible to implement
intelligent cut and paste, in which extra spaces are removed when a
word is cut from text, and any needed spaces are added when a
word is pasted into text. Macintosh Human Interface Guidelines
recommends that you implement intelligent cut and paste in script
systems that support it.
If you use the CharToPixel function to determine text widths,
such as for line breaking, you need to clear the smsfReverse bit
rst. For more information, see the chapter CQQuickDraw TextOin

this book.
smScriptToken

The resource ID of the script@ tokens ('it14') resource. The

tokens resource contains information for tokenizing and number
formatting. The value of this variable is initialized from the script
system@ international bundle resource. See the appendix
Onternational ResourcesOin this book for a description of the
tokens resource.

Script Manager Reference

6-69

CHAPTER

6

Script Manager

smScriptEncoding

smScriptLang

smScriptNumDate

The resource ID of the script@ (optional) encoding /rendering
('it15') resource. For 1-byte scripts, the encoding /rendering
resource speci es text-rendering behavior; for 2-byte scripts, it
speci es character-encoding information. The value of this variable
is taken from the script system@ international bundle resource. See
the appendix Ginternational ResourcesOfor a description of the
encoding /rendering resource.
The language code for this version of the script. A language is a
specialized variation of a speci c script system. Constants for
all de ned language codes are listed on page 6-54. The value of this
variable is initialized from the script system@ international bundle
resource.
The numeral code and calendar code for the script. The numeral
code speci es the kind of numerals the script uses, and is in the
high-order byte of the word; the calendar code speci es the type of
calendar it uses and is in the low-order byte of the word. The value
of this variable is initialized from the script system@ international
bundle resource. It may be changed during execution when the
user selects, for example, a new calendar from a script system@

control panel.
The following numeral-code constants are available for specifying

numerals. Note that they are bit numbers, not masks:
Constant

Value

Explanation

intWestern

0

Western numerals

intArabic

1

Native Arabic numerals

intRoman

2

Roman numerals

intJapanese

3

Japanese numerals

intEuropean

4

European numerals

intOutputMask

$8000

Output mask

The following calendar-code constants are available for specifying
calendars. Note that they are bit numbers, not masks:
Constant

6-70

Value

Explanation

calGregorian

Q

Gregorian calendar

calArabicCivil

1

Arabic civil calendar

calArabicLunar

2

Arabic lunar calendar

calJapanese

3

Japanese calendar

calJewish

4

Jewish calendar

calCoptic

5

Coptic calendar

calPersian

6

Persian calendar

Script Manager Reference

CHAPTER

6

Script Manager

smScriptKeys

The resource ID of the script@ current keyboard-layout (' KCHR')
resource. The keyboard-layout resource is used to map virtual key
codes into the correct character codes for the script; it is described in
the appendix (Keyboard ResourcesOin this book. The value of this
variable is initialized from the script system@ international bundle
resource. It is updated when the user selects a new keyboard layout,
or when the application calls the KeyScript procedure. You can
force a particular keyboard layout to be used with your application
by setting the value of this variable and then calling KeyScript.

smScriptIcon

The resource ID of the script@ keyboard icon family (resource types
'kes#', 'kcs4',and 'kcs8'). The keyboard icon family consists
of the keyboard icons displayed in the keyboard menu; it is
described in the appendix (Keyboard ResourcesOin this book. The
value of this variable is initialized from the script system@

international bundle resource. Note that, unlike smScriptKeys, the

smScriptPrint

smScriptTrap
smScriptCreator

value of this variable is not automatically updated when the
keyboard layout changes. (System software assumes that the icon
family has an identical ID to the keyboard-layout resource, and
usually ignores this variable.)
The print action routine vector, set up by the script system (or by the
Script Manager if the smsfAutoInit bit is set) when the script is
initialized. See Inside Macintosh: Devices for information on the print
action routine.
A pointer to the script@ script-record dispatch routine (for internal
use only).
The 4-character creator type for the script system@ le, that is, the
le containing the script system. For the Roman script system, it is
'ZSYS', for WorldScript litis

'univ', and for World Script II it is

'doub'.

smScriptFile

smScriptName

A pointer to the Pascal string that contains the name of the script
system@ le, thatis, the le containing the script system. For the
Roman script system, the string is 'System'.
A pointer to a Pascal string that contains the script system@ name.
For the Roman script system and 1-byte simple script systems, the
string is 'Roman'. For 1-byte complex script systems, this name is
taken from the encoding /rendering ('it15') resource. For 2-byte
script systems, it is taken from the WorldScript I] extension and is
'WorldScript

II'.

smScriptMonoFondSize

The default font family ID and size (in points) for monospaced text.

The ID is stored in the high-order word, and the size is stored in the

low-order word. The value of this variable is taken from the script
system@ international bundle resource. Note that not all script
systems have a monospaced font.

Script Manager Reference

6-71

CHAPTER

6

Script Manager

smScriptPrefFondSize

Currently not used.

smScriptSmallFondSize

The default font family ID and size (in points) for small text,

generally the smallest font and size combination that is legible on
screen. The ID is stored in the high-order word, and the size is
stored in the low-order word. Sizes are important; for example, a

9-point font may be too small in Chinese. The value of this variable
is taken from the script system@ international bundle resource.
smScriptSysFondSize

The default font family ID and size (in points) for this script

system@ preferred system font. The ID is stored in the high-order

word, and the size is stored in the low-order word. The value of this

variable is taken from the script system@ international bundle
resource.
This variable holds similar information to the variable accessed
through the smScriptSysFond selector. If you neeed font family
ID only and don@want

size information, it is simpler to use

smScriptSysFond. Note, however, that changing the value of this
variable has no effect on the value accessed through
smScriptSysFond.

smScriptAppFondSize
The default font family ID and size (in points) for this script

system@ preferred application font. The ID is stored in the

high-order word, and the size is stored in the low-order word. The

value of this variable is taken from the script system@ international
bundle resource.
This variable holds similar information to the variable accessed
through the smScriptAppFond selector. If you neeed font family
ID only and don@want

size information, it is simpler to use

smScriptAppFond. Note, however, that changing the value of this

variable has no effect on the value accessed through
smScriptAppFond.

smScriptHelpFondSize
The default font family ID and size (in points) for Balloon Help. The
ID is stored in the high-order word, and the size is stored in the
low-order word. Sizes are important; for example, a 9-point font

may be too small in Chinese. The value of this variable is taken from
the script system@ international bundle resource.

smScriptValidStyles

The set of all valid styles for the script. For example, the Extended
style is not valid in the Arabic script. When the
GetScriptVariable function is called with the
smScriptValidstyles selector, the low-order byte of the

returned value is a style code that includes all of the valid styles for

6-72

Script Manager Reference

CHAPTER

6

Script Manager

the script (that is, the bit corresponding to each QuickDraw style is
set if that style is valid for the speci ed script). See Figure 6-7.
The value of this variable is taken from the script system@
international bundle resource.
Figure 6-7

76543

Li

Style code format

titi

210

tt

|

Ls

Bold

Italic
Underline
Outline
Shadow
Condense
Extend

(reserved)

smScriptAliasStyle

The style to use for indicating aliases. When the

Get ScriptVariable
function is called with
smScriptAliasStyle, the low-order byte of the returned value is

the style code (see Figure 6-7) that should be used in that script for
indicating alias names (for example, in the Roman script system,
alias names are indicated in italics). The value of this variable is
taken from the script system@ international bundle resource.
Note
Some script systems, such as Arabic and Hebrew, have private
script-system selectors that are unique to those scripts. Those private
selectors are negative, whereas selectors that extend across script systems
are positive.

Data Structures
This section presents the following types and data structures used by the Script Manager:
the token block record and the token record. Other data type de nitions are in the section
(Summary of the Script ManagerObeginning on page 6-107.
The Script Manager also makes use of many of the types and data structures de ned in
the appendix Ginternational ResourcesOin this book.

Script Manager Reference

6-73

CHAPTER

Script

6

Manager

Token Block Record
The token block record, of data type TokenBlock, is a parameter block used to pass
information to the Int lTokenize function and to retrieve results from it.
TYPE

TokenBlock

=

RECORD

source:
sourceLength:
tokenList:
tokenLength:

Ptr;
LongInt;
Ptr;
LongInt ;

{pointer to source text to be tokenized}
{length of source text in bytes}
{pointer to array of token records}
{maximum size of TokenList }

tokenCount

LongInt ;

{number

stringList:
stringLength:
stringCount :
doString:

Ptr;
LongInt;
LongInt ;
Boolean;

{pointer to list of token strings}
{length available for string list}
{current length of string list}
{make strings & put into StringList?}

doAppend:

Boolean;

{append

:

doAlphanumeric: Boolean;
doNest:
Boolean;
ARRAY

[0..1]

OF

rightDelims:

ARRAY

[0..1]

OF

:

ARRAY

[0..3]

OF

rightComment:

ARRAY

[0..3]

OF

escapeCode:
decimalCode:
itlResource:

TokenType;
TokenType;
Handle;

reserved:

ARRAY

currently

TokenList}

replace--TokenList?}

may include
nest?}

numerics?}

delimiters

for

literals}

for

literals}

for

comments}

for

comments}

TokenType;

{closing

delimiters

TokenType;

{opening

delimiters

TokenType;

{closing

delimiters

{escape symbol code}
{decimal symbol code}
{'itl4' resource of script
OF

in

TokenType;

{opening

[0..7]

tokens

to--not

{identifiers
{do comments

leftDelims:

leftComment

of

for

this

text}

LongInt;

{must

be

zero!}

END;

TokenBlockPtr

=

*TokenBlock;

The elds in the token block record are described under the routine description for
IntlTokenize,
beginning on page 6-92.

Token Record
The token record (data type TokenRec) holds the results of the conversion of a sequence
of characters to a token by the Int 1Tokenize function. When it analyzes text,
Int1Tokenize generates a token list, which is a sequence of token records.

6-74

Script Manager Reference

CHAPTER

Script

6

Manager

TYPE

TokenRec

=

RECORD

theToken:
position:

TokenType;
Ptr;

length:

LongInt ;

stringPosition:

StringPtr;

{numeric code for token}
{pointer to source text from }
{ which token was generated}
{length of source text from }
{ which token was generated}
{pointer to Pascal string }
{ generated from token}

END ;

TokenRecPtr

=

“TokenRec;

The elds in the token record are described under the routine description for
Int 1Tokenize, on page 6-95.

Routines
The Script Manager routines documented in this section allow you to
control the system direction
access Script Manager variables
access script variables
control the keyboard and keyboard script
determine script codes
obtain character-type information
directly access a script system@ international resources
tokenize text
transliterate text
replace the default routines for a 1-byte complex script system
Throughout these routine descriptions, unless otherwise noted, the Script Manager
expects that
there is a buffer containing text characters only; font and style information are stored
separately
the storage order of the charactersN the order in which character codes are stored in

memoryN is their logical order, the order in which they would most naturally be
entered from the keyboard
all offsets within text buffers are zero-based and speci

ed in bytes, not characters

a valid graphics port exists, and the font of the port is set correctly; all text-related
elds in the graphics port record refSect the characteristics of the text being
manipulated
Script Manager Reference

6-75

CHAPTER

6

Script Manager

Assembly-language note
You can invoke each of the Script Manager routines that uses the
_ScriptUtil trap with a macro that has the same name as the routine,
preceded by an underscore. See Gummary of the Script ManagerOat
the end of this chapter for a list of the routines that use the
_ScriptUtil trap.

Checking and Setting the System Direction
The Get SysDirection routine returns the value of SysDirection, the global variable
that represents the system direction. A value of 0 for SysDirection means that the
primary line direction is left-to-right; a value of 1 means that the primary line direction
is right-to-left. The value of SysDirection is initialized from the system@ international
con guration resource, and may be controlled by the user. Your application can use the
SetSysDirection procedure to change SysDirection while drawing, but should
restore it when appropriate (such as when your application becomes inactive).

GetSysDirection
The Get SysDirection function returns the current value of SysDirection, the global
variable that determines the system direction (primary line direction).
FUNCTION

GetSysDirection:

Integer;

DESCRIPTION

There are two possible return values from Get SysDirection:
0 = left-to-right line direction
1 = $FFFF = right-to-left line direction

SetSysDirection
The

Set SysDirection procedure sets the value of SysDirection, the global variable

that determines the system direction (primary line direction).
PROCEDURE

SetSysDirection

(newDirection:

newDirection

The desired value for SysDirection.

6-76

Script Manager Reference

Integer) ;

CHAPTER

6

Script Manager

DESCRIPTION

There are two valid input values for newDirection:
0 = left-to-right line direction
1 = $FFFF = right-to-left line direction

Checking and Setting Script Manager Variables
The Script Manager maintains a set of variables that control general settings of the text
environment, including the identity of the system script and the keyboard script, and the
settings of the font force fsag and the international resources selection fag.
You may want access to the Script Manager variables in order to understand the current
environment or to modify it. The Get ScriptManagerVariable function retrieves the
values of the Script Manager variables, and the Set ScriptManagerVariable function
sets their values. (The variables themselves are private and you cannot access them
directly.) When you call either routine, you use a selector to describe the variable that
interests you. The integer constants for allde ned GetScriptManagerVariable/
Set ScriptManagerVariable selectors are described beginning on page 6-61.

GetScriptManagerVariable
The Get ScriptManagerVariable function retrieves the value of the speci
Manager variable.
FUNCTION

selector

GetScriptManagerVariable

Avalue that speci

(selector:

Integer):

ed Script

LongInt;

esa particular Script Manager variable.

DESCRIPTION

Although Get ScriptManagerVariable always returns a long integer, the actual value
may be a long integer, standard integer, or signed byte. If the value is not a long integer, it
is stored in the low-order word or byte of the long integer returned by
Get ScriptManagerVariable; the remaining bytes are set to 0.
The Get ScriptManagerVariab1le

function returns 0 if the selector is invalid.

Note
For some valid selectors, 0 may also be a valid return value. For example,

when you call Get ScriptManagerVariable with a selector value of
smRegionCode ona version of Macintosh system software that has been
localized for the United States, it returns 0.

To specify the Script Manager variable whose value you need, use one of the selector
constants listed on page 6-61.

Script Manager Reference

6-77

CHAPTER

6

Script Manager

SetScriptManagerVariable
The SetScriptManagerVariable function sets the speci
to the value of the input parameter.

ed Script Manager variable

FUNCTION

Integer;

SetScriptManagerVariable

(selector:
param:

selector

Avaluethatspeci

param

The new value for the speci

LongInt):

OSErr;

esa particular Script Manager variable.
ed Script Manager variable.

DESCRIPTION

The actual values to be assigned may be long integers, standard integers, or signed bytes.
If the value is other than a long integer, you must store it in the low-order word or byte of
the param parameter and set the unused bytes to 0.
The SetScriptManagerVariable

function returns the value smBadVerb if the

selector is not valid. Otherwise, it returns 0 (noErr).

To specify the Script Manager variable whose value you wish to change, use one of the
selector constants listed on page 6-61.

RESULT CODES

noErr
smBadVerb

0
1

No error
Invalid selector passed to the routine

Checking and Setting Script Variables
Each enabled script system maintains a set of variables that control the current settings of
that script system, including the ID numbers of its international resources, its preferred
fonts and font sizes, and its primary line direction.
You may want access to the script variables in order to conform to the script@ current
settings or to modify them. The Get Script Variable function retrieves the values of
the script variables, and the SetScriptVariable

function sets their values. (The

variables themselves are private and you cannot access them directly.) When you call
either routine, you use a selector to describe the variable that interests you. The integer
constants for allde

ned GetScriptVariable/SetScriptVariable

described on page 6-65.

6-78

Script Manager Reference

selectors are

CHAPTER

6

Script Manager

GetScriptVariable
The Get ScriptVariable function retrieves the value of the speci
from the speci ed script system.
FUNCTION

GetScriptVariable

(script:

ed script variable

ScriptCode;

selector:

Integer):

LongInt;

script

A value that speci

es the script system whose variable you are accessing.

selector

Avvalue that speci

esa particular script variable.

DESCRIPTION

Although Get Script Variable always returns a long integer, the actual value may bea
long integer, standard integer, or signed byte. If the value is not a long integer, it is stored
in the low-order word or byte of the long integer returned by Get Script Variable; the
remaining bytes are set to 0.
Valid selector values are de ned by each script system. Get ScriptVariable returns 0
if the selector value is invalid or if the speci ed script system is not installed.
Note
For some valid selectors, 0 may also be a valid return value.

For example, calling

Get Script Variable

with a selector of

smScriptLang ona version of Macintosh system software that has been
localized for the United States returns 0.

To specify the script variable whose value you need, use one of the selector
constants listed on page 6-65. To specify the script system, use one of the
script-code constants listed on page 6-52.

SetScript Variable
The Set ScriptVariable function sets the speci ed script variable for the specifed
script system to the value of the input parameter.
FUNCTION

SetScriptVariable

(script:

ScriptCode;

param:

LongInt):

selector:

Integer;

OSErr;

script

A value that speci

es the script system whose variable you are setting.

selector

Avalue that speci

esa

param

The new value for the speci

Script Manager Reference

particular script variable.
ed script variable.

6-79

CHAPTER

6

Script Manager

DESCRIPTION

The actual values to be assigned may be long integers, standard integers, or signed bytes.
If the value is not a long integer, you must store it in the low-order word or byte of the
param parameter and set the unused bytes to 0.
The

Set Script Variable

function returns the value smBadVerb if the selector is not

valid, and smBadScript if the script is invalid. Otherwise, it returns 0 (noErr).
To specify the script variable whose value you wish to change, use one of the
selector constants listed on page 6-65. To specify the script system, use one of
the script-code constants listed on page 6-52.

RESULT CODES

noErr
smBadVerb
smBadScript

0
1
2

No error
Invalid selector passed to the routine
Invalid script code passed to the routine

Making Keyboard Settings
The Script Manager provides the KeyScript procedure to let you specify the current
keyboard script (the script system used for keyboard input), keyboard layout (the
mapping of keys to characters), or input method (a facility for entering 2-byte characters),
and to make various settings related to text input.
For the purposes of KeyScript, keyboard layout means a keyboard-layout (' KCHR')
resource, plus optionally a key-remap ('it1k') resource. To change keyboard layouts
means to change the current keyboard-layout resource.

KeyScript
The KeyScript procedure uses the supplied value to change the keyboard script, to
change the keyboard layout or input method within the current keyboard script, or to
make a setting related to text input. If the Keyboard menu is displayed, KeyScript also
updates the Keyboard menu.
PROCEDURE

code

KeyScript

(code:

Integer) ;

If 0 or positive, directly speci es a script system (that is, it is read as a
script code). Negative values have special meanings.

DESCRIPTION

The Keyscript procedure makes the change based on the selector with which it is
called. If more than one script system is enabled or if the smf ShowI con bit fag is set in
the Script Manager variable accessed by the Get ScriptManagerVariable selector

6-80

Script Manager Reference

CHAPTER

6

Script Manager

smGenF lags, Keyscript also updates the Keyboard menu by changing the icon
displayed on the menu bar and placing a check beside the appropriate keyboard
menu item.
The code parameter is a selector that can explicitly specify a keyboard script by script
code. Script code constants are listed on page 6-52. If the selector speci es a script, then
the current default keyboard layout ('KCHR' resource) for that script, as speci ed in the
script@ international bundle resource, becomes the current keyboard layout.
The selector can also implicitly specify a keyboard script (for example, the next script), a
keyboard layout (for example, the previously used keyboard layout in the current script),
or an input method (for example, inline input versus window-based input). It can also
specify settings that enable or disable keyboard layouts and keyboard scripts, and toggle
among input options or line direction. The valid constants for the code parameter are
listed in Table 6-5 on page 6-18.
If you call KeyScript and explicitly specify a script system that is not available,
KeyScript does nothing. The current keyboard script remains unchanged.

SPECIAL CONSIDERATIONS

KeyScript operates only on those keyboard-layout and key-remap resources that are
present in the System le.
Your application@ keyboard-menu setting is not maintained by the Process Manager; if
the state of the keyboard menu is changed while you are switched out, the Process
Manager does not restore your setting when you are switched back in. However, the
Process Manager does maintain the keyboard disable state (Script Manager variable
smKeyDisableState) for your application. See electors for Script Manager
VariablesObeginning on page 6-61 for a description of the smKeyDisableState
variable.
KeyScript may move memory; your application should not call this procedure at
interrupt time.

SEE ALSO

The Process Manager is described in Inside Macintosh: Processes.
Determining Script Codes From Font Information
The Font Script, FontToScript, and Int1Script functions give you ways to
determine a script code from font information. This information is subject to two control
SagsN the font force Sag and the international resources selection Sag. You can test and
set these Sags with the GetScriptManagerVariable
SetScriptManagerVariable

selectors smFont Force

and
and smInt1Force.

For more

information on the font force 8ag, see (Using the Font Force FlagOon page 6-24. For
more information on the international resources selection Bag, see Using the
International Resources Selection FlagOon page 6-25.

Script Manager Reference

6-81

CHAPTER

6

Script Manager

The routines start by initializing two result fags, the script-forced result Sag and
the script-defaulted result Sag, to FALSE. These fsags are Script Manager variables,
accessed through the

and smDefault.

Get ScriptManagerVariable function selectors smForced

FontScript
The Font Script function returns the script code for the current script. The current
script is usually the font script.
FUNCTION

FontScript:

Integer;

DESCRIPTION

The FontScript function returns a script code. All recognized script codes and their
de ned constants are listed on page 6-52. Font Script returns only explicit script codes
(2 0).
If the font of the active graphics port is Roman and the font force Sag is TRUE, the script
code returned is that of the system script and the script-forced result Sag is set to TRUE.
If the font of the active graphics port is non-Roman, the state of the font force Sag is
ignored.
If the script system corresponding to the font of the active graphics port is not installed
and enabled, the script code returned is that of the system script and the script-defaulted
result Sag is set to TRUE.

SPECIAL CONSIDERATIONS

FontScript may move memory; your application should not call this function at
interrupt time.

FontToScript
The Font ToScript function translates a font family ID number into its corresponding
script code, if that script system is currently enabled.
FUNCTION

FontToScript

(fontNumber:

fontNumber

A font family ID number.

6-82

Script Manager Reference

Integer):

Integer;

CHAPTER

6

Script Manager

DESCRIPTION

The Font ToScript function returns a script code. All recognized script codes and their
de ned constants are listed on page 6-52. Font ToScript returns only explicit script
codes (2 0).
If fontNumber is in the Roman range and the font force Sag is TRUE, the script code
returned is that of the system script and the script-forced result Sag is set to TRUE.
If

fontNumber is in the non-Roman range, the state of the font force fsag is ignored.

If the script system corresponding to font Number is not enabled, the script code
returned is that of the system script and the script-defaulted result Sag is set to TRUE.

SPECIAL CONSIDERATIONS

FontToScript may move memory; your application should not call this function at
interrupt time.

IntlScript
The Int1Script function identi es the script system used by the Text Utilities
date-formatting, time-formatting, and string-sorting routines. It also identi es the script
system whose resources are returned by the Script Manager function
Get Int 1Resource. It is either the font scriptN the script system corresponding to the
current font of the active graphics portN or the system script.
FUNCTION

IntlScript:

Integer;

DESCRIPTION

The Int1Script function returns a script code. All recognized script codes and their
de ned constants are listed on page 6-52. Int 1Script returns only explicit script
codes (2 0).
If the international resources selection fsag is TRUE, the script code returned is that of the
system script.
If the identi ed script system is not enabled, the script code returned is that of the system
script and the script-defaulted result fsag is set to TRUE.

SPECIAL CONSIDERATIONS

IntlScript may move memory; your application should not call this function at
interrupt time.

Script Manager Reference

6-83

CHAPTER

6

Script Manager

Analyzing Characters
This section describes the functions CharacterByteType,

CharacterType, and

FillParseTable, which give you information about a character or group of characters,
speci ed by character code:

m
m

The CharacterByteType function identi

character or as the

es a byte in a text buffer as a 1-byte

rst or second byte of a 2-byte character.

The CharacterType function returns speci

particular byte offset.

c information about the character at a

m The FillParseTable function Ils a 256-byte table that indicates, for each possible
byte value, whether it is the rst byte of a 2-byte character.
The script system associated with the character you wish to examine must be enabled in
order for any of these three routines to provide useful information. For example, if only
the Roman script system is available and you attempt to identify a byte in a run of 2-byte
characters, the CharacterByteType function returns 0, indicating that the byte is a

1-byte character.

1-byte script systems
For 1-byte script systems, the character-type tables reside in the
string-manipulation ('it12') resource and refSect region-speci c or
language-speci c differences in uppercase conventions. The
CharacterType function gets the tables from the string-manipulation
resource using the Get Int lLResource function. @
2-byte script systems
For 2-byte script systems, the character-type tables reside in the
encoding /rendering ('it15') resource, not the string-manipulation
resource. Whenever you call CharacterByteType,

CharacterType,

or FillParseTable, the necessary character-set encoding information
is taken from the encoding/rendering resource. You cannot use the
Get Int1lResource function to access 2-byte character-type
tables directly.

CharacterByteType
The CharacterByteType function identi

or asthe

es a byte in a text buffer as a 1-byte character

rst or second byte of a 2-byte character.

FUNCTION

CharacterByteType

(textBuf:
script:

textBuf
textOffset

6-84

Ptr;

textOffset:

ScriptCode):

A pointer to a text buffer containing the byte to be identi
The offset to the byte to be identi
byte has an offset of 0.

Script Manager Reference

Integer;

Integer;

ed.

ed. Offset is measured in bytes; the

rst

CHAPTER

6

Script Manager

script

A value that speci es the script system of the text in the buffer. Constants
for all de ned script codes are listed on page 6-52. To specify the font
script, pass smCurrentScript in this parameter.

DESCRIPTION

CharacterByteType returns one of three identi

cations: a 1-byte character, the

rst

byte of a 2-byte character, or the second byte of a 2-byte character. The rst byte ofa
2-byte characterN the one at the lower offset in memoryN is the high-order byte; the
second byte of a 2-byte characterN the one at the higher offsetN is the low-order byte.
This is the same order in which text is processed and numbers are represented.

From byte value alone, it is not possible to distinguish the second byte of a 2-byte
character from a 1-byte character. See the discussion of character encoding in the chapter
Cntroduction to Text on the MacintoshOin this book. CharacterByteType

differentiates the second byte of a 2-byte character from a 1-byte character by assuming
that the byte at offset 0 is the rst byte of a character. With that assumption, it then
sequentially identi es the size and starting position of each character in the buffer up to
textOffset.

SPECIAL CONSIDERATIONS

If you specify smCurrentScript for the script parameter, the value returned by
CharacterByteType can be affected by the state of the font force fag. It is unaffected

by the state of the international resources selection fag.
RESULT CODES
smFirstByte

smSingleByte

1

First byte of a 2-byte character

1

Second byte of 2-byte character

0

smLastByte

1-byte character

CharacterType
The CharacterType function returns a variety of information about the character
represented by a given byte, including its type, class, orientation, direction, case, and size
(in bytes).
FUNCTION

CharacterType

(textBuf:
script:

textBuf
textOffset

Ptr;

textOffset:

ScriptCode):

Integer;

Integer;

A pointer to a text buffer containing the character to be examined.
The offset to the location of the character to be examined. (It can be an
offset to either the rst or the second byte of a 2-byte character.) Offset is
in bytes; the rst byte of the rst character has an offset of 0.

Script Manager Reference

6-85

CHAPTER

6

Script Manager

script

A value that speci es the script system the byte belongs to. Constants for
all de ned script codes are listed on page 6-52. To specify the font script,
pass smCurrent Script in this parameter.

DESCRIPTION

The CharacterType return value is an integer bit eld that provides information about
the requested character. The eld has the following format:
range

Name

Explanation

03

Type

Character types

47

(reserved)

8 11

Class

Character classes ( = subtypes)

12

Orientation

Horizontal or vertical

13

Direction

Left or right

14

Case

Uppercase or lowercase

15

Size

1-byte or 2-byte

" In 2-byte script systems, bit 13 indicates whether or not the character is part of the main
character set (not a user-de ned character).

The Script Manager de nes the recognized character types, character classes, and
character modi ers (bits 12 15), with constants to describe them. All of the constants are
listed and described in the section GGetting Character-Type InformationObeginning on
page 6-28.
The Script Manager also de nes a set of masks with which you can isolate each of the
elds in the CharacterType return value. If you perform an AND operation with the
CharacterType result and the mask for a particular eld, you select only the bits in that
eld. Once you@e done that, you can test the result, using the constants that represent
the possible results.
The CharacterType

eld masks are the following:

Mask

Hex. value

Explanation

smcTypeMask

$000F

Character-type mask

smcReserved

$00F0

(reserved)

smcClassMask

$000

Character-class mask

smcOrientationMask

$1000

Character orientation (2-byte scripts)

smcRightMask

$2000

Writing direction (bidirectional scripts)

smcUpperMask

$4000

Uppercase or lowercase

smcDoubl eMask

$8000

Size (1 or 2 bytes)

Main character set or subset (2-byte scripts)

The character type of the character in question is the result of performing an AND
operation with smcTypeMask and the CharacterType result. Constants for the de

character types are listed on page 6-28.
6-86

Script Manager Reference

ned

CHAPTER

6

Script Manager

The character class of the character in question is the result of performing an AND
operation with smcClassMask and the CharacterType result. Character classes can be

considered as subtypes of character types. Constants for the de ned character classes are
listed on page 6-29.
The orientation of the character in question is the result of performing an AND operation

with smcOrientationMask and the CharacterType result. The orientation value can
be either smCharHorizontal or smCharVertical.

The direction of the character in question is the result of performing an AND operation
with smcRightMask and the CharacterType result. The direction value can be either
smCharLeft (left-to-right) or smCharRight (right-to-left).

The case of the character in question is the result of performing an AND operation with
smcUpperMask and the CharacterType result. The case value can be either
smCharLower

or smCharUpper.

The size of the character in question is the result of performing an AND operation
with smcDoubleMask and the CharacterType result. The size value can be either
smCharlbyte

or smChar2byte.

Note
CharacterType calls CharacterByteType to determine whether the

byte at textOffset is a 1-byte character or the rst byte or second byte
of a 2-byte character. The larger the text buffer, the longer
CharacterByteType takes to execute. To be most ef cient, place the

pointer text Buf at the beginning of the character of interest before
calling CharacterType. (If you want to be compatible with older

versions of CharacterType, also set textOffset to 1, rather than 0,

for 2-byte characters.) @

SPECIAL CONSIDERATIONS

CharacterType may move memory; your application should not call this function
at interrupt time.
If you specify smCurrentScript

for the script parameter, CharacterType

always assumes that the text in the buffer belongs to the font script. It is unaffected
by the state of the font force Sag or the international resources selection fag.
For 1-byte script systems, the character-type tables are in the string-manipulation
('it12') resource. For 2-byte script systems, they are in the
encoding /rendering ('it15') resource. If the appropriate resource does not
include these tables, CharacterType exits without doing anything.
Some Roman fonts (for example, Symbol) substitute other characters for the
standard characters in the Standard Roman character set. Since the Roman script system
CharacterType function assumes the Standard Roman character set, it may return

inappropriate results for nonstandard characters.

In versions of system software earlier than 7.0, the textOffset parameter to the

CharacterType function must point to the second byte of a 2-byte character.

Script Manager Reference

6-87

CHAPTER

6

Script Manager

RESULT CODES

The complete set of CharacterType return values is found in the section

GGetting Character-Type InformationObeginning on page 6-28.

FillParseTable
The FillParseTable function helps your application to quickly process a buffer of
mixed 1-byte and 2-byte characters. It returns a 256-byte table that distinguishes the
character codes of all possible 1-byte characters from the rst (high-order) byte values of
all possible 2-byte characters in the speci ed script system.
FUNCTION

FillParseTable

(VAR

table:

script:

CharByteTable;

ScriptCode):

Boolean;

table

A 256-byte table to be

Iledin by FillParseTable.

script

A value that speci es the script system the parse table belongs to.
Constants for all de ned script codes are listed on page 6-52. To specify
the font script, pass smCurrentScript in this parameter.

DESCRIPTION

Before calling Fill ParseTable, allocate space for a 256-byte table to pass to the
function in the table parameter.
The information returned by Fill ParseTable is a packed array de ned by the
CharByteTable data type as follows:
CharByteTable

=

PACKED

ARRAY[0..255]

OF

SignedByte;

In every script system, 2-byte characters have distinctive high-order (_ rst) bytes that
allow them to be distinguished from 1-byte characters. FillParseTable lls a 256-byte
table, conceptually equivalent to a 1-byte character-set table, with values that indicate,
byte-for-byte, whether the character-code value represented by that byte index is the rst
byte of a 2-byte character. An entry in the CharByteTab1e is 0 for a 1-byte character and
1 forthe rst byte of a 2-byte character.
If your application is processing mixed characters, it can use the table to identify the
locations of the 2-byte characters as it makes a single pass through the text, rather than
having to call CharacterByteType or CharacterType for each byte of the text buffer
in turn. CharacterByteType and CharacterType start anew at the beginning of the

text buffer each time they are called, tracking character positions up to the offset of the
byte to be analyzed.

6-88

Script Manager Reference

CHAPTER

6

Script Manager

SPECIAL CONSIDERATIONS

FillParseTable may move memory; your application should not call this function at
interrupt time.

The table de ned by CharByteTab1le is not dynamic; it does not get updated when the
current font changes. You need to call it separately for each script run in your text.
The return value from FillParseTable

is always TRUE.

If you specify smCurrentScript for the script parameter, the value returned by
FillParseTable can be affected by the state of the font force fag. It is unaffected by
the international resources selection Sag.

Directly Accessing International Resources
You can access the International resources (resource types

'it10',

'itl1','itl2',

'1t14',and 'it15') with the Get Intl Resource function. You can access speci c
tables within an international resource with the Get Int lResourceTable procedure. If
your application provides its own 'it12' or 'it14' resources, it should call the
ClearInt1lResourceCache procedure before accessing those resources.

ClearIntlResourceCache
The ClearInt1ResourceCache procedure clears the application@ international
resources cache, which contains the resource ID numbers of the string-manipulation
('it12') and tokens ('it14') resources for the current script.
PROCEDURE

ClearIntlResourceCache;

DESCRIPTION

At application launch, the script management system sets up an international resources
cache for the application. The cache contains the resource ID numbers of the
string-manipulation and tokens resources for all enabled scripts.
If you provide your own string manipulation or tokens resource to replace the default for
a particular script, call ClearIntlResourceCache at launch to ensure that your
supplied resource is used instead of the script system@ 'it12' or 'it14' resource.
The current default ID numbers for a script system@ 'it12' and 'it14' resources are
stored in its script variables. You can read and modify these values with the
GetScriptVariable and SetScriptVariable functions using the selectors
smScriptSort (for the 'it12' resource) and smScriptToken (for the '1t14'

resource). Before calling ClearInt1ResourceCache, you should set the script@ default
ID number to the ID of the resource that you are supplying.

Script Manager Reference

6-89

CHAPTER

6

Script Manager

If the international resources selection fsag is TRUE, the ID numbers of your supplied
resources must be in the system script range. Otherwise, the [Ds must be in the range of
the current script.
IMPORTANT

If you use the Set ScriptVariable function to change the
value of the 'it12' or 'i1t14' resource ID and then call
ClearInt1ResourceCache to fush the cache, be sure to
restore the original resource ID before your application quits. a
SPECIAL CONSIDERATIONS

ClearInt1lResourceCache may move memory; your application should not call this
procedure at interrupt time.

GetIntlResource
The Get Int 1Resource function returns a handle to one of the following international
resources: numeric-format ('it10'), long-date-format ('it11'), string-manipulation
('it12'), tokens ('1t14'), or encoding/rendering ('1t15'). GetIntlResource

selects the resource of the requested type for the current script.
FUNCTION

GetIntlResource

theID

(theID:

Integer)

:Handle;

Contains an integer (0, 1, 2, 4, or 5 respectively for the

'i3t12',

'1t10','it11',

'it14',and 'it15'resources) to identify the type of the

desired international resource.

DESCRIPTION
The Get Int 1Resource function returns a handle to the correct resource of the
requested type. The resource returned is that of the current script, which is either the font
script or the system script. See (Determining Script Codes From Font InformationOon
page 6-21.
If Get Int LResource cannot return the requested resource, it returns a NIL handle and
sets the global variable resErr to the appropriate error code.

SPECIAL CONSIDERATIONS

Get IntlResource may move memory; your application should not call this function at
interrupt time.

6-90

Script Manager Reference

CHAPTER

6

Script Manager

SEE ALSO
See the Resource Manager chapter in Inside Macintosh: More Macintosh Toolbox for
information on resErr and how to get its value.

GetIntlResourceTable
The Get Int lResourceTable procedure gives you access to a speci _c word-selection,
line-break, number-parts, untoken, or whitespace table from the appropriate
international resource.
PROCEDURE

GetIntlResourceTable

(script:

ScriptCode;

tableCode:

Integer;

VAR

itlHandle:

Handle;

VAR

offset:

LongInt;

VAR

length:

LongInt) ;

script

A script code, the value that speci es a particular script system. Constants
for all de ned script codes are listed on page 6-52.

tableCode

Anumber that speci

itlHandle

Uponcompletion of the call, contains a handle to the string-manipulation
('it12') or tokens ('1t14') resource containing the table speci ed in
the tableCode parameter.

offset

Upon completion of the call, contains the offset (in bytes) to the speci
table from the beginning of the resource.

length

Upon completion of the call, contains the size of the table (in bytes).

es which table is requested.

ed

DESCRIPTION
When you provide a script code in the script parameter, and a table code in the
tableCode parameter,

Get Int lResourceTable returns a handle to the

string-manipulation resource or tokens resource containing that table, the offset of the
speci ed table from the beginning of the resource, and the length of the table.
If the script system whose table is requested is not available,
returns a NIL handle.

Get Int LResourceTable

Constants for all de ned script codes are listed on page 6-52.

Script Manager Reference

6-91

CHAPTER

6

Script Manager

These are the de

ned constants for tableCode:

Constant

Value

Explanation

smWordSelectTable

0)

Word-break table

smWordWrapTable

1

Line-break table

smNumberPartsTable

2

Number-parts table

smUnTokenTable

3

Untoken table

smWhiteSpaceList

4

Whitespace table

If you wish to manipulate the contents of the table you have requested, use the size
returned in the length parameter to allocate a buffer, and perform a block move of the
table@ contents into that buffer.

SPECIAL CONSIDERATIONS

Get IntlResourceTable may move memory; your application should not call this
procedure at interrupt time.

SEE ALSO

Block moves are described in the Memory Manager chapter of Inside Macintosh:
Memory.
Tokenization
The Script Manager provides a way to take programming-language text in an arbitrary
script system and break it into tokens: language-independent symbols that can be used as
input to a parser. The Int 1Tokenize function uses information in a script system@
tokens ('it14') resource to convert text to tokens that stand for names, symbols,
comments, and quoted literals.

IntlTokenize
The Int 1Tokenize function allows your application to convert text into a sequence of
language-independent tokens. It returns a list of tokens that correspond to the text that
you pass it.
FUNCTION
tokenParam

IntlTokenize

(tokenParam:

TokenBlockPtr):

A pointer to a token block record. The record speci

TokenResults;

es the text to be

converted to tokens, the destination of the token list, a handle to the
tokens ('it14') resource, and a set of options.

6-92

Script Manager Reference

CHAPTER

6

Script Manager

The token block record is a parameter block and a data structure of type TokenBlock,
described on page 6-74. You specify input values and receive return values in as
shown here:
Parameter block
SOULrCE

Ptr

>

sourceLength

LongiInt

ard

tokenList

Ptr

A pointer to the beginning of the source
text (not a Pascal string) to
be converted.
The number of bytes in the source text.
A pointer to a buffer you have

LongiInt

Int 1Tokenize
function places the list
of token records it generates.
The maximum size of token list (in

=>

tokenLength

allocated, into which the

number of tokens, not bytes) that will

t into the buffer pointed to by the
tokenList eld.

tokenCount

LongiInt

On input: If doAppend
= TRUE, must

contain the correct number of tokens
currently in the token list. (Ignored if
doAppend
= FALSE.)

On output: The number of tokens
currently in the token list.
stringList

Ptr

stringLength

LongiInt

stringCount

LongiInt

If doString
= TRUE, must contain a

pointer to a buffer into which
Int1lTokenize
can place a list of
strings it generates. (Ignored if

doString = FALSE.)

If

doString

= TRUE, must contain the

size in bytes of the string list buffer
pointed to by the stringList eld.
(Ignored if doString = FALSE.)
On input: If doString
= TRUE and
doAppend
= TRUE, must contain the

correct current size in bytes of the

string list. Ignored if doString =
FALSE or doAppend
= FALSE.)

On output: The current size in bytes of
the string list. (Indeterminate if

doString = FALSE.)

doString

Boolean

If TRUE, instructs

Int lTokenizeto

doAppend

Boolean

If TRUE, instructs

Int lTokenizeto

create a Pascal string representing the
contents of each token it generates.
If FALSE, Int lTokenize generates
a token list without an associated string
list.
append tokens and strings it generates
to the current token list and string list.
If

FALSE,

Int lTokenize
writes over

any previous contents of the buffer
pointed to by tokenList
and
stringList.

Script Manager Reference

6-93

CHAPTER

6

Script Manager

>

doAlphanumeric

If TRUE, instructs Int lTokenizeto
interpret numeric characters as

Boolean

alphabetic when mixed with alphabetic

characters. If FALSE, all numeric

characters are interpreted as numbers.
>

doNest

If TRUE, instructs

Boolean

Int lTokenizeto

allow nested comments (to any depth
of nesting).
If FALSE, comment

delimiters may not be nested within
other comment delimiters.

>

leftDelims

DelimType

An array of two integers, each of which

>

rightDelims

DelimType

delimPad.
An array of two integers, each of which

>

leftComment

Comment Type

>

right Comment

Comment Type

>

escapeCode

TokenType

>

decimalCode

TokenType

>

itlResource

Handle

>

reserved

ARRAY

[0..7]

LongInt

contains the token code of the symbol
that may be used as an opening
delimiter for a quoted literal. If only
one opening delimiter is needed, the
other must be speci ed to be

OF

contains the token code of the symbol
that may be used as the matching
closing delimiter for the corresponding
opening delimiter in the leftDelims
eld.
An array of two pairs of integers, each
pair of which contains codes for the
two token types that may be used as
opening delimiters for comments.
An array of two pairs of integers, each
pair of which contains codes for the
two token types that may be used as
closing delimiters for comments.
A single integer that contains the token
code for the symbol that may be an
escape character within a quoted literal.
A single integer that contains the token
type of the symbol to be used fora
decimal point.
A handle to the tokens ('it14')
resource of the script system under
which the source text was created.
Must
be set to 0.

DESCRIPTION

The Int 1Tokenize function returns a list of tokens that correspond to the input
text. The token list is an array of token records (type TokenRec). Each token record
describes the token generated, speci es the part of the source text it came from, and
optionally provides a character string that is a normalized version of the text that
generated the token.

6-94

Script Manager Reference

CHAPTER

6

Script Manager

Int 1Tokenize also returns a result code that speci

es the type of error that

occurred, if any.

Before calling the Int 1Tokenize function, allocate memory for and set up the following
data structures:
m A token block record (data type TokenBlock). The token block record is a parameter
block that holds both input and output parameters for the Int 1Tokenize function.
m A token list to hold the results of the tokenizing operation. To set up the token list,
estimate how many tokens will be generated from your text, multiply that by the size
of a token record, and allocate a memory block of that size in bytes. An upper limit to
the possible number of tokens is the number of characters in the source text.
m Astring list, if you want the Int1Tokenize function to generate character strings for
all the tokens. To set up the string list, multiply the estimated number of tokens by the
expected average size of a string, and allocate a memory block of that size in bytes. An
upper limit is twice the number of tokens plus the number of bytes in the source text.
Int 1Tokenize creates tokens based on information in the tokens ('it14') resource

of the script system under which the source text was created. You must load the tokens
resource and place its handle in the token block record before calling the Int 1Tokenize
function.
The token block record contains both input and output values. At input, you must
provide values for the elds that specify the source text location, the token list location,
the size of the token list, the tokens ('it14') resource to use, and several options that

affect the operation. You must set reserved locations to 0 before calling Int 1Tokenize.

On output, the token block record speci es how many tokens have been generated and
the size of the string list (if you have selected the option to generate strings).
The results of the tokenizing operation are contained in the token list, an array of token
records. A token record (data type TokenRec) consists of a token code, a pointer to a
location in the source text, the length of a character sequence in the source text, and an
optional pointer to a Pascal string:
TYPE

TokenRec

=

RECORD

theToken:
position:

TokenType;
Ptr;

length:

LongInt ;

stringPosition:

StringPtr;

{numeric code for token}
{pointer to source text from }
{ which token was generated}
{length of source text from }
{ which token was generated}
{pointer to Pascal string }
{ generated from token}

END;

TokenRecPtr

=

Script Manager Reference

“TokenRec;

6-95

CHAPTER

6

Script Manager

Field descriptions

theToken

position
length
stringPosition

The token code that speci es the type of token (such as whitespace,
opening parenthesis, alphabetic or numeric sequence) described by
this token record. Constants for all de ned token codes are listed on
page 6-58.
A pointer to the rst character in the source text that caused this
particular token to be generated.
The length in bytes of the source text that caused this particular
token to be generated.
If doString = TRUE, a pointer to a null-terminated Pascal

string, padded if necessary so that its total number of bytes
(length byte + text + null byte + padding) is even. If
doString = FALSE, this

eldis NIL.

Note
The value in the length byte of the null-terminated Pascal string
does not include either the terminating zero byte or the possible
additional padding byte. There may be as many as two additional
bytes beyond the speci ed length.
Pascal strings are generated if the doSt ring parameter in the token block record is set to
TRUE. The string is a normalized version of the source text that generated the token;
alternate digits are replaced with ASCII numerals, the decimal point is always an ASCII
period, and 2-byte Roman letters are replaced with low-ASCII equivalents.
To make a series of calls to

Int 1Tokenize and append the results of each call to the

results of previous calls, set doAppend to FALSE and initialize tokenCount and

stringCount to 0 before making the rst call to Int 1Tokenize. (You can ignore
stringCount if you set doString to FALSE.) Upon completion of the call,
tokenCount and stringCount will contain the number of tokens and the length in
bytes of the string list, respectively, generated by the call. On subsequent calls, set
doAppend to TRUE, reset the source and sourceLength parameters (and any other

parameters as appropriate) for the new source text, but maintain the output values for
tokenCount and stringCount from each call as input values to the next call. At the
end of your sequence of calls, the token list and string list will contain, in order, all the
tokens and strings generated from the calls to Int 1lTokenize.
If you are making tokens from text that was created under more than one script system,
you must load the proper tokens resource and place its handle in the token block record
separately for each script run in the text, appending the results each time.
Delimiters for quoted literals are passed to Int 1Tokenize in a two-integer array:
TYPE

DelimType

=

ARRAY[0..1]

The individual delimiters, as speci

6-96

Script Manager Reference

TokenType;

ed in the leftDelims and rightDelims

parameters, are paired by position. The
leftDelims is paired with the

OF

rst (in storage order) opening delimiter in

rst closing delimiter in rightDelims.

CHAPTER

6

Script Manager

Comment delimiters may be 1 or 2 tokens each and there may be two sets of opening and
closing pairs. They are passed to Int 1Tokenize ina commentType array:
TYPE

CommentType

=

ARRAY[0..3]

OF

TokenType;

If only one token is needed for a delimiter, the second token must be speci

ed to be

delimPad. If only one delimiter of an opening-closing pair is needed, then both of the
tokens allocated for the other symbol must be delimPad. The rst token of a two-token
sequence is at the higher position in the left Comment or rightComment array. For
example, if the two opening (in this case, left) delimiters were O( *Oand O{Q they would
be speci ed as follows:
leftComment
[0]

:=

tokenAsterisk;

(*asterisk*)

leftComment
[1]

:=

tokenLeftParen;

(*left

leftComment
[2]

:=

delimPad

(*nothing* )

leftComment
[3]

:=

tokenLeftCurly;

;

(*curly

parenthesis*)
brace*)

When Int1Tokenize encounters an escape character within a quoted literal, it places
the portion of the literal before the escape character into a single token (of type
tokenLiteral), places the escape character into another token (tokenEscape), places
the character following the escape character into another token (whatever token type it
corresponds to), and places the portion of the literal following the escape sequence into
another token (tokenLiteral). Outside of a quoted literal, the escape character has no

special signi cance.

Int 1Tokenize considers the character speci ed in the decimalCode parameter to be a
decimal character only when it is Sanked by numeric or alternate numeric characters, or
when it follows them.

SPECIAL CONSIDERATIONS

IntlTokenize may move memory; your application should not call this function at
interrupt time.
Because each call to Int 1Tokenize must be for a single script run, there can be no
change of script within a comment or quoted literal.
Comments and quoted literals must be complete within a single call to Int lTokenize
in order to avoid syntax errors.
Int 1Tokenize always uses the tokens resource whose handle you pass it in the token
block record. Therefore, it is not directly affected by the state of the font force Sag or the
international resources selection fsag. However, if you use the Get Int l[Resource
function to get a handle to the tokens resource to pass to Int 1Tokenize, remember that
Get Int 1Resource is affected by the state of the international resources selection fag.
See (Determining Script Codes From Font InformationObeginning on page 6-21.

Script Manager Reference

6-97

CHAPTER

6

Script Manager

RESULT CODES

tokenOK
tokenOverflow

Q
1

stringOverflow

2

badDelim

3

badEnding
crash

4
5

Valid token
Number of tokens exceeded maximum speci

tokenList
eld of token block record
Size of string list larger than maximum speci
stringList
eld of token block record
Invalid delimiter

ed in
ed in

(currently unused)
Unknown error

SEE ALSO

See the appendix Cnternational ResourcesOin this book for a description of the tokens
('it14"') resource.

Transliteration
Transliteration is the conversion of text from one form or subscript to another within a
single script system. In the Roman script system, transliteration means case conversion.
In 2-byte script systems, it is the automatic conversion of characters from one subscript to
another. One common use for transliteration is as an initial stage of text conversion
for an input method.

TransliterateText
The TransliterateText function converts characters from one subscript to the closest
possible approximation in a different subscript within the same 2-byte script system.
TransliterateText also performs uppercasing and lowercasing, with consideration
for regional variants, in the Roman script system and on Roman text within 2-byte
script systems.
FUNCTION

6-98

TransliterateText

(srcHandle:

Handle;

dstHandle:

Handle;

target:

Integer;

srcMask:

script:

ScriptCode):

LongInt;

OSErr;

srcHandle

A handle to the source text to be transliterated.

dstHandle

Ahandle toa buffer that, upon completion of the call, contains the
transliterated text.

target

A value that speci es what kind of text the source text is to be
transliterated into. The low byte of the target is the format to convert
to. The high byte contains modi ers, whose meanings depend on the
script code.

Script Manager Reference

CHAPTER

6

Script Manager

srcMask

A bit array that speci es which parts of the source text are to be
transliterated. A bit is set for each script system or subscript that should be
converted.

script

A value that speci es the script system of the text to be transliterated.
Constants for all de ned script codes are listed on page 6-52. To specify
the font script, pass smCurrentScript in this parameter.

DESCRIPTION

The types of conversions TransliterateText performs are described in the section
CfransliterationObeginning on page 6-43.
The TransliterateText function converts all of the text that you pass it in the
srcHandle parameter. It determines the length of the source text (in bytes) from the
handle size.
Before calling TransliterateText, allocate a handle (of any size) to pass in the
dstHandle parameter. The length of the transliterated text may be different (as when
converting between 1-byte and 2-byte characters), and TransliterateText sets the
size of the destination handle as required. It is your responsibility to dispose of the
destination handle when you no longer need it.
The srcMask parameter is the source mask; it speci es which subscript(s) represented in
the source text should be converted to the target format. In all script systems, the
srcMask parameter may have the following values: smMaskAscii, smMaskNative,
and smMaskA11, as described on page 6-46. In 2-byte script systems, additional values
are recognized, as described on page 6-46.
The low-order byte of the target parameter is the target format; it determines what
form the the text should be transliterated to. In all script systems, there are two currently
supported values for target format: smTransAscii and smTransNative, as described
on page 6-46. In 2-byte script systems, additional values are recognized, as described
on page 6-47.
The high-order byte of the target parameter is the target modi er; it provides
additional formatting instructions. In all script systems, there are two values for target
modifer: smTransLower and smTransUpper, as described on page 6-47.
Note
Because the low-ASCII character set (character codes $20 $7F) is present
in all script systems, you could theoretically use the
TransliterateText function to convert characters from one script
system into another completely different script system. You could
transliterate from a native subscript into ASCII under one script system,
and then transliterate from that ASCII into a native subscript under a
different script system. Such a procedure is not recommended, however,
because of the imperfect nature of phonetic translation. Furthermore,
many script systems do not support transliteration from native
subscripts to ASCII. @

Script Manager Reference

6-99

CHAPTER

6

Script Manager

SPECIAL CONSIDERATIONS

TransliterateText may move memory; your application should not call this function
at interrupt time.
If you pass smCurrent Script in the script parameter, the conversion performed by
TransliterateText can be affected by the state of the font force fag. It is unaffected
by the international resources selection fag.
Transliteration of a block of text does not work across script-run boundaries. Because the
TransliterateText function requires transliteration tables that are in a script system@
international resources, you need to call it anew for each script run in your text.
Currently, the Roman version of TransliterateText checks the source mask only to
ensure that at least one of the bits corresponding to the smMaskAscii and
smMaskNative constants is set.
The Arabic and Hebrew versions of TransliterateText perform case conversion only.
They allow the target values smTransAscii and smTransNative only; otherwise, they
behave like the Roman version.
The TransliterateText tables for 1-byte script systems reside in the
script@ string-manipulation ('it12') resource, so they can reBect region-speci c
or language-speci c differences in uppercase conventions. If the string-manipulation
resource does not include these tables, TransliterateText

doing anything.

exits without

The TransliterateText tables for 2-byte script systems reside in the script@
transliteration ('trs1') resource. If the 'trs1' resource does not include these tables,
TransliterateText

exits without doing anything.

The Japanese, Traditional Chinese, and Simpli

ed Chinese versions of

TransliterateText have two modes of operation:

m

If either smMaskAscii

or smMaskNative is speci

ed in the source mask, and if the

target is smTransAscii, and if either of the target modi ers is speci ed,
TransliterateText performs the speci ed case conversion on both 1-byte and
2-byte Roman letters.

m Otherwise, TransliterateText performs conversions according to the target
format values de ned on page 6-47. Any combination of source masks and target
format is permitted.

RESULT CODES

In addition to Memory Manager errors, TransliterateText

following results:
noErr

6-100

0

1

No error

Illegal source or target, or '1t12'

Script Manager Reference

can return the

could not be loaded

CHAPTER

6

Script Manager

Replacing a Script System@ Default Routines
The four Script Manager routines described in this section allow you to access or replace
the text-manipulation and text-display routines in WorldScript I, the system extension for
1-byte complex script systems. The function Get ScriptUtilityAddress and the
procedure SetScriptUtilityAddress

work with the script utilities routines. The

function Get ScriptQDPatchAddress and the procedure
SetScriptQDPatchAddress work with patches of the QuickDraw routines StdText,
StdTxMeas, and MeasureText, and the Font Manager routine FontMetrics.

For more information on how to use these calls, see the appendix (Built-in Script
SupportOin this book.
Por

Get ScriptUtilityAddress

and SetScriptUtilityAddress, these are the

valid values for the selector parameter:
Script utility

Selector value

GetScriptVariable

$000C

SetScriptVariable

$000E

CharacterByteType

$0010

CharacterType

$0012

TransliterateText

$0018

FindWordBreaks

$001A

HiliteText

$001C

FillParseTable

$0022

FindScriptRun

$0026

VisibleLength

$0028

PixelToChar

$002E

CharToPixel

$0030

DrawJustified

$0032

Measurejustified

$0034

PortionLine

$0036

For

Get Script QDPatchAddress

and

valid values for the trapNum parameter:
QuickDraw patch

trapNum value

_StdText

$A882

_StdTxMeas

$A8ED

_MeasureText

$A837

_FontMetrics

$A835

Script Manager Reference

SetScriptQDPat

chAddress,

these are the

6-101

CHAPTER

6

Script Manager

GetScriptUtilityAddress
The Get ScriptUtilityAddress function returns a pointer to the speci
script utilityN or the original Roman utilityN for the given script system.
FUNCTION

GetScriptUtilityAddress

(selector:

ed 1-byte

Integer;

before:

Boolean;

script:

ScriptCode):

Ptr;

selector

Avalue that speci
is needed.

es the name of the utility routine whose address

before

A Boolean that speci es which of two routines is needed. If TRUE, the
address returned is that of the WorldScript I implementation of the utility.
If FALSE, the address returned is that of the original routine (usually the

built-in Roman version).

script

The numeric code that speci es the script system whose dispatch table
contains the pointers to the utility routines. Constants for all de ned script
codes are listed on page 6-52.

DESCRIPTION

The GetScriptUtilityAddress function examines the speci
table and returns a pointer to the desired routine.

ed script@ dispatch

Because each element in the dispatch table consists of a pair of addresses, one for the
WorldScript I implementation of the utility, and another for the original (Roman) version
of the utility, you can get the address of either routine. Either routine can then be
replaced, using the Get ScriptUtilityAddress call.
This function can return NIL for the pointer if, for example, either the WorldScript I

implementation or the original Roman routine is not used by the script system.
Valid values for the selector parameter are listed on page 6-101.
If the speci
pointer.

ed script system is not enabled, Get

ScriptUtilityAddress

returns a NIL

SEE ALSO

WorldScript I is described in the appendix Built-in Script SupportOin this book.

6-102

Script Manager Reference

CHAPTER

6

Script Manager

SetScriptUtility Address
The SetScriptUtilityAddress procedure replaces the speci
utilityN or the original Roman utilityN for the given script.
PROCEDURE

SetScriptUtilityAddress

(selector:
before:

Integer;
Boolean;

routineAddr:
script:

ed 1-byte script

Ptr;

ScriptCode) ;

selector

Avalue that speci

before

A Boolean that speci es which of two routines is to be replaced. If TRUE,
the WorldScript I implementation of the utility is replaced. If FALSE, the
original routine (usually the built-in Roman version) is replaced.

routineAddr

script

es the name of the utility routine to be replaced.

A pointer to the routine that is to replace the script utility.
The numeric code that speci es the script system whose dispatch table
contains the pointers to the utility routines. Constants for all de ned script
codes are listed on page 6-52.

DESCRIPTION

The SetScriptUtilityAddress procedure replaces the pointer to the desired routine
in the speci ed script@ dispatch table.
Several of the WorldScript I utilities call the original Roman routine after they execute.
Each element in the dispatch table consists of a pair of addresses: one for the
WorldScript I implementation of the utility, and another for the original (Roman) version
of the utility. With SetScriptUtilityAddress you can replace either routine. Thus
you can insert your patch code either before (or in place of) the WorldScript I version of
the utility, or before (or in place of) the original Roman routine.
IMPORTANT

When you patch a script system@ script utility, you alter that script@

behavior for as long as it remains enabled. Therefore, be sure to restore

the pointer to its original state whenever your application quits or is
switched out by the Process Manager. &

Valid values for the selector parameter are listed on page 6-101.

SEE ALSO

WorldScript I is described in the appendix (Built-in Script SupportOin this book.

Script Manager Reference

6-103

CHAPTER

6

Script Manager

GetScriptQDPatchAddress
The Get ScriptQDPatchAddress function returns a pointer to the speci ed
WorldScript I QuickDraw patchN or the built-in QuickDraw callN for the given
script system.
FUNCTION

GetScriptQDPatchAddress

(trapNum:
before:

Integer;
Boolean;

forPrinting:
script:

Boolean;

ScriptCode):

Ptr;

trapNum

A value that speci es the name of the QuickDraw routine whose
address is needed.

before

A Boolean that speci es which of two routines is needed. If TRUE, the
address returned is that of the WorldScript I patch to the QuickDraw
routine. If FALSE, the address returned is that of the original routine
(usually the built-in QuickDraw routine).

forPrinting

script

A Boolean that speci es whether the desired routine is for printing. If
TRUE, the address returned is that of a QuickDraw patch that is
speci cally for printing; if FALSE, the address returned is that of a
QuickDraw patch that is not speci cally for printing.
The numeric code that speci es the script system whose dispatch table
contains the pointers to the QuickDraw routines. Constants for all de ned
script codes are listed on page 6-52.

DESCRIPTION

The Get Script QDPatchAddress function examines the speci
table and returns a pointer to the desired routine.

ed script@ dispatch

Because each element in the dispatch table consists of a pair of addresses, one for the
WorldScript I patch to the QuickDraw routine, and another for the original QuickDraw
version of the routine, you can get the address of either routine. Either routine can then
be replaced, using the SetScriptQDPatchAddress call.
Some printers perform their own text layout on text that is passed to them. Therefore,
each QuickDraw patch has two entry points: one for screen display and printing, and one
for printing only. By specifying either TRUE

or FALSE

in the

forPrinting parameter,

the pointer you obtain is to either the Gor printing onlyOor the Chot for printing onlyO
entry point. For example, some script systems might use the Gor printing onlyOentry
point to perform extra- ne justi cation of text on a PostScript printer.
Valid values for the trapNum parameter are listed on page 6-101.
If the speci ed script system is not enabled,
a NIL pointer.

6-104

Script Manager Reference

Get Script QDPatchAddress returns

CHAPTER

6

Script Manager

SEE ALSO
WorldScript I is described in the appendix (Built-in Script SupportOin this book.
In order to handle contextual formatting appropriately for each script system, printer
drivers should call the Script Manager@ print action routine, described in
Inside Macintosh: Devices.

SetScriptQDPatchAddress
The Set ScriptQDPatchAddress procedure replaces the WorldScript I speci
QuickDraw patchN or the built-in QuickDraw callN for the given script.
PROCEDURE

SetScriptQDPatchAddress

(trapNum:
before:

Integer;
Boolean;

forPrinting:

Boolean;

routineAddr:

Ptr;

script:

ed

ScriptCode) ;

trapNum

A value that speci
be replaced.

before

A Boolean that speci es which of two routines is to be replaced. If
TRUE, the WorldScript I patch of the QuickDraw routine is replaced.
If FALSE, the original routine (usually the built-in QuickDraw routine)
is replaced.

forPrinting

es the name of the QuickDraw routine that is to

A Boolean that speci

es whether the replacement routine is for printing. If

TRUE, the new QuickDraw patch is speci

new QuickDraw patch is not speci
routineAddr

script

cally for printing; if FALSE, the

cally for printing.

A pointer to the routine that is to replace the existing QuickDraw routine.
The numeric code that speci es the script system whose dispatch table
contains the pointers to the QuickDraw routines. Constants for all de ned
script codes are listed on page 6-52.

DESCRIPTION

The Set ScriptQDPatchAddress procedure replaces the pointer to the desired routine
in the speci ed script@ dispatch table.

Script Manager Reference

6-105

CHAPTER

6

Script Manager

All of the WorldScript I patches call the original QuickDraw routine after they execute.
Each element in the dispatch table consists of a pair of addresses: one for the WorldScript
I patch, and another for the original (built-in QuickDraw) version of the routine. With
SetQDPatchAddress you can replace either routine. Thus you can insert your patch
code either before (or in place of) the WorldScript I QuickDraw patch, or before (or in
place of) the original QuickDraw routine.
Some printers perform their own text layout on text that is passed to them. Therefore,
each QuickDraw patch has two entry points: one for screen display and one for printing
only. By specifying either TRUE or FALSE in the

forPrinting parameter, you specify

whether you are passing the Gor printing onlyOor the (hot for printing onlyOentry
point. For example, some script systems might use the Gor printing onlyOentry point to
perform extra- ne justi cation of text on a PostScript printer.
IMPORTANT

When you patch a script system@ QuickDraw call, you alter that script@

behavior for as long as it remains enabled. Therefore, be sure to restore

the pointer to its original state whenever your application quits or is
switched out by the Process Manager. &

Valid values for the trapNum parameter are listed on page 6-101.

SEE ALSO

WorldScript I is described in the appendix Built-in Script SupportOin this book.
In order to handle contextual formatting appropriately for each script system, printer
drivers should call the Script Manager@ print action routine, described in
Inside Macintosh: Devices.

6-106

Script Manager Reference

CHAPTER

Script

6

Manager

Summary of the Script Manager
Pascal Summary
Constants

{Script

system

{Implicit

constants}

script

smSystemScript

codes}
=

-1;

smCurrentScript

=

smAllScripts

-3;

{Explicit
smRoman

=

script
=

0;

smJapanese

=

1;

smTradChinese

=

=

3;

smArabic

=

4;

ll

smHebrew

smGreek

=

6;

smCyrillic

=

smRSymbol

=

8;
=

9;

smGurmukhi

=

10;

smGujarati

=

11;

smOriya

=

12;

smBengali
smTamil

=
=

smTelugu

13;

14;
=

smKannada

15;
=

smSinhalese
smKhmer
smThai

=
=

=

17;

=

18;

19;

20;

=

21;

smLaotian

=

22;

system script. }
font script.}
any script}

{Roman}
{ Japanese }
{Traditional Chinese}
{Korean}
{Arabic}
{Hebrew}
{Greek}
{Cyrillic}
{Right-left symbol}
{Devanagari }
{Gurmukhi }
{Gujarati}
{Oriya}
{Bengali}
{Tamil}
{Telugu}
{Kannada/Kanarese }

16;

smMalayalam
smBurmese

2;

7;

smDevanagari

{designates
{designates
{designates

codes}

uw

smKorean

-2;

{Malayalam}
{Sinhalese}
{Burmese }
{Khmer/Cambodian}
{Thai}
{Laotian}

Summary of the Script Manager

6-107

CHAPTER

Manager

smGeorgian

=

23;

{Georgian}

smArmenian

= 24;

{Armenian}
{Simplified

Chinese}

{Tibetan}
{Mongolian}

smGeez

{Geez/Ethiopic}

Il

=

5;

langSpanish

6;
=

7;

langPortuguese

=

langNorwegian

=

langHebrew

10;

=

langJapanese

=

8;

9;
11;

15;

16;

langTurkish

17;

langCroatian

=

18;

langTradChinese

=

langUrdu

=

langHindi
langThai

=

langKorean

21;
22;
=

23;

langLithuanian
langPolish

=

=

25;

langHungarian

=

langEstonian

langLettish

6-108

19;

20;

=

=

=

script

smRoman

script

smRoman

script

smRoman

script

smRoman

script

smRoman

script

smRoman

script

smHebrew

script

smJapanese

OE cent

=
=

smRoman

ete Tt cet

langMaltese

script

tien Tt eet

langArabic = 12;
langFinnish = 13;
langGreek = 14;
langIcelandic

script

smRoman

et)

4;

langSwedish
langDanish

smRoman

24;
26;

27;

28;

e.g.

palette

symbols}

}

script

}

smArabic script }
smRoman script }
smGreek script }
extended

Roman

script

}

extended

Roman

script

}

extended

Roman

script

}

Serbo-Croatian
Chinese

in

in

extended

traditional

smArabic script }
smDevanagari script
smThai script }
smKorean script }
smEastEurRoman

script

smEastEurRoman

script

smEastEurRoman

script

smEastEurRoman

script

smEastEurRoman

script

Summary of the Script Manager

Roman

characters

}

cmd

langDutch

Ww

langItalian

2;

~

=

Tt ete St tie Ot te

1;

langGerman

script

ot

langFrench

smRoman

ete

0;

tie

=

TE tien OE ete Tt ete TE cet

Codes}

tee Tt etiam St ction TE antistatic

{Language
langEnglish

{Synonym for smGeez}
{Synonym for smSlavic}
{Vietnamese }
{extended Arabic}
{uninterpreted symbols,

te Tt te TE ete Ot ete Tt

smEthiopic = 28;
smEastEurRoman = 29;
smVietnamese = 30;
smExtArabic = 31;
smUninterp = 32;

Tt tie

28;

Fetes TE

=

auntie, sendin cael

25;

sn auntie

=

smTibetan = 26;
smMongolian = 27;

er

smSimpChinese

eee
I
Ue

Script

6

script
}

}

CHAPTER

langLappish

=

Ol

29;

langFarsi

=

=

30;

31;

langPersian

=

31;

langRussian

=

32;

langSimpChinese
langFlemish
langIrish

=

=
34;

=

35;

langAlbanian

=

36;

langRomanian
langCzech

37;

=

langSlovak

33;

38;
=

39;

langSlovenian

=

40;

langYiddish

=

41;

langSerbian

=

42;

langMacedonian

=

43;

langBulgarian

=

44;

langUkrainian

=

45;

langByelorussian

=

langUzbek

=

langKazakh

=

48;

langAzerbaijani

=

langAzerbaijanAr
=

51;

langGeorgian

=

52;

langMoldovan

49;
=

langArmenian

langKirghiz

=
=

=

langTurkmen

53;

54;

55;
=

56;

langMongolian

=

57;

langMongolianCyr

=

langPashto

=

langKurdish

langNepali

61;

62;
=

=

63;
64;

langSanskrit
langMarathi

60;
=

=

langTibetan

58;

59;

=

langKashmiri
langSindhi

50;

53;

langMoldavian
langTajiki

46;

47;

=
=

65;
66;

Summary of the Script Manager

7 ceetien T ceteeen St centieen St ctieee TE conten TE centimeter
TE tie eta
tee TE ete
tien TE te Tt et TE tien
te Tt tin
ete
te TE tee
tie Tt ote St te TE ti OE ote
ete
et

langFaeroese

Synonym for langLettish
extended Roman script }

}

Synonym

}

for

langSaamisk

smRoman script }
smArabic script }
Synonym

for

langFarsi

}

smCyrillic script }
Chinese in simplified
smRoman script }
smRoman script }
smRoman script }
smEastEurRoman

script

smEastEurRoman

script

smEastEurRoman

script

smEastEurRoman

script

smHebrew

script

}

Serbo-Croatian

in

characters

smCyrillic

smCyrillic

script

smCyrillic

script

smCyrillic

script

smCyrillic

script

smCyrillic

script

smCyrillic

script

}

Azerbaijani

in

smCyrillic

Azerbaijani

in

smArabic

smArmenian
smGeorgian
smCyrillic

script
script
script

Synonym

for

smCyrillic
smCyrillic
smCyrillic

script

}

script

script

}

(Iran)

}

}
}
}

langMoldovan

script
script
script

}

amd

29;

es aunties candies sendin

28;

=

candle, cnndlliens cad

=

langSaamisk

ss aunties audi

langLatvian

ee

Manager

te Tt

Script

6

}

}
}
}

Mongolian

in

smMongolian

Mongolian

in

smCyrillic

script
script

}
}

smArabic script }
smArabic script }
smArabic script }
smExtArabic script }
smTibetan script }
smDevanagari script }
smDevanagari script }
smDevanagari script }

6-109

CHAPTER

67;

=

69;
70;

=

74;

Se

langTamil

Tt ete

langOriya = 71;
langMalayalam = 72;
langKannada = 73;

langLao

=

=

tie
ete St

78;

Ot tn Tt ten Tt tie

langKhmer

te

langTelugu = 75;
langSinhalese = 76;
langBurmese = 77;
79;

langVietnamese

=

80;

=

langMalayArabic

langGalla

87;

langOromo

87;

=

langSwahili
=

langRundi

89;
90;

92;
=

langEsperanto
=

langCatalan

langLatin

129;
=

=

130;

131;

langQuechua

=

132;

langGuarani

133;

langAymara

langTatar

94;

ten TE eta

langBasque

=
128;

=

=

134;

135;

langUighur = 136;
langDzongkha = 137;
langJavaneseRom

langSundaneseRom

6-110

=

138;

=

139;

Summary of the Script Manager

}

script

}

smOriya script }
smMalayalam script
smKannada script }
smTamil

script

}

}

smTelugu script }
smSinhalese script
smBurmese script }
smKhmer

script

smLactian

script

smVietnamese

smRoman
smRoman

}

script

script
script

smEthiopic
smEthiopic
smEthiopic

}

}

}

}
}

smArabic

St ete TO

=

script

smGurmukhi

smRoman

TE tien Tt

langWelsh

93;

smGujarati

in

tee TE tie St ete TO ete

=

langMalagasy

}

in

OE te Tete

91;

}

script

Malay

TO ction SE cet

langChewa

88;
=

langRuanda

86;

script

smBengali

Malay

tin

85;
=

langSomali

84;

St tie Ot tee TE te Tt tie Ot ete TE

=

langTigrinya

83;

=

cet

langAmharic

TE

langMalayRoman

tee Seti

langIndonesian = 81;
langTagalog = 82;

smBengali

script

script
script
script

}

}
}
}

synonym

for

smRoman

script

}

smRoman

script

smRoman

script

smRoman

script

}
}

smRoman

script

}

smRoman

script

}

extended

Roman

script

smRoman

script

smRoman

script

smRoman

script

smRoman

script

smRoman

script

smRoman

script

smRoman

script

}

smCyrillic

}

script

langGalla

}

}

}

te

=

langPunjabi

tie Ot tee Tl tee SE te St te

langGujarati

68;

te

=

ten

=

langAssamese

Fete TE aeetieen TE ceeteeen St eet

langBengali

Manager

Oe
UR Se

Script

6

script

}

smArabic
(lang of

script }
Bhutan) smTibetan

script

Javanese

in

}

Sundanese

in

smRoman

smRoman

script

script

}

}

CHAPTER

Script

{ Region

codes

verUS

0;

=

verFrance

=

verBritain
verGermany
verlItaly

=

Manager

}

1;

=

2;

=

3;

4;

verNetherlands

=

verFrBelgiumLux
verSweden

=

verSpain

=

=

verFrCanada
=

=
=

verArabic

10;

=

11;

=

=

16;

verFrSwiss
verGrSwiss

= 18;
= 19;
=

vericeland

{Swiss
{Swiss

21;

22;
=

23;

verTurkey

=

24;

verYugoCroatian
verIndiaHindi
verPakistan

= 25;

{Croatian

33;

{Hindi

system}

system

for

India}

34;
=

=

41;

42;

verHungary

43;

verEstonia

=
=

verLapland

44;
45;

=

verFaeroelIsl

verIreland

=
=

verLithuania

verRussia

French}
German}

20;

=
=

=

verArabia}

17;

verCyprus

veriran

for

15;

16;
=

verLatvia

{synonym

13;

verFinland

verPoland

& Luxembourg}

14;

verArabia

verMalta

Belgium

9;
=

verAustralia

verGreece

for

12;

=

verJapan

{French

7;

verPortugal

verlIsrael

5;

= 6;

8;

verDenmark

verNorway

6

46;
=

47;

48;

=

49;
=

50;

Summary

{English-language

of the Script

Manager

version

for

Ireland}

6-111

CHAPTER

Script

verkKorea

=

51;

verChina

=

52;

verTaiwan

=

6

Manager

53;

verThailand

=

54;

minCountry

=

verUS;

maxCountry

=

verThailand;

{Calendar

codes}

calGregorian

=

0;

calArabicCivil

1;

calArabicLunar
calJapanese

2;

=

calJewish

3;

4;

calCoptic

=

5;

calPersian

=

{Numeral

codes}

intWestern

=

intArabic
intRoman

6;

0;

=

1;

=

2;

intJapanese

=

3;

intEuropean

=

4;

intOutputMask

=

$8000;

{ CharacterByteType
smSingleByte

=

smFirstByte
smLastByte

-1;
=

2;

{CharacterType
smcTypeMask

=

smcReserved

=

smcClassMask

field
SOOFO;

=

smcRightMask

=

smcUpperMask

=

smcDoubleMask

SOFOO;

=

character

types}

script

glyph

orientation}

$8000;

smCharPunct

=

$0000;

smCharAscii

=

$0001;

6-112

{2-byte

$4000;

CharacterType

=

$1000;

$2000;
=

smCharExtAscii

masks}

SOOOF;

smcOrientationMask

smCharEuro

}

1;

smMiddleByte

{Basic

types

0;

=
=

byte

$0007;
=

$0007;

{more

Summary of the Script Manager

correct

synonym

for

smCharEuro}

CHAPTER

Script

{Additional

6

Manager

CharacterType

character

types

for

script

systems}

smCharKatakana

=

$0002;

{Japanese

smCharHiragana

=

$0003;

{ Japanese Hiragana}
{ Hanzi, Kanji, Hanja}
{ 2-byte Greek in Far East systems}
{ 2-byte Cyrillic in Far East systems}
{ Arabic/Hebrew}
{ contextual left-right: Thai, Indic scripts}
{ noncontextual left-right: Cyrillic, Greek}
{ Korean Hangul }
{ Korean Jamo}
{ Chinese Bopomofo (Zhuyinfuhao)}

smCharIdeographic

= $0004;

smCharTwoByteGreek

=

$0005;

smCharTwoByteRussian
smCharBidirect

=

=

$0008;

smCharContextualLR

=

$0009;

smCharNonContextualLR
smCharHangul
smCharJamo

=
=

=

SOOOA;

S000C;

$000D;

smCharBopomofo

=

{CharacterType

classes

SOOOE;

smPunctNormal

=

$0000;

smPunctNumber

=

$0100;

for

punctuation

smPunctBlank

=

$0300;

CharacterType

classes

for

smPunctRepeat = $0400;
smPunctGraphic = $0500;
{CharacterType

Katakana

{CharacterType

and

Hiragana

ideographic

Jamo

smJamoJaeum

$0000;

=

smJamoBogJaeum

=

=

classes

{CharacterType

glyph

smCharHorizontal

=

smCharVertical

classes

for

=

Summary

classes

for

for

2-byte

Korean

systems}

2-byte

systems}

consonant

{complex

{simple

{

$0300;
orientation

$0000;

complex

for

vowel

Manager

char}

char}

vowel

2-byte

{vertical

char}

consonant

{horizontal

$1000;

of the Script

systems}

systems}

{simple

$0200;
=

two-byte

{level 1 char}
{level 2 char}
{user char}

$0100;

smJamoBogMoeum

in

{small Kana character}
{can have dakuten}
{can have dakuten or han-dakuten}

smIdeographichevell = $0000;
smIdeographichevel2 = $0100;
smIdeographicUser = $0200;
{CharacterType

punctuation

{repeat marker}
{line graphics}

smKanaSmall = $0100;
smKanaHardOK = $0200;
smKanaSoftOK = $0300;

smJamoMoeum

(smCharPunct) }

$0200;

smPunctSymbol

{Additional

$0006;

Katakana}

char}

systems}

character

character

form,

or

for

both}

form}

6-113

CHAPTER

Script

{CharacterType
smCharLeft

smCharRight

=

6

Manager

directions}
$0000;

=

$2000;

{CharacterType

case

smCharLower

=

$0000;

smCharUpper

=

$4000;

modifers}

{CharacterType

character

smCharlbyte

$0000;

=

smChar2byte

size

modifiers

(1

or

multiple

$8000;

{TransliterateText target
smTransAscii = 0;
smTransNative = 1;
smTransCase = SFE;
smTransSystem = $FF;

types

{TransliterateText

types

target

for Roman}
{convert to ASCIT}
{convert to font script}
{convert case for all text}
{convert to system script}
for

2-byte

scripts}

smTransAsciil = 2;
smTransAscii2 = 3;
smTransKanal = 4;
smTransKana2 = 5;

{1-byte
{2-byte
{l-byte
{2-byte

Roman}
Roman}
Japanese
Japanese

Katakana}
Katakana}

smTransGana2

{2-byte

Japanese

Hiragana

{2-byte
{2-byte
{2-byte

Korean Hangul}
Korean Jamo}
Chinese Bopomofo

=

7;

smTransHangul2 = 8;
smTransdJamo2 = 9;
smTransBopomofo2 = 10;
{TransliterateText

target

= $4000;

{target

becomes

lowercase}

smTransUpper

=

{target

becomes

uppercase

$8000;

{TransliterateText

resource

smTransRuleBaseFormat

=

smTransHangulFormat

= 2;

{TransliterateText

property

format

1;

smTransPreDoubleByting

= 1;

smTransPreLowerCasing

= 2;

{TransliterateText source
smMaskAll = SFFFFFFFF;

(no

1-byte

Hiragana) }

(Zhuyinfuhao)}

modifiers}

smTransLower

6-114

bytes) }

}

numbers}

{rule-based

trsl

{table-based

Hangul

resource

trsl

format

}

resource

flags}

mask

{convert
{ before
{convert
{ before

all text to 2-byte }
transliteration}
all text to lowercase
transliteration}

- general}
{convert all

Summary of the Script Manager

text}

}

format}

CHAPTER

Script

6

Manager

{TransliterateText

source

masks}

smMaskAscii = $00000001;
smMaskNative = $00000002;
{TransliterateText

{2*smTransAscii}
{2*smTransNative }

source

masks

for

smMaskAsciil = $00000004;
smMaskAscii2 = $00000008;
smMaskKanal = $00000010;
smMaskKana2 = $00000020;
smMaskGana2 = $00000080;
smMaskHangul2 = $00000100;
smMaskJamo2 = $00000200;
smMaskBopomofo2 = $00000400;
{Result

values

from

{ GetScriptVariable,
smNotInstalled

=

smRedrawLine

=

and

=

smMunged

=

smEnabled

{routine

{bad
{bad
redraw

-1;

8;

=

10;

=

smDefault
smPrint

12;
=

=

14;

16;

smSysScript

=

18;

smLastScript

=

smKeyScript

= 22;

smSysRef

=

smKeySwap

20;

24;

smKeyCache

28;

smGenFlags

= 30;

smOverride

=

32;

Summary

script}

a routine}
to a routine}

character only}
entire word (2-byte

{redraw

entire

line

systems)}

(bidirectional

Manager

version

change

count}

systems) }

selectors}

number}

{ obsolete}
{ Swapping table handle}
{ General flags long}
{ Script override flags}

= 26;
=

specified

{ Count of enabled scripts, incl Roman}
{ At least one bidirectional script}
{ Force font flag}
{ Intl resources selection flag}
{ Script was forced to system script}
{ Script was defaulted to Roman script}
{ Printer action routine}
{ System script}
{ Last keyboard script}
{ Keyboard script}
{ System folder refNum}

6; ;
=

in

{redraw
{redraw

{ Globals

smintlForce

available

SetScriptManagerVariable

4; ;

=

not

selector passed to
script code passed

{Script

smFontForce
smForced

and

0;

=

}

flag}

2;

smBidirect

SetScriptManagerVariable,

SetScriptVariable}

0;

{GetScriptManagerVariable

smVersion

scripts}

GetScriptManagerVariable,

smBadVerb = -1;
smBadScript = -2;
{Values for script
smRedrawChar = 0;
smRedrawWord = 1;

2-byte

{2*smTransAsciil}
{2*smTransAscii2}
{2*smTransKanal }
{2*smTransKanaz2 }
{2*smTransGanaz2 }
{2“smTransHangul12 }
{2*smTransJamoz2 }
{2*smTransBopomofo2 }

of the Script

Manager

6-115

CHAPTER

Script

smCharPortion
=

smKCHRCache

Manager

=

smDoubleByte
=

smRegionCode

6

{Ch vs SpExtra proportion}
{Flag for double-byte script installed}
{Returns pointer to KCHR cache}
{Returns current region code (verXxx)}

34;
36;

38;
=

40;

smKeyDisableState

=

{ GetScriptVariable
smScriptVersion
=

smScriptEnabled

smScriptRight
smScriptJust

=

4;

6;
=

10;

smScriptSysFond

=

smScriptAppFond

=

smScriptBundle

12;

14;
16;

smScriptNumber

16;

=

18;

smScriptSort

20;

smScriptFlags

=

22;

smScriptToken

=

24;

smScriptEncoding

=

smScriptLang

=

28;

smScriptNumDate

=

smScriptKeys

=

26;

{Script
{ Script

30;

32;

smScriptiIcon

34;

smScriptPrint
smScriptTrap

=
=

36;
38;

smScriptCreator

=

smScriptFile

=

42;

smScriptName

=

44;

40;

smScriptMonoFondSize

=

78;

smScriptPrefFondSize

80;

smScriptSmallFondSize

=

smScriptSysFondSize
=

smScriptHelpFondSize
=

smScriptAliasStyle

smKeySysScript
smKeySwapScript

6-116

=

selectors

smKeyNextScript

=
=

-1;
-2;

=

86;

=

smScriptValidStyles

{ Negative

82;

84;

smScriptAppFondSize

-3;

keyboard

disable

state}

{ Script entry changed count}
{ Script enabled flag}
{ Right to left flag}
{ Justification flag}
{ Word redraw flag}
{ Preferred system font}
{ Preferred Application font}
{ Beginning of itlb verbs}
{ Script itlo id}
{ Script itl1 id}
{ Script itl2 id}
{ flags word}
{ Script itl4 id}
{ id of optional it15, if present}
{ Current language for script}

2;

8;

smScriptRedraw

current

SetScriptVariable selectors. }
{Script software version}

0;

=

=

smScriptDate

and

=

smScriptMunged

{ Returns

42;

88;
90;

92;

for

Number/Date
KCHR id}

formats. }

{ ID # of SICN or kes#/kcs4/kcs8 family}
{ Script printer action routine}
{ Trap entry pointer}
{s cript file creator}
{ Script file name}
{ Script name}
{ default monospace FOND (hi) & size (lo)}
{ preferred FOND (hi) & size (lo)}
{ default small FOND (hi) & size (lo)}
{ default system FOND (hi) & size (lo)}
{ default app FOND (hi) & size (lo)}
{ default Help Mgr FOND (hi) & size (lo)}
{ mask of valid styles for script}
{ style (set) to use for aliases}

KeyScript }
{ Switch
{ Switch

to
to

next available script
the system script }

{

to

previously-used

Switch

Summary of the Script Manager

script

}
}

CHAPTER

Script

6

Manager

smKeyNextKybd

=

-4;

{ Switch

to

next

smKeySwapKybd

=

-5;

{

Switch

to

previous

{

Disable

keyboards

{

Re-enable
Toggle

smKeyDisableKybds

=

smKeyEnableKybds

=

-6;
-7;

smKeyToggleInline

keyboard
not

keyboards

inline

in

current

keyboard
in

in

system

for

all

current

keyscript

current
or

Roman

enabled

}

keyscript
script

scripts

keyscript

}
}

}

=

-8;

{

input

for

smKeyToggleDirection

=

-9;

{Toggle

default

line

direction

}

smKeyNextInputMethod

=

-10;

{Switch

to

next

input

method

in

current

script}

smKeySwapInputMethod

=

-11;

{Switch

to

prev.

input

method

in

curr.

script}

(TESysJust)}

smKeyDisableKybdSwitch = -12;
smKeySetDirLeftRight = -15;
smKeySetDirRightLeft = -16;

{Disable switching from current keyboard}
{Set default line dir. left-right,align left}
{Set default line dir. right-left,align right}

smKeyRoman

keyscript

{

Bits

(bits

=

in

-17;

the

above

Set

smScriptFlags

8

smsfIntellCP
smsfSingByte

{

are

=
=

Roman.

Does

nothing

if

}

{Script
{Script

has
has

{Native

chars

smsfContext = 3;
smsfNoForceFont = 4;
smsfBODigits = 5;

{Script
{Script
{Script

is contextual}
will not force characters}
has alternate digits at BO-B9}

smsfAutoInit = 6;
smsfUnivExt = 7;

{Auto initialize the script}
{Script is handled by WorldScript

smsfNatCase

=

2;

smsfSynchUnstyledTE

=

8;

{ Bits
{First

=

long.}
is set

31;

Script

Manager

smFondStart

smFondEnd
{

=

=

$4000;

$C000;
font

smUprHalfCharSet

=

Character

Set

diaeresisUprY
fraction

=

equates.

=

Extensions

&

and

lower

case}

I}

chartype

in

unstyled

TE}

forms for letters}
ligatures}
text, right-left}

flags
if

byte.
only

one

}
script}

caret for mixed direction
for internal use}

text}

}

{start

from

16K}

{past

end

range

equates.
$80;

even

cut & paste}
bytes}

upper

keyboard

itlc

icon

{Use dual
{Reserved

font

Miscellaneous

{

from

{Show

smfDualCaret = 30;
smfNameTagEnab = 29;
{

have

{Uses contextual
{Uses contextual
{Reverses native

in the smGenFlags
(high-order) byte

smfShowIcon

intelligent
only single

{Synchronize

smsfForms = 13;
smsfLigatures = 14;
smsfReverse = 15;

Roman-only}

word

non-static)

0;
1;

to

of

at

48K}

}

{first

char

code

in

top

half

of

std

char

set}

}

$D9;

SDA;

Summary

of the Script

Manager

6-117

CHAPTER

Script

intlCurrency

Manager

=

SDB;

leftSingGuillemet

=

rightSingGuillemet
filigature

=

flLigature
=

centeredDot

SDF;
=

SE1;
=

baseDblQuote

=

perThousand

SE2;
SE3;

=

S$E4;

circumflexUprA

=

$E5;

circumflexUprE
=

SE6;

SE7;

diaeresisUprE

=

graveUprE

=

SE9;

acuteUprliI

=

SEA;

circumflexUpriI
=

graveUpriI

=

SED;

acuteUprO

=

SEE;

circumflexUproO
=
=

graveUpru

=

SF3;

= $F4;

dotlessLwrlI

=

circumflex

=

SF5;
SF6;

SF7;

SF8;
=

SFA;
=

cedilla

=

SFB;
SFC;

doubleAcute
=

hachek

=

SFE;
SFF;

{ TokenType
tokenIntl

SFD;

values
=

tokenEmpty

4;
=

tokenUnknown

-1;
=

the

itl

used

internally

chars

resource

that

whitespace }

tokenWhite

=

6-118

Summary of the Script Manager

_a

1;

0;

}
ere

ringMark

SF9;

oa

overDot

=

a

=

breveMark

ogonek

SEF;

SF2;

circumflexUprU

macron

=

SF1;

acuteUprU

=

SEB;
SEC;

SFO;

graveUpro

tilde

SE8;

=

diaeresisUprI

appleLogo

=

SEO;

baseSingQuote

acuteUprA

SDC;

SDE;

=

dblDagger

6

do

number
as

not

an

of

the

empty

match

a

tokenizer}

flag}

defined

token

type}

CHAPTER

Script

tokenLeftLit

Manager

=

2;

tokenRightLit
tokenAlpha

=

=

3;

4;

tokenNumeric

=

tokenNewLine

5;

= 6;

tokenLeftComment

=

7;

tokenRightComment
tokenLiteral

=

=

=

10;

tokenAltNum

=

11;

tokenRealNum

=

12;

tokenAltReal

=

13;

tokenReservel

=

14;

tokenReserve2

=

15;

tokenLeftParen

=

tokenRightParen

16;
=

tokenLeftBracket

17;
=

18;

tokenRightBracket
tokenLeftCurly

=

=

tokenRightCurly

=

21;
=

22;

tokenRightEnclose
tokenMinus

=

23;

24;
=

tokenDivide

= 26;
=

in

"\n",
in

"\t")}

Arabic,Hebrew)}

{ open square bracket}
{ close square bracket}
{ open curly bracket}
{ close curly bracket}
{ open guillemet}
{ close guillemet}

=

{times/multiply}

= 28;

{plus

or

minus

symbol}

29;

tokenBackSlash

=

30;

tokenLess = 31;
tokenGreat = 32;
=

{less than symbol}
{greater than symbol}

33;

tokenLessEqual2

=

34;

{less

than

or

tokenLessEquall

= 35;

{less

than

or

tokenGreatEgqual2

=

36;

{greater

tokenGreatEgquall

=

37;

token2Equal

'\'

$BO-B9

27;

tokenPlusMinus

tokenEgual

{ literal begin}
{ literal end}
{ alphabetic}
{ numeric}
{ new line}
{ open comment }
{ close comment }
{ literal}
{ character escape (e.g.
{ alternate number (e.g.
{ real number}
{ alternate real number}
{ reserved}
{ reserved}
{ open parenthesis}
{ close parenthesis}

25;

tokenAsterisk

tokenSlash

19;

20;

tokenLeftEnclose
=

8;

9;

tokenEscape

tokenPlus

6

= 38;

equal,

2

characters

equal,

1 character}

than

or

equal,

2

characters

{greater

than

or

equal,

1

character}

{double

equal

(e.g.

{colon equal}
{not equal, 1 character}

tokenLessGreat

{less/greater,

=

41;

Summary

of the Script

{exclamation
{exclamation

Manager

Pascal

equal,
point}

<=) }

(e.g.

>=)}

==) }

tokenColonEqual = 39;
tokenNotEqual = 40;
tokenExclamEqual = 42;
tokenExclam = 43;

(e.g.

not

equal

(e.g.

<>)}

C not

equal

(e.g.

!=)}

6-119

CHAPTER

Script

Manager

tokenTilde

= 44;

tokenComma

=

tokenPeriod

{centered

=

46;
=

tokenRight2Quote
=

tokenRight1lQuote
token2Quote

48;
49;

=

50;

51;
=

52;

tokenSemicolon

=

tokenPercent
tokenCaret

=
=

56;

=

57;

=

tokenQuestion

=

60;

{lower-case pi}
{square root symbol}
{capital sigma}
{integral sign}

61;
=

tokenSigma

62;
=

63;

tokenIntegral

= 64;

tokenMicro

=

65;

tokenCapPi

= 66;

tokenInfinity

{capital

=

tokenColon

=

tokenHash

= 69;

tokenDollar

68;

=

tokenFraction

{e.g.

=

=

71;

=

73;

{non-breaking

=

tokenRightSingGuillemet
tokenPerThousand

tokenNil

=

127;

delimPad

=

-2;

=

=

tokenCenterDot

=

75;

76;

78;

selectors

smWordWrapTable

for
=
=

1;
=

=

3;
=

GetIntlResourceTable

0;

smNumberPartsTable
smWhiteSpaceList

74;
=

77;

smWordSelectTable

smUnTokenTable

space}

72;

tokenLeftSingGuillemet

tokenEllipsis

#}

70;

tokenIntlCurrency

6-120

pi}

67;

tokenNoBreakSpace

{ Table

bar}

58;

= 59;

tokenRoot

{vertical

54;
=

=

quote}

55;

tokenAmpersand
tokenAtSign

{single
53;

tokenUnderline

tokenPi

{ open double quote}
{ close double quote}
{ open single quote}
{ close single quote}
{ double quote}

47;
=

tokenLeft1lQuote

tokenlQuote

tilde}

45;

tokenLeft2Quote

tokenBar

6

4;

2;

{

get

{
{
{
{

}

word

break

table

from

'it12'

}

get

line

break

table

from

'it12'

}

get

number

parts

get

unToken

table

get

whitespace

Summary of the Script Manager

table

from

from

table

'itl4'

'itl4'

from

}

}

'itl4'

}

CHAPTER

Script

6

Manager

Data Types
TYPE

TokenResults

=

(tokenOK,

tokenOverflow,

badEnding,

crash)

CharByteTable

;

=

PACKED

ARRAY[0..255]

OF

SignedByte;

Integer;

TokenType
DelimType

=

ARRAY[0..1]

CommentType
TokenRec

stringOverflow,badDelim,

=

OF

ARRAY[0..3]

TokenType;
OF

TokenType;

=

RECORD

theToken:

TokenType;

position:

Ptr;

{pointer

length:

LongInt ;

{length

stringPosition:

StringPtr;

{Pascal/C

END ;

TokenRecPtr
TokenBlock

=

into
of

original

text

in

string

copy

source}

original
of

source}

identifier}

“TokenRec;

=

RECORD

source:

Ptr;

{pointer

sourceLength:

LongiInt;

{length

tokenList:
tokenLength:

Ptr;
Longint;

{pointer
{maximum

tokenCount:

LongiInt;

{number

stringList:
stringLength:
stringCount :

Ptr;
LongInt;
Longint;

{pointer to stream of identifiers}
{length of string list}
{number of bytes currently used}

doString:

Boolean;

{make

doAppend:

Boolean;

{append

doAlphanumeric:
doNest:

Boolean;
Boolean;

{identifiers
{do comments

leftDelims:

DelimType;

rightDelims:

DelimType;

leftComment
rightComment

:

stream
source

of

characters}

stream}

to array of tokens}
length of TokenList}
tokens

strings

to

generated

&

put

TokenList

into

by

StringList}

rather

may include
nest? }

tokenizer}

than

replace}

numeric}

CommentType;
:

CommentType;

escapeCode:

TokenType; {escape

decimalCode:

TokenType;

Summary

to
of

of the Script

Manager

symbol

code}

6-121

CHAPTER

Script

6

Manager

itlResource:

Handle;

reserved:

ARRAY

{handle

[0..7]

OF

to

current

LongInt;

script

itl4

{must

zero! }

be

resource}

END;

TokenBlockPtr

=

*TokenBlock;

Routines

Checking and Setting the System Direction
FUNCTION

GetSysDirection:

PROCEDURE

SetSysDirection

Integer;
(newDirection:

Integer) ;

Checking and Setting Script Manager Variables
FUNCTION

GetScriptManagerVariable
(selector:

FUNCTION

Integer):

LongInt;

SetScriptManagerVariable
(selector:

Integer;

param:

LongInt):

OSErr;

Checking and Setting Script Variables
FUNCTION

GetScriptVariable

(script:

ScriptCode;

selector:
FUNCTION

SetScriptVariable

(script:

Integer):
ScriptCode;

param:

LongInt):

(code:

Integer) ;

LongInt;
selector:

Integer;

OSErr;

Making Keyboard Settings
PROCEDURE

KeyScript

Determining Script Codes From Font Information
FUNCTION

FontScript:

FUNCTION

FontToScript

FUNCTION

IntlScript:

Integer;
(fontNumber:

Integer):

Integer;

Integer;

Analyzing Characters
FUNCTION

CharacterByteType

(textBuf:
script:

FUNCTION

CharacterType

(textBuf:
script:

FUNCTION

FillParseTable

(VAR

Summary of the Script Manager

Ptr;

Integer;

Integer;

textOffset:

ScriptCode):

table:

script:

6-122

Ptr;textOffset:
ScriptCode):

Integer;

Integer;

CharByteTable;

ScriptCode):

Boolean;

CHAPTER

Script

6

Manager

Directly Accessing International Resources
PROCEDURE
FUNCTION
PROCEDURE

ClearIntlResourceCache;
GetIntlResource

(theID:

Integer):

Handle;

GetIntlResourceTable
(script:

ScriptCode;tableCode:

itlHandle:

length:

Handle;

VAR

Integer;VAR

offset:

LongInt;VAR

LongInt) ;

Tokenization
FUNCTION

IntlTokenize

(tokenParam:

TokenBlockPtr):

TokenResults;

Transliteration
FUNCTION

TransliterateText

(srcHandle:

Handle;

dstHandle:

target:

Integer;

script:

ScriptCode):

srcMask:

Handle;

LongInt;

OSErr;

Replacing a Script System’s Default Routines
FUNCTION

PROCEDURE

GetScriptUtilityAddress
(selector:

Integer;

before:

script:

ScriptCode):

Ptr;

Integer;

before:

SetScriptUtilityAddress
(selector:

routineAddr:
FUNCTION

Ptr;

script:

Boolean;

ScriptCode) ;

GetScriptQDPatchAddress
(trapNum:

PROCEDURE

Boolean;

Integer;

before:

Boolean;

script:

ScriptCode):

forPrinting:

Boolean;

Ptr;

SetScriptQDPatchAddress
(trapNum:

Integer;before:

forPrinting:
script:

Summary

of the Script

Manager

Boolean;

Boolean;

routineAddr:

Ptr;

ScriptCode) ;

6-123

CHAPTER

Script

6

Manager

C Summary
Constants

Please see page 6-107 for a listing of constants de ned in Pascal by the Script Manager.
The constants as de ned in C are identical to them.
Data Types
typedef

unsigned

typedef

char

CharByteTable

typedef

short

TokenType;

typedef

TokenType

DelimType[2] ;

typedef

TokenType

CommentType
[4] ;

struct

TokenRec

TokenType

char

TokenResults;

[256];

{

theToken;

Ptr

position;

/*pointer

long

length;

/*length

StringPtr

stringPosition;

typedef

struct

typedef

TokenRec

struct

TokenBlock

Ptr

TokenRec

into
of

/*Pascal/C

original

text

in

string

copy

original
of

*TokenRecPtr;

{

source;

/*pointer

to

of

stream

sourceLength;

/*length

Ptr

tokenList;

/*pointer

to

long

tokenLength;

/*maximum

length

tokenCount ;

of

source

characters*/

stream*/

array

of

of

tokens*/

TokenList*/

/*number

tokens

generated

Ptr

stringList;

/*pointer

to

stream

of

long

stringLength;

/*length

of

string

list*/

long

stringCount;

/*number

of

bytes

currently

strings

Boolean

doString;

/*make

Boolean

doAppend;

/*append

Boolean

doAlphanumeric;

/*identifiers

may

Boolean

doNest;

/*do

nest?*/

6-124

source*/

identifier*/

TokenRec;

long

long

source*/

Summary of the Script Manager

to

comments

&

put

TokenList

by

tokenizer*/

identifiers*/

into

used*/
StringList*/

rather

include

than

numeric*/

replace*/

CHAPTER

Script

6

Manager

TokenType

leftDelims
[2] ;

TokenType

rightDelims
[2];

TokenType
TokenType

leftComment
[4] ;
rightComment
[4] ;

TokenType

escapeCode;

TokenType

decimalCode;

Handle
long

itlResource;
reserved
[8] ;

/*escape

symbol

/*handle

to

/*must

be

code*/

itl4

resource

of

current

script*/

zero!*/

hi
typedef

struct

TokenBlock

typedef

TokenBlock

TokenBlock;

*TokenBlockPtr;

Routines

Checking and Setting the System Direction
#define
pascal

GetSysDirection()
void

SetSysDirection

(*

(short*)

(short

OxOBAC) ;

newDirection) ; f

Checking and Setting Script Manager Variables
pascal

long

GetScriptManagerVariable

(short
pascal

OSErr

selector) ;

SetScriptManagerVariable
(short

selector,

long

param) ;

Checking and Setting Script Variables
pascal

long

GetScriptVariable
(ScriptCode

pascal

OSErr

script,

short

selector) ;

script,

short

selector,

SetScriptVariable
(ScriptCode

long

param) ;

Making Keyboard Settings
pascal

void

KeyScript

(short

code) ;

Determining Script Codes From Font Information
pascal

short

FontScript

(void) ;

pascal

short

FontToScript

(short

pascal

short

IntlScript

(void) ;

Summary of the Script Manager

fontNumber) ;

6-125

CHAPTER

Script

6

Manager

Analyzing Characters
pascal

short

CharacterByteType
(Ptr

textBuf,

ScriptCode
pascal

short

CharacterType

(Ptr

textBuf,

ScriptCode
pascal

Boolean

short

textOffset,

script) ;
short

textOffset,

script) ;

FillParseTable
(CharByteTable

table,

ScriptCode

script);

Directly Accessing International Resources
pascal

void

ClearIntlResourceCache
(vo1id)

pascal

Handle

;

GetIntlResource
(short

pascal

void

thelID);

GetIntlResourceTable
(ScriptCode
Handle

script,

short

tableCode,

*itlHandle,

long

*offset,

long

*length) ;

Tokenization
pascal

TokenResults

IntlTokenize
(TokenBlockPtr

tokenParam) ;

Transliteration
pascal

OSErr

TransliterateText
(Handle
short

srcHandle,
target,

Handle

long

dstHandle,

srcMask,

ScriptCode

script);

Replacing a Script System’s Default Routines
pascal

Ptr

GetScriptUtilityAddress
(short

selector,

ScriptCode
pascal

pascal

void

Ptr

(short

selector,

Ptr

routineAddr,

before,

ScriptCode

script);

trapNum,

Boolean

forPrinting,

before,
ScriptCode

script) ;

SetScriptQDPatchAddress
(short
Boolean

trapNum,

Summary of the Script Manager

Boolean

forPrinting,

ScriptCode

6-126

Boolean

GetScriptQDPatchAddress
Boolean

void

before,

SetScriptUtilityAddress

(short
pascal

Boolean

script) ;

script) ;

before,
Ptr

routineAddr,

CHAPTER

Script

6

Manager

Assembly-Language Summary
Trap Macros
Trap Macro Names
Pascal name

Trap macro name

FontScript

_FontSeript

IntlScript

_IntlSeript

KeyScript

_KeyScript

FontToScript

_FontToScript

GetScriptManagerVariable

_GetScriptManagerVariable

SetScriptManagerVariable

_SetScriptManagerVariable

GetScriptVariable

_GetScriptVariable

SetScriptVariable

_SetScriptVariable

CharacterByteType

_CharacterByteType

CharacterType

_CharacterType

TransliterateText

_TransliterateText

FillParseTable

_FillParseTable

GetScriptUtilityAddress

_GetScriptUtilityAddress

SetScriptUtilityAddress

_SetScriptUtilityAddress

GetScriptQDPatchAddress

_GetScriptQDPatchAddress

SetScriptQDPatchAddress

_SetScriptQDPatchAddress

IntlTokenize

_Int1lTokenize

GetIntlResource

_GetInt1lResource

ClearInt

_ClearInt]lResourceCache

lLResourceCache

GetIntlResourceTable

_GetIntlResourceTable

Global Variables
SysDirection
BootDrive

— System direction; the primary line direction and alignment for text
The drive number of the startup volume

Summary

of the Script

Manager

6-127

C

HAPTER 7

Text Services Manager

Contents
About Text Services
7-6
About Input Methods
7-6
About the Text Services Manager

= 7-9

The Text Services Environment

7-9

The Text Services Manager and Input Methods
7-11
Inline Input
7-11
Floating Input Windows
7-13
Floating Utility Windows
7-14
About Text Service Components
7-14
Using the Text Services Manager (for Client Applications)
Testing for the Availability of the Text Services Manager
Calling the Text Services Manager
= 7-17
Initializing as a TSM-Aware Application
7-18
Creating a TSM Document
7-18
Making Text Services Available to the User
7-20
Activating and Deactivating a TSM Document
7-20
Passing Events, Menu

Selections, and Cursor Setting

7-17
7-17

7-21

Con rming Active Text Within a TSM Document
7-23
Deleting a TSM Document
7-24
Closing Down as a TSM-Aware Application
= 7-24
Requesting a Floating Input Window for Text Entry
7-24
Associating Input Methods With Scripts and Languages
7-25
Handling Text Service Apple Events
7-25
Receiving Text and Updating the Active Input Area
7-26
Converting Screen Position to Text Offset
7-29
Converting Text Offset to Screen Position
7-32
Showing or Hiding the Input Window
7-36
Direct Access to Text Service Components
7-36
Calling the Component Manager
7-36
Calling Text Service Components
7-37
Contents

CHAPTER

7

Using the Text Services Manager (for Text Service Components)
7-37
Providing Menus and Icons
7-38
Providing a Text Service Component Menu
7-38
Providing Input Method Icons for the Keyboard Menu
7-39
Responding to Calls
7-40
Initiating a Text Service
7-41
Activating Text Service Component Windows
7-41
Responding to Events and Updating the Cursor and Menu
7-41
Con rming Active Text Input
7-42
Closing a Text Service
7-42
Identifying the Supported Scripts and Languages
7-42
Making Calls
7-44
Sending Apple Events to Client Applications
7-44
Opening Floating Utility Windows
7-48
Text Services Manager Reference
7-48
Text Services Manager Routines for Client Applications
—_ 7-48
Initializing and Closing as a TSM-Aware Application
7-49
Creating and Activating TSM Documents
7-50
Passing Events to Text Service Components
7-54
Passing Menu Selections and Cursor Setting = 7-55
Con rming Active Input in a TSM Document
7-56
Making Text Services Available to the User
7-57
Requesting a Floating Input Window
7-61
Associating Scripts and Languages With Components
7-62
Apple Event Handlers Supplied by Client Applications —_ 7-65
Creating and Updating an Active Input Area
7-68
Converting Global Coordinates to Text Offsets
7-72
Converting Text Offsets to Global Coordinates
7-74
Showing or Hiding the Floating Input Window
7-76
Text Services Manager Routines for Components
7-77
Sending Apple Events to a Client Application
7-77
Opening Floating Utility Windows
7-79
Text Service Component Routines
7-84
Providing a Text Service
7-84
Responding to Events and Updating the Cursor and Menu
7-87
Con rming Active Input in a TSM Document
7-89
Identifying the Supported Scripts and Languages
7-90
Summary of the Text Services Manager
= 7-92
PascalSummary
7-92
Constants
7-92
Data Types
7-94
Text Services Manager Routines for Client Applications
7-95
Text Services Manager Routines for Components
7-97
Text Service Component Routines
7-97
C Summary
7-98
Constants
7-98
Data Types
7-101

7-2

Contents

CHAPTER

7

Text Services Manager Routines for Client Applications
Text Services Manager Routines for Components
7-104
Text Service Component Routines
7-104
Assembly-Language Summary
7-105
‘Trap Macros
7-105
Result Codes
7-107

Contents

7-102

CHAPTER

7

Text Services Manager

This chapter describes how text-processing applications can communicate fexibly and
ef ciently with utilities that provide services to those applications. Applications that need
input methods, spell-checking, hyphenation, and so forth can use the Text Services
Manager to search for, obtain information about, and communicate with those utilities.

Utilities can use the Text Services Manager to request actions and information from
applications, and to send data to them.

Read this chapter if you are developing or enhancing an application to use text services.
In particular, if you want your application to support text input in a 2-byte script system,
you should use the Text Services Manager. Your application will then work with multiple
script systems and many input methods.
Read this chapter if you are writing or adapting a utility that provides a text service such
as text input. Utilities that work with the Text Services Manager are called text service
components. If your utility is a text service component, it will be able to communicate with
a wide range of applications.
Before reading this chapter, read the chapter Ontroduction to Text on the MacintoshOin
this book. To use this chapter, you should also be familiar with the Apple Event Manager
and the Component Manager. For details on the Apple Event Manager, see Inside
Macintosh: Interapplication Communication. For more on the Component Manager, see
Inside Macintosh: More Macintosh Toolbox.
This chapter refers to routines, constants, and data structures from QuickDraw, the Event

Manager, the Window Manager, the Menu Manager, and the Process Manager. For details
on QuickDraw, see Inside Macintosh: Imaging. For more on the Event Manager, Window
Manager, and Menu Manager, see Inside Macintosh: Macintosh Toolbox Essentials. For
information on the Process Manager, see Inside Macintosh: Processes.

This chapter rst provides a brief introduction to text services in general, input methods
in particular, and the Text Services Manager itself. If you are writing an application, it
then discusses how you can
m use the Text Services Manager routines for client applications, to send information to
text service components

m implement the text-service Apple event handlers in your client application, to receive
information from text service components
m communicate directly with the Component Manager and text service components, if
your application@ special needs require you to bypass the Text Services Manager
If you are writing a text service component, this chapter discusses how you can
=m implement the text service component routines, so that the Text Services Manager and
client applications can request the text services you provide
m use the Text Services Manager routines for text service components, to send
information to client applications and the Text Services Manager

CHAPTER

7

Text Services Manager

About Text Services
The Text Services Manager is the part of Macintosh system software that maintains
communication between applications that need text services and utility programs that
provide them. The Text Services Manager exists so that these two types of programs can
work together without needing to know anything about each othersGnternal structures
or identities.
A text service is aspeci c text-handling task such as spell-checking, hyphenation, and
handling input of complex text. A text service component is a utility program that uses
the Text Services Manager to provide a text service to an application. Text service
components are registered components with the Component Manager, as described in the
Component Manager chapter of Inside Macintosh: More Macintosh Toolbox.
A client application is a text-processing program that uses the Text Services Manager to
request a service from a text service component. To accomplish this, a client application
needs to make the Text Services Manager aware of its existence and needs to make
speci c Text Services Manager calls during execution.
In principle, text services can include many different types of tasks. However, only one
type of text service is currently de ned: text input. This chapter describes how to work
with any type of text service component, and how to create any type of text service
component, but it emphasizes input methods. It also points out the ways in which input
methods are handled differently from other types of text service components.

About Input Methods
An input method is a facility that automatically converts phonetic or syllabic characters
into ideographic or other complex representations. It permits use of a standard keyboard
to generate the thousands to tens of thousands of different characters needed by
some languages. Text input in Japanese, Chinese, and Korean usually requires an
input method.
For example, text input in the Japanese script system requires software for transcribing
Romaji (phonetic Japanese using Roman characters) or Hiragana (syllabic Japanese) into
ideographic Kanji (Chinese characters). Each Kanji character may correspond to more
than one possible Hiragana sequence, and vice versa. The input method must
grammatically parse sentences or clauses of Hiragana text (which has no word
separations) and select the best combination of Kanji and Hiragana characters to
represent that text.
Chinese text input is similar to Japanese, in that a conversion from Pinyin (Roman) or
Zhuyinfuhao (phonetic) to ideographic Hanzi (Chinese characters) is required. Korean
text input requires conversion from Jamo (phonetic) to non-ideographic Hangul
(complex clusters of Jamo).

7-6

About Text Services

CHAPTER

7

Text Services Manager

Bottomline input allows the user to type text into a special floating input windowN
usually displayed in the lower portion of the screenN where conversion is to take place.
The fSoating input window typically appears whenever the user starts typing characters.
See Figure 7-1.
Figure 7-1

Bottomline input with a floating input window

=O

untitled

&5#,5 ER]

S|

nt

a
oe

vl

Inline input is an input method in which conversion of characters takes place at the
current line position in the application where the text is intended to appear. This allows
the user to type text directly into the application window and requires no separate input
window. Inline input is the principal example of the kind of text service supported by the
Text Services Manager. See Figure 7-2.
Figure 7-2

Inline input

xxx"
58, 5RRe05kU

z_“pMt tL

|
|

|

a)

About Input Methods

7-7

CHAPTER

7

Text Services Manager

With either bottomline input or inline input, the user can usually type Roman characters
or characters of another subscript. Figure 7-3 shows an example of a Soating palette, with
which the user can select whether text entry is to be in 1-byte or 2-byte Romaji, Katakana,
or Hiragana. The user presses a key such as the Space bar to initiate conversion from the
input characters to the nal characters.
The input method is often extended so that characters may be converted in extremely
precise ways. For example, in the Japanese script system, when Hiragana text is
converted to Kanji, the user has the option of changing any individual phrase:
lengthening it, shortening it, or selecting different possible interpretations. Figure 7-3
shows a scrolling list of additional conversion options displayed next to the converted
text in a Soating input window. Only after the user is satis ed with the conversion and
presses the Return key is the text actually sent to the application.
Figure 7-3

Displaying conversion options for bottomline input

Ss

untitled

&5 #55]

aa

at

<
[Oo

|

eh

|? RE
|
[2]
old]

>
har FRAS AT)
£54 D(U5 AVS)
[botad(asnt)

oz

Input methods commonly rely upon one or more dictionaries to perform conversion. The
main dictionary lists all standard conversion options for any valid syllabic or phonetic
input. Besides using the main dictionary, users can add specialized dictionaries, such as
legal or medical dictionaries, to extend the range of the input method. See the chapter
(Dictionary ManagerOin this book for more information.

About Input Methods

CHAPTER

7

Text Services Manager

About the Text Services Manager
The Text Services Manager links text service components to client applications that use
text services. When a client application requests a service from the Text Services Manager,
the Text Services Manager routes the request to a text service component associated with
that application. The text service component processes the request and may send text or
other information back to the Text Services Manager, which passes it on to the client
application through an Apple event.
An application that explicitly uses the Text Services Manager is called a TSM-aware
application. An application that does not make calls to the Text Services Manager is
called non-TSM-aware. A non-TSM-aware application can still make indirect use of some
services of the Text Services Manager; see (Floating Input WindowsOon page 7-13.

The Text Services Environment
The text services environment is a structure for the ef cient Sow of information between
client applications and text service components. It allows client applications to obtain text
services without having to know anything about the speci c text service components
performing them. Likewise, it allows text service components to perform their services
without having to know anything about the speci c client applications making the
requests.

The text services environment consists of a client application, a text service component,
the Apple Event Manager, the Component Manager, and the Text Services Manager. For a
client application to work within the text services environment, it must
m call the routines of the Text Services Manager application interface described under
Cfext Services Manager Routines for Client ApplicationsOon page 7-48. By using these
application-level routines, a client application becomes TSM-aware and communicates
with other parts of the environment.
= implement handlers for the Apple events described under OApple Event Handlers
Supplied by Client ApplicationsOon page 7-65. A client application receives text and
other information from a text service component through Apple events.
For a text service component to work within the text services environment, it must

m register as a component with the Component Manager
m call the routines of the Text Services Manager component interface described under
Ofext Services Manager Routines for ComponentsOon page 7-77
m implement the component-level text service component routines described under
Clext Service Component RoutinesOon page 7-84

About the Text Services Manager

7-9

CHAPTER

7

Text Services Manager

Figure 7-4 shows some of the Sow of information in the text services environment when a
TSM-aware application uses a text service component. Application-level calls that an
application makes to the Text Services Manager application interface are converted to
component-level calls that are passed to an individual text service component. The text
service component in turn makes calls to the Text Services Manager component interface;
those calls are converted to Apple events that are passed on to the application.
The Text Services Manager controls the overall process by keeping track of which text
service components are available to a given application and which application is to
receive data from a given text service component. The Text Services Manager
communicates with text service components through the Component Manager;
applications that have special needs can likewise communicate directly with individual
text service components by calling the text service component routines.
Figure 7-4

How a TSM-aware client application uses the Text Services Manager

Apple
event

eS
“0 CO

oI

oo

oo

~~ a”

[_]

Flow of text input

[J

Other calls

Input

=) SS =

TSNaware

application

Lo

Text
Services

~~

Key-down

Key-down

event

event

Text service
component

IMPORTANT

The event-handling structure of the Text Services Manager requires that
the low-memory global variable SEvt Enb be nonzero. If your
application sets SEvt Enb to 0 to force the Event Manager function
SystemEvent to always return a value of FALSE, text service
components do not function correctly. See Inside Macintosh: Macintosh
Toolbox Essentials for more information on the SystemEvent function

and the SEvtEnb global variable. a

7-10

About the Text Services Manager

CHAPTER

7

Text Services Manager

The Text Services Manager and Input Methods
Although the Text Services Manager can work with any type of text service component, it
provides several features speci c to input methods for 2-byte script systems. The Text
Services Manager synchronizes the current input method with the current keyboard
script. For example, if the user changes from a Japanese to a Chinese font, the application
changes the keyboard script to Chinese and the Text Services Manager then switches the
current input method from Japanese to Chinese as well. Unlike with other text services,
the Text Services Manager opens and closes input methods, and takes care of their menu
handling.

Inline Input
A principal feature of the Text Services Manager is its support for inline input. Figure 7-4
shows how information Sows through the Text Services Manager when a TSM-aware
application uses it for inline input. The application passes key-down events to the
text service component; the text service component sends text and messages back to
the application with Apple events. Events, messages, and requests for service
between the application and the text service component all pass through the Text Services
Manager.
For inline input, the Text Services Manager offers routines that let client applications and
text service components communicate about what happens in the active input areaN the
portion of the screen in which the user enters text and where the text service component
displays converted text. The client application and the text service component share
control over the active input area.
The active input area is almost like a small window with invisible borders inside of the
application® document window. It replaces the insertion point in the document, but it
can be any width; it can even occupy more than one entire line of text. Text within the
active input area can have its own font and size, different from that of body text. Text

within the active input area can even scroll out of sight if there is more text than can
the space allotted for it in the active input area.

tin

The application is responsible for determining the location and size of the active input
area, and for drawing and highlighting all text within it. The text service component

is responsible for accepting user input (as key-down events), for converting input text
to nal text, and for telling the application what characters to drawN and what characters
to accept as con rmedNat every step of the way. The text service component can also
instruct the application to scroll certain parts of the active input area into
view, if necessary.

About the Text Services Manager

7-11

CHAPTER

7

Text Services Manager

The text service component processes the user input, called raw text, as it is entered. The
text service component rst has the application draw the text on the screen as entered.
Then it converts the raw text, translating it from phonetic or syllabic to ideographic or
complex syllabic characters. Finally, it confirms the converted text upon user approval of
the conversion. By convention in some script systems, a text service component converts
text when the user presses the Space bar after entering a sequence of characters, and
con rms the converted text when the user presses Return to accept the conversion.
See Figure 7-5. (In Korean, conversion happens continuously and automatically, and
con rmation happens by convention when the user presses either Return or the
Space bar.)
Figure 7-5

Entering, converting, and confirming text in an active input area

Ta
1. User enters raw text (gray underline) into
active input area.

2. User presses Space bar; raw text is
converted (black underline) but remains
in active input area.

____EZ_aZ

AZ

Te

Bee

3. User presses Return; converted text is
confirmed (no underline). Active input
area closes.

Dk

4. New active input area opens when user
enters more raw text.

The text service component continually removes the con rmed input from the active
input area and sends it to the application for storage in its text buffer. The text service
component uses Apple events for this purpose, and for notifying the application of every
character (raw, converted, or con

active input area.

rmed) that needs to be drawn or highlighted within the

In a number of situations, a client application may need to initiate the con rmation of
input in progress. For example, if a user switches input methods, makes a menu
selection, or selects text outside the active input area, the user has implicitly requested
con rmation of the existing text. The client application needs to inform the text service
component so it can con

rm all text, whether raw or converted, in the active input area.

The client application can make that request through a call to the Text Services Manager.

7-12

About the Text Services Manager

CHAPTER

7

Text Services Manager

Floating Inout Windows
The Text Services Manager also provides a service to facilitate the use of an input
window for text entry and conversion when inline input is not supported by the
application or not desired by the user. This Soating input window is a standard
bottomline input window: it usually appears in the lower portion of the screen, although
the user can drag it to any location. Once the user@ text has been converted correctly
in the window, it is sent to the application.
The Text Services Manager@ Boating input window is mainly for use with applications
that are not TSM-aware. See Figure 7-4. The input window uses the floating window
service, a part of the Text Services Manager. It works this way:
1. The Process Manager intercepts key-down events and passes them to the
Text Services Manager.
2. The Text Services Manager passes them to the appropriate input method
for processing.
3. The input method then passes the processed text back to the Text Services Manager.
The fSoating window service displays the text in a Soating input window.
4. When the user is nished with the text, the Soating window service passes the
processed text back to the client application through standard key-down events
(not Apple events).
Figure 7-6

How a non-TSM-aware application uses the Text Services Manager

Non-TSM-

aware

application

<

Key-down
event

. OD Co

~~ a

oa

ty

[_]

Flow of text input

[J

Other calls

ci

A

|

Input

| /I] Floating window —)
7

:

service

Text Services]
Manager

d

<2=====||

“reyaoun

Text service

component

Key-down
event

In this way the Text Services Manager can provide an input method text service
component for applications that have no knowledge of the text services environment.
TSM-aware applications should normally use inline input. However, the Text Services
Manager does allow TSM-aware applications to use a Soating input window. Users may
prefer bottomline input if the size of the text displayed in the document makes reading
the characters dif cult.

About the Text Services Manager

7-13

CHAPTER

7

Text Services Manager

Floating Utility Windows
Floating windows are useful for more than just text entry. Input methods can use the Text
Services Manager Soating window service to create utility windowsN 8oating windows
that display palettes or present lists of choices to the user. For example, most Japanese
input methods let a user set the input mode to either 2-byte Hiragana, 1-byte Hiragana,
2-byte Romaji, or 1-byte Romaji. In the past, users selected these modes from controls
inside the input method@ input window. Now, since the system provides a standard
Soating input window for non-TSM-aware applications as well as for TSM-aware
applications that request it, input methods should offer mode selection in a separate
Soating palette. Figure 7-3 on page 7-8 shows an example of a Soating palette window
used with bottomline input; Figure 7-9 on page 7-33 shows the same palette used with
inline input.
Figure 7-7 illustrates the window-layer organization provided by the Text Services
Manager. A Soating window, whether an input window

or a utility window, is always in

front of all application windows but behind any help balloons.
Figure 7-7

Floating window service layer

Untitled-1

Untitled-1

Application layers

a
Floating window layer
Besku

om
aa

en:
Ee

4
_..----.----------- 4
: Help layer
al

Input window
Floating palette

:

Help

ae

balloon

Te

|

About Text Service Components
Text service components are components as de ned and used by the Component
Manager. They have a speci c structure, interface, and manner of execution. For more
information on components, see the chapter CComponent ManagerOin Inside Macintosh:
More Macintosh Toolbox. This section briefsy describes the component description record,
a data structure associated with a text service component.

7-14

About Text Service Components

CHAPTER

7

Text Services Manager

The component description record, maintained by the Component Manager for each
registered component, identi es the characteristics of the component, including the
nature of services provided by the component and the manufacturer of the component. It
is lled out by the text service component at initialization.
The ComponentDescription data type de nes the format of the component
description record:
TYPE

ComponentDescription

=

RECORD

componentType:

OSType;

{command

component

OSType;

{specifies

componentFlags:

OSType;
OSType;

{vendor ID}
{control flags}

componentFlagsMask:

OSType;

{mask

SubType:

set

ID}

flavor}

componentManufacturer:

for

control

flags}

END;

Field descriptions

componentType

For text service components, this eld contains the interface type.
The interface type speci es the set of Apple events and component
commands associated with the text service component. Currently, all
text service components have the same interface type,
kText Service, whose associated 4-character tag is

'tsvc'. To

obtain a list of all available text service components, a client
application can specify the value kText Services in the
componentType eld when calling the Component Manager
routine GetServiceList.
component SubType

For text service components, this eld contains the text service
component type. The text service component type speci es the

function and optionally a set of additional routines and data
structures associated with that particular kind of text service

component. Currently, only one text service component type is
de ned, 'inpm', specifying an inline input method.

componentManufacturer
The identi cation number of the manufacturer of this particular text
service component.

About Text Service Components

7-15

CHAPTER

7

Text Services Manager

componentFlags

Four bytes that contain component-speci
Figure 7-8:

c information. See

Bits 0 7 contain the language code (as unsigned 8 bits).
Bits 8 14 contain the script code (as unsigned 7 bits).
Bit 15 indicates whether the text service component takes active
events. When bit 15 = 1, the text service component is interactive

and accepts user events. When bit 15 = 0, the text service component

is not interactiveN that is, it only supplies batch services.
Apple has reserved bits 16 23, so text services must set them to 0.
The Component Manager de nes bits 24 31.
Figure 7-8

The format of the

31

2423

161514

L

aN

J|\

component Flags

87

|

NK

field of the component description record

0
)

|____ Language code

Script code
Takes active
key events
Reserved: must be set to 0
Flags defined by the Component Manager

componentFlagsMask

Four bytes that contain values used to affect the

eld. This

component

Flags

eld should be 0 in the component description record for

any text service component.

For example, an input method for the Japanese script system might assign the following
values to the componentType,

component description record.
cd:

elds of

ComponentDescription;

cd.componentType

:=

kTextService;

cd.componentSubType

:=

kInputMethodService;

{'inpm'}

$0000810B;

{Japanese

script

{

user

cd.componentFlags

7-16

component SubType, and componentFlags

About Text Service Components

{'tsvc'}

--takes

&

language

events}

}

CHAPTER

7

Text Services Manager

Using the Text Services Manager (for Client Applications)
This section describes how your client application can use the Text Services Manager
application interface to communicate with text service components, how it can use Apple
event handlers to receive information from text service components, and how it can
communicate directly with text service componentsN bypassing the Text Services
Manager altogetherN for special purposes.

Testing for the Availability of the Text Services Manager
Use the Gestalt environmental selector

gestalt TSMgrVersion to determine whether

the Text Services Manager is available. The Gestalt function returns a 32-bit value
indicating which version of the Text Services Manager is installed.
For more information on the Gestalt
Macintosh: Operating System Utilities.

function, see the Gestalt Manager chapter in Inside

Calling the Text Services Manager
The application interface to the Text Services Manager consists of application-level calls
that your client application uses to send information to text service components by way
of the Text Services Manager. They are documented in detail under Mfext Services
Manager Routines for Client ApplicationsOon page 7-48. The Text Services Manager
maps many of those calls to equivalent component-level calls to text service components.
Those text service component routines are described under Clext Service Component
RoutinesOon page 7-84.
This section describes how your client application can use the application interface to the
Text Services Manager to
m prepare for communication with the Text Services Manager
m create an internal record called a TSM document
m make text services other than text input available to the user
m activate and deactivate a TSM document
m give text service components a chance to handle events, respond to menu selections,
and set the shape of the cursor
m explicitly con

rm text within the active input area

m terminate communication with the Text Services Manager

Using the Text Services Manager (for Client Applications)

7-17

CHAPTER

7

Text Services Manager

Initializing as

a TSM-Aware Application

If your client application plans to use any of the Text Services Manager
application-interface routines, it must call Init TSMAwareApplication at startup,
immediately after calling the rest of the Toolbox initialization routines. See Listing 7-1.
Listing 7-1

Initializing as

FUNCTION

Initialize:

a TSM-aware application
OSErr;

VAR

myErr:

OSErr;

BEGIN

InitGraf

(@thePort)

;

InitFonts;
InitWindows;
InitMenus;
TEInit;

InitDialogs
(NIL) ;
InitCursor;

IF

(InitTSMAwareApplication

Initialize

:=

DoNew;

=

noErr)

THEN

{application routine that }
{ creates window & TSM document}

END;

The Text Services Manager records the fact that your client application is TSM-aware, and
allocates any private data storage as necessary.

Creating

a TSM Document

Your client application needs to create an internal record called a TSM document
(de ned by the TSMDocument data type) before it can use any services provided through
the Text Services Manager. A TSM document is a private data structure that is associated
with each of your application® documents that use a text service. You cannot access the
TSM document record directly. You call the NewI'SMDocument function to instruct the
Text Services Manager to create the TSM document. The Text Services Manager returns a
TSM document ID, an identi er that you supply in subsequent calls to the Text Services
Manager.
Typically, you create a TSM document for each window that your application uses. Use
the supportedInterfaceTypes

array to indicate which text service interfaces you

support. Currently only one interface is de nedN 'tsvc', the component type for text
services components. Pass any data you like in the refcon parameter to the call. The
Text Services Manager returns the refcon value in the keyAETSMDocumentRefcon
parameter of any Apple event sent to your application. You can then use the refcon
value to determine which TSM document and window the Apple event belongs to.

7-18

Using the Text Services Manager (for Client Applications)

CHAPTER

7

Text Services Manager

Listing 7-2 shows the sample application@ DoNew function, which is called from the

initialization routine presented in Listing 7-1. The call to NewT'SMDocument speci es that
the application supports one interface type (kText Service). NewTSMDocument opens
the default input method for the current keyboard script, assigns it to this document, and
returns the TSM document ID in the idocID parameter. The routine makes use of a
modi ed window record (type MyWindowRecord) that is a standard window record
with an additional eld for holding the TSM document ID.
Listing 7-2

Creating

FUNCTION

DoNew:

a new TSM document and associating it with a window

OSErr;

VAR

wRecordPtr:

myWindowPtr;

window:

WindowPtr;

supportedTypes:

InterfaceTypeList;

myErr:

OSErr;

BEGIN

supportedTypes[0]

:=

kTextService;

{allocate
wRecordPtr
IF

:=

myWindowPtr

wRecordPtr

<>

NIL

(NewPtr

storage

(sizeof

for

window

record}

(myWindowRecord)
) ) ;

THEN

BEGIN

IF

gColorQDAvailable
window

:=

THEN

GetNewCWindow(kWINDResID,

Ptr(wRecordPtr),

WindowPtr(-1) )
ELSE

window

:=

GetNewWindow(kWINDResID,

Ptr(wRecordPtr),

WindowPtr(-1));

IF

window

= NIL

THEN

{couldn't

get

window}

BEGIN

DisposePtr (Ptr (wRecordPtr)
DoNew

:=

) ;

{clean

up}

kWindowFailed;

Exit (DoNew) ;
END;

myErr

:=

NewTSMDocument
(1,

supportedTypes,

wRecordPtr*.idocID,
LongInt

(wRecordPtr)

) ;

END;

{do

other

DoNew

:=

window

intialization,

like

creating

scroll

bars}

myErr;

END;

Using the Text Services Manager (for Client Applications)

7-19

CHAPTER

7

Text Services Manager

Making Text Services Available to the User
Text services that are input methods are always displayed in the keyboard menu. System
software takes care of that; your application does not need to list input methods.
However, your application may wish to provide a menu or scrolling list to display other
types of available text services. (Note that, currently, no text services other than input
methods are available. This capability is provided for future extensibility.)
To obtain a list of the available text services on the user@ system, call the
GetServiceList function. You pass it an array of interface types (to indicate the types
of services you want returned in the list) and a pointer to a data structure (to hold the
list). The function returns the number of available components, and a name and

component identi

er for each one.

Because text service components can be registered or unregistered at any time, your
client application should periodically call either Get ServiceList or the Component
Manager function Get Component ListModSeed to see if the list of registered text
service components may have changed.
IMPORTANT

If your client application displays a list or menu of text
service components, do not show input methods. They are already
displayed in the Keyboard menu. To show them in two places would
be confusing to users. A
The Text Services Manager automatically opens input methods; your client application
does not have to open them. You do have to explicitly open all other types of text
services, however. If the user chooses a text service from a menu or list that you have
displayed, you need to open that text service.
You call the OpenText Service function to associate the text service component with
the current TSM document. OpenText Service then returns a valid component instance
to indicate that the text service component has been opened and initialized.
Whenever a user wishes to close a text service component that you have opened, call the
CloseTextService function.

Activating and Deactivating

a TSM Document

To notify the Text Services Manager that a window in your client application associated
with a TSM document has been activated, and that you are ready to use a text service
component, use the ActivateTSMDocument

function.

Listing 7-3 shows how to handle activating and deactivating a TSM document. You
specify the document using the ID assigned to it when it was created (with the
NewTSMDocument function). This routine, like the previous samples, assumes that
the application has an extended window record witha
eld, idocID, that contains the
TSM document ID.

7-20

Using the Text Services Manager (for Client Applications)

CHAPTER

7

Text Services Manager

Listing 7-3
PROCEDURE

Activating and deactivating
DoActivate

(window:

a TSM document
WindowPtr;

becomingActive:

Boolean) ;

VAR
myErr:

OSErr;

BEGIN
IF

becomingActive
myErr

THEN

:=

ActivateTSMDocument
(MyWindowPtr (window) *.idocID)

:=

DeactivateTSMDocument
(MyWindowPtr (window) *.idocID)

ELSE
myErr

;

END;

When the Text Services Manager receives an ActivateTSMDocument

call, it deactivates

the currently active TSM document (if it hasn@already been explicitly deactivated) and
stores the new document as the currently active TSM document. If the speci ed text
service component for the document has a menu, the Text Services Manager inserts the

menu into the menu bar as an application or system menu.

When a window in your client application associated with a TSM document has been
deactivated, you should call the DeactivateTSMDocument function. The Text Services
Manager in turn calls the text service component function DeactivateTextService
for any text service components associated with the TSM document being deactivated.
Input-method text services are handled in a special way: the identity of the input method
of the deactivated document is retained by the Text Services Manager, and compared
with the input method used by the next activated document. If the newly active document
uses the same input method, the Text Services Manager will simply activate the new
instance of the same input method. If the documents use different input methods, the
previous input method is then closed, and any windows belonging to it are closed and
menus are removed. The new input method is then activated. Not closing an input
method until it is actually unneeded avoids extra removal and immediate redisplay of
input method palettes and menus.

Passing Events, Menu Selections, and Cursor Setting
Whenever your client application receives an event from the Event Manager function
WaitNextEvent, you need to give each text service component an opportunity to
handle that event, if appropriate. Use the TSMEvent function to let the Text Services
Manager dispatch the events to the correct text service component. You provide a pointer
to the event record containing the event. The Text Services Manager passes the event in
turn to each component associated with the currently active TSM document, starting
with input methods. If the event is handled by a component, TSMEvent returns TRUE
and the event is changed to a null event. If the event is not handled, TSMEvent returns
FALSE and you are responsible for handling the event.
Listing 7-4 is a partial example of an event handler in which the application passes
events to the Text Services Manager for routing to text service components. If no text
service component handles an event, the application handles it. The global variable

Using the Text Services Manager (for Client Applications)

7-21

CHAPTER

7

Text Services Manager

gUsingTSM is TRUE if the Text Services Manager is present and the application is making
use of it.
Listing 7-4

PROCEDURE

Passing events to a text service component

MyDoEvent

(event:

eventRecord) ;

VAR

handledByTs

:

gotEvent:

Boolean;
Boolean;

BEGIN
WHILE

TRUE

DO

BEGIN

IF

gHasWaitNextEvent

THEN

BEGIN

gotEvent

:=

WaitNextEvent

(everyEvent,

kSleep,
handledByTS

IF

:=

event,

NIL);

FALSE;

(gUsingTSM

AND

gotEvent)

THEN

handledByTS

:=

TSMEvent

(event)

;

END;

IF

gotEvent

AND

{process

event

(NOT

in

handledByTS)

normal

THEN

way}

END;
END;

Whenever a user chooses a menu item, it may be from a text service component@ menu;

your application must therefore give the text service component a chance to respond.
(This situation occurs only with text service components that are not input methods.)
To do this, use the TSMMenuSelect function with the result from the Menu Manager
function MenuSelect in the menuResult parameter. If TSMMenuSelect returns TRUE,
then the text service component has handled the menu selection, so your client
application does not need to do so. However, your application is still responsible for
removing the highlighting from the menu title after the selection has been handled.

Your client application is generally responsible for setting the cursor to an appropriate
shape. However, the text service component may have its own cursor requirements when
the cursor is within the boundaries of its windows or palettes. To allow a text service
component to set the cursor, use the

Set TSMCursor function. Call it whenever you

would normally set the cursor yourself. If Set TSMCursor returns TRUE, the cursor is
either on a text service component window or on the active input area and a text service
component has set the cursor. In this case, you should not set the cursor.

7-22

Using the Text Services Manager (for Client Applications)

CHAPTER

7

Text Services Manager

Confirming Active Text Within

a TSM Document

Normally, an input method text service component ejects nished input from the active
input area continually as it processes user events, sending the con rmed text to your
application with the Update Active Input Area Apple event.
Circumstances may arise in which you need to con rm input in progress before the text
service component ejects it (that is, before the user presses Return). If, for example, the
user clicks the mouse in text outside the active input area, that constitutes an implicit

user acceptance of the text in the active input area. You should explicitly terminate any
active input and save the text that is in the active input area by calling the
FixTSMDocument
function. The text service component sends the con rmed
text to your
application and empties the active input area.
Listing 7-5 shows what happens when the user clicks the go-away box of the active
document window after entering some text in the active input area. The global variable
gIDocID represents the ID of the active TSM document.
Listing 7-5

Confirming text in an active input area

PROCEDURE

DoMouseDown

(event:

EventRecord) ;

VAR
part:

Integer;

theWindow:

WindowPtr;

myErr:

OSErr;

BEGIN
part

:=

CASE

part

FindWindow(event.where,

theWindow) ;

OF

inContent :
DoContentClick

(theWindow,

event);

inDrag:
DragWindow(theWindow,

event.where,

theWindow*.portRect) ;
inGoAway:
IF

TrackGoAway

(theWindow,

event.where)

THEN

(gIDocID)

{confirm

BEGIN

myErr

:=

FixTSMDocument

DoActivate (theWindow, FALSE) ;
HideWindow (theWindow) ;
gVisible

:=

;

text}

{deactivate window}
{put it away}

FALSE;

END;
END;
END;

Using the Text Services Manager (for Client Applications)

7-23

CHAPTER

7

Text Services Manager

Deleting

a TSM Document

When your client application closes a document window and no longer needs its
associated TSM document, it needs to call the DeleteTSMDocument

the Text Services Manager that the TSM document should be deleted.

function to inform

The Text Services Manager closes the text service components for the speci ed TSM
document by calling the Component Manager CloseComponent function for each open
text service component. It then disposes of the internal TSM document record for the
speci ed TSM document.

Closing Down as a TSM-Aware Application
To let the Text Services Manager perform needed housekeeping chores when your
application has closed, your client application needs to call
CloseTSMAwareApplication just before quitting, as shown in Listing 7-6.

Listing 7-6
FUNCTION

Closing a TSM-aware application
DoQuitApplication:

OSErr;

VAR

myErr:

OSErr;

BEGIN

{app-specific
myErr

:=

clean

up}

CloseTSMAwareApplication;

{ignore

the

error}

ExitToShell;
END;

Requesting a Floating Input Window for Text Entry
Your client application may need to provide for users who prefer to enter text using a
Soating input window instead of entering text directly in the line of a document. For
example, when the text font size is too small for reading ideographic characters, too big
for convenient entry directly into the document window, or is being greeked, users may
prefer a Soating input window.
Your client application calls the Use Input Window function with the useInputWindow
parameter set to TRUE to display a fSoating input window for the TSM document you
specify in the idocID parameter to the call. To display fSoating input windows for all
documents associated with your application, you set the idocID parameter to NIL and
the useInput Window parameter to TRUE. To return to inline input, call
UseInput Window

7-24

with the

useInput Window parameter set to FALSE.

Using the Text Services Manager (for Client Applications)

CHAPTER

7

Text Services Manager

Associating Input Methods With Scripts and Languages
If you use the application-interface routines, the Text Services Manager automatically
associates a default input method with your TSM document every time the current script
and language change. Although it is unlikely that it would ever need to, your client
application can use Text Services Manager routines to control that automatic association.
The Operating System uses the GetDefault InputMethod and
SetDefault InputMethod functions to associate an input method with a given script
and language. When the user uses the Keyboard menu, Keyboard control panel, or other
device for controlling input method preferences, these functions establish permanent
associations (they last across restarts).
The Text Services Manager maintains a current text service language that it uses to
synchronize input methods to the current script system and language. The Operating
System calls the

Set Text ServiceLanguage function when the user switches the

keyboard script, and the Soating window service calls the
function to determine the text service language.

Get Text ServiceLanguage

These routines make use of the script-language record, described under Gdentifying the
Supported Scripts and LanguagesOon page 7-42.
If your client application uses the Text Services Manager application-interface
routines, the Text Services Manager automatically synchronizes the input method to the
current text service language and there is no need to make the calls described here.
If your client application bypasses the Text Services Manager and uses the text
service component routines, the Text Services Manager does not provide automatic input
method synchronization and you may have to make some of these calls yourself.
See Direct Access to Text Service ComponentsOon page 7-36 for more information
on the Component Manager and on how to communicate directly with text
service components.

Handling Text Service Apple Events
Text service components send information to your client application through Apple
events. To communicate with an input method text service component, you need to
implement Apple event handlers that
m receive raw, converted, or con rmed text from the input method, update the active
input area, and highlight text appropriately
m convert screen location (in global coordinates) to text offset (in the active input area or
in the application@ text buffer), so that the input method can, for example, adjust the
caret position or cursor display to refSect the text beneath the cursor
m convert text offset to screen location, so that the input method can, for example, place a
list of conversion options next to a particular section of raw text
m respond to the input methodG@ request to show or hide a Boating input window

Using the Text Services Manager (for Client Applications)

7-25

CHAPTER

7

Text Services Manager

Each Apple event contains two required parameters:
m The keyAETSMDocumentRefcon parameter is Iled in by the Text Services Manager.
It tells the application which TSM document is affected by the Apple event.
mw The keyAEServerInstance parameter is lled in by the text service component, and
identi es the component that is sending the Apple event.
Other parameters are speci c to each Apple event, and are described under OApple Event
Handlers Supplied by Client ApplicationsOon page 7-65.
For general rules for writing Apple event handlers, see the discussion of the Apple Event
Manager in Inside Macintosh: Interapplication Communication.

Receiving Text and Updating the Active Input Area
The text service component uses the Update Active Input Area Apple event to request
that your client application create and update an active input area, including drawing
text in the active input area, and accepting con rmed text. For details on active input
areas, see Cinline InputOon page 7-11. This Apple event also asks the client application to
update a range of text in the active input area and highlight appropriately.
Because your application is responsible for all drawing in the active input area, it receives
an Update Active Input Area Apple event whenever the user enters raw text (for
example, Romaji for Japanese input), whenever that raw text is converted to an
intermediate form (for example, Hiragana), whenever the text is converted (for example,
to Kanji), and whenever the converted text is con rmed. The input method also uses this
Apple event to instruct your application in how to highlight the various types of text
(raw, converted, and so on) within the active input area.

The input method uses the Update Active Input Area Apple event to send additional
information to your application, such as current caret position, a range of text that should
be scrolled into view if it is not visible, and boundaries of clauses (language-speci c
groupings of text) that may exist in the active input area.
Listing 7-7 shows a sample handler for the Update Active Input Area Apple event.
The handler rst receives the input parameters, including the text and the ranges of
text to highlight and update. The handler then puts any con rmed text into the
application@ text buffer.
Listing 7-7
FUNCTION

A sample handler for the Update Active Input Area Apple event
MyHandleUpdateActive

(theAppleEvent:
reply:

handlerRefCon:
VAR

7-26

theHiliteDesc:

AEDesc;

theUpdateDesc:

AEDesc;

theTextDesc:

AEDesc;

myErr:

OSErr;

AppleEvent ;

AppleEvent;

Using the Text Services Manager (for Client Applications)

LongInt):

OSErr;

CHAPTER

7

Text Services Manager

returnedType:

DescType;

script:

ScriptLanguageRecord;

fixLength:

LongInt ;

refcon:

LongInt ;

textSize:

LongInt ;

actualSize:

LongInt ;

thePinRange:

TextRange;

BEGIN

{Get

the

myErr

:=

IF

myErr

required

parameter

AEGetParamPtr

=

nokrr

keyAETSMDocumentRefcon}

(theAppleEvent,

keyAETSMDocumentRefcon,

typeLongInteger,

returnedType,

sizeof (refcon),

actualSize);

@refcon,

THEN

BEGIN

{Get

the

required

parameter

theTextDesc.dataHandle
myErr

:=

:=

keyAETheData}

NIL;

AEGetParamDesc(theAppleEvent,
typeChar,

keyAETheData,

theTextDesc) ;

END;

IF

myErr

<>

nokrr

THEN

BEGIN

MyHandleUpdateActive
Exit

:=

myErr;

(MyHandleUpdateActive) ;

END;

{Get

the

myErr

:=

required

parameter

keyAEScriptTag}

AEGetParamPtr(theAppleEvent,

keyAEScriptTag,

typeIntlWritingCode,
@script,
IF

myErr

=

{Get

the

myErr

:=

nokrr

sizeof

returnedType,

(script),

actualSize) ;

THEN

required

parameter

AEGetParamPtr

keyAEFixLength}

(theAppleEvent,

keyAEFixLength,

typeLongIinteger,
@fixLength,

returnedType,

sizeof

(fixlength),

actualSize) ;
IF

myErr

=

nokrr

THEN

BEGIN

{Get

the

optional

parameter

theHiliteDesc.dataHandle
myErr

:=

:=

keyAEHiliteRange}

NIL;

AEGetParamDesc(theAppleEvent,

keyAEHiliteRange,

typeTextRangeArray,

theHiliteDesc) ;

END;

Using the Text Services Manager (for Client Applications)

7-27

CHAPTER

7

Text Services Manager

IF

mykrr

<>

nokrr

THEN

BEGIN
MyHandleUpdateActive

myErr
Exit

:=

myErr;

:= AEDisposeDesc(theTextDesc) ;

{ignore

the

error}

(MyHandleUpdateActive) ;

END;

{Get

the

optional

parameter

theUpdateDesc.dataHandle
myErr

:=

keyAEUpdateRange}

:=

NIL;

AEGetParamDesc(theAppleEvent,

keyAEUpdateRange,

typeTextRangeArray,
IF

mykrr

<>

nokrr

theUpdateDesc) ;

THEN

BEGIN

MyHandleUpdateActive

:=

myErr;

myErr

:= AEDisposeDesc(theTextDesc) ;

myErr

:=

Exit

{ignore

the

error}

AEDisposeDesc(theHiliteDesc) ;

(MyHandleUpdateActive) ;

END;

{Get

the

myErr

:=

optional

parameter

keyAEPinRange}

AEGetParamPtr(theAppleEvent,
typeTextRange,
@thePinRange,

keyAEPinRange,
returnedType,
sizeof

(thePinRange)

,

actualSize) ;
MyHandleUpdateActive
IF

myErr

=

nokrr

:=

myErr;

THEN

BEGIN

textSize

:=

GetHandleSize(theTextDesc.dataHandle) ;

MyHandleUpdateActive
IF

MemError

=

nokrr

:=

MemError;

THEN

BEGIN

{if

the

value

of

keyAEFixLength

{ contained

in

{

replace

completely

{ the
IF

the

application

fixLength

=

-1

keyAETheData
the

is

-1,

the

parameter

text

}

should

active

input

area

in

fixLength

:=

textSize;

}

window}
THEN

{ the application procedure SetNewText handles }
{ updating and confirming the text in the active
{ input area, highlighting, and scrolling the }
{ specified offsets into view}

7-28

}

Using the Text Services Manager (for Client Applications)

}

CHAPTER

7

Text Services Manager

SetNewText

(refcon,

textSize,

script,

theTextDesc.dataHandle,

fixLength,

TextRangeArrayHandle

(theUpdateDesc.dataHandle),

TextRangeArrayHandle

(theHiliteDesc.dataHandle)

);

END;
END;

myErr

:=

AEDisposeDesc

(theTextDesc)

myErr

:=

AEDisposeDesc

(theHiliteDesc)

;
;

{ignore

myErr

:=

AEDisposeDesc

(theUpdateDesc)

;

the

errors}

END ;

Converting Screen Position to Text Offset
An input method text service component uses the Position To Offset Apple event when it
needs to know the byte offset in a text buffer (usually the buffer corresponding to the
active input area) corresponding to a given screen position. An input method typically
sends the Position To Offset Apple event to your application in response to a
mouse-down event. If the event location is in the application window (including the
active input area), the input method may want to know which character the event
corresponds to, in order to locate the caret or de ne highlighting.
An input method may also send Position To Offset in response to Set TSMCursor, so that
it can modify the appearance of the cursor depending on the type of text the cursor
passes over.
Your application@ handler returns a byte offset and a value indicating whether the screen
position is within the active input area. If it is, the offset is measured from the start of the
active input area (the leading edge of the rst character on the rst line). If it is not, the
offset is measured from the beginning of the application@ body text. The de nition of
body text and the signi cance of measurements within it are speci _c to your application;
here it means any application text outside of the active input area.
To help the input method more speci cally de ne individual characters, your application
can optionally return an indication as to whether the position corresponds to the leading
edge or the trailing edge of the glyph corresponding to the character at the indicated
offset.
The Position To Offset Apple event is similar in function to the QuickDraw
PixelToChar function, and returns similar results. Your handler may use
PixelToChar to get the information it returns to the text service component, or it may
use a TextEdit call, as shown in the following code sample.
Listing 7-8 shows a sample handler for the Position To Offset Apple event. The handler
rst receives the input parameters, then uses the TextEdit function TEGet Offset to
convert a screen location to text offset. The TEGet Offset function is described in the
chapter fextEditOin this book.

Using the Text Services Manager (for Client Applications)

7-29

CHAPTER

7

Text Services Manager

A sample handler for the Position To Offset Apple event

Listing 7-8
FUNCTION

MyHandlePos20ffset

(theAppleEvent:
reply:

AppleEvent;

AppleEvent;

handlerRefCon:

LongInt) :

OSErr;

VAR
myErr:

OSErr;

returnedType:

DescType;

refcon:

LongInt ;

currentPoint:

Point;

clickWindow:

WindowPtr;

where,

part:

Integer;

oldPort:

GrafPtr;

offset:

LongInt ;

te:

TEHandle;

actualSize:

LongInt ;

bodyRect :

Rect;

dragging:

Boolean;

isMatch:

Boolean;

BEGIN
{Get

the

myhrr

:=

IF

required
AEGet

myErr

=

{Get

the

myhrr

:=

parameter

nokrr

TSMDocumentRefcon}

(theAppleEvent,

ParamPtr

keyAETSMDocumentRefcon,

typeLongInteger,

returnedType,

sizeof

actualSize) ;

(refcon),

@refcon,

THEN

required
AEGet

parameter

keyAECurrentPoint }

(theAppleEvent,

ParamPtr

typeQDPoint,

keyAECurrent

Point,

returnedType,

@currentPoint,
sizeof
IF

mykrr

<>

nokrr

(currentPoint),

actualSize) ;

THEN

BEGIN
MyHandlePos20ffset
Exit

:=

myErr;

(MyHandlePos20ffset) ;

END;
where

:=

part
{the

{if

FindWindow(currentPoint,
application

the

isMatch

7-30

kTSMOutsideOfBody;

refcon
:=

function

is

IsWindowForTheAE

associated

IsWindowForTheAE

clickWindow) ;

with

the

(refcon,

Using the Text Services Manager (for Client Applications)

returns

window}

clickWindow) ;

TRUE}

CHAPTER

7

Text Services Manager

IF

((clickWindow
isMatch

=

FrontWindow)

AND

(part

=

AND

inContent))

THEN

BEGIN

Get Port

(oldPort) ;

Set Port

(clickWindow) ;

{convert

currentPoint

{

coordinates

of

GlobalToLocal

into

the

(currentPoint)

{the application function
{body rect of the window}
bodyRect
IF

:=

PtInRect

the

current

local

}

grafport }

;

GetTheBodyRect

GetTheBodyRect

(clickWindow)

(currentPoint,

bodyRect)

returns

the}

;

THEN

BEGIN

where

{the

:=

application

{ window’s
{

kTSMInsideOfBody;

TEGetOffset
te

:=

:=

returns

the

TEGetOffset

application

FindTheTEHandle

Then

FindTheTEHandle

offset

{The

function

TEHandle.

the

TextEdit

offset

returns

function

corresponding

the

}

the

point}

}
to

(clickWindow) ;
(currentPoint,

function

te);

IsInsideInputArea

returns

}

{ TRUE if offset is within the active input area. }
{ It is application's responsibility to remember }
the
IF

range

of

the

IsInsideInputArea
where

:=

input

area. }

(offset,

clickWindow)

THEN

kTSMInsideOfActivelInputArea;

END;

{get

the

optional

parameter:

dragging

:=

myErr

AEGetParamPtr

:=

keyAEDragging}

FALSE;
(theAppleEvent,
typeBoolean,

@dragging,

keyAEDragging,
returnedType,

sizeof

(dragging),

actualSize) ;
END;

IF

myErr

<>

nokrr

THEN

Using the Text Services Manager (for Client Applications)

7-31

CHAPTER

7

Text Services Manager

BEGIN
MyHandlePos20ffset
Exit

:=

myErr;

(MyHandlePos20ffset) ;

END;

{ if the parameter keyAEdragging is TRUE and the mouse}
{ position is outside the body text, the application }

{ can scroll the text within the active input area, }
{ rather than returning kTSMOutsideOfBody. The application

{

procedure

IF

HandleScroll

(dragging

=

TRUE)

is

AND

handling

(where

=

the

}

scrolling. }

kTSMOutsideOfBody)

THEN

BEGIN

HandleScroll(te,
where

:=

offset) ;

kTSMInsideOfActivelInputArea;

END;

SetPort

(oldPort)

{Construct
myErr

:=

the

;

return

parameter

AEPutParamPtr(reply,

keyAEOffset}
keyAEOffset,

@offset,
IF

myErr

=

nokrr

{Construct

the

typeLongInteger,

sizeof (offset) );

THEN
return

MyHandlePos20ffset

:=

parameter

keyAERegionClass}

AEPutParamPtr(reply,

keyAERegionClass,

typeShortiInteger,
@where,
ELSE

MyHandlePos20ffset

:=

sizeof

(where)

)

myErr;

END;

Converting Text Offset to Screen Position
An input method text service component uses the Offset To Position Apple event when it
needs to know the screen position corresponding to a given byte offset in the text buffer
for the active input area. An input method typically sends the Offset To Position Apple
event to your application when it needs to draw something in a speci c spatial
relationship with a given character in the active input area. For example, it may need to
draw a Soating window containing suggested conversion options beside a particular
range of raw or converted text. See Figure 7-9.
The text service component supplies a byte offset, measured from the character at the
start of the active input area. The application returns a point designating the global
coordinates of the caret position corresponding to that offset. Your application may
optionally return information about the font, size, and other measurements of the text in

the active input area, so that the text service component can more precisely locate the
elements it is to draw.

7-32

Using the Text Services Manager (for Client Applications)

CHAPTER

7

Text Services Manager

Figure 7-9

Drawing a window with conversion options next to the active input area

=a

edee

untitled

S|
cP

Een

[CEA SAS)

[£5 Fs 35AG)
|botad(hsnt)

old]

Je)
te) 2)

The Offset To Position Apple event is similar in function to the QuickDraw

CharToPixel function, and it returns similar results. Your handler may use
CharToPixel to get the information it returns to the text service component, or it may
use a TextEdit call, as shown in the following code sample.
Listing 7-9 shows a sample handler for the Offset To Position Apple event. The handler
rst receives the input parameters, then uses the TextEdit function TEGet Point to
convert a text offset to a screen location. The TEGet Point function is described in the
chapter fextEditOin this book.
A sample handler for the Offset To Position Apple event

Listing 7-9
FUNCTION

MyHandleOffset2Pos(theAppleEvent:
reply:

AppleEvent;

AppleEvent;

handlerRefCon:

LongInt) :

OSErr;

VAR

myErr:

OSErr;

rtErr:

OSErr;

returnedType:

DescType;

offSet:

LongInt;

refcon:

LongInt;

actualSize:

LongInt;

theWindow:

WindowPtr;

te:

TEHandle;

oldPort:

GrafPtr;

thePoint:

Point;

theFixed:

Fixed;

BEGIN

Using the Text Services Manager (for Client Applications)

7-33

CHAPTER

7

Text Services Manager

{Get

the

myErr

:=

IF

required

parameter

keyAEOffset }

AEGetParamPtr(theAppleEvent,

myErr

=

{Get

the

myErr

:=

nokrr

keyAEOffset,

typeLongInteger,

returnedType,

sizeof (offSet),

actualSize) ;

@offSet,

THEN

required

parameter

AEGetParamPtr

TSMDocumentRefcon}

(theAppleEvent,
keyAETSMDocumentRefcon,
typeLongInteger,

@refcon,

returnedType,

sizeof (refcon),

actualSize) ;
IF

mykrr

<>

nokrr

THEN

BEGIN
MyHandleOffset2Pos
Exit

:=

myErr;

(MyHandleOffset2Pos) ;

END;
{the

application

{ window

which

rtErr

noErr;

:=

theWindow
IF

:=

GetWindowFromRefcon

associated

with

GetWindowFromRefcon

theWindow

rtErr

function

is

:=

=

NIL

the

returns

the

}

refcon}

(refcon)

{initialize

rtErr}

returns

}

;

THEN

errOffsetInvalid

ELSE
BEGIN

{the

application

{ TEHandle
te

:=

{the

for

the

TextEdit

thePoint

:=

(offSet
rtErr

ELSE

the

TEGetPoint

:=

TEGetPoint

returns

offset}

(offSet,

te);

OR

(offSet

<

the

0)

point

}

THEN

errOffsetInvalid
(thePoint,

theWindow*.portRect)

errOffsetIsOutsideOfView

ELSE
BEGIN

7-34

the

;

given

> te**.teLength)
:=

IF (PtInRect

rtErr

(theWindow)

function

to

FindTheTEHandle

window}

FindTheTEHandle

{ corresponding

IF

function

Get Port

(oldPort) ;

SetPort

(thewWindow)

;

Using the Text Services Manager (for Client Applications)

=

FALSE)

THEN

CHAPTER

7

Text Services Manager

{Convert

thePoint

LocalToGlobal
SetPort

into

(thePoint)

(oldPort)

global

coordinates}

;

;

END ;

{construct
myErr

:=

the

return

parameter

AEPutParamPtr(reply,

keyAEPoint}
keyAEPoint,

@thePoint,
IF

myErr

=

nokrr

{construct
myErr

:=

typeQDPoint,

sizeof(thePoint)
);

THEN

the

optional

return

AEPutParamPtr(reply,

parameter

typeLongInteger,
sizeof
IF

myErr

=

nokrr

keyAETextFont }

keyAETextFont,

@te**.txFont,

(longInt) ) ;

THEN

BEGIN

{construct

optional

return

parameter

theFixed

:=

myErr

AEPutParamPtr(reply,

:=

BSL(Fixed(te**.txSize),

keyAEText

PointSize}

16);

keyAETextPointSize,

typeFixed,

@theFixed,

sizeof

(theFixed)

) ;

return

parameter

keyAETextLineHeight }

END;

IF

myErr

=

nokrr

{construct
myErr

:=

THEN

optional

AEPutParamPtr(reply,

keyAETextLineHeight,

typeShortInteger,
IF

myErr

=

nokrr

{construct
myErr

:=

sizeof

(Integer)

return

parameter

@te**.lineHeight,

) ;

THEN

optional

AEPutParamPtr(reply,

keyAETextLineAscent }

keyAETextLineAscent,

typeShortInteger,
sizeof
IF

myErr

=

nokrr

(Integer)

@te**.fontAscent,

) ;

THEN

BEGIN

{construct

{90

the

= horizontal

optional

return

direction,

theFixed

:=

myErr

AEPutParamPtr(reply,

:=

parameter

180

= vertical

keyAEAngle--

}

direction}

Fixed(90);
typeFixed,

sizeof

keyAETextPointSize,
@theFixed,

(Fixed) );

END;

IF

myErr

<>

nokrr

THEN

BEGIN

Using the Text Services Manager (for Client Applications)

7-35

CHAPTER

7

Text Services Manager

MyHandleOffset2Pos
Exit

:=

myErr;

(MyHandleOffset2Pos) ;

END;
END;

{Construct

the

return

MyHandleOffset2Pos

:=

parameter

keyErrorNumber}

AEPutParamPtr(reply,

keyErrorNumber,

typeShortInteger,

@rtErr,

sizeof (rtErr));
END;

Showing or Hiding the Inout Window
Input methods that work with a Soating input window often offer options to the user for
either (1) continually displaying the input window, (2) displaying it only as text is being
typed in and hiding it immediately after the user con rms it, or (3) leaving the window
up for a speci ed amount of time after con rmation. The Show/Hide Input Window
Apple event requests that your client application make the bottomline Soating input
window either visible or not visible. An input method text service component sends this
Apple event whenever it needs to know or change the current state of the window.
This Apple event is for use only by applications that display their own input windows. If
your application does not itself control the display of a Soating input window, you can
ignore this Apple event. If your application uses the Text Services Manager Soating
window service for bottomline input (by calling UseInputWindow), you do not receive
this Apple event because it is handled by the Text Sevices Manager.

Direct Access to Text Service Components
Your client application can bypass the Text Services Manager and communicate with text
service components directly. Many of the text service component routines correspond in
function to the Text Services Manager application-interface routines. It is therefore
possible for a client application to use the text service component routines if it needs to
exert ner control over its interaction with text service components or if it requires
speci c kinds of text services or server-speci c knowledge. It is not recommended in
most cases, because the Text Services Manager is not available to help with dispatching
and housekeeping chores.

Calling the Component Manager
If your client application does not use the Text Services Manager, it has to communicate
with the Component Manager directly to identify and initialize individual text service
components. You can use Component Manager calls to nd components, set a default
component, get information about components, and open components. See the chapter
CComponent ManagerOin Inside Macintosh: More Macintosh Toolbox for more information.

7-36

Using the Text Services Manager (for Client Applications)

CHAPTER

7

Text Services Manager

Calling Text Service Components
If your client application calls text service components directly, it uses the text service
component routines, a component-level interface described under (ext Service
Component RoutinesOon page 7-84.
After opening a text service component with the OpenComponent or
OpenDefaultComponent function, your client application calls
InitiateTextService function to instruct the text service component to commence
its operations.
To inform a text service component that its associated document window is becoming
active or inactive, call the ActivateTextService

function.

or DeactivateTextService

You are responsible for adding the text service component menu to your application@
menu bar. Furthermore, you are responsible for either disabling the menu or removing
it from your menu bar when the text service component becomes inactive. Call the
Get Text ServiceMenu function to obtain menus from each open text service
component.

To pass events to text service components, call the Text ServiceEvent function. You
are also responsible for allowing the text service components to control the cursor. Use
the Set Text ServiceCursor function to give the text service component a chance to set
the cursor.
When a user makes a selection from the menu for a text service component, call the
TextServiceMenuSelect function.
You should call Text ServiceMenuSelect right
after the Menu Manager routines MenuSelect or MenuKey.
Before closing the component, call the TerminateText Service function to tell the text
service component to nish its operations. You should remove the text service
component@ menu from the menu bar when the text service component is deactivated.

Using the Text Services Manager (for Text Service
Components)
This chapter does not describe how to write a text service component. It describes only
the interface between text service components and the Text Services Manager. Each text
service component has several functions; it must be able to

m perform the tasks for which it was created
™ communicate with the Component Manager
m receive calls from the Text Services Manager (or client applications), through the
Component Manager
m send calls to the Text Services Manager

Using the Text Services Manager (for Text Service Components)

7-37

CHAPTER

7

Text Services Manager

How components perform their speci c text-handling tasks is beyond the scope of Inside
Macintosh. How components communicate with the Component Manager is described
in the chapter CComponent ManagerOin Inside Macintosh: More Macintosh Toolbox.
How text service components communicate with the Text Services Manager is described
in this section.
The text service component routines are the component-level calls that the Text
Services Manager makes to text service components through the Component Manager.
See Cfext Service Component RoutinesOon page 7-84 for detailed descriptions of the
calls. If you are writing a text service component, it must implement the text service
component routines.

Text service components also make calls to the Text Services Manager, to send Apple
events to client applications and to request the use of a Soating window when needed.
See Cext Services Manager Routines for ComponentsOon page 7-77 for detailed
descriptions of those component-interface calls.
For a brief discussion of some of the data types associated with text service components,
see About Text Service ComponentsObeginning on page 7-14.

Providing Menus and Icons
If you are writing a text service component, you can have it display its own menu,
provide an icon for the title of that menu, and provide icons for the Keyboard menu.

Providing a Text Service Component Menu
Although most user selections and con gurations are best made with fSoating palettes, a
text service component may put one menu into the menu bar. For input-method text
service components, the menu cannot be hierarchical. Input-method menus appear on
the right (system) side of the menu bar, between the Help menu and the Keyboard menu.
Menus for non-input-method text service components appear on the left (application)
side of the menu bar. See Figure 7-10 on page 7-40.
To create the menu, follow the standard procedures as described in the Menu Manager
chapter of Inside Macintosh: Macintosh Toolbox Essentials. The Text Services Manager
installs the menu in the menu bar whenever your component is opened or activated. The
application (through the Text Services Manager) passes the menu commands to you for
handling when appropriate.

7-38

Using the Text Services Manager (for Text Service Components)

CHAPTER

7

Text Services Manager

All instances of an input-method text service component must share one menu handle.
Therefore, make sure to allocate the handle in the System heap. You can store the menu
handle in your component@ refcon eld. See the discussion of the Component Manager
Set ComponentRefcon routine in Inside Macintosh: More Macintosh Toolbox.
IMPORTANT

An input-method text service component should never dispose
of its menu handle in response to a TerminateTextService
call (see page 7-86). Any other kind of text service component
should always dispose of its menu handle in response to a
TerminateTextService call. a
Using an icon for the menu title

If you wish to have an icon instead of text as the title of your text service
component menu,

rst create a small-icon suite (such as 'kcs#',

'kes4',and 'kcs8') to represent your menu title. Then, in your menu
resource, make the menu title a 5-byte Pascal string (6 bytes total size),
with this format:
Byte

Value

0

$05 (length byte for menu string)

1

$01 (invalid character code)

25

Handle to icon suite

When the menu is created, the menu bar de

nition procedure knows

from the values of the rst 2 bytes that the nal 4 bytes are a handle to an
icon suite, and the procedure will put the icon in the menu bar. For more
on creating icon suites and drawing icons, see the Finder Interface

chapter of Inside Macintosh: Macintosh Toolbox Essentials. See also
Macintosh Human Interface Guidelines for design suggestions for color icon
families.
Remember these limitations when considering an input-method menu: an input method
can put up only one menu, the menu cannot be hierarchical, and the menu can be
removed from the menu bar if there is insuf

be more appropriate to use palettes.

cient room for it (on a small screen). It may

Providing Input Method Icons for the Keyboard Menu
Any text service component that provides an input method must supply the following
keyboard icon resources to display an icon for the input method in the Keyboard menu:
'kes#',

'kcs4',and

'kcs8'. The resource ID number of the keyboard icon resources

must equal the script code of the script system that the input method supports. If your
input method supports more than one script system, you can have more than one icon
suite, each with the appropriate resource IDs.

Using the Text Services Manager (for Text Service Components)

7-39

CHAPTER

7

Text Services Manager

Figure 7-10 shows a Keyboard menu displaying a Japanese input method and a Korean
input method, as well as keyboard layouts from several other script systems. The
Japanese input method is active; its icon is checked in the menu and appears highlighted
on the menu bar.
Figure 7-10

Input method icons in the Keyboard menu and menu bar

@

7S

About Keyboards

ae

© Jpop
@

U.S.

@& U.S.

- System 6

me Pycckas

x nay
yw) Awhnds nay

Vv

cea

The pencil icon between the Keyboard menu and the Help menu in Figure 7-10 is the title
for the menu belonging to the active input method.
For more information on keyboard icon suites, see the appendix (Keyboard ResourcesO
in this book. For information on script codes, see the chapter CScript ManagerOin
this book.

Responding to Calls
When a client application makes certain calls to the Text Services Manager application
interface, the Text Services Manager in turn calls your text service component. Your text
service component responds to these calls by initiating or closing a text service,
manipulating text service windows, responding to events or menu commands, and
con

7-40

rming text input.

Using the Text Services Manager (for Text Service Components)

CHAPTER

7

Text Services Manager

Initiating a Text Service
When your text service component receives the InitiateTextService call, it can
commence its operations to provide its text service. That may include opening windows
or palettes, initializing data structures, communicating with the user or application, or
otherwise getting started with its tasks.
The Text Services Manager may call InitiateTextService on its own or in response
to receiving the application-interface call OpenText Service.

Activating Text Service Component Windows
If a window associated with a TSM document associated with your text service is being
activated, your text service component receives the ActivateText Service call. You
should show fSoating windows associated with your component instance and prepare to
receive and handle events.
If the window is being deactivated, your text service component receives the
DeactivateTextService call. You should perform any necessary cleanup or other
tasks associated with deactivating your current component instance. If your text service
component is not an input method, you should also hide all Soating windows associated
with the document being deactivated. If your text service component is an input method
and if the newly activated document does not use your text services, you will receive the
HidePaletteWindows call. At that point you should hide all Soating windows
associated with the component instance being deactivated.
The Text Services Manager calls ActivateTextService and
DeactivateText Service in response to receiving the application-interface calls
ActivateTSMDocument and DeactivateTSMDocument, respectively.

Responding to Events and Updating the Cursor and Menu
The Text Services Manager (or a client application) is responsible for adding your
text service component@ menu to the menu bar. When your text service component
receives a Get Text ServiceMenu call, it needs to return a menu handle. The section

(Providing Menus and IconsOon page 7-38 gives instructions for creating text service
menus and icons.
When your text service component receives the call

Text ServiceEvent,

Text ServiceMenuSelect, or SetTextServiceCursor, it should handle the event,

menu command, or cursor-drawing if appropriate. For example, when the user enters
text, you receive and handle the key-down events; you in turn inform the application
what characters to draw in the active input area. When the user makes a menu selection,
you are given an opportunity to check whether it is from your menu and then to act on it.
You are regularly given the opportunity to redraw the cursor, in case it may be over an
area under your control (such as a palette window or the active input area).

Using the Text Services Manager (for Text Service Components)

7-41

CHAPTER

7

Text Services Manager

The Text Services Manager may call Get Text ServiceMenu on its own or in response to
receiving the application-interface call OpenText Service. The Text Services Manager
calls

Text ServiceEvent, TextServiceMenuSelect, and SetTextServiceCursor

in response to receiving the application-interface calls TSMEvent, TSMMenuSelect, and
Set TSMCursor, respectively.

Confirming Active Text Input
A client application may need your input method text service component to terminate
input immediately and con rm any text currently in the active input area. When your
text service component receives the call FixTextService, itshould con rm all text in
the active input area, just as if the user had pressed Return. It should send the con rmed
text to the client application through the Update Active Input Area Apple event.
The Text Services Manager calls FixText Service
application-interface call FixTSMDocument.

in response to receiving the

Closing a Text Service
When your text service is no longer needed, the Text Services Manager calls your text
service component@ TerminateText Service function before calling the Component
Manager to close the component. Your text service component should use this time to
con rm any active input in progress and then dispose of memory as needed.
The Text Services Manager may call TerminateText Service on its own or in response
to receiving the application-interface call CloseText Service.

Identifying the Supported Scripts and Languages
The Operating System, the Text Services Manager, or a client application may need to
determine which scripts and languages your text service component supports. When you
receive the

Get ScriptLanguageSupport call, you return that information in a

script-language support record.

The

Get ScriptLanguageSupport

function and several Text Services Manager

application-interface routines use the script-language recordN and the script-language
support recordN to pass information about the scripts and languages associated with text
service components.

The script-language record provides a script code and language code for the script
system and the language associated with a given text service component. The
script-language record is de ned by the ScriptLanguageRecord data type as follows:
TYPE

ScriptLanguageRecord

=

RECORD

fScript:

ScriptCode;

flanguage:

lLangCode;

END;

7-42

Using the Text Services Manager (for Text Service Components)

CHAPTER

7

Text Services Manager

Field descriptions

fScript

The number that identi es a script system supported by the text
service component
The number that identi es a language associated with the script
supported by the text service component

flanguage

For a list of constants for all de ned script and language codes, see the chapter CScript
ManagerOin this book.
The script-language support record consists of an array of script-language records. It is
de

ned by the ScriptLanguageSupport

TYPE

ScriptLanguageSupport

data type as follows:

=

RECORD
fScriptLanguageCount

:

Integer;

fScriptLanguageArray:

ARRAY[0..0]

of

ScriptLanguageRecord;

END ;
Field descriptions
fScriptLanguageCount

The number of script-language records in this script-language
support record.

fScriptLanguageArray

A variable-length array of script-language records.

The Text Services Manager can call

Get Script LanguageSupport

on its own or in

response to receiving the application-interface call

Get Text ServiceLanguage.

Listing 7-10 gives an example of the response to the

Get ScriptLanguageSupport

by a Chinese input method.
Listing 7-10

call

Determining the script and language for a text service component

TYPE

scriptHandlePtr=

“ScriptLanguageSupportHandle;

VAR

scriptHd1lPtr:scriptHandlePtr;
{The

following

{

text

{

response

service
to

is

part

of

component

the

case

routines.

receiving

a

statement

that

It

component’s

is

the

GetScriptLanguageSupport

dispatches

}

}

call}

kCMGetScriptLangSupport:
BEGIN

scriptHd]lPtr

IF

:=

scriptHd1lPtr*

(scriptHandlePtr)

=

NIL

@(cmParams~.params[0]) ;

THEN

Using the Text Services Manager (for Text Service Components)

7-43

CHAPTER

7

Text Services Manager

scriptHd1Ptr*

:=

(ScriptLanguageSupportHandle)
NewHandle
(sizeof

IF

scriptHd1Ptr* <> NIL THEN
WITH scriptHd1lPtr*** DO
fScriptLanguageCount

(ScriptLanguageSupport)
) ;

BEGIN
:=

1;

fScriptLanguageArray
[0] .fScript:=

smTradChinese;

fScriptLanguageArray
[0] .fLanguage:=
langTradChinese;
result

:=

nokErr;

END;
ELSE

result

:=

memFullErr;

END;

Making Calls
Your text service component needs to make two kinds of calls to the Text Services
Manager: calls that cause the sending of an Apple event to a client application, and calls
that request a Soating window from the Text Services Manager.

Sending Apple Events to Client Applications
Apple events allow text service components to send information to and request speci c
services of client applications. It is the responsibility of the client application to install
Apple event handlers for these Apple events. Using these events, the text service
component controls the text services environment by requesting a variety of services
from the client application.
Your text service component can send Apple events to request that a client application
perform the following actions:
m create or update text in an active input area
m help you track cursor movements by converting global coordinates to the byte offset of
characters in the active input area
m help you position items on the screen by converting the byte offset of characters in the
active input area to global coordinates
m show or hide a Soating input window
Note
Your text service component must always use the kCurrent Process

constant as the target address when it creates an Apple event to send to
the Text Services Manager. @

7-44

Using the Text Services Manager (for Text Service Components)

CHAPTER

7

Text Services Manager

To send Apple events to a client application, your text service component calls the Text
Services Manager SendAEFromTSMComponent function. The Text Services Manager
then completes the Apple event and sends it to the application. For general information
on constructing and sending Apple events, see the discussion of the Apple Event
Manager in Inside Macintosh: Interapplication Communication.
Listing 7-11 shows an example of a text service component preparing and sending an
Update Active Input Area Apple event. The component creates the Apple event and
constructs the required parameters, including the text to be sent to the application. It also
constructs the optional parameters that specify highlighting and update ranges in the
text. It then calls SendAEFromTSMComponent
to send the Apple event. In this listing,

globalHand1e is a handle to a data structure in which the text service component
maintains all information about the text in the active input area.
Listing 7-11

FUNCTION

Constructing and sending an Update Active Input Area Apple event

MyCreateUpdateInlineAreaAE

(globalHandle:

TglobalHandle)

OSErr;
VAR

psnRecord:

ProcessSerialNumber ;

myErr:

OSErr;

addrDescriptor:

AFAddressDesc;

theAEvent

AppleEvent ;

:

theReply:

AppleEvent ;

slRecord:

ScriptLanguageRecord;

theRangeTableSize:

LongInt ;

theTextData:

Handle;

theUpdateRangeTable:

TextRangeArray;

theHiliteRangeTable:

TextRangeArray;

BEGIN

{Apple

to

the

psnRecord.highLongOfPSN

:=

0;

psnRecord.lowLongOfPSN

:=

kCurrentProcess;

myErr

event

:=

must

go

current

myErr

}

AECreateDesc(typeProcessSerialNumber,
sizeof

IF

process

<>

nokrr

(psnRecord),

@psnRecord,

addrDescriptor) ;

THEN

BEGIN

MyCreateUpdateInlineAreaAE
Exit

:=

myErr;

(MyCreateUpdateInlineAreaAE) ;

END;

Using the Text Services Manager (for Text Service Components)

7-45

CHAPTER

7

Text Services Manager

{create
myErr

the
:=

Apple

event

record}

AECreateAppleEvent

(kTextServiceClass,
kUpdateActivelInputArea,
addrDescriptor,
kAutoGenerateReturnlID,
kAnyTransactionID,

IF

mykrr

<>

nokrr

theAEvent) ;

THEN

BEGIN

MyCreateUpdateInlineAreaAE

myErr
Exit

:=

myErr;

:= AEDisposeDesc(addrDescriptor) ;

{ignore

the

error}

(MyCreateUpdateInlineAreaAE) ;

END;

{construct

the

required

{ globalHandle**.fSelf
myErr

:=

parameter

= global

keyAEServerInstance--

containing

AEPutParamPtr(theAEvent,

component

}

instance}

keyAEServerInstance,

typeComponentiInstance,

@globalHandle**.fSelf,
sizeof
IF

myErr

=

nokrr

(ComponentInstance)
) ;

THEN

BEGIN

{construct

required

parameter

{

in

case}

--Korean

this

slRecord.fScript

:=

slRecord.fLanguage
myErr

:=

keyAEScriptTag

}

smKorean;
:=

langKorean;

AEPutParamPtr(theAEvent,

keyAEScriptTag,

typeIntlWritingCode,

@slRecord,

sizeof

(slRecord)

) ;

END;

IF

myErr

=

nokrr

THEN

BEGIN

{construct
{

is

a

required

handle

to

parameter

component's

keyAETheData.
data

structure

globalHandle
describing

}
}

{ all text in the active inline area}
theTextData := globalHandle**.fTextData;
HLock

(theTextData) ;

myErr

:=

AEPutParamPtr(theAEvent,

keyAETheData,

typeChar,

theTextData’,
globalHandle**.fTextDataLength) ;
HUnlock

(theTextData)

;

END;

7-46

Using the Text Services Manager (for Text Service Components)

CHAPTER

7

Text Services Manager

IF

myErr

=

nokrr

{construct
myErr

:=

THEN

the

required

parameter

keyAEFixLength}

AEPutParamPtr(theAEvent,

keyAEFixLength,

typeiInteger,

@globalHandle**.fFixedLength,
sizeof
IF

myErr

=

nokrr

(LongInt)

) ;

THEN

BEGIN

{construct

the

optional

theUpdateRangeTable
theRangeTableSize

myErr

:=

:=
:=

parameter

UpdateRangeTable}

globalHandle**.fUpdateRangeTable;

sizeof

(TextRangeArray)

+

theUpdateRangeTable.fNumOfRanges

*

sizeof

(TextRange)

AEPutParamPtr(theAEvent,

;

keyAEFixLength,

typeiInteger,
@theUpdateRangeTable,
theRangeTableSize) ;
END;

IF

myErr

=

nokrr

THEN

BEGIN

{construct

the

optional

theHiliteRangeTable
theRangeTableSize

myErr

:=

:=
:=

parameter

HiliteRangeTable}

globalHandle**.fHiliteRangeTable;

sizeof

(TextRangeArray)

+

theHiliteRangeTable.fNumOfRanges

*

sizeof

(TextRange)

AEPutParamPtr(theAEvent,

;

keyAEFixLength,

typeiInteger,
@theHiliteRangeTable,
theRangeTableSize)
END;

IF

myErr

<>

nokrr

THEN

BEGIN

MyCreateUpdateInlineAreaAE

:=

myErr;

myErr

:=

AEDisposeDesc

myErr

:=

AEDisposeDesc(addrDescriptor) ;

Exit

(theAEvent)

;

{ignore

the

errors}

(MyCreateUpdateInlineAreaAE) ;

END ;

{send

the

Apple

event}

myErr

:=

SendAEFromTSMComponent

(theAEvent,

kAEWaitReply

+

theReply,
kAENeverInteract,

kAENormalPriority,
MyCreateUpdateInlineAreaAE

:=

120,

NIL,

NIL);

myErr;

Using the Text Services Manager (for Text Service Components)

7-47

CHAPTER

7

Text Services Manager

myErr

:= AEDisposeDesc(theAEvent) ;

myErr

:=

AEDisposeDesc(addrDescriptor) ;

myErr

:=

AEDisposeDesc(theReply) ;

{ignore

the

errors}

END;

Opening Floating Utility Windows
To open a Soating utility window in front of the current client application, you use the
NewServiceWindow function. If the call is successful, NewServiceWindow allocates a

Soating window in the Soating window service layer, and returns a pointer to the
window. See (Floating Input WindowsOon page 7-13 and (Floating Utility WindowsOon
page 7-14 for a discussion of the Text Services Manager Soating window service and the
Soating window service layer.
Your text service component can open multiple Soating windows. When your component

receives an event, you must determine if the event belongs to one of your text service
Soating windows. To get a pointer to the frontmost window in the Soating window
service layer, call the

Get Front ServiceWindow function. To

nd out which part of

your Soating window an event occurred in, call the FindServiceWindow function.
Your text service component can close the Soating window you originally allocated by
using the CloseServiceWindow function.

Text Services Manager Reference
This section describes four categories of routines and handlers, and their related
constants and data structures:

m Text Services Manager routines called by client applications (the application interface
to the Text Services Manager)
m application-supplied handlers for Apple events initiated by text service components
m Text Services Manager routines called by text service components (the component
interface to the Text Services Manager)
m text service component routines, called by the Text Services Manager and possibly by
client applications

Text Services Manager Routines for Client Applications
The Text Services Manager provides an application interface that allows client
applications to use text service components independently of any speci c knowledge of
those components. Your client application makes these application-level calls to the Text
Services Manager, which in turn calls the text service component using the
component-level routines described in the section (ext Service Component RoutinesOon
page 7-84.

7-48

Text Services Manager Reference

CHAPTER

7

Text Services Manager

The routines in the application interface let you
m initialize and close your TSM-aware application
m use TSM documents
m™

pass events, menu items, and cursor control to text service components

m con

rm active input in TSM documents that use input methods

m provide text services to the user
m request a Soating input window instead of inline input
m associate scripts and languages with text service components

Initializing and Closing as a TSM-Aware Application
If your client application uses any of the application-level Text Services Manager
routines, call the Init TSMAwareApplication function immediately after you have
called the other Toolbox initialization routines.
The Text Services Manager needs to perform some housekeeping when your client
application is closed. To expedite this process, call the CloseTSMAwareApplication
function when you quit.

InitTSMAwareA pplication
The Init TSMAwareApplication function informs the Text Services Manager that your
application is TSM-aware.
FUNCTION

InitTSMAwareApplication:

OSErr;

DESCRIPTION

The Text Services Manager notes that your application is TSM-aware by allocating the
necessary data in its internal data structures.

RESULT CODES

noErr
memFullErr
tsmAlreadyRegisteredErr

tsmNotAnAppErr

No error
Insuf cient memory to initialize
Application is already TSM-initialized

The caller is not an application

SEE ALSO

For sample code that uses the Init TSMAwareApplication function, see Listing 7-1 on

page 7-18.

Text Services Manager Reference

7-49

CHAPTER

7

Text Services Manager

CloseTSMAwareA pplication
The CloseTSMAwareApplication function informs the Text Services Manager that

you have closed your application.
FUNCTION

CloseTSMAwareApplication:

OSErr;

DESCRIPTION

The Text Services Manager performs necessary housekeeping when your
application closes.
Before you call the CloseTSMAwareApplication function, be sure that your

application disposes of all open TSM documents by calling the DeleteTSMDocument
function (see page 7-53).

RESULT CODES

noErr
tsmNeverRegisteredErr

No error
Application was never TSM-initialized

SEE ALSO

For sample code that uses the CloseTSMAwareApplication function, see Listing 7-6

on page 7-24.

Creating and Activating TSM Documents
This section describes the functions that let you create, activate, deactivate, and dispose
of a TSM document (for details on the contents of

(Creating a TSM DocumentOon page 7-18).

a TSM document, see the section

NewTSMDocument
The NewTSMDocument

function creates

a TSM

document and returns a handle to the

document@ ID.
FUNCTION

NewTSMDocument

(numOfInterface:
VAR

Integer;

supportedinterfaceTypes:

InterfaceTypeList;
VAR

idocID:

refCon:

7-50

Text Services Manager Reference

TSMDocumentID;

LongInt):

OSErr;

CHAPTER

7

Text Services Manager

numOfInterface

The number of supported text service interface types. Currently, this
number must be 1.

supportedinterfaceTypes

A list of supported interface types. This list helps the Text Services
Manager to locate the text services that have the correct interface type.
Currently, the Text Services Manager has de ned one interface type:
kTextService (= 'tsvc'). The data type InterfaceTypeList isa
simple array of 4-character (OSType) tags.

idocID

Upon successful completion of the call, contains the document

refCon

A reference constant to store in the TSM document record. It may have
any value you wish.

identi

cation number of the TSM document created.

DESCRIPTION

Each time your client application calls the NewI!'SMDocument function, the Text Services
Manager creates an internal record called a TSM document and returns its ID.
If the call is successful, NewTSMDocument opens the default input method text service
component of the current keyboard script and assigns it to this document. If
NewTSMDocument returns tsmScriptHasNoIMErr, it has still created a valid TSM

document, but has not associated an input method with it.

If NewTSMDocument fails to create
idocID

anew TSM document, it returns an error and sets

to NIL.

RESULT CODES

noErr

No error

tsmUnsupportedTypeErr
tsmNeverRegisteredErr
tsmScriptHasNoIMErr
tsmCantOpenComponentErr

Supported type was not 'tsvc'
Application is not TSM-aware
Current script does not use input methods
Cannot open default input of current script

memFul lErr

Insuf

cient memory to open document

SEE ALSO

For sample code that uses the NewTSMDocument function, see Listing 7-2 on page 7-19.

ActivateTSMDocument
The ActivateTSMDocument function instructs the Text Services Manager to mark the
TSM document associated with a newly active window as active.
FUNCTION

ActivateTSMDocument

Text Services Manager Reference

(idocID:

TSMDocumentID):

OSErr;

7-51

CHAPTER

7

Text Services Manager

idocID

A TSM document identi cation number created by a prior call to the
NewTSMDocument function (see page 7-50).

DESCRIPTION

When a window that has an associated TSM document becomes active, your client
application must call the Act ivateTSMDocument function to inform the Text Services
Manager that the document is activated and is ready to use text service components.
ActivateTSMDocument calls the equivalent text service component routine
ActivateTextService (see page 7-85) for all open text service components associated
with the TSM document.
If a text service component has a menu, the Text Services Manager inserts the menu into
the menu bar.

RESULT CODES

noErr
tsmInvalidDocIDErr

No error
Document is not a valid TSM

document

SEE ALSO

For sample code that uses the ActivateTSMDocument function, see Listing 7-3 on
page 7-21.

DeactivateTSMDocument
The DeactivateTSMDocument function instructs the Text Services Manager to mark
the TSM document as inactive.
FUNCTION

idocID

DeactivateTSMDocument

(idocID:

TSMDocumentID):

OSErr;

A TSM document identi cation number created by a prior call to the
NewTSMDocument function (see page 7-50).

DESCRIPTION

The DeactivateTSMDocument function lets you inform the Text Services Manager that
a TSM document in your client application is no longer active and must temporarily stop
using text service components.
The Text Services Manager calls the equivalent text service component function
DeactivateText Service (see page 7-85) for any text service component associated
with the TSM document being deactivated.

7-52

Text Services Manager Reference

CHAPTER

7

Text Services Manager

IMPORTANT

Once your application is initialized as a TSM-aware application, at least
one TSM document must always be active when your application is
active. If a situation arises in which you are a TSM-aware application but
all of your TSM documents are inactive, any text service component that
has a menu or palette windows will be unable to communicate with the
user. The best policy is to always create a TSM document, even if only a
dummy document, immediately after initializing as a TSM-aware
application. &

RESULT CODES

noErr
tsmInvalidDocIDErr

No error
Document is not a valid TSM

document

SEE ALSO

For sample code that uses the DeactivateTSMDocument function, see Listing 7-3 on
page 7-21.

DeleteTSMDocument
The DeleteTSMDocument function closes all opened text service components for the
TSM document.
FUNCTION

idocID

DeleteTSMDocument

(idocID:

TSMDocumentID):

OSErr;

A TSM document identi cation number created by a prior call to the
NewTSMDocument function (see page 7-50).

DESCRIPTION

When your application disposes of a TSM document, it must call the
DeleteTSMDocument function to inform the Text Services Manager that the document
is no longer using text service components. DeleteTSMDocument invokes the
Component Manager CloseComponent

function for each open text service component

associated with this document. It also disposes of the internal data structure for the
TSM document.

RESULT CODES

noErr
tsmInvalidDocIDErr

tsmNeverRegisteredErr

Text Services Manager Reference

No error
Document is not a valid TSM

Application is not TSM-aware

document

7-53

CHAPTER

7

Text Services Manager

Passing Events to Text Service Components
This section describes a function that lets you instruct the Text Services Manager to pass
certain events to the appropriate text service component.

TSMEvent
The TSMEvent function passes all events obtained from the WaitNext Event function,
including null events, to the Text Services Manager.
FUNCTION
event

TSMEvent

(VAR

event:

EventRecord):

Boolean;

The event record for the event that has been obtained from
WaitNextEvent.

DESCRIPTION

Your client application regularly obtains events such as key-down events from the
Toolbox Event Manager function WaitNextEvent. Some of these events may need to be
handled by text service components. The TSMEvent function lets you pass those events
to the Text Services Manager. The Text Services Manager dispatches the passed events to
the appropriate text service components by calling the Text ServiceEvent function for
each component (see page 7-87).
If TSMEvent returns FALSE, you need to process the event as you normally do. If
TSMEvent returns TRUE, the event has been handled by a text service component and is
now a null event. You should process the null event as you normally do.
Note
The way the Text Services Manager uses and dispatches Apple events
creates the potential for a reentrance situation that your client application
should know about and be prepared to handle. When your application
calls TSMEvent, the Text Services Manager uses the Apple Event
Manager function AESend to pass data to your application through an
Apple event. Your Apple event handler is thus invoked before the
TSMEvent trap has returned.
SEE ALSO

The WaitNextEvent function is described in the Event Manager chapter of
Inside Macintosh: Macintosh Toolbox Essentials.
For sample code that uses the TSMEvent function, see Listing 7-4 on page 7-22.

7-54

Text Services Manager Reference

CHAPTER

7

Text Services Manager

Passing Menu Selections and Cursor Setting
This section describes two functions, TSMMenuSelect

and

Set TSMCursor, that let you

instruct the Text Services Manager to pass menu commands and cursor control to the
appropriate text service component.

TSMMenuSelect
The TSMMenuSelect function gives the speci
reply to a menu selection.
FUNCTION
menuResult

TSMMenuSelect

ed text service component a chance to

(menuResult:

LongInt):

Boolean;

The result from the Menu Manager MenuSelect function.

DESCRIPTION

When the user chooses a menu item, the item may belong to a text service component@®
menu. To provide an opportunity for the text service component to reply to its menu
selections, your application should call TSMMenuSelect with the result from the Menu
Manager MenuSelect function.
TSMMenuSelect returns FALSE if a text service component did not handle the menu
selection. In this case, your client application should process the menu selection normally.
TSMMenuSelect returns TRUE when a text service component handled the menu
selection. In this case, you should take no action.

After TSMMenuSelect returns, your application shouldN as usualN call the Menu
Manager function HiliteMenu with the menuID parameter set to 0 to remove the
highlighting from the menu title.

SEE ALSO

The Menu Manager is described in Inside Macintosh: Macintosh Toolbox Essentials.

SetTSMCursor
The Set TSMCursor function provides an opportunity for the text service component to
set the shape of the cursor. If the text service component does not respond, your
application may set the cursor.
FUNCTION

SetTSMCursor

Text Services Manager Reference

(mousePos:

Point):

Boolean;

7-55

CHAPTER

7

Text Services Manager

mousePos

A QuickDraw point indicating the position (in global coordinates) of the
cursor in your application.

DESCRIPTION

Your client application is responsible for setting the cursor to an appropriate shape as it
passes over your various user interface elements. It is also necessary to provide an
opportunity for a text service component to set the cursor over its own user interface

elements. The Set TSMCursor function allows the text service component to control the
shape of the cursor if appropriate.
Call

Set TSMCursor whenever you would normally call the QuickDraw Set Cursor

procedure. When

Set TSMCursor returns TRUE, the cursor is positioned in a text service

component window or in the active input area and it has been set by a text service
component. Your client application should not set the cursor in this case. When
SetTSMCursor returns FALSE, the cursor has not been set, and your client application
may set it.

SetTSMCursor calls the equivalent text service component function
SetTextServiceCursor (page 7-88) for each open text service component to
provide an opportunity for each one to set shape of the cursor. If a text service
component actually changes the shape of the cursor, the Text Services Manager does not
call Set Text ServiceCursor for the rest of the text service components and returns
TRUE. If none of the text service components sets the cursor, then

Set TSMCursor returns

FALSE.

SEE ALSO

The Set Cursor procedure is described in the QuickDraw chapters of
Inside Macintosh: Imaging.

Con

rming Active Input in a TSM Document
This section describes the FixTSMDocument function, which allows you to explicitly
con rm text in the active input area.

FixTSMDocument
The FixTSMDocument function informs the Text Services Manager that input in the
active input area of a speci ed TSM document has been interrupted, and that the text
service component must con
FUNCTION

idocID

7-56

rm the text and terminate user input.

FixTSMDocument

(idocID:

TSMDocumentID):

OSErr;

The identi cation number of a TSM document created by a prior call to
the NewTSMDocument function (see page 7-50).

Text Services Manager Reference

CHAPTER

7

Text Services Manager

DESCRIPTION

Typically, an inline input text service component removes con rmed input from the
active input area each time the user presses the Return key, and passes the con rmed text
to your application through an Apple event.
In certain situations, however, your client application may need to inform the text service
component that there has been an interruption in user input for a speci c TSM document.
In this case you call the FixTSMDocument function to give the input method text service
component the opportunity to con rm any input in progress.
For instance, if the user clicks in the close box of the window in which active input is
taking place, call FixTSMDocument before you close the window. The text service
component will pass you the current contents (both converted and unconverted) of the
active input area as con rmed text.
For simple activating and deactivating of your application@ window, it is not necessary
to con rm the text in the active inline area. The input method saves the text and restores
it when your window is reactivated.

RESULT CODES

noErr

No error

tsmTSNotOpenErr

The default input method is not open

tsmInvalidDocIDErr
tsmDocNotActiveErr

The document is not a valid TSM document
The TSM document is not active

SEE ALSO

For sample code that uses the FixTSMDocument function, see Listing 7-5 on page 7-23.

Making Text Services Available to the User
This section describes functions that let you provide ways for the user to choose, open,
and close text service components that are not input methods.
Your client application is responsible for providing a wayN usually a menuN for the user
to choose from among all available text service components. To get a list of available text
service components to display in a menu, call the Get ServiceList function. Be sure to
lter out input methods, because the Keyboard menu already displays them.
When the user chooses a text service component that is not an input method, call the
OpenText Service function to add the text service component to the TSM document.
The OpenText Service and CloseTextService functions let you inform the Text
Services Manager that a user of your client application has chosen to open or close a text
service component. The Text Services Manager then opens or closes the component and
associates it with a TSM document or ends the association as appropriate.

Text Services Manager Reference

7-57

CHAPTER

7

Text Services Manager

GetServiceList
The Get ServiceList function obtains a complete list of text service components of a
given kind available to the user of your client application.
FUNCTION

GetServiceList

(numOfInterfaceTypes:

Integer;

supportedinterfaceTypes:
InterfaceTypeList;

VAR

servicelInfo:

VAR

seedValue:

TextServiceListHandle;
LongInt):

OSErr;

numOfInterfaceTypes

The number of interface types supported by your client application.

supportedinterfaceTypes

A list of the interface types supported by your client application. The data
type InterfaceTypeList is a simple list of 4-character (OSType) tags.

servicelInfo

A handle to the text service component list data structure. If the handle is

NIL, the Text Services Manager allocates the handle; otherwise, it assumes

the handle is a valid text service component list handle, as de ned by the
TextServiceListHandle data type.
seedValue

Avalue that indicates whether the list of text service components returned
by GetServiceList may have been modi ed. This value is returned in
this parameter after the Text Services Manager calls the Component
Manager Get Component ListModSeed function.

DESCRIPTION

When your client application calls Get ServiceList, the Text Services Manager locates
all the text service components that support the speci ed interface and text service
component types and creates a text service component list, de ned by the
TextServiceList data type, that contains an entry for each of the text service
components.

It is possible to register text service components or withdraw them from registration at
any time. Once it has compiled a list of text services, the Text Services Manager invokes
the

Get Component

ListModSeed

function and returns the value in the modseed

parameter. You can save that value and, the next time you need to draw or regenerate the
list of services, call the Component Manager Get Component ListModSeed function. If
the seed value differs from the one you received from your last call to Get ServiceList,
you need to call Get ServiceList once more to update the information. Alternatively,
you can simply call Get ServiceList each time you need to update the list, although
that may be less ef cient.

7-58

Text Services Manager Reference

CHAPTER

7

Text Services Manager

GetServiceList uses the text service component information record, de ned by the
TextServicelInfo data type, and the text service component list record, de ned by the
TextServiceList data type.
TYPE

TextServicelInfo

=

RECORD

fComponent:

Component ;

fitemName:

Str255;

END ;

TextServicesInfoPtr

=

“TextServicelInfo;

Field descriptions

fComponent

itemName

TYPE

A component identi er for this text service component. You can use
the component identi er in Text Services Manager functions that
open or obtain information about a text service component.
A Pascal string with the name of a text service component. (The
script system to use for displaying the string is speci ed in the
componentFlags
eld of the component description record. See
page 7-15.)

TextServiceList

=

RECORD

fTextServiceCount

:

Integer;

fServices:

ARRAY[0..0]

of

TextServicelInfo;

END ;

TextServiceListPtr

=

TextServiceListHandle

“TextServiceList;
=

“*TextServiceListPtr;

Field descriptions
fTextServiceCount

An integer that provides the number of text service components in
the text service component list.

fServices

A variable-length array of text service component information
records.

RESULT CODES

noErr
memFullErr

tsmUnsupportedTypeErr

Text Services Manager Reference

No error
Insuf cient memory

Supported type was not 'tsvc'

7-59

CHAPTER

7

Text Services Manager

OpenTextService
The OpenText Service function instructs the Text Services Manager to open a text
service component that a user has chosen and to associate it with a TSM document.
FUNCTION

OpenTextService

(idocID:

TSMDocumentID;

aComponent:
VAR

Component ;

aComponentiInstance:

ComponentInstance):

idocID
aComponent

OSErr;

The identi cation number of a TSM document created by a prior call to
the NewTSMDocument function (see page 7-50).
A component identi

er for this text service component.

aComponentInstance

Upon completion of the call, contains a component instance. This value
identi es your application@ connection to a text service component. You
must supply this value whenever you call the text service functions
provided by the component directly.

DESCRIPTION

You can obtain the component identi er to pass in aComponent by comparing the menu
item name selected by the user with the component item names in the
TextServiceList record obtained by calling GetServiceList.
The Text Services Manager opens the requested component by calling the Component
Manager OpenComponent

function.

If the speci ed text service component is already open, the Text Services Manager does
not open it again and the tsmComponentAlreadyOpenErr error message is returned as
a result code. Whether or not the text service is open, the Text Services Manager calls the
functions InitiateTextService (see page 7-84) and ActivateTextService (see

page 7-85) for the given text service and returns a valid component instance. Upon
completion of the OpenTextService call, the selected text service component is

initialized and active.

Note
This function is for opening text service components other
than input methods. Your application does not need to open or close
input methods. @

RESULT CODES

noErr
tsmInvalidDocIDErr
tsmComponentAlreadyOpenErr
tsmCantOpenComponentErr

7-60

Text Services Manager Reference

No error
The document is not a valid TSM document
Component is already open for this document
Component doesn@exist or won®open

CHAPTER

7

Text Services Manager

CloseTextService
The CloseText Service function deactivates the active TSM document@ association
with the speci ed text service and closes the service component.
FUNCTION

CloseTextService

(idocID:

TSMDocumentID;

aComponentInstance:

ComponentInstance)

:

OSErr;

idocID

The identi cation number of a TSM document created by a prior call to
the NewTSMDocument function (see page 7-50).

aComponentiInstance

The component instance created by a prior call to

O(penText Service.

DESCRIPTION

When a user wants to close an opened text service component, your client application
should call CloseText Service.
If the text service component displays a menu, the Text Services Manager removes the
menu from the menu bar.
Note
This function is for closing text service components other than input
methods. Your application does not need to open or close
input methods. @
RESULT CODES
noErr
tsmInvalidDocIDErr
tsmNoOpenTSErr

No error
The document is not a valid TSM document
The component for this document is not open

Requesting a Floating Input Window
In certain situations, bottomline input with a Soating input window is preferable to inline
input for text input users. The Text Services Manager provides two ways to control how
the Soating input window is used: with a single speci ed TSM document or with all
documents of a given application.

Text Services Manager Reference

7-61

CHAPTER

7

Text Services Manager

UseInputWindow
The UseInput Window function associates a Soating input window with a particular
TSM document or with all TSM documents of an application.
FUNCTION

UseInputWindow

(idocID:

TSMDocumentID;

useWindow:

idocID

Boolean):

OSErr;

The TSM document ID of the particular TSM document to be associated

with the fSoating input window. If NIL, this call affects all your

application@ TSM documents.

useWindow

A Boolean value that indicates whether to use the Soating input window.
Set it to TRUE if you want to use a fsoating window; set it to FALSE if you
do not want to use a Soating window.

DESCRIPTION

The Text Services Manager provides a Soating input window for your application@ use if
you call UseInput Window with a value of TRUE in the useWindow parameter. To
specify inline input instead, call UseInputWindow with a value of FALSE in the
useWindow parameter.
The default value for useWindow is FALSE;

if you do not call

Use Input Window,

the

Text Services Manager assumes that your application wants to use inline input. If your
application wants to save the user@ choice, it can put the last-used value for useWindow
ina preferences le before quitting.
If you pass a valid TSM document ID for the idocID parameter, the useWindow
parameter affects only that TSM document. If you pass NIL for the idocID parameter,
the useWindow parameter affects all your application@ TSM documents, including
documents you create after making this call.

RESULT CODES

noErr
tsmInvalidDocIDErr

tsmNeverRegisteredErr

No error
The document is not a valid TSM

Application is not TSM-aware

document

Associating Scripts and Languages With Components
The utility routines described in this section allow you to
m assign a particular text service component as the default component to be associated
with a given script system and language
m determine which text service component is the default component associated with a
given script system and language

7-62

Text Services Manager Reference

CHAPTER

7

Text Services Manager

m determine the script system and language combination for the currently active text
service component
m assign a script system and language combination to the currently active text service
component

In addition to these routines, you can use the text service component function
Get Script LanguageSupport (described on page 7-90) to determine which additional
scripts and languages a text service component supports.

These routines make use of the script-language record, described under Gdentifying the
Supported Scripts and LanguagesOon page 7-42.

SetDefaultInputMethod
The operating system uses the SetDefault InputMethod function to assign a default
(input method) text service component to a given script and language.
FUNCTION

SetDefaultInputMethod

(ts:
VAR

Component;

slRecord:

ScriptLanguageRecord) :

OSErr;

ts

The component identi er of the input method text service component to
be associated with the script and language combination given in the
slRecord parameter.

slRecord

Ascript-language record that describes the script and language
combination to be associated with the input method text service
component speci ed in the ts parameter.

DESCRIPTION

The operating system uses Set Default InputMethod to associate an input method text
service component with a given script and language. The operating system calls this
function when the user expresses input method preferences through the Keyboard menu,
Keyboard control panel, or other device. The associations made with this function are
permanent; that is, they persist after restart.
If the script code and language code speci

ed in the script-language record are

incompatible,

returns the error paramErr.

Set

Default InputMethod

RESULT CODES

noErr
paramErr
tsmScriptHasNoIMErr
tsmCantOpenComponentErr

Text Services Manager Reference

No error
The script does not match the language
Current script does not use input methods
Cannot open default input of current script

7-63

CHAPTER

7

Text Services Manager

GetDefaultInputMethod
The Get Default InputMethod function returns the default (input method) text service

component for a given script and language.
FUNCTION

GetDefaultInputMethod

(VAR
VAR

ts:

Component;

slRecord:

ScriptLanguageRecord) :

OSErr;

ts

The component identi er of the input method text service component that
is associated with the script and language combination given in the
slRecord parameter.

slRecord

Ascript-language record that describes the script and language
combination that is associated with the input method text service speci
in the ts parameter.

ed

DESCRIPTION

The operating system uses GetDefaultInputMethod to nd out which input method
to activate when the user selects a new keyboard script from the Keyboard menu or by
Command-key combination, or when an application calls KeyScript to change
keyboard scripts.
In versions of Japanese system software starting with KanjiTalk 7.0, if the default input
method is an old (pre-KanjiTalk 7.0) non-TSM-aware method,
GetDefaultInputMethod returns the error

tsmInputMethodIsOldErr. In that case

the ts parameter contains the script code of the old input method in its high-order word,
and the reference ID of the old input method in its low-order word.

RESULT CODES

noErr
paramErr
tsmScriptHasNoIMErr
tsmInputMethodIsOldErr

No error
The script does not match the language
The script does not use input methods
The default input method is old-style

SetTextServiceLanguage
The Set Text
and language.
FUNCTION

ServiceLanguage

function changes the current input script

SetTextServiceLanguage

(VAR

slRecord:

ScriptLanguageRecord):

slRecord

7-64

A

OSErr;

script-language record for the current text service component.

Text Services Manager Reference

CHAPTER

7

Text Services Manager

DESCRIPTION
The operating system calls this Text Services Manager function when the user switches
the keyboard script, so that the Text Services Manager can synchronize the input method
with the current keyboard script.
RESULT CODES
noErr
paramErr
tsmCantOpenComponentErr

No error
The script does not match the language
Cannot open default input of the script

GetTextServiceLanguage
The Get Text ServiceLanguage function returns the language supported by the
default (current) input method text service component for the current keyboard script.
FUNCTION

GetTextServiceLanguage

(VAR

slRecord:

ScriptLanguageRecord):

slRecord

OSErr;

Ascript-language record that, upon completion of the call, describes the
language supported by the current text service component.

RESULT CODES

noErr

No error

Apple Event Handlers Supplied by Client Applications
This section describes the Apple events for which client applications must install
handlers. Text service components request action from and send information to client
applications through these Apple events.
Your application uses these Apple events to receive text from text service components, to

show or hide input windows, and to convert screen positions to text offsetsN and vice

versaN for text service components. The conversion operations are used to track mouse

events and determine screen locations of text in the active input area.

The Apple events described in this section are all organized under the
kTextServiceClass constant with a value of 'tsvc'.

Text Services Manager Reference

7-65

CHAPTER

7

Text Services Manager

lists the Apple event ID constants for the Apple events described in this section.
Table 7-1

Apple event ID constants

Constant

Value

Explanation

kUpdateActivelInputArea

‘'updt'!

Update Active Input Area

kPos20ffset

'p2st'!

Position To Offset

kOffset2Pos

'st2p'

Offset To Position

kShowHideInput Window

'shiw'

Show /Hide Input Window

Table 7-2 shows the Apple event keyword constants used in the Apple events described
in this section.

Table 7-2

Apple event keyword constants

Constant

Value

Meaning

keyAETSMDocumentRefcon

'refc!

TSM document reference constant

keyAEServerInstance

'srvi'!

Component instance

keyAETheData

'kdat!

Text from active input area

keyAEScriptTag

'sclg'

Script-language record

keyAEFixLength

'fixl'!

Length of con

keyAEHiliteRange

'hrng'

Highlight range in text

keyAEUpdateRange

'udng'!

Update range in text

keyAEClauseOffsets

'clau'

Clause offsets array

keyAECurrent Point

'cpos'!

Current point

keyAEDragging

‘bool!

Dragging Sag

keyAEOffset

'ofst'

Byte offset in text

keyAERegionClass

'rgnc!

Region class

keyAEPoint

'gpos'!

Calculated point

rmed text

optional keyword for Update Active Input Area
keyAEPinRange

'pnrg'

Range for scrolling

optional keywords for Offset To Position

7-66

keyAEText

Font

'"ktxt!

Text font

keyAEText

PointSize

'ktps'

Text size

keyAEText

LineHeight

'ktlh'

Text line height

keyAEText

LineAscent

'ktas'

Font ascent

Text Services Manager Reference

CHAPTER

7

Text Services Manager

Table 7-2

Apple event keyword constants (continued)

Constant

Value

Meaning

keyAEAngle

‘kang!

Text angle

'klef!

Leading-edge Boolean

optional keyword for Position To Offset
keyAELeadingEdge

Table 7-3 lists the Apple event descriptor types discussed in this section.
Table 7-3

Apple event descriptor types

Constant

Value

Meaning

typeComponentInstance

'cmpi'

Server instance

typeTextRangeArray

'tray'

Text range array

typeOffsetArray

'ofay'

Offset array

typeIntlWritingCode

‘intl!

Script-language record

typeQDPoint

'QDpt!

QuickDraw point

typeAEText

't TXT!

Apple event text

typeText

'TEXT!

Plain text

typeTextRange

'txrn!

A text range record

typeTSMDocumentRefcon

'refc!

TSM document reference constant

typeFixed

'fixd'!

Fixed 16.16 format

Table 7-4 lists the Apple event descriptor type constants for region class discussed in
this section.
Table 7-4

Apple event descriptor type constants for the Apple event region class

Constant
kTSMOut

Value
sideOfBody

1

kTSMInsideOf Body

2

kTSMInsideOfActiveInputArea

3

For the values of standard Apple event constants used in the following section not listed
in these tables, see the Apple Event Registry: Standard Suites.

Text Services Manager Reference

7-67

CHAPTER

7

Text Services Manager

Creating and Updating an Active Input Area
The text service component uses the Update Active Input Area Apple event to request
that your client application create and update an active input area, and accept con rmed
text. For details on active input areas, see Cinline InputOon page 7-11.
Update Active Input Area—Creating and Updating an Active Input Area
Event class

kTextServiceClass

Event

kUpdateActivelInputArea

ID

Requested action

Update a range of text. Specify any necessary highlighting with
offsets in the optional keyAEHiliteRange parameter.

Required parameters
Keyword:

keyAETSMDocumentRefcon

Descriptor type:

typeLongInteger

Data:

A TSM document speci er (reference constant) supplied by the
application in a prior call to the NewTSMDocument function (see
page 7-50). This value is associated with the TSM document
whose active input area is to be updated.

Keyword:

keyAEServeriInstance

Descriptor type:

typeComponent

Data:

A component instance value created by a prior call to the
Component Manager OpenComponent function. This value
identi es the text service component.

Keyword:

keyAETheData

Descriptor type:

typeChar

Data:

Text data that has been processed in some way by a text service

Keyword:

keyAEScriptTag

Descriptor type:

typeIntlWritingCode

Data:

The script code and language code associated with the text

Instance

component.

returned in the keyAETheData parameter. The information is

passed in a script-language record, as de ned on page 7-42.

7-68

Text Services Manager Reference

CHAPTER

7

Text Services Manager

Update Active Input Area—Creating

and Updating an Active Input Area (continued)

Required parameters

Keyword:

keyAEFixLength

Descriptor type:

typeLongIinteger

Data:

The length of the con

rmed text in the active inline area.

If the value of keyAEFixLength is

1, the text contained in the

keyAETheData parameter is to completely replace the current
selection in the application window. In this case, there is to be no
active input area, the text is all considered to be con rmed, and is
to be made part of the body text of the client application.
If the value is 0, an active input area is in process, but there is no
completely con rmed text being sent.
If the value is greater than 0, the text speci ed in the
keyAETheData parameter up to the indicated offset is con rmed
data and should be consumed by the application. The Text
Services Manager considers any text beyond the offset speci ed

by the keyAEFixLength parameter to be inside the active input

area with the starting point of the active input area at that offset.
This is illustrated in Figure 7-11.

Figure 7-11

Updating text in an active input area

TNE MIVE OALPK CEM
keyAEFixLength = -1 (no conversion needed)

nN he wine dark sea
keyAEFixLength = 0 (no confirmed text)

Tne wine dark sea
A

keyAEFixLength = 5

(first 5 characters are confirmed)

Text Services Manager Reference

7-69

CHAPTER

7

Text Services Manager

Update Active Input Area—Creating and Updating an Active Input Area (continued)
Optional parameters

Keyword:

keyAEHiliteRange

Descriptor type:

typeTextRangeArray

Data:

An array that speci es the ranges of text to be highlighted in
the active input area. It also speci es caret position. There are
5 types of highlighting:
Constant

Applies to

kCaret Position

The caret position only

kRawText

All of the unconverted text

kSelectedRawText

Part of the unconverted text

kConvertedText

All of the converted text

kSelectedConvertedText

Part of the converted text

For instance, the input method may have the application highlight
all raw text with a gray underline; but if it needs to further highlight
a selection within that raw text, it may specify a different underline
for the selected raw text. The text range array is an array of
text-range records, each of which has this form:
TYPE

TextRange

=

RECORD

fStart:
fEnd:
fHiliteStyle:

LongInt ;
LongInt ;
Integer;

END;

For the text-range record whose highlight style is kCaret Position,
both £Start and fEnd are the same and denote the position of the
caret.

Negative values for a text range mean that the speci ed range only
adds to, rather than replaces, any current highlighting for the
speci ed type of text.

7-70

Text Services Manager Reference

CHAPTER

7

Text Services Manager

Update Active Input Area—Creating

and Updating an Active Input Area (continued)

Optional parameters

Keyword:

keyAEUpdateRange

Descriptor type:

typeTextRangeArray

Data:

An array of text-range records that indicates the update range of the
active input area (in many circumstances, not all of the active input
area needs updating). Update Active Input Area always uses the
text-range records in the text range array in pairs. The rst record (0)
speci es a range of old text (text in the inline buffer) to be updated;
the second record (1) speci es the range of text in keyAETheData
that is to replace that old text. In general, the record n (n >= 0, n is an
even number) speci es the range of old text to be updated and the
record n + 1 speci es the range of new text to replace the
corresponding old text. (The fHiliteStyle eld is ignored.)

Keyword:

keyAEPinRange

Descriptor type:

typeTextRange

Data:

A text range record that speci es a start offset and and an end offset
that should be scrolled into view if the text speci ed by these offsets
is not already in view. (The

fHiliteStyle

eld is ignored.)

Keyword:

keyAEClauseOffsets

Descriptor type:

typeOffsetArray

Data:

An offset array (de ned by the Of fsetArray data type) that
speci es offsets of word or clause boundaries of the new text. Offsets
are from the start of the active input area. Applications can use this
information for word selection or other purposes.
TYPE

OffsetArray

=

RECORD

fNumOfOffsets:
Integer;
foffset:
ARRAY[0..0]
of

LongInt;

END ;

The numofoffsets eld contains an integer that speci es the
number of offsets in the offset array. The [Offset eldis an array of
long integers with the number of entries speci ed in the
numOfOffsets eld.
Return parameter

Keyword:

keyErrorNumber

Descriptor type:

typeShortInteger

Data:

Any errors that the application needs to return to the text service
component. The application must pass Memory Manager, TextEdit,
or other errors that it receives through to the component; otherwise,
it should pass 0 (noErr).

Text Services Manager Reference

7-71

CHAPTER

7

Text Services Manager

The text range array data structure used in the keyAEHiliteRange
and keyAEUpadateRange parameters described above is de ned by the
TextRangeArray data type:
TYPE

TextRangeArray

=

RECORD

fNumOfRanges:

Integer;

fRange:

ARRAY[0..0]

of

TextRange;

END;

The £NumOfRanges eld contains an integer that indicates how many text ranges this
array holds. The fRange_ eld contains a series of text-range records. (If the array consists
of more than one text-range record, the size of the array must be calculated as
fNumOfRanges

*

SizeOf

(fRange).)

For sample code that handles the Update Active Input Area Apple event, see Listing 7-7
on page 7-26.

Converting Global Coordinates to Text Offsets
The Position To Offset Apple event requests a client application to convert speci ed
global coordinates to byte offsets in text. The text service component uses this Apple
event for mouse tracking, in order to draw the caret, highlight text, or adjust the cursor
appearance.
Position To Offset—Converting Global Coordinates to Text Offset
Event class

kTextServiceClass

Event ID

kPos20ffset

Requested action

Convert global coordinates speci ed in the keyAECurrent Point
parameter to a byte offset. If the click is within the limits of the

active input area, the offset is relative to the start of the active input

area. Otherwise, the offset is relative to the start of the application@
body text. The client application speci es the classi cation of the
location of the offset in the keyAERegionClass return parameter.
Required parameters

7-72

Keyword:

keyAETSMDocumentRefcon

Descriptor type:

typeLongInteger

Data:

A TSM document speci er (reference constant) supplied by the
application in a prior call to the NewTSMDocument function
(see page 7-50). This value is associated with the TSM document
affected by this event.

Text Services Manager Reference

CHAPTER

7

Text Services Manager

Position To Offset—Converting Global Coordinates to Text Offset (continued)

Required parameters

Keyword:

keyAEServeriInstance

Descriptor type:

typeComponent

Data:

A component instance value created by a prior call to the
Component Manager OpenComponent function. This value
identi es the text service component.

Keyword:

keyAECurrent

Descriptor type:

typePoint

Data:

A point that contains the global coordinates that describe the
current mouse position.

Instance

Point

Optional parameter

Keyword:

keyAEdragging

Descriptor type:

typeBoolean

Data:

A Boolean value that indicates whether the input method is
currently tracking the mouseN that is, whether the user is dragging
the current selection. If it is TRUE, the application should pin the
cursor to the limits of the active input area (to avoid highlighting
beyond the limits of the active input area).

Return
parameters

Keyword:

keyAEOffset

Descriptor type:

typeLongIinteger

Data:

A byte offset that speci es the character corresponding to the
current mouse position (keyAECurrent Point). If the click is

within the limits of the active input area, the offset is relative to the
start of the active input area. Otherwise, the offset is relative to the

start of the application@ body text.

Keyword:

keyAERegionClass

Descriptor type:

typeShortInteger

Data:

The classi cation of the position speci ed in the keyAEOffset
parameter. Three constants de ne the classi cation:
Valu
e

Constant
kTSMOut

sideOf Body

1

kTSMInsideOfBody

2

kTSMInsideOfActivelInputArea

3

A value of

kTSMOut

sideOfBody means that the offset is

outside the application@ body text. A value of
kTSMInsideOfBody means that the offset is inside the body text.

kTSMInsideOfActiveInputArea means that the offset is inside

the active input area.

continued

Text Services Manager Reference

7-73

CHAPTER

7

Text Services Manager

Position To Offset—Converting Global Coordinates to Text Offset (continued)

Return
parameters
Keyword:

keyErrorNumber

Descriptor type:

typeShort Integer

Data:

Any errors that the application needs to return to the text service
component. The application must pass Memory Manager, TextEdit,
or other errors that it receives through to the component; otherwise,
it should pass 0 (noErr).

Optional return parameter
Keyword:

keyAELeadingEdge

Descriptor type:

typeBoolean

Data:

A Boolean value that is equivalent to the leadingEdge parameter
of the QuickDraw PixelToChar function. It is TRUE if the

speci ed point corresponds to the leading edge of the character
whose offset is returned; it is FALSE if the speci ed point
corresponds to the trailing edge of the character.
For sample code that handles the Position To Offset Apple event, see Listing 7-8 on
page 7-30.

Converting Text Offsets to Global Coordinates
The Offset To Position Apple event requests that a client application convert byte offsets
in text to global coordinates. The text service component uses this Apple event to
determine where in the active input area to draw an element (such as the caret or a
palette of conversion choices) that relates to a particular character.
Offset To Position—Converting Text Offsets to Global Coordinates
Event class

kTextServiceClass

Event ID

kOffset2Pos

Requested action

Convert a speci ed byte offset into global coordinates. The offset
value passed to the client application is relative to the start of the
active input area. If there is no active input area, the offset is relative
to the start of the current text body.

Required parameters

7-74

Keyword:

keyAETSMDocument
Ref con

Descriptor type:

typeLongInteger

Data:

A TSM document speci er (reference constant) supplied by the
application in a prior call to the NewTSMDocument function (see
page 7-50). This value is associated with the TSM document affected
by this event.

Text Services Manager Reference

CHAPTER

7

Text Services Manager

Offset To Position—Converting Text Offsets to Global Coordinates (continued)

Required parameters

Keyword:

keyAEServeriInstance

Descriptor type:

typeComponentInstance

Data:

A component instance value returned by a prior call to the
Component Manager OpenComponent function. This value
identi es the text service component.

Keyword:

keyAEOffset

Descriptor type:

typeLongInteger

Data:

The text offset to be converted into a global point. Offset is in terms
of bytes from the start of the active input area.

Return parameters

Keyword:

keyAEPoint

Descriptor type:

typePoint

Data:

A point that contains the global coordinates obtained by converting
the byte offset passed in the keyAEOffset parameter.

Keyword:

keyErrorNumber

Descriptor type:

typeShortInteger

Data:

errOffsetInvalid indicates that there is no text at the offset.
errOf fsetIsOutsideOf View indicates that the text offset is out
of view.

The application must pass Memory Manager, TextEdit, or other
errors that it receives through to the component; otherwise, it should
pass 0 (noErr).
Optional return parameters

Keyword:

keyAEText Font

Descriptor type:

typeLongInteger

Data:

The font of the text in the active input area. The application can send
this information to the input method to help the input method
position the active input area.

Keyword:

keyAEText

Descriptor type:

typeFixed

Data:

The size of the text in the active input area. The application can send
this information to the input method to help the input method
position the active input area.

Keyword:

keyAEText

Descriptor type:

typeShortInteger

Data:

The line height of the text in the active input area. The application
can send this information to the input method to help the input
method position the active input area.

PointSize

LineHeight

continued

Text Services Manager Reference

7-75

CHAPTER

7

Text Services Manager

Offset To Position—Converting Text Offsets to Global Coordinates (continued)

Optional return parameters

Keyword:

keyAEText

Descriptor type:

typeShortInteger

Data:

The ascent height of the text in the active input area. The application
can send this information to the input method to help the input
method position the active input area.

Keyword:

keyAEAngle

Descriptor type:

typeFixed

Data:

The orientation of the text in the active input area. The value 90
speci es a horizontal line direction and 180 speci es a vertical line
direction. The application can send this information to the input
method to help the input method position the active input area.

LineAscent

For sample code that handles the Offset To Position Apple event, see Listing 7-9 on
page 7-33.
Showing or Hiding the Floating Input Window
Input methods that supply Soating input windows for bottomline input may need to
show or hide the input window at various times. The Show/Hide Input Window Apple
event requests the client application to make the Soating input window either visible or
not visible, so that an input method can offer any of the above options.
Note

If your application is not displaying its own Soating input window, you
can ignore this Apple event. @
Show/Hide Input Window—Showing or Hiding the Floating Input Window
Event class

kTextServiceClass

Event ID

kShowHidelInputWindow

Requested action

Make the bottomline Soating input window either visible or not
visible, depending on the value of the
keyAEShowHide InputWindow parameter.

Required parameters

7-76

Keyword:

keyAETSMDocumentRefcon

Descriptor type:

typeLongInteger

Data:

A TSM document speci er (reference constant) supplied by the
application in a prior call to the NewTSMDocument function (see
page 7-50). This value is associated with the TSM document for the
window being shown or hidden.

Keyword:

keyAEServeriInstance

Descriptor type:

typeComponent

Text Services Manager Reference

Instance

CHAPTER

7

Text Services Manager

Show/Hide Input Window—Showing

Data:

or Hiding the Floating

Input

Window

(continued)

A component instance value returned by a prior call to the
Component Manager OpenComponent function. This value
identi es the text service component.

Optional parameter
Keyword:

keyAEShowHideInputWindow

Descriptor type:

typeBoolean

Data:

If TRUE, the bottomline input window should be shown; if FALSE, it

should be hidden. This parameter is not needed if the input method
is simply inquiring about the state of the input window.

Return parameter
Keyword:

keyAEShowHideInputWindow

Descriptor type:

typeBoolean

Data:

The current state of the input window: TRUE if the window is
shown; FALSE if it is hidden. If the optional parameter

keyAEShowHideInputWindow is included, this return parameter

should show the state of the window before it was set to the state
requested in the optional parameter.

Text Services Manager Routines for Components
This section describes the Text Services Manager component interfaceN the routines and
related data structures that are for the use of text service components. These functions let
your text service component

m send Apple events to a client application to request speci
active input area in a TSM document

_c information about the

m put up a fSoating window for various purposes

Sending Apple Events to a Client Application
This section describes the SendAEFromTSMComponent

function, with which your text

service component sends Apple events to a client application.

SendAEFromTSMComponent
The SendAEFromTSMComponent function sends Apple events from a text service
component to a client application.
FUNCTION

SendAEFromTSMComponent

(VAR
VAR

theAppleEvent:

reply:

sendMode:

Text Services Manager Reference

AppleEvent;

AppleEvent;
AESendMode;

7-77

CHAPTER

7

Text Services Manager

sendPriority:

AESendPriority;

timeOutInTicks:
idleProc:
filterProc:

LongInt;

IdleProcPtr;
EventFilterProcPtr):

OSErr;

theAppleEvent

The Apple event to be sent.

reply

The reply Apple event returned by SendAEFromTSMComponent.

sendMode

The value that lets you specify one of the following modes speci ed by
corresponding constants: the reply mode for the Apple event, the
interaction level, the application switch mode, the reconnection mode, and
the return receipt mode. To obtain the value for this parameter, add the
appropriate constants. Comprehensive details about these constants are
provided in the description of the Apple Event Manager AESend function
in Inside Macintosh: Interapplication Communication.

sendPriority

The value that speci

es whether to put the Apple event at the back of the

event queue (set with the kAENormal Priority £ag) or at the front of the
queue (kAEHighPriority f&ag).
timeOutInTicks

The length of time (in ticks) that the client application is willing to wait for
the reply or return receipt from the server application before it times out.
If the value of this parameter is kNoTimeOut, the Apple event never times
out.

idleProc

filterProc

A pointer toa function for any tasks (such as displaying a globe, a
wristwatch, or a spinning beach ball cursor) that the application performs
while waiting for a reply or a return receipt.
A pointer to a routine that accepts certain incoming Apple events that are
received while the handler waits for a reply or a return receipt and _lters
out the rest.

DESCRIPTION

The SendAEFromTSMComponent function is essentially a wrapper routine for the Apple
Event Manager function AESend. See the description of AESend for additional necessary
information, including constants for the sendMode parameter and result codes.
SendAEFromTSMComponent identi es your text service component from the
keyAEServer Instance parameter in the Apple event speci ed in the
theAppleEvent parameter. If a reference constant (refcon) in a TSM document that

corresponds to this parameter is found in the internal data structures of the Text Services
Manager, SendAEFromTSMComponent adds the reference constant as the
keyAETSMDocumentRefcon parameter to the given Apple event before sending it to
the application.

7-78

Text Services Manager Reference

CHAPTER

7

Text Services Manager

If the client application is not TSM-aware, SendAEFromTSMComponent routes the Apple
events to the Soating input window to allow bottomline input.
IMPORTANT

If your text service component changes the environment in any wayN
such as by modifying the A5 world or changing the current zoneN while
constructing an Apple event, it must restore the previous settings before
sending the Apple event. a
Note
Your text service component should always use the kCurrent Process
constant as the target address when it creates an Apple event to send to
the Text Services Manager. @
SEE ALSO

The AESend function is described with the Apple Event Manager in Inside Macintosh:
Interapplication Communication.
The kCurrent Process

constant is described in Inside Macintosh: Processes.

For sample code showing how a text service component calls the
SendAEFromTSMComponent

function, see Listing 7-11 on page 7-45.

Opening Floating Utility Windows
In conjunction with the Process Manager, the Text Services Manager maintains the
Soating window service, whose windows occupy a special layer called the Soating
window service layer. See Figure 7-7 on page 7-14.
The Text Services Manager uses the Soating window service to provide a standard
Soating input window when needed. Text service components can use the service to
create, close, and nd fSoating windows used for various other user-interface purposes.
You can manipulate the service windows with these calls:
m The NewServiceWindow function lets you open a Soating window in front of the
current application.
m The CloseServiceWindow function lets you close a previously allocated foating
window.
m The Get FrontServiceWindow function helps you
window in the Soating window service layer.

nd out which is the frontmost

m The FindServiceWindow function helps you nd out which part of a text service
component@ Soating window a mouse-down event has occurred in.
Client applications

These calls may be made by client applications also. See the following
description of NewServiceWindow for special instructions for client
applications.

Text Services Manager Reference

7-79

CHAPTER

7

Text Services Manager

NewServiceWindow
The NewServiceWindow function opens a Soating utility window in the Goating
window service layer, in front of the current application. The text service component may
use the window for interaction with the user or other purposes.
FUNCTION

NewServiceWindow

(wStorage:
title:
theProc:

Ptr;

Str255;

boundsRect

visible:

Integer;

goAwayFlag:

wStorage

boundsRect:
behind:

Rect;

Boolean;
WindowPtr;

Boolean;

ts:

ComponentiInstance;

VAR

window:

WindowPtr):

OSErr;

Apointer to the location in memory of the window record. Do not allocate
the window record on the stack. Always be sure to allocate the window in
the heap, or else pass NIL for this parameter.
A rectangle given in global coordinates that determines the size and
location of the new fSoating window. This rectangle becomes the
portRect eld ofthe graphics port record (de ned by the QuickDraw
GrafPort data type) for this window.

title

A Pascal string that contains the title of the window.

visible

A Boolean value to determine whether the window is to be drawn. If

TRUE, NewServiceWindow draws the window. First it calls the window

de nition procedure de ned in the theProc parameter to draw the
window frame. Then it generates an update event for the entire window
contents.

theProc

The window

de

nition procedure for the fSoating window.

behind

A window pointer (de ned by the Window Manager WindowPtr data
type) that determines the plane of the foating window.
NewServiceWindow inserts the new window behind the window

pointed to by this parameter. To put the new window behind all other
windows, use behind
= NIL. To place it in front of all other windows,
use behind
= POINTER(-1).
goAwayFlag

ts

A Boolean value that determines whether the go-away region should be
drawn in the window. If this parameter is TRUE and the window is
frontmost (as speci ed by the behind parameter), NewServiceWindow
draws a go-away region in the frame.
A component instance returned by a prior call to the Component Manager
OpenComponent function. This value is stored in the refcon

eld of the

window record; text service components should not change the value of
the window@ refcon eld.

7-80

Text Services Manager Reference

CHAPTER

7

Text Services Manager

Client applications

If you are a client application making this call, pass the Process Manager
constant kCurrent Process in this parameter so that events in the new
window will be forwarded to you. After you have created the window,
you can use its refcon eld for private storage as usual. @
window

A pointer to the newly allocated Soating window.

DESCRIPTION

This function calls the Window Manager NewWindow function. If a Soating window is
successfully allocated, NewServiceWindow returns a pointer to that window as the
function result. Otherwise, it returns NIL.

A text service component can open multiple windows in this layer. When a text service
component receives an event, it determines whether the event belongs to one of its text
service component windows by calling FindServiceWindow.
If you are an application that uses NewServiceWindow to open a Soating window, be
sure to hide the fsoating window when you are switched out; that is, when another
application®@ windows become active.
Balloon Help

If you are writing a text service component and want the service window
to have custom Balloon Help, place an 'hwin' resource (with references
to 'hcrt' and 'STR#' resources) in your component resource fork,
with a name equal to the window title. The Text Services Manager will
then open the resources automatically when needed. If you are writing a
client application, you need not follow anything other than normal
procedures to have Balloon Help.

RESULT CODES

noErr
memFullErr

No error
Insuf cient memory to open the window

SEE ALSO

Window de _ nition procedures and the NewWindow function are described in the
Window Manager chapter of Inside Macintosh: Macintosh Toolbox Essentials.
Balloon Help is described in the Help Manager chapter of Inside Macintosh: More
Macintosh Toolbox.

Text Services Manager Reference

7-81

CHAPTER

7

Text Services Manager

CloseServiceWindow
The CloseServiceWindow function closes a previously allocated Soating
input window.
FUNCTION

CloseServiceWindow

window

(window:

WindowPtr):

OSErr;

A pointer to the service window to close. This function calls the Window
Manager CloseWindow procedure.

DESCRIPTION

If the window pointer is NIL or if it points to a non-foating window,
CloseServiceWindow returns paramErr.

RESULT CODES

noErr
paramErr

No error
Parameter error

SEE ALSO

The CloseWindow procedure is described in the Window Manager chapter of Inside
Macintosh: Macintosh Toolbox Essentials.

GetFrontServiceWindow
The

Get Front ServiceWindow

function determines which is the frontmost window

the fSoating window service layer.
FUNCTION

window

GetFrontServiceWindow

(VAR

window:

WindowPtr):

OSErr;

A pointer to the frontmost window in the service layer.

DESCRIPTION

This function calls the Window Manager

Front Window

function. The

Get Front ServiceWindow function returns a pointer to the frontmost window in the
service layer. If there is no window in the service layer, it returns NIL.

SEE ALSO

The Front Window function is described in the Window Manager chapter of Inside
Macintosh: Macintosh Toolbox Essentials.

7-82

Text Services Manager Reference

in

CHAPTER

7

Text Services Manager

FindServiceWindow
The FindServiceWindow function determines which part of a text service component@
Soating window a mouse-down event has occurred in.
FUNCTION

FindServiceWindow

(thePoint:

VAR

Point;

theWindow:

WindowPtr):

Integer;

thePoint

The point where the mouse button was pressed (in global coordinates, as
stored inthe where eld of the Event Manager event record).

theWindow

A pointer toa Window Manager window pointer (de ned by the
WindowPtr data type) that identi es the Soating window in which the
mouse-down event occurred. If the mouse-down event did not occur ina
text service component fsoating window, this parameter is set to NIL.

DESCRIPTION

The FindServiceWindow function is similar to the Window Manager FindWindow
function, except that FindServiceWindow searches the Soating window service
layer only.
FindServiceWindow calls the Window Manager FindWindow function. It returns one
of the following prede ned constants to identify the location of the mouse-down event.
Constant

Value

inDesk

0

None of the following

Explanation

inMenuBar

1

In menu bar

inSysWindow

2

In system window

inContent

3

In content region (except grow, if active)

inDrag

4

In drag region

inGrow

5

In grow region (active window only)

inGoAway

6

In go-away region (active window only)

inZoomIn

7

In zoom-in region

inZoomOut

8

In zoom-out region

It the mouse position is not over a Soating window, FindServiceWindow returns
inDesk (0) as its function result, and sets the return parameter theWindow to NIL.

SEE ALSO

The FindWindow function is described in the Window Manager chapter of
Inside Macintosh: Macintosh Toolbox Essentials.

Event records are described in the Event Manager chapter of Inside Macintosh: Macintosh
Toolbox Essentials.
The Process Manager is described in Inside Macintosh: Processes.

Text Services Manager Reference

7-83

CHAPTER

7

Text Services Manager

Text Service Component Routines
This section describes the component-level routines and related data structures and
constants through which the Text Services Manager communicates with text service
components. The Text Services Manager uses the Component Manager to dispatch the
text service component routines to speci c text service components.
Client applications also may make the calls described in this section, but the
Text Services Manager does not play a role in the connection between the client
application making the call and the text service component receiving it. If you are
an application making these calls, you need to know the component instance of the
component whose routine you are calling.
If you are writing a text service component, it must implement routines for the calls
described in this section. With these routines, your component
m provides a text service
m accepts events and updates its cursor and menu (if any)
m con

rms active input when requested (if it is an input method)

m identi

es the scripts and languages it supports

Providing a Text Service
This section describes the functions a text service component supports to initiate,
activate, deactivate, and terminate a text service. The Text Services Manager makes these

calls to components either on its own or in response to application-interface calls it
receives from client applications.

InitiateTextService
The InitiateTextService function instructs a speci ed text service component to do
whatever it needs to set up its operations and commence its performance.
FUNCTION

InitiateTextService

(ts:

ComponentInstance) :

ComponentResult;

ts

A component instance created by a prior call to the Component Manager
OpenComponent

function.

DESCRIPTION
The Text Services Manager can call InitiateTextService to any component that it
has already opened with the Component Manager OpenComponent or
OpenDefaultComponent functions. Text service components should be prepared to
handle InitiateTextService calls at any time.

7-84

Text Services Manager Reference

CHAPTER

7

Text Services Manager

Any text service component can receive multiple InitiateTextService calls. The
Text Services Manager calls InitiateTextService each time the user adds a text
service to a TSM document, even if the text service component has already been opened.
This provides an opportunity for the component to restart or to display user interface
elements that the user may have closed.
This function should return a ComponentResult value of zero if there is no error, and
an error code if there is one.

ActivateTextService
The ActivateTextService function noti es a text service component that its
associated document window is becoming active. This allows the text service component
to display any associated Soating windows.
FUNCTION

ActivateTextService

(ts:

ComponentInstance) :

ComponentResult ;

ts

A component instance created by a prior call to the Component Manager
OpenComponent

function.

DESCRIPTION
The appropriate response to ActivateText Service is for the text service component
to restore its active state, including displaying all Soating windows if they have been
hidden. If it is an input method, it should specify the redisplay of any uncon rmed text
currently in the active input area.

DeactivateTextService
The DeactivateTextService function lets a text service component know that its
associated document window is becoming inactive. This allows time for the text service
component to prepare for deactivation.
FUNCTION

DeactivateTextService

(ts:

ComponentInstance) :

ComponentResult;

ts

A component instance created by a prior call to the Component Manager
OpenComponent

Text Services Manager Reference

function.

7-85

CHAPTER

7

Text Services Manager

DESCRIPTION

When it receives

a DeactivateTextService

call, the text service component is

responsible for saving whatever state information it needs to save, so that it can restore
the proper information when it becomes active again. A component other than an input
method should also hide all its Soating windows and menus. However, an input-method
component should not hide its windows in response to this call. If the subsequent
document being activated is using the same component@ service, it would be irritating to
the user to hide and then immediately redisplay the same windows. An input-method
component should hide its windows only in response to a HidePaletteWindows call.
An input method should not con
should save it until reactivated.

rm any uncon

rmed text in the active input area, but

HidePaletteWindows
The HidePaletteWindows function instructs an input method to hide its Soating
windows because another input method is becoming active.
FUNCTION

HidePaletteWindows

(ts:

ComponentInstance) :

ComponentResult ;

ts

A component instance created by a prior call to the Component Manager
OpenComponent

function.

DESCRIPTION

The HidePalet teWindows function is not called every time a component@ document
becomes inactive; it is called by the Text Services Manager only if the new document that
is becoming active does not use the same text service component as the document last
deactivated. When it receives a HidePalet teWindows call, the text service component
should hide all its Soating and nonfsoating windows. Its menus, if any, will be removed
from the menu bar by the Text Services Manager.
If the text service component has no palettes, it should return a ComponentResult
value of noErr.

Terminate TextService
The TerminateTextService function terminates the operations of a text service in
preparation for closing the text service component.
FUNCTION

TerminateTextService

(ts:

ComponentInstance) :

ComponentResult;

7-86

Text Services Manager Reference

CHAPTER

7

Text Services Manager

ts

A component instance created by a prior call to the Component Manager
OpenComponent

function.

DESCRIPTION

The Text Services Manager calls TerminateText Service before closing the component
instance. A text service component must use this opportunity to con rm any inline input
in progress.
If the text service component needs to remain open, it should return an OSErr value in
the component result return value. This could happen, for example, if the user chooses
Cancel in response to a text service component dialog box.
If this call is made to the last open instance of a text service component, the component
should hide any open palette windows. If it is an input method, the component should
not dispose of its menu handle if it has a menu.

Responding to Events and Updating the Cursor and Menu
To pass events to text service components, the Text Services Manager calls the
TextServiceEvent function. To allow components to handle menu commands, it calls

TextServiceMenuSelect. To allow components to set the shape of the cursor, it calls
SetTextServiceCursor. To allow components to add their menus to the menu bar, it
calls Get Text ServiceMenu.

TextServiceEvent
The

Text ServiceEvent function routes an event to a speci

FUNCTION

TextServiceEvent

(ts:

ComponentInstance;

numOfEvents:
VAR

ed text service component.

event:

Integer;
EventRecord) :

ComponentResult ;

ts

A component instance created by a prior call to the Component Manager
OpenComponent

numOfEvents

event

function.

The number of events being passed.
The Event Manager event record (de ned by the
for the event being passed.

Text Services Manager Reference

Event Record

data type)

7-87

CHAPTER

7

Text Services Manager

DESCRIPTION

If the text service component handles the event, it should return a nonzero value for

componentResult and it should change the event to a null event. If it does not handle

the event, it should return 0.

TextServiceMenuSelect
The Text ServiceMenuSelect
commands from its menus.
FUNCTION

function lets a text service component handle

TextServiceMenuSelect

(ts:

ComponentInstance;

serviceMenu:

item:

ts

Integer):

ComponentResult ;

A component instance created by a prior call to the Component Manager
OpenComponent

serviceMenu

item

MenuHandle;

function.

A Menu Manager menu handle (de ned by the MenuHand1e data type) to
aspeci c text service component menu.
The text service component menu item that the user has selected.

DESCRIPTION

When the user makes a menu selection, the client application calls TSMMenuSelect; the
Text Services Manager in turn calls Text ServiceMenuSelect to all active components.
The text service component receiving this call should return 0 for componentResult if
it did not handle the menu selection, and 1 if it did.

After the text service component performs the chosen task, it is not responsible for
removing the highlighting from the menu title.

SetTextServiceCursor
The Set TextServiceCursor function lets the text service component control the shape
of the cursor.
FUNCTION

SetTextServiceCursor

(ts:

ComponentInstance;

mousePos:

ts

ComponentResult;

A component instance created by a prior call to the Component Manager
OpenComponent

7-88

Point):

Text Services Manager Reference

function.

CHAPTER

7

Text Services Manager

mousePos

A location (speci ed asa QuickDraw point) that speci es the global
coordinates for the vertical and horizontal position of the mouse.

DESCRIPTION

The text service component must return a nonzero value for ComponentResult

if it has

set the cursor, and 0 if it has not.

GetTextServiceMenu
The Get Text ServiceMenu function returns a handle to a menu belonging to a text
service component.
FUNCTION

GetTextServiceMenu

(ts:

ComponentInstance;

VAR

serviceMenu:

MenuHandle) :

ComponentResult;

ts

A component instance created by a prior call to the Component Manager
OpenComponent

serviceMenu

function.

A menu handle (de ned by the Menu Manager MenuHand1e data type)
for the text service component that is to be updated.

DESCRIPTION

The Text Services Manager calls Get Text ServiceMenu to a text service component
when the component is opened or activated, so that it can put the component@ menu on
the menu bar.
The menu handle passed in serviceMenu may be preallocated or it may be NIL. If
the menu handle is NIL, the text service component should allocate anew menu and
return it.
Note
All instances of an input-method component must share a single menu
handle, allocated in the system heap. @
If the text service component does not have a menu, it should return a
Component Result value of TSMHasNoMenuErr.

Con

rming Active Input in a TSM Document
To stop active input in a text service component, the Text Services Manager calls the
FixTextService function described in this section.

Text Services Manager Reference

7-89

CHAPTER

7

Text Services Manager

FixTextService
The FixText Service function explicitly terminates any input that is in progress in a
speci ed text service component.
FUNCTION

FixTextService

ts

(ts:

ComponentInstance):

ComponentResult;

A component instance created by a prior call to the Component Manager
OpenComponent

function.

DESCRIPTION

This function is equivalent to the user explicitly con rming text, but the request comes
instead from the application or from the Text Services Manager. The text service
component must stop accepting further input and con rm the current input, as
appropriate.

Identifying the Supported Scripts and Languages
The Text Services Manager or a client application may call the
GetScriptLanguageSupport

function to

supported by your text service component.

nd out all the scripts and languages

GetScriptLanguageSupport
The

speci

Get ScriptLanguageSupport

function determines which languages and scripts a

ed text service component supports, including its primary language and script.

FUNCTION

GetScriptLanguageSupport

(ts:

ComponentInstance;

VAR

scriptHandle:

ScriptLanguageSupportHandle) :
ComponentResult ;

ts

A component instance created by a prior call to the Component Manager
OpenComponent

scriptHandle

function.

A handle to a script-language support record. The handle must be either
NIL or a valid handle. If it is NIL, the text service component allocates a

new handle. If it is already a valid handle, the text service component

resizes it as necessary.

7-90

Text Services Manager Reference

CHAPTER

7

Text Services Manager

DESCRIPTION

The

Get ScriptLanguageSupport

function lets a caller

languages that your text service component supports.

nd out all scripts and

Get ScriptLanguageSupport

should return a list of scripts and languages in the scriptHand1le

return parameter. The

Component Result return value should contain 0 if the list is correct, or an error value if
an error occurred.

The component should list all its supported scripts and languages, starting with the
primary script and language as speci edin the componentFlags_ eld of its component
description record. See page 7-15.
The result is returned in a handle to a script-language support record. See identifying
the Supported Scripts and LanguagesOon page 7-42 for a description of the
script-language support record.

SEE ALSO

For sample code that shows a text service component responding to the
GetScriptLanguageSupport

Text Services Manager Reference

function, see Listing 7-10 on page 7-43.

7-91

CHAPTER

7

Text Services Manager

Summary of the Text Services Manager
Pascal Summary
Constants
CONST
kTSMVersion

=

kTextService

1;
=

'tsvc';

kInputMethodService
bTakeActiveEvent
bScriptMask

=

bLanguageMask

=

=

'inpm';

{Bit

15;

=

ScriptMask

kSelectedConvertedText

=

5;

+

takes

activate events}
{Bits 8 - 14}
{Bits 0 - 7}
{Bits 0 - 14}

{specify
{specify
{specify
{specify

caret
range
range
range

position}
of raw text}
of selected raw text}
of converted text}

{specify

range

of

selected

converted

text}

constants}

=

{Event class}
{Update active inline area}
{Convert global coordinates to }
{ character position}
{Convert character position to }
{ global coordinate}
{show or hide the input window}

'st2p';

kShowHideInputWindow
{Event keywords}
keyAETSMDocumentRefcon

=

'shiw';

=

'refc';

keyAEServerInstance = 'srvi';
keyAETheData = 'kdat';

7-92

component

bLanguageMask;

kTextServiceClass = kTextService;
kUpdateActiveInputArea = 'updt';
kPos20ffset = 'p2st';
koffset2Pos

if

SOOOOOOFF;

{Hilite styles}
kCaretPosition = 1;
kRawText = 2;
kSelectedRawText = 3;
kConvertedText = 4;

Event

set

$00007F00;
=

bScriptLanguageMask

{Apple

{Version of Text Services Manager}
{Component type for component description}
{Component subtype for component desc.}

{TSM

document

{Server instance}
{typeText }

Summary of the Text Services Manager

refcon}

CHAPTER

7

Text Services Manager

keyAEScriptTag

=

'sclg';

keyAEFixLength

=

'fixl';

keyAEHiliteRange

=

'hrng'

keyAEUpdateRange = 'udng'
keyAEClauseOffsets = 'clau';
keyAECurrentPoint = 'cpos';
keyAEDragging = 'bool';
keyAEOffset = 'ofst';
keyAERegionClass = 'rgnc';
keyAEPoint = 'gpos';
keyAEBufferSize = 'buff';
keyAERequestedType = 'rtyp'
keyAEMoveView = 'mvvw';
keyAELength = 'leng'
keyAENextBody = 'nxbd';
{optional

keywords

keyAETextFont

for
=

{Hilite

range

=

'ktlh';

keyAETextLineAscent

=

'ktas';

'kang'

{optional keyword for Pos20ffset}
keyAELeftSide = 'klef';
{type

Boolean}

{optional keyword for kShowHideInputWindow}
keyAEShowHideInputWindow = 'shiw';
{type
for

type

Boolean}

PinRange}

keyAEPinRange

{Desc

=

'pnrg';

...}

typeComponentiInstance

=

'cmpi';

{component

instance}

typeTextRange = 'txrn';
typeTextRangeArray = 'tray'
typeOffsetArray = 'ofay'
typeIntlWritingCode = '‘intl';

{text range}
{text range array}
{offset array}
{script code}

typeQDPoint

{QuickDraw

=

'QDpt';

typeAEText = 'tTXT';
typeText = 'TEXT';
{Apple

text}

'ktps';
=

{keyword

array}

{Update range array}
{Clause offsets array}
{Current point}
{Dragging flag}
{Offset}
{Region class}
{Current point}
{Buffer size to get the
{Requested text type}
{Move view flag}
{Length}
{Next or previous body}

Offset2Pos}

keyAETextLineHeight
=

tag}

'ktxf';

keyAETextPointSize

keyAEAngle

{Script

event

{Apple
{plain

descriptor

kTSMOutsideOfBody
kTSMInsideOfBody

type

=
=

point}

event
text}

text}

constants}

1;
2;

Summary of the Text Services Manager

7-93

CHAPTER

7

Text Services Manager

kTSMInsideOfActivelInputArea
kNextBody

=

event

3;

1;

kPreviousBody

{Apple

=

=

2;

error

constants}

errOffsetInvalid

=

-1800;

errOffsetIsOutsideOfView
errTopOfDocument
errTopOfBody

=

=

=

-1801;

-1810;

-1811;

errEndOfDocument
errEndOfBody

=

=

-1812;

-1813;

Data Types
TYPE

TextRange

=

RECORD

fStart:

LongInt ;

fEnd:

LongInt ;

fHiliteStyle:

Integer;

END;

TextRangePtr

= “TextRange;

TextRangeHandle
TextRangeArray

=

“TextRangePtr;

=

RECORD
fNumOfRanges:

Integer;

fRange:

ARRAY

[0..0]

of

TextRange;

END;
TextRangeArrayPtr

=

TextRangeArrayHandle
OffsetArray

“TextRangeArray;
=

“TextRangeArrayPtr;

=

RECORD
fNumOfOffsets:

Integer;

fOffset:

ARRAY

[0..0]

of

LongInt;

END;

OffsetArrayPtr

=

“OffsetArray;

OffsetArrayHandle
TextServicelInfo

=

“*OffsetArrayPtr;

=

RECORD
fComponent:

7-94

Component ;

Summary of the Text Services Manager

CHAPTER

7

Text Services Manager

fitemName:

Str255;

END;

TextServicesInfoPtr
TextServiceList

=

“TextServicelInfo;

=

RECORD

fTextServiceCount:

Integer;

fServices:

ARRAY

[0..0]

of

TextServicelInfo;

END;

TextServiceListPtr

=

*TextServiceList;

TextServiceListHandle
ScriptLanguageRecord

=

“TextServiceListPtr;

=

RECORD

fScript:

ScriptCode;

flanguage:

lLangCode;

END;

ScriptLanguageSupport

=

RECORD
fScriptLanguageCount

:

Integer;

fScriptLanguageArray:

ARRAY

[0..0]

of

ScriptLanguageRecord;

END ;
ScriptLanguageSupportPtr

=

“ScriptLanguageSupport ;

ScriptLanguageSupportHandle

InterfaceTypeList
TSMDocumentID

=

= ARRAY

=

“ScriptLanguageSupportPtr;

[0..0]

of

OSType;

Ptr;

Text Services Manager Routines for Client Applications

Initializing and Closing as a TSM-Aware Application
FUNCTION

InitTSMAwareApplication:

FUNCTION

CloseTSMAwareApplication:

OSErr;
OSErr;

Creating and Activating TSM Documents
FUNCTION

FUNCTION

NewTSMDocument

(numOfInterface:

Integer;

VAR

supportedinterfaceTypes:

VAR

idocID:

InterfaceTypeList;

TSMDocumentID;

refCon:

LongInt):

OSErr;

(idocID:

TSMDocumentID):

ActivateTSMDocument

Summary of the Text Services Manager

OSErr;

7-95

CHAPTER

7

Text Services Manager

FUNCTION
FUNCTION

DeactivateTSMDocument
DeleteTSMDocument

(idocID:

TSMDocumentID):

OSErr;

(idocID:

TSMDocumentID):

OSErr;

Passing Events to Text Service Components
FUNCTION

TSMEvent

(VAR

event:

EventRecord) :

Boolean;

Passing Menu Selections and Cursor Setting
FUNCTION

TSMMenuSelect

(menuResult:

FUNCTION

SetTSMCursor

(mousePos:

LongInt):
Point):

Boolean;

Boolean;

Confirming Active Input in a TSM Document
FUNCTION

FixTSMDocument

(i1docID:

TSMDocumentID):

OSErr;

Making Text Services Available to the User
FUNCTION

GetServiceList

(numOfInterfaceTypes:

Integer;

supportediInterfaceTypes:

serviceiInfo:
VAR
FUNCTION

OpenTextService

seedValue:

(idocID:
VAR

InterfaceTypeList;

TextServiceListHandle;
LongInt):

TSMDocumentID;

aComponentInstance:

OSErr;
aComponent:

Component;

ComponentInstance) :

OSErr;

FUNCTION

CloseTextService

(idocID:

TSMDocumentID;

ComponentInstance):

aComponentiInstance:

OSErr;

Requesting a Floating Input Window
FUNCTION

UselInputWindow

(idocID:

TSMDocumentID;

useWindow:

Boolean) :

OSErr;

Associating Scripts and Languages With Components
FUNCTION

FUNCTION

FUNCTION

SetDefaultInputMethod
(ts:

Component;

VAR

slRecord:

(VAR

ts:

VAR

slRecord:

ScriptLanguageRecord):

OSErr;

slRecord:

ScriptLanguageRecord):

OSErr;

slRecord:

ScriptLanguageRecord):

OSErr;

Component;

SetTextServiceLanguage
GetTextServiceLanguage
(VAR

7-96

OSErr;

GetDefaultInputMethod

(VAR
FUNCTION

ScriptLanguageRecord):

Summary of the Text Services Manager

VAR

CHAPTER

7

Text Services Manager

Text Services Manager Routines for Components
Sending Apple Events to a Client Application
FUNCTION

SendAEFromTSMComponent

(VAR

theAppleEvent:

VAR

reply:

AppleEvent;

AppleEvent;

sendPriority:

AESendMode;

AESendPriority;

timeOutInTicks:
idleProc:

sendMode:

LongInt;

IdleProcPtr;

filterProc:

EventFilterProcPtr):

OSErr;

Opening Floating Utility Windows
FUNCTION

NewServiceWindow

(wStorage:

title:

Ptr;

Str255;

theProc:

behind:

Boolean;

WindowPtr;

ts:

ComponentInstance;

WindowPtr):

OSErr;

(window:

WindowPtr):

OSErr;

CloseServiceWindow

FUNCTION

GetFrontServicewWindow

(VAR

window:

(thePoint:

WindowPtr):
Point;

VAR

Rect;

Boolean;

window:

FUNCTION

FindServiceWindow

visible:

Integer;

goAwayFlag:

FUNCTION

boundsRect:

VAR

OSErr;

theWindow:

WindowPtr) :

Integer;

Text Service Component Routines

Providing a Text Service
FUNCTION
FUNCTION
FUNCTION

InitiateTextService
(ts:

ComponentInstance):

ComponentResult;

(ts:

ComponentInstance):

ComponentResult;

(ts:

ComponentInstance):

ComponentResult;

(ts:

ComponentInstance):

ComponentResult;

(ts:

ComponentInstance):

ComponentResult;

ActivateTextService
DeactivateTextService

FUNCTION

HidePaletteWindows

FUNCTION

TerminateTextService

Responding to Events and Updating the Cursor and Menu
FUNCTION

TextServiceEvent

(ts:

ComponentInstance;

VAR

event:

Summary of the Text Services Manager

EventRecord):

numOfEvents:

Integer;

ComponentResult;

7-97

CHAPTER

7

Text Services Manager

FUNCTION

TextServiceMenuSelect
(ts:

ComponentInstance;

item:
FUNCTION

Integer):

serviceMenu:

MenuHandle;

ComponentResult;

SetTextServiceCursor
(ts:

ComponentInstance;

mousePos:

Point) :

ComponentResult;
FUNCTION

GetTextServiceMenu

(ts:

ComponentInstance;

VAR

serviceMenu:

MenuHandle):

ComponentResult;

Confirming Active Input in a TSM Document
FUNCTION

FixTextService

(ts:

ComponentInstance):

ComponentResult;

Identifying the Supported Scripts and Languages
FUNCTION

GetScriptLanguageSupport
(ts:

ComponentInstance;

VAR

scriptHandle:

ScriptLanguageSupportHandle):

ComponentResult;

the

C Summary
Constants
#define

kTSMVersion

1

/*

#define

kTextService

'tsvc'!

/*

#define

kiInputMethodService

'‘'inpm'

/*

Version

Text

bTakeActiveEvent

15

/*

Services

component
the

#define

of

Manager

type

component

component

component

bit

set

if

takes

description

subtype

the

the

active

bScriptMask

O0x00007F00

/*

bit

8

-

14

*/

bLanguageMask

OxO000000FF

/*

bit

0

-

7

*/

#define

bScriptLanguageMask

bScriptMask+bLanguageMask

Hilite

typedef

7-98

styles

enum

...

/*

*/

component
event

#define

*/

for

description

#define

/*

*/

for

*/

bit

0

-

14

*/

text

* /

*/

{

kCaretPosition

=

1,

/*

specify

caret

position

kRawText

=

2,

/*

specify

range

of

raw

kSelectedRawText

=

3,

/*

specify

range

of

selected

kConvertedText

=

A,

/*

specify

range

of

converted

Summary of the Text Services Manager

*/
text

*/
raw

text

*/

CHAPTER

7

Text Services Manager

kSelectedConvertedText

=

5

/*

specify

range

converted

}

HiliteStyleType;

/*

Apple

Event

constants

/*

Event

class

...

#define
/*

event

...

...

selected

*/

*/

*/

kTextServiceClass
ID

of

text

kTextService

*/

#define

kUpdateActivelInputArea

‘updt'

/*

update

#define

kPos20ffset

'p2st'!

/*

converting

#define

kOffset2Pos

'st2p'

/*

#define

kShowHideInput Window

'shiw'

/*

to

Event

keywords

...

char

Inline

global

position

coordinates

show

or

hide

input

window

*/

bottomline
*/

*/

#define

keyTSMDocumentRefcon

'refc'

/*

TSM

#define

keyAEServerInstance

'srvi'

/*

component

#define

keyAETheData

'kdat'

/*

typeText

#define

keyAEScriptTag

'sclg'

/*

script

#define

keyAEFixLength

'fixl'

/*

fix

#define

keyAEHiliteRange

'hrng'

/*

hilite

document

#define

keyAEUpdateRange

'udng'

/*

#define

keyAEClauseOffsets

'clau'

/*

#define

keyAECurrentPoint

'cpos'

#define

keyAEDragging

'bool'

#define

keyAEOffset

#define

keyAERegionClass

#define
#define

refcon

*/

instance

*/

*/
tag

*/

??

*/

len

range

array

*/

update

range

array

*/

Clause

Offsets

/*

current

point

*/

/*

dragging

flag

*/

'ofst'

/*

offset

*/

'rgnc'!

/*

region

class

keyAEPoint

'gpos'

/*

current

point

keyAEBufferSize

‘buff!

/*

buffer

size

#define

keyAERequestedType

'rtyp'

/*

requested

#define

keyAEMoveView

'mvvw'

/*

move

#define

keyAELength

'leng'

/*

length

*/

#define

keyAENextBody

'nxbd'

/*

next

previous

/*

optional

#define
/*

keyword

for

UpdateActivelInputArea

keyAEPinRange

optional

*/

*/

char

global

area

coordinates

position

converting
to

/*

active

keywords

view
or

array

*/

*/
*/
to

get

text

text

type

*/

flag

*/
body

*/

*/

*/

'pnrg'
for

Offset2Pos

*/

#define

keyAETextFont

'"ktxf!

#define

keyAETextPointSize

'ktps'

Summary of the Text Services Manager

7-99

CHAPTER

7

Text Services Manager

#define

keyAETextLineHeight

'ktlh'

#define

keyAETextLineAscent

'ktas'

#define

keyAEAngle

'kang'

/*

optional

keywords

for

#define

keyAELeadingEdge

/*

event

Apple

#define

Pos20ffset

descriptor

*/

'klef'!

*/

type

typeComponentInstance

'cmpi'

/*

server

instance

*/

#define

typeTextRange

'txrn'

/*

text

range

record

*/

#define

typeTextRangeArray

‘tray'

/*

text

range

array

*/

#define

typeOffsetArray

'ofay'

/*

offset

array

*/

#define

typeIntlWritingCode

/*

script

code

*/

#define

typeQDPoint

'intl'
'QDpt!

/*

QuickDraw

#define

typeAEText

"Ct TXT!

/*

Apple

#define

typeText

"TEXT!

/*

#define

typeFixed

'fixd'

/*

/*

event

Apple

typedef

enum

kTSMOut

descriptor

type

constants

{

sideOfBody

kTSMInsideOfBody
kTSMInsideOfActivelInputArea

}

AERegionClassType;

typedef

enum

{

kNext Body
kPreviousBody

}
/*

AENextBodyType;
Apple

typedef

Event

enum

error

definitions

*/

{

errOffsetInvalid

-1800,

errOffsetIsOutsideOfView

-1801,

errTopOfDocument

-1810,

errTopOfBody

-1811,

errEndOfDocument

-1812,

errEndOfBody

-1813

} AppleEventErrorType;

7-100

Summary of the Text Services Manager

*/

Point

Event

text

Plain

text

*/

Fixed

number

*/

16.16

*/
*/

CHAPTER

7

Text Services Manager

Data Types
struct

TextRange

{

/*

long

fStart;

long

fEnd;

short

fHiliteStyle;

typeTextRange

'txrn'

*/

bi
typedef

struct

TextRange

TextRange;

typedef

TextRange

*TextRangePtr;

typedef

TextRangePtr

*TextRangeHandle;

struct

/*

typeTextRangeArray

short

TextRangeArray

fNumOfRanges;

{

/*

specify

TextRange

fRange

/*

when

fNumOfRanges

array

has

[1] ;

the

size

to

be

'txra!
of

the

>

1,

*/

fRange
the

calculated

array

size

of

*/

this

*/

bi
typedef

TextRangeArray

TextRangeArray ;

typedef

TextRangeArray

*TextRangeArrayPtr;

typedef

TextRangeArrayPtr

*TextRangeArrayHandle;

struct

struct

OffsetArray

{

/*

typeOffsetArray'offa'

short

fNumofoffsets;

/*

specify

long

fO0ffset[1];

/*

when

fNumoOfOffsets

the

size

this

array

has

to

of

*/
the

>
be

1,

fOffset
the

array

size

*/

of

calculated

*/

bi
typedef

OffsetArray

OffsetArray;

typedef

OffsetArray

*OffsetArrayPtr;

typedef

OffsetArrayPtr

*OffsetArrayHandle;

/*

struct

extract

#define

Script/Language
mGetScriptCode

code

(cdRec)

from

Component

flag

((ScriptCode)

...

*/

(cdRec.componentFlags
bScriptMask)

#define

mGetLanguageCode(cdRec)

( (LangCode)

cdRec.componentFlags

&

>>

8)
&

bLanguageMask)
typedef
/*

text

struct

void

*TSMDocumentID;

service

component

TextServicelInfo

information

list

*/

{

Component

fComponent ;

Str255

fitemName;

hi
typedef
typedef

struct

TextServicelInfo

TextServicelInfo;

TextServicelInfo

*TextServicelInfoPtr;

Summary of the Text Services Manager

7-101

CHAPTER

7

Text Services Manager

/*text

service

struct

TextServiceList

component

short

list*/

{
fTextServiceCount;

TextServicelInfo

fServices

/*

[1];

number

/*

entries

in

'fServices'

of

array

*/

Note:

of

array

records

bi
typedef

TextServiceList;

typedef

TextServiceList

*TextServiceListPtr;

typedef

TextServiceListPtr

*TextServiceListHandle;

struct

and

language

'TextServicelInfo'

follows

TextServiceList

/*script

struct

the

*/

record*/

ScriptLanguageRecord

ScriptCode

fScript;

LangCode

fLlanguage;

{

bi
typedef

struct

/*script

and

struct

ScriptLanguageRecord

language

support

ScriptLanguageSupport

short

ScriptLanguageRecord;

record*/
{

£ScriptLanguageCount;

/*

number

of

entries

in

the

'fScriptLanguageArray'

array
ScriptLanguageRecord

fScriptLanguageArray[1];

/*

*/

Note:

array

of

'ScriptLanguageRecord'

records

bi
typedef

struct

follows

*/

ScriptLanguageSupport

ScriptLanguageSupport ;

typedef

ScriptLanguageSupport

*ScriptLanguageSupportPtr;

typedef

ScriptLanguageSupportPtr

*ScriptLanguageSupportHandle;

Text Services Manager Routines for Client Applications

Initializing and Closing as a TSM-Aware Application
pascal

OSErr

InitTSMAwareApplication

();

pascal

OSErr

CloseTSMAwareApplication

();

Creating and Activating TSM Documents
pascal

OSErr

NewTSMDocument

(short

numOfInterface,

OSType

supportedinterfaceTypes[],

*idocID,

7-102

Summary of the Text Services Manager

long

refCon) ;

TSMDocumentID

CHAPTER

7

Text Services Manager

pascal

OSErr

ActivateTSMDocument
(TSMDocumentID

pascal

OSErr

idocID) ;

DeactivateTSMDocument
(TSMDocumentID

pascal

OSErr

idocID) ;

DeleteTSMDocument
(TSMDocumentID

idocID) ;

Passing Events to Text Service Components
pascal

Boolean

TSMEvent

(EventRecord

*event);

Passing Menu Selections and Cursor Setting
pascal

Boolean

TSMMenuSelect
(long

menuResult) ;

pascal

Boolean

SetTSMCursor

mousePos) ;

(Point

Confirming Active Input in a TSM Document
pascal

OSErr

FixTSMDocument

(TSMDocumentID

idocID) ;

Making Text Services Available to the User
pascal

OSErr

GetServiceList

(short

numOfInterfaceTypes,

OSType

supportediInterfaceTypes[],

TextServiceListHandle
long
pascal

OSErr

*seedValue) ;

OpenTextService
(TSMDocumentID

idocID,

ComponentInstance
pascal

OSErr

*servicelinfo,

Component

aComponent,

*aComponentInstance) ;

CloseTextService
(TSMDocumentID

idocID,

ComponentInstance

aComponentInstance)

Requesting a Floating Input Window
pascal

OSErr

UselInputWindow

(TSMDocumentID

idocID,

Boolean

useWindow) ;

Associating Scripts and Languages With Components
pascal

OSErr

SetDefaultInputMethod
(Component

ts,

ScriptLanguageRecord
pascal

OSErr

*slRecordPtr) ;

GetDefaultInputMethod
(Component

*ts,

ScriptLanguageRecord

Summary of the Text Services Manager

*slRecordPtr) ;

7-103

CHAPTER

7

Text Services Manager

pascal

OSErr

SetTextServiceLanguage
(ScriptLanguageRecord

pascal

OSErr

*slRecordPtr) ;

GetTextServiceLanguage
(ScriptLanguageRecord

*slRecordPtr) ;

Text Services Manager Routines for Components
Sending Apple Events to a Client Application
pascal

OSErr

SendAEFromTSMComponent
(AppleEvent

*theAppleEvent,

AppleEvent

*reply,

AESendPriority
long

AESendMode

sendMode,

sendPriority,

timeOutInTicks,

EventFilterProcPtr

IdleProcPtr

idleProc,

filterProc) ;

Opening Floating Utility Windows
pascal

OSErr

NewServiceWindow
(void

*wStorage,

const

ConstStr255Param
short

theProc,

Boolean
pascal

OSErr
OSErr
short

behind,

ComponentInstance

*window) ;
window) ;
*window) ;

FindServiceWindow
(Point

thePoint,

WindowPtr

Text Service Component Routines

Providing a Text Service
pascal

ComponentResult

InitiateTextService

(ComponentInstance
pascal

ComponentResult
ComponentResult

ts);

DeactivateTextService
(ComponentiInstance

7-104

ts);

ActivateTextService
(ComponentiInstance

pascal

visible,

GetFrontServiceWindow
(WindowPtr

pascal

WindowPtr

CloseServiceWindow
(WindowPtr

pascal

*boundsRect,

Boolean

goAwayFlag,

WindowPtr

Rect

title,

Summary of the Text Services Manager

ts);

*theWindow) ;

ts,

CHAPTER

7

Text Services Manager

pascal

ComponentResult

HidePaletteWindows
(ComponentInstance

pascal

ComponentResult

ts);

TerminateTextService
(ComponentInstance

ts);

Responding to Events and Updating the Cursor and Menu
pascal

ComponentResult

TextServiceEvent
(ComponentInstance
short

pascal

ComponentResult

MenuHandle
ComponentResult

ComponentResult

*event)

ts,

serviceMenu,

short

item) ;

SetTextServiceCursor

(ComponentInstance
pascal

EventRecord

TextServiceMenuSelect
(ComponentInstance

pascal

ts,

numOfEvents,

ts,

Point

mousePos) ;

ts,

MenuHandle

GetTextServiceMenu

(ComponentInstance

*serviceMenu) ;

Confirming Active Input in a TSM Document
pascal

ComponentResult

FixTextService
(ComponentInstance

ts);

Identifying the Supported Scripts and Languages
pascal

ComponentResult

GetScriptLanguageSupport
(ComponentInstance

ts,

ScriptLanguageSupportHandle

*scriptHdl) ;

Assembly-Language Summary
Trap Macros
Trap Macro Names for Text Services Manager Routines
Pascal name

Trap macro name

NewTSMDocument

_NewTSMDocument

DeleteTSMDocument

_DeleteTSMDocument

ActivateTSMDocument

_ActivateTSMDocument

DeactivateTSMDocument

_DeactivateTSMDocument

TSMEvent

_TSMEvent

TSMMenuSelect

_TSMMenuSelect

Summary of the Text Services Manager

7-105

CHAPTER

7

Text Services Manager

Pascal name

Trap macro name

SetTSMCursor

_SetTSMCursor

FixTSMDocument

_FixTSMDocument

GetServiceList

_GetServiceList

OpenTextService

_OpenTextService

CloseTextService

_CloseTextService

SendAEFromTSMComponent

_SendAEFromTSMComponent

SetDefaultInputMethod

_SetDefaultInputMethod

GetDefaultInputMethod

_GetDefaultInputMethod

SetTextServiceLanguage

_SetTextServiceLanguage

GetTextServiceLanguage

_GetTextServiceLanguage

UseInputWindow

_UseInputWindow

NewServiceWindow

_NewServiceWindow

CloseServiceWindow

_CloseServiceWindow

GetFrontServicewindow

_GetFrontServiceWindow

InitTSMAwareApplication

_InitTSMAwareApplication

CloseTSMAwareApplication

_CloseTSMAwareApplication

FindServicewindow

_FindServiceWindow

Trap Macro Names for Text Service Component Routines
Pascal name

Trap macro name

GetScriptLanguageSupport

_GetScriptLanguageSupport

InitiateTextService

_InitiateTextService

TerminateTextService

_TerminateTextService

ActivateTextService

_ActivateTextService

DeactivateTextService

_DeactivateTextService

TextServiceEvent

_TextServiceEvent

Get TextServiceMenu

_GetTextServiceMenu

Text ServiceMenuSelect

_TextServiceMenuSelect

FixTextService

_FixTextService

SetTextServiceCursor

_SetTextServiceCursor

HidePaletteWindows

_HidePaletteWindows

7-106

Summary of the Text Services Manager

CHAPTER

7

Text Services Manager

Result Codes
tsmComponentNokErr

tsmUnsupScriptLanguageErr
tsmInputMethodNot
tsmNotAnAppErr

FoundErr

tsmAlreadyRegisteredErr
tsmNeverRegisteredErr
tsmInvalidDocIDErr
tsmTSMDocBusyErr
tsmDocNotActiveErr
tsmNoOpenTSkErr
tsmCantOpenComponentErr

tsmTextServiceNot

FoundErr

tsmDocumentOpenkErr
tsmUseInputWindowErr
tsmTSHasNoMenukErr
tsmTSNotOpenkErr
tsmComponentAlreadyOpenErr
tsmInputMethodIsOldErr

tsmScriptHasNoIMErr

tsmUnsupportedTypeErr
tsmUnknownErr

2500
2501
2502
2503
2504
2505
2506
2507
2508
2509
2510
2511
2512
2513
2514
2515
2516
2517
2518
2519

Summary of the Text Services Manager

Component result: no error
Speci ed script and language are not supported
Speci ed input method cannot be found
The caller was not an application
The caller is already TSM-initialized
The caller is not TSM-aware
Invalid TSM document ID
Document is still active
Document is not active
There is no open text service component
Can® open the component

No text service component found
There are open documents
An input window is being used
The text service component has no menu
Text service component is not open
Text service component already open for document
The default input method is old-style
Script has no (or old) input method
Unsupported interface type
Any other error

7-107

C

HAPTER 8

Dictionary Manager

Contents
About Dictionaries for Input Methods
8-3
About the Dictionary Manager _— 8-4
The Structure of a Dictionary
8-5
Garbage Data
8-8
Dictionary Manager Limitations
8-10
Using the Dictionary Manager
8-11
Testing for the Presence of the Dictionary Manager _— 8-11
Making a Dictionary
8-11
Creating the File
8-12
Constructing the Dictionary
8-13
Accessing a Dictionary
8-13
Opening and Closing the Dictionary
8-13
Obtaining Information About the Dictionary
8-14
Locating Records in a Dictionary
8-15
Locating Records by Key
8-15
Locating Records by Index _— 8-17
Modifying a Dictionary
8-18
Compacting a Dictionary
8-20
Dictionary Manager Reference
8-20
Data Structures
8-20
Routines
8-20
Making a Dictionary
8-20
Accessing a Dictionary
8-22
Locating Records in a Dictionary
8-26
Modifying a Dictionary
8-30
Compacting a Dictionary
8-33
Summary of the Dictionary Manager
8-34
Pascal Summary
8-34
Constants
8-34
Data Types
8-34
Contents

8-1

CHAPTER

8

Routines
8-35
C Summary
8-36
Constants
8-36
Data Types
8-37
Routines
8-37
Assembly-Language Summary
Trap Macros
8-39
Result Codes
8-39

8-2

Contents

— 8-39

CHAPTER

8

Dictionary Manager

This chapter describes how you can use the Dictionary Manager to create and work with
dictionaries for input methods or other text services. The Dictionary Manager supplies a
uniform and public dictionary format that lets you perform searching, insertion,
and deletion.
Read this chapter if you are developing or enhancing an input method or other text
service component that uses dictionaries.
To use this chapter, you should be familiar with the Macintosh script management
system, the Text Services Manager, and parts of the File Manager. The script management
system is described in the chapter introduction to Text on the MacintoshOin this book.
The Text Services Manager is described in the chapter (Text Services ManagerOin this
book. The organization of the Dictionary Manager is based on B*-trees, used by the File
Manager and the Finder. For more on the B*-trees, see the File Manager chapter of Inside
Macintosh: Files.
This chapter presents a brief introduction to dictionaries and then discusses how you can
make, access, locate records in, and modify them.

About Dictionaries for Input Methods
Input methods for 2-byte script systems use dictionaries, data les with information
essential to the text conversions they perform. An input method uses its dictionary to
convert the raw text entered by the user. For a discussion of raw text, conversion, and

input methods, see the chapter Ofext Services ManagerOin this book.

Input methods commonly rely upon two or more dictionaries to perform conversion
most ef ciently. The main dictionary lists all standard conversion options for any valid
syllabic or phonetic input. A main dictionary may have thousands to tens of thousands of
entries, and is usually

xed in content. The user dictionary, also called an editable

dictionary, is a complementary le in which users can add specialized or custom
information that does not exist in the main dictionary. Because the main dictionaries of
many input methods have only about 80 percent of the needed conversion options, a user
dictionary is extremely valuable to users who customize the input process to improve its
precision.
Users can also set dictionary learning. This allows the input method to incorporate
frequency information as the user works, so that the frequency of combinations in a
particular grammatical context is taken into account in doing conversions. This makes
a user dictionary even more valuable to the individual that has worked with it for
a long time.
In principle, the dictionaries for different input methods of a given writing system should
be very similar. For instance, most Japanese dictionaries contain information relevant to
the conversion of Hiragana to Kanji. Korean dictionaries consist of data necessary for the
conversion of Hangul to Hanja. Chinese dictionaries have entries relevant to the
conversion of radical to Hanzi, Zhuyinfuhao to Hanzi, or Pinyin to Hanzi.

About Dictionaries for Input Methods

8-3

CHAPTER

8

Dictionary Manager

In practice, however, many currently available Chinese, Japanese, and Korean input
methods use their own dictionary formats. Each input method has independently
implemented operations to insert, delete, and search for the entries in its own

dictionaries.

Input methods that use their own dictionary formats can understand only the
dictionaries they create. This may be desirable for main dictionaries, because the features

of a main dictionary can distinguish the quality of one input method from another;
input method developers may be hesitant to share such dictionaries with other vendors.
But for user dictionaries, incompatible formats create serious dif culties for

usersN particularly when a user dictionary contains many entries.

Consider the following situation. A user purchases an input method and uses it for
perhaps a year, making numerous entries in the user dictionary. Then a new and better
input method is introduced, but the new input method cannot understand the

customized user dictionary. Because there is no general dictionary format, the user is
forced to choose between two undesirable alternatives: creating an entirely new user
dictionary by manually keying in thousands of previous entries, or continuing to use the
old input method, forgoing the bene ts of the new one.
This chapter describes a dictionary format that allows user dictionaries to be carried over
from one input method to another, to avoid the dif culty just described. And although
dictionaries are primarily of use to input methods, and are discussed in that context here,
other text services such as thesauri or spelling checkers can also bene t from using
dictionaries with this format.

About the Dictionary Manager
The Dictionary Manager supplies a uniform and public dictionary format and a
set of operations that allows you to manipulate data in a dictionary le. This
standard dictionary format helps to make the insertion, deletion, and searching
operations in a dictionary available for all input methods.
This section describes the format and content of the data in a dictionary le, discusses
the concept of garbage data and how the Dictonary Manager handles it, and
presents some of the limitations you should be aware of before planning to use the
Dictionary Manager.

8-4

About the Dictionary Manager

CHAPTER

8

Dictionary Manager

Dictionary file types and Finder routing
Dictionaries belong in the Extensions folder within the user@ System
Folder. If your dictionary hasa le typeof 'dict', 'dicO', 'dicl',or
'dic2', the Finder automatically routes it to the Extensions folder if the
user drops it on the System Folder. @

The Structure of a Dictionary
A dictionary is a collection of dictionary records. Each dictionary record consists of a key
and some associated data referenced by that key. A key is a Pascal search string with a
maximum length of 129 bytes (including the length byte). The data associated with a key
has a maximum length of 4096 bytes.
The key for a dictionary record is stored separately from its data. The key, an offset to the
data, and the length of the data make up the record@ index entry. The index entry is
stored as a B*-tree structure in the data fork of the dictionary le. The data is stored in
the resource fork of the le; the Dictionary Manager accesses the data with Resource
Manager partial resource routines. When a dictionary lookup is needed, the Dictionary
Manager uses the key to nd the location and size of the data in the resource fork. Then,
it uses a partial resource reading to read the data into memory. (Routines for reading
partial resources are described in the Resource Manager chapter of Inside Macintosh: More
Macintosh Toolbox.) Figure 8-1 shows the general format of a dictionary record.
Note

Always use Dictionary Manager functions to gain access to records in the
resource fork rather than examining them directly with Resource
Manager routines. #
Figure 8-1

General format of a dictionary record

Index entry (in data fork)
Key

Offset]

=

Size

Data (in resource fork)
Less than
or equal to
4096 bytes

Each key-data pair is unique in a dictionary. No two keys in a single dictionary
are identical.

About the Dictionary Manager

8-5

CHAPTER

8

Dictionary Manager

Figure 8-2 shows the format of the data associated with a dictionary key. The
which speci

rst byte,

es the total number of entries in the data, is followed by a series of entries.

Each entry has a maximum length of 256 bytes.
Figure 8-2

Format of data associated with a key

Bytes
1

Total number of entries

4
Less than —
or equal to
4096 bytes

Entry 1

4

4

/

Less than

or equal to
256 bytes

4

Entry n

4

QL

A dictionary entry in the data associated with a key contains raw data plus optional
attributes. Raw data consists of any information related to the key entry. In a general
dictionary it might be an explanation of the key; in a given East Asian dictionary it might
be all the Chinese characters with the pronunciation of the key. A data attribute contains
some information about the raw dataN for example, grammatical or context-sensitive
details, plus an attribute type. The attribute type is an integer constant in the range 128
to 127. The currently de ned attribute types are listed on page 8-27.
Note
Apple reserves all negative attribute types. Positive attribute types are
available for the use of developers of applications and text service
components.

Figure 8-3 shows the format of an entry. If data attributes are present, the
in each data attribute are the attribute size and the attribute type.

8-6

About the Dictionary Manager

rst two bytes

CHAPTER

8

Dictionary Manager

Figure 8-3

Format of an entry in the data associated with a key

Bytes
(—

Length of entry
Length of raw data

(—
Pascal —
string

4

Raw data

|
1
Bytes

/

\_
a

4

Attribute 1

/

Less than —
or equal to
2

96 bytes

Length of attribute
:
Attribute type

me
(Optional) —

4

4
\

/

Attribute n

{

Optional data
“s

4

\

Depending on the script system, the key, raw data, and attributes may differ.
In a record in an English dictionary, a key is any word; raw data is one or more
de nitions of the word; and a data attribute is the type of speech of the keyN for
exampleN verb, noun, adverb, adjective, or a combination of these.

In a record in a Japanese dictionary, a key is a symbol of the phonetic subscript
Hiragana; the associated raw data are the Kanji (ideographic characters); and the data
attributes include the parts of speech or input method speci c attributes such as
homonyms or groupings (clauses) of Kanji.
In a record in a Chinese phonetic dictionary, a key is one of the phonetic symbols of
Bopomofo; raw data is one or more Chinese words with the same pronunciation as the
key; and there may be no associated data attributes.
In a record in a Korean dictionary, a key may be a syllable or word in the Hangul
subscript; associated raw data may be one or more Chinese words with the
pronunciation of the key; and there may be no associated data attributes.

About the Dictionary Manager

8-7

CHAPTER

8

Dictionary Manager

Garbage Data
In an editable dictionary, information is continually being added, deleted, or altered.

Because it is too time-consuming to regenerate the entire dictionary each time a change is
made, unused information called garbage data builds up over time. Garbage data is
created whenever the size of the information associated with a key increases or decreases,
or if the information is deleted. The data is no longer used by the dictionary.
Consider the simple dictionary le in Figure 8-4. It has only two dictionary records; each
record has two entries. There is no garbage data in either record.
Figure 8-4

A simple dictionary with no garbage data

Key 1

Key 2

Ge

Entry 1 of key 1
Entry 2 of key 1

Entry 1 of key 2
Entry 2 of key 2

With the addition of one entry to the rst record, the Dictionary Manager allocates a new
block at the end of the dictionary@ resource fork to hold all the entries in the rst record,
and creates a new index entry that points to the new block. The data the old index entry
points to is no longer accessible and becomes garbage data. See Figure 8-5.

8-8

About the Dictionary Manager

CHAPTER

8

Dictionary Manager

Figure 8-5

Key 1
Key 2

Creating garbage data in a dictionary

)

Entry 1 of key 1
Entry 2 of key 1

a)

|

Entry 1 of key 2
Entry 2 of key 2

Entry 1 of key 1
Entry 2 of key 1
Entry 3 of key 1

As the records in a dictionary le are modi ed, the size of the garbage data continues to
increase. The Dictionary Manager keeps track of the amount of garbage data ina
dictionary; to obtain the current size of garbage data in a dictionary, you can use the
GetDictionaryInformation function (see page 8-24).
At some point, you may want to get rid of the garbage data permanently. The
CompactDictionary function (see page 8-33) instructs the Dictionary Manager to
create a new copy of the dictionary le, containing only valid entries. Once the new
dictionary is constructed, the Dictionary Manager deletes the old one. (If the new
dictionary fails to build properly, the original dictionary is preserved intact.) Note that
CompactDictionary does not actually compress any data; it simply removes unusable
information.

About the Dictionary Manager

8-9

CHAPTER

8

Dictionary Manager

Figure 8-6 illustrates the structure of the simple dictionary built in Figure 8-4 and Figure
8-5 after the compaction process. Note that the order of the records in the resource fork
may be different from what it was before compaction.
Figure 8-6

Deleting garbage data from a dictionary

Key 1

ED)
Key 2

——

Entry 1 of key 2
Entry 2 of key 2

Entry 1 of key 1
Entry 2 of key 1
Entry 3 of key 1

Note
The Dictionary Manager creates new garbage data only if the size of the
associated data is enlarged or reduced or if the associated data is deleted
altogether. If you simply rearrange the order of the entries within a single
record, without changing the size of the associated data, the Dictionary
Manager does not create any garbage data. This feature is especially
useful for input methods that support dictionary learning, in which the
entries require constant rearrangement according to their frequency of
use. @

Dictionary Manager Limitations
Consider these limitations before using the Dictionary Manager:
mw The Dictionary Manager does not perform data compression. Your input method can
compress part of the information before submitting it to the Dictionary ManagerN but
such compression would make your dictionary nontransferable and thus defeat a
major purpose of using the Dictionary Manager.
m The Dictionary Manager utilizes partial resource reading and writing to manipulate
the actual data in a dictionary. Hence, each dictionary may not exceed 16 MB, a
Resource Manager limitation.

8-10

About the Dictionary Manager

CHAPTER

8

Dictionary Manager

m The user cannot edit an active dictionary (one currently being used by an input
method). This also is a Resource Manager limitation.
m If you are developing a sophisticated input method, you may decide not to convert
your main dictionaries into the Dictionary Manager format, because you may not want
to publicize the keys and associated data in your main dictionaries.
m It may not even be practical to convert your main dictionaries. For example, several
input methods contain giganticN and signi cantly compressedN main dictionaries. In
such cases, the conversion and decompression of dictionaries into Dictionary Manager
format might greatly increase the size of your dictionary.
In summary, the Dictionary Manager is best for constructing user dictionaries of
moderate size. Nevertheless, it is possible and in some cases it may be practical to use the
Dictionary Manager for a main dictionary also.

Using the Dictionary Manager
This section tells how to use the Dictionary Manager to create and manipulate
dictionaries. Using Gestalt Manager, Dictionary Manager, and File Manager calls, you can
m determine whether the Dictionary Manager is present and what attributes it has
m make anew dictionary (create a_

le and initialize the dictionary)

m gain access to a dictionary (open it, close it , and get information about it)
m locate records in a dictionary (by key or by index)
m™ modify the contents of a dictionary (insert, replace, or delete information)
m™ compact a dictionary

Testing for the Presence of the Dictionary Manager
Use Gestalt with the gestaltDictionaryMgrAttr environment selector to obtain a

result in the response parameter that identi

es the attributes of the Dictionary Manager.

A result of gestaltDictionaryMgrPresent

is present.

(= 0) means that the Dictionary Manager

For details on the Gestalt function, see the Gestalt Manager chapter in Inside Macintosh:

Operating System Utilities.

Making a Dictionary
You make a new dictionary by
Manager dictionary.

Using the Dictionary Manager

rst creatinga_

le and then initializing it as a Dictionary

8-11

CHAPTER

8

Dictionary Manager

Creating the File
To create a dictionary le, you rst use a File Manager function such as FSpCreate
or HCreate tocreatea_ le. Listing 8-1 is asample routine that createsa_ le fora
user dictionary.
Listing 8-1

Creating a dictionary file

FUNCTION

CreateUserDictionary

(VAR

dictionaryFSSpec:

creator,

fileType:

script:

ScriptCode):

FSSpec;

OSType;
OSErr;

VAR
err:

OSErr;

fileReply:

StandardFileReply;

BEGIN
err

:=

nokrr;

{get

dictionary

name

and

filespec}

StandardPutFile('Create

empty

dictionary

'UserDictionary',
{delete
IF

existing

dictionary

fileReply.sfGood

THEN

dictionaryFSSpec

:=

IF

:=

{create
=

err

:=

IF

err

OKs

it}

BEGIN
THEN

FSpDelete(dictionaryFSSpec) ;

the

err

user

fileReply.sfFile;

fileReply.sfReplacing
err

IF

if

as...',

fileReply) ;

empty

nokrr

dictionary

THEN

file}

BEGIN

FSpCreate(dictionaryFSSpec,
fileType,
<>

nokrr

creator,

script);

THEN

DebugErrStr(err,

'FSpCreate');{handle

error

here}

{handle

error

here}

{assign

error}

END
ELSE

DebugErrStr(err,

'FSpDelete') ;

END
ELSE

err

:=

fnfErr;

CreateUserDictionary

END ;

8-12

:=

err;

{CreateUserDictionary}

Using the Dictionary Manager

CHAPTER

8

Dictionary Manager

Constructing the Dictionary
To make the internal structure of your newly created dictionary le, you use the
InitializeDictionary function. You providea lesystem speci cation pointer to
the le you just created, you specify what maximum size the dictionary keys can have,
and you can specify what search criteriaN such as case-sensitivityN the dictionary
will support.
The following code is a statement that initializes a dictionary le. It uses an
application-de ned constant (kMaximumKeyLength) to specify key length, an
application-de ned global (gDictionaryScriptID) to specify the script system for the
dictionary, and the kIsCaseSensitive constant to specify that searches are to be
case-sensitive.
err

:=

InitializeDictionary(dictionaryFile,
$1000

+

kMaximumKeyLength,

kIsCaseSensitive,

gDictionaryScriptID) ;

Accessing a Dictionary
Before you can use a dictionary you must rst open it. Once it is open, you can get
information about it and you can use it. When you are nished with the dictionary, you
must close it.

Opening and Closing the Dictionary
To open and use a dictionary, you must create an access path to the dictionary le using
the OpenDictionary function. You provide a pointer to the le system speci cation
record that de nes the le, and you specify the read and write permission for the
access path.
The OpenDictionary function returns a long integer, called a dictionary reference number,
that speci es the open dictionary. You use that same dictionary reference number
whenever you use the dictionary, and nally when you close the dictionary with the
CloseDictionary function.

Listing 8-2 gives an example of how to create and close this access path. It consists of
portions of the CASE statement from a sample application@ menu-dispatching routine.
Listing 8-2

{if

Opening and closing a dictionary file

user

selects

“Open

dictionary”

menu

item: }

iOpenDictionary:
IF

gDictionaryReference

{only

open

fileTypes[0]

Using the Dictionary Manager

my

own
:=

=

0

THEN

dictionary

BEGIN

file

types}

kMyDictionaryFileType;

8-13

CHAPTER

8

Dictionary Manager

StandardGetFile(NIL,
IF

fileReply.sfGood

1,

fileTypes,

THEN

gDictionaryFile

:=

{open

read-write

err

file
:=

with

fileReply) ;

BEGIN

fileReply.sfFile;

OpenDictionary

permission}

(@gDictionaryFile,
fsRdwrPern,

gDictionaryReference) ;
END;
END;

{if

user

selects

“Close

dictionary”

menu

item: }

iCloseDictionary:
IF

gDictionaryReference
err

:=

<>

CloseDictionary

gDictionaryReference

0

THEN

BEGIN

(gDictionaryReference)
:=

;

0;

END;

Obtaining Information About the Dictionary
You can use the Get DictionaryInformation
function to obtain the following
information about a dictionary _ le:
its

lesystem speci cation record

m the number of records it contains
m the current size in bytes of its unused (garbage) data
m the script code of the script system it belongs to
m its maximum key length
m its search criteria
To identify the desired dictionary le, you use the dictionary reference number obtained
when you open a dictionary le with the OpenDictionary function.
The GetDictionaryInformat
ion function returns its information in a dictionary

information record. The dictionary information record is de ned by the
DictionaryInformation
data type as follows:
TYPE

DictionaryInformation

=

RECORD
dictionaryFSSpec:

FSSpec;

numberOfRecords:

LongInt ;

currentGarbageSize:

LongInt;

script:

ScriptCode;

maximumKeyLength:

Integer;

keyAttributes:

UnsignedByte;

END;

8-14

Using the Dictionary Manager

{ file system spec}
{ total no. of records}
{ size of unusable data}
{ script system}
{ maximum length of keys}
{ key search criteria}

CHAPTER

8

Dictionary Manager

See page 8-25 for a complete description of these elds. Listing 8-3 shows a call to
GetDictionaryInformation to obtain the number of records in a dictionary.
Listing 8-3

Obtaining information about a dictionary

FUNCTION

GetNumberOfRecordsInDictionary

(dictionaryReference:
LONGINT) :

INTEGER;

VAR
err:

OSErr;

dictionarylInfo:

DictionaryInformation;

numRecords:

Integer;

BEGIN

numRecords
IF

:=

-1;

{return

dictionaryReference

<>

{get

the

information

err

:=

dictionary

0

THEN

result

in

case

of

error}

BEGIN

GetDictionaryInformation

record}
(gDictionaryReference,
dictionarylInfo) ;

IF

err

<>

noErr

numRecords

THEN
:=

dictionaryInfo.numberOfRecords

ELSE

DebugErrStr(err,

'GetDictionaryInformation') ;

{error}

END ;

GetNumberOfRecordsInDictionary

END;

:=

numRecords;

{GetNumberOfRecordsInDictionary}

Locating Records in a Dictionary
This section tells you how to use a dictionaryN that is, how to extract records from it. You

can obtain records from a dictionary in two general ways: by key (search string) and by
index (position in the

le).

Locating Records by Key
You can use the FindRecordInDictionary
function to search for dictionary records
that match speci ed keys. Matching keys is perhaps the most standard dictionary search
method: the user types in a key, and you search the dictionary for the data associated
with that key.
You can provide a requested attributes table to narrow the search to only certain types of
entries within the record that matches the search key. Figure 8-7 shows its format. You
can request

m only the entries with the speci

ed attributes

m the raw data of all the entries in the record without any attributes
m everything in the record
Using the Dictionary Manager

8-15

CHAPTER

8

Dictionary Manager

Figure 8-7

The requested attributes table

Bytes

Number of attribute types
Attribute type 1 (signed byte)

Attribute type n (signed byte)

For example, you can use the requested attributes table to select only the verbs or nouns
in the dictionary that match a key. The currently de ned attribute types and their
constants are listed in Table 8-2 on page 8-27.
Here is an example of how to use FindRecordInDictionary. Suppose the following
entries are all the entries that match the key GQhunchOin a dictionary record:
Raw data

Attribute type

'guess'

kNoun

1

kVerb

2

kVerb

2

'push'
'bend'

Value

Optional attribute data

kMyTypel

127

MyTypelData

kMyType2

126

MyType2Data

Now suppose you call FindRecordInDictionary and pass a pointer to a requested
attributes table that speci es two types: kNoun ( 1) and kMyTypel (127).
FindRecordInDictionary returns the data shown in Table 8-1.

Table 8-1

Sample data returned by FindRecordInDictionary

Offset

Value

Explanation

00

2

Number of entries found

(first entry starts here)

01

8

Length of entry

02

5

Length of raw data

03

08
09

‘guess!

1

The raw data

Length of
1

rst attribute

Attribute type (= kNoun)

(second entry starts here)

10

8-16

18

Using the Dictionary Manager

Length of entry

CHAPTER

8

Dictionary Manager

Table 8-1

Sample data returned by FindRecordInDictionary

Offset

Value

Explanation

11

4

Length of raw data

12

‘push!

The raw data

16

12

Length of

17

127

Attribute type (= kMyTypel1)

18

'MyTypelData'

Optional
data for

(continued)

rst attribute
rst attribute

Locating Records by Index
You can use the FindRecordByIndexInDictionary function to retrieve record data

within a dictionary le by index rather than by matching key strings. In this way you can
examine a speci c record or sequence of records, to look for the information you need.
As with FindRecordInDictionary,
you can provide a requested attributes table to
narrow the search to certain types of entries. If you want to get all records with entries of
a particular attribute type, you can call FindRecordByIndexInDictionary
repeatedly. In Listing 8-4, the routine loops through the entire dictionary, displaying the
key and the raw data of the rst entry of each record in turn. (The application routine
Get IndexedDataStringFromRecord
converts the raw data from each record into

a string for display.)
Listing 8-4
PROCEDURE

Displaying all records in a dictionary by index
ShowAllEntries

(dictionaryReference:

LONGINT) ;

VAR
err:

OSErr;

dictionarylInfo:

DictionaryInformation;

index:

Integer;

keyString,

descriptionStr:

Str255;

entriesHandle:

Handle;

txtDialog:

DialogPtr;

finalTick:

LongInt ;

BEGIN

IF

dictionaryReference

<>

{first

find

many

err

GetDictionaryInformation

:=

out

how

0

THEN

BEGIN

records

there

are}

(gDictionaryReference,
dictionarylInfo) ;

IF

err

=

noErr

entriesHandle
IF

THEN

:=

entriesHandle

descriptionsStr

Using the Dictionary Manager

BEGIN

NewHandle
(0) ;
<>

NIL

:=

THEN

BEGIN

'Displaying

names

in

dictionary';

8-17

CHAPTER

8

Dictionary Manager

txtDialog

:=

ShowTextDialog(@descriptionstr
[1],

LENGTH
Delay(60,

finalTick) ;

FOR

:=

DO

index

1

TO

(descriptionStr)
);

dictionaryInfo.numberOfRecords

BEGIN

{return
err

:=

raw

data

for

all

entries

of

each

record}

FindRecordByIndexInDictionary
(dictionaryReference,
index

-

1,

keyString,

{we

only

care

about

the

first

NIL,
entriesHandle) ;

description

string

Get IndexedDataStringFromRecord(entriesHandle,

}

1,

descriptionStr) ;

{format

as

"key:

description" }

keyString

:=

CONCAT(keyString,

':

keyString

:=

CONCAT(keyString,

descriptionsStr) ;

SetTextDialog(txtDialog,
LENGTH
Delay(60,

');

@keyString[1],

(keyString)

) ;

finalTick) ;

END;

CloseTextDialog(txtDialog) ;

DisposeHandle

(entriesHandle)

;

END;
END;
END;

END;

{ShowAllEntries}

Modifying a Dictionary
This section tells you how to use the Dictionary Manager routines to add, replace, or
delete dictionary records.
You can use the InsertRecordToDictionary
function to add or replace a record in a
speci ed dictionary. Because there cannot be two separate records with the same key
value in a dictionary, adding a new record may nullify an existing one. To avoid such a
problem, you can specify the insertion mode, which noti es the Dictionary Manager
how you want the new record treated. The insertion mode determines whether to put the
record into the dictionary
m only if it does not replace an existing record with the same key
m only if it does replace an existing record with the same key
m regardless of whether it adds a record or replaces another record

8-18

Using the Dictionary Manager

CHAPTER

8

Dictionary Manager

You can effectively insert and replace individual entries in records, in that you can obtain
a record from a dictionary (with FindRecordInDictionaryor

FindRecordByIndexInDictionary),
modify parts of the record, and then put the
record back into the dictionary with InsertRecordToDictionary.
In Listing 8-5, the routine prompts the user for a key word and data for a new dictionary
record. It then constructs the new recordN in proper dictionary formatN by calling the
application routine NewDictionaryEntry.
Finally, it calls
InsertRecordToDictionary, providing a dictionary reference number to the desired
dictionary le, a Pascal string representing the key, a handle to the new record, and a
speci cation of how to insert the record into the dictionary.
Listing 8-5

Inserting a record into a dictionary

PROCEDURE

AddNewRecord

(dictionaryReference:

LonglInt) ;

VAR

keyStr,

descriptionStr:

Str255;

descriptionHandle:

Handle;

err:

OSErr;

BEGIN

IF

dictionaryReference

<>

keyStr

key:',

IF

:=

Ask('Enter

keyStr

<>

'!'

THEN

descriptionStr

:=

0

THEN

BEGIN

'<key

BEGIN

Ask (CONCAT

(CONCAT

('Enter

description

keyStr),
IF

descriptionStr

word>') ;

'"'),

for

'<record

<>

''

THEN

descriptionHandle

:=

NewDictionaryEntry

BEGIN
(descriptionStr,

IF

descriptionHandle

err

:=

<>

"',
data>');

NIL

THEN

128,

'');

BEGIN

InsertRecordToDictionary
(dictionaryReference,
keyStr,

descriptionHandle,

kInsertOrReplace) ;
IF

err

<>

nokrr

THEN

DebugErrStr(err,
DisposeHandle

'InsertRecordToDictionary') ;

(descriptionHandl1le)

;

END ;
END ;
END ;
END ;

END;

{AddNewRecord}

Using the Dictionary Manager

8-19

CHAPTER

8

Dictionary Manager

To remove a record from a dictionary, call the DeleteRecordFromDictionary
function. When you call DeleteRecordFromDictionary you speci y the key of the
record to be deleted and the dictionary reference number of the dictionary le that
contains the record.
Remember that deleting records from a dictionary, or replacing them with shorter
records, does not make the dictionary le any smaller. It simply creates garbage data.

Compacting a Dictionary
You can use the CompactDictionary function to reduce the size of the dictionary by
removing garbage data from the dictionary le.
IMPORTANT

Before compacting a dictionary, be aware that the operation may require
considerable time to complete. You should notify the user of this. Avoid
the compaction operation unless it is absolutely necessary or is
mandated by the user. &

Dictionary Manager Reference
This section describes the routines and related data structures and constants that are

speci

c to the Dictionary Manager.

Data Structures
The DictionaryInformation data type, which de nes the dictionary information
record, is described with the GetDictionaryInformation function on page 8-24.

Routines
This section shows the functions for making, accessing, using, and
modifying dictionaries.

Making a Dictionary
To make a dictionary

le,

rstcreatea

le witha File Manager function such as

FSpCreate or HCreate, and then call the InitializeDictionary function described

in this section.

8-20

Dictionary Manager Reference

CHAPTER

8

Dictionary Manager

Initialize Dictionary
The InitializeDictionary function constructs, for the speci

B*-tree structure that makes it a dictionary
FUNCTION

InitializeDictionary

le.

(theFSSpecPtr:

keyAttributes:

theFSSpecPtr

A pointer toa

lesystem speci

le, the internal

FSSpecPtr;

maximumKeyLength:
script:

ed_

Integer;

Byte;

ScriptCode):

OSErr;

cation record. This record contains the

lename, directory, and volume associated with this dictionary _ le.

maximumKeyLength

The maximum length of the keys in the dictionary, including the length

byte. The length must be less than or equal to 129.
keyAttributes

The search criteria for the keys in the dictionary.

script

The number that speci

es the script system this dictionary supports.

DESCRIPTION

InitializeDictionary does not open the dictionary
initializes it. To open and use a dictionary
page 8-22).

le after the Dictionary Manager

le, use the OpenDictionary function (see

You can set the maximum key length of a dictionary only once; you cannot change
it after the dictionary has been created. ‘To maximize ef ciency, keep the length to
a minimum.
The keyAttributes parameter allows you to specify search criteria. For example, in
one script system, it might be desirable to design the search to disregard case and be
sensitive to diacritical marks, whereas in another script system these preferences might
be reversed in keeping with the character encoding. Two prede ned constants are
available for the key attributes: the kIsCaseSensitive constant indicates that search
procedures are to be case sensitive, and the kIsNotDiacriticalSensitive constant

speci es that the search procedures are to ignore diacritical marks. To specify a
combination of the different attributes, you add the constants together.
Constant

Value

Explanation

kIsCaseSensitive

16

Search is case-sensitive

kIsNotDiacriticalSensitive

32

Search is not diacritical-sensitive

SPECIAL CONSIDERATIONS

InitializeDictionary may move memory; your application should not call this
function at interrupt time.

Dictionary Manager Reference

8-21

CHAPTER

8

Dictionary Manager

RESULT CODES
In addition to the standard File Manager, Memory Manager, and Resource Manager error
codes, InitializeDictionary may return any of the following result codes.
noErr
btNoSpace
keyLenErr
keyAttrErr

0
413
416
417

No error
Insuf cient disk space to store dictionary information
Maximum key length too great or equal to zero
~~ Nosuch key attribute

SEE ALSO
Constants for all de ned script codes are listed in the chapter Script ManagerOin
this book.
File system speci cation records and File Manager error codes are described in Inside
Macintosh: Files. Memory Manager error codes are described in Inside Macintosh: Memory.
Resource Manager error codes are described in Inside Macintosh: More Macintosh Toolbox.

Accessing a Dictionary
Once you have created and initialized a dictionary

le, you can use the

OpenDictionary and CloseDictionary functions to open and close the dictionary.

Once the dictionary is open, you can get information about it with the
GetDictionaryInformation function.

OpenDictionary
The OpenDictionary function creates an access path to the speci
FUNCTION

OpenDictionary

(theFSSpecPtr:

le.

FSSpecPtr;

accessPermission:

VAR

ed dictionary

SignedByte;

dictionaryReference:

LongInt)

OSErr;

theFSSpecPtr

A pointer to the

le system speci

record contains the

dictionary

le.

cation record for the

le to open. This

lename, directory, and volume associated with this

accessPermission

The read and write permission for the access path. This permission must
follow the File Manager access permission conventions.

dictionaryReference

A number that speci

8-22

Dictionary Manager Reference

es a particular open dictionary.

CHAPTER

8

Dictionary Manager

DESCRIPTION

The OpenDictionary function returns, in the dictionaryReference parameter, a

dictionary reference numberN an identifying value that you use to specify the dictionary
in subsequent calls to the Dictionary Manager.
The data structures accessed through the dict ionaryReference parameter are
allocated in the current heap. If the same dictionary is to be shared across applications,
make sure the current zone is the system zone, so the data structures will be allocated in

the system heap.

The following constants de ne the allowed values for the accessPermission
parameter:
Constant

Value

Explanation

fsRdPerm

1

Request read permission only

fsWrPerm

2

Request write permission only

fsRdWrPerm

3.

Request exclusive read/write permission

If the requested permission is not granted, OpenDictionary returns a result code that
speci es the type of error.

SPECIAL CONSIDERATIONS

OpenDictionary may move memory; your application should not call this function at
interrupt time.

RESULT CODES

In addition to the standard File Manager, Memory Manager, and Resource Manager
errors, OpenDictionary may return any of the following result codes.
noErr
notBTree

0
410

No error
File is not a dictionary

SEE ALSO

File system speci cation records, File Manager access permissions, and File Manager
error codes are described in Inside Macintosh: Files. Memory Manager error codes are
described in Inside Macintosh: Memory. Resource Manager error codes are described in
Inside Macintosh: More Macintosh Toolbox.
For sample code that uses the OpenDictionary function, see Listing 8-2 on page 8-13.

Dictionary Manager Reference

8-23

CHAPTER

8

Dictionary Manager

CloseDictionary
The CloseDictionary function closes the speci
FUNCTION

CloseDictionary

ed open dictionary.

(dictionaryReference:

LongInt)

OSErr;

dictionaryReference

A number that speci

es a particular open dictionary.

RESULT CODES

In addition to the standard File Manager and Resource Manager errors,
CloseDictionary may return any of the following result codes.
noErr
notBTree

0
410

No error
File is not a dictionary

SEE ALSO

File Manager error codes are described in Inside Macintosh: Files. Resource Manager error

codes are described in Inside Macintosh: More Macintosh Toolbox.

For sample code that uses the CloseDictionary function, see Listing 8-2 on page 8-13.

GetDictionaryInformation
The GetDictionaryInformation function returns, in a dictionary information record,

information about the speci
FUNCTION

ed dictionary.

GetDictionaryInformation
(dictionaryReference:

VAR

LongInt;

theDictionaryInformation:

DictionaryInformation):
dictionaryReference

A number that speci

OSErr;

es a particular open dictionary.

theDictionaryInformation

Upon completion of the call, contains a_lled-out dictionary information
record that describes the dictionary.

DESCRIPTION

The GetDictionaryInformat ion function returns data about a dictionary ina
dictionary information record in the dictionaryInformation parameter. The

DictionaryInformation data type de nes this record as follows:

8-24

Dictionary Manager Reference

CHAPTER

8

Dictionary Manager

TYPE

DictionaryInformation

=

RECORD

dictionaryFSSpec:

FSSpec;

numberOfRecords:

LongInt ;

currentGarbageSize:

LongInt;

script:

ScriptCode;

maximumKeyLength:

Integer;

keyAttributes:

UnsignedByte;

END;

Field descriptions
dictionaryFSSpec

numberOfRecords

The

lesystem speci

cation record for this particular dictionary.

The number of records in the dictionary.

currentGarbageSize

The current size of unusable (garbage) information in the
dictionary. For a discussion of garbage in a dictionary, see GGarbage
DataOon page 8-8.
The number that speci es the script system this dictionary supports.

script
maximumKeyLength

The maximum

keyAttributes

length of any key in the dictionary.

Avalue that speci es the criteria for key searching. For a description
of the key attribute constants, see the description of the

InitializeDictionary function on page 8-21.

SPECIAL CONSIDERATIONS

GetDictionaryInformation may move memory; your application should not call
this function at interrupt time.

RESULT CODES

In addition to the standard File Manager and Resource Manager errors,
GetDictionaryInformation may return any of the following result codes.
noErr
notBTree

0
410

No error
File is not a dictionary

SEE ALSO

Constants for all de ned script codes are listed in the chapter Script ManagerOin
this book.
File Manager error codes are described in Inside Macintosh: Files. Resource Manager error

codes are described in Inside Macintosh: More Macintosh Toolbox.

Dictionary Manager Reference

8-25

CHAPTER

8

Dictionary Manager

For sample code that uses the GetDictionaryInformation function, see Listing 8-3

on page 8-15.

Locating Records in a Dictionary
The following section describes the Dictionary Manager functions that let you
m locate a record within a dictionary by its key
m locate a record within a dictionary by its index
You can constrain both key and index searches to include only entries with certain
attributes.

FindRecordInDictionary
The FindRecordInDictionary function searches a dictionary for a record that
matches the speci ed key, and returns entries with the speci ed attributes.
FUNCTION

FindRecordInDictionary

(dictionaryReference:
key:

LongInt;

Str255;

requestedAttributeTablePointer:
recordDataHandle:
dictionaryReference

A number that speci

key

Handle):

Ptr;

OSErr;

es a particular open dictionary.

A Pascal string that denotes the key to be matched.

requestedAttributeTablePointer

A pointer to a table with attributes that you can request. This parameter
provides a way for you to narrow the search to speci ed types of entries in
the record. For instance, you could use the requested attributes table to
specify only the verbs in the record that matches the key.

recordDataHandle

On entry, any valid handle. Upon completion, a handle to the
requested data.

DESCRIPTION

The FindRecordInDictionary

function returns, in the recordDataHandle

parameter, a handle to the record data: a collection of entries matching the key
and the requested attributes. FindRecordInDictionary returns the data in
standard Dictionary Manager data formatN as shown in Figure 8-2 on page 8-6 and
Figure 8-3 on page 8-7.

8-26

Dictionary Manager Reference

CHAPTER

8

Dictionary Manager

The Dictionary Manager uses the Memory Manager procedure SetHandleSize to set
the size of the recordDataHandle parameter correctly. If the Dictionary Manager
cannot change the size of the handle to accommodate the returned matched data, it
returns a Memory Manager error.
To limit the search to speci c types of attributes, you construct a requested attributes
table and pass a pointer to that table to FindRecordInDictionary. The requested
attributes table consists of a byte which speci es the number of attributes, followed by a
list of attribute types, as shown in Figure 8-7 on page 8-16.
m

Ifthe requestedAttributeTablePointer parameter is Ptr(-1),

m

Ifthe requestedAttributeTablePointer parameter is NIL,

FindRecordInDictionary returns everything in the matching record (that is, both
raw data and attributes for all entries in the record).
FindRecordInDictionary returns the raw data of all the entries in the matching
record, without any attached attributes.

m Ifthe requestedAttributeTablePointer parameter is a valid pointer,
FindRecordInDictionary returns only those entries in the matching record whose
attributes match those in the requested attributes table. In this case, if a record in the
dictionary has a key that matches the search key but no entries in the record possess
the requested attributes, the returned recordDataHand1le parameter references a

data buffer one byte in length that contains a value of 0.

Table 8-2 lists constants for the currently de ned attribute types.
Table 8-2
Constant

Defined attribute types for dictionary entries
Value

Explanation

kNoun

1

Noun

kVerb

2

Verb

kAdjective

3

Adjective

kAdverb

4

Adverb

SPECIAL CONSIDERATIONS

FindRecordInDictionary may move memory; your application should not call this
function at interrupt time.

RESULT CODES

In addition to the standard File Manager, Memory Manager, and Resource Manager
errors, FindRecordInDictionary can return any of the following result codes.
noErr
notBTree
btRecNotFnd
btKeyLenErr

0
410
415
416

No error
File is not a dictionary
Record cannot be found
__ Key length too great or equal to zero

Dictionary Manager Reference

8-27

CHAPTER

8

Dictionary Manager

SEE ALSO

File Manager error codes are described in Inside Macintosh: Files. Memory Manager error
codes are described in Inside Macintosh: Memory. Resource Manager error codes are

described in Inside Macintosh: More Macintosh Toolbox.

FindRecordByIndexInDictionary
The FindRecordByIndexInDictionary function locates a record in a dictionary by
index, and returns entries with the speci ed attributes.
FUNCTION

FindRecordByIndexInDictionary
(dictionaryReference:
recordindex:

LongInt;

LongInt;

requestedAttributeTablePointer:
VAR

recordKey:

Str255;

recordDataHandle:
dictionaryReference

A number that speci

recordiIndex

Ptr;

Handle):

OSErr;

es a particular open dictionary.

The index for the record to be searched; its position in the dictionary. The
index range for FindRecordByIndexInDictionary is from 0 to one
less than the maximum number of records in a dictionary. To obtain the
maximum index range of a dictionary, you can use the
GetDictionaryInformation function (see page 8-24).

requestedAttributeTablePointer

A pointer to a table with attributes that you can request. This parameter
provides a way for you to narrow the search to speci ed types of entries in
the record. For instance, you could use the requested attributes table to
specify only the verbs in the record at that index.

recordKey

Upon succcessful completion, contains the key of the indexed record.

recordDataHandle

A handle that contains a collection of entries in the indexed record that

match the requested attributes.

DESCRIPTION

The FindRecordByIndexInDictionary function returns, in the recordDataHandle

parameter, a handle to the record data: a collection of entries from the speci ed record
matching the requested attributes. FindRecordByIndexInDictionary returns the
data in standard Dictionary Manager data formatN as shown in Figure 8-2 on page 8-6
and Figure 8-3 on page 8-7.

8-28

Dictionary Manager Reference

CHAPTER

8

Dictionary Manager

The Dictionary Manager uses the Memory Manager procedure SetHandleSize to set
the size of the recordDataHandle parameter correctly. If the Dictionary Manager
cannot change the size of the handle to accommodate the returned matched data, it
returns a Memory Manager error.
To limit the search to speci c types of attributes, you construct a requested attributes
table and pass a pointer to that table to FindRecordByIndexInDictionary. The
requested attributes table and a list of de ned attribute types are described with the
FindRecordiInDictionary function, on page 8-26.
m

Ifthe requestedAttributeTablePointer parameter is Ptr(-1),

FindRecordByIndexInDictionary returns everything in the matching record
(that is, both raw data and attributes for all entries in the record).

m Ifthe requestedAttributeTablePointer parameter is NIL,

FindRecordByIndexInDictionary returns the raw data of all the entries in the

matching record, without any attached attributes.

m Ifthe requestedAttributeTablePointer parameter is a valid pointer,
FindRecordByIndexInDictionary returns only those entries in the matching
record whose attributes match those in the requested attributes table. In this case, if a
record in the dictionary has a key that matches the search key but no entries in the
record possess the requested attributes, the returned recordDataHandle parameter
references a data buffer 1 byte in length that contains a value of 0.
SPECIAL CONSIDERATIONS

FindRecordByIndexInDictionary may move memory; your application should not
call this function at interrupt time.

RESULT CODES

In addition to the standard File Manager, Memory Manager, and Resource Manager
errors, FindRecordByIndexInDictionary

may return any of the following

result codes.
noErr

notBTree

btRecNotFnd

0

410
415

No error

File is not a dictionary

Record cannot be found

SEE ALSO

File Manager error codes are described in Inside Macintosh: Files. Memory Manager error
codes are described in Inside Macintosh: Memory. Resource Manager error codes are

described in Inside Macintosh: More Macintosh Toolbox.

For sample code that uses the FindRecordByIndexInDictionary function, see
Listing 8-4 on page 8-17.

Dictionary Manager Reference

8-29

CHAPTER

8

Dictionary Manager

Modifying a Dictionary
The routines described in this section allow you to modify the contents of a dictionary by
adding, replacing, or deleting records.

InsertRecordToDictionary
The InsertRecordToDictionary function inserts a dictionary record into the
speci ed dictionary le.
FUNCTION

InsertRecordToDictionary
(dictionaryReference:
key:

recordDataHandle:
whichMode:
dictionaryReference

A number that speci

key

LongInt;

Str255;
Handle;

InsertMode):

OSErr;

es a particular open dictionary.

A Pascal string that denotes the key of the record to be inserted.

recordDataHandle

A handle containing the data for the new record.

whichMode

A value that determines whether the inserted record is to replace a record
in the dictionary whose key matches the key parameter.

DESCRIPTION

The InsertRecordToDictionary function places the speci ed record into the
speci ed dictionary. The recordDataHandle parameter must be a handle to data
formatted like the data of a dictionary record, as shown in Figure 8-2 on page 8-6. Each
entry in the data must be formatted as shown in Figure 8-3 on page 8-7. If the data size
referenced by the recordDataHandle parameter exceeds the maximum of 4096 bytes,
InsertRecordToDictionary returns a recordDataTooBigErr result code.

8-30

Dictionary Manager Reference

CHAPTER

8

Dictionary Manager

The whichMode parameter controls the insertion mode, the manner in which the
insertion can take place. There are three possibilities, for which the Dictionary Manager
de nes three constants:
Constant

Value

kInsert

0

Description

Insert the record only if no existing record has a
matching key. If a record with a matching key already
exists in the dictionary, this function returns the result
code btDupRecErr.

kReplace

1

Insert the record only if it replaces an existing record
with a matching key. If no existing record in the
dictionary has a matching key, this function returns
the result code bt RecNot Fnd.

kInsertOrReplace

2

Insert the new record either way. Add it if no existing

record in the dictionary has a matching key; replace
the existing record if there is a match.

If IngsertRecordToDictionary returns one of the errors listed in CResult Codes,Othe

speci

ed record was not inserted or replaced.

SPECIAL CONSIDERATIONS

InsertRecordToDictionary may move memory; your application should not call
this function at interrupt time.

RESULT CODES

In addition to the standard File Manager, Memory Manager, and Resource Manager
errors, InsertRecordToDictionary can return one of the following result codes.
noErr
notBTree
btNoSpace
btDupRecErr
btRecNotFnd
btKeyLenErr
unknownInsertModeErr
recordDataTooBigErr

0
410
413
414
415
416
20000
20001

No error
File is not a dictionary
Insuf cient disk space to store dictionary
_— Record already exists
Record cannot be found
_ Key length too great or equal to zero
No such insertion mode
Entry data bigger than buffer size

SEE ALSO

File Manager error codes are described in Inside Macintosh: Files. Memory Manager error
codes are described in Inside Macintosh: Memory. Resource Manager error codes are

described in Inside Macintosh: More Macintosh Toolbox.

For sample code that uses the
on page 8-19.

Dictionary Manager Reference

Insert RecordToDictionary function, see Listing 8-5

8-31

CHAPTER

8

Dictionary Manager

DeleteRecordFromDictionary
The DeleteRecordFromDictionary function removes a record from the speci
dictionary le.
FUNCTION

ed

DeleteRecordFromDictionary
(dictionaryReference:
key:

dictionaryReference

A number that speci

key

Str255):

LongInt;

OSErr;

es a particular open dictionary.

A Pascal string that denotes the key of the record to be deleted.

DESCRIPTION

If DeleteRecordFromDictionary returns any of the errors listed in Result Codes,Oit
did not remove any records from the speci ed dictionary.

SPECIAL CONSIDERATIONS

DeleteRecordFromDictionary may move memory; your application should not call
this function at interrupt time.

RESULT CODES

In addition to the standard File Manager, Memory Manager, and Resource Manager
errors, DeleteRecordFromDictionary may return any of the following result codes.
noErr
notBTree
btRecNot Fnd
btKeyLenErr

0
410
415
416

No error
File is not a dictionary
Record cannot be found
_ Key length too great or equal to zero

SEE ALSO

File Manager error codes are described in Inside Macintosh: Files. Memory Manager error
codes are described in Inside Macintosh: Memory. Resource Manager error codes are

described in Inside Macintosh: More Macintosh Toolbox.

8-32

Dictionary Manager Reference

CHAPTER

8

Dictionary Manager

Compacting a Dictionary
The routine described in this section allows you to compact a dictionary _ le.

CompactDictionary
The CompactDictionary function compacts the speci
all garbage data from it.
FUNCTION

CompactDictionary

ed dictionary

le by removing

(dictionaryReference:LongInt )
OSErr;

dictionaryReference

Anumber that speci

es a particular open dictionary.

DESCRIPTION

The CompactDictionary function removes garbage data by creating a new copy of the
dictionary le that contains only valid entries. Once the new dictionary is constructed,
the Dictionary Manager deletes the old one.
If there is insuf

cient disk space to build the new dictonary, CompactDictionary

returns the btNoSpace error message, and the original dictionary is preserved intact.
Note that CompactDictionary makes a dictionary
information. It does not actually compress any data.

le smaller by removing unusable

SPECIAL CONSIDERATIONS

CompactDictionary may move memory; your application should not call this function
at interrupt time.

RESULT CODES

In addition to the standard File Manager, Memory Manager, and Resource Manager
errors, CompactDictionary may return any of the following result codes.
noErr
notBTree
btNoSpace

0
410
413

No error
File not a dictionary
_— Insuf cient disk space to store dictionary information

SEE ALSO

File Manager error codes are described in Inside Macintosh: Files. Memory Manager error
codes are described in Inside Macintosh: Memory. Resource Manager error codes are

described in Inside Macintosh: More Macintosh Toolbox.

Dictionary Manager Reference

8-33

CHAPTER

8

Dictionary Manager

Summary of the Dictionary Manager
Pascal Summary
Constants
CONST

{Data

Insertion

kInsert

Modes}
=

0;

{only

insert

input

=

1;

kInsertOrReplace

=

2;

{insert

if

kReplace

entry

if

{
{ entries exist,
{ input entry}
matches

CONST

{Key

Attribute

=

kIsNotDiacriticalSensitive

CONST {Registered
kNoun
=
kVerb
=
kAdjective
=
kAdverb
=

AttributeType

in

with

the

dictionary

already

matched

replace

them

}
}

}

with

the

}

{diacritical

mark

is

case

sensitive}

{diacritical

mark

not

case

sensitive}

Attribute Types}
-1;
{noun }
-2;
{verb}
-3;
{adjective}
-4;
{adverb}

Integer;
=

nothing

match

key

}

16;

TYPE

=

if

in

32;

Data Types

InsertMode

key;

nothing

Constants}

kIsCaseSensitive

8-34

entry

{ dictionary matches key}
{only replace entries that
{ input entry}

Integer:

Summary of the Dictionary Manager

CHAPTER

8

Dictionary Manager

DictionaryInformation

=

RECORD
dictionaryFSSpec:

FSSpec;

numberOfRecords:

LongInt ;

currentGarbageSize:

LongInt;

{ file system specification }
{ record for this dictionary}
{ number of records in }
{ this dictionary}
{ current size of garbage }
{

script:

ScriptCode;

maximumKeyLength:

Integer;

keyAttributes:

UnsignedByte;

(unusable)

data

in

dictionary}

{ script system supported by }
{ this dictionary}
{ maximum length of any key }
{ in this dictionary}
{ key search criteria}

END;

Routines
Making a Dictionary
FUNCTION

InitializeDictionary

(theFSSpecPtr:

FSSpecPtr;

maximumKeyLength:

keyAttributes:
script:

Integer;

Byte;

ScriptCode):

OSErr;

Accessing a Dictionary
FUNCTION

OpenDictionary

(theFSSpecPtr:

FSSpecPtr;

accessPermission:

VAR

SignedByte;

dictionaryReference:

LongInt) :

OSErr;

FUNCTION

CloseDictionary

(dictionaryReference:

LongInt):

OSErr;

FUNCTION

GetDictionaryInformation

(dictionaryReference:
LongInt;
VAR theDictionaryInformation:
DictionaryInformation):

OSErr;

Locating Records in a Dictionary
FUNCTION

FindRecordInDictionary

(dictionaryReference:
key:

LongInt;

Str255;

requestedAttributeTablePointer:
recordDataHandle:

Summary of the Dictionary Manager

Handle):

Ptr;

OSErr;

8-35

CHAPTER

8

Dictionary Manager

FUNCTION

FindRecordByIndexInDictionary
(dictionaryReference:
recordindex:

LongInt;

LongInt;

requestedAttributeTablePointer:
VAR

recordKey:

Ptr;

Str255;

recordDataHandle:

Handle):

OSErr;

Modifying a Dictionary
FUNCTION

InsertRecordToDictionary
(dictionaryReference:LongInt;
key:

Str255;

recordDataHandle:
whichMode:
FUNCTION

Handle;

InsertMode):

OSErr;

DeleteRecordFromDictionary
(dictionaryReference:
key:

Str255):

LongInt;

OSErr;

Compacting a Dictionary
FUNCTION

CompactDictionary

(dictionaryReference:LongInt)
OSErr;

C Summary
Constants
/*

Dictionary

enum

data

insertion

modes.

*/

/*

Only

insert

/*

Only

{

kInsert

=

0,

in

kReplace

=

1,

the

=

2

/*

bi
/*

Key

attribute

constants.

Insert

the

entry

that

if

entries

which

input

entry.

*/

entry

dictionary

which

if

there

is

the

key.

matches

the

the

there

is

*/

the

nothing

in

there

matches

the

key.

If

matched

entries,

replace

the

matched

entries

with

input

the

nothing

match

already

key

the
are

existing

entry.

*/

*/

#define

kIsCaseSensitive

#define

kIsNotDiacriticalSensitive

8-36

input

dictionary

replace

with
kInsertOrReplace

the

0x10

Summary of the Dictionary Manager

0x20

/*

case-sensitive

/*

non-diac-sensitive

=

16

*/

=

32

*/

CHAPTER

8

Dictionary Manager

/*

Registered

enum

attribute

type

constants.*/

{

kNoun

=

-1,

kVerb

=

-2,

kAdjective

=

kAdverb

-4

=

-3,

hi
Data Types
typedef

short

InsertMode;

typedef

short

AttributeType;

/*

Dictionary

struct

information

record.*/

DictionaryInformation{

FSSpec

dictionaryFSSpec;

long

numberOfRecords;

long

currentGarbageSize;

ScriptCode

script;

short

maximumKeyLength;

unsigned

char

keyAttributes;

bi
typedef

struct

DictionaryInformation

DictionaryInformation;

Routines

Making a Dictionary
pascal

OSErr

InitializeDictionary

(FSSpecPtr
short

theFsspecPtr,

maximumKeyLength,

unsigned
ScriptCode

char

keyAttributes,

script)

Accessing a Dictionary
pascal

pascal

OSErr

OSErr

OpenDictionary

(FSSpecPtr

theFsspecPtr,

char

accessPermission,

long

*dictionaryReference)

(long

dictionaryReference)

CloseDictionary

Summary of the Dictionary Manager

8-37

CHAPTER

8

Dictionary Manager

pascal

OSErr

GetDictionaryInformation
(long

dictionaryReference,

DictionaryInformation

*theDictionaryInformation)

Locating Records in a Dictionary
pascal

OSErr

FindRecordInDictionary
(long

dictionaryReference,

Ptr

requestedAttributeTablePointer,

Handle

pascal

OSErr

ConstStr255Param

key,

recordDataHandle)

FindRecordByIndexInDictionary
(long

dictionaryReference,

long
Ptr

recordIndex,
requestedAttributeTablePointer,

Str255

recordKey,

Handle

recordDataHandle)

Modifying a Dictionary
pascal

OSErr

InsertRecordToDictionary
(long

dictionaryReference,

ConstStr255Param

InsertMode
pascal

OSErr

key,

Handle

DeleteRecordFromDictionary
(long

dictionaryReference,

Compacting a Dictionary
pascal

OSErr

CompactDictionary

(long

8-38

recordDataHandle,

whichMode)

dictionaryReference)

Summary of the Dictionary Manager

ConstStr255Param

key)

CHAPTER

8

Dictionary Manager

Assembly-Language Summary
Trap Macros
Trap Macro Names
Pascal name

Trap macro name

InitializeDictionary

_InitializeDictionary

OpenDictionary

_OpenDictionary

CloseDictionary

_CloseDictionary

InsertRecordToDictionary

_InsertRecordToDictionary

DeleteRecordFromDictionary

_DeleteRecordFromDictionary

FindRecordInDictionary

_FindRecordInDictionary

FindRecordByIndexInDictionary

_FindRecordByIndexInDictionary

GetDictionaryInformation

_GetDictionaryInformation

CompactDictionary

_CompactDictionary

Result Codes
notBTree
btNoSpace
btDupRecErr
btRecNotFnd
btKeyLenErr
btKeyAttrErr
unknownInsertModeErr
recordDataTooBigErr
invalidiIndexErr

—410
—413
—414
—415
—416
—417
—20000
—20001
—20002

File not a dictionary
Insufficient disk space to store dictionary information
Record already exists
Record cannot be found
Key length too great or equal to zero
Dictionary Manager doesn’t understand an attribute
No such insertion
mode
Entry data bigger than buffer size
Invalid index

Summary of the Dictionary Manager

8-39

Appendixes

APPENDIX A

Built-in Script Support

Contents
The Roman Script System
A-4
The Standard Roman Character Set
Nonprinting Characters
A-6
Printing Characters
A-8
Variations in the Character Set

A-4

§_A-16

The U.S. Keyboard-Layout ("“KCHR’) Resource

A-19

Standard Sorting Routines
A-20
Diacritical Stripping and Case Conversion
A-23
U.S. International Resources and Keyboard Resources
A-23
WorldScriptI
= A-25
About WorldScriptI
= A-25
Shared Script Utilities and QuickDraw Patches
A-25
Table-Based Script Behavior
A-27
Contextual Formatting Routines = A-27
Flexible Dispatching Method
A-28
Initialization Sequence
A-28
How Calls Are Dispatched
= =A-29
Saving User Preferences
A-31
Replacing a Script Utility or QuickDraw Patch
A-32
Patching Script Utilities
A-33
Patching QuickDraw Routines
A-34
Issues in Designing a Script Utility or QuickDraw Patch
= A-35
WorldScript II
A-36
About WorldScript I
A-36
Shared Script Utilities
A-37
Table-Based Script Behavior
A-38
Initialization Sequence
A-38
How Calls Are Dispatched
A-39

Contents

APPENDIX

A

Built-in Script Support

This appendix describes support for script-speci c behavior that is built into Macintosh
system software. The code and data described here can work with the resources of many
script systems to give the script systems their unique behaviors.
For historical reasons, much of the behavior of the Roman script system is built into
Macintosh system software code resources and ROM. The rest of its behavior is expressed
in international and keyboard resources that are installed in every version of Macintosh
system software. This appendix summarizes that behavior, which represents the default
set of Macintosh text-handling features.
WorldScript I is a script extension, consisting of code that implements table-driven
measuring and drawing behavior for all 1-byte complex script systems. Using tables in
each script system@ international resources, WorldScript I properly performs caret
placement, hit-testing, justi cation, text layout, and drawing for all supported scripts.
This appendix describes how WorldScript I works and how you can replace some of its
individual routines.
WorldScript II is another script extension that implements table-driven measuring and
drawing behavior for all 2-byte script systems. Like WorldScript I, WorldScript II uses
tables in each script system@ international resources to perform text manipulation
properly for all supported scripts. This appendix describes how WorldScript I] works;
note, however, that you cannot replace any of its routines.
Read this appendix for information on Roman character encoding, U.S. Roman
keyboard-layout resource features, and the default Roman sorting routines. Read this
appendix also if you wish to understand how the WorldScript extensions work, and
especially if you intend to replace or modify any of the WorldScript I routines.
Before reading this appendix, read the chapter Gintroduction to Text on the MacintoshOin
this book. If you intend to modify WorldScript I, read also the discussion on replacing a
script system@ default routines in the chapter Script ManagerOin this book. Additional
information on sorting behavior can be found in the description of the
string-manipulation resource in the appendix Cinternational ResourcesOin this book.
Additional information on the keyboard-layout resource can be found in the appendix
(Keyboard ResourcesOin this book.

A-3

APPENDIX

A

Built-in Script Support

The Roman Script System
The Roman script system is available on all localized versions of Macintosh system
software throughout the world. It is not entirely uniform; in different localized systems,
the Roman script may have different features. Nevertheless, its character set and its
sorting and formatting rules provide baselines that non-Roman script systems adopt,
modify, or replace as their needs align with or diverge from Roman conventions.
The Standard Roman character set is implemented by the U.S. keyboard-layout ('KCHR ')
resourceN included with every Macintosh systemN and by the keyboard-layout resources
of other localized versions of the Roman script system (such as French or Spanish).
The standard U.S. Roman sorting routines are the basis for sorting strings composed of
characters from the Standard Roman character set. The routines can be modi ed with
code ina script system@ string-manipulation resource; many non-U.S. Roman script
systems and many non-Roman script systems override the standard U.S. routines.

The Standard Roman

Character Set

The Standard Roman character set is an extended version of the Macintosh character
set, documented in Volume I of the original Inside Macintosh. The Macintosh character set
is itself an extended version of the ASCII character set. The conventional ASCII character
set, also called low ASCH, de nes control codes, symbols, numbers, and letters, assigning

them character codes from $00 through $7F. The Macintosh character set adds codes from
$80 through $D8, representing accented characters and additional symbols. Current
Macintosh le-system sorting, as well as the sorting order used by several Text Utilities
routines such as Rel String,

A-4

The Roman Script System

is based on the Macintosh character set.

APPENDIX

A

Built-in Script Support

The Standard Roman character set adds more accented forms, symbols, and diacritical

marks, assigning them character codes from $D9 through $FF. It thus consists of all the
character codes from $00 $FF, and it includes uppercase versions of all of the lowercase
accented forms, a number of symbols, and other forms. See Figure A-1.

The Standard Roman character set is the closest to a universal character encoding that
exists in the Roman script system. The Standard Roman characters are available in most
Roman outline fonts, but not all are available in the Apple bitmapped versions of
Chicago, Geneva, New York, and Monaco.

Figure A-1

Ox

The Standard Roman character set

1x

2x

3x

4x

x0

|nuljdle|

so}

0

|@|P

x1

}sohjDC1)

| | 1

x2 | stx |pC2
x3

6x

Jetx|DC3]

8x

Ax

Bx

lt

floflel-]+4]¢6

lQ}]alq{/Ale}le

#

}3

g] 4

|co

Cx

le]

|s}ecls{leElile

Dx

Ex

q]—

|E

|U]e|

x6 fack/syn]

a} o

|E|

vil

x7 | bel | etb

|e

Fx

O

]u

vy

, | U

]/o]T]alt{niils]¥l#Fl:f%fu

%|5

u

o}i

|.

uls

Ali

tlvlulalealalalefeél-:

7/G/wlg/lwlialo

LIK]
TMl>l]y

jcan|

(|

8

|H

|X]

x9 | htyem}

)

jo

|i

}y]ilyfato

xA | If

*

|sub]

9x

p|Ale

lenginak]

x8 | bs

7x

2/B/R}]bilrilclifle]ls]a}*],

x4 feot|DC4)
x5

JA

5x

h{

x | alo

J}Z]j}zfalo

™
}l™]

Sf

OLA]
| elo
Y/|E]~

nbsp]

7 | i

xB|

vt jesc]

+];

|K I] [|]

k]¢]al]o

2/aAlalil|e

xC|

ff | fs],

}<

}L]\}

it]

2;

falda

~

Al<]ifs

xofer{gs}-]}=|uMly}mly}elol4}Qlols]il”
xE | so | rs

>

|N{[*]1n]~]e]a

xF{/sifus}/;}]2]/o]

The Roman Script System

ele]

filo]

s+

|oldllélul@aloalelAlol—

A-5

APPENDIX

A

Built-in Script Support

Nonprinting Characters
Table A-1 lists the nonprinting characters in the Standard Roman character set. The
Unicode 1.0 name and the Macintosh character code (in hexadecimal and decimal) are
provided also. (Unicode is an ISO standard for 16-bit universal worldwide
character encoding.)
Table A-1

Nonprinting characters in the Standard Roman character set

Unicode name

Hexadecimal

Decimal

NULL

$00

0

START OF HEADING

$01

1

START OF TEXT

$02

2

END OF TEXT

$03

3

END OF TRANSMISSION

$04

4

ENQUIRY

$05

5

ACKNOWLEDGE

$06

6

BELL

$07

7

BACKSPACE

$08

8

HORIZONTAL TABULATION

$09

9

LINE FEED

$0A

10

VERTICAL TABULATION

$0B

11

FORM FEED

$0C

12

CARRIAGE RETURN

$0D

13

SHIFT OUT

$0E

14

SHIFT IN

$0F

15

DATA LINK ESCAPE

$10

16

DEVICE CONTROL ONE

$11

17

DEVICE CONTROL TWO

$12

18

DEVICE CONTROL THREE

$13

19

DEVICE CONTROL FOUR

$14

20

NEGATIVE ACKNOWLEDGE

$15

21

The Roman Script System

APPENDIX

A

Built-in Script Support

Table A-1

Nonprinting characters in the Standard Roman

character set (continued)

Unicode name

Hexadecimal

Decimal

SYNCHRONOUS IDLE

$16

22

END OF TRANSMISSION BLOCK

$17

23

CANCEL

$18

24

END OF MEDIUM

$19

25

SUBSTITUTE

$1A

26

ESCAPE

$1B

27

FILE SEPARATOR

$1C

28

GROUP SEPARATOR

$1D

29

RECORD SEPARATOR

$1E

30

UNIT SEPARATOR

$1F

31

DELETE

$7F

127

Using Roman Character Codes as Delimiters
Your application may need to use a character code or range of codes to represent
noncharacter data (such as_ eld delimiters). Character codes below $20 are never affected
by the script system. Some of these character codes can be used safely for special
purposes. Note, however, that most characters in this range are already assigned special
meanings by parts of Macintosh system software, such as TextEdit, or by programming
languages like C. Table A-2 lists the low-ASCII characters to avoid in your application.
Table A-2

Low-ASCIl characters to avoid as delimiters

Character

Hexadecimal representation

Null

$00

Home

$01

Enter

$03

End

$04

Help

$05

Backspace

$08

Tab

$09
continued

The Roman Script System

A-7

APPENDIX

A

Built-in Script Support

Table A-2

Low-ASCIl characters to avoid as delimiters (continued)

Character

Hexadecimal representation

Page up

$0B

Page down

$0C

Carriage return

$0D

F1 through F15

$10

System characters

$11, $12, $13, $14°

Clear

$1B

Arrow keys

$1C, $1D, $1E, $1F

* System fonts use these codes for the printing characters PROPELLER, LOZENGE

and APPLE LOGO, respectively.

, RADICAL,

For certain writing systems, font layouts (tables that map glyph codes to glyphs) may use
some of these character codes internally, for ligatures or other contextual forms. Also, as
noted in Table A-2, system fonts use codes $11 through $14 for printing special symbols
such as the Apple logo. Thus in unusual situations font changes may have an impact on
the glyph representation of stored character codes with values less than $20, even though
a user cannot generate those codes directly.

Printing Characters
Table A-3 shows the printing characters that exist in the Standard Roman character set.
Macintosh applications can assume that glyphs for these characters exist in every Roman
font. (However, see also the discussion of Roman fonts on page A-18.) The Unicode 1.0
and PostScript names and Macintosh character code (in hexadecimal and decimal) are
provided along with a glyph example for printable characters. Modi ed versions of the
Standard Roman character set exist for Croatian, Romanian, Turkish, and Icelandic/

Faroese, with different character assignments for the same codes. See Table A-4 through
Table A-7.

The Roman Script System

APPENDIX

A

Built-in Script Support

Unicode name

PostScript name

Hexadecimal

Decimal

SPACE

space

$20

32

EXCLAMATION MARK

exclam

$21

33

QUOTATION MARK

quotedbl

$22

34

NUMBER SIGN

numbersign

$23

35

DOLLAR SIGN

dollar

$24

36

PERCENT SIGN

percent

$25

37

AMPERSAND

ampersand

$26

38

APOSTROPHE-QUOTE

quotesingle

$27

39

OPENING PARENTHESIS

parenleft

$28

40

CLOSING PARENTHESIS

parenright

$29

41

ASTERISK

asterisk

$2A

42

PLUS SIGN

plus

$2B

43

COMMA

comma

$2C

44

HYPHEN-MINUS

hyphen

$2D

45

PERIOD

period

$2E

46

™

SLASH

slash

$2F

47

Oo

DIGIT ZERO

zero

$30

48

FP

DIGIT ONE

one

$31

49

NY

DIGIT TWO

two

$32

50

DIGIT THREE

three

$33

51

DIGIT FOUR

four

$34

52

DIGIT FIVE

ve

$35

53

DIGIT SIX

Six

$36

54

DIGIT SEVEN

seven

$37

55

DIGIT EIGHT

eight

$38

56

DIGIT NINE

nine

$39

57

COLON

colon

$3A

58

SEMICOLON

semicolon

$3B

59

LESS-THAN SIGN

less

$3C

60

EQUALS SIGN

equal

$3D

61

eo

ON

DBD

OF

Glyph

Printing characters in the Standard Roman character set

WD

Table A-3

continued

The Roman Script System

APPENDIX

A

Built-in Script Support

Table A-3

Hexadecimal

Decimal

$3E

62

QUESTION MARK

question

$3F

63

COMMERCIAL AT

at

$40

64

$41

65

$42

66

$43

67

$44

68

$45

69

$46

70

$47

71

$48

72

$49

73

$4A

74

$4B

75

$4C

76

$4D

77

$4E

78

$4F

79

$50

80

$51

81

$52

82

$53

83

$54

84

$55

85

$56

86

$57

87

$58

88

$59

89

$5A

90

x

¢s<st

LATIN CAPITAL LETTER G
LATIN CAPITAL LETTER H
LATIN CAPITAL LETTER I

Tm
rao

LATIN CAPITAL LETTER F

LATIN CAPITAL LETTER J
LATIN CAPITAL LETTER K
LATIN CAPITAL LETTER L
LATIN CAPITAL LETTER M
LATIN CAPITAL LETTER N
LATIN CAPITAL LETTER O
LATIN CAPITAL LETTER P
LATIN CAPITAL LETTER Q
LATIN CAPITAL LETTER R
LATIN CAPITAL LETTER 5
LATIN CAPITAL LETTER T
LATIN CAPITAL LETTER U
LATIN CAPITAL LETTER V
LATIN CAPITAL LETTER W
LATIN CAPITAL LETTER X
LATIN CAPITAL LETTER Z

NK

_—

OPENING SQUARE BRACKET

bracketleft

$5B

91

a

LATIN CAPITAL LETTER Y

WRFOTOBAZORO

GHenMFRFO

TPOAZAOARATSH

comm

LATIN CAPITAL LETTER E

—_=

LATIN CAPITAL LETTER D

GH

Uae

LATIN CAPITAL LETTER C

¢$<

Se»

LATIN CAPITAL LETTER A

OUND D>

PostScript name
SIGN

LATIN CAPITAL LETTER B

Nx

character set (continued)

greater

Unicode name
GREATER-THAN

X¥

Glyph

Printing characters in the Standard Roman

BACK SLASH

backslash

$5C

92

A-10

The Roman Script System

APPENDIX

A

Built-in Script Support

Table A-3
Glyph

Unicode name

]

CLOSING SQUARE

A

Printing characters in the Standard Roman

character set (continued)

PostScript name

Hexadecimal

Decimal

bracketright

$5D

93

SPACING CIRCUMFLEX

asciicircum

$5E

94

_

SPACING UNDERSCORE

underscore

$5F

95

.

SPACING GRAVE

grave

$60

96

a

LATIN SMALL LETTER A

a

$61

97

b

LATIN SMALL LETTER B

b

$62

98

Cc

LATIN SMALL LETTER C

Cc

$63

99

d

LATIN SMALL LETTER D

d

$64

100

e

LATIN SMALL LETTER E

e

$65

101

f

LATIN SMALL LETTER F

f

$66

102

g

LATIN SMALL LETTER G

g

$67

103

h

LATIN SMALL LETTER H

h

$68

104

i

LATIN SMALL LETTER I

i

$69

105

j

LATIN SMALL LETTER J

j

$6A

106

k

LATIN SMALL LETTER K

k

$6B

107

l

LATIN SMALL LETTER L

l

$6C

108

m

LATIN SMALL LETTER M

m

$6D

109

n

LATIN SMALL LETTER N

n

$6E

110

re)

LATIN SMALL LETTER O

re)

$6F

111

P

LATIN SMALL LETTER P

P

$70

112

q

LATIN SMALL LETTER Q

q

$71

113

r

LATIN SMALL LETTER R

r

$72

114

Ss

LATIN SMALL LETTER S

Ss

$73

115

t

LATIN SMALL LETTER T

t

$74

116

u

LATIN SMALL LETTER U

u

$75

117

Vv

LATIN SMALL LETTER V

Vv

$76

118

Ww

LATIN SMALL LETTER W

Ww

$77

119

x

LATIN SMALL LETTER X

x

$78

120

y

LATIN SMALL LETTER Y

y

$79

121

Z

LATIN SMALL LETTER 2

Z

$7A

122

BRACKET

continued

The Roman Script System

A-11

APPENDIX

A

Built-in Script Support

Table A-3
Glyph

character set (continued)

Unicode name

PostScript name

Hexadecimal

Decimal

OPENING

braceleft

$7B

123

VERTICAL BAR

bar

$7C

124

CLOSING CURLY BRACKET

braceright

$7D

125

TILDE

asciitilde

$7E

126

$7F

127

DELETE

A-12

Printing characters in the Standard Roman

CURLY BRACKET

(nonprinting)

LATIN CAPITAL LETTER A DIAERESIS

Adieresis

$80

128

LATIN CAPITAL LETTER A RING

Aring

$81

129

LATIN CAPITAL LETTER C CEDILLA

Ccedilla

$82

130

LATIN CAPITAL LETTER E ACUTE

Eacute

$83

131

LATIN CAPITAL LETTER N TILDE

Ntilde

$84

132

LATIN CAPITAL LETTER O DIAERESIS

Odieresis

$85

133

LATIN CAPITAL LETTER U DIAERESIS

Udieresis

$86

134

LATIN SMALL LETTER A ACUTE

aacute

$87

135

LATIN SMALL LETTER A GRAVE

agrave

$88

136

LATIN SMALL LETTER A CIRCUMFLEX

acircumfsex

$89

137

LATIN SMALL LETTER A DIAERESIS

adieresis

$8A

138

LATIN SMALL LETTER A TILDE

atilde

$8B

139

LATIN SMALL LETTER A RING

aring

$8C

140

LATIN SMALL LETTER C CEDILLA

ccedilla

$8D

141

LATIN SMALL LETTER E ACUTE

eacute

$8E

142

LATIN SMALL LETTER E GRAVE

egrave

$8F

143

LATIN SMALL LETTER E CIRCUMFLEX

ecircumfsex

$90

144

LATIN SMALL LETTER E DIAERESIS

edieresis

$91

145

LATIN SMALL LETTER I ACUTE

iacute

$92

146

LATIN SMALL LETTER I GRAVE

igrave

$93

147

LATIN SMALL LETTER I CIRCUMFLEX

icircumfSex

$94

148

LATIN SMALL LETTER I DIAERESIS

idiaresis

$95

149

LATIN SMALL LETTER N TILDE

ntilde

$96

150

LATIN SMALL LETTER O ACUTE

oacute

$97

151

LATIN SMALL LETTER O GRAVE

ograve

$98

152

The Roman Script System

APPENDIX

A

Built-in Script Support

Table A-3

Printing characters in the Standard Roman

character set (continued)

Glyph

Unicode name

PostScript name

Hexadecimal

Decimal

6

LATIN SMALL LETTER O CIRCUMFLEX

ocircumflex

$99

153

)

LATIN SMALL LETTER O DIAERESIS

odieresis

$9A

154

)

LATIN SMALL LETTER O TILDE

otilde

$9B

155

u

LATIN SMALL LETTER U ACUTE

uacute

$9C

156

u

LATIN SMALL LETTER U GRAVE

ugrave

$9D

157

a

LATIN SMALL LETTER U CIRCUMFLEX

ucircumflex

$9E

158

u

LATIN SMALL LETTER U DIAERESIS

udieresis

$9F

159

DAGGER

dagger

$A0

160

°

DEGREE SIGN

degree

$A1

161

¢

CENT SIGN

cent

$A2

162

£

POUND SIGN

sterling

$A3

163

§

SECTION SIGN

section

$A4

164

°

BULLET

bullet

$A5

165

I

PARAGRAPH SIGN

paragraph

$A6

166

6

LATIN SMALL LETTER SHARP $

germandbls

$A7

167

®

REGISTERED TRADEMARK

registered

$A8

168

©

COPYRIGHT SIGN

copyright

$A9

169

™

TRADEMARK

trademark

$AA

170

°

SPACING ACUTE

acute

$AB

171

SPACING DIAERESIS

dieresis

$AC

172

#

NOT EQUAL TO

notequal

$AD

173

A

LATIN CAPITAL LETTER AE

AE

$AE

174

1)

LATIN CAPITAL LETTER O SLASH

Oslash

$AF

175

oo

INFINITY

infinity

$B0

176

+

PLUS-OR-MINUS SIGN

plusminus

$B1

177

<

LESS THAN OR EQUAL TO

lessequal

$B2

178

>

GREATER THAN OR EQUAL TO

greaterequal

$B3

179

¥

YEN SIGN

yen

$B4

180

y

MICRO SIGN

mu

$B5

181

)

PARTIAL DIFFERENTIAL

partialdiff

$B6

182

SIGN

continued

The Roman Script System

A-13

APPENDIX

A

Built-in Script Support

Unicode name

PostScript name

Hexadecimal

Decimal

summation

$B7

183

N-ARY PRODUCT

product

$B8

184

GREEK SMALL LETTER PI

pi

$B9

185

INTEGRAL

integral

$BA

186

FEMININE ORDINAL INDICATOR

ordfeminine

$BB

187

MASCULINE ORDINAL INDICATOR

ordmasculine

$BC

188

OHM

Omega

$BD

189

LATIN SMALL LETTER AE

ae

$BE

190

LATIN SMALL LETTER O SLASH

oslash

$BF

191

INVERTED QUESTION MARK

questiondown

$C0

192

Do

INVERTED EXCLAMATION MARK

exclamdown

$C1

193

BD

character set (continued)

N-ARY SUMMATION

NOT SIGN

logicalnot

$C2

194

SQUARE ROOT

radical

$C3

195

LATIN SMALL LETTER SCRIPT F

Sorin

$C4

196

ALMOST EQUAL TO

approxequal

$C5

197

INCREMENT

Delta

$C6

198

LEFT POINTING GUILLEMET

guillemotleft

$C7

199

RIGHT POINTING GUILLEMET

guillemotright

$C8

200

HORIZONTAL ELLIPSIS

ellipsis

$C9

201

$CA

202

th

mim >

oD

Glyph

Printing characters in the Standard Roman

a

Table A-3

eo)

NON-BREAKING SPACE

A-14

LATIN CAPITAL LETTER A GRAVE

Agrave

$CB

203

LATIN CAPITAL LETTER A TILDE

Atilde

$CC

204

LATIN CAPITAL LETTER O TILDE

Otilde

$CD

205

LATIN CAPITAL LETTER O E

OE

$CE

206

LATIN SMALL LETTER O E

oe

$CF

207

EN DASH

endash

$D0

208

EM DASH

emdash

$D1

209

DOUBLE TURNED COMMA QUOTATION
MARK

quotedblleft

$D2

210

DOUBLE COMMA QUOTATION MARK

quotedblright

$D3

211

SINGLE TURNED COMMA QUOTATION
MARK

quoteleft

$D4

212

The Roman Script System

APPENDIX

A

Built-in Script Support

PostScript name

Hexadecimal

Decimal

quoteright

$D5

213

DIVISION SIGN

divide

$D6

214

LOZENGE

lozenge

$D7

215

LATIN SMALL LETTER Y DIAERESIS

ydieresis

$D8

216

mr

LATIN CAPITAL LETTER Y DIAERESIS

Ydieresis

$D9

217

_

FRACTION SLASH

fraction

$DA

218

CURRENCY SIGN

currency

$DB

219

LEFT POINTING SINGLE GUILLEMET

guilsingleleft

$DC

220

RIGHT POINTING SINGLE GUILLEMET

guilsingleright

$DD

221

(no Unicode designation)

fi

$DE

222

(no Unicode designation)

fl

$DF

223

DOUBLE DAGGER

daggerdbl

$E0

224

MIDDLE DOT

periodcentered

$E1

225

LOW SINGLE COMMA QUOTATION MARK

quotesinglbase

$E2

226

LOW DOUBLE COMMA QUOTATION
MARK

quotedblbase

$E3

227

PER MILLE SIGN

perthousand

$E4

228

LATIN CAPITAL LETTER A CIRCUMFLEX

Acircumflex

$E5

229

LATIN CAPITAL LETTER E CIRCUMFLEX

Ecircumflex

$E6

230

LATIN CAPITAL LETTER A ACUTE

Aacute

$E7

231

LATIN CAPITAL LETTER E DIAERESIS

Edieresis

$E8

232

LATIN CAPITAL LETTER E GRAVE

Egrave

$E9

233

ly

LATIN CAPITAL LETTER I ACUTE

Iacute

$EA

234

—>

LATIN CAPITAL LETTER I CIRCUMFLEX

Icircumflex

$EB

235

I:

LATIN CAPITAL LETTER I DIAERESIS

Idieresis

$EC

236

—

LATIN CAPITAL LETTER I GRAVE

Igrave

$ED

237

OQ

character set (continued)

LATIN CAPITAL LETTER O ACUTE

Oacute

$EE

238

Oo

Glyph

Printing characters in the Standard Roman

LATIN CAPITAL LETTER O CIRCUMFLEX

Ocircumflex

$EF

239

a.

Table A-3

APPLE LOGO

Apple

$FO

240

LATIN CAPITAL LETTER O GRAVE

Ograve

$F1

241

LATIN CAPITAL LETTER U ACUTE

Uacute

$F2

242

LATIN CAPITAL LETTER U CIRCUMFLEX

Ucircumflex

$F3

243

Unicode name

Sf

oO

SINGLE COMMA

Ca°o

fi

QUOTATION

MARK

continued

The Roman Script System

A-15

APPENDIX

A

Built-in Script Support

Table A-3

Printing characters in the Standard Roman

character set (continued)

Glyph

Unicode name

PostScript name

Hexadecimal

Decimal

6

LATIN CAPITAL LETTER U GRAVE

Ugrave

$F4

244

o)

LATIN SMALL LETTER DOTLESS I

dotlessi

$F5

245

fe)

MODIFIER LETTER CIRCUMFLEX

circumfex

$F6

246

+

SPACING TILDE

tilde

$F7

247

B

SPACING MACRON

macron

$F8

248

u

SPACING BREVE

breve

$F9

249

u

SPACING DOT ABOVE

dotaccent

$FA

250

a

SPACING RING ABOVE

ring

$FB

251

u

SPACING CEDILLA

cedilla

$FC

252

SPACING DOUBLE ACUTE

hungarumlaut

$FD

253

SPACING OGONEK

ogonek

$FE

254

MODIFIER LETTER HACEK

caron

$FF

255

y

Variations in the Character Set
Two types of variations from the Standard Roman character set can occur. First, several
languages and regional variations of Roman reassign parts of the character set; second,
many specialized Roman fonts completely override the character set to provide other
types of symbols.
Table A-4 shows the glyph assignments in the Croatian version of the Roman character
set that diverge from the Standard Roman character set, their Unicode and PostScript
names, and their Macintosh character codes in hexadecimal and decimal. For example,
the code (hexadecimal $A9) that is assigned to the copyright sign in the Standard Roman
character set is replaced by the Scaron (that is, the Roman capital letter GOwith a hacek).
The copyright sign appears later at position $D9, which is assigned to the Latin capital
letter O/Odiaeresis in the Standard Roman character set.
Table A-4

Croatian variations from the Standard Roman character set

Glyph

Unicode name

PostScript name

Hexadecimal

Decimal

S

LATIN CAPITAL LETTER S HACEK

Scaron

$A9

169

Z

LATIN CAPITAL LETTER Z HACEK

Zcaron

$AE

174

A

INCREMENT

Delta

$B4

180

5

LATIN SMALL LETTER S HACEK

scaron

$B9

185

Zz

LATIN SMALL LETTER Z HACEK

zcaron

$BE

190

A-16

The Roman Script System

APPENDIX

A

Built-in Script Support

Table A-4

Croatian variations from the Standard Roman

character set (continued)

Glyph

Unicode name

PostScript name

Hexadecimal

Decimal

C

LATIN CAPITAL LETTER C ACUTE

Cacute

$C6

198

C

LATIN CAPITAL LETTER C HACEK

Ccaron

$C8

200

D

LATIN CAPITAL LETTER D BAR

Dmacron

$D0

208

é

APPLE LOGO

apple

$D8

216

©

COPYRIGHT SIGN

copyright

$D9

217

®

LATIN CAPITAL LETTER A E

AE

$DE

222

E

RIGHT POINTING GUILLEMET

guillemotright

$DF

223

EN DASH

endash

$E0

224

é

LATIN SMALL LETTER C ACUTE

cacute

$E6

230

¢

LATIN SMALL LETTER C HACEK

ccaron

$E8

232

d

LATIN SMALL LETTER D BAR

dmacron

$FO

240

T

GREEK SMALL LETTER PI

pi

$F9

249

é

LATIN CAPITAL LETTER E DIAERESIS

Edieresis

$FA

250

ee

LATIN CAPITAL LETTER E CIRCUMFLEX

Ecircumfsex

$FD

293

LATIN SMALL LETTER A E

ae

$FE

254

Table A-5 shows the glyph assignments in the Romanian version of the Roman character
set that diverge from the Standard Roman character set, their Unicode and PostScript
names, and their Macintosh character codes in hexadecimal and decimal.

Table A-5

Romanian variations from the Standard Roman character set

Glyph

Unicode name

PostScript name

Hexadecimal

Decimal

A

LATIN CAPITAL LETTER A BREVE

Abreve

$AE

174

S

LATIN CAPITAL LETTER S CEDILLA
(COMMA VARIANT)

Scedilla

$AF

175

a

LATIN SMALL LETTER A BREVE

abreve

$BE

190

$

LATIN SMALL LETTER S CEDILLA
(COMMA VARIANT)

scedilla

$BF

191

T

LATIN CAPITAL LETTER T CEDILLA
(COMMA VARIANT)

Tcedilla

$DE

222

t

LATIN SMALL LETTER T CEDILLA
(COMMA VARIANT)

teedilla

$DF

223

The Roman Script System

A-17

APPENDIX

A

Built-in Script Support

Table A-6 shows the glyph assignments in the Turkish version of the Roman character set
that diverge from the Standard Roman character set, their Unicode and PostScript names,
and their Macintosh character codes in hexadecimal and decimal.

Table A-6

Turkish variations from the Standard Roman character set

Glyph

Unicode name

PostScript name

Hexadecimal

Decimal

G

LATIN CAPITAL LETTER G BREVE

Gbreve

$DA

218

4

LATIN SMALL LETTER G BREVE

ebreve

$DB

219

I

LATIN CAPITAL LETTER I DOT

Idot

$DC

220

fe)

LATIN SMALL LETTER DOTLESS I

dotlessi

$DD

221

$

LATIN CAPITAL LETTER S$ CEDILLA

Scedilla

$DE

222

S

LATIN SMALL LETTER 5 CEDILLA

scedilla

$DF

223

Table A-7 shows the glyph assignments in the Icelandic and Faroese versions of the
Roman character set that diverge from the Standard Roman character set, their Unicode
and PostScript names, and their Macintosh character codes in hexadecimal and decimal.

Table A-7

Icelandic and Faroese variations from the Standard Roman character set

Glyph

Unicode name

PostScript name

Hexadecimal

Decimal

Y

LATIN CAPITAL LETTER Y
ACUTE

Yacute

$A0

160

D

LATIN CAPITAL LETTER ETH

Eth

$DC

220

6

LATIN SMALL LETTER ETH

eth

$DD

221

p

LATIN CAPITAL LETTER THORN

Thorn

$DE

222

p

LATIN SMALL LETTER THORN

thorn

$DF

223

y

LATIN SMALL LETTER Y ACUTE

yacute

$E0

224

In addition to regional variations in the character set, the Roman script system in
particular contains many fonts with unique glyphs. Since the character encoding is
limited to 256 values, specialized fonts such as Symbol and ITC Zapf Dingbats override
the Standard Roman character encoding. For example, in the Standard Roman character
set $70 corresponds to lowercase Q>Q but it is the numeric symbol for pi (x) in the
Symbol font, an outlined square (4) in Zapf Dingbats, and the musical symbol
pianissimo for play quietly in the Sonata font. Hence, there is no guarantee that a Roman
character code will always represent the same character in every font.

A-18

The Roman Script System

APPENDIX

A

Built-in Script Support

The U.S. Keyboard-Layout (‘KCHR') Resource
The U.S. system software keyboard-layout resource (resource type 'KCHR', ID = 0) is
included with every Macintosh system. It implements the Standard Roman character set
shown in Figure A-1 on page A-5. The structure of the keyboard-layout resource is
documented in the appendix (Keyboard ResourcesOin this book. This section describes
in general how the U.S. 'KCHR' resource handles key combinations and dead keys.
The U.S. system software@ keyboard-layout resource makes it possible to enter accented
forms in the Standard Roman character set with dead keys, designated keys or
modi er-plus-key combinations that produce no immediate effect when pressed but
instead affect the character or characters produced by the next keys typed, called
completer keys. Users can enter all the accented forms in the Standard Roman character
set with dead keys. For example, pressing Option-E on the U.S. keyboard produces
nothing (no event is posted), but subsequently typing @Oproduces OO
Note
Other keyboard layouts may produce accented characters in other ways.
On the French keyboard ('KCHR' resource ID = 1), for example, pressing
Option-E directly produces
OO ¢
The U.S. keyboard-layout resource provides the following key-combination features for
consistency:
m Because the Shift key is ignored if the Command key is pressed, the Caps Lock key is
also ignored if the Command key is pressed.
m Handling of the Option-Shift and Option Caps Lock key combinations is based on the
following principles:
4 If either the Option or the Option-Shift key combination produces a letter, then the
Option Caps Lock key combination produces the same character as the Option, not
the Option-Shift, key combination.

O If the Option key combination is a dead key for a particular accent, then the
Option-Shift key combination produces the accent directly.
A no-match character (also called a default completion character) is the character that is
produced when the keystroke following a dead key is either a space or a key fora
character that cannot take the accent corresponding to the dead key. In system software
versions 7.0 and later, default completion characters are QealOaccent characters instead
of low-ASCII approximations.

The Roman Script System

A-19

APPENDIX

A

Built-in Script Support

Standard Sorting Routines
The standard Macintosh sorting routines are contained in the Pack 6 resource, a system
code resource (type = 'PACK', ID = 6) initialized at startup. As they process each
character or sorting unit, the standard routines

rst call equivalent routines in the current

script system@ string-manipulation ('it12') resource. Those routines, called sorting
hooks, are described with the string-manipulation resource in the appendix
Onternational ResourcesOin this book.

The U.S. string-manipulation ('it12') resource contains only empty sorting hooks.
Other localized versions of the Roman script systemN and non-Roman script systemsN
provide their own string-manipulation resources that may have nonempty routines to
modify or replace any of the standard routines, on a character-by-character basis.
Table A-8 describes the sorting behavior implemented by the standard Macintosh sorting
routines. All characters of the Standard Roman character set are sorted. Primary sorting is
shown in vertical order; secondary sorting is horizontal. This is the default sorting
behavior used by the Text Utilities, and is appropriate for U.S. and similar localized
versions of the Roman script system. All Text Utilities sorting routines (other than
RelString and EqualString) use the sorting behavior speci

ed in the

string-manipulation resource, which may or may not be identical to the standard
behavior. (RelString and EqualString use an invariant sorting behavior that is

described in the chapter Ofext UtilitiesOin this book.)

Table A-8

Standard sorting order (for Standard Roman character set)

Primary

Secondary

$00

NUL

E

A-20

$1F

US

$20

space ($20) non-breaking space ($CA)

$21

{

$22

" C($C7) E($C8) O($D2) O($D3)

$23

#

$24

$

$25

%o

$26

&

The Roman Script System

APPENDIX

A

Built-in Script Support

Table A-8

Standard sorting order (for Standard Roman character set) (continued)

Primary

Secondary

$27

' Q$D4) Q$D5)

$28

(

$40

@

$41

Ac

$42

Bb

$43

C,ce

$44

Dd

$45

Eféxe@e

E

EA

Ieat*%
«&

ee

E
$49
E

1léiéiios’%”e

$4E

N,

$4F

Oinai..f
- o—™

n5;

E
$55

Uso

é66tT

$59

Yy

OU

$5A

ZZ

$5B
E

[

$60

.

$7B
E
$7F
$A0
E

{

uce

Y

E

DEL

The Roman Script System

A-21

APPENDIX

A

Built-in Script Support

Low-ASCII characters (other than letters) not listed in Table A-8 have primary sorting
only and are sorted according to numeric code. Low-ASCII letters not listed in Table A-8
have a primary sorting order that is alphabetical and a secondary sorting order of
uppercase followed by lowercase (like CB bQ. All characters with codes above $A0 that
are not listed in Table A-8 are sorted after $A0 according to numeric character code
(except for ligatures; see note on sorting of ligatures).
Note the following details and anomalies in the standard Macintosh sorting order:
m The symbols »($BB) and ($BC) are explicitly treated as symbols, not as letters, and
their primary sorting positions are not respectively the same as A and O.
m The en-dash ($D0) and em-dash ($D1) do not have the same primary sorting position
as hyphen-minus ($2D).
m The double low quotation mark a ($E3) does not have the same primary sorting
position as quotation " ($22).
m The single low quotation mark 4($E2), and the left and right single guillemet U ($DC,
$DD) do not have the same primary sorting position as apostrophe ' ($27).
m The secondary sorting position for dotless-lower-i 6($F5) is indeterminate. It sorts at
exactly the same place (primary and secondary order) as regular lower i ($69).
m The character U does not sort between Y and y.
Sorting of ligatures

For a ligature, the primary sorting position is equivalent to the separate
characters that make up the ligature. The secondary sorting position is
just following the equivalent separate characters. Ligatures are sorted by
the following rst and second characters:

A-22

Ligature

First
character

Second
character

®

A

E

a

e

f

i

fs

f

]

I

O

E

I

fe)

e

§

S

S

The Roman Script System

APPENDIX

A

Built-in Script Support

Diacritical Stripping and Case Conversion
The Text Utilities routines LowercaseText, UppercaseText, StripDiacritics, and

UppercaseStripDiacritics use information ina script system@ string-manipulation
('it12') resource to perform their tasks. A Roman string-manipulation resource is
included with every Macintosh system; the U.S. version of the Roman

string-manipulation resource converts case and strips diacritical marks according to the
following rules:
m
m
m

The unaccented letters

A Z anda

z are converted to unaccented a zandA

respectively, by case conversion. They are unaffected by stripping.

Z,

Accented versions (*, ¢, ,, ) are converted to equivalent unaccented versions (A, e, N)

by stripping.

Accented versions (*, ¢, ,, ) are converted to identically accented case-changed
versions (Cia, —) by case conversion.

m Ligatures are unaffected by stripping, but are converted as appropriate by case
conversion. Only the ligatures §,

,and &, which have no uppercase versions, are

unaffected by case conversion as well as by stripping.

U.S. International Resources and Keyboard Resources
When Macintosh system software is localized for a non-U.S. market, its system script
may be Roman or non-Roman. In either case, it contains replacements for or

modi cations to the U.S. international resources and keyboard resources. Any U.S.
Roman resource that is not replaced is included with the localized system.
Table A-9 shows which international resources are included in the U.S. system software,
and how localized versions of the system software (and secondary scripts) add resources
or replace them in the System le. Note that all non-Roman script systems and most
localized versions of system software include localized versions of the '1t10','it11',

'i1t12',and 'it14' resources. (Not all non-U.S. Roman script systems add a non-U.S.
'it14'.) Some non-Roman systems may also use optional 'it15' or 'trs1' resources.

Table A-9
Resource type

International resources in U.S. system software
U.S. system software

Localized versions

including Roman

of system software or

'itle'

Roman

'itlc'

May replace 'itlc'

'itlm'

Default 'it1m'

May replace 'it1m'

'itlb'

Roman

May add non-Roman

script system

'itlb'

other script systems

'it1lb'!
continued

The Roman Script System

A-23

APPENDIX

A

Built-in Script Support

Table A-9

International resources in U.S. system software (continued)

Resource type

U.S. system software
including Roman
script system

Localized versions
of system software or
other script systems

'itlo'

US.

'itlo'

Adds non-U.S. 'it10!

‘itll!

U.S.

'itl1'

Adds non-U.S.

'it11!

'itl2!

U.S.

'it12'

Adds non-U.S.

'it12!

'itl4!

U.S.

'it14!

May add non-U.S.

'atl5'

(none)

May add non-Roman

'it15'

'trsl'!

(none)

May add non-Roman

'trs1'

'1t14'

Table A-10 lists the keyboard resources that are included in the U.S. system software and
shows how localized versions of the system software (and auxiliary scripts) add
resources or replace them in the System le. Note that all localized versions of system
software and all non-Roman script systems include at least one keyboard-layout resource
and keyboard icon family; some provide a key-remap resource; and none need provide a
key-map resource or key-caps resource.
Table A-10

Keyboard resources in U.S. system software

including Roman
script system

U.S. system software

Localized versions
of system software or
other script systems

'itlk'!

(none)

May add an 'itlk' °

"KCHR'!

U.S.

Adds

'KSWP!

Standard 'KSWP'

May replace 'KSWP'

'KMAP !

All necessary

(none)

'kes#!

U.S. 'kes#!

Adds non-US.

'kes4!

US. 'kes4!

Adds non-US. 'kes4'*

'kes8!

US. 'kes8!

Adds non-US. 'kcs8 '*

'KCAP!

All necessary

Resource type

'KCHR'

'KMAP's

'KCAP's

non-U.S.

'KCHR'

'kes#'*

(none)

* ID number equal to corresponding 'KCHR' ID number

For more information on these resources, see the appendixes Onternational ResourcesO
and (Keyboard ResourcesOin this book.

A-24

The Roman Script System

APPENDIX

A

Built-in Script Support

WorldScript I
WorldScript I is a system extension, available with system software version 7.1 and later,

that can support all types of 1-byte complex script systems. It contains code that
implements many script-aware text-manipulation routines, eliminating the need for each
script to maintain its own code extensions.
WorldScript lis a single le located in the Extensions folder within the System Folder on
the user@ Macintosh computer. It installs and initializes all compatible script systems
present in the System Folder, and provides each with a set of standard routines. Script
systems compatible with WorldScript I are called universal scripts, because they make use
of the universally applicable WorldScript I routines.

About WorldScript |
Script systems developed prior to system software version 7.1 contain their own code to
handle language-speci c text processing. Each script system also has its own
initialization and con guration code, installing itself at startup and adding its own
modi cations to the system. This process can result in a layering of patches to the same
traps, inconsistent behavior, and inef

cient use of memory.

WorldScript I rede nes what a script system consists of by combining the executable code
for many routines for all 1-byte script systems. It includes initialization and formatting
routines that support all contextual forms required by all 1-byte scripts; script-speci c
behavior is encoded in resource-based tables. This approach reduces memory
requirements for multiscript systems and avoids layering of patches.
WorldScript I routes script-aware calls through each universal script@ own dispatch table;
the dispatch table initially points back to the script utility routines in WorldScript I. This
indirection allows your application to add to or replace existing routines on a
script-by-script basis. Script Manager calls allow you to modify or add to any script@
utility routine or patch. You can even replace an individual script system@ routine
completely if you need features signi cantly different from those provided by
WorldScript I. Script utilities and dispatch tables are described in the next section and
under (Flexible Dispatching MethodObeginning on page A-28.

Shared Script Utilities and QuickDraw Patches
The script utilities are the low-level routines through which an individual script system
implements script-aware Text Utilities, QuickDraw, and Script Manager routines. When

an application makes a script-aware call, the script management system converts it to a
script utility call and passes it on to the appropriate script system. Previous to system
software version 7.1, individual script systems provided their own script utilities. With
WorldScript I, a single set of script utilities can work with all 1-byte complex scripts.

WorldScript |

A-25

APPENDIX

A

Built-in Script Support

Two Script Manager routines, Get ScriptUtilityAddress and
SetScriptUtilityAddress, allow you to access and override a script@
utility routines.
Table A-11 lists the script utilities implemented by WorldScript I, along with the chapters
in this book that describe their corresponding high-level routines.
Table A-11

Script utilities supported by WorldScript |

Script utility

Chapter in this book

CharacterByteType

Script Manager

CharacterType

Script Manager

CharToPixel

QuickDraw Text

DrawJustified

QuickDraw Text

FillParseTable

Script Manager

FindScriptRun”

Text Utilities

FindWordBreaks*

Text Utilities

GetScriptQDPatchAddress

Script Manager

GetScriptUtilityAddress

Script Manager

GetScriptVariable'

Script Manager

HiliteText

QuickDraw Text

MeasureJustified

QuickDraw Text

Pixel ToChar

QuickDraw Text

PortionLine

QuickDraw Text

SetScriptQDPatchAddress

Script Manager

SetScriptUtilityAddress

Script Manager

SetScriptVariable

Script Manager

TransliterateText

Script Manager

VisibleLength

QuickDraw Text

NOTE
WorldScript I supports the following script utilities for backward compatibility. They call
newer versions of themselves to handle their tasks. They are: Pixel2Char (calls Pixel ToChar),
Char2Pixel (calls CharToPixel), DrawJust (calls DrawJustified), MeasureJust (calls
MeasureJustified), PortionText (calls PortionLine), CharByte (calls
CharacterByteType), CharType

(calls CharacterType),

ParseTable

FillParseTable), Transliterate (calls TransliterateText).
*

A-26

(calls

The Script Manager handles these routines directly if the necessary tables are in the script@
'1t12' resource. Otherwise, they are passed to WorldScript I.
The Script Manager handles these routines directly if the standard selectors documented in this
book are used. The routines are passed to WorldScript I if private selectors are used.

WorldScript |

APPENDIX

A

Built-in Script Support

WorldScript I also patches four standard QuickDraw text-handling routines: StdText,
StdTxMeas, MeasureText, and FontMetrics. (FontMetrics is a Font Manager

routine, but for simplicity all four routines and patches are referred to in this appendix as
QuickDraw routines and patches.) The purpose of the QuickDraw patches is to lay out
text according to context and line direction. The original QuickDraw routine is called
after the text is laid out properly. The QuickDraw dispatch table has special entries to
support developer patching of routines for printing as well as for display.
Two Script Manager routines, Get ScriptQDPatchAddress and
SetScriptQDPatchAddress, allow you to access and override a script@
QuickDraw patches.
Table A-12 lists the QuickDraw patches implemented by WorldScript I, along with the
chapters in this book that describe the original routines.
Table A-12

QuickDraw patches supported by WorldScript |

QuickDraw patch

Chapter in this book

FontMetrics

Font Manager

MeasureText

QuickDraw Text

StdText

QuickDraw Text

StdTxMeas

QuickDraw Text

Table-Based Script Behavior
The shared script utilities determine script-speci
script system@ international resources.

c characteristics from the tables in each

WorldScript I uses tables in a script system@ string-manipulation (' it 12') resource for
analyzing character types, nding word breaks, and performing case conversion. This
use of tables predates the existence of WorldScript I, but WorldScript I extends the use of
tables to all routines for 1-byte complex script systems. New tables that are required are
put in the script@ encoding /rendering (' it 15") resource, using a tagged-table index for
storage and retrieval. For example, the contextual formatting routines (described in the
next section) uses tables in the encoding /rendering resource.
The international resources are described in the appendix international ResourcesOin
this book.

Contextual Formatting Routines
WorldScript I uses a set of table-driven routines to format text according to each script@
requirements and attributes. The WorldScript I script utilities and QuickDraw patches
that perform text formatting and layout rely on these table-driven routines. Each script
has several tables in its encoding /rendering ('1t15') resource to specify the display
characteristics of its text.

WorldScript |

A-27

APPENDIX

A

Built-in Script Support

Flexible Dispatching Method
Each enabled script system has a script record, a private data structure that holds
information and addresses pertinent to that script. When an application makes a
script-aware call, the script management system determines the current script and
consults that script@ script record for the address of the script@ dispatch routine (which
is actually part of WorldScript I). It passes the call to the dispatch routine, which uses the
script@ dispatch table to execute the proper script utility. Every script system has its own
pointer to the dispatch routine and its own dispatch table, separate from other scripts.
When the application makes a script-aware QuickDraw call, WorldScript I uses the
script@ QuickDraw dispatch table to execute the proper QuickDraw patch.
At run time, the application call has been converted to a lower-level script utility call or
QuickDraw call. Each script utility call includes a script utility selector, a number that the
dispatch routine uses to select the proper routine from the dispatch table.

Initialization Sequence
The startup code for enabling all available 1-byte complex script systems and script
utility routines is in WorldScript I. WorldScript I is located in the Extensions folder; its
type is 'scri' and its creator is 'univ’.

le

At startup, WorldScript I does the following:
1. It checks for a valid machine con guration. WorldScript I works on Macintosh Plus
models and later; it requires Script Manager version 2.0 or later and system software
version 7.1 or later.
2. WorldScript I gets the number of valid 1-byte script bundles in the System le. A valid
script bundle consists of a set of international resources ('it1b!' and 'it15'
required,

'it10',

'itl1','1t12',and

'it14'

optional) and at least one font in the

script system@ ID range. The smsfSingByte bit in the international bundle (' it1b')
resource must also be set to indicate that the script is 1-byte.
If no 1-byte script bundles are present, WorldScript I does not load any of its script
utilities or QuickDraw patches. It exits without signaling an error.
3. If one or more valid script bundles are present, WorldScript I does the following for
each script:

1. It checks for enough memory to load the script.
2. It checks the smsfUnivExt bit in the script@ international bundle resource. If the
ag is set, the script system is a universal script system, and WorldScript I proceeds.
If the Sag is clear, WorldScript I goes on to the next script.
3. It creates a script record and initializes the record with the script@ values.
4. Ifthisisthe rst universal 1-byte script allocated, WorldScript I loads its script
utilities and QuickDraw patches into the system heap.

A-28

WorldScript |

APPENDIX

A

Built-in Script Support

5. WorldScript I allocates the script@ dispatch table and sets the table@ elements to
point to the WorldScript I script utilities and QuickDraw patches or to the original
Roman script utilities and QuickDraw calls, as appropriate for the script.
6. WorldScript I makes default settings for the script system based on information
from the con guration table in the script@ encoding /rendering ('it15') resource.
It then looks in the Preferences folder for a script preferences le. If one is found,
and ifthe lecontains acon guration resource (type 'CNFG') for this script system,
WorldScript I uses that resource to reinitialize the script record@ elds.
If no preferences le is available, WorldScript I keeps the default settings loaded
from the encoding/rendering resource.
7. WorldScript I initializes Script Manager data structures that point to this
script record.
Any initialization errors that occur are reported to the user via the Noti

cation Manager.

How Calls Are Dispatched
In every script system that is compatible with WorldScript I, the dispatch-table element
for every script utility and QuickDraw patch consists of two pointers: one to the
WorldScript I implementation of the routine and one to the original routine. In all cases,
the WorldScript I routine executes rst. In some cases, WorldScript I calls the original
routine after its own; in other cases, the pointer to the original routine is NIL and the

WorldScript I routine is all that executes. See Figure A-2. This design allows you to place
a patched routine so that it executes either before, in place of, or after the WorldScript I
routine and allows you to either call the original routine or not call it.
Figure A-2

Dispatch table entry for script utilities and QuickDraw patches

.\

Address of script’s
Address of
patch to stdText | original stdText

=

WorldScript |

Ee»

pascal

WorldScript |

ScriptStdText

Original code

():

Nap)

pascal

StdText

():

A-29

APPENDIX

A

Built-in Script Support

Every script-aware call to system software that executes as a script utility goes through
the ScriptUtil trap (SA8B5). The script management system handles some of those
calls, such as

Get SMVariable, itself; other calls, such as DrawJustified, it passes toa

script system through the script system@ script record. Those calls are listed in Table A-11
on page A-26. The script system uses its script utility dispatch table to call the right script
utility. See Figure A-3.
When it receives a script utility call, a script@ dispatch routine does the following:
1. It checks to see if the call (as de ned by the script utility selector) is within the range of
routines handled by the script.
2. It gets the address of the script utility from the script@ dispatch table, using the script
utility selector.
3. It replaces the selector on the stack with the address of its own script record.
4. It jumps into the WorldScript I routine obtained in step 2. As the routine executes, it
obtains script-speci c characteristics from the script record passed to it in step 3.
5. The WorldScript I routine gets the address of the original (Roman) routine from the
dispatch table and, if it is not NIL, jumps to that routine upon completion.
Figure A-3

Script-aware

call

_

SeriptUtil

P

How calls are dispatched to the 1-byte script utilities

thePort

»

Script

management

system

txFont

Gets script
from our rent

Script record

Gets address of
script’s dispatch routine

Script utility
dispatch table

;

Jumps

WorldScript |

WorldScript |
Jumps to
routine
WorldScript |

dispatch
routine

Gets address of
WorldScript |
script utility

|
toy

script utility
,
Original

Jumps to

(Roman)

Roman

Gets address of
Roman script utility

routine | script utility
[__} Flow of control

Returns

A-30

WorldScript |

[_]

Address fetching

APPENDIX

A

Built-in Script Support

A patched low-level QuickDraw call follows a similar path, except that it goes through a
QuickDraw trap that has been patched to execute code in WorldScript I instead of
passing through the script management system. After determining which script should
handle this call (by examining the current font), WorldScript I uses the script@
QuickDraw dispatch table to jump to the proper routine. See Figure A-4.
Figure A-4

I

Low-level

QuickDraw call

How calls are dispatched to the 1-byte QuickDraw patches

_StdText,etc.

|>

thePort

.

WorldScript |
Gets script

txFont

;

from current

Script record

font

Dispatch
routine

;
uickDraw
table
dispatch

Gets address of script’s
:
i
table
dispatch
QuickDraw

pot tt
<

S

Gets address of WorldScript |
QuickDraw patch

Jumps to |
WorldScript
QuickDraw patch

igi

QuiceDia
routine

<

Jumps to built-in

QuickDraw routine

os

WorldScript |
routine

Gets address of

v7

built-in QuickDraw routine

lle
Returns

Saving User Preferences
The Operating System and some individual script systems use control panels to let
users change text-related system settings, such as line direction, associated font,
kashida preferences, and caret style. Script systems may store these settings in a
script preferences le in the Extensions folder. This le contains resources of type
'CNFG', whose resource ID numbers are equal to the script codes of the script systems
they represent.

WorldScript |

A-31

APPENDIX

A

Built-in Script Support

As noted under Gnitialization SequenceOon page A-28, when installing a script system
WorldScript I looks for a script preferences le in the Preferences folder. For each script
system it initializes, WorldScript I loads the 'CNFG' resource for that script from the
script preferences le and uses it to recon gure the script.
Note
The 'CNFG' resource in the script preferences le has exactly the same
format as the script con guration table in the encoding /rendering
resource. However, it may not have exactly the same elements. The types
of con guration settings speci ed in the 'i1t15' resource may be
different from those settable by the user through a control panel.
See the discussion of the encoding /rendering resource in the appendix Onternational
ResourcesOin this book for a description of the script con guration table.

Replacing a Script Utility or QuickDraw Patch
Developers of 1-byte complex script systems should be able to specify most of their script
system@ behavior in tables in the script system@ encoding /rendering ('it15 ') resource.
In cases where the WorldScript I routines are insuf cient to handle the script@ speci c
needs, the developers may create patches and install them as described here. The patches
may be installed by an extensions le that is executed at system startup.
Application developers who need speci c script-based behavior for their programs
should not alter the tables in a 1-byte script@ encoding / rendering ('it15') resource.
However, they can replace one or more 1-byte script utilities or QuickDraw patches for
their target script system, as described here.
IMPORTANT

When you patch a script system@ script utility or QuickDraw call, you
alter that script@ behavior for as long as it remains enabled. Therefore, be
sure to restore the patches to their original state whenever your
application quits or is switched out by the Process Manager. &
The script-based dispatch table design gives you a simple, Sexible way to replace
individual routines without having to patch out all of the ScriptUtil trap or any of
the QuickDraw

low-level routines in their entirety. Furthermore, in a multiscript

environment each patch of this type applies only to its own script system. A developer
might, for example, patch StdText for the Thai script system only, leaving all the other
scripts unchanged.

A-32

WorldScript |

APPENDIX

A

Built-in Script Support

In addition, you can choose the point at which your patched routine executes: either
before (which also means in place of if your routine does not call the WorldScript I routine
at all) or after the WorldScript I routine executes. For example, the WorldScript I version
of StdText works by rst performing contextual analysis and reordering of characters
on the supplied text, and then calling the original version of StdText. Suppose you want
to keep the WorldScript I contextual analysis and reordering of characters, but you want
to do some additional processing before calling the original StdText. To do that, just
patch out the WorldScript I routine@ call to the original StdText, instead of patching out
the entire WorldScript I routine. Then do your own processing and call StdText
yourself.
Because you can patch at two points, and because you can perform your own processing
either before or after a patch, your Sexibility is great. To replace only the WorldScript I
routine, replace its pointer in the dispatch table; to keep the WorldScript I routine while
replacing or patching the original routine, replace the original-routine pointer in the

dispatch table. The four Script Manager routines that allow you to make those patches
are GetScriptUtilityAddress,
GetScriptQDPatchAddress,

SetScriptUtilityAddress,

and SetScriptQDPatchAddress.

Hither pointer in the

dispatch table may be NIL, meaning that WorldScript I either doesn@patch the original
routine or doesn@call the original routine.

Patching Script Utilities
In terms of how to patch them, the script utilities can be divided into different groups,
depending on whether or not WorldScript I performs contextual formatting and whether
or not it subsequently calls the original Roman version of the utility. See Table A-13. For
utilities that perform contextual formatting, keep in mind that if you replace them you
will have to handle formatting yourself. For utilities that subsequently call their original
Roman version, you can replace either the WorldScript I version of the call or the Roman
version or both, depending on what your needs are.
Table A-13

— Classification of 1-byte script utilities by function

No formatting,
do not call original
Roman routine

No formatting,
do call original
Roman routine

May do formatting,
do not call original
Roman routine

CharacterByteType

CharacterType

HiliteText

GetScriptVariable

TransliterateText

VisibleLength

SetScriptVariable

FindWordBreaks

Pixel ToChar

FillParseTable

FindScriptRun

CharToPixel

PortionLine

DrawJustified
MeasureJustified

WorldScript |

A-33

APPENDIX

A

Built-in Script Support

Note that those script utilities that do not call their equivalent Roman routine
nevertheless call QuickDraw StdText or StdTxMeas ifthe grafProcs

eldinthe

graphics port has been changed. Thus, if you have changed (patched) either of those
QuickDraw routines, your patch will still be called. Conversely, if the grafProcs eldis
NIL, The WorldScript I script utilities do not necessarily call StdText or StdTxMeas.

If you are replacing a script utility, remember that its interface is similar to that of its
equivalent high-level call as described in Inside Macintosh. The utility takes the same
parameters in the same order, except that it gets one additional last parameter on the
stack: a pointer to the script record. For example, if you are replacing VisibleLength,
whose high-level interface is
FUNCTION

VisibleLength

(textPtr:

Ptr;

textLen:

LongInt):

LongInt;

your patch to the equivalent script utility should expect to receive parameters as if the
high-level interface were
FUNCTION

VisibleLength

(textPtr:

Ptr;

textLen:

LongInt;

scriptRecord:

Ptr):

LongInt;

Also, if your replacement calls the original routine, don@forget to pass the extra
parameter to it.

Patching QuickDraw Routines
WorldScript I patches the low-level QuickDraw text-handling routines StdText and
StdTxMeas, the high-level QuickDraw routine MeasureText, and the Font Manager

routine FontMetrics.

The QuickDraw patches lay out lines of text according to the context and line-direction
rules for a script system. In each case (except for MeasureText) the patch calls the
original QuickDraw routine after performing the contextual formatting. The contextual
formatting routines are called only for contextual scripts.

A-34

WorldScript |

APPENDIX

A

Built-in Script Support

Table A-14 lists the patches and what they do. For those patches that perform contextual
formatting, if you replace them you will have to handle formatting for line layout
yourself. For all of them, you can replace either the WorldScript I patch or the standard
QuickDraw call or both, depending on your needs.
Table A-14

— Classification of 1-byte QuickDraw patches by function

Call

Function

FontMetrics

Returns font measurements

MeasureText

Calls MeasureJustified (with slop = 0)

StdText

Does formatting, then calls original routine

StdTxMeas

Does formatting, then calls original routine

Issues in Designing a Script Utility or QuickDraw Patch
Keep the following points in mind if you plan to replace one or more script utilities or
QuickDraw patches in WorldScript I:
In script systems compatible with WorldScript I, text handling typically involves
WorldScript I contextual analysis followed by a call to the original Roman version of
the routine. You need to know whether it is the WorldScript I functionality or the
original functionality that you want your routine to replace, and you need to be sure
that your routine is called only at the correct points in the process. More detailed
information on text layout is found in the chapter GQuickDraw TextOin this book.
Script utilities process text in individual style runs, whose boundaries are de ned by
the application. If your application supports styled text, each script utility will need to
handle only individual style runs. But if your application supports unstyled text only,
there may be mixed Roman and non-Roman characters in a single font. Before
performing text layout, your script utility will have to separate the Roman characters
into their own style runs, and assign them to an associated font, if your script system
uses associated fonts.
If you provide your own script utility, you need to be sure that text is not formatted
more than once. Because script utilities might be called reentrantly during printing,
you may want to save the port for each contextual analysis. Check this port against the
current port for each possible contextual analysis request, so you can prevent the text
from being formatted twice.
Printing adds another level of complexity to the WorldScript I QuickDraw
patches and your ability to patch out those patches. The QuickDraw dispatch
table has special entries to support developer patching of routines in printing as well
as for display. See the descriptions of the routines Get ScriptQDPatchAddress
and SetScriptQDPat chAddress in the chapter Gcript ManagerOin this book
for more information. See also Macintosh Technical Note #174 for additional
information on printing.

WorldScript |

A-35

APPENDIX

A

Built-in Script Support

WorldScript II
WorldScript II is a system extension, available with system software versions 7.1 and

later, that can support 2-byte script systems: Chinese (traditional and simpli ed
characters), Japanese, and Korean. It contains code that implements script-aware
text-manipulation routines, eliminating the need for each script to maintain its own code
extensions. WorldScript II supports the input, display, and printing of the thousands of
characters needed by the 2-byte script systems.
WorldScript Il isa single le located in the Extensions folder within the System Folder on
the user@ Macintosh. It installs all compatible 2-byte script systems that are present in the
System Folder and provides each with a set of standard routines.
Note
Unlike WorldScript I, WorldScript II does not support the Script Manager
routines (such as

Set

ScriptUtilityAddress) that allow replacement

of script utilities or QuickDraw calls.

About WorldScript II
The 2-byte script systems developed prior to system software version 7.1 contain their
own code to handle language-speci c text processing. Each also has its own initialization
and con guration code, installing itself at startup and adding its own modi cations to
the system. Each script system patches three different areas of system software:
QuickDraw, the Event Manager, and the script management system. This can result in a

layering of patches to the same traps, inconsistent behavior, and inef cient use of
memory.

WorldScript Il, working with the Text Services Manager and other parts of system
software, eliminates code duplication and provides for the special text-input needs of the
2-byte systems:
m Enhancements to QuickDraw and the Font Manager now support the display of the

thousands of Chinese, Korean, and Japanese characters. To handle a character set that

is larger than the 256-character ASCII range, the Font Manager and other parts of
system software contain the code necessary to retrieve and render the characters.

m The Text Services Manager, using enhancements to the Event Manager, provides broad
support for input methods. Input methods that employ the Text Services Manager
intercept every key-down event, map the event to a character code, and pass the result
to the application.
mw WorldScript II provides language-speci c capabilities for script-aware text-handling
routines called script utilities. For instance, WorldScript II provides routines that tell
whether a byte in a string is a 1-byte or 2-byte character.
WorldScript II rede nes what a 2-byte script system consists of. WorldScript II combines
the executable code for many routines for all 2-byte script systems. Script-speci c

A-36

WorldScript II

APPENDIX

A

Built-in Script Support

behavior is encoded in resource-based tables. This reduces memory requirements for
multiscript systems and avoids layering of patches.

Shared Script Utilities
WorldScript II contains the code for all script utilities. Script-speci_c behavior is
determined by tables in each script@ international resources. In a multiscript
environment, WorldScript II loads only one copy of its code into memory. Furthermore,
the user needs only the WorldScript II le in the Extensions folder, rather than one
extension le per script system. This eases memory requirements and saves disk space.
Table A-11 lists the script utilities implemented by WorldScript H, along with the chapters
in this book that describe their corresponding high-level routines.
Table A-15

— Script utilities supported by WorldScript II

Script utility

Chapter in this book

CharacterByteType

Script Manager

CharacterType

Script Manager

CharToPixel

QuickDraw Text

DrawJustified

QuickDraw Text

FillParseTable

Script Manager

FindScriptRun™

Text Utilities

FindWordBreaks*

Text Utilities

GetScriptVariable'

| Script Manager

HiliteText

QuickDraw Text

MeasureJustified

QuickDraw Text

PixelToChar

QuickDraw Text

PortionLine

QuickDraw Text

SetScriptVariable'

Script Manager

TransliterateText

Script Manager

VisibleLength

QuickDraw Text

NOTE
WorldScript II supports the following script utilities for backward compatibility. They call
newer versions of themselves to handle their tasks. They are: Pixel 2Char (calls PixelToChar),
Char2 Pixel (calls CharToPixel), DrawJust (calls DrawJustified), MeasureJust (calls
MeasureJustified), PortionText (calls PortionLine), CharByte (calls
CharacterByteType), CharType

(calls CharacterType),

ParseTable

FillParseTable), Transliterate (calls TransliterateText).
*

(calls

The Script Manager handles these routines directly if the necessary tables are in the script@ ‘itl2'
resource. Otherwise, they are passed to WorldScript II.
The Script Manager handles these routines directly if the standard selectors documented in this
book are used. The routines are passed to WorldScript II if private selectors are used.

WorldScript II

A-37

APPENDIX

A

Built-in Script Support

Table-Based Script Behavior
Script-speci_c text behavior is controlled by tables in each script systemG@ international
resources. The encoding/rendering resource (type 'it15') contains character encoding
information, and the transliteration resource (type 'trs1') contains information for
character conversion among subscripts of a 2-byte script.
For example, the byte-type table in a script@ encoding /rendering resource typically
contains information about the type of a speci c byte in the range of $00 $FFN whether it
can be the high-order byte of a 2-byte character, the low-order byte of a 2-byte character,
or a 1-byte character. The character-type table in the same resource gives more detailed
information about a character in a particular coding scheme.
Currently, there are two transliteration formats used by WorldScript II and supported by
tables in a script@ transliteration resource. One of them is used to transliterate Jamo to
Hangul (and Hangul to Jamo) in the Korean system. The other is a more general
rule-based transliteration. You cannot customize the Jamo-to-Hangul transliteration. You
can customize the rule-based transliteration by supplying the proper tables in a
transliteration resource.
The encoding /rendering resource and the transliteration resource are described in the
appendix Cnternational ResourcesOin this book.

Initialization Sequence
The startup code for enabling all available 2-byte script systems and script utility routines
is in WorldScript II. WorldScript I is located in the Extensions folder; its le type is
'scri' and its creator is 'doub'.
At system startup, all extension les in the Extensions folder are executed; script
executed before all other extensions.

les are

At startup, WorldScript II does the following:
1. It gets the total number of international bundle ('it1b') resources from the

System Folder.

2. For each bundle resource that belongs to a 2-byte script, WorldScript I
O creates a script record and copies the byte-type table from the script@ encoding /
rendering ('it15') resource into the script record
4 gets handles to all transliteration resources for that script and adds them to the
script record
0 initializes the script@ script record, a private data structure that holds information
and addresses pertinent to that script

A-38

WorldScript II

APPENDIX

A

Built-in Script Support

How Calls Are Dispatched
WorldScript II does not implement all of the script utilities because some of them (such as
Get ScriptManagerVariable) are handled by the script management system itself.
The script utilities that the script management system does not handle are listed in Table
A-11 on page A-26. For those, the script management system passes execution to the
WorldScript II dispatch routine, which in turn uses the script system@ dispatch table to
call the appropriate utility routine in WorldScript II.
When the WorldScript II dispatch routine calls a script utility, it replaces the selector of a
normal script utility call with the address of the script record of the font script. It then
calls the script utility. For instance:
1. In assembly language, when you call CharacterByteType, you typically call it
through a macro in the following way:
subq.w

#2,

move .1
clr.w

SP
textPtr,-(sp)
- (sp)

CharacterByteType
tst.w

(sp) +

2. The CharacterByteType
move .1
$82060010,
ScriptUutil

;

room

for

result.

;
;

push
push

text
text

pointer.
offset.

;

find

out

;

2-byte

character.

;

is

1-byte?

it

whether

it

is

l1-byte

or

macro expands into
- (sp)

;
;

push
call

the selector.
Script Manager

trap.

3. For this example, the stack looks like the following when the trap has been called:
return address

(long) <-- top of stack

routine selector

(long)

text offset

(word)

text pointer

(long)

result

(word)

4. If the Script Manager does not handle the call, it passes the call to the current script@
dispatch routine. The dispatch routine gures out by the value of the routine selector
whether the call is in the range of calls it handles. If it is not, the dispatch routine strips
the stack and returns without doing anything.
5. If the call is in the valid range, the dispatch routine performs these tasks:
1. It gets the address of the WorldScript II version of the script utility from the script@
dispatch table.
2. It gets the address of the script record and replaces the selector on the stack with the
address of the script record.
3. It jumps into the routine.

WorldScript II

A-39

APPENDIX

A

Built-in Script Support

6. So the stack becomes

return address

(long) <-- top of stack

address of script record

(long)

text offset

(word)

text pointer

(long)

result

(word)

The script@ dispatch routine passes the script record to the WorldScript II script utilities
so that they can use the script-speci c information (such as the byte-type tables) in the
script@ international resources.

A-40

WorldScript II

A

PPEN

DIX_~—

B

International Resources

Contents
About the International Resources
B-4
What the International Resources Are
B-4
Script Codes and Resource ID Ranges
__B-6
Using the International Resources
_—_—B-8
International Con guration Resource (Type ‘itlc’)
B-9
The ItlcRecord Data Type
B-10
Script-Sorting Resource (Type ‘itlm’)
B-12
International Bundle Resource (Type ' itlb’)
B-17
The ItlbRecord Data Type
B-18
The ItlbExtRecord Data Type
B-20
Numeric-Format Resource (Type ‘itl0’)
B-22
The IntlORec Data Type
B-23
Long-Date-Format Resource (Type ‘it1’)
B-28
The Intl1Rec Data Type
B-28
The Itl1ExtRec Data Type
B-31
String-Manipulation Resource (Type ‘itl2')
B-34
Resource Header
B-35
The ‘itl2' Sorting Hooks
B-37
The ‘itl2' Tables
B-39
Script Run Table Format — B-40
Supplying Custom Sorting Routines
B-43
Supplying Custom Word-Break Tables
B-44
NBreakTable Format
_—__B-44
How FindWordBreaks Uses the Break Table
B-49
Tokens Resource (Type ‘itl4’)
B-50
The NItl4Rec Data Type
B-51
The Token Table
B-53
The Extension-Fetching Routine
B-54
The Token-String Copy Routine
B-54
The Untoken Table
B-54
Contents

B-1

APPENDIX

B

The Number Parts Table
B-55
The Whitespace Table
B-58
Encoding / Rendering Resource (Type 'itl5')
B-58
Resource Header
B-59
Tables for 1-Byte Script Systems
B-60
Script Con guration Table
—_B-60
Line-Layout Metamorphosis Table
—_B-63
Line-Layout Glyph-Properties Table
—_B-64
Character Expansion Table
B-64
Glyph-to-Character Table
—_B-65
Break-Table Directory
B-66
Script Run Tables
B-67
Kashida Preferences Table
B-68
Feature List Table
B-68
Reordering Table
B-68
Tables for 2-Byte Script Systems
B-68
Byte-Type Table
B-69
Character-Type Table
B-69
Transliteration Resource (Type ‘trsl’)
B-70
Resource Header
B-71
Rule-Based Format — B-72
Table-Based Format
—_B-73
Summary of the International Resources
B-74
PascalSummary _ B-74
Constants
B-74
Data Types
B-75
C Summary
B-80
Constants
B-80
Data Types
B-82

Contents

APPENDIX

B

International Resources

This appendix describes the international resources, which constitute the major portion of
each Macintosh script system. The international resources de ne how a script system
implements its particular writing system and how it allows for language or regional
variations within a writing system.
The Script Manager, the Text Utilities, QuickDraw, and the Font Manager all use the

international resources directly to handle text in various script systems. TextEdit makes
indirect use of information in the international resources through calls to the Script
Manager and other managers.
A text application uses the international resources indirectly whenever it makes a call to a
script-aware routine in QuickDraw, the Text Utilities, or the Script Manager. It can also
access the international resources directly through Script Manager calls, in order to
™ pass a resource handle or pointer as a parameter to a text-handling routine
m extract formatting information from a table within a resource
m™ modify the contents of a resource, to customize text handling

Your most common reason to access the international resources may be to get a handle or
pointer to pass to a text-handling routine. For that task, you do not need the information
in this appendix.
Read this appendix if your application needs information about the internal structure of
one or more international resources. If you need a particular resource table to perform a
speci c operation, such as formatting currencies or dates, extracting number parts, or
converting script-independent tokens to the text of a particular script system, this
appendix shows you where to get the information you need.
Read this appendix also if your application requires a custom localized version of some
text-handling feature. To provide that feature, you can modify one or more of the
international resources and supply that modi ed version with your application or its
documents. In this way, you can localize the formats of numbers, currency, time, dates,

and measurement; you can localize string comparison and word selection; you can
modify the conversion of strings to tokens; you can specify custom character-rendering
behavior; and you can specify custom transliteration rules.
Read this appendix also if you are creating a new script system. A complete script system
requires a full set of the appropriate international resources, certain keyboard resources
(as described in the appendix (Keyboard ResourcesOin this book), and one
or more fonts.
Before reading this appendix, read the chapter Gintroduction to Text on the MacintoshOin
this book. The parts of the Macintosh script management system that make use of the
resources documented here are described in the chapters QQuickDraw Text,OCIext
Utilities, Oand especially Script Manager,Oin this book. The Resource Manager, which
manages all Macintosh resources, is described in Inside Macintosh: More Macintosh Toolbox.

This appendix describes the international resources in general, shows the relationship
between resource ID and script code, shows how to gain access to international resources
and use them, and then describes each resource in detail.

B-3

APPENDIX

B

International Resources

About the International Resources
This section introduces the international resources, describes how the set of international

resources varies among script systems and among different localized versions of
Macintosh system software, and gives a table showing the relationship between script
code and resource ID number used by fonts and by speci c types of international
resources and keyboard resources.

What the International Resources Are
Each script system consists of a set of international resources and a set of keyboard
resources. These resources, possibly in conjunction with the WorldScript I or WorldScript
II extensionN and with the use of the proper fontN completely specify a script@ behavior.
Because script-speci c behavior is segregated into resources that are customizable and
replaceable, your software can potentially use the same routines to handle text in any
language, even one that is not curently supported.
The international resources that de ne individual script systems can include all but two
in the following table. Two of the international resources, the international con

guration

resource and the script-sorting resource, are unique to each Macintosh System
do not belong to any script system.

le; they

Table B-1 lists the international resources and their resource types, and gives a capsule
description of their contents. More complete descriptions follow.
Table B-1

The international resources

Name

Resource
type
'itle'

Con

Script sorting

'itlm'

Sorting order among scripts

International bundle

'itlb'

IDs of all resources for a script system

Numeric format

'it10!

Number, time, and short-date formats

Long-date format

"itll!

Long date formats

String manipulation

'itl2!

Sorting order, word breaks

Tokens

'it14'!

Tables of tokens, number parts

Encoding /rendering

'itl15!

Character encoding or rendering

Transliteration

'trsl'

Tables for phonetic conversion

International con

B-4

guration

About the International Resources

Partial contents
guration of the system

APPENDIX

B

International Resources

m International con guration resource. Sets up the basic con guration for the system,
including the system script. Speci es the system script code and the region code that
identi es the regional version of the system script; initializes the states of the system

direction, the font force fsag, the international resources selection fag, the international

keyboard fag (used for the Macintosh Plus), and the Script Manager general fags.
There is only one 'it1c' resource for each localized version of
system software.

m Script-sorting resource. Speci es the preferred sorting order for script codes, language
codes, and region codes. Also speci es the default language for each script, the parent
script for each language, and the parent language for each region. There is only one
'itlm' resource for each localized version of system software.
m International bundle resource. Sets up the basic con guration for an individual script
system. The international bundle resource speci es the resource IDs for the script@
resources. It also initializes many script variables, such as the script fags, the default
language code, and the numeral and calendar representation codes for the script. The
international bundle resource also speci

es font information, script initialization data,

valid styles for the script, and the style to use for designating aliases. Each script
system has one

=

'it1b'

resource.

Numeric-format resource. Contains short date and time formats, and formats for

currency and numbers and the preferred unit of measurement. It also contains the
region code for this particular resource. A script system can have one or more
'it10'

resources.

m= Long-date-format resource. Speci es the long date format for a particular region,
including the names of days and months. Each long-date-format resource contains the
region code for this particular resource. A long-date-format resource can have an
optional extension for additional month and day names as well as abbreviated month
and day names. A script system can have one or more 'it11' resources.
m String-manipulation resource. Contains routines that control text-sorting behavior, and
tables for character type, case conversion, and word breaks. A script system can have

one or more 'it12' resources.

m Tokens resource. Contains tables and code for converting text to tokens. It also has
tables for formatting numbers, for converting tokens to text, and for determining
whitespace characters. A script system can have one or more 'it14' resources.

m Encoding/rendering resource. Contains either information related to character
encoding, or information controlling text-rendering behavior, in a script-speci c
format. This is an optional resource; a script system can have zero or more
'it15'

resources.

m Transliteration resource. Speci es how to convert characters from one subscript to
another within a script system. This is an optional resource; a script system can have
zero or more

'trsl1'

resources.

About the International Resources

B-5

APPENDIX

B

International Resources

International resources and localized system software
When Macintosh system software is localized for a non-U.S. market, it
contains replacements for or modi cations to some of the U.S. versions
of the international resources. See the discussion of U.S. international
resources and keyboard resources in the appendix (Built-in Script
SupportOfor a list of resources that may be replaced during
localization. @

Script Codes and Resource ID Ranges
Fonts, international resources, and keyboard resources that are related to a particular
script system have resource ID numbers in a range speci c to that script. The script
management system uses this relationship between resource ID and script code to assign
the proper resources for displaying and formatting text. For example, the Script Manager
FontScript,

IntlScript, and FontToScript functions all use a font family ID to

determine the script code that they return. Many other Script Manager, Text Utilities, and
QuickDraw routines that load and use international resources take an explicit or implicit
script code parameter; they will load only resources with ID numbers in the proper range
for the supplied script code.
This numbering convention applies to font family IDs, and to the ID numbers of the
following international and keyboard resources: '1t10', 'it1l1',
'it12','1itl14',
'3t15', 'trsl', 'KCHR', 'itlk', 'kcs#', 'kcs4',and 'kcs8'.

Resources with ID numbers below 16384 ($4000) belong to the Roman script system.
Currently, the script management system uses the following formula to calculate the
script code for resources with ID numbers of 16384 and over:
scriptCode

=

((resourceID

-

16384)

DIV

512)

+

1

The formula allots half of the range of nonnegative ID values to the Roman script system,
and 512 ID numbers (for each resource type) to each other script system, as shown in
Table B-2. Please note that this formula may change in the future; note also that future
script systems may possibly use negative ID values.
Table B-2

Resource ID ranges for each script system

Script system

B-6

Script code

Resource ID range
Decimal

Hexadecimal

Roman

0

2 16383

$0000 $3FFF

Japanese

1

16384 16895

$4000 $41FF

Chinese (Traditional)

2

16896 17407

$4200 $43FF

Korean

3

17408 17919

$4400 $45FF

About the International Resources

APPENDIX

B

International Resources

Table B-2

Resource ID ranges for each script system (continued)

Script system

Script code

Resource ID range

Arabic

17920

18431

$4600

Hebrew

ON
HD
oO

Hexadecimal

18432

18943

$4800 $4FF9

18944

19455

$4A00

19456

19967

$4C00 $4DFF

19968

20479

$4E00 $4FFF

oro

Decimal

20480

20991

$5000 $51FF

20992

21503

$5200 $53FF

Greek
Russian

Right-left symbols
Devanagari
Gurmukhi

$47FF

$4BFF

Gujarati

11

21504

22015

$5400 $55FF

Oriya

12

22016

22527

$5600 $57FF

Bengali

13

22528

23039

$5800 $5FF9

Tamil

14

23040

23551

$5A00

Telugu

15

23552

24063

$5C00 $5DFF

Kannada

16

24064

24575

$5E00 $5FFF

Malayalam

17

24576

25087

$6000 $61FF

Sinhalese

18

25088

25599

$6200 $63FF

Burmese

19

25600

26111

$6400 $65FF

Cambodian

20

26112

26623

$6600 $67FF

Thai

21

26624

27135

$6800 $6FF9

Laotian

22

27136

27647

$6A00

Georgian

23

27648

28159

$6C00 $6DFF

Armenian

24

28160

28671

$6E00 $6FFF

28672

29183

$7000 $71FF

Chinese (Simpli

ed)

$5BFF

$6BFF

Tibetan

26

29184

29695

$7200 $73FF

Mongolian

27

29696

30207

$7400 $75FF

Ethiopian

28

30208

30719

$7600 $77FF

Non-Cyrillic Slavic

29

30720

31231

$7800 $79FF

Vietnamese

30

31232

31743

$7A00

Sindhi

31

31744

32255

$7CO0 $7DFF

32256

32767

$7EOO $7FFF

Uninterpreted symbols

About the International Resources

$7BFF

APPENDIX

B

International Resources

Starting with a script code, you can back-calculate resource ID ranges as follows:
m Scripts with script codes in the range 1 32 have a range of 512 resource ID numbers,
beginning with a number calculated according to this formula:
firstID

=

16384

+

512

*

(script

code

-

1)

m Scripts with script codes in the range 33 64 have a range of 512 resource ID numbers,
beginning with a number calculated according to this formula:
firstID

=

-32768

+

512

*

(script

code

-33)

Note
Some script codes above 32 are not usable because they correspond to
resource ID ranges that are reserved for other purposes. Script codes 33
through 40 are invalid; furthermore, script codes above 48 are currently
unavailable and may become invalid. #
Constants for all de ned script codes are listed in the chapter Script ManagerOin
this book.

Using the International Resources
The Script Manager and the other managers that make up the Macintosh script
management system use the information in the international resources to format dates
and times, nd word boundaries, transliterate text, and determine character type, among
other tasks. Your application indirectly accesses that information when it makes
script-aware calls that rely on the current script system. In addition, you can directly
access an international resource in order to
™ pass a resource handle or pointer as a parameter to a text-handling routine. Many
text-handling calls may take an explicit handle to an international resource; you rst
load the resource with calls to the Script Manager, and then pass its handle as a
parameter to the call.
m extract formatting information from a table within a resource. If you are formatting
currencies, dates, or numbers (without calling the Text Utilities routines that do

formatting for you) , or if you are converting script-independent tokens to the text of a
particular script system, you can load the appropriate resource with calls to the Script
Manager, and then examine its contents for the information you need.
m

provide a modi

ed version of a resource, to customize text handling. You can load the

appropriate resource with calls to the Script Manager, change it, and then save the
changed resource in such a manner that it is used in place of the original resource.

Keep these points in mind when using a script system@ international resources:
m

B-8

You can load the international resources

'it10',

'1t11',

'1t12',or

'1it14'

directly with GetResource or other related Resource Manager routines, but it is not
recommended. If you use a Script Manager call such as Get Int 1Resource instead,

Using the International Resources

APPENDIX

B

International Resources

the Script Manager determines which particular instance of an international resource
to load, given the current font script, the script system@ default preferences, and the
current state of the international resources selection Sag.
m= Remember that most of the script-speci c international resources have ID numbers
within a range unique to their script system. If you are providing resources that add to
or replace a script system@ default resources, make sure that your resources have
resource IDs in the proper range.
m

If the international resources selection Sag is set to TRUE, the international resources

used by several script-aware Text Utilities routines are those of the system script.
However, you can force those routines to use the international resources of the font
script instead by clearing the international resources selection Sag to FALSE. You can
set and clear the international resources selection Sag by using the Script Manager
SetScriptManagerVariable function. See the discussion on determining script
codes in the chapter CScript ManagerOin this book.

m You can use multiple formats for different languages or regions with the same script
system by adding multiple versions of international resources, each having a different
resource ID within the script@ range. You store those international resources in your
application@ or document@ resource fork, where they can override those in the System
le.
For more information, see the discussions of direct access to international resources and

replacing default international resources in the chapter Script ManagerOin this book.
Note
Several international resources have type de nitions that give you direct
access to their components from high-level languages. These de nitions
are documented in this appendix. For other international resources
high-level types are not de ned, and graphic gures show the
structures instead.

International Con

guration Resource (Type ‘itlc’)

The international con guration resource (resource type 'it1c') contains script-related
con guration information for the currently executing version of system software. Only
one 'itlc' resource is provided with each localized version of Macintosh system
software. It is in the System le. Its resource ID is 0.
The Script Manager uses the international con guration resource at startup to
con gure the system and the system script. The resource includes elds that specify these
attributes:
m script code for the system script
m region code for this localized version of system software and the system script
m initial values for the Script Manager general fags
m initial value for the system direction

International Configuration Resource (Type ‘itlc’)

B-9

APPENDIX

B

International Resources

Several Script Manager variables are initialized from this resource. Selectors for the Script
Manager variables are listed in the chapter Script ManagerOin this book.

The ItlcRecord Data Type
The international con guration record (data type It lcRecord) describes the contents of
the international con guration resource.
TYPE

ItlcRecord

RECORD

itleSystem:
itlcReserved:
itlcFontForce:
itlcIntlForce:
itlcOldKybd:
itleFlags:
itlcIconOffset:
itlcIconSide:
itlcIconRsvd:

Integer;
Integer;
SignedByte;
SignedByte;
SignedByte;
SignedByte;
Integer;
SignedByte;
SignedByte;

{system script}
{reserved}
{initial font force flag}
{initial int’l res. flag}
{old keyboard}
{Script Mgr. general flags}
{reserved}
{reserved}
{reserved}

itlcRegionCode:

Integer;

{preferred

itlcSysFlags:
itlcReserved4:

Integer;
ARRAY [0..31]

region

code}

{flags for system globals}
OF SignedByte;
{reserved}

END;

Field descriptions
itlcSystem

The script code de ning the system script. The system script affects
system default settings, such as the default font and the text that
appears in dialog boxes and menu bars, and so forth. Script codes
and their constants are listed in the chapter Script ManagerOin this
book. At startup, this value is copied into the Script Manager
variable accessed through the selector smSysScript.

itlcReserved

Reserved.

itlcFontForce

The initial setting for the font force fsag.

itlcIntlForce

B-10

A value of TRUE ($FF) forces

Roman fonts to be interpreted as belonging to the system script. The
font force 8ag is described in the chapter Script ManagerOin this
book. At startup, this value is copied into the Script Manager
variable accessed through the selector smFont Force.
The initial setting for the international resources selection fag. A
value of TRUE ($FF) forces Text Utilities routines to use the
international resources for the system script, rather than the font
script. The international resources selection fsag is described in the
chapter CScript ManagerOin this book. At startup, this value is
copied into the Script Manager variable accessed through the
selector smInt1Force.

International Configuration Resource (Type ‘itlc’)

APPENDIX

B

International Resources

itlcOldkybd

itlcFlags

The initial setting for the international keyboard {Sag for use by the
Macintosh Plus computer. In addition to the standard Macintosh
Plus keyboard (keyboard type 11), two types of smaller keyboard
without numeric keypad are available: a U.S. version and an
international version. Both have a keyboard type of 3, and the user
uses the Keyboard control panel to indicate which is being used; the
user@ selection is saved in this eld. When TRUE ($FF), this Bag
indicates that the international keyboard is being used. When
FALSE, this fsag indicates that the U.S. keyboard is being used.
The initial settings for the Script Manager general fags. At startup,
this value is copied into the rst (high-order) byte of the Script
Manager variable accessed through the selector smGenFlags.

itlcIconOffset

(reserved).

itlcIconSide

(reserved).

itlcIconRsvd

(reserved).

itlcRegionCode

The region code for this version of system software. It speci es the
region for which the system and system-script resources were
localized. The constants that de ne region codes are also described
in the chapter CScript ManagerOin this book. At startup, this value is
copied into the Script Manager variable accessed through the
selector smRegionCode.

itlcSysFlags

Flags for setting system global variables. Currently only one bit is
de ned; it allows the con guration resource to set the system
direction (left-to-right or right-to-left) at startup. It is bit 15, de ned
by the following constant:
CONST

itlcSysDirection

=

15;

The system global SysDirection is initialized from this value. A
value of 0 for bit 15 sets a system direction of left-to-right

(SysDirection = 0) at startup, whereas a value of 1 for the bit sets

a system direction of right-to-left (SysDirection = $FFFF). You
can access SysDirection through the Script Manager routines
Get SysDirection and SetSysDirection. System direction may
be initially localized to a value appropriate for the system script, but
the user can reset its value at any time if a bidirectional script system
is present.
Note

The itlcSysFlags
eld was formerly the
itlcReserved3
eld.
itlcReserved4

An array of 32 bytes that is reserved for future use.

International Configuration Resource (Type ‘itlc’)

B-11

APPENDIX

B

International Resources

Script-Sorting Resource (Type ‘itlm’)
The script-sorting resource (resource type 'it1m') lists, in preferred sorting order, a
set of script codes, language codes, and region codes. For each listed script system it
de nes the default language; for each listed language it de nes the script system that
language belongs to; and for each listed regional version it describes the language
that region belongs to. The listing may be sparse; not all de ned script, language, and
region codes need appear in the resource. Only one script-sorting resource is provided
with each localized version of Macintosh system software. It is in the System le. Its
resource ID is 0.
One purpose of the script-sorting resource is to aid the sorting of multilanguage lists.
Each individual script system de nes, in its string-manipulation ('i1t12') resource, how
its own strings are sorted; the script-sorting resource de nes how strings in two or more
different scripts (or languages or regions) are ordered. For example, the
string-manipulation resource for the Japanese script system de _ nes the order in which
Japanese strings appear in a sorted list. The script-sorting resource, on the other hand,
de nes whether Japanese strings appear before or after Roman strings in a sorted list.
IMPORTANT

Regardless of the sorting order presented in the script-sorting resource,
text in the system script is always sorted to appear ahead of text in any
other script system. A
Another purpose of the script-sorting resource is to provide a mapping among scripts,
languages, and regions. From information in the resource you can determine all
the languages of a listed script system, and all the regional variations of a listed language.
The script-sorting resource consists of a resource header followed by three tables.
Figure B-1 shows the format of the resource header.

Script-Sorting Resource (Type ‘itlm’)

APPENDIX

B

International Resources

Figure B-1

Format of the script-sorting resource header

Byte

offset
0

>

Version

number

4

Format code

6

Number of offset /ength pairs
Offset to script data table

10

Length of script data table
14

Offset to language data table
18

Length of language data table
22

Offset to region data table
26

Length of region data table
30

(

Variable table data

4

The resource header contains these elements:
m

Version number. The version number of this resource.

m

Format code. A number that identi

es the format of this resource.

= Number of offset/length pairs. The number of data tables in the resource.
m

Offsets to, and lengths of, the de

ned tables for this resource. Offsets are measured

from the beginning of the resource.

Script-Sorting Resource (Type ‘itlm’)

B-13

APPENDIX

B

International Resources

Currently there are three de ned tables in the script-sorting resource: the script data
table, the language data table, and the region data table. The formats of the three tables
are similar, as shown in Figure B-2.

Figure B-2

Byte

offset
0

Script, language, and region data tables in the script-sorting resource

Script data table

Language data table

Maximum script code

2

Default language code

4

~

Script code
pon nnn rrr
ry
Default language code

B
10

14

Number of entries in table

6

Language code
f --- <9 nnn nnn rrr]
Parent script code

8
10

Script code
}----------------------]
Default language code

12

Default script code

4

Number of entries in table

6

Maximum language code

2

{

|. Sorted
script
array

Language code
| ----------------------]
Parent script code

12
14

4

{

4

Region data table
Maximum region code

2

Default language code

4

Number of entries in table

6

>

Region code

8

PL

'

Parent language code

10

Region code
12 |} ----------------------!

Parent language code

14

{

Script-Sorting Resource (Type ‘itlm’)

|. Sorted

region

array

{_

|. Sorted
language
array

APPENDIX

B

International Resources

Each table consists of a header, followed by an array of paired integers. These are the
elds in the script data table, language data table, and region data table, respectively:
m Maximum code. The maximum de ned value for script, language, or region code
listed in this table. Because entries in the table may be sparse (incomplete), this value is
useful for de ning the maximum size of table to construct to hold the information. For
example, a maximum script code of smUninterp means the script data table might
cover any subset of the scripts with codes 0 through 32, but the table does not contain
any script codes above 32.
m Default code. The default language code for unlisted script codes, the default script
code for unlisted language codes, or the default language code for unlisted region
codes. This assures a de ned sorting position for any script, language, or region code,
whether or not it is listed in the resource.
= Number of entries in table. The number of script codes, language codes, or region
codes in this table.
m Sorted array. A list of paired integers, in sorting order:
O For the script data table, it is a script array: a list of script codes in their preferred
sorting order, each paired with (followed by) its default language code.
4 For the language data table, it is a language array: a list of language codes in their
preferred sorting order, each paired with (followed by) the code for its parent script.
4 For the region data table, it is a region array: a list of region codes in their preferred
sorting order, each paired with (followed by) the code for its parent language.
Constants for all de ned script codes, language codes, and region codes are listed in the
chapter Script ManagerOin this book.
Table B-3 lists a sorting hierarchy of scripts, languages, and regions generated from a
sample script-sorting resource. Not all scripts and languages are represented in this list
because region codes do not currently exist for all language codes and script codes.
Table B-3

Sorted scripts, languages, and regions from a script-sorting resource

Script code

Language code

Region code

smRoman

langEnglish

veruUs
verBritain

verAustralia
verIreland
langFrench

verFrance
verFrBelgiumLux

verFrCanada
verFrSwiss
continued

Script-Sorting Resource (Type ‘itlm’)

B-15

APPENDIX

B

International

Resources

Table B-3

Sorted scripts, languages, and regions from a script-sorting resource (continued)

Script code

Language code

Region code

langGerman

verGermany

verGrSwiss
langItalian

verlitaly

langDutch

verNetherlands

langSwedish

verSweden

langSpanish

verSpain

langDanish

verDenmark

langPortuguese

verPortugal

langNorwegian

verNorway

langFinnish

verFinland

langIcelandic

veriIceland

langMaltese

verMalta

langTurkish

verTurkey

langLithuanian

verLithuania

langEstonian

verEstonia

langLettish

verLatvia

langSaamisk

verLapland

langFaeroese

verFaeroelIsl

langCroatian

verYugoCroatian

langPolish

verPoland

langHungarian

verHungary

smGreek

langGreek

verGreece

smCyrillic

langRussia

verRussia

smArabic

langArabic

verArabic

langUrdu

verPakistan

langFarsi

verlIran

smHebrew

langHebrew

verIsrael

smDevanagari

langHindi

veriIndiaHindi

smEastEurRoman

Script-Sorting
Resource (Type ‘itlm’)

APPENDIX

B

International Resources

Table B-3

Sorted scripts, languages, and regions from a script-sorting resource (continued)

Script code

Language code

Region code

smThai

langThai

verThailand

smTradChinese

langTradChinese

verTaiwan

smSimpChinese

langSimpChinese

verChina

smJapanese

langJapanese

verJapan

smKorean

langKorea

verkorea

International Bundle Resource (Type ' itlb')
The international bundle resource (resource type 'it1b') has two purposes. First, it is
the bundle resource for a particular script system: by analogy with the Finder bundle
resource type, it speci es the resource IDs for the other international resources and
keyboard resources used by that script. (See the Finder Interface chapter of Inside
Macintosh: Macintosh Toolbox Essentials for a description of Finder bundle resources.)
Second, the 'it1lb'

resource contains con

guration information for the script.

Several script variables are initialized from this resource. Selectors for the script variables
are listed in the chapter Script ManagerOin this book. If you need to change the initial
values of those variables, you need to change the content of the international bundle
resource itself. For example, to change the initial keyboard layout (script variable
smScriptKeys) for a script system, you would change the value of the itlbKeys eld
of the international bundle resource. The user can makes this change from the Keyboard
control panel; the user can make other changes to the 'it1b' resource from other control
panels, as described under user control of script systems in the chapter Gntroduction to
Text on the MacintoshOin this book.
Each script system has one and only one international bundle resource. The resource ID
of the resource is that script system@ script code. Therefore, once you know the script
code for a particular script system, you can nd all of the script@ default international
and keyboard resources by examining the international bundle resource whose ID equals
that script code. For a list of de ned script codes, see the chapter Script ManagerO
in this book.
The original international bundle resource, de ned by the It lbRecord data type,
was de ned for system software versions earlier than 7.0. The extended 'it1b' record,
de ned by the It lbExtRecord data type, is de ned for system software versions 7.0
and later. It includes the standard international bundle resource and adds extensions.

International Bundle Resource (Type ' itlb’)

B-17

APPENDIX

B

International Resources

The ItlbRecord Data Type
The structure of the standard international bundle resource, de

data type, is as follows:
TYPE

ned by the

It lbRecord

ItlbRecord

RECORD

itlbNumber:
itlbDate:
itlbSort:
itlbFlags:
itlbToken:

Integer;
Integer;
Integer;
Integer;
Integer;

{'itl0'
{'itl1'
{'itl2'
{script
{'itl4'

ID number}
ID number}
ID number}
flags}
ID number}

itlbEncoding:

Integer;

{'it1l5'

ID

itlbLang:
itlbNumRep:
itlbDateRep:
itlbKeys:
itlbIcon:

Integer;
SignedByte;
SignedByte;
Integer;
Integer;

{current language for script}
{current numeral code}
{current calendar code}
{'KCHR' ID number}
{ID of keyboard icon family}

number

(optional) }

END;

Field descriptions
itlbNumber

itlbDate

itlbSort

itlbFlags

The resource ID of the numeric-format ('it10') resource to be used

by this script. The Script Manager initializes the script variable
accessed through the selector smScriptNumber from this eld.

The resource ID of the long-date-format ('it11') resource to be

used by this script. The Script Manager initializes the script variable
accessed through the selector smScriptDate from this eld.
The resource ID of the string-manipulation ('it12') resource to

be used by this script system. The Script Manager initializes
the script variable accessed through the selector smScriptSort
from this eld.

The bit Sags that describe the features of this script system. The
Script Manager initializes the script fSags variable, accessed through
the selector smScriptFlags, from this eld. For example, you can
set the smsfAutoInit bitintheitlbFlags

eld to instruct the

Script Manager to initialize the script system automatically. For
de nitions of the constants that specify the components of the script
Sags word, see the list of selectors for script variables in the chapter
(Script ManagerOin this book.

B-18

International Bundle Resource (Type ' itlb')

APPENDIX

B

International Resources

itlbToken

itlbEncoding

The resource ID of the tokens ('it14') resource to be used by this

script. The Script Manager initializes the script variable accessed
through the selector smScriptToken from this eld.
The resource ID of the encoding /rendering ('1t15') resource to be
used by this script system. The Script Manager initializes the script

variable accessed through the selector smScriptEncoding

from this eld. If there is no encoding /rendering resource for this
script, this eld is set to 0. This eld was reserved in versions of
system software prior to 7.0.

itlbLang

itlbNumRep

The language code specifying the default language for this script.
The Script Manager initializes the script variable accessed through
the selector smScriptLang from this eld. See the chapter CScript
ManagerOin this book for a list of de ned language codes.
The numeral code to be used by this script system. This byte
speci es which types of numerals the script supports. The Script
Manager initializes the high-order byte of the script variable
accessed through the selector smScriptNumDate from this _ eld.
For de nitions of the constants that specify numeral codes, see the
list of selectors for script variables in the chapter CScript ManagerO
in this book.

itlbDateRep

The calendar code to be used by this script system. This byte
speci es which types of calendars the script supports. The Script
Manager initializes the low-order byte of the script variable accessed
through the selector smScriptNumDate from this eld. For
de nitions of the constants that specify calendar codes, see the list of
selectors for script variables in the chapter CScript ManagerOin this
book.

itlbKeys

The resource ID of the preferred keyboard-layout (' KCHR') resource
to be used by this script system. The Script Manager initializes the
script variable accessed through the selector smScriptKeys from
this eld.

itlbIcon

The resource ID of the keyboard icon family (resource types
'kes#', 'kcs4',and 'kcs8') for the default keyboard layout to
be used with this script. The Script Manager initializes the script
variable accessed through the selector smScriptIcon from this
eld. (When loading a keyboard-layout resource, the Script Manager
in fact ignores that variable and looks only for a keyboard icon suite
whose ID matches that of the keyboard-layout resource being
loaded.)

International Bundle Resource (Type ' itlb')

B-19

APPENDIX

B

International

Resources

The ItlbExtRecord Data Type
The extended 'it1b!' record adds font and style information to the standard 'it1b'
record.
Its structure, de ned by the It lbExtRecord data type, is as follows:
TYPE

ItlbExtRecord

=

RECORD

base:
itlbLocalSize:
itlbMonoFond:
itlbMonoSize:
itlbPrefFond:
itlbPrefSize:
itlbSmallFond:
itlbSmallSize:
itlbSysFond:
itlbSysSize:
itlbAppFond:
itlbAppSize:
itlbHelpFond:
itlbHelpSize:
itlbValidStyles:
itlbAliasStyle:

ItlbRecord;
LongInt ;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Style;
Style;

{standard ItlbRecord}
{size of script variables}
{default monospaced font}
{default monospaced size}
{not used}
{not used}
{default small font}
{default small font size}
{default system font}
{default system font size}
{default application font}
{default appl. font size}
{default Help font}
{default Help font size}
{valid styles for script}
{styles to mark aliases}

END;

Field descriptions

base

The standard 'it1b'

itlbLocalSize

The size of the record of script variables for this script system.
(A script system whose smsfAutoInit bitinits itlbFlags eld
is set needs to provide this information for the Script Manager.)

record for this script.

i1ltbMonoFond

The font family ID for the preferred font for monospaced text in this
script system. The Script Manager initializes the high-order word of
the script variable accessed through the selector
smScriptMonoFondSize
from this

itlbMonoSize

B-20

eld.

itlbPrefFond

The default size for monospaced text in this script system. The Script
Manager initializes the low-order word of the script variable
accessed through the selector smScriptMonoFondSize
from
this eld.
This eld is currently unused.

itlbPrefSize

This

eld is currently unused.

International Bundle Resource (Type ' itlb')

APPENDIX

B

International Resources

itlbSmallFond

The font family ID for the default font to display small text in this
script system. The Script Manager initializes the high-order word of
the script variable accessed through the selector

itlbSmallSize

The default size for small text in this script system. The Script
Manager initializes the low-order word of the script variable
accessed through the selector smScriptSmallFondSize
from
this eld.
The font family ID for the preferred system font in this script
system. The Script Manager initializes the high-order word of the
script variable accessed through the selector smSysFondSize from
this eld.

smScriptSmallFondSize from this

itlbSysFond

itlbSysSize

eld.

The default size for the system font in this script system. The Script
Manager initializes the script variable accessed through the selector
smScriptSysFond, and the low-order word of the script variable

accessed through the selector smSysFondSize, from this
itlbAppFond

eld.

The font family ID for the preferred application font in this script
system. The Script Manager initializes the script variable accessed

through the selector smScriptAppFond, and the high-order word

of the script variable accessed through the selector
smScriptAppFondSize, from this

itlbAppSize

eld.

The default size for the application font in this script system.
The Script Manager initializes the low-order word of the script

variable accessed through the selector smScriptAppFondSize
itlbHelpFond

from this eld.
The font family ID for the preferred font for Balloon Help in this
script system. The Script Manager initializes the high-order word of
the script variable accessed through the selector
smScriptHelpFondSize from this

itlbHelpSize

eld.

The default size for the Balloon Help font in this script system.
The Script Manager initializes the low-order word of the script

variable accessed through the selector smScriptHelpFondSize

from this

eld.

itlbValidStyles

A style code that de nes all of the valid styles for this script system.
(In a style code, the bit corresponding to each QuickDraw style is set
if that style is valid for the speci ed script. For example, the extend
style is not valid in the Arabic script system.) The Script Manager
initializes the script variable accessed through the selector

itlbAliasStyle

A style code that de nes the styles to use for displaying alias names
in this script system. For example, in the Roman script system, alias
names are displayed in italics. The Script Manager initializes the

smScriptValidStyles

from this

eld.

script variable accessed through the selector smScriptAliasStyle

from this

eld.

International Bundle Resource (Type ' itlb’)

B-21

APPENDIX

B

International Resources

Numeric-Format Resource (Type ‘itl0')
The numeric-format resource (resource type 'it10') contains general conventions for
formatting numeric strings. It provides separators for decimals, thousands, and lists; it
determines currency symbols and units of measurement; it speci es formats for currency,
times, and short dates (the speci cation of dates in purely numeric representationN for
example, in the U.S. Roman script system the short date for Tuesday, December 3, 1946, is
12/3/46). It also contains the region code for this particular instance of the 'it10'
resource.
Each enabled script system has one or more numeric-format resources. The resource ID
for each one is within the range of resource ID numbers for that script system. The
default numeric-format resource for a script is speci ed inthe itlbNumber eld of the
script@ international bundle (' it1b') resource.
The Text Utilities routines TimeString, LongTimeString, and StringToTime use

information in the numeric-format resource to create time strings and to convert time
strings to internal numeric representations. See the chapter ext UtilitiesOin this book.
The Operating System Utilities function IsMet ric examines the numeric-format
resource to determine the result it returns. See Inside Macintosh: Operating System Utilities.
Each numeric-format resource speci

es the following:

= Number format. The characters to use as the decimal separator, thousands separator,
and list separator.
m Currency format. The currency symbol and its position; whether or not to include
leading unit zero or trailing decimal zero; how to show negative values.
m Short date format. The order of presentation of the day, month, and year elements;
whether or not to include the century and a leading zero for month or days; the
separator for the elements.
m

Time format. Whether or not to present leading zeros for hours, minutes, and seconds;

whether to use a 24-hour time cycle or a 12-hour A.M./P.M. cycle; how to specify a
trailing string (such as a morning or an evening string if a 12-hour time cycle is

being used).

m Unit of measure. Whether or not the metric system should be used.
Table B-4 lists constants that you can use in the numeric-format and long-date-format
resources to specify separators for standard international formats. For example, in the
U.S., slashSymbol1 is the separator for the short date 12/3/46, but in Germany
periodSymbol1 is the separator for the short date 3.12.1946.

B-22

Numeric-Format Resource (Type ‘itl0')

APPENDIX

B

International

Resources

Table B-4

Constants for specifying numeric separators

Constant

Symbol

periodSymbol
commaSymbol

,

semicolonSymbol

;

dollarsignSymbol

$

slashSymbol

/

colonSymbol

IMPORTANT

When it speci

es the order of elements, the numeric-format resource

describes them in terms of storage order, not display order. Using the
information in a numeric-format resource frees you from assuming a
particular memory order for the components of numbers and short
dates. However, the resource does not necessarily specify the left-to-right
order for displaying the components. A

The IntlORec Data Type
You can access the numeric-format resource through the Int 10Rec data type.
TYPE

IntloORec
PACKED

=

RECORD

decimalPt:
thousSep:
listSep:
currSyml1 :

Char;
Char;
Char;
Char;

currSym2:

Char;

currSym3 :

Char;

currFmt :
dateOrder:
shrtDateFmt :
dateSep:

Byte;
Byte;
Byte;
Char;

{currency format flags}
{order of short date elements}
{short date format flags}
{date separator}

timeCycle:

Byte;

{time

timeFmt :
mornstr:

Byte;
PACKED

eveStr:

PACKED

timeSep:
timelSuff:
time2Suff:

Char;
Char;
Char;

Numeric-Format Resource (Type ‘itlO')

{decimal point character}
{thousands separator}
{list separator}
{currency symbol}

cycle:0-23,

0-11,

or

12-11}

{time format flags}
ARRAY[1..4] OF Char;
{trailing }
{ string for first 12-hour cycle}
ARRAY[1..4] OF Char;
{trailing }
{ string for last 12-hour cycle}
{time separator}
{trailing string for morning }
{ part of 24-hour cycle}

B-23

APPENDIX

B

International Resources

time3Suff:

Char;

time4Suff:

Char;

time5Suff:
timeé6Suff:

Char;
Char;

time7Suff:

Char;

time8Suff:

Char;

metricSys:

Byte;

{255

intlOVers:

Integer;

{version

{trailing
{ part of

if

string for afternoon
24-hour cycle}

metric,

0

if

}

not}

information}

END;

“TIntl0Rec;

IntloPtr
IntloHndl

=

“IntloPtr;

Note

A NULL character (ASCII code 0) ina_

eld of type Char means that no

such character exists . The currency symbol and the trailing string for the

24-hour cycle are separated into individual Char elds because of Pascal
packing conventions . All strings include any required spaces. @
Field descriptions
decimalPt

Part of the number format de nition. Thel-byte character that
appears before the decimal representation of a fraction with a
denominator of 10. In the United States, this format is a period. In
several European countries, it is a comma.

thousSep

Part of the number format de nition. The 1-byte character that
separates every three digits to the left of the decimal point. In the
United States, this format is a comma. In several European
countries,
it is a period.

listSep

Part of the number format de nition. The 1-byte character that

separates numbers, as when a list of numbers is entered by the user;

it must be different from the decimal point character. If it@ the same

as the thousands separator, the user must not include the latter in
entered numbers. In the United States, this format is a semicolon. In
the United Kingdom, it is a comma.
currsyml1

Part of the currency format de nition. The initial byte used to
indicate currency. One character is suf

and United Kingdom (£).

currsym2

Part of the currency format de nition. The second byte used to
indicate currency. Two characters are required for France (Fr).

currsym3

Part of the currency format de nition. The third byte used to
indicate currency. Three characters are required for Italy (Li.) and
Germany (DM.).

B-24

cient for the United States ($)

Numeric-Format Resource (Type ‘itl0')

APPENDIX

B

International Resources

currFmt

Part of the currency format de nition. The four least signi cant bits
are unused. The four most signi cant bits are Boolean values. Bit 7
determines whether there is a leading integer zero; for example, a 1
inthis eld speci es a format like 0.23, whereas a 0 speci es .23.
Bit 6 determines whether there are trailing decimal zeros; for
example,alinthis
eld speci es a format like 325.00, whereas a 0

speci es 325. Bit 5 determines whether to use a minus sign or
parentheses to denote a negative currency amount; for example,
alinthis eld speci esa format like 0.45, whereas a0 speci es
(0.45). Bit 4 determines whether the currency symbol trails or leads;
for example, a value of lin this eld speci es a format like the $3.00
used in the United States, whereas a value of 0 speci

3 DM. used in Germany.

es the

You can use the following prede ned constants as masks to set or
test the bits in the currFmt eld:
Constant

Value

Explanation

currSymLead

16

Currency symbol leads

currNegSym

32

Use minus sign for negative

currTrailingZ

64

Use trailing decimal zeros

currLeadingZ

128

—_ Use leading integer zero

Note
You can also apply the currency format@ leading-zero and
trailing-zero indicators to the number format if desired.
dateOrder

Part of the short date format de nition. De nes the order of the
elements (month, day, and year) of the short date format. The order
varies from region to regionN for example, 12/29/72 is a common
order in the United States, whereas 29.12.72 is common in Europe.

You can indicate the order of the day, month, and year with the
following constants:
Constant

Value

Explanation

mdy

0

Month-day-year

dmy

1

Day-month-year

ymd

2

Year-month-day

myd

3

Month-year-day

dym

4

Day-year-month

ydm

5

Year-day-month

Numeric-Format Resource (Type ‘itlO')

B-25

APPENDIX

B

International Resources

shrtDateFmt

Part of the short date format de nition. The ve least signi cant bits
are unused. The three most signi cant bit elds are Boolean values
that determine whether to show the century, and whether to show
leading zeros in month and day numbers. For example, if the rst bit
is set to 1 it speci es a date format like 10/21/1917, and set to 0
speci es the format 10/21/17. The second bit set to 1 speci esa
format like 05/23/84, and set to 0 speci

es the format 5/23/84. The

third bit set to 1 speci es a format like 12/03/46, and set to 0
speci es the format 12/3/46.
To set or test the bits in the shrtDateFmt
following prede ned constants as masks:
Constant

dateSep

timeCycle

Value

eld, you can use the

Explanation

dayLdingZ

32

Show leading zero for day

mntLdingZ

64

Show leading zero for month

century

128

Show century

Part of the short date format de nition. The 1-byte character that
separates the different parts of the date. For example, in the United
States this character is a slash (12/3/46), in Italy it is a hyphen
(3-12-46), and in Japan it is a decimal point (46.12.3).
Part of the time format de nition. Indicates the time cycleN that is,

whether to use 12 or 24 hours as the basis of time, and whether to

consider midnight and noon to be 12:00 or 0:00. You can use the
following prede ned constants to specify the time cycle:
Constant

timeFmt

Value

Explanation

timeCycle24

0

Use 24-hour format

timeCycleZero

1

Use A.M./P.M. format

timeCyclel12

255

Use A.M./P.M. format

(midnight = 0:00)

(midnight and noon = 0:00)

(midnight and noon = 12:00)

Part of the time format de nition. Indicates whether to show leading
zeros in time representation. Bit 5 determines whether there are
leading zeros in seconds; for example, a value of lin this eld
speci

es a format like 11:15:05, whereas a 0 speci

es the format

11:15:5. Bit 6 determines whether there are leading zeros in minutes;
for example, a value of lin this eld speci es a format like 10:05,
whereas a 0 speci es the format 10:5. Bit 7 determines whether there
are leading zeros in hours; for example, a value of

speci

B-26

es a format like 09:15, whereas a O speci

Numeric-Format Resource (Type ‘itl0')

lin this

eld

es the format 9:15.

APPENDIX

B

International Resources

You can use the following prede
or testing bits in the time format
Constant

Value

ned constants as masks for setting
eld:

Explanation

secLeadingZ

32

Use leading zero for seconds

minLeadingZ

64

Use leading zero for minutes

hrLeadingZ

128

Use leading zero for hours

mornsStr

Part of the time format de nition. A string of up to 4 bytes to follow
the time to indicate morning (for example, OAMQ. Typically, the
string includes a leading space.

eveStr

Part of the time format de nition. A string of up to 4 bytes to follow
the time to indicate evening (for example, OPMO. Typically, the
string includes a leading space.
Part of the time format de nition. The 1-byte character that is the
time separator (for example, the colon).

timeSep

timelSuff,
time2Suff, time3Suff, time4Suff

Part of the time format de nition. A trailing string of up to 4 bytes
for the morning part of the 24-hour cycle. For example, the German
string QuhrOcan be stored here.

time5Suff,

time6Suff,

time7Suff,

time8Suff

Part of the time format de nition. A trailing string of up to 4 bytes
for the evening part of the 24-hour cycle. Typically, this string

duplicates the string contained in time1Suff through time4Suff.
For example, the German string QuhrOcan be stored here.
metricSys

The unit-of-measure de

nition. Indicates whether to use the metric

system. If 255, the metric system is used; if 0, metric is not used.
intlOVers

Region code and version number. The code number of the region
that this resource applies to is in the high-order byte, and the version
number of this numeric-format resource is in the
low-order byte.

Numeric-Format Resource (Type ‘itlO')

B-27

APPENDIX

B

International Resources

Long-Date-Format Resource (Type ‘itl1’)
The long-date-format resource (resource type '1t11') contains the long date format for
a particular region, including the names of days and months, the exact order of
presentation of the elements, and the speci cation of whether or not to suppress any
element. (For example, in U.S. format, the long date for 12/3/46 without the name of the

day suppressed is Tuesday, December 3, 1946.) The long-date-format resource also has an
optional extension for additional month and day names as well as abbreviated month
and day names and separators. The extension also speci es the calendar code (for
example, Arabic lunar) to use for long dates.
Each enabled script system has one or more long-date-format resources. The resource ID
for each one is within the range of resource ID numbers for that script system. The
default long-date-format resource for a script system is speci edintheitlbDate eld of
the script@ international bundle (' it 1b') resource.
The Text Utilities routines DateString, LongDateString, and StringToDate use

information in the long-date-format resource to create date strings and to convert date
strings to internal numeric representations. See the chapter ext UtilitiesOin this book.
The basic (unextended) long-date-format resource speci
m

es

The long date format. Month and day names, order of elements, and which elements
to suppress.

m Separator strings. What characters (commonly punctuation) appear between elements
of the date.
m Region code. The number that identi es the regional version of the script system that
this long-date-format resource applies to.
IMPORTANT

When it speci

es the order of elements, the long-date-format resource

describes them in terms of storage order, not display order. Using the
information in a long-date-format resource frees you from assuming a
particular memory order for the components of long dates. However, the
resource does not necessarily specify the left-to-right order for displaying
the components. A

The Intl1 Rec Data Type
You can access the contents of the long-date-format resource through the
Int11Rec data type.

B-28

Long-Date-Format Resource (Type ‘itl1')

APPENDIX

B

International

Resources

TYPE

IntlilRec

PACKED

=

RECORD

{ day names}
{ month names}

days:

ARRAY

[1. .7]

months :

ARRAY

[1 ..12]

suppressDay:

Byte;

lngDateFmt :

{ order of elements}
Byte;
{ leading 0 in day no.?}
Byte;
{abbreviation length}
PACKED ARRAY[1..4]
OF Char;
{separator string }
PACKED ARRAY[1..4]
OF Char;
{separator string }
PACKED ARRAY[1..4]
OF Char;
{separator string}
PACKED ARRAY[1..4]
OF Char;
{separator string}
PACKED ARRAY[1..4]
OF Char;
{separator string }
Integer;
{version & region}
ARRAY[0..0] OF Integer; {flag for extended it11}

OF
OF

Str15;
Str15;

{elements

to

suppress}

Byte;

dayLeading0:
abbrLen:
sto:
stl:
st2:
st3:
st4:

intliVers:
localRtn:
END ;
TYPE

IntliPtr

TYPE

IntliHndl

“Tntl1Rec;

=

=

“IntliPtr;

Field descriptions
days

An array of 7 day names (ordered for days corresponding to Sunday
through Saturday). Each day name may consist of a maximum of 15
characters.

months

An array of 12 month names (ordered for months corresponding to
January through December). Each month name may consist of a
maximum of 15 characters.

suppressDay

A byte that lets you omit any element in the long date. To include
the day name in the long date, you set the eld to 0. To suppress the
day name, set the eld to 255 ($FF).
If the value does not equal 0 or $FF, this eld is treated as bit fags.
You can use the following prede ned constants as masks to set the
appropriate
bits in the suppressDay byte.
Explanation

Constant

Value

supDay

1

Suppress day of month

supWeek

2

Suppress
day name

supMonth

4

Suppress month

supYear

8

Suppress year

Note that a value of 2 is same as a value of $FFin this

Long-Date-Format Resource (Type ‘itl1')

eld.

B-29

APPENDIX

B

International Resources

lngDateFmt

The byte that indicates the order of long date elements. If the byte
value of the eld is neither 0 (which speci es an order of day/
month/year) nor $FF (which speci es an order of month/day/
year), then its value is divided into 4 elds of 2 bits each. The least
signi cantbit eld (bits 0 and 1) corresponds to the rst element in
the long date format, whereas the most signi cant bit eld (bits 6
and 7) speci es the last (fourth) element in the format. You can use
the following prede ned constants to set each bit eld to the
appropriate value.
Constant

Value

longDay

0

Day of the month

Explanation

longWeek

1

Day of the week

longMonth

2

Month

longYear

3

Year

Note that these constants represent values for the 2-bit eld, and are
neither masks nor bit numbers. For example, suppose you wanted
long dates to appear in this order: day of the week, day of the
month, month, and year. You would set the value of longDateFmt

like this:

longDateFmt

:=

longWeek*1
+ LongDay*4
+ longMonth*16
+ longYear*64;
dayLeading0O
abbrLen

sto

B-30

{sets
{sets
{sets
{sets

bits
bits
bits
bits

0
2
4
6

and
and
and
and

1}
3}
5}
7}

If 255 (GFF), speci es a leading zero in a day number. If 0, no leading
zero is included in the day number.
The number of characters to which month and day names should be
abbreviated when abbreviation is desired.
String that precedes (in memory) the rst element in a long date. See
Table B-5 and Figure B-3.

stl

String that separates the rst and second elements in a long date. See
Table B-5 and Figure B-3. This string is suppressed if the rst
element in the long date is suppressed.

st2

String that separates the second and third elements in a long date.
See Table B-5 and Figure B-3. This string is suppressed if the second
element in the long date is suppressed.

st3

String that separates the third and fourth elements in a long date.
See Table B-5 and Figure B-3. This string is suppressed if the third
element in the long date is suppressed.

Long-Date-Format Resource (Type ‘itl1')

APPENDIX

B

International Resources

st4

String that follows the fourth element in a long date. See Table B-5
and Figure B-3. This string is suppressed if the fourth element in the
long date is suppressed.

Table B-5
lngDateFm

Separator positions in long date format

t

Long date format

0

st0O day
name

stl

255

st0O day
name

stl
month

intliVers

day

st2
month
st2

day

st3
year

st4

st3
year

st4

Region code and version number. The code number of the region
that this resource applies to is in the high-order byte, and the version
number of this long-date-format resource is in the low-order byte.
Originally designed to contain a routine that localizes sorting order;
now unused for that purpose. If an extended long-date-format
resource is available (see the next section), this eld contains the
hexadecimal value $A89F as the rst word.

localRtn

Figure B-3 gives two examples of how the Text Utilities routines format dates based on
the elds in the numeric-format resource. The examples assume that the suppressDay
and dayLeadingo
eldscontain 0. Ifthe SuppressDay
eld contains a value of 255, the

formatting routines omit the day and the punctuation indicated in the st1_ eld. If the
dayLeadingo
eld contains a value of 255, the Text Utilities place a 0 before day
numbers less than 10.
Figure B-3

Examples of long date formatting

IngDateFmt

| st0

/st1|st2|

st3/

st4

Sample

result

0

"

rn

ee

Mittwoch,2. February 1985

255

"

re

ee

Wednesday February 1 1985

The Itli ExtRec Data Type
The standard long-date-format resource has several limitations. First, it assumes that
seven day names and 12 month names are suf cient, which is not true for some

calendars. For example, the Jewish calendar can have 13 months in some years. Second,
it assumes that day and month names can be abbreviated by simply truncating them to a
xed length, but this not true in many languages.

Long-Date-Format Resource (Type ‘itl1')

B-31

APPENDIX

B

International

Resources

An optional extension to the long-date-format resource provides additional information
that solves these problems. The Text Utilities routines that generate date strings use
information in the 'i1t11' extension if it is present.
The standard long-date-format resource ends with a variable-length eld (localRtn)
originally intended to be used for code that alters the built-in U.S. sorting behavior. This
eld is no longer needed, because code for changing the sorting behavior is now in the
string-manipulation
('it12') resource.
In existing unextended long-date-format resources, the localRtn eld contains a single
RTS instruction (hexadecimal $4E75). In extended long-date-format resources, the
hexadecimal value $A89F is the

rst wordinthelocalRtn

eld. (This is the

unimplemented trap instruction, which could not have been the rst word of any valid
local routine.) The resource extension follows immediately after that word.

You can access the contents of the '1t11' resource extension through the Itl1ExtRec
data type.
TYPE

Itl1lExtRec

=

RECORD

version:

Integer;

format:

Integer;

calendarCode:

Integer;

extraDaysTableOffset:

LongiInt;

extraDaysTableLength:

LongiInt;

extraMonthsTableOffset:

LongInt;

extraMonthsTableLength:

LongInt;

abbrevDaysTableOffset:

LongInt;

abbrevDaysTableLength:

LongInt;

abbrevMonthsTableOffset:LongInt ;
abbrevMonthsTableLength:LongtInt ;
extraSepsTableOffset:

LongiInt;

{un-extended
tee Ot tie Tt ete Tt tie TE tie St tee TE tien Ot ete Tl ete Tt

Intl1Rec;

7 cate TE ceetien St ote Tt tiene TE

base:

extraSepsTableLength:

LongInt;

tables:

ARRAY[0..0]

Int1l1Rec}

version

number

{format

code}

{calendar

}

code

for

{offset

to

extra

'itl1'}

days

table}
table}

{length

of

extra

days

joffset

to

extra

months

table

months

table

days

table

length

of

extra

offset

to

abbrev.

length

of

abbrev.

days

table

offset

to

abbr.

months

table

length

of

abbr.

months

{offset

to

extra

seps

table}

of

extra

seps

table}

{length
OF

{the

table

Integer;

tables;

variable-length}

END;

Field descriptions

base

A standard (unextended) long-date-format resource.

version

The version

number

in the unextended
the version number.

B-32

Long-Date-Format Resource (Type ‘itl1')

of this extension.

'it11'

Unlike

resource, this

the intl1iVers

eld

eld contains nothing but

APPENDIX

B

International Resources

format
calendarCode

A number that identi es the format of this resource. The current
extended long-date-format resource format has a format code of 0.
Multiple calendars may be available on some systems, and it is
necessary to identify the particular calendar for use with this
long-date-format resource. Constants for the currently de ned
calendars are as follows:
Constant

Value

Explanation

calGregorian

Q

Gregorian calendar

calArabicCivil

1

Arabic civil calendar

calArabicLunar

2

Arabic lunar calendar

calJapanese

3

Japanese calendar

calJewish

4

Jewish calendar

calCoptic

5

Coptic calendar

calPersian

6

Persian calendar

The Script Manager initializes part of the script variable accessed
through the selector smScriptNumDate with the value in this eld.
extraDaysTableOffset

The offset from the beginning of the long-date-format resource to the
extra days table.

extraDaysTableLength

The length in bytes of the extra days table.

extraMonthsTableOffset

The offset from the beginning of the long-date-format resource to the
extra months table.

extraMonthsTableLength

The length in bytes of the extra months table.

abbrevDaysTableOffset

The offset from the beginning of the long-date-format resource to the
abbreviated days table.

abbrevDaysTableLength

The length in bytes of the abbreviated days table.

abbrevMonthsTableOffset

The offset from the beginning of the long-date-format resource to the
abbreviated months table.

abbrevMonthsTableLength

The length in bytes of the abbreviated months table.

extraSepsTableOffset

The offset from the beginning of the long-date-format resource to the
extra separators table.

extraSepsTableLength

The length in bytes of the extra separators table.

tables

The tables that make up the rest of the

Long-Date-Format Resource (Type ‘itl1')

'it11' resource extension.

B-33

APPENDIX

B

International Resources

Each table in the 'it11' resource extension is an array consisting of an integer
count followed by a list of Pascal strings specifying names of days, names of months,
or separators.

m Extra days table. A list of names. This format is for those calendars with more than 7
day names.
mw

Extra months table. A list of names. This format is for those calendars with more than
12 months.

m Abbreviated days table. A table of abbreviations. If the header speci

es an offset to

and length of the abbreviated days table, the Text Utilities routines that create date

strings use this table instead of truncating day names to the number of characters
speci edinthe abbrevLen eld ofthe standard 'it11' resource.
m Abbreviated months table. A table of abbreviations. If the header speci

es an offset to

and length of the abbreviated months table, the Text Utilities routines that create date

strings use this table instead of truncating month names to the number of characters
speci edinthe abbrevLen eld ofthe standard '1t11' resource.

m Extra separators table. A list of additional date separators. When parsing date strings,
the Text Utilities StringToDate and StringToTime functions permit the separators
in this list to be used in addition to the date separators speci ed elsewhere in the
numeric-format and long-date-format resources.

otring-Manipulation Resource (Type ‘itl2')
The string-manipulation resource (resource type '1t12') is used by the Text Utilities
and the Script Manager for de ning and comparing text elements.
The string-manipulation resource contains routines, called sorting hooks, that perform

string sorting; it also contains tables that de ne character type, case conversion, and

word boundaries. The Text Utilities routines IdenticalString,
IdenticalText,
CompareString, and CompareText call the Text Utilities sorting hooks. The Text
Utilities routines CharacterType, FindWordBreaks, LowercaseText,
UppercaseText, StripDiacritics, and UppercaseStripDiacritics, and the

Script Manager function TransliterateText, may make use of tables in the
string-manipulation resource.

By replacing the sorting hooks, you can modify the way string comparisons are made;
by replacing tables in the string-manipulation resource, you can modify how word
boundaries are determined. See the sections Gupplying Custom Sorting RoutinesOon
page B-43, and Gupplying Custom Word-Break TablesOon page B-44, for more
information.

String-Manipulation Resource (Type ‘itl2’)

APPENDIX

B

International Resources

Each enabled script system has one or more string-manipulation resources. The resource
ID for each one is within the range of resource ID numbers for that script system. The
default 'it12' resource for a script is speci ed in the itlbSort eld of the script@
international bundle resource (type 'it1lb').
Note
The resource template used by Rez and DeRez speci esa particular
ordering of code and tables in the string-manipulation resource,
although that order is not required for the resource to be used
correctly.
Each string-manipulation resource contains the following elements:
m header
m string comparison routines (sorting hooks)
m character-type tables (optional)
m case-conversion and stripping tables (optional)
m word break tables
m subscript table (optional)
The string-manipulation resource described in this section is sometimes called the
extended 'it12' resource. Prior to Macintosh system software version 6.0.4, a more
abbreviated 'it12' version was supported. That original'it12' resource consisted of
the header and sorting hooks only. The full resource as documented here is supported by
system software versions 7.0 and later.

Resource Header
The string-manipulation resource header allows you to access the code segments and
tables that make up the resource. All elds in the header are 16-bit words. Each eld
designated as an offset contains the signed offset, in bytes, from the beginning of the
resource to the speci ed code block or table. The header is followed by the actual code
segments and tables, which may be in any order. Figure B-4 shows the structure of
the header.

String-Manipulation Resource (Type ‘itl2’)

B-35

APPENDIX

B

International Resources

Figure B-4

Format of the string-manipulation resource header

Byte
OO

Offset to init hook

MW

Offset to fetch hook

FF

Offset to vernier hook

oOo

offset

Offset to project hook

Offsets to sorting
t— hooks

Itl2 version flag

Offset to type list

14

Offset to class array

16

Offset to uppercase list
Offset to lowercase list

Offset to uppercase strip list

22

Offset to word-selection table

24

Offset to line-break table

26

Offsets to

|__ character type,

conversion, and
word-break tables

Offset to strip list

28

Version

30

Format code

32

Length of init hook

34

Length of fetch hook

36

Length of vernier hook

38

Length of project hook

40

(reserved)

42

Length of exit hook

44

Length of type list

46

Length of class array

48

Length of uppercase list

50

Length of lowercase list

52

Length of uppercase strip list

54

Length of word-selection table

56

Length of line-break table

58

Length of strip list

60

Offset to script run table

62

Length of script run table

String-Manipulation Resource (Type ‘itl2’)

J

20

t—

Na

18

N

Offset to exit hook

12

Size of the code
blocks and tables

Offset and length
[— pairs for additional
tables

APPENDIX

B

International Resources

The header consists of four sections. The rst section contains offsets to the sorting hooks;
the second section contains offsets to tables for character type, case conversion and
diacritical stripping, and word break; the third section contains the lengths of all of the
code blocks and tables; the fourth section contains offset and length pairs for tables to be
added in the future.
m The

rst section of the header contains a version Sag and_

ve offsets to the sorting

hooks: init hook, fetch hook, vernier hook, project hook, and exit hook. The sorting

hooks are string-comparison routines, code segments that control sorting behavior.
The hooks can replace or modify the built-in U.S. sorting behavior, on a
character-by-character basis.
The Itl2 version fsag is a long integer value that describes the format of this
string-manipulation resource. A value of 1 indicates that this string-manipulation
resource is in the system software version 6.0.4 (or newer) format. In versions previous
to 6.0.4, this element contains the offset to the reserved hook, another sorting hook. In
versions previous to 6.0.4, the string-manipulation resource header stops at this point.
m The second section of the resource header contains the following elements:
HO Offsets to the character-type tables: type list, class array.
11 Offsets to the case conversion and diacritical stripping lists: uppercase list,
lowercase list, uppercase strip list, strip list.
C11 Offsets to the word-break tables: word-selection table, line-break table.

O Version number. The version number of this string-manipulation resource.
4 Format code. Contains 0 if the string-manipulation resource header stops at this
point (true for system software version 6.0.4 ); contains 1 if the string-manipulation
resource header has the format shown in Figure B-4 (true for system software
version 7.0 and later).
m The third section of the header contains the lengths of all of the code blocks and tables
for which there are offsets in the rst two sections. The Script Manager requires valid
length values in this section only for those tables that can be accessed through the
Get IntlResourceTable procedure (the word-selection and line-break tables).
m The fourth section contains offset and length pairs for additional tables. The
in this section is used for an optional table (EindScriptTable) de

rst pair

ning characters of

a subscript within a non-Roman script system. It is used by the Script Manager

FindScriptRun function. See Script Run Table FormatObeginning on page B-40. If
this table is not present, the offset and length are 0.

The ‘itl2' Sorting Hooks
The string-manipulation resource contains ve sorting hooks, each of which can modify
the functioning of its equivalent default sorting routine that is built into Text Utilities. If
the sorting hooks are all empty, the default U.S. Roman sorting behavior results. For
example, the 'it12' resource in the version of the Roman script system that has been
localized for the United States contains the built-in sorting behavior and empty hooks.
For other script systems, one or more of the hooks are replaced with actual routines, to
handle characters that need to be sorted differently from the defaultN for example, the

String-Manipulation Resource (Type ‘itl2")

B-37

APPENDIX

B

International Resources

Spanish character combination QrOor the Norwegian O-O Most of the sorting routines
are called in turn for each character in each string of a pair that are being compared. Here
is what each of the routines does:
m Init routine. The init routine prepares two strings for comparison. The Text Utilities
sorting routines compare a pair of strings byte for byte, and pass control to the init
routine as soon as a pair of unequal byte values occur. All the init routine does is check
to see if either of the byte values is the second byte of a 2-byte character (or other
sorting unit, such as GrOin Spanish). If it is, the init routine backs up one byte in the
string, and passes control to the fetch routine.
m Fetch routine. The fetch routine fetches the next sorting unit from each string, taking
into account whether the unit is composed of one or two bytes. Many, though not all,
characters in 2-byte script systems are 2 bytes long. Character combinations in 1-byte
scripts can also be considered as single sorting units during sortingN such as Q@hOin
Spanish and Q1zOin Croatian. For example, consider the second characters in these
two strings:
bcha
bcad

In analyzing the second sorting unit of each string, English versions of the fetch

routine would return @Oin each case. Spanish versions, which combine QOand ChO

into a singular sorting unit @hO would return @hOfor the upper string and QOfor
the lower string.

m Project routine. The project routine de nes the primary sorting position for the
individual sorting unit passed to it. In the example just presented, the English version
of the project routine would give the same result for the second sorting unit of each
string, whereas the Spanish version would give them different values.
Where secondary sorting exists, the project routine QorojectsOeach character into the
sorting position of its equivalent primary character (perhaps uppercase with diacritical
marks stripped). For example, consider the following two strings:
bCadf
Bcdidg
The project routine would give identical results for all the character pairs until passed
the @Oand @O In terms of the project routine, the strings would be sorted as if
they were
BCADF
BCADG

The Text Utilities use the project routine to establish decision characters to be used
later if a primary difference is not available. The rst pair of sorting units that have the
same projected position but are not byte-for-byte identical is saved from this. Those
decision characters are acted upon by the vernier routine.
m Vernier routine. The vernier routine is the tie breaker that determines the sorting order
for strings that are equivalent in terms of primary sorting. It de nes the secondary
sorting position for the sorting unit passed to it. Suppose, in the previous example,
that the strings were
bcadf
bc Cif

B-38

String-Manipulation Resource (Type ‘itl2')

APPENDIX

B

International Resources

Primary equivalence exists between the two strings. The decision characters QuOand
Gare passed in turn to the vernier routine; the vernier routine passes back a sorting
position for each one. The return values determine whether QOsorts before or after
(XE) and thus establish the sorting order for the strings.
m Exit routine. This sorting hook exists to allow for any needed post-processing after the
sorting order for a pair of strings has been determined. It is called just before the Text
Utilities string-comparison routine returns to the caller.
For information on providing custom versions of the sorting hooks, see Supplying
Custom Sorting RoutinesOon page B-43.

The ‘itl2' Tables
The following tables in the string-manipulation resource de ne character and word
features for processing strings.
m Type list. Contains character-type information for each class of character (as speci ed
by the class array) in the script system@ character set. The Script Manager
CharacterType function uses this table. The type list is used by 1-byte script systems
only; character-type information for a 2-byte script system is in that script@ encoding /
rendering ('i1t15') resource.
m Class array. Maps each character in the script system@ character set to a class, which is
used to index into the other character tables in the string-manipulation resource. The
Script Manager CharacterType function uses this table. The class array is used by
1-byte script systems only; character-class information for a 2-byte script system is in
that script@ encoding /rendering ('it15') resource.
m Uppercase list. Used to generate uppercase equivalents for all lowercase characters in
the script system@ character set. For each character class, contains a value to be added
to the character code to convert all characters to uppercase. The Text Utilities
UppercaseText procedure uses this table. The uppercase list is used by 1-byte script
systems only.
m Lowercase list. Used to generate lowercase equivalents for all uppercase characters in
the script system@ character set. For each character class, contains a value to be added
to the character code to convert all characters to lowercase. The Text Utilities
LowercaseText procedure uses this table. The lowercase list is used by 1-byte script
systems only.
m Uppercase strip list. Used to generate uppercase equivalentsN without diacritical
marksN for all characters in the script system@ character set. For each character class,
contains a value to be added to the character code to convert all characters to
uppercase versions without diacritical marks. The Text Utilities
UppercaseStripDiacritics procedure uses this table. The uppercase strip list is
used by 1-byte script systems only.
m Strip list. Used to generate equivalentsN without diacritical marksN for all characters
in the script system@ character set. For each character class, contains a value to be
added to the character code to strip diacritical marks. The Text Utilities
StripDiacritics procedure uses this table. The strip list is used by 1-byte script
systems only.

String-Manipulation Resource (Type ‘itl2’)

B-39

APPENDIX

B

International Resources

m Word-selection table. A table of data type NBreakTable or BreakTable, used by the
Text Utilities FindWordBreaks procedure to nd word boundaries for the purposes
of word selection. See Supplying Custom Word-Break TablesOon page B-44 for a
description of the break-table formats.
m Line-break table. A table of data type NBreakTable or BreakTabl1le, used by theText
Utilities FindWordBreaks procedure to nd word boundaries for breaking lines of
text. The rules governing word boundaries for line breaking are generally somewhat
different from those for word selection.
m Script run table. A data structure used by the Text Utilities FindScriptRun function.

Itis used to nd runs of a subscript, such as Roman, within text of a non-Roman script
system. See the next section.

Script Run Table Format
The script run table is used by the Text Utilities FindScriptRun function.
FindScriptRun locates runs of text that belong to a subscript, such as Roman, within a
single script run. The FindScriptRun function is described in the chapter ext
UtilitiesOin this book.
There are two formats of script run table. The original format, used in versions of system
software earlier than 7.1, consists of a series of byte pairs with the format character code,
script code. The character code is the nal character code in a range of characters that
belongs to the script speci ed by the script code. (The table contains only nal character
codes; the initial character code of a range is assumed to be one greater than the nal
character code in the previous rangeN or 0 for the rst range.) The last pair must
have character code $FF. For example, if the character set encoding for script smSample
were de ned such that $00 7F and $A0 were Roman characters and the remaining
characters were native characters in smSamp1le, the table would appear as follows:
Character
code

Script code

$7F

smRoman

$9F

smSample

$A0

smRoman

$FF

smSample

This simple format is appropriate for script systems whose text can be separated into
Roman or native characters based purely upon character code, and for which other
subscript information (returned inthe variant

eld of the ScriptRunStatus

record

by FindScriptRun) is always 0. For 2-byte script systems, or when the same character
could be designated as either Roman or native (depending on its context), this simple
format is insuf cient.
The newer format for the script run table is used in versions of system software starting
with 7.1. It consists of a header, a state table, and a set of associated tables, similar in

structure to the word-break table of type NBreakTable (described on page B-44). It is
more exible than the old format: for example, it can consider punctuation marks such as

B-40

String-Manipulation Resource (Type ‘itl2’)

APPENDIX

B

International Resources

the period (ASCII code $2E) to be either to Roman or non-Roman, depending upon
whether they are associated with Roman or non-Roman characters in the text. The script
run table format is shown in Figure B-5.
Figure B-5

Format of the script run table header (new format)

Bytes

Flags 1

1

Flags 2

2

Version

2

Length

2

Offset to class table

2

Offset to auxiliary class table | 2
Offset to state table

2

Offset to return table

2

(reserved)

2

The table header has these elements:

Flags 1 and fags 2. The fags are not de ned and should be 0, except that the
high-order bit of the second byte (fsags 2) must be 1 to mark this as a new-format script
run table.
Version. The version number of this script run table format.
Length. The length in bytes of this script run table.
Offset to class table. The offset in bytes from the beginning of the script run table to the
beginning of the class table.
Offset to auxiliary class table. The offset in bytes from the beginning of the script run
table to the beginning of the auxiliary class table.
Offset to state table. The offset in bytes from the beginning of the script run table to the
beginning of the state table.
Offset to return table. The offset in bytes from the beginning of the script run table to
the beginning of the return table.
(reserved). Reserved.

The header is immediately followed by the data of the class table, auxiliary class table,
state table, and return table. The tables have this format and content:

The class table is an array of 256 signed bytes. It assigns class values to 1-byte
characters and works with the auxiliary class table to assign class values for 2-byte
characters. It has the same format as the class table used by the word-break table
described under ONBreakTable FormatObeginning on page B-44.
String-Manipulation Resource (Type ‘itl2")

B-41

APPENDIX

B

International Resources

m The auxiliary class table assigns character classes to 2-byte characters. It has the same
format as the auxiliary class table used by the word-br eak table described under
ONBreakTable FormatObeginning on page B-44.
m The state table is used by FindScriptRun to determine the subscript assignment for
a given character class, accounting for its context. Using the state table,
FindScriptRun starts at a speci ed character, moving forward through the text until
it encounters a subscript boundary.
The state table is shown in Figure B-6. The table begins with a list of words containing
byte offsets from the beginning of the state table to the ro ws Of the state table; this
is followed by a c-by-s byte array, where c is the number of classes (columns) and s is
the number of states (rows). The bytes in this array are stored with the column index
varying most rapidlyN that is, the bytes for the state 0 row precede the bytes for
the state 1 row. There is a maximum of 128 classes and 64 states (including the start
and exit states).
Figure B-6

Script run table state table

Bytes

Offset to state 0 row

2

Offset to state 1 row

2

Offset to state 2 row

2

Offset to state 3 row

2

f

{
Class 0

Class 1

Class2

Class3

Class4

State 0 row

action

action

action

action

action

State 1 row

action

action

action

action

action

State 2 row

action

action

action

action

action

State 3 row

action

action

action

action

action

Each entry in this array is an action code, which speci
mw whether to mark the current offset
m whether to exit
m

B-42

the next state or (if exiting) the exit code

String-Manipulation Resource (Type ‘itl2’)

es

APPENDIX

B

International Resources

The format of an action code is shown in Figure B-7.
Figure B-7

Format of a script run table action code

Mark bit (1 = mark current offset)
[ceabit (1 = exit)

765

0
Next state or
exit code

The return table is a list of script code variant pairs, as shown in Figure B-8. The table
lists possible return values for the FindScriptRun function. Each pair in the table is a
ScriptRunStatus record, as described in the chapter (Text UtilitiesOin this book. The

variant associated with each script code gives subscript information for 2-byte script
systems. When FindScriptRun exits the state table, it has encountered a subscript
boundary; it uses the exit code to index into the return table and determine the script
code of the subscript run it has just exited from.
Figure B-8

Format of the script run table return table

Word
offset

Bytes

0

Script

Variant

2

1

Script

Variant

2

2

Script

Variant

2

{

{

Supplying Custom Sorting Routines
String comparison in a given script system is controlled by routines accessed through the
sorting hooks in the string-manipulation resource. However, there is also a default
sorting behavior built into the Text Utilities, and the sorting hooks are designed to allow
a given script system to use, modify, or replace parts of that default behavior, ona
character-by-character basis. The U.S. version of the Roman script system, for example,
uses the built-in sorting behavior exclusively; its '1t12' resource has only
nonfunctional (empty) sorting hooks. The built-in sorting behavior used by the Text
Utilities is described in the appendix Built-in Script SupportOin this book.

String-Manipulation Resource (Type ‘itl2')

B-43

APPENDIX

B

International Resources

The sorting hooks are described under (ihe ‘itl2' Sorting HooksOon page B-37. You can
supply a replacement string-manipulation resource with nonempty versions of any
sorting hooks, to create sorting behavior more appropriate for your target region.
Note
Even QmptyOsorting hooks cannot be completely empty. All 'it12'
sorting hooks are responsible for setting the condition codes that indicate
whether or not they have taken any sorting action. If these condition
codes have not been set, the Text Utilities uses the default Roman sorting

behavior.

@

For more information on replacing any or all of the sorting hooks, see Macintosh
Technical Note #178, available from Macintosh Developer Technical Support.

Supplying Custom Word-Break Tables
The Text Utilities FindWordBreaks procedure uses state machines and associated tables
in a script@ string-manipulation resource to determine word boundaries and
line breaks.
The FindWordBreaks procedure examines a block of text to determine the
boundaries of the word that includes a speci ed character in the block. Usually,
FindWordBreaks uses different state tables to de ne words for word selection than it
does for line breaking.
To replace the word-selection criteria, you can supply a replacement string-manipulation
resource with a modi ed break table. This section describes the break table and how
FindWordBreaks uses it.

NBreakTable Format
FindWordBreaks uses word-break tables of type NBreakTable, de ned for system
software version 7.0 and later:
TYPE

NBreakTable

=

RECORD

flags1:
flags2:
version:
classTableOff:
auxCTableoff:
backwdTableoOff :
forwdTableoff:
doBackup:
length:

SignedByte;
SignedByte;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;
Integer;

String-Manipulation Resource (Type ‘itl2’)

{break table format flags}
{break table format flags}
{version no. of break table}
{offset to ClassTable array}
{offset to auxCTable array}
{offset to backwdTable array}
{offset to forwdTable array}
{skip backward processing? }
{length of the break table}

APPENDIX

B

International Resources

charTypes:

ARRAY[0..255]

tables:

ARRAY[0..0]

OF
OF

SignedByte;

Integer;

{break

tables}

END;

TYPE

NBreakTablePtr

=

“NBreakTable;

Field descriptions

flags1l

The high-order byte of the break table format Bags. If the high-order

bit of this byte is set to 1, this break table is in the format used by
FindWordBreaks.

flags2

The low-order byte of the break table format fags. If the value in
this byte is 0, the break table belongs to a 1-byte script system; in this
case FindWordBreaks does not check for 2-byte characters.

version

The version number

classTableoff

The offset in bytes from the beginning of the break table to the
beginning of the class table.
The offset in bytes from the beginning of the break table to the
beginning of the auxiliary class table.

auxCTableoff
backwdTableoOff

forwdTableoff
doBackup

of this break table.

The offset in bytes from the beginning of the break table to the
beginning of the backward-processing table.
The offset in bytes from the beginning of the break table to the
beginning of the forward-processing table.
The minimum byte offset into the buffer for doing backward
processing. If the selected character for FindWordBreaks hasa

byte offset less than doBackup, FindWordBreaks

skips backward

length

processsing altogether and starts from the beginning of the buffer.
The length in bytes of the entire break table, including all the

charTypes

The class table. See explanation below.

tables

The data of the auxiliary class table, backward table, and
forward table.

individual tables.

The tables have this format and content:

m The class table is an array of 256 signed bytes. Offsets into the table represent byte
values; if the entry at a given offset in the table is positive, it means that a byte
whose value equals that offset is a single-byte character, and the entry at that offset is
the class number for the character. If the entry is negative, it means that the byte is the
rst byte of a 2-byte character code, and the auxiliary class table must be used to
determine the character class. Odd negative numbers are handled differently from
even negative numbers.
m The auxiliary class table assigns character classes to 2-byte characters. It is used when
the class table determines that a byte value represents the rst byte of a 2-byte
character.

String-Manipulation Resource (Type ‘itl2')

B-45

APPENDIX

B

International Resources

O Here is how the auxiliary class table handles odd negative values from the class
table. If the rst word of the auxiliary class table is equal to or greater than zero, it
represents the default class number for 2-byte character codesN the class assigned to
every odd negative value from the class table. If the rst word is less than zero, it is
the negative of the offset from the beginning of the auxiliary class table to a
rst-byte class table (a table of 2-byte character classes that can be determined from
just the rst byte). The value from the class table is negated, 1 is subtracted from it
to obtain an even offset, and the value at that offset into the

rst-byte class table is

the class to be assigned.
O Here is how the auxiliary class table handles even negative values from the class
table. The auxiliary class table begins with a variable-length word array. The words
that follow the rst word are offsets to row tables. Row tables have the same format
as the class table, but are used to map the second byte of a 2-byte character code to a
class number. If the entry in the class table for a given byte is an even negative
number, FindWordBreaks negates this value to obtain the offset from the
beginning of the auxiliary class table to the appropriate word, which in turn
contains an offset to the appropriate row table. That row table is then used to map
the second byte of the character to a class number.
m The backward-processing table is a state table used by FindWordBreaks for
backward searching. Using the backward-processing table, FindWordBreaks starts at
aspeci ed character, moving backward as necessary until it encounters a word
boundary.
m The forward-processing table is a state table used by FindWordBreaks for forward
searching. Using the forward-processing table, FindWordBreaks starts at one word
boundary and moves forward until it encounters another word boundary.
The backward-processing table and the forward-processing table have the same format,
as shown in Figure B-9. The table begins with a list of words containing byte offsets from
the beginning of the state table to the rows of the state table; this is followed by a c-by-s
byte array, where c is the number of classes (columns) and s is the number of states
(rows). The bytes in this array are stored with the column index varying most rapidlyN
that is, the bytes for the state 1 row precede the bytes for the state 2 row.
Note
There is a maximum of 128 classes and 64 states (including the start and
exit states).

@

String-Manipulation Resource (Type ‘itl2’)

APPENDIX

B

International Resources

Figure B-9

NBreakTable state table

Bytes

Reserved (must be 0)

2

Offset to state 1 row

2

Offset to state 2 row

2

Offset to state 3 row

2

Offset to state 4 row

2

Offset to state 5 row

2

Class 0

Class 1

Class2

Class3

Class 4

State 1 row

action

action

action

action

action

State 2 row

action

action

action

action

action

State 3 row

action

action

action

action

action

State 4 row

action

action

action

action

action

State 5 row

action

action

action

action

action

Each entry in this array is an action code, which speci
mw

whether to mark the current offset

m

the next state, which may be the exit state (state 0)

es

The format of an action code is shown in Figure B-10.
Figure B-10

Format of an NBreakTable

action code

Mark bit (1 = mark current offset)
7

6

1

0

Next state

String-Manipulation Resource (Type ‘itl2')

B-47

APPENDIX

B

International Resources

Table B-6 shows an example of the classes used in a state table. It is taken from the
word-selection table of the U.S. localized version of the Roman script system.
Table B-6

Example of classes for an NBreakTable state table

Class
number

Class name

Used for

0)

break

Everything not included below

1

nonBreak

Nonbreaking spaces

2

letter

Letters, ligatures, and accents

3

number

Digits

4

midLetter

Hyphen

5

midLetNum

Apostrophe (vertical or right single quote)

6

preNum

$£ *

7

postNum

wa

8

midNum

_,U

9

preMidNum

10

blank

Space, tab, null

11

cr

Return

¢

Table B-7 shows an example of the de ned states for a state table. It is taken from the
forward-processing table of the word-selection table of the U.S. localized version of the
Roman script system.
Table B-7

B-48

Example of states for an NBreakTable state table

State
number

Explanation

0

Exit

1

Start, or has detected initial nonBreak sequence

2

Has detected a letter

3

Has detected a number

4

Has detected a non-whitespace character that should stand alone;
now anything but nonBreak generates an exit

5

Has detected preMidNum or preNum;
now anything but number or nonBreak generates an exit

6

Has detected a blank

String-Manipulation Resource (Type ‘itl2’)

APPENDIX

B

International Resources

Table B-7

Example of states for an NBreakTabl1e state table (continued)

State

Explanation

7

Has detected letter followed by midLetter, midLetNum, or preMidNum; now
anything but letter generates an exit

8

Has detected a non-whitespace character followed by nonBreak
(the nonBreak should be treated as non-whitespace)

number

9

Has detected number followed by midNum, midLetNum, or preMidNum;

now anything but number generates an exit

10

Marks current offset, then exits

11

Has detected blank followed by nonBreak
(the nonBreak should be treated as a blank)

How FindWordBreaks Uses the Break Table
FindWordBreaks uses a state machine to determine the word boundaries on either side
of a given character in a text buffer. The state machine must start at a point in the buffer
at or before the beginning of the word that includes that character. If the speci ed
character is suf ciently close to the beginning of the text buffer (controlled by the
doBackupMin parameter in the break table), the state machine simply starts from the
beginning of the buffer. Otherwise, FindWordBreaks uses the backward-processing
table to work backwards from the speci ed character, analyzing characters until it
encounters a word boundary.
Once determined, this starting location is saved as an initial word boundary. From this

point the FindWordBreaks state machine moves forward using the forward-processing
table until it encounters another word boundary. If that word boundary is still before the
speci ed character, its location is saved as the starting point and the state machine is
restarted from that location. This process repeats until the state machine nds a word
boundary that is after the speci ed character. At that point, FindWordBreaks returns
the location of the previously saved word boundary and the current word boundary as
the offset pair de ning the word.
The state machine operates in a similar manner whether moving backward or forward;
any differences in behavior are determined by the tables. The machine begins in the start
state (state 1). It then cycles one character at a time until it

nds a boundary break and

exits. In each cycle, the current character is mapped to a class number, and the character
class and the current state are used as indices into the array of action codes in the state
table. Each action code speci es the next state and whether to mark the current offset.
When the state machine exits, it has encountered a word boundary. The location of the

word boundary is the last character offset that was marked.

String-Manipulation Resource (Type ‘itl2')

B-49

APPENDIX

B

International Resources

Figure B-11 gives two examples of the forward operation of the state machine for word
selection. It shows that an exit may or may not be generated at a hyphen, depending on
the character that follows. It also shows that the marked offset on exit may or may not
include the last character before the exit was generated.
Figure B-11

Forward operation of the state machine for word selection

|
|

|
|

|
|

|
|

|
|

|
|

|
|

|

|

| oo |

|

|

|

|

|

|
-———_>_

Marked
offsets

*

|

*

|

|

|

|

|

|

|

|

Word defined at exit by
marked offsets: “UH”

Exit

|

|

an

|

|

|

|

|

—O

|

|
4.

|

*

Start

|
|___iime

|

|

|
*

|

|

|
*

Start

|

|

|

|

|

|

|

|

*

|
|

|

|
*

|e

|

|

Word defined at exit by

marked offsets: “UH-oh”

*

Exit

Tokens Resource (Type ‘itl4’)
The tokens resource (resource type'it14') contains information needed to convert text
into a series of language-independent tokens. Compilers, interpreters, and other
expression evaluators convert source text to tokens as an initial step in their processing.
The Script Manager Int 1Tokenize function uses information in the tokens resource to
produce tokens from source text.
The tokens resource also contains tables for converting tokens into text, for formatting
numbers, and for determining whitespace characters.
Each enabled script system has one or more tokens resources. The resource ID for each
one is within the range of resource ID numbers for that script system. The default
'it14' resource for a script is speci ed in the itlbToken eld of the script@
international bundle ('it1b')

resource.

Each tokens resource contains the following:
m Header
mw Tokenizing tables and code
m

B-50

Untoken table

Tokens Resource (Type ‘itl4")

APPENDIX

B

International

Resources

= Number parts table
mw Whitespace table
The tokenizing tables and code are used by the Int 1Tokenize function. The untoken
table is used by the Int 1Tokenize function and by applications that want to convert
tokens to strings. The number parts table is used by the Text Utilities number-formatting
routines and by applications that do their own number formatting. The whitespace table
is available for application use.

The Nitl4Rec Data Type
The tokens resource is de ned by the NIt14Rec data type as follows:
TYPE

NItl4Rec

=

RECORD

flags:

Integer;

resourceType:

LongiInt;

resourceNum:

Integer;

version:

Integer;

format :

Integer;

resHeader:

Integer;

resHeader2:

LongInt ;

numTables:

Integer;

mapOffset:

LongInt ;

strOffset:

LongInt ;

fetchOffset:

LongInt ;

unTokenOffset:

LongInt ;

defPartsOffset:

LongInt ;

whtSpListOffset:

LongInt;

resOffset7:

LongInt ;

resOffsets:

LongInt ;

resLengthl1:

Integer;

resLength2:

Integer;

resLength3:

Integer;

unTokenLength:

Integer;

defPartsLength:

Integer;

whtSpListLength:

Integer;

resLength?7:

Integer;

resLengths8:

Integer;

{ reserved}
{ contains 'itl4'}
{ resource ID}
{ version number}
{ format code}
{ reserved}
{ reserved}
{ number of tables}
{offset
{offset
{offset
{offset
{offset
{offset

to
to
to
to
to
to

{ reserved}
{ reserved}
{ reserved}
{ reserved}
{ reserved}
{ length of
{ length of
{ length of
{ reserved}
{ reserved}

token table}
string-copy rtn.}
ext. fetch routine}
untoken table}
number parts table}
whitespace table}

untoken table}
number parts table}
whitespace table}

END;

TYPE
TYPE

NItl4Ptr
NItl4Handle

= “NIt14Rec;
= “NIt1l4Ptr;

Tokens Resource
(Type ‘itl4")

B-51

APPENDIX

B

International Resources

Field descriptions
flags

(reserved)

resourceType

'1t14"'

(the resource type of the tokens resource).

resourceNum

The resource ID number of this tokens resource.

version

The version number of this tokens resource.

format

The format code, a number that identi
resource.

resHeader

(reserved)

es the format of this tokens

resHeader2

(reserved)

numTables

The number

mapOffset

The offset in bytes from the beginning of the resource to the token
table, an array that maps each byte to a token type.
The offset in bytes from the beginning of the resource to the
token-string copy routine, a code segment that creates strings that
correspond to the text that generated each token.
The offset in bytes from the beginning of the resource to the

stroffset

fetchoffset

of tables in this tokens resource.

extension-fetching routine, a code segment that fetches the second

byte of a 2-byte character for the Int 1Tokeni ze function.
unTokenoffset

defPartsOffset

The offset in bytes from the beginning of the resource to the untoken
table, an array that maps token types back to the canonical strings
that represent them.
The offset in bytes from the beginning of the resource to the number
parts table, an array of characters that correspond to each part of a
number format (used primarily by the FormatRecToString and
StringToExt ended functions).

whtSpListOffset

resOffset7
resOffsets8
resLength1l
resLength2
resLength3
unTokenLength
defPartsLength
whtSpListLength

B-52

The offset in bytes from the beginning of the resource to the
whitespace table, a list of all the characters that should be treated
as whitespaceN for example, blank and tab for the Roman
script system.
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
The length in bytes of the untoken table.
The length in bytes of the number parts table.

resLength7

The length in bytes of the whitespace table.
(reserved)

resLength8

(reserved)

Tokens Resource (Type ‘itl4")

APPENDIX

B

International Resources

The Token Table
The 'it14' resource includes the token table, an array of type mapCharTable. The
token table, also called the character-mapping table, maps each possible byte value ina
1-byte character set into a token type. Its format is shown in Figure B-12.
Figure B-12

Byte
offset

Format of the token table

;

$20

/
tokenWhite

Z
$30

$41

4

| tokenNumeric

Z

{

4
tokenAlpha

j

The table consists of 256 bytes. The byte offset of each location in the table represents a
character code: location 0 represents a character code of 0, location 255 represents a
character code of 255. Each location in the table contains a token code that represents the
type of token corresponding to that character code. Constants for all de ned token codes
are listed in the chapter Script ManagerOin this book.
The token table is used to de ne tokens in 2-byte script systems also. Any location in the
table that has a value of 1 represents the rst byte of a 2-byte character. When it
encounters such a byte, the

Int lTokenize

function calls the extension-fetching routine,

described next, which analyzes that byte and the subsequent byte in the source text to
determine what type of token is represented.

Tokens Resource (Type ‘itl4")

B-53

APPENDIX

B

International Resources

The Extension-Fetching Routine
The Int 1Tokenize function uses the extension-fetching routine to retrieve the second
byte of a 2-byte character and determine what type of token should represent it. When
Int1Tokenize encounters a byte value in the source text that is represented bya lin
the token table, Int 1Tokenize calls the extension-fetching routine with register AO
pointing to the second byte of the 2-byte character.
The extension-fetching routine consults internal, script-speci c tables and returns the
token code associated with the byte pair. Int 1Tokenize adds that token to the token
list, and continues processing with the rst byte following the byte pair.

The Token-String Copy Routine
When it creates a token list, the Int l1Tokenize function offers the option of also
returning Pascal strings that are the normalized equivalents of the tokens it generates.
Int1Tokenize uses the token-string copy routine to create those strings and store them
in a canonical format in a string list.
Canonical format means that the string-copy routine converts all numerals into standard
ASCII numbers and converts the decimal separator to a period. For example, it would
convert the Thai number

O%G

Pascal string of '248'.

GsOinto one token, tokenAltNum, with an associated

The Untoken Table
The untoken table provides a Pascal string for any type of xed token. A fixed token is a
token whose representation is unvarying, like punctuation. Alphabetic and numeric
tokens are not xed; specifying the token does not specify the string it represents.
The untoken table contains standard representations for the xed tokens. You can use
it to display the canonical format for any xed token in the script system of the
tokens resource.
The unTokenTable data type describes the format of the untoken table:
TYPE

UntokenTable

=

RECORD

len:
lastToken:

Integer;
Integer;

index:

ARRAY

{length of untoken table}
{maximum token code to be

[0..255]

OF

{offsets

to

{

last

tokens;

Pascal

END;

B-54

UntokenTablePtr

=

“UntokenTable;

UntokenTableHandle

=

“UntokenTablePtr;

Tokens Resource (Type ‘itI4"’)

used}

Integer;

strings

entry

=

for

}

lastToken}

APPENDIX

B

International Resources

Field descriptions

len

The length in bytes of the untoken table.

lastToken
index

The highest token code used in this table (for range-checking).
An array of byte offsets from the beginning of the untoken table to
Pascal stringsN one for each possible token typeN that give the
canonical format for each xed token type. The entries in the array
correspond, in order, to token code values from 0 to last Token.
For example, the offset to the Pascal string for tokenColonEqual
(token code = 39) is found at offset 39 in the array.

The string data directly follows the index array. It is a simple concatenation of Pascal
strings; for example, the Pascal string for the token type tokenColonEqual may consist
of a length byte (of value 2) followed by the characters O: =O

The Number Parts Table
The number parts table contains standard representations for the components of
numbers and numeric strings. The Text Utilities number-formatting routines
StringToExtended and ExtendedToString use the number parts table, along with a
number-format string created by the StringToFormatRec and FormatRecToString
routines, to create number strings in localized formats.

The NumberParts data type de nes the number parts table:
TYPE

NumberParts

=

RECORD

version:

Integer;

data:

ARRAY

pePlus:
peMinus:
peMinusPlus:
altNumTable:

WideCharArr;
WideCharArr;
WideCharArr;
WideCharArr;

reserved:

PACKED

[1..31]

ARRAY[0..19]

{version
OF

of

this

table}

WideChar;

{2-byte number parts}
{positive exp. notation}
{negative exp. notation}
{neg. or pos. exp. }
{alternate digits}
OF

Char;

{reserved}
END ;

TYPE

NumberPartsPtr

version
data

=

“NumberParts;

An integer that speci es which version of the number parts table is
being used. A value of 1 speci es the rst version.
An array of 31 wide characters (2 bytes each), indexed by a set of
constants. Each element of the array, accessed by one of the

constants, contains 1 or 2 bytes that make up that number part. (If
the element contains only one 1-byte character, it is in the low-order
byte and the high-order byte contains 0.) Each number part, then,
may consist of one or two 1-byte characters, or a single 2-byte
character.

Tokens Resource (Type ‘itl4’)

B-55

APPENDIX

B

International Resources

Of the 31 allotted spaces, 15 through 31 are reserved for up to 17
unquoted charactersN special literals that do not need to be enclosed
in quotes in a numeric string. See the discussion of number
formatting in the chapter Clext UtilitiesOin this book for more
information.
These are the de ned constants for accessing number parts in the
data array:

Constant

Value

Explanation

tokLeftQuote

1

Left quote

tokRightQuote

2

Right quote

tokLeadPlacer

3

Spacing leader format marker

tokLeader

4

Spacing leader character

tokNonLeader

5

No leader format marker

tokZeroLead

6

Zero leader format marker

tokPercent

7

Percent

tokPlusSign

8

Plus

tokMinusSign

9

Minus

tokThousands

10

Thousands separator

11

(reserved)

tokSeparator

12

List separator

tokEscape

13

Escape character

tokDecPoint

14

Decimal separator

tokUnquoteds

15

(_ rst unquoted character)

(15 through 31 reserved)
tokMaxSymbols

31

Maximum symbol (for range check)

IMPORTANT

Note that these constants are unrelated to the token-type constants
de ned for the Int lTokenize function. A
pePlus

An array that speci
scienti

es how to represent positive exponents for

c notation. It is a wide character array, an 11-word data

structure de ned by the WideCharArr data type. It contains up to
ten 1-byte or 2-byte number parts for representing positive
exponents.
peMinus

B-56

An array that speci

es how to represent negative exponents for

scienti c notation. It isa wide character array, an 11-word array
de ned by the WideCharArr data type. It contains up to ten 1-byte
or 2-byte number parts for representing negative exponents.

Tokens Resource (Type ‘itl4")

APPENDIX

B

International Resources

peMinusPlus

An array that speci es how to represent positive exponents for
scienti c notation when the format string exponent is negative.
Symbols from this array can be used with the input number string to
the StringToExtended function; they are not for use with the

StringToFormatRec function. The array is a wide character array,
an 11-word array de ned by the WideCharArr data type. It
contains up to ten 1-byte or 2-byte number parts for representing
positive exponents.
A wide character array that speci es the alternate representation of

altNumTable

numerals. The array contains ten character codes, each of which

represents an alternate numeral. If the sms£BODigits bit of the
script-fSags word is set, you should substitute the characters in this
array for the character codes $30

$39 (regular ASCII numerals) in a

string whose token code is tokenAltNum or tokenAltReal.
Alternate numerals and the script fSags word are described with the
list of selectors for script variables in the chapter CScript ManagerO
in this book.
reserved

(reserved for future expansion)

The wide character (data type WideChar) is a format for representing a character that
may be either 1 or 2 bytes long. For a 1-byte character, the high-order (rst) byte in the
record is 0, and the low-order (second) byte contains the character code. For a 2-byte
character, the high-order byte is nonzero.

TYPE
WideChar

=

RECORD

CASE BOOLEAN OF
TRUE:
(a: PACKED ARRAY[0..1]
FALSE:
(b: INTEGER) ;
END ;

OF

Char) ;

{0

= high-order

char}

The wide character array (data type WideCharArr) consists of an integer count followed
by a packed array of wide characters.
TYPE
WideCharArr

size:
data:
END ;

=

RECORD

INTEGER;
PACKED ARRAY[0..9]

{no.
OF

of

entries

-1}

WideChar;

Field descriptions
size

The number

of items in the table minus 1.

data

Up to ten wide characters. If the number part is only a single 1-byte
character, that character is in the low-order byte of the word.

Tokens Resource (Type ‘itl4’)

B-57

APPENDIX

B

International Resources

The Whitespace Table
The whitespace table contains characters that may be used to indicate white space, such
as blanks, tabs, and carriage returns. Figure B-13 shows the format of the whitespace
table. Each entry pointed to by the table is a Pascal string specifying a single whitespace
character (which may be 1 or 2 bytes long). The strings immediately follow the
offset elds.
Figure B-13

Format of the whitespace table

Bytes
Length of whitespace table

2

Number of entries

2

Offset from beginning to first entry

2

Offset from beginning to second entry | 2

Z

V4

Z

First entry (Pascal string)

/

Z

Second entry (Pascal string)

/

{

{

Encoding /Rendering Resource (Type ‘itl5’)
The encoding /rendering resource (resource type '1t15') speci es character encoding or
display behavior in a given script system. The resource has different formats and
functions for 1-byte and 2-byte script systems. In 1-byte script systems, it speci es
character rendering behavior. In 2-byte script systems, it contains byte-type and
character-type information.
The encoding /rendering resource is optional; it does not exist for all script systems. The
Roman script system does not include an '1t15' resource.

B-58

Encoding/Rendering

Resource (Type ‘itl5")

APPENDIX

B

International Resources

The resource ID of an encoding/rendering resource is within the range of resource ID
numbers for that script system. Although more than one encoding/rendering resource
may be associated with a given script system, the script by default uses the resource
speci

edinthe itlbEncoding

eld of its international bundle ('1t1b')

resource.

Resource Header
The header for the encoding /rendering resource is the same for 1-byte and 2-byte script
systems. Its format is general enough to allow new tables to be added in the future. This
is the de nition of the resource-header format:
TYPE

Itl5Record

=

RECORD

versionNumber:

Fixed;

numberOfTables:

Integer;

reserved:

ARRAY[0..2]

OF

Integer;

tableDirectory:

ARRAY[0..0]

OF

TableDirectoryRecord;

END ;

Field descriptions
versionNumber

The version of this

'1t15'

resource.

numberOfTables

The number

reserved
tableDirectory

of tables this resource contains.

(for internal use)

A directory of all the tables in the resource. Each entry in the
directory is a table directory record, with this format:
TYPE

TableDirectoryRecord

=

RECORD

tableSignature:

OSType

reserved:

LongInt ;

tableStartOffset:

LongInt;

tableSize:

LongInt ;

;

END ;

Field descriptions
tableSignature

A 4-byte tag (of type OSType) that identi
record refers to.

reserved
tableStartoffset

tableSize

es the kind of table this

(for internal use)

The number of bytes from the beginning of the resource to the
beginning of the table.
The length of the table, in bytes.

Encoding/Rendering Resource (Type ‘itl5')

B-59

APPENDIX

B

International Resources

Tables for 1-Byte Script Systems
In 1-byte script systems, the encoding/rendering resource speci es character-rendering
behavior. In general, only 1-byte complex script systemsN those that work with the
WorldScript I script extensionN include an encoding /rendering resource. The de ned
table types at this time are
m Scriptcon

guration table

m Line-layout metamorphosis table
m Line-layout glyph-properties table
m Character-expansion table
mw Glyph-to-character table
m Break-table directory
m

FindScriptRun tables

m Feature-list table
m Kashida priorities table
m Reordering table

Script Configuration Table
The script con guration table (OSType = 'info') de nes certain settings that affect the
characteristics of a script system. The table exists so that user preferences for script
con guration can be saved ina preferences le, called the script preferences le, between
system restarts.

The script con

guration table consists of a 6-byte header followed by a set of table

entries, each of which contains a

Set ScriptVariable

selector. The table entries

correspond to script settings that the user can make, typically through a script-system
control panel.
The format of the script con

B-60

Encoding/Rendering

guration table is shown in Figure B-14.

Resource (Type ‘itl5")

APPENDIX

B

International Resources

Figure B-14

Format of the script configuration table

Bytes
—

Version number

2

Reserved

2

Number of entries

:2°

Header —
L

Bytes

Tag

4

/14

Selector

9

y,

Parameter length

4

Parameter

4

f

Z

Entry 1

7
Table —

entries

Z

Entry n

4

Variable data

/ 14

4

QL

The resource header consists of three elements:
m

Version number. The version number

of this resource. The major version number is in

the high-order byte; the minor version number is in the low-order byte.

m Reserved. A 2-byte reserved element.
= Number of entries. The number of entries in the script con

guration table.

The entries immediately follow the header. Each entry has four elements:
m Tag. A 4-byte identi

er of type OSType.

m Selector. A selector to access a script variable through the Script Manager
SetScriptVariable function.

m Parameter length. The length of the parameter to pass to the Set ScriptVariable
function. This value always equals 4, unless this entry refers to variable-length data.
See below.
m Parameter. This element contains the parameter to pass to the SetScriptVariable
function, unless this entry refers to variable-length data. See below.
For most entries in the script con guration table, the tag is 'long', the parameter
length is 4 (the length of a Set ScriptVariable parameter), and the parameter
element contains the Set ScriptVariable parameter. However, a table entry may
reference variable-length data, such as a string representing the name of a script system.

Encoding/Rendering

Resource (Type ‘itl5')

B-61

APPENDIX

B

International Resources

Such data follows the last entry in the table, and its location is speci edN as an offset
from the beginning of the tableN in the parameter element of the table entry that
references it. The data length in bytes is speci ed in the parameter length element of that
table entry.
For example, a Hebrew encoding/rendering resource might have a script con
table with the information shown in Table B-8.
Table B-8

guration

A script configuration table for a Hebrew encoding/rendering resource

Offset

Value

Explanation

00

0x0100

Version number ( rst release = 1.0)

02

O0x0000

(reserved)

04

0x0004

Four tables follow

(The table entries start here)

B-62

06

'long'

The data type is a long

10

0x006

SetScriptVariable

12

Ox0004

Four bytes follow

16

OxFFFF

1 = right-to-left line direction

20

'long'

The data type is a long

24

O0x0008

SetScriptVariable

26

Ox0004

Four bytes follow

30

OxFFFF

1 = right-aligned

34

'long'

The data type is a long

38

Ox000A

SetScriptVariable

40

Ox0004

Four bytes follow

44

OxFFFF

1 =redraw entire line for each character

48

'pstr'

The data type is a Pascal string

52

0x002C

SetScriptVariable

54

O0x0008

The string is 8 bytes long (with length byte and pad)

58

62

Offset from beginning of table to data

62

Ox6,'Hebrew'

The data string

Encoding/Rendering

Resource (Type ‘itl5")

selector

smScriptRight

selector smScriptJust

selector smScriptRedraw

selector smScriptName

APPENDIX

B

International Resources

In this case, the script con guration table causes the execution of four
Set ScriptVariable calls, to set the script@ line direction, alignment, redraw
characteristics, and name.

Each script system generally has two versions of the script con guration table: one in the
encoding /rendering resource and one in a script preferences le in the Preferences folder
within the user@ System Folder. The table in the encoding /rendering resource has an
OSType tag of 'info'; the corresponding table in the preferences le is a resource of
type 'CNFG'. The script preferences leisa leoftype 'pref!' with creator 'univ'.
Both script con guration tables are used at startup. When installing a 1-byte complex
script system, WorldScript I locates the script con guration table in the script@
encoding /rendering resource, and loops through the table for as many times as there are
entries in it, making a Set Script Variable call for each entry. WorldScript I then looks
for a 'CNFG' resource for that script system in the script preferences le, and loops
through that table. Thus a script system is always con gured to its default settings at
initialization, and then those settings are modi ed to refSect any user changes that have
been saved. WorldScript I is described in the appendix (Built-in Script SupportOin
this book.

Line-Layout Metamorphosis Table
The line-layout metamorphosis table (OSType = 'mort') speci esa set of
transformations that the WorldScript I contextual formatting routines can apply to
the glyphs of a font. WorldScript I is described in the appendix (Built-in Script SupportO
in this book.
A transformation can be something simple, such as a ligature, or something complex,
such as a number of changes (ligatures plus ornateness of style plus positioning of glyphs
in a word). These transformations are called text features in the context of the
metamorphosis table. Each text feature can have different settings, or levels of operation.
These are the text features and settings currently supported by the contextual formatting
routines in WorldScript I:
m Ligature formation. Whether to form ligatures and to what extent.
m= Contextual ornateness. Whether to use contextual glyphs and which set of them to use.
m= Noncontextual ornateness. Which of various style and case-substitution options to use.
m Character reordering. Whether or not to reorder characters.
m

Diacritical marks. Whether to show diacritical marks, hide them, or make them

separate glyphs.

The line-layout metamorphosis table is identical in format to the @lyph metamorphosis
tableOdescribed in the currently unpublished document TrueType GX Font Table Formats,
available from Macintosh Developer Technical Support.

Encoding/Rendering Resource (Type ‘itl5")

B-63

APPENDIX

B

International Resources

Line-Layout Glyph-Properties Table
The line-layout glyph properties table (OSType = 'prop') de nes the properties
associated with each glyph ina font. Examples of a glyph@ properties are its line
direction and whether or not it is a space character.
The line-layout glyph properties table is identical in format to the @lyph properties
tableOdescribed in the currently unpublished document TrueType GX Font Table Formats,
available from Macintosh Developer Technical Support.

Character Expansion Table
The character expansion table (OSType = 'c2c#') gives multiple-character equivalents
to compound characters in a script system@ character set. This table expands ligatures
into their component characters, analogous to expanding the Roman ligature O Ointo GO
and GO The contextual formatting routines need the character expansion table
because they are speci cally designed to work with a script system@ fundamental
character codes.
Figure B-15 shows the format of the character expansion table.
Figure B-15

Format of the character expansion table

Bytes
Version

2

Format

2

First character

2

Number of entries — 14

2

Offset to first entry

2

Offsets —

Character entry

LL
=

Z
Z

4
First entry

_*

_-* |

/

Character —|
entries

Bytes

Number of characters
Controlling character
Character codes

1
1
4

9--—-—____________-4-...

4

4

The table has these elements:
m

Version. The version number of this table.

A value of $0100 means version 1.

m= Format. The format code, a number that identi

B-64

Encoding/Rendering Resource (Type ‘itl5')

es the format of this table.

APPENDIX

B

International Resources

m First character. The character code of the
m= Number of entries

rst character to be expanded.

1. The number of entries in this table, as a zero-based count.

m Offsets to entries. The offset from the beginning of the table to each character entry.
The character entries immediately follow the offsets. Because the table always covers a
continuous range of a character set, the character code corresponding to each character
entry is calculated as (_ rst character) + (entry number), where the

numbered 0. Each character entry has these elements:

rst character entry is

m The total number of (expanded) characters in this entry.
m The controlling character, the character whose position is considered equivalent to the
position of the ligature as a whole. By analogy with Roman, the controlling character
in the O Oligature might be considered the CO so that a mouse-down event on the

leading edge of the ligature would translate, after expansion, to a mouse-down event
on the leading edge of the GO
m The character codes of the characters that are the expanded equivalent to the character
code for this entry.
Any character within the range of character codes for this table that does not have an
expanded equivalent has a value of 0 for its offset.

Glyph-to-Character Table
The glyph-to-character table (OSType = 'pamc') maps 2-byte glyph indexes to 1-byte
character codes, or to 1-byte glyph codes in bitmapped fonts whose font layouts do not
exactly correspond to their script system@ character encoding. The glyph-to-character
table is conceptually the opposite of the TrueType character-code mapping table (type
'cmap'). It is used by the WorldScript I contextual formatting routines.
Figure B-16 shows the format of the glyph-to-character table.
Figure B-16

Format of the glyph-to-character table

Bytes
Version

2

Format

2

Platform

2

Script code

Language code

2

2.07

Character code record
‘

Array of

Character code

{

Script code

character
code records

Encoding/Rendering Resource (Type ‘itl5')

B-65

APPENDIX

B

International Resources

The table header has these elements:
m

Version. The version number of this table. A value of $0100 means version 1.

m= Format. The format code, a number that identi

es the format of this table.

m Platform. The computer system this table is designed for. A value of 1 means
Macintosh.
m Script code. The script system of this glyph set.
m Language code. The language of this glyph set.
The table header is followed by an array of character code records. There is one record for
each glyph index, which ranges from zero to a maximum value that can be greater than
$FEF. Each character code record has two elements:
m Character code. The character code corresponding to this glyph code.
m Script code. The script system of the character. For example, most glyphs that map to
low-ASCII characters have a script code of smRoman in their character code record.

Break- Table Directory
The break-table directory (OSType = 'fwrd') provides access to one or more break
tables (of type NBreakTable) for use by the Text Utilities FindWordBreaks procedure.
It consists of a header, followed by entries that give offsets to the break tables, followed
by the break tables themselves. Figure B-17 shows the format of the break-table directory.
Figure B-17

Format of the break-table directory

Bytes
Version

2

Format

2

Number of entries

—

2+" 7

Z Entry for first break table 7
Table —
7

Break —
tables

B-66

at

Encoding/Rendering

Selector

4

Offset to table

4

Length of table

4

]°

—

Z

Bytes

2
;

entries

Table entry

First break table

/

{
Resource (Type ‘itl5")

APPENDIX

B

International Resources

The directory header has these elements:
m

Version. The version number

of this directory. A value of $0100 means version 1.

m

Format. Another type of version number.

=

Number of entries. The number of entries, and therefore the number of break tables, in

this directory.

The table entries consist of three elements each:

m Selector. A number that designates the speci c type of break table referenced by this
entry. The currently de ned values are 0, signifying a table for word selection, and 1,
signifying a table for line-breaking. These are the same default values that may be
passed as break-table pointers to the FindWordBreaks procedure.
m Offset to table. The byte offset from the beginning of the directory to the break table
referenced by this entry.
m Length of table. The length in bytes of the break table referenced by this entry.
The break tables themselves follow the table entries.
Most script systemsCbreak tables are in their string-manipulation (' it 12") resources.
For some 1-byte complex script systems, break tables are in the encoding /rendering
resource so that the Script Manager routines for replacing the WorldScript I script utilities
will function correctly. See the discussions of the

Get ScriptUtilityAddress

and

SetScriptUtilityAddress routines in the chapter Gcript ManagerOin this book,
and the discussion of WorldScript I in the appendix (Built-in Script Support.O

Script Run Tables
Typically, tables to control the Text Utilities FindScriptRun function are in a script
system@ string-manipulation ('it12') resource. For some 1-byte complex script
systems, the script run tables (OSType = 'fstb') are in the encoding/rendering
resource so that the Script Manager routines for replacing the WorldScript I script utilities
will function correctly.
The set of script run tables in the encoding/rendering resource consists of a header
followed by one or more tables. The header has this format:
m

Version number (2 bytes).

m

Format code (2 bytes).

m Chain header (12 bytes). This part of the header is identical in format to the chain
header in the line-layout metamorphosis table (see page B-63).
The header is followed by one or more tables. Each script run table consists of a table
fags element (4 bytes), followed by a table identical to the new-format script run table in
the string-manipulation resource. See CScript Run Table FormatObeginning on page B-40.
For more information, see the discussions of the

Get ScriptUtilityAddress

and

SetScriptUtilityAddress routines in the chapter Gcript ManagerOin this book,
and the discussion of WorldScript I in the appendix (Built-in Script Support.O

Encoding/Rendering

Resource (Type ‘itl5')

B-67

APPENDIX

B

International Resources

Kashida Preferences Table
The kashida preferences table (OSType = 'kash'), used in Arabic versions of the

encoding /rendering resource, maps each glyph code to a kashida priority class. It
speci es which glyphs can have kashida inserted between them, in what priority, when
justifying Arabic text.

Feature List Table
The feature list table (OSType = 'f1st') contains information used to override default

line-layout behaviors (features) speci ed in the metamorphosis table (page B-63). It
includes an array of feature entries, each of which speci es a feature type and a setting
for that feature.

Reordering Table
The reordering table (OSType = 'reor') isa state table that speci es the classes and
states used to reorder glyphs for contextual formatting. The reordering table contains
offsets to three state tables and two arrays of level adjustments. The WorldScript I
contextual formatting routine makes a_ rst pass to resolve ordering of numbers, a second
pass to resolve neutrals (whitespace, number separators, and terminators), and a third
pass (using the values in the level adjustments arrays) to adjust nesting levels for each
glyph. Finally, the routine reorders the line according to the resolved nesting levels.

Tables for 2-Byte Script Systems
In 2-byte script systems, the encoding/rendering resource contains byte-type and
character-type information. The tables immediately follow the directory in the
'it15' header.
A byte-type table contains character-size information about a speci c byte in the range of
$00 to $FF. A character-type table contains detailed information about the character
represented by a speci c byte, given a particular character-encoding scheme.
Table B-9 shows the general structure of a typical encoding /rendering resource for a
2-byte script system.
Table B-9

B-68

Sample encoding/rendering resource for a 2-byte script system

Offset

Value

Explanation

0)

$00010000

Version number ( rst release = 1.0)

4

2

Two tables in this resource

6

$000000000000

(reserved)

12

'btyp'

Tag for byte-type table

16

$00000000

(reserved)

20

30

Offset to the byte-type table

Encoding/Rendering

Resource (Type ‘itl5")

APPENDIX

B

International Resources

Table B-9

Sample encoding/rendering resource for a 2-byte script system (continued)

Offset

Value

Explanation

24

256

Length of the byte-type table

28

'ctyp'

Tag for the character-type table

32

$00000000

(reserved)

36

286

Offset to the character-type table

40

variable

Length of the character-type table

44

Start of byte-type table (256 bytes long)

300

Start of character-type table

Byte-Type Table
A byte-type table has 256 integer entries, one for each possible byte value in the range $00
to $FF. Each byte value is an index into the table. At each byte value, the table entry can
have one of three values, specifying what kind of character or part of a character that byte
value can represent.
m

1-=1-byte character only

m

0-=1-byte character or low-order byte of a 2-bye character

m

1=high-order or low-order byte of a 2-byte character

When processing text sequentially in a buffer, you encounter a 2-byte character@
high-order byte before its low-order byte. Thus you can determine the character
relationship of a given byte (1-byte or 2-byte, high-order or low-order byte) by
determining its byte type and, if necessary, comparing it with the byte type of the
previous byte in the buffer.

Character-Type Table
The character-type table consists of one high-order byte table and a series of low-order
byte tables.
The high-order byte table contains 256 word-length entries. The index position of each
entry represents a high-order byte value. Nonzero entries mark valid high-order bytes of
a 2-byte character. If a given entry is nonzero, it speci es which low-order byte table to
consult to get character-type information.
There are one or more low-order byte tables, each of which can contain either a single

entry or 256 word-length entries. If all low-order bytes for a given high-order byte have
the same character type, the low-order byte QableOfor that high-order byte consists of a
single character-type value. Otherwise, every possible low-order byte is represented by
an index into the table, with an appropriate character-type value at each valid index
position.

Encoding/Rendering Resource (Type ‘itl5")

B-69

APPENDIX

B

International Resources

For example, to nd character-type information for the Japanese character with character
code $EA40, you would examine location $EA in the high-order byte table; it would
indicate the existence of a low-order byte table, and in that table you would examine
location $40. That location would contain information showing that the character is a
2-byte JIS level-2 ideographic character that is part of the main character set.
Character types are discussed under the description of the CharacterType function in
the chapter Script ManagerOin this book.

Transliteration Resource (Type ‘trsl')
The transliteration resource (resource type 'trs1') contains information used by the
Script Manager TransliterateText function, which performs phonetic conversion
among subscripts in 2-byte script systems.
The transliteration resource is optional. Currently, no 1-byte script systems, including the
Roman script system, have transliteration resources. All 2-byte script systems have
transliteration resources.
The resource ID for a transliteration resource is within the range of resource ID numbers
for its script system. There is one transliteration resource for each kind of transliteration
supported by the script system. The name of an individual 'trs1' resource, such as
Qamo to HangulQ speci es the kind of transliteration that the resource performs.
There are two formats for the transliteration resource: one supplies table-based
transliteration from Jamo and Hangul, and vice versa, in the Korean script system; the

other provides a more general rule-based transliteration.

Note
In the Roman script system, and for Roman text within other script
systems, the TransliterateText

function performs case conversion.

The tables that control case conversion are in a script system@
string-manipulation ('it12') resource, not in a transliteration
resource. @

B-70

Transliteration Resource (Type 'trsl')

APPENDIX

B

International Resources

Resource Header
Figure B-18 shows the format of the transliteration resource header.
Figure B-18

Format of the transliteration resource header

Byte

offset
0

Source type

2

Target type

4

Format code

6

Property flag

8

The resource header is the same for both the table-based and the rule-based formats:

m Source type. The type of text to perform the transliteration on. Speci ed by an integer;
the currently de ned mask constants for source type are listed under the discussion of
the TransliterateText function in the chapter Gcript ManagerOin this book.
m Target type. The type of text to convert to. Speci ed by an integer; the currently
de ned target format constants are listed under the discussion of the
TransliterateText function in the chapter @cript ManagerOin this book.
m

Format code.

A number that identi

es the format of this transliteration resource.

m Property Sag.
Abit eld that speci es the kinds of operations to perform on a
piece of text before or after transliteration. These are the currently de ned bits of the
property Gag:
Bit

number
1

2

Operation

Convert all 1-byte characters into 2-byte characters before
performing the transliteration.
Convert all Roman characters to uppercase before performing
the transliteration.

The property Sag is needed because of the complex nature of the Chinese, Japanese, and
Korean character sets, which include 1-byte and 2-byte characters as well as lowercase
and uppercase characters. For example, to transliterate the Roman string CkiOinto 2-byte
Hiragana characters, the two-character string could be interpreted with as many as eight
combinations of 1-byte Roman, 2-byte Roman, uppercase, and lowercase characters.

Transliteration Resource (Type ‘trsl')

B-71

APPENDIX

B

International Resources

To simplify matters the transliteration resource allows you to convert your source text
into a common set of characters before it matches them against the transliteration rules.
So, to translate the Roman string CkiOinto Hiragana, you can rst convert the characters
into their 2-byte equivalents, then convert them into uppercase, and then perform the
transliteration.
Note
In most 2-byte transliteration resources, bits 1 and 2 in the

property fag are set (= 1). The reason for the preliminary conversion
of all source text to 2 bytes is that 2-byte Katakana is a superset of all
the Katakana characters; thus, it is possible to convert all the

1-byte Katakana characters to 2-byte characters but not vice versa.

Rule-Based Format
In the rule-based version of the transliteration resource, the header is followed

immediately by a 2-byte eld containing a count of the number of rules in the resource;
the rules immediately follow the count eld and constitute the remainder of the resource.
This is the de nition of the rule-based resource header:
TYPE

RuleBasedTrslRecord

=

RECORD

sourceType:

Integer;

targetType:

Integer;

formatNumber:

Integer;

propertyFlag:

numberOfRules:

{ {target
{ {target

for

type

for

of

left
right

side

resource}

Integer;

{ transliteration

property

Integer;

{ {number

that

of

rules

of

side

this

END;

{format

type

rule}

of

rule}

flags}

follow}

Figure B-19 shows the format of a rule.
Figure B-19

Format of a transliteration rule

Ne

Lengyh of

rule

Left

side of

rule

Nowe

space

(0x20)

IN

m The length of the rule is a byte that speci
excluding the length byte itself.

B-72

Transliteration Resource (Type 'trsl')

Right

side of

rule

IN

es the actual number of bytes in the rule,

APPENDIX

B

International Resources

m The left side of the rule contains the source pattern, a sequence of one or more
character codes that the TransliterateText function compares to the source string.
If it nds a match, it returns the right side of the rule (the target pattern). The rules are
organized to implement the longest match algorithm, meaning that the longest source
pattern that matches a particular target pattern is the one that is converted. For
instance, the rule
abb

—

hello

takes precedence over the rule
ab

>

hello

Some rules in some versions of the transliteration resource incorporate a look-ahead
feature, in which a particular source pattern is converted to its target pattern only if it is
followed by other speci _c characters. For example, if Orepresents the look-ahead
symbol, the characters preceding it in the left side of the rule are converted to the right
side of the rule only if the characters following QOin the left side of the rule match the
subsequent characters in the input string.
If these are the matching rules:
Left side

Rignt side

albe

A

b

B

Cc

Cc

d[ef

D

£

F

Then if we have the input string
abcdf

the output string will be:
ABCdF

because, in the input string, the characters GocOfollow CaQ but the characters @fOdo not

follow QiO

Table-Based Format
The Jamo-to-Hangul transliteration resource contains a set of conversion tables. The
structure of the tables is private.
Jamo-to-Hangul transliteration is used by the input method supplied with the Korean
script system; see the discussion of input methods in the chapter Gintroduction to Text on
the MacintoshOin this book.

Transliteration Resource (Type ‘trsl')

B-73

APPENDIX

B

International

Resources

Summary of the International Resources
Pascal Summary
Constants

{ Bits

in

the

itlcFlags

itlcShowIcon

7;

{show

itlcDualCaret

= 6;

{use

{ Bits

itlcSysFlags

in

=

byte. }

the

itlcSysDirection

NumberParts

tokLeftQuote

=

tokRightQuote
tokLeadPlacer
=

2;

=

3;

=

tokZeroLead

=
=

tokMinusSign
tokThousands

tokSeparator

-

left/right

or

5;

8;
=

9;

=

tokUnquoteds

{11

is

a reserved

field}

14;
=

tokMaxSymbols

15;
=

31;

curNumberPartsVersion
currSymLead

=

=

1;

{current

version

16;

=

32;

currTrailingZ

=
=

text}

right/left}

13;

tokDecPoint

B-74

direction

}

= 12;

=

currLeadingZ

{system

7;
=

currNegSym

script}

direction

6;

ll

tokPlusSign

tokEscape

one

mixed

4;

tokNonLeader
tokPercent

only

1;
=

hb

tokLeader

if

for

word. }

15;

indices

even

caret

©

{ the

=

icon

dual

64;
128;

Summary of the International Resources

of

NumberParts

record}

zeroCycle
longDay

APPENDIX

B

International

Resources

=
=

longWeek

=

longMonth

1;
=

longYear

2;

=

supDay

=

supWeek

=

{ suppress day of
{ suppress day of
{ suppress month}
{ suppress year}

2;
=

=

4;
8;

dayLdingz
=
=

64;

secLeadingZ

=

32;

=

64;

hrLeadingZ

=

{ Date

Orders

mdy

=

0;

dmy

=

1;

=

2;

myd

=

3;

dym

=

4;

ydm

=

5;

week}

128;

minLeadingZ

ymd

month}

32;

mntLdingZ
century

{year }

3;

1;

supMonth
supYear

{ 0:00 AM/PM format}
{ day of the month}
{ day of the week}
{ month of the year}

1;

0;

128;

}

Data Types
TYPE

ItlcRecord

=

RECORD

itleSystem:
itlcReserved:
itleFontForce:
itlcIntlForce:
itlcOldKybd:
itleFlags:
itlcIconOffset:
itlcIconSide:
itlcIconRsvd:
itlcRegionCode:

Integer;
Integer;
SignedByte;
SignedByte;
SignedByte;
SignedByte;
Integer;
SignedByte;
SignedByte;
Integer;

{default system script}
{reserved}
{default font force flag}
{default intl force flag}
{MacPlus intl keybd flag}
{general flags}
{reserved}
{reserved}
{reserved}
{preferred verXxx code}

itlcSysFlags:

Integer;

{flags

itlcReserved4:

ARRAY [0..31]

OF

for

setting

SignedByte;

system

{for

globals}

future

use}

END;

Summary of the International Resources

B-75

APPENDIX

B

International

Resources

ItlbRecord

=

RECORD

itlbNumber:

Integer;

itlbDate:

Integer;

itlbSort:

Integer;

itlbFlags:

Integer;

itlbToken:

Integer;

itlbEncoding:

Integer;

itlbLang:

Integer;

itlbNumRep:

SignedByte;

itlbDateRep:

SignedByte;

itlbKeys:

Integer;

itlbIcon:

Integer;

END;
ItlbExtRecord

{ itloO id number}
{ itll id number}
{ itl2 id number}
{ Script flags}
{ itl4 id number}
{itl5

ID

#

(optional ;

char

encoding) }

{ current language for script }
{ number representation code}
{ date representation code }
{ KCHR id number}
{ ID# of SICN or kcs#/kcs4/kcs8 family}

=

RECORD
base:

ItlbRecord;

itlbLocalSize:

LongtInt ;

itlbMonoFond:

Integer;

itlbMonoSize:

Integer;

itlbPrefFond:

Integer;

itlbPrefSize:

Integer;

itlbSmallFond:

Integer;

itlbSmallSize:

Integer;

itlbSysFond:

Integer;

itlbSysSize:

Integer;

itlbAppFond:

Integer;

itlbAppSize:

Integer;

itlbHelpFond:

Integer;

itlbHelpSize:

Integer;

itlbValidStyles:

Style;

itlbAliasStyle:

Style;

{ unextended ItlbRecord}
{ Size of script's local record}
{ default monospace FOND ID}
{ default monospace font size}
{ preferred FOND ID}
{ preferred font size}
{ default small FOND ID}
{ default small font size}
{ default system FOND ID}
{ default system font size}
{ default application FOND ID}
{ default application font size}
{ default Help Mgr FOND ID}
{ default Help Mgr font size}
{ set of valid styles for script}
{ style (set) to mark aliases}

END;
IntlORec
PACKED

B-76

=
RECORD

decimalPt:

Char;

thousSep:

Char;

listSep:

Char;

currsyml1 :

Char;

currsym2:

Char;

currsym3:

Char;

currFmt :

Byte;

{ decimal point character}
{ thousands separator character}
{ list separator character}
{ currency symbol}
{currency

Summary of the International Resources

format

flags}

APPENDIX

B

International

Resources

dateOrder:

Byte;

{order

Byte;

{format

dateSep:
timeCycle:
timeFmt :

Char;
Byte;
Byte;

{date separator character}
{specifies time cycle: 0..23, 1..12,
{format flags for each time element}

mornStr:

PACKED

ARRAY[1..4]

if

12-hour

cycle}

eveStr:

PACKED

ARRAY[1..4]

cycle}

Char;
Char;

{trailing string for PM if
{time separator character}
{trailing string for AM if

12-hour

timeSep:
timelSuff:

24-hour

cycle}

time2Suff:

Char;

time3Suff:

Char;

time4Suff:

Char;

time5Suff:

Char;

{trailing

cycle}

timeé6Suff:

Char;

time7Suff:

Char;

time8Suff:

Char;

metricSys:

Byte;

intlOVers:

Integer;

shrtDateFmt

:

of

short

flags

{trailing

{255

if

date
for

OF

string

for

OF

mdy,
date

dmy,

etc.}

element}

or

0..11}

AM

Char;

string

code

short

Char;

metric,

{region

elements:

each

0

(hi

for

PM

if

24-hour

if

inches

etc.}

byte)

and

version

(lo

byte) }

END;

IntloPtr = “Intl0Rec;
IntloHndl = “IntloPtr;
Intl1lRec
PACKED

=

RECORD

days:

ARRAY[1..7]

OF

Str15;

{day

months:

ARRAY [1..12]

OF

Str15;

{month

suppressDay:

Byte;

IngDateFmt :

{255
Byte;

dayLeading0O:
abbrLen:
sto:

PACKED

for

names}

no day, or flags to
{order of long date

suppress any
elements}

Byte;

{255

in

Byte;

{length

for

ARRAY[1..4]

leading
for

OF

{separator

strings

PACKED

ARRAY[1..4]

OF

Char;

PACKED

ARRAY[1..4]

OF

Char;

Sst3:

PACKED

ARRAY[1..4]

OF

Char;

st4:

PACKED

ARRAY[1..4]

OF

Char;

intliVers:

Integer;

{region

(hi

ARRAY [0..0]

{a

OF

flag

Summary of the International Resources

day

element}

number}
names}

Char;

Sst2:

code

0

abbreviating

stl:

localRtn:

names}

byte)

for

and

long

date

format}

version

(lo

byte) }

Integer;

for

optional

extension}
B-77

APPENDIX

B

International

Resources

END;
Intl1iPtr

=

IntliHndl

“Intl1Rec;
=

Itl1lExtRec

“IntliPtr;
=

RECORD

base:

Intl1Rec;

version:

Integer;

format:

Integer;

calendarCode:

Integer;

extraDaysTableOffset:

LongInt;

extraDaysTableLength:

LongInt;

extraMonthsTableOffset:

LongInt;

extraMonthsTableLength:

LongInt;

abbrevDaysTableOffset:

LongInt;

abbrevDaysTableLength:

lLongInt;

{ {un-extended Int1l1Rec}
{ ,version number }
{ {format code}
{ {calendar code for 'itl1'}
{ {offset to extra days table}
{length

of

extra

days

{offset

to

extra

months

table

{length

of

extra

months

table

{ offset

to

abbrev.

days

{
{ offset
{ length
{ {offset

of

abbrev.

days

length

abbrevMonthsTableOffset:LongInt ;
abbrevMonthsTableLength:LongtInt ;

extraSepsTableOffset:

Longint;

extraSepsTableLength:

LongInt;

tables:

ARRAY [0..0]

{the

END ;
NItl4Rec

{length
OF

table}

}
}
table }
table }
table }
table }

to

abbr.

months

of

abbr.

months

to

extra

seps

table}

of

extra

seps

table}

Integer;

tables;

variable-length}

=

RECORD

B-78

flags:

Integer;

{reserved}

resourceType:

LongInt;

{contains

resourceNum:
version:
format:
resHeader:
resHeader2:
numTables:
mapOffset:
strOffset:

Integer;
Integer;
Integer;
Integer;
LongInt;
Integer;
LongInt;
LongInt;

{resource ID}
{version number}
{format code}
{reserved}
{reserved}
{number of tables, one-based}
{table that maps byte to token}
{routine that copies string}

fetchoffset:

LongInt;

{routine

unTokenOffset:

LongiInt;

{table

that

maps

defPartsOffset:

LongiInt;

{offset

to

default

whtSpListOffset:
resOffset7:
resOffsets:
resLengthl:
resLength2:

LongInt;
LongInt;
LongInt;
Integer;
Integer;

{offset to
{reserved}
{reserved}
{reserved}
{reserved}

Summary of the International Resources

'itl4'}

to

get

next

byte

token

to

number

whitespace

of

character}

string}
parts

table}

table}

APPENDIX

B

International

Resources

resLength3:
unTokenLength:
defPartsLength:
whtSpListLength:
resLength7:
resLengths:

Integer;
Integer;
Integer;
Integer;
Integer;
Integer;

END ;

{reserved}
{ length of
{ length of
{ length of
{reserved}
{reserved}

untoken table}
number parts table}
whitespace table}

NItl4Ptr = “NItl4Rec;
NItl4Handle = “NIt14Ptr;
UntokenTable

=

RECORD
len:

Integer;

lastToken:

Integer;

index:

ARRAY

[0..255]

OF

Integer;

{index

table;

last=lastToken}

high

order

character}

END;

UntokenTablePtr

“UntokenTable;

UntokenTableHandle

=

WideChar

=

CASE

“UntokenTablePtr;

RECORD

Boolean

OF

TRUE:

(a:

PACKED

ARRAY[0..1]

OF

Char);{0

is

the

FALSE:

(bo:

Integer) ;

END;
WideCharArr

=

RECORD

size:

Integer;

data:

PACKED

ARRAY[0..9]

OF

WideChar;

END;
NumberParts

=

RECORD

version:

Integer;

data:

ARRAY
[1. .31]

pePlus:

WideCharArr;

peMinus:

WideCharArr;

peMinusPlus:

WideCharArr;

altNumTable:

WideCharArr;

reserved:

PACKED

OF

WideChar;

ARRAY[0..19]

OF

Char;

END;
NumberPartsPtr

“NumberParts;

Summary of the International Resources

B-79

APPENDIX

B

International

Resources

Itl5Record

=

RECORD

versionNumber

Fixed;

{itl5

resource

version

numberOfTables:

:

Integer;

{number

of

it

reserved:

ARRAY

[0..2]

OF

ARRAY[0..0]

number}
contains}

Integer;

{reserved
tableDirectory:

tables

OF

for

internal

use}

TableDirectoryRecord;

{table

directory

records}

END;
TableDirectoryRecord
RECORD

tableSignature:
reserved:
tableStartOffset:
tableSize:

OSType ;
LongInt ;
LongInt ;
LongInt ;

{4 byte long table name}
{reserved for internal use}
{table start offset in bytes}
{table size in bytes}

END;
RuleBasedTrslRecord

=

RECORD
sourceType:

Integer;

{target

type

for

left

targetType:

Integer;

{target

type

for

right

formatNumber:

Integer;

{transliteration

resource

format

propertyFlag:

Integer;

{transliteration

property

flags}

numberOfRules:

Integer;

{Number

following

this

of

rules

side

of

side

rule}

of

rule}

number}

field}

END;

C Summary
Constants
enum
/*

{

Bits

in

the

itlcShowIcon
itleDualCaret

/*

Bits

in

the

itlcFlags
=

7,
=

*/
/*show

6,

/*use

itlcSysFlags

itlcSysDirection

B-80

byte.

=

15,

word.

icon
dual

even

if

only

caret

for

mixed

one

script*/

direction

text*/

*/

/*System

Summary of the International Resources

direction--left/right

or

right/left*/

/*

the

APPENDIX

B

International

Resources

NumberParts

tokLeftQuote

=

indices

tokRightQuote

=

2,

tokLeadPlacer

=

3,

tokLeader

=

4,

tokNonLeader

=

tokZeroLead

=

tokPercent

=

tokPlusSign

5,

6,
7,

=

8,

tokMinusSign

=

9,

tokThousands

=

10,

=

12,

tokSeparator
tokEscape

*/

1,

=

/*11

is

a

reserved

field*/

13,

tokDecPoint

=

tokUnquoteds

14,
=

tokMaxSymbols

15,
=

31,

curNumberPartsVersion

=

1

/*current

version

of

NumberParts

record*/

bi
enum

{

currSymLead

=

currNegSym

16,

=

32,

currTrailingZ

=

currLeadingZ

=

64,
128,

bi
enum

{mdy,dmy, ymd,myd,dym, ydm} ;

enum

{

zeroCycle
longDay

=
=

longWeek

0,
=

1,

longMonth

supWeek
supMonth
supYear

of

the

month*/

/*day

of

the

week*/

/*suppress

day

of

month*/

/*suppress

day

of

week*/

4,

/*suppress

month*/

8,

/*suppress

year*/

=

dayLdingz

/*year*/

32,

mntLdingZ
century

/*day

year*/

2,

=

format*/

the

3,

1,
=

AM/PM

/*month

2,

=
=

/*0:00

of

=

longYear
supDay

1,

=
=

secLeadingZ

64,

128,
=

32,

Summary of the International Resources

B-81

APPENDIX

B

International

Resources

minLeadingZ
hrLeadingZ

=
=

64,
128

bi
Data Types
typedef

unsigned

char

DateOrders;

struct

ItlcRecord

{

short

itlcSystem;

/*default

/*reserved*/

system

script*/

short

itlcReserved;

char

itlcFontForce;

/*default

font

char

itlcIntlForce;

/*default

char

itlcOldKybd;

/*MacPlus

char

itlcFlags;

/*general

flags*/

short

itlcIconOffset;

force

flag*/

intl

force

flag*/

intl

keybd

flag*/

/*reserved*/

char

itlcIconSide;

/*reserved*/

char

itlcIconRsvd;

/*reserved*/

short

itlcRegionCode;

/*preferred

verXxx

short

itlcSysFlags;

/*flags

for

setting

/*for

future

use*/

char

itlcReserved4
[32] ;

code*/

system

globals*/

bi
typedef

struct

ItlcRecord

ItlcRecord;

struct

ItlbRecord

{

short

itlbNumber;

/*itloO

id

number*/

short

itlbDate;

/*itll1

id

number*/

short

itlbSort;

/*itl2

id

short

itlbFlags;

/*Script

short

itlbToken;

/*itl4

id

number*/

short

itlbEncoding;

/*itl5

ID

#

number*/
flags*/

(optional;
for

encoding)*/

short

itlbLang;

/*current

char

itlbNumRep;

/*number

char

itlbDateRep;

/*date

representation

short

itlbKeys;

/*KCHR

id

number*/

short

itlbIcon;

/*ID

of

SICN

or

kcs#/kces4/kes8

System

7

*/

#

language

char
script

representation

*/

code*/
code

*/

bi
typedef
/*

struct

ItlbRecord

ItlbRecord;

New

ItlbExtRecord

structure

struct

ItlbExtRecord

{

ItlbRecord

long

B-82

base;

itlbLocalSize;

for

/*unextended
/*size

of

ItlbRecord*/

script's

Summary of the International Resources

local

record*/

family.*/

APPENDIX

B

International

Resources

short

itlbMonoFond;

/*default

monospace

FOND

ID*/

short

itlbMonoSize;

/*default

monospace

font

size*/

short

itlbPrefFond;

/*preferred

Short

FOND

/*preferred

itlbPrefSize;

font

ID*/
size*/

short

itlbSmallFond;

/*default

small

FOND

ID*/

short

itlbSmallSize;

/*default

small

font

size*/

short

itlbSysFond;

/*default

system

FOND

short

itlbSysSize;

/*default

system

font

short

itlbAppFond;

/*default

application

FOND

ID*/

short

itlbAppSize;

/*default

application

font

size*/

short

itlbHelpFond;

/*default

Help

Mgr

FOND

ID*/

font

size*/

ID*/
size*/

short

itlbHelpSize;

/*default

Help

Mgr

Style

itlbValidStyles;

/*set

valid

styles

for

Style

itlbAliasStyle;

/*style

(set)

to

aliases*/

bi

typedef

struct

struct

Intl0ORec

ItlbExtRecord

of

mark

ItlbExtRecord;

{

char

decimalPt;/*decimal

char

thousSep;/*thousands

char

listSep;

char

currSym1;/*currency

char

currSym2;

char

currSym3;

/*list

point

character*/

separator

separator

character*/

character*/

symbol*/

unsigned

char

currFmt;

/*currency

format

unsigned

char

dateOrder;

/*order

short

unsigned

char

shrtDateFmt;

/*format

char

script*/

dateSep;

of

/*date

flags

for

separator

unsigned

char

timeCycle;

/*specifies

unsigned

char

timeFmt;

/*format

flags*/
date

each

short

date

element*/

character*/

time

flags

elements:mdy,dmy,etc.*/

cycle:0..23,1..12,or
for

each

time

0..11*/

element*/

char

mornsStr
[4] ;

/*trailing

string

for

AM

if

12-hour

cycle*/

char

eveStr[4];

/*trailing

string

for

PM

if

12-hour

cycle*/

char

timeSep;

/*time

char

timelSuff;

/*trailing

string

for

AM

if

24-hour

cycle*/

char

time2Suff;

char

time3Suff;

char

time4Suff;

char

timeS5Suff;

/*trailing

string

for

PM

if

24-hour

cycle*/

char

time6éSuff;

char

time7Suff;

char

timesSuff;

if

inches

etc.*/

byte)

and

version

unsigned
short

char

metricSys;

intl0Vers;

/*255

separator

if

/*region

Summary of the International Resources

metric,
code

(hi

character*/

0

(lo

byte)

*/

B-83

APPENDIX

B

International

Resources

typedef

struct

IntlORec

typedef

IntlORec

struct

IntllRec

Str15

daysI[7];

Str15

months

unsigned

char

unsigned
unsigned

unsigned

Intl0ORec;

*IntloOPtr,

**IntlOHndl;

{
/*day

[12];

names*/

/*month

names*/

suppressDay;

/*255

char

lngDateFmt;

/*order

char

dayLeading0O;

/*255

char

abbrLen;

/*length

char

st0[4];

char

st1[4];

char

st2[4];

char

st3[4];

char

st4[4];

=

no

of
for

day,

or

long

date

leading

0

for

intllVers;

/*region

code

(hi

short

localRtn[1] ;

/*now

flag

for

struct

typedef

IntllRec

struct

ItllExtRec

IntllRec
short

IntllRec

day

names*/

for

long

date

format*/

byte)

and

version

(lo

opt

/*fields

base;

for

optional

/*un-extended

format;

itll

/*calendar

code

for

this

itll

extra

days

extraDaysTableOffset;

/*offset

in

itll

to

long

extraDaysTableLength;

/*length

of

extra

days

long

extraMonthsTableOffset;

/*xoffset

in

itll

to

long

extraMonthsTableLength;

/*length

of

extra

months

long

abbrevDaysTableOffset;

/*offset

in

itll

to

long

abbrevDaysTableLength;

/*length

of

abbrev

long

abbrevMonthsTableOffset;

/*offset

in

itll

long

abbrevMonthsTableLength;

/*length

of

abbrev

long

extraSepsTableOffset;

/*offset

in

itll

long

extraSepsTableLength;

/*length

of

extra

/*now

flag

for

tables[1] ;
struct

Itl1lExtRec

UntokenTable

short

len;

short

lastToken;

B-84

extension*/

IntllRec*/

long

struct

byte) */

extension*/

version;
calendarCode;

typedef

number*/

**IntliHndl;

{

short

short

elements*/

IntllRec;

*Intl1iPtr,

short

bi

suppress

elements*/
in

strings

short

typedef

to

abbreviating

/*separator

a

flags

Itl1ExtRec;

{

Summary of the International Resources

a

months

abbrev
abbrev

opt

days

table*/

table*/

months
extra

seps

table*/

table*/

days

to

table*/

table*/

extra

to

resource*/

months

table*/

table*/
seps

table*/

extension*/

table*/

short

bi

APPENDIX

B

International

Resources

typedef

struct

typedef

UntokenTable

union

/*index

index[256];
UntokenTable

WideChar

char

al[2];

short

b;

table;

last

=

lastToken*/

UntokenTable;

*UntokenTablePtr,

**UntokenTableHandle;

{
/*0

ig

the

high-order

character*/

bi
typedef

struct
short

union

WideChar

WideCharArr

WideChar;

{

size;

WideChar

data[10];

bi
typedef

struct
short

struct

WideCharArr

NumberParts

{

version;

WideChar

data[31];

/*index

WideCharArr

pePlus;

WideCharArr

peMinus;

WideCharArr

peMinusPlus;

WideCharArr

altNumTable;

char

bi

reserved
struct

typedef

NumberParts

NumberParts

New

NIt1l4Rec

for

struct

NItl4Rec

{

short

by

[tokLeftQuote..tokMaxSymbols]
*/

[20];

typedef

/*

WideCharArr;

flags;

NumberParts;

*NumberPartsPtr;

System

7.0:

*/

/*reserved*/

long

resourceType;

/*contains

'itl4'*/

short

resourceNum;

/*resource

ID*/

short

version;

/*version

number*/

short

format;

/*format

code*/

short

resHeader;

/*reserved*/

long

resHeader2;

/*reserved*/

numTables;

short

/*number

of

tables,

long

mapOffset;

/*offset

to

table

long

strOffset;

/*offset

to

routine

that

copies

long

fetchoOffset;

/*offset

to

routine

that

gets

long

unTokenOffset;

/*offset

to

table

that

long

defPartsOffset;

/*offset

to

number

parts

Summary of the International Resources

one-based*/

that

maps

maps

byte

to

token*/

canonical
next

token

byte
to

string*/
of

canon.

char.*/
string*/

table*/

B-85

APPENDIX

B

International

Resources

long

whtSpListOffset;

/*offset

long

resOffset7;

/*reserved*/

to

long

resOffsets8;

/*reserved*/

whitespace

table*/

short

resLengthli1;

/*reserved*/

short

resLength2;

/*reserved*/

short

resLength3;

/*reserved*/

short

unTokenLength;

/*length

of

untoken

table*/

short

defPartsLength;

/*length

of

default

number

short

whtSpListLength;

/*length

of

whitespace

short

resLength7;

/*reserved*/

short

resLength8;

/*reserved*/

parts

table*/

table*/

bi
typedef

struct

typedef

NItl4Rec

NItl4Rec

NItl4Rec;

struct

TableDirectoryRecord

OSType

tableSignature;

*NItl4Ptr,

**NItl4Handle;

{
/*4

byte

long

table

long

reserved;

/*reserved

unsigned

long

tableStartOffset;

/*table

start

offset

unsigned

long

tableSize;

/*table

size

in

bi

typedef

struct
Fixed

struct

TableDirectoryRecord

Itl5Record

for

name

unsigned

internal

*/
use

in

*/

byte*/

byte*/

TableDirectoryRecord;

{

versionNumber;

/*it1lS

resource

unsigned

short

numberOfTables;

/*number

unsigned

short

reserved[3];

/*reserved

TableDirectoryRecord

tableDirectory[1];

/*table

of

version

tables
for

it

number

*/

contains

*/

internal

directory

use

records

bi
typedef

struct

Itl5Record

Itl5Record;

struct

RuleBasedTrslRecord

short

sourceType;

/*target

{
type

for

left

side

short

targetType;

/*target

type

for

right

side

short

formatNumber;

/*transliteration

resource

format

short

propertyFlag;

/*transliteration

property

flags

short

numberOfRules;

/*number

following

this

of

rules

of

rule

*/

of

rule

*/

bi
typedef

B-86

struct

RuleBasedTrslRecord

RuleBasedTrslRecord;

Summary of the International Resources

number

*/

*/
field

*/

*/

*/

APPENDIX C

Keyboard Resources

Contents
About Keyboards
C-4
About the Keyboard Resources
C-6
What the Keyboard Resources Are
C-7
Key Translation
C-8
Using the Keyboard Resources
C-10
Key-Map Resource (Type 'KMAP’)
C-11
Apple Extended Keyboard
C-13
Reassigning Right-Hand Key Codes
=_C-14
Other Hardware Dependencies
C-14
Virtual Key Codes for Non-ADB Keyboards
= -C-15
Key-Remap Resource (Type ‘itlk’)
C-16
Keyboard-Layout Resource (Type 'KCHR’)
C-18
Resource Format
C-18
The KeyTranslate Function and the Keyboard-Layout Resource
Special Uses for the KeyTranslate Function
C-22
Installing a Custom Keyboard-Layout Resource
C-22
Using KeyTranslate for Command-Key Equivalents
= _C-23
Keyboard Icon Family (Types 'kcs#', 'kcs4’, 'kcs8')
C-25
Keyboard-Swap Resource (Type 'KSWP’)
C-26
Key-Caps Resource (Type 'KCAP’)
C-28
Resource Format
C-28
Key Caps Desk Accessory
C-32
Summary of the Keyboard Resources
= C-35
Assembly-Language Summary
C-35
Global Variables
C-35

Contents

C-19

C-1

APPENDIX

C

Keyboard Resources

This appendix describes the Macintosh keyboard resources. The keyboard resources
make text input possible; they provide a hardware interface to different types of
keyboards and a software interface to different script systems. Some of the keyboard
resources belong to an individual script system and are independent of any particular
keyboard; others belong to a type of keyboard and are independent of any script system.
By installing the appropriate keyboard resources, you can perform text input in any
script system, from any Macintosh-supported keyboard. By modifying the keyboard
resources, you can localize or customize text input by changing keyboard layouts,
remapping key combinations, creating keyboard icons, modifying the keyboard-layout
display in the Key Caps desk accessory, and changing the way the user switches among
keyboard layouts and keyboard scripts.
Most text-processing applications have no need for direct access to keyboard resources.
You may need to read this appendix, however, if you are
m using the Event Manager KeyTranslate function to get speci c information from a
custom keyboard-layout resource or to make Command-key handling more
script-independent
m creating your own localized version of a script system
m designing a new type of keyboard
Before reading this appendix, read the chapter Cntroduction to Text on the MacintoshOin
this book. The keyboard resources are used by the Script Manager, described in this book,
and by the Event Manager and Menu Manager, described in Inside Macintosh: Macintosh
Toolbox Essentials. Resources in general are described in the Resource Manager chapter of
Inside Macintosh: More Macintosh Toolbox. Additional information on keyboards
themselves can be found in Inside Macintosh: Devices and in Guide to the Macintosh Family
Hardware.
This appendix starts with a brief discussion of keyboards. It then lists the keyboard
resources, shows how they may differ in different versions of localized software, and
presents the concept of key translation. It then discusses each keyboard resource in detail.
Note
All keyboard information that relates to virtual key codes and their
relation to raw key codes is discussed under CKey-Map Resource (Type
'KMAP')Obeginning on page C-11, even if it is not speci cally related to
the key-map resource. @

C-3

APPENDIX

C

Keyboard Resources

About Keyboards
The Macintosh computer supports over 12 separate physical types of keyboards. Your
application needs to be able to handle text input from the domestic and ISO layouts of all
Apple keyboards. It also needs to be able to distinguish multiple keyboards and to use
the modi er fag that detects the state of the modifier keys (Shift, Caps Lock, Command,
Option, and Control) on keyboards.
Table C-1 lists the keyboard types. These type values are used in some of the keyboard
resources discussed later in this appendix.
Table C-1

The keyboard types

Keyboard
type

Keyboard

r

Apple Keyboard and Apple Keyboard II (domestic layout)

2

Apple Extended Keyboard and Apple Extended Keyboard II

3

Small Macintosh 512K Keyboard (no keypad; domestic layout)

4

Apple Keyboard (ISO layout)

5

Apple Extended Keyboard II (ISO layout)

6

Apple Macintosh Portable Keyboard (domestic layout)

7

Apple Macintosh Portable Keyboard (ISO layout)

8

Apple Macintosh Keyboard II (domestic layout)

9

Apple Macintosh Keyboard II (ISO layout)

11

Macintosh Plus Keyboard with the built-in keypad

12

Macintosh PowerBook Keyboard (domestic layout)

13

Macintosh PowerBook Keyboard (ISO layout)

259

Small Macintosh 512K Keyboard (no keypad; ISO layout)

(domestic layout)

" Keyboard type is also the resource ID of the corresponding 'KMAP' or 'KCAP' resource.
The KodType low-memory global variable contains the low byte of this value for the last
keyboard used.

C-4

About Keyboards

APPENDIX

C

Keyboard Resources

Figure C-1 and Figure C-2 show the U.S. layout of the Apple Keyboard II and Apple
Extended Keyboard II and the virtual key codes produced by each key. The codes are the
values that result after the raw key codes produced by the hardware have been mapped
through the key-map resource. See (Key TranslationOon page C-8. Other keyboards can
produce different virtual key codes; some produce raw key codes only.
The Apple Extended Keyboard may be connected to the Apple Desktop Bus (ADB) of any
computer in the Macintosh II or Macintosh SE family. It contains duplicated Shift,
Option, and Control keys to the right of the Space bar. Other keyboards have different
physical layouts.
Figure C-1

Apple Keyboard

II (domestic layout)

~
‘a

>
£48
f

@19
2

Q

12

A

9S 21
4

13

14

WWE

of.

S
Z

58
option!

I]# 20
3

[a3
5

R

15

I " 22

T

17

he 26
7

Y

i_29.30.59

6

X

D

F

7

89
V

C

Rp

G

16

H
B

11

I-28
8

U

49

32

J
N

45]

Ii 25

!

349

289
M

49

K
46

I) 29
0

O

31

400

L

I-27 I+ 24
=
35

WP

370

) 43

;
47
.

55
esc

(33

i

41

delete
B30

939)

'

I ’?44
/

return
shift

123
1241)
[<-->

Wf! 42

]

125
fy

75

/

9

36

6

56

| 78

-

t

I

65

.

67

88 || 69
85

3

26
:

92

%

76

|enter

&

A

Figure C-2

Apple Extended Keyboard

II (domestic layout)

a

>

[=]

122]
Fr

120]
Fo

99 118
Ire. | F4

96 I 97 1 98 1] 100
Fo
iro WF? Wyre

401 Wf 109]
FO Wrfo

103
\PFit

111
WFt2

yi
yu)
Fig \Fi4 |) FAS
115

116

home

aad

/

end

pee

9

119 Wf 121

6

26
125

\

eo
co
Pr caps sx
75
92

67
78

=>

88 I] 69

®
124
->

*

+

76

65
[enter

/

About Keyboards

C-5

APPENDIX

C

Keyboard Resources

Table C-2 shows the keyboard modi er bits in the high byte of the modifiers eld ofan
event record (de ned by the Event Record data type). The byte consisting of these bits is
used to control the selection of tables in the keyboard-layout resource. See
(Keyboard-Layout Resource (Type 'KCHR')Obeginning on page C-18.
The keyboard modifier bits in an event record

Key

(Right Control if used)”
(Right Option if used)"
Control (Left Control if different from Right Control)
Option (Left Option if different from Right Option)

oO

FN

KF

(Right Shift if used)"

WoO

UD

Bit
N

Table C-2

Caps Lock
Shift (Left Shift if different from Right Shift)
Command

" See CReassigning Right-Hand Key CodesObeginning on page C-14.

About the Keyboard Resources
The keyboard resources are Macintosh resources that facilitate worldwide keyboard
handling and support the Macintosh script management system. They specify how
keyboard input is converted to text for a particular writing system, language, or region.
The Event Manager, the Script Manager, and the Menu Manager use the information in
these resources to convert keystrokes to character codes, to switch input among different
script systems, and to display the icon of the current keyboard in the Keyboard menu.
Note
Other Apple publications use the term ASCII code for character code (the
8-bit integer representing a text character generated by a key ora
combination of keys on the keyboard or keypad) and the terms key-down
transition code and response code for virtual key code (the key code that
actually appears in keyboard eventsN that is, the value produced after a
raw key code [the original value generated by a keyboard] has been
mapped through the key-map resource). The terms character code, raw key
code, and virtual key code are preferred in this book. ASCII code is limited
here to the 7-bit code representing a character from the lower half of the
Standard Roman character set.

C-6

About the Keyboard

Resources

APPENDIX

C

Keyboard Resources

What the Keyboard Resources Are
The keyboard resources fall into two categories: those that are hardware-dependent
(and script-independent) and those that are script-dependent (and
hardware-independent). It is this division that allows many different physical keyboards
to work correctly with many different script systems. Table C-3 lists the keyboard
resources and their resource types, and gives a capsule description of their contents.
More complete descriptions follow.
Table C-3

The keyboard resources

Name

Resource type

Contents

Key map

'KMAP'

Tables to map raw key codes to virtual key
codes

Key remap

'itlk'

Tables to remap virtual key codes for
certain key combinations

Keyboard layout

'KCHR'

Tables to map virtual key codes to character
codes

Keyboard icons

'kes#'!

Keyboard icon (1-bit; black-and-white)

'kes4!

Keyboard icon (4-bit)

'kes8!

Keyboard icon (8-bit)

Keyboard swap

'KSWP!

Table specifying key combinations for
changing keyboard script or input method

Key caps

'KCAP!

Data that determines keyboard display

m Key-map resource. Maps the raw key codes that have been generated by a speci c
keyboard microprocessor into hardware-independent standard virtual key codes.
There is a maximum of one key-map resource per physical keyboard (several
keyboards can share a single key-map resource).
m Key-remap resource. Remaps the virtual key codes for certain key combinations on
certain keyboards to other virtual key codes, to allow a single keyboard-layout
resource to work with all keyboards. This resource is optional; it is provided with
certain keyboard-layout resources.
m Keyboard-layout resource. Maps virtual key codes to character codes. The
keyboard-layout resource implements the character set for a script system. It is with
different keyboard-layout resources that text input for different script systems and
localized versions of system software is enabled. A script system has one or more
keyboard-layout resources.

About the Keyboard Resources

C-7

APPENDIX

C

Keyboard Resources

m Keyboard icon family. Implements keyboard iconsN small icons that represent a
keyboard script or input methodN for screens of different bit depths (black-and white,
4-bit, and 8-bit, respectively). These icons are used in the Keyboard menu and in the
Keyboard control panel. There is one icon family per keyboard-layout resource (or
input method).
m Keyboard-swap resource. Lists modi er-plus-key combinations that can be used to
change the keyboard script, or the keyboard layout or input method within a script.
There is one keyboard-swap resource per version of system software.
m Key-caps resource. Speci es the physical arrangement of keys on a keyboard and is
used to display the characters produced by each keypress. The key-caps resource is
independent of any script system, but the Key Caps desk accessory uses it along with
the keyboard-layout resource of the current script systemN and a font in the current
script systemN to display the characters corresponding to each keypress or
combination of keypresses.There is one key-caps resource per physical keyboard.
Keyboard resources and localized system software
When Macintosh system software is localized for a non-U.S. market,
it contains replacements for or modi cations to some of the U.S. versions
of the keyboard resources. See the discussion of U.S. international
resources and keyboard resources in the appendix
(Built-in Script SupportOfor a list of resources that may be replaced
during localization.

Key Translation
Key translation is the conversion of keystrokes to character codes. In early versions of the
Macintosh, keyboard translation was simple and direct: two low-memory pointers
in the System le (accessed through global variables Key1Trans or Key2Trans) pointed
to the translation routines. Those pointers are still available and are called by the
Macintosh Plus but are not called by newer systems. The pointers are preserved so that
applications that call them can still function correctly. However, they now point to a
routine that implements a new standard mechanism.
The standard mechanism was developed with the advent of ADB keyboards; it was
needed to map the different sets of raw key codes to a standard set of virtual key codes,
which could in turn be mapped to character codes. In the standard method, a keystroke
generates an interrupt; the keyboard driver maps the raw key code to a virtual key code,
which it sends to the Event Manager; the Event Manager maps the virtual key code to a
character code, and returns the character code to the driver. The driver in turn posts the

key-down event. This method has two advantages:

About the Keyboard

Resources

APPENDIX

C

Keyboard Resources

mw The mapping from raw key code to virtual key code achieves keyboard hardware
independence. The raw mapping routine uses the table of a key-map resource for the
keyboard, in the System le or in ROM.
m The mapping from virtual key code to character code allows support of multiple
character sets. It is performed by the Event Manager KeyTranslate function, which
is accessed through the KeyTrans trap (not to be confused with the Key1Trans or
Key2Trans pointers). KeyTranslate maps the virtual key code (plus modi ers, if
any) to a character code, using tables in a keyboard-layout resource, also in the System
le or in ROM. (KeyTranslate also handles dead keys; see page C-19.)
The Macintosh keyboard routines handle the keyboard properly for all script systems.
Except for purely hardware-speci c characteristics such as controlling lights on
the keyboard, the function of the keyboard is completely determined by
character-encoding tables in the keyboard-layout resource (with an optional associated
key-remap resource). For each virtual key code and each possible modi er-key state,
the character-encoding tables specify the equivalent character code. Figure C-3
summarizes the key translation process:
1. Akeystroke initially produces a raw key code.
2. The keyboard driver uses the hardware-dependent key-map resource to map that raw
key code into a hardware-independent virtual key code, and to set bits indicating the
state of the modi er keys.
3. It then calls the Event Manager KeyTranslate function. The optional key-remap
resource speci es how KeyTranslate should remap certain key combinations on
certain keyboards before it performs its mapping. The key-remap resource
reintroduces hardware dependence because certain scripts, languages, and regions
need subtle differences in layout for speci c keyboards. Generally, the key-remap
resource affects only a few keys.
4. KeyTranslate uses the keyboard-layout resource to map a modi
virtual key code into a character code, such as an ASCII code.

er state and a

5. KeyTranslate returns the character code, and if the character code is nonzero the

keyboard driver posts the key-down event into the event queue.

The net result of the process of key translation is a virtual key code and a character code
inthe message

eld of anevent record, and modi

eld of the event record.

er-key information in the modifiers

Note
On the Macintosh Plus, the event record contains raw key codes, not
virtual key codes. However, except in the case of the small Macintosh

512K Keyboard with ISO layout, the Macintosh Plus raw key codes are
identical to the virtual key codes that would have been produced. @

About the Keyboard Resources

C-9

APPENDIX

C

Keyboard Resources

Figure C-3

O

The key translation process

Qe
eo
oo" -- 2"

ieee

et

Raw key

Modifier

code

KeyTranslate function

state

7
New modifier

—- He
'

KMAP

'

>t

'itlk'

; (if present)

Virtual

key code

|

state

|

'KCHR'!

;
New virtual

Character
code

key code
»

Virtual
key code

Character
code

Event message

Using the Keyboard Resources
The Operating System, along with the Script Manager and other Macintosh system
software managers, uses information in the keyboard resources to convert keystrokes into
character codes; to display keyboard icons; to change the current keyboard script,
keyboard layout, or input method when the user enters Command-key combinations;
and to properly display keyboard layout with the Key Caps desk accessory.
Most applications do not handle any of these tasks and therefore have no need for
direct access to any of the keyboard resources. However, if you have the following special
software needs related to text input, you can use the keyboard resources to
help meet them:
m If your application needs to provide better international support for Command-key
equivalents or a custom keyboard-layout resource, you can use the Event Manager
KeyTranslate function to get the information you need from the appropriate
keyboard-layout resource. See Special Uses for the KeyTranslate FunctionObeginning
on page C-22.

C-10

Using the Keyboard Resources

APPENDIX

C

Keyboard Resources

m If you are creating your own localized version of a script system and need to allow text
input in that script system, you may need to create or modify a keyboard-layout
resource, and possible a key-remap resource. If you do make a new keyboard-layout
resource, you also need to create a keyboard icon family to accompany it. To do that
you will need the information in (Keyboard-Layout Resource (Type 'KCHR')O
beginning on page C-18, Key-Remap Resource (Type 'itIk')Obeginning on page C-16,
and (Keyboard Icon Family (Types ‘kcs#', 'kcs4’, 'kcs8')Obeginning on page C-25.
m If you are designing a new type of keyboard, you need to make sure it produces the
appropriate raw key codes. See the next section. Each new keyboard also needs to
work correctly with the Key Caps desk accessory; see (Key-Caps Resource (Type
'KCAP')Obeginning on page C-28. Note that hardware development is beyond the
scope of Inside Macintosh. See Guide to the Macintosh Family Hardware and contact
Macintosh Developer Technical Support for more information.

Key-Map Resource (Type 'KMAP"’)
The key-map resource (resource type 'KMAP') is used for converting the raw key codes
produced by a keyboard@ microprocessor into hardware-independent virtual key codes.
There is one key-map resource per physical keyboard on a Macintosh; it belongs to the
Operating System, not to any script system.
The key-map resource ID number equals the ID number of the type of keyboard it is
associated with. See Table C-1 on page C-4. If a matching key-map resource cannot be
found for the keyboard in use, the Operating System substitutes the 'KMAP' resource
whose ID is 0; on all Macintosh systems later than the Macintosh Plus, the key-map
resource with ID = 0 is in ROM.
Note
Most current keyboards use the key-map resource with ID = 0. However,
keyboard types 2 and 5, for example, require their own key-map
resources. @
The key-map resource contains a 128-byte table that provides a one-to-one mapping of
raw key codes to virtual key codesN the rst byte contains the virtual key code for a raw
key code of $00, the second for $01, and so forth. The table is followed by an array of

exceptions. The high bit of the byte containing the virtual key code signals an exception
entry in the exception array. (Virtual key codes themselves are only 7 bits long.)

Key-Map Resource (Type 'KMAP’")

C-11

APPENDIX

C

Keyboard Resources

The exception array lets the device driver initiate communication with the device, usually
to perform a state changeN for example, to send codes to the keyboard that instruct it to
turn on lights when a given key such as Caps Lock is down. The exception array begins
with a 2-byte record count followed by that many records. The format of the key-map
resource and its exception array is shown in Figure C-4.
Figure C-4

Format of the key-map resource

Bytes

Z

ID

2

Version

2

Key code map

128

;

Count of exception records
{

Exception array

| 2 .°
4

Exception record

Bytes

P

a

Boolean

_|

Raw key code

1

Length of string

1

f

y

ADB opcode | 1

String

4

The elements in the resource have these meanings:

ID. The resource ID for this particular key-map resource.
Version. The version number of this key-map resource format.
Key code map. A 128-byte table that contains virtual key codes. At each byte offset into
the table, the entry is the virtual key code (plus possibly an exception entry fsag) for
the raw key code whose value equals that offset.
Count of exception records. The number of entries in the exception array.
Exception array. An array of exception records, which map raw key codes to
communication instructions.
Each exception record has these elements (see also Figure C-4):
A raw key code.
One byte containing the following elements:
O A Boolean (Xor or noXor) eld that determines whether to instruct the driver to
invert the state of the key instead of using the state provided by the hardware.
O

Filler (3 bits in length).

O The ADB opcode, an instruction to the keyboard to perform some task. ADB
opcodes are described in Inside Macintosh: Devices.

C-12

Key-Map

Resource (Type 'KMAP')

APPENDIX

C

Keyboard Resources

m A variable length Pascal data string that is passed to the ADB op trap along with the
ADB opcode. The rst byte in the string is the length byte.
The following is an example of the exception array used to turn the Caps Lock light of the
Apple Extended Keyboard II on and off, to match the state of the Caps Lock key.

{
$39,

noXor,

SE,

"\S$00\S02";

SB9,

noXor,

SE,

"\$00\S02";

}
Note
Do not change the key-map resource. Everything your application needs
to support any kind of text input is in the keyboard-layout and
key-remap resources. You need to work with the key-map resource only
if you are making your own keyboard.

Apple Extended Keyboard
With the Apple Extended Keyboard (and Apple Extended Keyboard II, shown in Figure
C-2), the standard key-map resource that is supplied with the system converts the
following raw key codes to virtual key codes, as listed in Table C-4.
Table C-4
Key

Key-map resource assignment of raw key codes to virtual key codes
Raw key

Virtual key

Control

$36

$3B

Left Arrow

$3B

$7B

Right Arrow

$3C

$7C

Down Arrow

$3D

$7D

Up Arrow

$3E

$7E

code

code

The standard key-map resource leaves all other virtual key codes identical to the raw key
codes they are generated from.

Key-Map Resource (Type 'KMAP"')

C-13

APPENDIX

C

Keyboard Resources

Reassigning Right-Hand Key Codes
It is possible to reassign the standard raw key codes and virtual key codes for the Shift,
Option, and Control keys on the right side of the Apple Extended Keyboard, in order to
distinguish right-side keystrokes from left-side keystrokes for those keys. To do so, you
need to obtain the special values listed in Table C-5.
Table C-5

Reassigning right key codes for Shift, Option, and Control keys

Right

Normal
raw

virtual

Normal

Special
raw

virtual

Shift

$38

$38

$7B

$3C

Option

$3.A

$3A

$7C

$3D

Control

$36

$3B

$7D

$3E

key

Special

The normal raw and virtual key codes for Right-Shift, Right-Option, and Right-Control

keys correspond to the left versions of these keys. You can obtain the special raw and
virtual key codes only by changing the value of the device handler ID _ eld in the Apple
Extended Keyboard@ register 3 from 2 to 3. For details about the device handler ID eld,
see Inside Macintosh: Devices.
WARNING

This capability is included for compatibility with certain existing
operating systems that distinguish between the left and right versions of
these keys. Its use by new applications violates the Apple human
interface guidelines and is strongly discouraged. A

Other Hardware Dependencies
The principle underlying virtual key codes is to have a single unique code per
character code, regardless of the keyboard used. Nevertheless, some hardware
dependencies remain:
mw The small Macintosh 512K Keyboard with ISO layout and the ISO ADB keyboards
have an extra key not present on domestic keyboards. This key produces a virtual
key code of $0A.

C-14

Key-Map

Resource (Type 'KMAP')

APPENDIX

C

Keyboard Resources

m There is a different virtual key code for the Enter key, depending on whether it is on
the keypad ($4C on the Macintosh Plus keyboard and most ADB keyboards), or on the
main section of the keyboard ($34 on the original Macintosh keyboard and the
Macintosh Portable and PowerBook keyboards).
m Virtual key codes for cursor keys and some keypad operator keys differ between ADB
keyboards and non-ADB (Macintosh Plus) keyboards, as shown in Table C-6. Note that
on Macintosh Plus keyboards, the virtual key codes for keypad operators are the same
as the virtual key codes for cursor keys. The Shift modi er controls which character
code is generated. On these keyboards, for example, holding down the Shift key and
pressing the Left Arrow key produces the plus character (+).
Table C-6

ADB and non-ADB virtual key codes for cursor keys and keypad keys

Key

ADB

code

Non-ADB

code (Macintosh

Plus)

Left Arrow

$7B

$46

Right Arrow

$7C

$42

Down Arrow

$7D

$48

Up Arrow

$7E

$4D

Keypad Plus (+)

$45

$46 (with Shift bit set in modi

ers)

Keypad Asterisk (*)

$43

$42 (with Shift bit set in modi

ers)

Keypad Equal (=)

$51

$48 (with Shift bit set in modi

ers)

Keypad Slash (/)

$4B

$4D (with Shift bit set in modi

ers)

Virtual Key Codes for Non-ADB Keyboards
The original Macintosh keyboard (for both the 128K and 512K versions) and the
Macintosh Plus keyboard produce event records with raw key codes rather than virtual
key codes, because there is no key-map resource for them. For domestic versions of these
keyboards it is not a problem, because the raw key codes are identical to the virtual key
codes expected by the U.S. keyboard-layout resource. The international version of the
Macintosh Plus keyboard, however, and the ISO layout of the small Macintosh 512K

keyboard, produce raw key codes that cannot be treated as virtual.

Key-Map Resource (Type 'KMAP"')

C-15

APPENDIX

C

Keyboard Resources

When a keypress from the international version of the Macintosh Plus keyboard occurs,
the interrupt handler calls the _Key1Trans hook, which translates the raw key codes to

virtual key codes before calling KeyTranslate. Thus your application normally
receives the correct character codes even if an international version of the Macintosh Plus
keyboard is attached. However, the raw key code is what is placed in the event record.
Therefore, if you need to explicitly convert raw key codes to virtual key codes, you can
use the values in Table C-7. Raw key codes are offsets into the table; the byte
at each offset represents the virtual key code for that raw key code. (The keyboard
produces raw key codes up to $3F only; key codes above that value are generated by an
optional keypad.)
Table C-7

Virtual key codes for the international Macintosh Plus keyboard

Raw codes

Virtual codes

$00 $07

$00

$01

$02

$03

$04

$05

$32

$06

$08 $0F

$07

$08

$2C

$09

$0C

$0D

$0E

$0F

$10 $17

$10

$11

$12

$13

$14

$15

$16

$17

$18 $1F

$18

$19

$1A

$1B

$1C

$1D

$1E

$1F

$20 $27

$20

$21

$22

$23

$2A

$25

$26

$27

$28 $2F

$28

$29

$24

$2E

$2F

$0B

$2D

$2B

$30 $37

$30

$34

$0A

$33

$31

$35

$36

$37

$38 $3F

$38

$39

$3A

$3B

$3C

$3D

$3E

$3F

The domestic and ISO layouts of the small Macintosh 512K keyboard have keyboard
types of 3 and 259, respectively. However, in both cases the low-memory global that
speci es current keyboard type (KbdType) holds the value 3. The user indicates which
keyboard is in use through a control in the Keyboard control panel that appears only on
non-ADB systems. The user@ selection is kept in the it lcOldKeyboard eld of the
system script@ international con guration ('it1c') resource. You can examine that eld
if you need to know whether the ISO or domestic layout of the small Macintosh 512K
keyboard is in use.

Key-Remap Resource (Type ‘itlk’)
The key-remap resource (resource type '1t1k') is used by the KeyTranslate function
to ensure that all international keyboard layouts work on all Macintosh keyboards. The
key-remap resource speci es how to remap the virtual key codes produced by certain key
combinations before KeyTranslate converts the virtual key codes to character codes
with a keyboard-layout ('KCHR') resource. KeyTranslate is described in the chapter
CEvent ManagerOin Inside Macintosh: Macintosh Toolbox Essentials.

C-16

Key-Remap

Resource (Type ‘itlk’)

APPENDIX

C

Keyboard Resources

There is one key-remap resource per keyboard-layout resource that needs it. The 'it1k'
resource has the same resource ID as the keyboard-layout resource with which it is
associated. The Operating System loads key-remap resources from the System le only.
The key-remap resource consists of an integer count of entries followed by a set of 8-byte
entries. Figure C-5 shows the format of an entry.
Figure C-5

Format of an entry in the key-remap resource

Keyboard type
(integer)

Current
modifiers
(byte)

Current
| key code
(byte)

Modifiers
mask
(byte)

| Key code
mask
(byte)

New
modifiers
(byte)

New
| key code
(byte)

Before the KeyTranslate function begins processing with the keyboard-layout
resource, it determines which entry in the key-remap resource to use. It tests each entry in
the key-remap resource to see whether
m the actual keyboard type matches the keyboard type element
m the product of an AND operation on the actual virtual key code with the key code mask
matches the current key code element
m the product of an AND operation on the actual modi
matches the current modi ers element

ers with the modi

ers mask

If all three match, KeyTranslate substitutes the new modi ers and virtual key code
from that entry before applying them to the keyboard-layout resource.
To allow for a more compact table when several virtual key codes produced from one key
(using different modi ers) are all mapped together to a different key, an additional step is
taken. KeyTranslate uses the modi ers mask and key-code mask in the key-remap
entry to produce a number of new modi ers and virtual key codes. Here is how a single
entry can remap all modi er combinations for a given key:
1. An AND operation is performed on the new modi ers and new virtual key code with
the modi ers mask and the key-code mask from the entry.
2. An AND operation is performed on the actual modi ers and actual virtual key code
with the 1@ complement of the modi ers mask and key code mask from the entry.
3. The OR of these two operations is the

nal result that is used for key translation.

Note
If the keyboard type is 259 (the ID for the ISO layout of the small
Macintosh 512K Keyboard), the third eld in the key-remap resource
(which usually contains the current virtual key code) consists of the raw
key code. See Table C-1 on page C-4 of this appendix for a list of the
keyboard types. @

Key-Remap

Resource (Type ‘itlk’)

C-17

APPENDIX

C

Keyboard Resources

Keyboard-Layout Resource (Type 'KCHR’)
The keyboard-layout resource (resource type 'KCHR') speci es the mapping of virtual
key codes to character codes. Each installed script system has one or more
keyboard-layout resources; there may be one or more for each language or region to suit
the preference of the user. The resource ID for each keyboard-layout resource is within
the range of resource ID numbers for its script system. The ID number of the default
'KCHR' resource for a script system is speci edin the itlbKeys_ eld of the script@
international bundle ('it1b')

resource.

U.S. keyboard-layout resource

Speci c features of the U.S. keyboard-layout resource (ID = 0) are
described in the appendix (Built-in Script SupportOin this book.
Keyboard-layout resources for 2-byte script systems
Keyboard-layout resources for 2-byte script systems have the same size
and function as those for 1-byte script systems; they generate 1-byte
character codes only. It is the input method that is responsible for
producing the nal 1-byte or 2-byte character codes. @

Resource Format
Figure C-6 shows the format of the keyboard-layout resource. Its header consists of a
version number only. The header is followed by a 256-byte table-selection index that is
used to access character-mapping tables. The index is followed by the character-mapping
tables, a series of 128-byte tables that map virtual key codes to character codes,
depending on what modi er keys are pressed. The nal part of the resource is a dead-key
table, a series of records that de ne dead keys and completers. The dead-key records
allow the user to enter special character forms, such as accented characters, from the

keyboard. How dead keys are processsed is described under (Lhe KeyTranslate Function
and the Keyboard-Layout ResourceObeginning on page C-19.
The dead-key table consists of a 2-byte count of dead-key records, followed by that many
records. A dead key record consists of a 1-byte table number (corresponding to a
character-mapping table), a 1-byte virtual key code (without up/down bit), a completion
table, and a no-match character.

Each completion table in a dead-key record consists of a count of completion records,
followed by that number of completion records. A completion record is simply a
substitution pair for character codes. If the character code matches the rst byte in the
completion record, the second byte is substituted for it.

C-18

Keyboard-Layout Resource (Type 'KCHR’)

APPENDIX

C

Keyboard Resources

Figure C-6

Format of the keyboard-layout resource

Bytes

Version

2

Table-selection index

7 256

Number of tables

2

Z

Character-mapping

/' 28

Z

Character-mapping
table 2

4 128

Z

table 1

VA

V4
Number of dead-key records | 2,.-*—

Z

Dead-key record 1

/

Dead-key record
Virtual key code

1
1

Number of completion records

2

Completion character
Substitution character

Completion character

Z

1

Dead-key record 2

/ :

{

Bytes

Table number

Substitution character

2)

Completion

2

Completion

record 1

record 2

No-match character
No-match character

The Key Translate Function and the Keyboard-Layout Resource
During the process of key translation, the Event Manager KeyTranslate function
applies the virtual key code and the state of the modi er keys to the keyboard-layout
resource to determine a character code. Table C-2 on page C-6 shows the meanings of the
keyboard modi er bits in the high-order byte of the modifiers eld of an event record
(de ned by the EventRecord data type). The KeyTranslate function uses the byte
value determined by the settings of these bits to control the selection of tables in the
keyboard-layout resource.

Keyboard-Layout Resource (Type 'KCHR’)

C-19

APPENDIX

C

Keyboard Resources

Figure C-7 gives an overview of how the parts of the keyboard-layout resource are
used. It starts when the user presses a key or combination of keys, and the Event
Manager passes the virtual key code and the state of the modi er keys to the
KeyTrans late

function:

1. First, KeyTranslate treats the modi

er state informationN 8 bits, each bit indicating
the state of one modi er keyNas a byte whose value is used as an index into the
256-byte table-selection index to get a table code. The table code speci es which
of the 128-byte character-mapping tables to use to map the virtual key code to a
character code.

. KeyTranslate uses the virtual key code as an index into the selected
character-mapping table. If the table has a nonzero entry for the virtual key code, that
entry is the desired character code. KeyTranslate returns that character code and
the Event Manager posts a key-down eventN unless the previous keypress had been a
dead key. See step 4.
. If the entry in the character-mapping table is 0, KeyTranslate searches the dead-key
table. It looks for a match with both the virtual key code and the table number elds in
a dead-key record. If there is no match, KeyTranslate returns 0. If there is a

match,the dead-key information is preserved in the state parameter of the

KeyTranslate function. KeyTranslate returns 0, so no event is posted, but the

state information affects how the next virtual key code is to be processed.

. If the previous key was a dead key, KeyTranslate searches the completion table in
the dead-key record corresponding to the previous keypress. If the character code of
the current keypress matches the rst byte of any completion record in the completion
table, the second byte in the record is substituted for it. If it does not match any rst
bytes in the completion table, the current character code is preceded by the no-match
character found at the end of the dead key record and KeyTranslate returns both
characters.
For instance, in the U.S. keyboard-layout resource the Option-E combination is a dead
key. When pressed, no character appears on the screen, but the state parameter of
KeyTranslate is modi ed to hold the information that the dead key for the acute

accent («) has been pressed. If the next character is a valid completer key (such as a, e, i,
o, or u), KeyTranslate returns the equivalent substitution character ({, ,’, 0d, an

event is posted, and the character appears on the screen. If the next character is not a
valid completer (for example, x), KeyTranslate returns both the no-match character
(typically the accent character by itself) and the current character code; two events are
posted, and both characters appear on the screen («).

As far as your application is concerned, no event is generated by pressing a dead key. The
only information you receive regarding the dead key is after the fact. When the user
produces @ Oby pressing Option-E followed by QAQ you receive a single event
containing a virtual key code corresponding to OAQO no modi
code of @ Q

C-20

Keyboard-Layout Resource (Type 'KCHR’)

ers, and a character

APPENDIX

C

Keyboard Resources

Figure C-7

Inside the keyboard-layout resource

Table-selection
ops
Modifiers
value

index
7

it

_
me

Previous key was
not a dead key

Character-mapping
tables

Virtual |

key code

Dead-key
records

i

i

Return

Return zero

character
code

Table-selection
index
Modifiers
value

;
=

rit

HTT

Character-mapping
tables

Return state

change for
keyTranslate

Previous key was
a dead key

Virtual |

key code

Dead-key
records

_——_I} => <n
(Completion

table)

“

yy"
Return no-match
character
and current
character code

Keyboard-Layout Resource (Type 'KCHR’)

Ves

Return
substitution
character

C-21

APPENDIX

C

Keyboard Resources

Special Uses for the Key Translate Function
In normal key translation, the Event Manager KeyTranslate function performs the
conversion from virtual key code to character code and passes the result to your
application in the message _ eld of the event record for a key-down event. The script
management system provides KeyTranslate with a pointer to the proper
keyboard-layout resource to use, based on the current script.
There may be situations, however, in which you may want to explicitly call
KeyTranslate, either to install your own keyboard layout or to perform special
processing.

Installing

a Custom Keyboard-Layout Resource

The script management system loads and uses only those keyboard-layout resources that
are installed in the System le. It cannot load a keyboard-layout resource that is, for
example, in the resource fork of your application. However, if your application needs to
modify the keyboard layout temporarily without forcing users to install anew keyboard
layout, you can load a keyboard-layout resource from your own application resource fork
and call KeyTranslate directly after each key-down event, passing it a pointer to that
keyboard-layout resource and using the same virtual key code and modi ers that you
received in the event message.
To more permanently replace a script system@ keyboard layout, you can have the user
install a keyboard-layout resource and a keyboard-icon family in the System le. Both
resources must have identical ID numbers, in the range for the script system for which
they will be used. You call the Script Manager Set Script Variable procedure twice, to
make those IDs the defaults for the given script system. You then call the Script Manager
KeyScript procedure to load the resources and make them available to the system.

Listing C-1 demonstrates the calls for a Dvorak keyboard layout in the Roman script
system.

Listing C-1

Loading a non-system keyboard-layout resource

CONST
DvorakID

=

500;

VAR
err:

OSErr;

BEGIN

err

=

SetScriptVariable(smRoman,

smScriptKeys,

DvorakID) ;

err

:=

SetScriptVariable(smRoman,

smScriptIcon,

DvorakID) ;

KeyScript

(smRoman)

;

END;

C-22

Keyboard-Layout Resource (Type 'KCHR’)

APPENDIX

C

Keyboard Resources

In this example you do not need to call KeyTranslate to get character codes for the
new keyboard layout, and the new keyboard layout will be in effect until the system is
restarted or until your application restores the original keyboard layout.
The most permanent way to replace the keyboard layout is to make the system use your
keyboard layout as its default. To do that you must modify the itlbKeys eld of the
target script system@ international bundle (' it 1b') resource. The international bundle
resource is described in the appendix Cnternational ResourcesOin this book.
IMPORTANT

Apple Computer@ system software licensing policy forbids shipping a
modi ed System le. If you want to modify the System le, it is best to
have the user either run the Installer to install your resources, or drag a
le consisting of those resources onto the System Folder. Contact
Macintosh Developer Technical Support for information on the
Installer. a
You can inspect and edit any keyboard-layout resource by using a resource editor such as
ResEdit.

Using KeyTranslate for Command-Key Equivalents
In some cases you may need to call KeyTranslate to regenerate a different character
code using the same keyboard-layout resource. For example, the U.S. 'KCHR' and some
other Roman keyboard layouts ignore the Shift modi er key if the Command modi er
key is also pressed. That means you cannot directly use uppercase characters or shifted
symbols as Command equivalents. Furthermore, for those keyboard layouts where the
period is a shifted key, it means that the standard Macintosh command to cancel an
operation (Command-period) cannot be generated. As another example, some
applications that accept Command-? as a request for Help simply assume that C?Ois a
shifted version of O/Q and thus bring up a Help window whenever the Command key
and Q/Oare pressed simultaneously. This gives incorrect behavior on keyboards in which
COis not generated by Shift-/.
To overcome this and similar dif culties, you can use the virtual key code you receive in
the key-down event record, and call KeyTranslate to run it back through the same

keyboard-layout resource, but without the modi er(s) that applied when the character
code was _ rst generated. If the resulting character code is one that is signi cant for a
command equivalent, you can use it plus the modi er state that originally applied to
decide what action to take.
Listing C-2 is a routine that removes the Command-key bit from the modi ers eld of an
event record and runs the same virtual key code through KeyTranslate, using the
same keyboard-layout resource, to see if a different character code results.

Keyboard-Layout Resource (Type 'KCHR’)

C-23

APPENDIX

C

Keyboard Resources

Listing C-2
FUNCTION

Regenerating a character code with KeyTranslate

TryAgain(myEvent:

EventRecord):

LongInt;

CONST

newModifierMask

= $FE0O;

{turn

off

cmdKey

bit}

keep

cmdKey

bit}

VAR

Modifiers:

Integer;

VirtualCode:

Integer;

KeyCode

Integer;

:

someState:

LongiInt ;

KCHRPtr:

Ptr;

BEGIN

{don't
Modifiers

:=

BAnd(myEvent.modifiers,

newModifierMask) ;

{keep
VirtualCode

:=

virtual

BSR(BAnd(myEvent.message,

{assemble
KeyCode

:=

BOr(Modifiers,

KCHRPtr

:=

Ptr (GetScriptManagerMVariable

TryAgain

:=
:=

code,

new

key

put

in

low

byte}

8);

code

for

KeyTranslate}

VirtualCode) ;

{get
someState

key

keyCodeMask),

0;
KeyTranslate(KCHRPtr,

pointer

to

current

(smKCHRCache)

'KCHR'}

) ;

{initialize KeyTranslate dead-key
{see what ascii code is returned}
KeyCode,

state}

someState) ;

{look for returned values in both
{ high and low word of result}

}

END;

In designing Command equivalents for your application, keep in mind that there may be
less chance of inconsistency and confusion if you present Command equivalents to the
userN and interpret them yourselfN as grouped modi ers applied to the basic (unshifted)
character you want to use for the command. (Note, however, that to do so you would

have to write your own custom menu-de nition resource.) For example, you might show
CCommand-Option-POin the menu rather than GCommand-zQ when interpreting it, you
could use KeyTranslate and the virtual key code in the event record to make sure that
the key for Q@Owas pressed, rather than just assuming that QtOis produced by Option-P.
Another possibility is to de ne few Commmand-key equivalents yourself, and to let the
user create as many equivalents as desired.

C-2 4

Keyboard-Layout Resource (Type 'KCHR’)

APPENDIX

C

Keyboard Resources

Keyboard Icon Family (Types ‘kcs#', 'kcs4’, 'kcs8’)
The keyboard icon family is a set of resources (resource types 'kcs#', 'kcs4', and
'kes8') that specify a family of small icons representing a keyboard layout. They de ne
black-and-white, 4-bit, and 8-bit small color icons, respectively. There is one keyboard
icon family per keyboard-layout resource; each of the keyboard icon resources has the
same resource ID as the keyboard-layout resource with which it is associated.
The Operating System loads keyboard icon resources from the System le only. The ID
number of the default keyboard icon family for a script system is speci ed in the
itlbIcon eld of the script@ international bundle (' it 1b') resource. However, the
Operating System ignores this value and instead looks for a keyboard icon family whose
resource ID matches the ID of the keyboard-layout resource it is loading. If it cannot nd
an icon family with that ID, the Operating System loads the default keyboard icon suite
(ID= 16491).
Some differences exist between the keyboard icon family and the color icon families used
elsewhere in the Macintosh Operating System. First, only small icons (16-by-16 pixels) are
supplied; there are no large keyboard icons (32-by-32 pixels). Second, the resource type
for keyboard small color icons is different from the resource type used elsewhere for
small color icons ('ics#',
'1cs4',and 'ics8'). This difference is to avoid resource ID
conficts with those icon resources, because the keyboard color icons may have IDs

anywhere in the range 0 32767, and certain negative ranges as well. The keyboard icon
types and the equivalent standard color icon types are shown in Table C-8.

Table C-8

Keyboard color icon types and standard icon equivalents

Keyboard
icon type

Standard icon
equivalent

Bit
depth

'kes#'!

'1ics#'

1

'kes4'!

'ics4'

4

'kes8'!

'ics8!

8

Note
If the 4-bit and 8-bit icons (resources

'kcs4'

and

'kcs8') in your

application have exactly the same appearance and colors, then you only
need to provide a 4-bit icon.

Keyboard

Icon Family (Types 'kcs#', 'kcs4', 'kcs8')

C-25

APPENDIX

C

Keyboard Resources

The keyboard icons are used in the Keyboard control panel and in the Keyboard menu
when it is displayed. In Macintosh system software versions 7.0 and later, the Keyboard
menu always appears when more than one script system is enabled, and may be forced
to appear even if only one script system is present (if the smf ShowIcon fag in the Script
Manager general fsags is set at startup).
Figure C-8

m

Sample keyboard icons

tl =

wer

=e

we

ONS

PB

See the Finder Interface chapter of Inside Macintosh: Macintosh Toolbox Essentials for
additional information on color icons and icon families. See also Macintosh
Human
Interface Guidelines for design suggestions for color icon families.

Keyboard-Swap Resource (Type 'KSWP’)
The keyboard-swap resource (resource type 'KSWP') speci es the modi er-plus-key
combinations with which the user can change keyboard scripts, keyboard layouts within
scripts, and input methods. For example, the standard keyboard-swap resource speci es
that pressing Command Space bar changes the keyboard to the default keyboard for the
next script. (In this case, next means next in the Keyboard menu.)

There is one keyboard-swap resource per localized version of system software. A
localized system may either use the standard 'KSWP' resource or replace it with one of
its own. The keyboard-swap resource is in the System le; its resource ID is 0.
The keyboard-swap resource consists of an array with series of entries, each of which
speci es modi er-plus-key combinations that can be used to change keyboard layouts
and scripts. Figure C-9 shows the format of entries in the 'KSWP' resource.
Figure C-9

Format of entries in the keyboard-swap resource

Script code or special
negative code
(integer)

C-26

Virtual
key code
(byte)

Keyboard-Swap Resource (Type 'KSWP'’)

Modifier
state
(byte)

APPENDIX

C

Keyboard Resources

The elements of the entry have these meanings:
m Script code or negative code. The code number of a script systemN such as 0
(smRoman)N or a special negative code for switching. The special negative codes are
identical to the selectors for the Script Manager KeyScript procedure. The selectors
are listed and described along with the KeyScript procedure in the chapter CScript
ManagerOin this book.
m Virtual key code. The virtual key code (for example, $31 for Space bar) required to
generate the script code or special negative code of this element.
m Modi er state. The modi er-key setting (for example, Command key down) that must
accompany the virtual key code.
Listing C-3 is a Rez-format de nition of a hypothetical keyboard-swap resource.
Listing C-3

resource
{/*

A hypothetical keyboard-swap resource

'KSWP'

(0,

array:

2

/*

[1]

-1,

$31,

/*

[2]

-4,

$31,

sysheap)
elements

{
*/

smKeyNextScript
controlOff,

=

smKeyNextKybd
controlOff,

*/

optionoff,

shiftoff,

commandOn,

*/
optionoOn,

shiftOff,

commandoOn,

bi
This resource de nes a rotation to the next script system on Command
rotation to the next keyboard layout on Command Option Space bar.

Space bar, and a

Note
The expression that evaluates the size of a keyboard-swap resource is
complicated. If you need to perform a DeRez operation on a
keyboard-swap resource, contact Macintosh Developer Technical
Support for details.
IMPORTANT

The Script Manager removes from the event queue any Command-key
combinations involving the Space bar if that Command-key combination
indicates a feature supported by the current script system. For example,
if multiple script systems are installed, the Script Manager strips the
Command Space bar combination (which speci es changing script
systems) from the event queue. If multiple script systems are not
installed, this event is not removed, so users can use it in Command-key

macros. Applications, however, should never depend on Command-key
combinations involving the Space bar. «

Keyboard-Swap Resource (Type 'KSWP’)

C-27

APPENDIX

C

Keyboard Resources

Key-Caps Resource (Type ‘KCAP’)
The key-caps resource (resource type 'KCAP') refsects the physical layout of a particular
keyboard and is used by the Key Caps desk accessory. The resource indicates the shapes
and positions of all keys, and de nes the virtual key codes that correspond to each
physical key. Key Caps uses this resource to draw a representation of the current
keyboard layoutN using the current keyboard-layout resourceN for the current
physical keyboard. If you are creating a new keyboard, you can de ne its physical
layout in a key-caps resource.
For system software versions 7.0 and later, the key-caps resource is located in the System
le. There is one 'KCAP' resource per physical keyboard on a Macintosh; it belongs to
the Operating System, and not to any script system. The resource ID for each key-caps
resource is equal to the keyboard type of the keyboard it is associated with. See Table C-1
on page C-4 for a list of keyboard types. For ADB keyboards, the ID of the key-caps
resource is the same as the keyboard handler ID.
IMPORTANT

The key-caps resource should never require localization. The only time a
key-caps resource needs to be added is for a keyboard that has a new
physical arrangement (or a new keyboard handler ID). a

Resource Format
Figure C-10 shows the format for the key-caps resource.

C-28

Key-Caps Resource (Type 'KCAP’)

APPENDIX

C

Keyboard Resources

Figure C-10

Format of the key-caps resource

Bytes
5

Boundary rectangle

8

Z

Text rectangle

/ 8

Count of shape entries in main array | 2-"

—
Z

Shape array

Bytes

Count of point entries — 1

2

Point entry

4

Key entry

Bytes

Z

Count of key entries — 1
Shape —

Shape array

2°

VA

Key entry

Z 6

Z

Key entry

/ 6

ownare

entry 1

Modifier mask
Virtual key code

1
11

Boolean

Vertical delta

2

Horizontal delta

2

Shape —

entry 2

Key-Caps Resource (Type 'KCAP" )

C-29

APPENDIX

C

Keyboard Resources

The key-caps resource has these elements:
Boundary rectangle. The position of the content region of the Key Caps window.
Text rectangle. The position of the text box within the Key Caps window.
Main array. The remainder of the resource. It consists of an array of one shape entry
for each key shape.
Each shape entry in the main array has two components:
Shape array. A (zero-based) count of entries followed by one or more entries. Each
entry is a point, representing the relative pixel offset from the origin of the key, that
de nea particular key shape. The shape array is a single point for rectangular keys.
More complex keys, like the Return key, need two points in their shape array.
Key array. A set of key entries, describing all the keys with that shape.
Each key entry in a shape entry speci

es the following information:

Vertical delta and horizontal delta. Vertical and horizontal values to move the pen
before drawing the current key. For each shape (that is, for each shape entry in the
main array), the pen starts out at the upper-left corner of the content region of the Key
Caps window, so the vertical and horizontal delta values for the rst key in the key
array for that shape are distances from the upper-left corner to the origin of the rst
key. For subsequent keys in the key array, the deltas are distances from the origin of
the previous key to the origin of the current key. Each key is drawn with the shape
de ned by the shape array for that shape.
Virtual key code. The virtual key code for the current key. Because it uses virtual key
codes, each key-caps resource is tied directly to a particular key-map resource and
hardware keyboard but can work with any keyboard-layout resource.
Modi er mask and Boolean. A modi er mask and a Boolean fag for how to use it.
When Key Caps draws the current key, it retrieves the byte that represents the real
modi er key state, combines it with this mask performing an OR or AND operation as
speci ed, calls the KeyTranslate function with the resulting modi er byte and the
virtual key code from the key-caps resource, and draws the resulting character or
characters in the current key@ location. The modi er mask is only required for
non-ADB keyboards, which use arti cial modi er key states to overlap the key codes
for arrow keys and keypad operator keys. For other keyboards, the mask is 0 and the
Sag is set to specify an OR operation.

C-30

Key-Caps Resource (Type 'KCAP’)

APPENDIX

C

Keyboard Resources

Listing C-4 is an abridged example of the data in a key-caps resource, shown in
Rez format.

Listing C-4
resource

Sample key-caps resource data in Rez format
'KCAP'

($01)

{60,
{12,

45,
42,
{

{

{

220, 455},
36, 368},

{21,

21}

},

{

/*
/*

boundsRect */
textRect */

/*

Shape

1
*/

*/

$35,

50,

0,

or,

$12,

0,

20;

/*

1!

0,

or,

$13,

0,

20;

/*

2

0,

or,

$7D,

0,

20;

/*

Down

0,

or,

STE,

0,

20;

/*

Up

0,

or,

$41,

0,

80;

/*

Keypad

.

*/

0,

or,

$55,

-20,

/*

Keypad

3

*/

2

*/

31}

},

0;

{

/*

0,

or,

$30,

70,

0,

or,

$33,

-20,

260

36};

{-41,

15}

{

{-21,

0,

or,

$24,

/*

No.

or,

{21,

10;

escape

0,

111,

10;

265

},

{

/*

*/
@

Shape

*/

arrow

arrow

No.

*/

/*

Tab

/*

Backspace

Shape
/*

*/

*/

No.

3

Return

*/

*/

*/

bi
The basic square key has a shape array of { {21, 21} }, which puts the origin in the
upper-left corner of the key. The rst key in the key array for this shape is the Escape key
(key code $35) in the upper-left corner of the keyboard; this key is at vertical and
horizontal delta offsets of (50, 50) from the upper-left corner of the window@ content
region. The next key with this shape is immediately to the right, with its origin at delta
offsets of (0, 20) from the origin of the previous key.

Key-Caps Resource (Type 'KCAP’)

C-31

APPENDIX

C

Keyboard Resources

The next shape is the slightly wider key with a shape array of { {21,

31}

}, used for

the Tab and Backspace keys. The origin of the Tab key is at offsets (70, 10) from the
upper-left corner of the windowG content region (which puts the Tab key one row below
the Escape key).
The shape array for the Return key is { {-21, 36}; {-41, 15} }, which means that
it is the union of two rectangles: the rst rectangle is from the origin of the key to the rst
point, and the second rectangle is from the rst point to the second point. (Both points are
measured relative to the key origin, however.) This shape array puts the Return key@
origin in the lower-left corner of the key. See Figure C-11. The origin is at offsets (111, 265)

from the upper-left corner of the windowG content region.
Figure C-11

Shape array and resulting region for the Return key

Rectangles for
return key:

Resulting
region:

(—41,15)

_
(0,0) key orgin

cl
(0,0) key orgin

Key Caps Desk Accessory
This section discusses how the Key Caps desk accessory uses information in its key-caps
resource to represent the physical layout of a keyboard. It also describes how the
Key Caps desk accessory provides feedback to the user on how dead keys produce
accented characters.

C-32

Key-Caps Resource (Type 'KCAP’)

APPENDIX

C

Keyboard Resources

Listing C-4 on page C-31 is a portion of the data from the key-caps resource ('KCAP'
ID = 1), which is used with the standard ADB keyboard (keyboard type 1, the domestic
layout of the Apple Keyboard II). Working with that resource, the Key Caps desk
accessory produces the display shown in Figure C-12 when it is used with the standard
U.S. keyboard-layout resource ('KCHR' ID = 0).
Figure C-12

Key Caps display with key origins

=

Origin for

Escape

key

e

O17

FKey

wheirit

uj

als|d]f

Ol=]/)%

9) 0)-)=

7]78)

6)

2)3)4)5)

Caps

ijo

h

Fis}

Ki

lj

J2}xfejvib} nfm] } fey

lve

\

:

ale

41516]

-

0

o

1f2f3

Origin for
Return key

The Key Caps desk accessory provides feedback on using dead keys to produce accented
characters. It indicates dead keys with dotted borders, as shown in the Key Caps window
in Figure C-13, which shows the U.S. keyboard layout with the Option
key pressed.
Figure C-13

Key Caps display of dead keys with Option key pressed

aS

Oo

Key

miti¢ic

Caps

es]?

]2)]-le

Oj}=]/]%

Jal...jze

4)5]

elz}jelt]s)°
- ein] ‘J
4|6)a

Qlelo}]y¥

©

A]

“duls|e]
«

+

7) 8] 9] +
6]

-

14273
0

Oo

Option key
”

Dead keys

Key-Caps Resource (Type 'KCAP’)

C-33

APPENDIX

C

Keyboard Resources

If a dead key is entered, such as the circumfex dead-key combination (Option-I), the
display changes to highlight the completer keys for this dead key. The user can press any
completer key to generate valid accented character combinations, as shown in Figure
C-14. If your application displays keyboards, you should use a similar method of
indicating dead keys and completers.
Key Caps display of completer keys after circumflex dead key has been pressed

273347576)

Caps

778797

0]-]=

o>

—ialwhetritlyfotife}p] cy]
falstalrfalniijkjis:] ]
[z}xjec]v}o}njm)
| jel
.

CL]

C-34

.

\

Completer keys

Key-Caps Resource (Type 'KCAP’)

il

O17

Ke

hm}
erp cy!

2 SSS

—;oipa)o

Figure C-14

APPENDIX

C

Keyboard Resources

Summary of the Keyboard Resources
Assembly-Language Summary
Global Variables
KbdType

The keyboard type of the most recently used keyboard

KeylTrans
Key2Trans

Pointer to key-translation routine (for non-ADB keyboards)
Pointer to key-translation routine (for non-ADB keyboards)

Summary of the Keyboard Resources

C-35

APPENDIX OD

Renamed and Relocated
Text Routines

D-1

APPENDIX

D

Renamed and Relocated Text Routines

This appendix lists, in Table D-1, those Macintosh system software routines that
have been renamed or relocated from one manager to another during the reorganization
necessary for the creation of Inside Macintosh: Text. It also lists those calls that have been
rendered obsolete by newer versions of themselves and are therefore removed
from documentation.
Most of the changes have been to text-related routines: the International Utilities Package
and the Binary-Decimal Conversion Package have been replaced by a new manager
called Text Utilities. The Text Utilities include most of their routines and also several
text-related routines that were formerly part of the Toolbox Utilities and Operating
System Utilities.
Many text-related routines that were formerly part of the Script Manager have been
moved to other managers, such as QuickDraw, the Font Manager, the Text Utilities, or the

Menu Manager, to be documented alongside existing routines with similar capabilities.
For example, all routines that measure and draw justi ed text have been moved from the
Script Manager to QuickDraw, to be with the existing QuickDraw text-measuring and
drawing routines.
Many other routines have not been moved, but their names have been changed to

more clearly refsect their functions, to minimize ambiguous interpretations, and to
expand abbreviations.
Some routines that are not related to text handling are listed here. They are former Script
Manager or International Utilities routines dealing with international issues, such as

IUMetric and WriteLocation. Those routines now belong to other managers, as
noted in Table D-1.
Note
Although obsolete routines are no longer documented, they may remain
in system software and their declarations may be maintained in the
interface les for backward compatibility. Renamed routines are no
longer documented under their old names, other than within the table in
this appendix.

D-3

APPENDIX

D

Renamed and Relocated Text Routines

Table D-1

Renamed, relocated, and obsolete text and international routines

Old name

New name

Char2Pixel

(obsolete; use CharToPixel)

Old location

QuickDraw

CharByte

(obsolete; use CharacterByteType)

Script Manager

CharType

(obsolete; use CharacterType)

Script Manager

Date2Secs

DateToSeconds

DrawJust

(obsolete; use DrawJustified)

EqualString

(unchanged)

O.5. Utilities

Text Utilities

FindScriptRun

(unchanged)

Script Manager

Text Utilities

FindWord

(obsolete; use FindWordBreaks)

Font 2Script

Font ToScript

Script Manager

(not moved)

Format2Str

FormatRecToString

Script Manager

Text Utilities

FormatStr2Xx

StringToExtended

Script Manager

Text Utilities

Format X2Str

ExtendedToString

Script Manager

Text Utilities

GetAppFont

(unchanged)

Script Manager

Font Manager

GetDefFontSize

(unchanged)

Script Manager

Font Manager

GetEnvirons

GetScriptManagerVariable

Script Manager

(not moved)

Get FormatOrder

(unchanged)

Script Manager

QuickDraw

GetIndString

(unchanged)

Toolbox Utilities

Text Utilities

GetMBarHeight

(unchanged)

Script Manager

Menu Manager

GetScript

GetScriptVariable

Script Manager

(not moved)

GetString

(unchanged)

Toolbox Utilities

Text Utilities

GetStylHandle

TEGetStyleHandle

TextEdit

(not moved)

GetStylScrap

TEGetStyleScrapHandle

TextEdit

(not moved)

GetSysFont

(unchanged)

Script Manager

Font Manager

GetSysJust

GetSysDirection

Script Manager

(not moved)

HiliteText

(unchanged)

Script Manager

QuickDraw

InitDateCache

(unchanged)

Script Manager

Text Utilities

IUClearCache

ClearInt1lResourceCache

Intl. Utilities

Script Manager

IUCompPString

CompareString

Intl. Utilities

Text Utilities

IUCompString

(obsolete; use CompareSt ring)

IUDatePString

DateString

O.S. Utilities

New location

(not moved)
QuickDraw

Text Utilities

Text Utilities
Intl. Utilities

Text Utilities

APPENDIX

D

Renamed and Relocated Text Routines

Table D-1

Renamed,

relocated, and obsolete text and international routines (continued)

Old name

New name

IUDateString

(obsolete; use DateString)

Old location

IUEqualPString

IdenticalString

IUEqualString

(obsolete; use IdenticalString)

TUGet Intl

GetIntlResource

Intl. Utilities

Script Manager

IUGetItlTable

GetInt1lResourceTable

Intl. Utilities

Script Manager

IULangOrder

LanguageOrder

Intl. Utilities

Text Utilities

IULDateString

LongDateString

Intl. Utilities

Text Utilities

IULTimeString

LongTimeString

Intl. Utilities

Text Utilities

IUMagIDPString

IdenticalText

Intl. Utilities

Text Utilities

IUMagIDString

(obsolete; use

IUMagPString

CompareText

IUMagString

(obsolete; use CompareText)

IUMetric

IsMetric

Intl. Utilities

O.S. Utilities

IUScriptOrder

ScriptOrder

Intl. Utilities

Text Utilities

TUSetIntl

(obsolete; for

Intl. Utilities

Text Utilities

IUStringOrder

StringOrder

Intl. Utilities

Text Utilities

IUTextOrder

TextOrder

Intl. Utilities

Text Utilities

IUTimePString

TimeString

Intl. Utilities

Text Utilities

IUTimeString

(obsolete; use

KeyTrans

KeyTranslate

Event Manager

(not moved)

LongDate2Secs

LongDateToSeconds

Script Manager

O.S. Utilities

LongSecsToDate

LongSecondsToDate

Script Manager

O.S. Utilities

LowerText

(obsolete; use LowercaseText)

Text Utilities

MeasureJust

(obsolete; use MeasureJustified)

QuickDraw

Munger

(unchanged)

Toolbox Utilities

Text Utilities

NChar2Pixel

CharToPixel

Script Manager

QuickDraw

NDrawJust

DrawJustified

Script Manager

QuickDraw

NewString

(unchanged)

Toolbox Utilities

Text Utilities

NFindWord

(obsolete; use

NMeasureJust

MeasureJustified

Intl. Utilities

Text Utilities
Text Utilities

IdenticalText)

TextUtilities
Intl. Utilities

'INTL' resources)

New location
Text Utilities

Text Utilities
Text Utilities

TimeSt ring)

Text Utilities

FindWordBreaks)

Text Utilities
Script Manager

QuickDraw
continued

APPENDIX

D

Renamed and Relocated Text Routines

Table D-1

Renamed,

relocated, and obsolete text and international routines (continued)

Old name

New name

Old location

New location

NPixel2Char

PixelToChar

Script Manager

QuickDraw

NPortionText

PortionLine

Script Manager

QuickDraw

NumToString

(unchanged)

Binary-Dec. Conv.

Text Utilities

ParseTable

(obsolete; use FillParseTable)

Script Manager

Pixel2Char

(obsolete; use PixelToChar)

QuickDraw

PortionText

(obsolete; use PortionLine)

QuickDraw

ReadLocation

(unchanged)

Script Manager

O.5. Utilities

RelString

(unchanged)

O.5. Utilities

Text Utilities

ReplaceText

(unchanged)

Script Manager

Text Utilities

Secs2Date

SecondsToDate

O.S. Utilities

(not moved)

SetClikLoop

TESetClickLoop

TextEdit

(not moved)

SetEnvirons

SetScriptManagerVariable

Script Manager

(not moved)

SetScript

SetScriptVariable

Script Manager

(not moved)

SetString

(unchanged)

Toolbox Utilities

Text Utilities

SetStylHandle

TESetStyleHandle

TextEdit

(not moved)

SetStylScrap

TEUseStyleScrap

TextEdit

(not moved)

SetSysJust

SetSysDirection

Script Manager

(not moved)

SetWordBreak

TESetWordBreak

TextEdit

(not moved)

Str2Format

StringToFormatRec

Script Manager

Text Utilities

String2Date

StringToDate

Script Manager

Text Utilities

String2Time

StringToTime

Script Manager

Text Utilities

StringToNum

(unchanged)

Binary-Dec. Conv.

Text Utilities

StripText

(obsolete; use StripDiacritics)

Text Utilities

StripUpperText

(obsolete; use UppercaseStripDiacritics)

Text Utilities

StyledLineBreak

(unchanged)

Script Manager

Text Utilities

TEGetScrapLen

TEGetScrapLength

TextEdit

(not moved)

TESetJust

TESetAlignment

TextEdit

(not moved)

TESetScrapLen

TESetScrapLength

TextEdit

(not moved)

TEStylInsert

TEStyleInsert

TextEdit

(not moved)

TEStylNew

TEStyleNew

TextEdit

(not moved)

APPENDIX

D

Renamed and Relocated Text Routines

Table D-1

Renamed,

relocated, and obsolete text and international routines (continued)

Old name

New name

Old location

New location

TeStylPaste

TEStylePaste

TextEdit

(not moved)

TextBox

TETextBox

TextEdit

(not moved)

ToggleDate

(unchanged)

Script Manager

O.S. Utilities

Transliterate

(obsolete; use TransliterateText)

TruncString

(unchanged)

Script Manager

Text Utilities

TruncText

(unchanged)

Script Manager

Text Utilities

UpperText

(obsolete; use UppercaseText)

UprString

UpperString

O.S. Utilities

Text Utilities

ValidDate

(unchanged)

Script Manager

O.S. Utilities

VisibleLength

(unchanged)

Script Manager

QuickDraw

WriteLocation

(unchanged)

Script Manager

O.S. Utilities

Script Manager

Text Utilities

Glossary
active input area In inline input, the area of the
application window in which the user enters text
for conversion by a text service component. The
application and the text service component share
responsibility for the active input area.

Arabic numerals

In the Macintosh script

advance width The full width of a glyph,
measured from the glyph origin to the other side
of the glyph, including any white space on
either side.

ascent line An imaginary horizontal line that
coincides with the tops of the tallest characters in
a font. See also base line, descent line, x-height.

management system, numerals native to

the Arabic writing system and not used in
the Roman writing system. Compare
western numerals.

The horizontal placement of lines of

ASCII character set The standard set of Roman
characters, with character-code values from $00 to

text area. Alignment can be left, right, centered, or

from character codes with values from $80 to $FF,

alignment

text with respect to the left and right edges of the
justified (Sush on both left and right edges). Not
to be confused with line direction.
alphabet

The set of letters, or characters, used

to write a language. The alphabet used by the
Roman script consists of 26 letters.
Appleevent
A high-level event that is
used for communication and data sharing
among applications.

Apple event handler Anapplication-de ned
function that extracts pertinent data from an
Apple event, performs the action requested by the
Apple event, and returns a result.
application font The default font for use by
applications. The application font is de ned by
each script system.
Arabic calendar A lunar calendar used in much
of the Arabic world. There are two Arabic
calendars supported by the Arabic script system:
the astronomical lunar calendar, based on the

moon@ phases as actually observed at each

location around the world; and the civil lunar

calendar, a statutory version of the astronomical
calendar. In both versions, the positions in time of
each month vary from year to year.

$7F. Also called low ASCII, to distinguish them

which are sometimes called high ASCH or extended
ASCH. The Roman characters that are part of each
non-Roman character set are the low ASCII set

only. Compare Macintosh character set and
Standard Roman character set.

associated font A Roman font whose glyphs are
automatically substituted for glyphs of a
non-Roman font, for characters in the Roman

range. For example, the Arabic script system uses
an associated font to display all Roman
characters, even within script runs of Arabic text.

attribute type An integer constant describing a
data attribute of a dictionary entry.
auxiliary script A script system other than the
system script that is available for application use.
An auxiliary script can be used in documents, but
it does not affect the default behavior of the
system software.
background
The part of a glyph bitmap that
surrounds the pixels that constitute the glyph
itself. Compare foreground.
background color The color that QuickDraw
applies to the background parts of a glyph;
speci ed by the bkColor eld of the current
graphics port.

GL-1

GLOSSARY

base line
An imaginary horizontal line that
coincides with the bottom of each character in

a font, excluding descenders (tails on letters
such as p).

Bézier curve Acurve, used for de ning
character shapes in outline fonts, de ned by three
outline points: two on-curve points that serve as
endpoints and one off-curve point that
determines the degree of curvature.
bidirectional script system A script system
where text is generally right-aligned with most
characters written from right to left, but with
some left-to-right text as well. Arabic and Hebrew
are bidirectional script systems.
bitmapped font A font made up of bitmapped
glyphs. Compare outline font.
bitmapped glyph A bitmap of a character
designed for display ata xed point size for a
particular display device.

canonical string The preferred representation of
a character or string in a particular writing
system, language, or region, often corresponding
to a token type de ned by the Script Manager
Int 1Tokenize function. For example, the left

literal double curly quotes (O can, in the
appropriate context, also be represented as double
straight quotes ("'). This stored preference is the
canonical string.
caret A vertical blinking bar within a line of
displayed text that marks the insertion point.
Compare cursor.
caret position A location (on the screen)
corresponding to the offset (in memory) of the
current text insertion point. At the boundary
between a right-to-left and left-to-right direction
run on a line, one character offset may correspond
to two caret positions, and one caret position may
correspond to two offsets.

Bopomofo
Chinese phonetic characters. Also
called Zhuyinfuhao.

case Uppercase or lowercase, an attribute of
the characters of some writing systems such
as Roman.

bottomline input

character

A type of input method in

which the user enters text in a small window,

called a floating input window, that appears near
the bottom of the screen.
B*-tree A data structure used by the Dictionary
Manager to organize dictionary index entries for
fast searching.
bundle resource
(1) Aresource of type 'BNDL'
that is used by the Finder to associate an
application and its les and icons. (2) A script
system@ international bundle resource.
byte offset

The indexed position of a byte ina

text buffer, starting at zero for the

rst byte. In

1-byte script systems, byte offset is the same as
character offset, and sequential values for byte
offset correspond to the storage order of the
characters. In 2-byte script systems, byte offset
and character offset are different.

GL-2

A symbol standing for a sound,

syllable, or notion used in a script; one of the

simple elements of a written language, for
example, the lowercase letter Q@Oor the number
C1O Compare character code, glyph.
character attribute

The font, size, style, or color

of text. Text of a single style run has uniform

character attributes.

character class
A return value of the
CharacterType function. Character class is a

subtype of character type.

character cluster A collection of characters
treated as individual components of a whole,
including a principal character plus attachments
in memory. For example, in Hebrew, a cluster
may be composed of a consonant, a vowel, a dot
to soften the pronunciation of the consonant, and
a cantillation mark.

GLOSSARY

character code An 8-bit or 16-bit value
representing a text character. Text is stored in
memory as character codes. Each script system@
keyboard-layout ('KCHR') resource converts the
virtual key codes generated by the keyboard or
keypad into character codes; each script system@
fonts convert the character codes into glyphs for
display or printing.
character-code mapping table A table ina font
that matches character codes to glyph indexes.
character encoding The organization of the
numeric codes that represent the characters of a
character set in memory.
character key A key that generates a keyboard
event when pressed (any key but Shift,
Caps Lock, Command, Control, or Option).

character offset
(1) The indexed position of a
character in a text buffer, starting at zero for the

rst character. Sequential values for character
offset correspond to the storage order of the
characters. In 1-byte script systems, character
offset is equivalent to byte offset; in 2-byte

systems it is not. (2) The horizontal separation

between a character rectangle and a font
rectangleN that is, the position of a given
character within the font@ bit image.
character origin

See glyph origin.

character type A return value of the
CharacterType function. Character type
describes the features of a given character,
such as whether it is a letter, number, or

subscript character.

character width The distance from one
character@ origin to the next character@ origin.
It is how far QuickDraw moves the pen after
drawing a character.
client application A program that requests text
services such as input methods, spell-checking,
and hyphenation from the Text Services Manager.
Client applications use the Text Services Manager
to search for, obtain information about, and
communicate with text service components.

completer key A keypress, following a dead
key, that generates a character. The key e is a
completer key for the dead-key combination
Option-E.
completion character The character produced
by acompleter key. The completion character for
the completer key e pressed after the dead-key
combination Option-E is é.
component
A software module of the speci c
type managed by the Component Manager. See
also text service component.

component instance A single executing version
of a component. There can be more than one
instance of a given component running at
one time.
Component Manager
The part of system
software that allows applications to nd and use
at runtime prede ned classes of software objects
called components.
configuration resource
configuration resource.

See international

confirm To accept converted text in an active
input area or Soating input window as nal and
send it to the application. Compare convert,
raw text.

context dependence
In text, when the glyph
corresponding to a character may be modi ed
depending on the preceding or following
characters in the text.
contextual script system

Ascript system, such

as Arabic, in which the displayed glyph for a

character may be context-dependent. It may be
modi ed based on the characters it is adjacent to.
continuous style In TextEdit, a style value that
is constant over an entire selection range.
convert To change the text entered in an active
input area or Soating input window into an
ideographic or other complex form. An input

method converts raw text, such as Hiragana, into
converted text, such as Kanji. See also confirm.

GL-3

GLOSSARY

current font The current font for drawing text;
the font speci ed inthe txFont eld of the
current graphics port.
current port The graphics port to which the next
drawing or measuring operation applies. The
current port is speci ed by the global variable
thePort, and changed by the QuickDraw
Set Port procedure.
current script The script system currently used
for text manipulation or display. It is the script
system used by a script-aware text-handling
routine when the identity of the script or its
resources is not an explicit parameter of the call.
The current script can be either the font script or
the system script.
cursive font A set of characters in one typeface
in which letters are connected together as in
cursive handwriting.
cursor

An arrow, I-beam marker, spinning disk,

or other small icon that marks a screen location

and moves with the mouse. Compare caret.

data attribute Ina dictionary, some information
about raw dataN for example, grammatical or
context-sensitive details.
Date & Time control panel A control panel that
allows the user to set the current date and time
and to specify formatting preferences for both.
date cache A temporary storage area used to
convert strings to date and time values.
dead key Akeypress or modi er-plus-keypress
combination that produces no immediate effect,
but instead affects the character or characters
produced by the next key (called the completer
key) that is pressed. For example, in the U.S.
Roman system Option-E has no effect; however,

when you type e after pressing Option-E, the
accented form appears: é.
derived font

A font whose characteristics are

partially determined by modifying an intrinsic
font. A derived font might be one whose

characters are scaled from an intrinsic font to
achieve a desired size or are slanted to achieve an

italic style.

GL-4

descent line An imaginary horizontal line that
coincides with the bottoms of character
descenders (such as the tail on a lowercase p)
extending farthest below the base line. See also
ascent line.
destination rectangle In TextEdit, the rectangle
de ning the area in which the text is drawn.
Text drawn in the destination rectangle is
made visible to the application user in the
view rectangle.
diacritic or diacritical mark A sign that
modi es the implicit sound or value of the
character with which it is associated. For example,
in the Roman system, the acute accent («) is a

diacritical mark.
dictionary

Acollection of records used by input

methods and other software modules that let the
user enter, format, and process text. See also main

dictionary, user dictionary.

dictionary entry An item associated witha
dictionary key. Each entry consists of raw data
plus optional data attributes.
dictionary key A Pascal search string that may
have a maximum length of 129 bytes. Data
associated with the key may consist of one or
more dictionary entries.
Dictionary Manager
The part of Macintosh
system software that makes dictionaries available
to input methods.
dictionary record Ina dictionary, a key and one
or more entries (data associated with the key).
direction

See line direction.

direction boundary A point between offsets in
memory or glyphs on a display, at which the
direction of the stored or displayed text changes.
direction run

A contiguous (in memory)

sequence of characters having the same
right-to-left or left-to-right line direction.

discontinuous highlighting A highlighting
effect that can occur when a selection range
crosses one or more direction boundaries.

GLOSSARY

discontinuous selection A type of selection
range in which the selected characters themselves
are not contiguous in memory. Not to be confused
with discontinuous highlighting.
dispatch routine A routine ina script system
that dispatches script utility calls. WorldScript I
and WorldScript II each contain a single dispatch
routine that works for all compatible 1-byte and
2-byte scripts, respectively.
dispatch table A table that is part of a script
system@ script record; it contains the addresses of
the script utilities for that script system.
display line The horizontal extent of an area for
drawing text on a display device. The left and
right ends of the display line are the text area@
left and right margins.
display order The left-to-right order in which
glyphs are drawn on a screen by QuickDraw.
Because not all text is read left-to-right, the
display order of glyphs may be different from the
storage order of their corresponding character
codes in memory.
dithering A technique of mixing existing colors
to create the effect of additional colors. Used by
QuickDraw to draw dimmed text on the screen.

dual caret A high caret and a low caret, each
measuring half the line@ height. The dual caret
appears only when the text insertion point is at
the boundary between two direction runs in a line
of text. The high (primary) caret is displayed at
the primary caret position, corresponding to the
character offset in the direction run that
corresponds to the system direction. The low
(secondary) caret is displayed at the secondary
caret position, corresponding to the character
offset in the direction run that is counter to the
system direction. When the caret position is
unambiguous (not on a direction boundary), the
primary and secondary carets are at the same
position, so the user sees one caret. Compare

single caret.

enable To make a script system available.
The Script Manager and the script extensions
enable only those script systems that have a
required set of resources and fonts. Compare

encoding/rendering resource An international
resource of type 'it15'. The encoding/rendering
resource speci es character encoding or rendering
information for a particular script system. The
encoding /rendering resource is optional and has
different formats in 1-byte and 2-byte script
systems.

entry

See dictionary entry.

explicit scaling Scaling performed by the Font
Manager when an application speci cally asks
QuickDraw to change text from a particular size
or shape to another. Compare implicit scaling.
fixed input In inline input, text that has already
been converted from phonetic to ideographic

representation, and thus can be removed from the

active input area. Usually, the text service
component continually gets rid of xed input. In
certain situations, a client application may need to
explicitly x input, if for example it must suspend
input in progress.
fixed token A token associated with a single,
invariant set of characters. The token
tokenPeriodisa

xed token; it represents a

period (.). The token tokenNumeric isnot
it could represent any number.

xed;

fixed-width font A font whose characters all
have the same width. Compare proportional font.
floating input window A fsoating window used
for text entry by an input method.
floating window
A window that is similar to a
standard Window Manager window except that it
occupies a special layer so that it always remains
in front of any application windows.
floating window service Aservice, managed by
the Text Services Manager and the Process
Manager, that provides foating windows for text
service components.
font (1) For bitmapped fonts, a complete set of
glyphs in one typeface, size, and style. (2) For
outline fonts, a complete set of glyphs in one
typeface and style. A font also has a table that
associates those glyphs with their equivalent
character codes.

install, initialize.

GL-5

GLOSSARY

font characterization table A table of
parameters in a device driver that speci es how
best to adapt fonts to that device.

font scaling factors Ratios that indicate how the
Font Manager should scale a glyph in the vertical
and horizontal directions.

font family A complete set of fonts for one
typeface including all available styles and sizes of
the glyphs in that typeface. A font family may
include both bitmapped and outline fonts. Font
families are de ned by resources of type 'FOND'.

font script The script system that corresponds
to the current font (the font speci ed in the
txFont eld of the current graphics port), hence
the script that determines in which writing
system to display text characters in the window.

font-family ID The number that identi es the
resource le (of type 'FOND') that speci es the
font family. Every font family has a unique
font-family ID, in a range of values that
determines the script system to which the font
family belongs.
font force flag A Script Manager variable that
forces text whose font has an ID in the range of
the Roman script system to be interpreted as
belonging to the system script instead.
font height The vertical distance from a font@
ascent line to its descent line.
fontID
(1) Font-family ID. (2) The number that
identi es the resource le of a particular
individual font, of type' FONT',

'nfnt',

or 'sfnt'.

font layout (1) The mapping of character codes
to the glyphs of one typeface. (2) The mapping of
glyph indexes to the glyphs of one typeface.
Font Manager
The part of the Toolbox that
supports the use of various fonts for QuickDraw
when it draws text.
fontname

The name, such as Geneva or Kyoto,

given to a font family to distinguish it from other
font families.

fontnumber

See font ID.

font rectangle The smallest rectangle enclosing
all the glyphs in a font if the images are all
superimposed over the same glyph origin.
fontrun
Asequence of text that is contiguous in
memory and in which all characters are in the
same font.
font scaling The process of changing a glyph
from one size or shape to another. The Font
Manager can scale bitmapped and outline fonts
by changing both sizes and shapes of glyphs.

GL-6

font size

The size of the glyphs in a font in

points; nominally a measure of the distance from
the base line of one line of text to the base line of

the next line of single-spaced text.

foreground
The part of a glyph bitmap that
constitutes the glyph itself. Compare
background.
foreground color The color that QuickDraw
applies to the foreground parts of a glyph;
speci ed by the fgColor eld of the current
graphics port.
full justification

See justification.

garbage data _ A type of data in a dictionary that
exists if the size of the information associated
with a key increases or decreases or if the
information is deleted. This data is no longer used
by the dictionary.
global width table A data structure used by
the Font Manager to communicate character

widths to QuickDraw.

glyph The distinct visual representation of a
character in a form that a screen or printer can
display. A glyph may represent one character (the
lowercase a), more than one character (the fi

ligature, two characters but one glyph), or a
nonprinting character (the space character).

glyph index Anumber that speci esa
particular glyph in a font. Some fonts directly
specify glyphs with character codes, whereas
others map character codes to glyph indexes,
which in turn specify the glyphs.
glyph origin The point on a base line used as a
reference location for drawing a glyph.
QuickDraw draws a glyph so that the glyph
origin corresponds to the current pen position.

GLOSSARY

graphics port Acomplete drawing environment
in QuickDraw, including such elements as a

bitmap, a subset of it in which
to draw, a character font, patterns for

drawing and erasing, and other graphics
characteristics. Graphics ports can be either
black-and-white (data type graf Port) or color
(data type CgrafPort).
greeked Said of text that is drawn so that its
individual characters are replaced with shading
or illegible marks. Text at very small point sizes is
often greeked when drawn to the screen.
Gregorian calendar ‘The calendar used in
Europe and America. It is not universally
acceptedN for example, different calendar
systems are often used in Japan, China, and the
Middle East.
Han
A general term for Chinese-derived
ideographic characters. Includes Hanzi, Kanji,
and Hanja.
Hangul
A Korean subscript which consists of
blocks of component glyphs called Jamo that are
arranged and transformed into boxes. Hangul
characters differ from typical character clusters in
that they are treated as singular units in memory;
there are no principal characters and attachments.
Hanja_ Korean ideographic characters borrowed
from Chinese.
Hanzi

Native Chinese ideographic characters.

high caret

See primary caret.

highlighting The display of text in inverse
video or with a colored background, to designate
a selection range.
Hiragana Acursive, phonetic subscript of the
Japanese writing system, with 50 syllables that
represent all sounds of the Japanese language.
Compare Katakana.
ideographic A type of character representation
in which characters do not represent

pronunciation alone, but are also related to

the component meanings of words; for example,
Japanese Kanji, Chinese Hanzi, and

implicit scaling Scaling performed by the Font
Manager when an application asks QuickDraw to
draw text in a size that is not represented by the
available fonts. Compare explicit scaling.
index

(1) The part of a dictionary through which

records are retrieved. Each index entry contains a
key. (2) A zero-based, ordinal position in a buffer

or data structure.

initialize For a script system, to create and set
up a script record at system startup. Script
systems either initialize themselves or are
initialized by the Script Manager. Only script
systems that are installed can be initialized.
inline input An input method that allows the
user to enter text directly into a document. In
inline input, entry and conversion of characters
take place at the current line positionN where the
converted text is intended to appearN rather than
in a separate window. Inline input is the principal
example of the kind of text service supported by
the Text Services Manager.
input method
A software facility for 2-byte
script systems that converts phonetic or syllabic

characters, entered from a keyboard, into

ideographic or other complex representations of
text. Because 2-byte script systems have too many
characters to be entered directly from a keyboard,
the input method uses a conversion technique,
such as translating sequences of phonetic
characters that are typed into a special input
window. For example, the Japanese script system
provides software for transcribing Kana (phonetic
Japanese) into ideographic Kanji.
insertion mode
For a dictionary, the manner in
which insertion of a new record occursN for
example, whether its data adds to or replaces data
of an existing matching key.
insertion point

A

location (offset) in a text

buffer at which the next insertion or deletion of
text is to take place. An insertion point is
equivalent to a selection range of zero characters.
install ‘To place (the resources of a script system)
in the System le.

Korean Hanja.

GL-7

GLOSSARY

intercharacter spacing Extra pixels that are
added between glyphs, in addition to the space
surrounding the glyph as de ned by the font, in
formatting or justifying text.
interface type Aspeci cation of the set of Apple
events and component commands associated
with a component; part of the component
description record. Currently, all text service
components have the same interface type:
kText Service, whose associated 4-character tag
is 'tsvc'.
international bundle resource An international
resource of type 'itlb'. The international
bundle resource identi es the complete set of
international resources and keyboard resources
used by a script system. It also speci es some of
the script@ default behavior. Every script system
has one international bundle resource.
international configuration resource An
international resource of type 'itlc'. The
international con guration resource identi es and
con gures the system script. There is only one
international con guration resource for each
Macintosh System le, regardless of the number
of script systems it supports.
international resources Aspeci c set of
resources used by the Script Manager, the Text

Utilities, and TextEdit. The international resources

contain information speci c to language or
region, such as date and time formats, sorting
order, and word-break rules.

international resources cache
A cache that
holds resource IDs of international resources used

by an application.

international resources selection flag A Script
Manager variable that determines which set of
international resources are to be used for text
processing operations. When the fag is set, the
resources belonging to the system script are used.
When the fag is clear, the resources belonging to
the font script are used.
interword spacing Extra pixels that are
added to word delimitersN whether white
space or extension barsN when formatting or
justifying text.

GL-8

intrinsic font
A font whose characteristics are
entirely de nedina 'FONT' or 'NFNT' resource.
The plain-style font of any family is an intrinsic

font. Other styles may or may not be intrinsic.
Compare derived font.
'it10'

resource

See numeric-format

resource.

'it11'

resource

See long-date-format

resource

See string-manipulation

'1t14'

resource

See tokens

'it15'

resource

See encoding/rendering

resource

See international bundle

resource.
'it12'

resource.
resource.

resource.
'itlb'
resource.

'itlc' resource
See international
configuration resource.

'itlk' resource

See key-remap resource.

'itlm' resource

See script-sorting resource.

Jamo

An individual phonetic glyph in the

Korean script that is transformed and combined
into clusters called Hangul.

jumping caret

See single caret.

justification A type of alignment that involves
the spreading or compressing of printed text to t
into a given line width so that it is Sush on both
left and right edges of the text area (destination
rectangle).
Kana _ A collective term for the Japanese
subscripts Hiragana and Katakana.
Kanji Japanese ideographic characters
borrowed from Chinese.
kashida Extension bars drawn between speci
Arabic characters to create justi ed text.

c

Katakana
An angular, phonetic subscript of the
Japanese writing system, with 50 syllables that
represent all sounds of the Japanese language.
Compare Hiragana.
'KCAP'

resource

'KCHR' resource
resource.

See key

caps

resource.

See keyboard-layout

GLOSSARY

'kcs#' resource

See keyboard icons family.

'kcs4' resource

See keyboard icons family.

'kcs8' resource

See keyboard icons family.

kern ‘To draw part of a glyph so that it overlaps
the space of an adjacent glyph.
key

See dictionary key.

keyboard
(1) A hardware input device
consisting of an array of keys that the user presses

in order to enter text into the computer. (2) For the

Macintosh script management system, a
keyboard-layout resource that provides for
keyboard input in a given script system. In this
sense, to change keyboards means to activate a
different keyboard layout, rather than physically
switching keyboards.
Keyboard control panel A control panel that
allows the user to switch among available
keyboard layouts.

keyboard equivalent The combination of the
Command key and another key, used to invoke a
menu item from the keyboard.
keyboard icon Asmall icon associated with
each keyboard through its keyboard-layout
('KCHR') resource. Keyboard icons are used
in the Keyboard menu and the Keyboard
control panel.
keyboard icon family

A set of keyboard

Keyboard menu) Amenuon the right side of the
menu bar that appears when more than one script
system is enabled. The Keyboard menu is
managed by the Operating System and permits
the user to change keyboard layouts, input
methods, and script systems for text input.
keyboard resources Aspeci c set of resources
used by the Script Manager, the Text Utilities, and
TextEdit for text input. The keyboard resources
provide for text input in any language from any
keyboard, for convenient switching from one

input language to another ona single keyboard,
and for simultaneous input from multiple
keyboards.
keyboard script The script system for keyboard
input. It determines the character input method
and the mapping of keystrokes to character codes.
The keyboard script may be different from the
font script, which determines how text is
displayed.
keyboard swap resource A keyboard resource
of type 'KSWP'. The keyboard swap resource
speci es key combinations that can be used to
change the keyboard script and the current
keyboard layout. There is one 'KSWP' resource

per system.

Key Caps
Adesk accessory that displays the
keyboard layout for a given keyboard and a
speci ed font.

There is one keyboard icon family for every
keyboard-layout ('KCHR') resource.

key caps resource A keyboard resource of type
'KCAP'. The key caps resource speci es the
physical arrangement of keys on a keyboard and
is used by the Key Caps desk accessory. There is
one 'KCAP' resource for each physical keyboard
supported.

keyboard layout (1) Thespeci cation of the
physical arrangement of keys on a keyboard and
the characters produced when those keys are
pressed. (2) The keyboard-layout resource.

key code An integer representing a key on the
keyboard or keypad, without reference to the
character the key stands for. See also raw key
code and virtual key code.

keyboard-layout resource A keyboard resource
of type 'KCHR'. The keyboard-layout resource
de nes a particular character set by associating a
character code with each virtual key code
produced by a keystroke or combination of
keystrokes on the keyboard or keypad. Each
script system has one or more 'KCHR' resources.

key entry Ina Dictionary Manager dictionary,
contains raw data and optional attributes. Each
entry may have a maximum length of 256 bytes.
The maximum length of the associated data is
1024 bytes.

resources, of types

'kcs#',

'kcs4', and

'kes8'. The keyboard icon family speci es
keyboard icons for screens of different bit depth
(black-and white, 4-bit, and 8-bit, respectively).

GL-9

GLOSSARY

key-map resource A keyboard resource of type
'KMAP'. The key-map resource takes the raw key
codes that have been generated by the keyboard
microprocessor and maps them into standard
virtual key codes. There is exactly one 'KMAP'
resource for each physical keyboard on a
Macintosh system.
key-remap resource A keyboard resource of
type 'it1k'. The key-remap resource provides
hardware-speci c modi cations for certain
keyboards. It remaps a few key combinations into
the virtual key codes needed for input to certain
versions of the keyboard-layout ('KCHR')
resource. There is one 'it1k' resource for every
'KCHR' resource that needs one.
key translation The process of converting raw
key codes to virtual key codes, and thence to
character codes, during text input.

'KMAP' resource

See key-map resource.

'KSWP' resource

See keyboard swap resource.

language
For the Macintosh script management
system, a particular implementation of a writing
system. Languages within a writing system
usually share a character set but differ in rules
of composition. For example, English and
Spanish are two languages within the Roman
writing system.
language code A number used to indicate a
particular written version of a language on the
Macintosh. Constants are de ned for each of the
language codes recognized by the Macintosh
script management system.

large character set

A character set with more

than 256 characters. Japanese, Chinese, and

Korean writing systems have large character sets.
The script system for such a writing system
requires 2-byte character codes, and is therefore
called a 2-byte script system.
leading (pronounced “LED-ing”)
The amount
of blank vertical space between the descent line of
one line of text and the ascent line of the next line
of single-spaced text. In early typesetting, strips
of lead were placed between lines of type for
spacing, hence the term. See also line spacing.

GL-10

leading edge The edge of a glyph that is
encountered rst when reading text of that
glyph@ script system. Compare trailing edge.
ligature

A glyph that is created when two

or more characters are combined to create a
new character.

line breaking The automatic continuation of
text from the end of one line to the beginning
of the next without ending the line in the middle
of a word.
line direction

Also called text direction, character

direction, or simply direction. The direction in
which text in a particular language is written and

read. The English language has a left-to-right line

direction; Arabic and Hebrew have a (primarily)
right-to-left line direction. See also system
direction. Line direction is not the same as
alignment.

line spacing The vertical distance between two
lines of type, measured from base line to base
line. For example, 10/12 indicates 10-point type

with 12 points base to base (that is, with 2 points

of leading).

localization The adaptation of system software
or applications to a particular language or region.
Localization involves translating strings and
providing proper conventions for sorting, date
and time formats, currency and measurement
units, calendars, numbers, and other culturally

speci

c items such as icons.

localized system software Macintosh system
software that has been adapted to a particular
language or region. Localization may involve
adding a second script system, as in the case of
Japanese system software; or it may simply
require modifying the U.S. Roman script system,
as in the case of French or Turkish system
software.
long-date-format resource An international
resource of type 'it11'. The long-date-format
resource de nes conventions for formatting long

dates, including names of days and months. Each

installed script system has one or more
long-date-format resources.

GLOSSARY

low ASCII character set Same as ASCII
character set; the standard set of Roman
characters with character-code values from
$00 to $7F.

low caret

See secondary caret.

Macintosh character set The characters and
character codes originally de ned for the
Macintosh computer. The Macintosh character set
consists of the ASCII character set, plus
additional characters (sometimes called high

ASCH or extended ASCII) with character codes

between $80 and $D8. Compare Standard Roman
character set.
Macintosh script management system The
Script Manager, the script-aware parts of other
text managers, the WorldScript extensions, and
one or more Macintosh script systems.
main dictionary A dictionary that contains most
of the information used by an input method for
its conversion operations. Compare user
dictionary.
missing character glyph The glyph ina font
that is drawn when no glyph is de ned fora
character code in a font.
mixed-directional text

The combination

of writing systems with left-to-right and

right-to-left directionsN within a single line
of text.

modifier key Any of the following keys ona
Macintosh keyboard: Option, Caps Lock, Shift,
Command, Control.

monospaced font

See fixed-width font.

monostyled edit record

A TextEdit record used

to contain text that is set in a single font, size,
and face.

mouse-down region The region between the
caret position and the middle of an adjacent
character that maps unambiguously to a single
character offset.
moving caret

See single caret.

multistyled edit record A TextEdit record that
contains text with style information that can vary
from character to character. A multistyled edit
record contains a number of additional subsidiary
data structures that support the text styling
information.
native Characters in a character set that belong
to the character set traditionally de ned for the
writing system of that font. For example, a
Hebrew font can display both Hebrew characters
and Roman characters. The Hebrew characters are
native to the font and the script system; the
Roman characters are not.

neighborhood base font The font with
the lowest font family ID for a particular
script system.
no-match character The character produced
when the keystroke that follows a dead key is a
space character or is not a valid completer key.
The no-match character is usually a stand-alone

accent form; for example, the no-match character

for the dead-key combination Option-E is «

null scrap Ascrap that is created and initialized
for a TextEdit multistyled edit record to store
style information associated with an insertion
point.
number parts table A table in the tokens
resource that contains number-formatting
information.
Numbers control panel A control panel that
allows the user to specify default number and
currency formats for text of the system script.
numeric-format resource

An international

resource of type 'i1t10'. The numeric-format
resource de

nes conventions for formatting

numeric strings. Each installed script system has
one or more numeric-format resources.

off-curve point An outline point between two
on-curve points that determines the curve of the
line between the two on-curve points. A Bézier
curve is de ned by all three points.
on-curve point One of the outline points that
determines the shape of a Bézier curve. Two
on-curve points and one off-curve point are
required to de ne the curve.

GL-11

GLOSSARY

1-byte complex script system A script system
that supports a writing system with a small
character set (requires only 1-byte characters), but
that is characterized by bidirectional or contextual
text. Arabic and Hebrew are examples of complex
1-byte script systems.
1-byte extension

See WorldScript I.

1-byte simple script system A script system
that supports a writing system with a small
character set (requires only 1-byte characters), has
a left-to-right text direction only, and that is
non-contextual. The Roman script system is an
example of a 1-byte simple script system.
Operating System
Aspeci c installation of
Macintosh system software. The Operating
System (or system) consists of the System le and
its associated resources, and the Operating
System components of the ROM-based Macintosh
Toolbox.
outline font A font made up of outline glyphs
in a particular typeface and style, with no size
restriction. The Font Manager can generate
thousands of point sizes from the same
outline font.
outline highlighting The highlighting of a
selection range by drawing an outline around the
selected characters. Typically used to show a
selection range in an inactive window.
outline point A point used by the Font Manager
to calculate the lines and curves that constitute an
outline glyph. See also on-curve point and
off-curve point.
Pascal string An array of characters, consisting
of a length byte followed by up to 255 bytes of
data. Compare text string.
pen position The screen position where
QuickDraw begins to draw a character, as
speci ed by the penLoc eld of the active
graphics port.
Pinyin Asystem for writing Chinese
ideographs by using Roman letters to represent
the sounds.
point A QuickDraw data structure that de nes
a screen location.

GL-12

port

See graphics port.

port font The font for drawing text in a graphics
port, as speci edinthetxFont eld of the
graphics port record.
primary caret The high caret that is displayed at
the primary caret position; part of a dual caret.
primary caret position When a dual caret
appears, the screen location that marks the
insertion point for text whose line direction
matches the primary line direction.
primary line direction The dominant line
direction (right-to-left or left-to-right) of the
current text. The primary line direction is
typically speci ed by the value of the system
direction global variable, SysDirection.
private scrap
TextEdit.

Ascrap used exclusively by

proportional font

Any font in which different

characters have different widths; thus, the space

taken up by words having the same number of
letters can vary.

raw data_ Ina dictionary, any information
related to the key entry. The information can be
the explanation of the key in a general
dictionary, or perhaps all the Han characters with
the pronunciation of the key entry in an East
Asian dictionary.
raw key code A key code generated by a
keyboard prior to any processing by the 'KMAP'
resource. See also virtual key code.
raw text Characters in an active input area or
Soating input window that have not yet been
converted to ideographic or other nal form.
Compare convert, confirm.
region For the Macintosh script management
system, a particular subset of a language. A
region can represent a linguistic or cultural entity,
not necessarily corresponding to a nation, whose
language is different enough from other versions
of the same language that it merits a speci c
localized version of Macintosh system software.
For example, U.S. and British are two regional
variations that are subsets of the English
language.

GLOSSARY

region code Anumber indicating the Macintosh
version of the written language of a particular
region. Constants are de ned for each of the
region codes recognized by the Macintosh script
management system.
Roman character set

Aset of characters used for

the Roman writing system. Roman character sets

include the Standard Roman character set,
Macintosh character set, and ASCII character set.

Roman writing system The visual
representation of words and letters based on the

Roman alphabet (a, b, c, and so forth). Developed

during the Roman empire, Roman is the most
widely used writing system in the world today.
For example, Roman is used in most countries of
Europe, the Americas, Africa, Oceania, and some

Asian nations.

run Asequence of characters that are
contiguous in memory and share a set of common
attributes. See, for example, direction run, script

run, font run, and style run.

scaling The adjustment in size or shape of the
glyphs of a font. The Font Manager performs both
implicit scaling and explicit scaling, at the
request of QuickDraw.
script

See script system.

script-aware Said of a routine or
system-software manager that takes the current
script system into account when manipulating or
displaying text.
script code Anumber indicating a particular
script system on the Macintosh. Constants are
de ned for each of the script codes recognized by
the Macintosh script management system.
script-defaulted result flag A Script Manager
variable that indicates whether the system script
has replaced the font script due to the
unavailability of the font script.

script extension A part of the Macintosh script
management system that allows for convenient
and ef cient creation of new script systems. Each
script system provides tables in its international
resources that specify the proper
text-manipulation and formatting behavior; the
script extension interprets those tables when an
application makes a text-related call. There are
two script extensions: WorldScript I, the
universal 1-byte script system extension, and
WorldScript II, the universal 2-byte script
system extension.
script-forced result flag A Script Manager
variable that indicates whether the system script
has replaced the font script due to font forcing.
script-language record Arecord thatde nesa
script and language supported by a text service

component.

script-language support record An array of
script-language records that de nes all the scripts
and languages supported by a text service

component.

script record A private data structure,
maintained by the script management system,
that de nes each enabled script system, and
through which calls to that script system are
dispatched.
scriptrun

A sequence of text that is contiguous

in memory and belongs to a single script system.

script-sorting resource An international
resource, of type 'it1lm'. The script-sorting
resource lists all de ned script codes, language
codes, and region codes, in proper sorting order.
It also maps each region to its parent language,
and each language to its parent script. An
application uses the script-sorting resource to sort
multiple-language lists. There is only one
script-sorting resource for each version of the
Macintosh system software.

GL-13

GLOSSARY

script system A collection of software facilities
that provides for the representation of a speci c
writing system. It consists of a set of keyboard
resources, a set of international resources, one or

more fonts, and possibly a script system extension
(1-byte or 2-byte). Script systems include Roman,

Japanese, Arabic, Traditional Chinese, Simpli ed
Chinese, Hebrew, Greek, Thai, and Korean. Types

of script systems include 1-byte simple, 1-byte
complex, and 2-byte.

script utility The low-level equivalent to one of
a large group of script-aware Script Manager, Text

Utilities, or QuickDraw text routines. Some script

utilities are handled by the script management
system; others are passed on to script systems.

Script utilities all use the ScriptUtil

trap.

secondary caret The low caret that is displayed
at the secondary caret position; part of a
dual caret.
secondary caret position The screen location
(denoted by the secondary caret) associated with
the character that has an opposing direction from
the primary line direction.
secondary script

See auxiliary script.

selection range ‘The series of characters in
memory where the next editing operation is to
occur. The onscreen glyphs of those characters are
commonly highlighted. The characters in a
selection range are always contiguous in memory,
but their glyphs are not necessarily so on screen.
selector An integer value that controls the
function of a multipurpose routine. For example,
the Script Manager uses selectors to

gure out

which variable you want to read when calling
GetScriptManagerVariable.

simple script system
script system.

GL-14

See 1-byte simple

single caret
In unidirectional text, the standard
text-insertion caret. In mixed-directional text, one

caret that appears at the place where the user will
insert the next character, given the current

keyboard script. At a boundary between two
direction runs, the single caret can correspond to
either the primary line direction or the secondary
line direction. Because changing the keyboard
script in that situation changes the caret location,
the single caret is also called a moving caret or
jumping caret. Compare dual caret.
slop

Injusti

ed text, the amount of space (in

pixels) that must be added to a line of text to
make it exactly t the desired line length. The
slop value for a line is to be distributed among the
style runs, words, and characters on the line.

small character set

A character set with no more

than 256 characters. Roman, Hebrew, and Arabic

have small character sets. The script system for
such a writing system needs only 1-byte character
codes, and is therefore called a 1-byte script
system.

sorting hook A routine in the
string-manipulation ('it12') resource that
controls sorting behavior for a particular
script system.
source mask A value that speci es which of a
script system@ subscripts the
TransliterateText function is to operate on.
split caret

See dual caret.

Standard Roman character set

The 256

characters and character codes that are supplied
with the Macintosh Roman script system. The
Standard Roman character set consists of the

Macintosh character set plus additional
de

ned characters with character codes between

$D9 and $FF.

storage order The order in which character
codes are stored in memory. Storage order may be
different from display order.

GLOSSARY

string-manipulation resource An international
resource of type 'it12'. The
string-manipulation resource de nes conventions
for comparing text elements, including sorting
order, character types, case conversion, and word
breaks. Each installed script system has one or
more string-manipulation resources.
style

A visual attribute, other than size, applied

as a systematic variation to the plain (unstyled)
characteristics of a font@ glyphs. The set of styles
supported by QuickDraw consists of bold, italic,

underline, outline, shadow, condense, and extend.

style code A byte-length mask with one bit
set for each QuickDraw-supported style to
be applied.
styled text Text that is displayed in
multiple styles.
stylerun A sequence of text that is contiguous
in memory and in which all the characters are in

the same font, size, style, color, and script system.

style scrap A TextEdit scrap that stores style
information associated with text that is cut
or copied.

system script The primary script system used
by various parts of the Operating System, such as
in dialog boxes and menu bars. The system script
affects system defaults, such as the system font,

line direction, and text-formatting rules. All other
scripts are secondary to the system script. The
system script is speci ed in the system software@
con guration resource ('it1lc').
target format A value that speci es what format
the TransliterateText function is to convert
text into.
target modifier A value that provides
formatting information beyond that speci

ed in

the target format, for use by the

TransliterateText function.

text The written representation of language.
Text is a sequence of symbols that conveys
meaning to its reader. The set of symbols used,
and the most basic rules for their presentation,
constitute the writing system of the text. The
lexical, grammatical, and semantic signi

cance of

combinations of the symbols constitute the
language of the text.
Text control panel

A control panel, available on

subscript A distinguishable subset of characters
included within a scriptN for example, Japanese

non-U.S. versions of system software, that allows

synthetic font A font created by the Font
Manager from a bitmapped font resource by
expanding the 1-bit font into a font that matches
the current screen depth.

text rendering The process of preparing
characters that are stored in memory for display
as glyphs.

Hiragana, Katakana, Kanji, and Romaji.

the user to set aspects of the text behavior of any
enabled script system.

interface elements, including the default line

text segment For text layout, the portion of a
style run (it may be the entire style run) that falls
on a single text line. Most text measuring and
drawing routines work on a single text segment at
a time.

System file

text service A text-entry or text-processing
function provided by a text service component.
Inline input is one example of a text service.

system direction

The horizontal placement of

direction (left-to-right or right-to-left) for text in
the system script. System direction is speci ed by
the global variable SysDirection.
A _ le, located in the System Folder,

that contains the basic system software plus some
system resources, such as international and

keyboard resources of installed script systems.
system font

The font used to display text in

menus, dialog boxes, alert boxes, and so forth in a
given script system. For example, in the Roman

script system, the system font is Chicago.

text service component
A software module that
is a registered component with the Component
Manager, and that is used for entry, processing, or
formatting of text. Text service components use
the Text Services Manager to request action from
and send information to client applications.

GL-15

GLOSSARY

text service component type

Aspeci

cation of

the function associated with a particular kind of
text service component; part of its component

description record. Currently, only one text
service component type is de ned: 'inpm',
specifying an inline input method.

Text Services Manager
The part of system
software that manages the interactions between
applications that request text services and text
service components that provide them.
text string An array of characters referenced by
a pointer and a length word. A text string may
contain up to 32,767 bytes of character data.
Compare Pascal string.
text style

See style.

token An abstract category of text element that
stands for a name, symbol, punctuation, quoted
literal, or other sequence of characters.
token block record A parameter block used by
the Int 1Tokenize function. The token block
record contains, among other information, a

pointer to a list of token records.

tokenization A function provided by the Script
Manager and individual script systems.
Tokenization identi es the different lexical
elements in an arbitrary string of text by using
localized information from the tokens resource
('it14'), and converts the string to a series
of tokens.
token record

Int1lTokenize

A data structure, used by the

individual token.

function, that describes an

tokens resource An international resource of
type 'it14'. The tokens resource contains
information needed to convert text in a particular
language into a series of tokens. Each installed
script system has one or more tokens resources.

trailing edge The edge of a glyph that is
encountered last when reading text of that
glyph@ script system. Compare leading edge.
trailing spaces White space characters occurring
at the end of the last style run in a line of text.

GL-16

transcription The representation of sound
sequences in phonetic symbols.
transfer mode
Aspeci cation of which Boolean
operation to perform when drawing. In drawing
text, QuickDraw uses transfer mode, along with

foreground and background color, to determine

how the text to be drawn (called the source)

interacts with anything already drawn in the
current graphics port, called the destination.
transliteration For the Macintosh script
management system, the conversion of characters
that are phonetic representations of the same
sound sequence between subscripts within a
script. In the Roman script system, this means
case conversion. For Japanese, Chinese, and

Korean, transliteration refers to the conversion,

without linguistic or semantic considerations, of
characters from one subscript to another subscript
within a script. Examples include the
transliteration of Japanese Hiragana to Katakana,
and the transliteration of Korean Jamo to Hangul.
transliteration resource An international
resource of type 'trs1'. The transliteration
resource provides rules for converting text
phonetically from one subscript to another within
a script system. The transliteration resource is
optional; it is used only by 2-byte script systems.
'trsl' resource
See transliteration resource.
See also international resources.

TSM-aware application An application that
makes calls to the Text Services Manager. A
TSM-aware application can use a variety of text
services such as inline input.
TSM document A private data structure
maintained by the Text Services Manager that

relates one or more text service components to a

particular application window.
2-byte extension

See WorldScript II.

2-byte script system A script system that
supports a writing system with a large character
set (requires 2-byte characters) and requires
sophisticated procedures for character input.

Japanese, Chinese, and Korean are examples of

2-byte script systems.

GLOSSARY

Unicode
A standard for a universal character
set now under development. Unicode assigns two
bytes per character code, and includes all the
characters of all the world@ major writing
systems in one character set.

WorldScript II A script extension used for all
2-byte script systems. Code in the extension reads
tables in the script system@ international
resources in order to provide the proper text
manipulation and formatting for that script.

unidirectional text A sequence of text that
has a single direction. Compare
mixed-directional text.

writing system A set of characters and the basic
rules for their use in creating a visual depiction of
language. Writing systems may differ in the

universal script A 1-byte complex script system
that is compatible with WorldScript I.

direction in which their characters and lines run,
the size of the character set used, and the context

sensitivity of character selection. Writing systems

untoken table A table in the tokens resource
that converts script-independent tokens to text of
a given script system.

include Roman, Japanese, Arabic, and Hebrew.

user dictionary Also called an editable dictionary.
A le, complementary to the main dictionary
used by input methods, in which users can add
information that does not exist in the main
dictionary.

x-height The height of a lowercase x in a given
font. It is the height, measured from the base line,
of the main portion of most lowercase letters
(excluding ascenders and descenders). See also

verb

Zhuyinfuhao
Chinese phonetic characters. Also
called Bopomofo.

See selector.

view rectangle In TextEdit, the rectangle
de ning the portion of the window within which
text is actually displayed. Text drawn in the
destination rectangle is made visible to the
application user in the view rectangle.

Compare script system. See also language,
region.

ascent line, base line, descent line.

virtual key code The key code that an
application receives in keyboard events. It is the
value produced after a raw key code has been
mapped through the key-map ('KMAP') and
key-remap ('1it1k') resources.
western numerals
For the Macintosh script
management system, the numerical symbols 1, 2,

3, 4, 5, 6, 7, 8, 9, and 0. Sometimes known as
Arabic numerals, but not to be confused with the

numerals native to the Arabic writing system.
word wrap

See line breaking.

WorldScriptI
A script extension used for all
1-byte complex script systems. Code in the
extension reads tables in the script system@
international resources in order to provide the
proper text manipulation and formatting for that
script. Simple 1-byte script systems do not need to
use WorldScript I.

GL-17

Index
Numerals

ID constants

0 (special font designator)

1-50, 1-61 to 1-62

1 (special font designator)

1-50, 1-61 to 1-62

1-byte character encoding 1-54 to 1-57
1-byte complex script systems 1-46
1-byte fonts 1-7
1-byte script extension. See WorldScript I
1-byte script Sag 6-68
1-byte simple script systems 1-46
2-byte character encoding 1-57 to 1-60
2-byte fSag 6-12, 6-64
2-byte fonts 1-7
2-byte script extension. See WorldScript II
2-byte script systems 1-46

A

7-66

keyword constants 7-66 to 7-67

application font 1-61 to 1-62, 2-9, 3-69, 4-14
actual ID number of 1-62, 4-38, 6-68
preferred, for a script system 6-14, 6-15, 6-67, 6-72,
B-21
Arabic calendar 1-33
arithmetic transfer modes. See transfer modes

arrow keys and caret movement

1-79, 2-11 to 2-12

ascent line 2-26, 2-27, 4-10
ASCII character set 1-9, 1-54, A-4. See also low-ASCI;
high-ASCII

AsscEntry data type 4-48, 4-96
associated data (in a dictionary record) 8-5
associated font

1-62, A-35

auxiliary scripts

1-15, 1-51

attribute types (in a dictionary entry) 8-6, 8-27
automatic scrolling 2-28, 2-61 to 2-62, 2-91 to 2-92
installed components of 1-102 to 1-103

abbreviated days table B-34
abbreviated months table B-34
abbreviations
of dates 5-30
and sorting 5-14

ActivateTextService function
ActivateTSMDocument function
7-51

B
7-41, 7-85
7-20 to 7-21, 7-41,

active input area 1-92, 7-11
ADB keyboard mapping C-8 to C-9
advance width of glyphs 4-10, 4-56
alias styles 6-15, 6-73, B-21
alignment 1-24 to 1-26, 1-68 to 1-69, 2-13, 2-17. See also

justi ed text

with TESetAlignment procedure
2-87

2-27, 2-50 to 2-51,

with TEText Box procedure 2-24, 2-88 to 2-89
in TextEdit edit records 2-69
alphabetic characters 1-22
alternate numerals
availability, in script fags 6-69
in number parts table B-57
and tokenization 6-42
analyzing characters. See characters
ApFontID global variable 4-38
Apple events to client applications 7-10, 7-25 to 7-36,
7-44, 7-65 to 7-77

descriptor types 7-67

background (of a glyph) 3-5
Balloon Help
preferred font for 6-15, 6-16 to 6-17, 6-72

base line 4-10
B zier curves 4-25 to 4-28
B zier equation 4-26
Bic transfer mode. See transfer modes
bidirectional Sag 6-11, 6-62
bidirectional style runs 1-71
bidirectional writing systems 1-24
Binary-Decimal Conversion Package D-3
bit image table 4-69
bitmap location table 4-69
bitmapped font ('NFNT') resources 4-66 to 4-71
bit image table 4-69
bitmap location table 4-69
fontType

eld 4-70 to 4-71

glyph-width table 4-70
image height table 4-70
width/offset table 4-69
bitmapped fonts 1-7, 1-44
compared to outline 4-19
de ned 4-8
bitmapped glyphs. See also bitmapped fonts; glyphs
de ned 4-7

IN-1

INDEX

bitmaps
for bitmapped glyphs 4-7
for outline glyphs 4-29 to 4-30
bkColor gra csport eld 3-5
BootDrive global variable 6-63
Bopomofo 1-93
bottleneck routines for text 3-62 to 3-63
bottomline input 7-7 to 7-8
bottomline input window. See foating input window
boundaries. See also word boundaries
of lines 5-23
of script runs 5-23
of words
bounding-boxes of glyphs 4-10
B*-tree structure of dictionary index 8-5
buffering, text (in TextEdit)

2-14 to 2-15

character attributes. See also styles
de

ned

CharacterByteType

6-85, A-26, A-37

data

type

canonical string 6-36
caret 2-70
dual 6-64
caret position
3-98

1-75, 3-16 to 3-17, 3-44 to 3-55, 3-91 to

and mouse-down region 1-83

primary

secondary

1-77, 2-11

1-78, 2-11

and TextEdit 2-11 to 2-13
carets 1-74 to 1-79, 3-47 to 3-60
blinking rate 2-32
de ned 1-74
dual 1-77, 2-11

and insertion point 2-10

movement with arrow keys
single (moving) 1-78, 2-11
vertical movement of 2-12

de

ned

1-8

and glyphs 4-6

character direction. See line direction
character encoding 1-48, 1-52 to 1-60, 4-49, 4-76

1-byte 1-54 to 1-57
2-byte 1-57 to 1-60
1-59

1-58 to 1-59

Korean 1-60
Standard Roman

1-54 to 1-56, A-4 to A-18

character order. See sorting order
character rendering. See display of text
character reordering 1-28 to 1-29
characters. See also glyphs
alphabetic 1-22

analyzing 1-98, 6-26 to 6-31, 6-84 to 6-89
clusters 1-23
de ned 1-8,4-6

ideographic 1-22
ignorable (for sorting) 5-14

native 1-53
Roman, in non-Roman character sets 1-62
Roman, in non-Roman text 1-71, 5-28, 5-81, A-35

CharacterType return value

whitespace
1-79, 2-11 to 2-13

case conversion 1-98 to 1-99, 5-14, 5-19
built-in routines A-23

and diacritical stripping 5-14, 5-19, 5-69 to 5-70

to lowercase 5-19, 5-65
to uppercase 5-19, 5-64 to 5-65, 5-67 to 5-68, 5-69 to
5-70
with the TransliterateText function 6-47, 6-100

IN-2

C-6

below $20 as delimiters A-7 to A-8

size 6-26 to 6-27, 6-84 to 6-89, B-69
syllabic 1-22
type 6-28 to 6-31, 6-85 to 6-88, B-69 to B-70. See also

case (upper and lower)
designated in script Sags 6-68

centered text. See alignment
CGrafPort data type 3-4, 3-75

6-26 to 6-27, 6-84 to

character encoding

and ASCII codes

Chinese

calendar codes 6-14, 6-70, B-19
in 'it1l1' resource B-33
calendars 1-33, 1-97
canonical number format. See NumFormatStringRec

function

character class 6-29
character clusters 1-23
character codes 1-87. See also ASCII character set;

Japanese

C

2-7

character byte table. See CharByteTable data type

wide

B-57

6-37

and writing systems

zero-width 1-73
character sets 1-7

1-22 to 1-23

character style. See styles
character type 1-98, 6-28

CharacterType function

3-31, 6-28 to 6-31, 6-85 to

6-88, A-26, A-37, B-39, B-69 to B-70

CharacterType return value
case 6-31, 6-87
character class 6-29, 6-87
character modi ers 6-30

6-28 to 6-31, 6-86

character type 6-28, 6-86

direction 6-31, 6-87
eld masks for 6-86
CharacterType return value

6-28 to 6-31, 6-86

INDEX

CharacterType return value
orientation 6-30, 6-87
size 6-31, 6-87
CharByte routine D-4

(continued)

CharByteTable data type 6-88
CharExtra procedure 3-20 to 3-22, 3-75
using with SpaceExtra 3-22
CharToPixel

function

2-59, 3-49 to 3-60, 3-94 to 3-96,

A-26, A-37
and TextEdit 2-59
Char2Pixel routine D-4

con rming text (in inline input) 7-12, 7-23, 7-42
contextual forms 1-11, 1-14, 1-26 to 1-29

contextual forms setting (script variables) 6-69
contextual script system (in script Sags) 6-68
contours of glyphs 4-28 to 4-29
contracting characters for sorting 5-14
control characters

CharType routine D-4
CharWidth function 3-27 to 3-28, 3-81 to 3-82

restrictions 3-28
Chicago font 1-61 to 1-62
Chinese character encoding 1-59
Chinese input method 1-93
ClearInt1lResourceCache procedure 6-32 to 6-33,
6-49, 6-89 to 6-90
click loop routine 2-35
and automatic scrolling 2-31, 2-61 to 2-62
replacing the default routine 2-61
client applications (of Text Services Manager). See also
TSM-aware applications
Apple events handled by 7-10, 7-25 to 7-36, 7-65 to
7-77
associating input methods with scripts and
languages 7-25, 7-63 to 7-65
closing a text service component 7-61
de ned 7-6
direct calls to text service components 7-36 to 7-37
listing available text services 7-20, 7-58 to 7-59
opening a text service component 7-60
passing cursor setting to components 7-22, 7-55 to
7-56
passing events to components 7-21 to 7-22, 7-54
passing menu selections to components 7-22, 7-55
requesting a Soating input window 7-24, 7-62
CloseDictionary function 8-13, 8-24
CloseServiceWindow function 7-48, 7-82
CloseTextService function 7-61
CloseTSMAwareApplication function 7-24, 7-50

'CNFG' resource type A-29, A-31 to A-32, B-60 to B-63

color, of text 2-7
Command-key combinations

component glyphs 4-84
Component Manager 7-36 to 7-37

1-91, 6-17, A-19, C-27

using the KeyTrans function with C-23
Comment Type data type 6-97
CompactDictionary function 8-20, 8-33
CompareString function 5-18, 5-62, B-34
CompareText function 5-18, 5-63, B-34

comparing strings. See sorting
completer keys A-19, C-18, C-20, C-34
completion character C-20
ComponentDescription data type

component description record 7-15

7-15

1-56, 1-58, A-6 to A-8. See also

number format speci cation strings
used as delimiters A-7 to A-8
control panels
Date & Time 1-110 to 1-112
Numbers 1-109
Text 1-107 to 1-108
converting text. See also input methods; case conversion
in inline input 7-12
lexical. See tokenization
phonetic. See transliteration
copying text 2-9, 2-30, 2-39 to 2-42
Copy transfer mode. See transfer modes
CurFMInput global variable 4-64
currency formats 1-32 to 1-34, 1-97, 6-33 to 6-34, B-25

currency symbols B-24
current line direction 1-77
current script

1-15, 1-52, 5-4 to 5-6, 6-22. See also font

script; font force fag; international resources
selection fag

cursor (de

ned)

1-74

customization (in application design) 1-18
customizing TextEdit 2-57 to 2-63, 2-110 to 2-117
cut and paste, intelligent 1-99, 6-68, 6-69
cutting text 2-9, 2-30, 2-39 to 2-42

D
dakuten 6-30
data attributes (in a dictionary entry) 8-6, 8-7
data in a dictionary record 8-5
Date & Time control panel 1-110 to 1-112
date cache record 5-31, 5-45, 5-82 to 5-86
date formats 1-32 to 1-34, 1-96 to 1-97, 5-29 to 5-31, 6-33

to 6-34
long 5-30, B-30 to B-31

short 5-29, B-25 to B-26
DateForm data type 5-34, 5-35, 5-87, 5-90

dates

converting

defaults used in 5-32
from strings 5-31 to 5-33, 5-84 to 5-85
into strings 5-34 to 5-35, 5-89 to 5-91
routines for 5-82 to 5-91
determining the year 5-32, 5-84

IN-3

INDEX

DateString procedure 5-34 to 5-35, 5-86 to 5-87, B-28
DateTimeRec data type 5-34
date-time record 5-34
date-time representation, standard 5-34
DateToSeconds routine 5-34
Date2Secs routine D-4
day names B-29, B-34
DeactivateTextService function 7-41, 7-85 to 7-86
DeactivateTSMDocument function 7-20 to 7-21, 7-41,
7-52 to 7-53
dead keys 1-89, A-19, C-18, C-33
and U.S. 'KCHR' resource A-19

decimal separators B-24

DeleteRecordFromDictionary function
DeleteTSMDocument function 7-24, 7-53

8-20, 8-32

deleting and inserting text 2-43
deleting text 2-43
delimPad token code 6-58
DelimType data type 6-96
derived fonts 4-8
descent line of fonts 4-10
desk scrap 2-40 to 2-42

destination rectangle 2-16, 2-25 to 2-29, 2-68
diacritical marks 1-29, 1-64

built-in stripping routines A-23
stripping 1-98 to 1-99, 5-14, 5-19, 5-68 to 5-70
diacritics. See diacritical marks
dictionaries 1-39, 8-3 to 8-4. See also dictionary entries;
dictionary records
accessing 8-13 to 8-15, 8-22 to 8-26
compacting 8-20, 8-33
de ned 8-3
entries 8-6
le types 8-5
garbage data in 8-8 to 8-10
locating records in 8-15 to 8-18, 8-26 to 8-29
main 8-3
making 8-11 to 8-13, 8-20 to 8-22
maximum key length 8-13, 8-14, 8-21, 8-25

modifying 8-18 to 8-20, 8-30 to 8-32
records 8-5 to 8-7
search criteria

8-13, 8-14, 8-21, 8-25

structure of 8-5 to 8-7
user 8-3
dictionary entries 8-6
attribute types 8-6, 8-27
data attributes 8-6, 8-7
raw data 8-6, 8-7

dictionary information record 8-14, 8-25
Dictionary Manager 1-39, 8-4 to 8-39. See also
dictionaries; dictionary records
accessing a dictionary 8-13 to 8-15, 8-22 to 8-26
compacting a dictionary 8-20, 8-33
limitations of 8-10

IN-4

locating records in a dictionary 8-15 to 8-18, 8-26 to
8-29
making a dictionary 8-11 to 8-13, 8-20 to 8-22
modifying a dictionary 8-18 to 8-20, 8-30 to 8-32
routines in 8-20 to 8-33
testing for the presence of 8-11
dictionary records
associated data 8-5
de ned 8-5
format of 8-5 to 8-7
indexes 8-5
insertion mode 8-31
keys 8-5, 8-7
dictionary reference number 8-13, 8-23
direction boundaries and caret movement
2-12

1-79, 2-11 to

direction runs 1-70 to 1-71
direction. See line direction
discontinuous highlighting 1-81 to 1-82, 2-10
discontinuous selection 1-80
dispatch record. See TextEdit dispatch record
dispatch routine for a script A-28, A-39
dispatch table for a script 6-51, A-28, A-39

display line (de ned) 3-12
display of text 1-5 to 1-7, 1-64 to 1-86, 3-4 to 3-108
alignment 1-68 to 1-69, 2-50
caret handling

1-74 to 1-79, 3-47 to 3-60

direction runs and 1-70 to 1-71
display order 1-65
drawing

3-12, 3-27 to 3-47, 3-76 to 3-81

drawing a Pascal string 3-28
drawing a simple line 3-29
drawing a single glyph 3-27
drawing complex lines 3-29
drawing justi ed text 1-70, 3-39
drawing mixed-directional lines 3-33
drawing scaled text 3-45. See also font scaling
drawing static text 2-24
font runs and 1-70 to 1-71
highlighting. See highlighting text
laying out a line of text 1-71 to 1-74, 3-12, 3-29
line direction and 1-67 to 1-68
measuring 3-27 to 3-47, 3-81 to 3-87
in TextEdit

2-14, 2-58

positioning the pen 3-42
primary line direction and 1-67
printing 1-85 to 1-86
script runs and 1-70 to 1-71
stack space for drawing 3-25
storage order and 1-66
stripping trailing spaces 3-36
style runs and 1-70 to 1-71
display order 1-10, 1-65, 3-33
dithering 3-26
dpi (dots per inch) 4-7

INDEX

DrawChar procedure 3-27, 3-28, 3-76 to 3-77
restrictions 3-28
DRAWHook registers 2-112

draw hook routine, replacing 2-58
drawing text. See display of text
DrawJustified procedure
DrawJust routine D-4

DrawString procedure

3-79 to 3-81, A-26, A-37

3-28, 3-77 to 3-78

DrawText procedure 3-42, 3-63, 3-78 to 3-79
dual caret 1-77, 2-11, 6-64

E
edit records

2-16 to 2-20, 2-64, 2-67 to 2-71, 2-106

activating and deactivating 2-33
creating 2-24 to 2-28
elds 2-67
incorporating text into 2-29
lineStarts array 2-62
multistyled 2-16
releasing memory allocated for 2-32
reusing 2-30
storing the handle to 2-25
text buffer of 2-29
em square 4-72
enabling script systems 1-15, 1-100, 6-8
encoding, character. See character encoding
encoding /rendering ('it15') resource B-5, B-58 to
B-70
break-table directory B-66 to B-67
byte-type table B-69
character expansion table B-64 to B-65
character-type table B-69 to B-70
feature list table B-68
glyph-to-character table B-65 to B-66
kashida preferences table B-68
line-layout glyph properties table B-64
line-layout metamorphosis table B-63
reordering table B-68
resource ID as script variable

6-14, 6-70, B-19

script con guration table B-60 to B-63
script run tables B-67
end-of-line character (replacing) 2-57
end-of-line hook routine, replacing 2-57 to 2-60
entries (in a dictionary). See dictionary entries

EqualString function 5-17, 5-51 to 5-52, A-20
event handling, in TextEdit 2-32 to 2-38
event record C-6, C-9

exception array C-12
expanding characters for sorting 5-14
exponents B-56, B-57
ExtendedToString function

B-55

5-36, 5-44, 5-100 to 5-101,

extension bar characters (kashida)
extension-fetching routine B-54
extra days table B-34
extra months table B-34
extra separators table B-34

1-26

F

family glyph-width table 4-24
family glyph-width table entry record 4-48
family glyph-width table record 4-48
FamRec data type 4-47, 4-90, 4-107
FDevDisable global variable 4-37
fgColor graphics port eld 3-5
le system sorting 5-16 to 5-17

FillParseTable function 6-27, 6-88 to 6-89, A-26,
A-37
FindRecordByIndexInDictionary function 8-17to

8-18, 8-28 to 8-29

FindRecordIinDictionary function

to 8-28

FindScriptRun function

B-40

8-15to8-17, 8-26

5-29,5-81 to5-82, A-26, A-37,

FindServiceWindow function 7-48, 7-83
FindWordBreaks procedure 5-77 to 5-79, 6-37, A-26,

A-37, B-40, B-49 to B-50

for line breaking 3-31, 3-45
and TextEdit 2-6, 2-60 to 2-61

for word selection 5-23
FindWord routine D-4
FixedPtr data type 4-56
xed tokens B-54
xed-width fonts

1-73, 4-10

FixTextService
FixTSMDocument

function
function

preferred, for a script system 6-15, 6-71, B-20

7-42, 7-90
7-23, 7-42, 7-56 to 7-57

Soating input windows 1-92, 7-7, 7-13. See also Soating
utility windows
requesting 7-24
Soating-point numbers
converting from strings 5-43, 5-98 to 5-99
converting to strings 5-44, 5-100 to 5-101
Soating utility windows 7-14
providing 7-48
Soating window layer 7-14
Soating window service 7-13, 7-24
FlushFonts function 4-37, 4-66

FMetricRec data type 4-55
FMInput data type 4-40 to 4-41
FMOutput data type 4-41 to 4-43
FMSwapFont

function

4-17, 4-64 to 4-65

'FOND' resource type. See font family (' FOND ')
resources

IN-5

INDEX

Font2Script

routine

D-4

FontAssoc data type 4-47, 4-95
font association entry record 4-48
font association table record 4-47
font characterization table 4-17
font classes 4-99
font depth 4-25
font design, instructions for 4-30, 4-72
font designators, special (0 and 1) 1-50, 1-61 to 1-62
font directory 4-74 to 4-76
font editors 4-66
font families

1-45, 4-8

font family (' FOND') resources 4-90 to 4-107
bounding-box table 4-97 to 4-98
de ned 4-13
font association table 4-95 to 4-96
glyph-name encoding table 4-105
glyph-width table 4-98 to 4-99
kerning table 4-106 to 4-107
offset table 4-96 to 4-97
style codes 4-94
style-mapping table 4-99 to 4-106
font family [Ds

1-61, 4-14 to 4-15

of application font 1-62, 4-38, 6-68
con rming font name 4-33
and Font Manager 4-14 to 4-15
getting 4-33
and picture les 3-64
and script codes B-6 to B-7
storing ina document 4-34
of system font

1-62, 4-14, 4-38, 6-67

used to identify font 3-6
used to obtain script system 3-35
font family kerning table record 4-49 to 4-50
font family record 4-47
font force fag 1-52, 1-63, 6-11, 6-24 to 6-25, 6-62, B-10
and Font Script, FontToScript functions 6-22 to

6-24
support for, in script fags 6-69
font handling 1-60 to 1-64
FontInfo data type 3-66, 4-34
font information record 4-34
font input record 4-17, 4-40 to 4-41
Font Manager

1-6, 1-37 to 1-38, 4-5 to 4-120

and caches 4-36
data structures in 4-39 to 4-50
erasing memory caches 4-66
favoring outline fonts as default 4-35
font resources in 4-66 to 4-107
for bitmapped fonts 4-66 to 4-71
for font families 4-90 to 4-107
for outline fonts 4-72 to 4-89
initializing 4-32
and Menu Manager 4-32 to 4-33
and QuickDraw Text 3-5

IN-6

rendering outline fonts 4-25 to 4-30
responding to font requests 4-17 to 4-18
routines in 4-50 to 4-66
scaling fonts 4-19 to 4-23, 4-62 to 4-63
FontMetrics procedure
A-27

1-63, 3-76, 4-34, 4-54 to 4-55,

font metrics record 4-34
font names 4-8
adding to menus 4-32 to 4-33
displaying in correct script 1-64, 6-16
storing in documents 4-33 to 4-34
font numbers. See font family IDs 4-8
font output record 4-41 to 4-43
FontRec data type 4-46
font record 4-46 to 4-47
font rectangle 4-10
'FONT' resources 4-13
introduced 4-13
restrictions on use of 4-15
font resources 4-12 to 4-16. See also font resource types
for bitmapped fonts 4-13
evolution of 4-13 to 4-14
for font families 4-13
history of 4-13 to 4-14
for outline fonts 4-13
font resource tables 4-13
font resource types 4-13
'FOND '. See font family (' FOND ') resources
'FONT!. See 'FONT' resources
'NFNT'!. See bitmapped font ('NFNT') resources
'sfnt'. See outline font ('sfnt ') resources

font runs 1-70 to 1-71
fonts

1-44 to 1-45, 4-6 to 4-12

accessing handles to 4-64 to 4-65
application 1-61 to 1-62, 3-69, 4-14
associated

1-62, A-35

bitmapped 1-7, 1-44
changing size of 2-48
Chicago 1-61 to 1-62
default 4-53

de ned 1-6, 3-6,48
xed-width 1-73, 4-10

general issues for 1-60 to 1-64
Geneva 1-61 to 1-62
identifying 4-8
ID ranges for

1-49 to 1-50, 1-61, B-6 to B-7

legible sizes 1-64
locking

4-37, 4-65

outline

1-7, 1-44

measuring 4-8 to 4-12, 4-38 to 4-39
in memory 4-65 to 4-66
names 4-8
neighborhood base 4-34
point size limit of 4-32
proportional 4-10

INDEX

fonts (continued)
requests for 4-16 to 4-18
resource ID range of 6-22
saved in QuickDraw pictures 3-63
scaling. See font scaling
size 3-74
storing names of 4-33 to 4-34
style code 4-94
styles for. See styles
synthetic 4-25
system

formatting numeric strings

fractional glyph widths

1-61 to 1-62, 3-69, 4-14

terminology for 4-6 to 4-12
as uninterpreted symbols 1-64
used to specify script systems 1-61
font scaling

5-35 to 5-44, 6-34 to 6-35,

B-55 to B-57. See also numeric strings, number
format speci cation strings
FormatX2Str routine D-4
FractEnable global variable 4-38

3-15 to 3-16, 4-19 to 4-23, 4-62 to 4-63

1-85, 4-55

calculating 4-23 to 4-24
enabling or disabling 4-58
enabling or disabling use of 3-23
using 4-38
FScaleDisable global variable 4-38
FScaleHFact global variable 4-21, 4-39
FScaleVFact global variable 4-21, 4-39
fully justi ed text. See justi ed text

of bitmapped fonts 4-22 to 4-23
disabling

4-22, 4-38 to 4-39, 4-59

G

and line breaking 3-44 to 3-45
of outline fonts 4-23
using StdTxMeas 3-46, 3-98

garbage data in dictionaries 8-8 to 8-10

font scaling factors 4-42, 4-43, 4-44, 4-56, 4-61, 4-62

de ned 4-20
in font input record 4-40 to 4-41
in font output record 4-41 to 4-43
in global width table 4-44

general Sags (Script Manager)

Script Manager selectors 6-8

and monostyled TextEdit 6-69
and the TEKey procedure 2-38

synchronizing with keyboard script

1-91, 1-107, 2-8 to 2-9, 6-19 to 6-21

1-14, 1-90 to

6-22 to 6-24, 6-82

font sizes 4-11
adding to menus 4-32 to 4-33
changing 4-32 to 4-33
de ned 4-11
limits to 4-32
scaling 4-19, 4-20
in TextEdit 2-48
fonts. See also bitmapped fonts; glyphs; outline fonts
font styles. See styles
font suf x name subtable record 4-49
FontToScript function

6-22 to 6-24, 6-82 to 6-83

font type element 4-70
foreground (of a glyph) 3-5
Format2Str routine D-4

FormatRecToString function

5-36, 5-43, 5-96 to 5-98,

B-55
FormatStatus data type 5-96 to 5-100
FormatStr2X routine D-4
formatting dates and times

6-33 to 6-34

1-96 to 1-97, 5-29 to 5-35,

formatting numbers and currency

6-34

6-11, 6-64, B-11

Geneva font 1-61 to 1-62
Gestalt function
QuickDraw selectors 3-18

and outline fonts 4-56, 4-61
font script 1-51 to 1-52, 1-90, 2-8
de ned 1-15, 1-51, 3-10

FontScript function

current size of 8-14, 8-25
removing 8-20, 8-33

TextEdit selectors 2-22 to 2-23
GetAppFont function 4-38, 4-54
GetDateTime function 5-34, 5-86 to 5-88
GetDefaultInputMethod function 7-25, 7-64
GetDefFontSize
function 4-53
GetDictionaryInformation function 8-14 to 8-15,
8-24 to 8-26
GetEnvirons routine D-4

Get FNum procedure

3-20, 4-33, 4-52

GetFontInfo procedure

1-63, 3-43, 3-75, 4-34

GetFontName procedure 4-51
Get FormatOrder procedure 3-33, 3-87 to 3-88
and application-supplied callback routine 3-100
and textin PICT
les 3-65
Get FrontServiceWindow function

GetIndString procedure
GetIntlResource

5-9, 5-50

function

7-48, 7-82

6-32 to 6-33, 6-90 to 6-91

GetInt1lResourceTable procedure

6-32 to 6-33, 6-91

to 6-92
GetOutlinePreferred function 4-35, 4-61
Get PreserveGlyph function 4-36, 4-63
GetScriptLanguageSupport function 7-42 to 7-44,
7-90 to 7-91
GetScriptManagerVariablefunction 4-37,4-46,6-11
to 6-13, 6-77
selectors for 6-61 to 6-65

1-97, 5-29, 6-33 to

IN-7

INDEX

GetScriptQDPatchAddress function 6-104, A-26,
A-33
selectors for 6-101
GetScript routine D-4
GetScriptUtilityAddress
function 6-102, A-26,
A-33
selectors for 6-101
GetScriptVariable
function 6-13 to 6-17, 6-79, A-26,

A-37
script codes for 6-52 to 6-53
selectors for 6-65 to 6-73

GetServiceList function 7-20, 7-58 to 7-59
Get String function 5-9, 5-49
GetStylHandle routine D-4
GetStylScrap routine D-4
GetSysDirection function 6-10, 6-76
GetSysFont function 4-38, 4-54
GetSysJust routine D-4
Get Text ServiceLanguage function 7-25, 7-65
GetTextServiceMenu function 7-41, 7-89

globalization (in application design) 1-18
global width table 1-73, 4-36 to 4-37, 4-43 to 4-46
fractional glyph widths 4-24
used in font scaling 4-21
global width table record 4-43 to 4-46
glyph indexes 4-77
glyph origin 4-10

glyphs. See also characters, fonts
bitmapped 4-7
component 4-84

H

Han characters 1-93
han-dakuten 6-30
HandToHand function
Hangul 1-23, 1-60
Hanja 1-22, 1-60
Hanzi 1-22, 1-59

2-32

Help font (preferred, for a script) 6-15, 6-16 to 6-17,

6-72, B-21
HidePaletteWindows function 7-41, 7-86
high-ASCII character set 1-19, 1-54, 1-56, 1-62

high caret. See dual caret

highlighting text 1-80 to 1-85, 2-70, 2-85, 3-16 to 3-17,
3-60 to 3-62, 3-97 to 3-98
discontinuous 1-81 to 1-82, 2-10
outline 2-11, 2-108
in TextEdit 2-10
HiliteText procedure 3-61, 3-97 to 3-98, A-26, A-37
Hiragana 1-53, 1-58
HITTESTHook routine 2-60

replacing 2-60
hit testing

HITTEST hook registers

2-113

replacing 2-60
replacing the default routine 2-60
and TEDoText global variable 2-63

hook
de

elds
ned 2-17

contours 4-28 to 4-29
de ned 1-8,4-6
kerning 4-12

leading and trailing edges of 1-75, 2-13, 3-49
measuring 4-8 to 4-12
for missing characters in set 4-6
and pixels 4-7, 4-29
simple

4-84

glyph widths
calculating 4-23 to 4-24

fractional 4-24, 4-38
elyph-width table 4-23, 4-24, 4-70

GrafPort data type 3-4
graphics port
CGrafPort and fractional pen position 3-5
de ned 3-4
de ning the text characteristics of 3-68
text-related elds of 3-19

grayishTextoOr transfer mode. See transfer modes

Gregorian calendar 1-33

icons. See also keyboard icon family
input method, for keyboard menu
for input method menu title 7-39

IdenticalString function 5-17, 5-52 to 5-53, B-34
IdenticalText function 5-18, 5-53 to 5-54, B-34

ideographic characters 1-22
idle processing 2-15, 2-32. See also TEIdle procedure
image height table 4-70
index (in a dictionary record) 8-5
InitDateCache function 5-31, 5-83

InitFonts procedure 4-32, 4-51
InitGraf procedure 3-18
initialization
automatic, of a script system 6-69
of date cache record

5-31, 5-83

of a dictionary 8-13
of Font Manager 4-32, 4-51
of QuickDraw

3-18

of Script Manager

IN-8

7-39 to 7-40

6-8

INDEX

initialization (continued)
of script systems 1-100, 6-8, A-28 to A-29, A-38
of TextEdit 2-23
of a TSM-aware application 7-18, 7-49

InitializeDictionary function 8-13, 8-21 to 8-22
InitiateTextService function 7-41, 7-84 to 7-85
'INIT' resource types

calling Script Manager routines from 6-8

InitTSMAwareApplication function
inline input 1-14, 1-92, 2-108, 7-7 to 7-8

7-18, 7-49

active input area 7-11
explicitly con rming text 7-23
togeling 6-18
input-method dictionaries. See dictionaries
input-method icons 1-105
input methods 1-14, 1-91 to 1-93, 7-6 to 7-8. See also
inline input; bottomline input; text service
components

Chinese
de

ned

1-93

1-14, 7-6

dictionaries. See dictionaries

Soating input window

1-92, 7-7 to 7-8

Japanese 1-92, 1-93
Korean 1-93
scripts and languages supported by 7-25
setting 6-17 to 6-19, 6-80 to 6-81
switching

1-106, 6-18

and transliteration 6-44
input of text 1-5, 1-87 to 1-93. See also input methods;
keyboard script; keyboards; keyboard layouts;
keyboard resources; key translation
input methods 7-6 to 7-8
keyboards C-4 to C-6
key translation C-8 to C-10
inserting and deleting text 2-43
inserting text 2-43
insertion mode (for dictionary records)

insertion point 1-74
de

ned

8-31

1-74, 2-10

and font script 2-9
and hit testing 2-63
marking with a caret 3-16
setting 2-34

InsertRecordToDictionary function

B-5, B-17 to

application font, preferred B-21

xed-width font, preferred
Help font, preferred B-21

B-20

initialization of script Sags 6-68

'it10' resource ID B-18
'it11' resource ID B-18
'it12' resource ID B-18
'i1t14' resource ID B-19
'it15' resource ID B-19
'KCHR' resource ID B-19, C-18
'kes#!/'kes4'/'kes8' resource ID

language code for script B-19

numeral code and calendar code

B-19, C-25

B-19

script Sags A-28, B-18
small text font, preferred B-21
styles, valid for script B-21
styles for aliases B-21
system font, preferred B-21
international con guration ('itlc') resource B-5, B-9
to B-11
font force Sag B-10
international resources selection fag B-10
old-keyboard setting B-11, C-16
region code for system script B-11
Script Manager general fsags B-11
and system direction 6-10
system global fsags B-11
system script code B-10
international resources

1-15, B-3 to B-86. See also

encoding /rendering resource; international
bundle resource; international con guration
resource; long-date-format resource;

numeric-format resource; script-sorting resource;

string-manipulation resource; tokens resource;
transliteration resource

direct access to tables of 6-32 to 6-37

and the international resources selection fag B-9

list of 1-41 to 1-42, B-4 to B-5
8-18 to 8-20,

converting from numeric strings 5-38 to 5-39
converting to numeric strings 5-38 to 5-39, 5-92
1-99, 6-68, 6-69

7-15

ID ranges for 1-49 to 1-50, B-6 to B-8, B-9

('sfnt') resources

intelligent cut and paste

international bundle ('it1b') resource
B-21

direct access to 6-31 to 6-34, 6-89 to 6-92

8-30 to 8-31
installing script systems 1-100 to 1-104
instruction sets for font design 4-72. See also outline
font
integers

interface type (text service component)

intercharacter and interword spacing 3-22, 6-12, 6-64
intercharacter space 1-25

and localized system software A-23 to A-24, B-6

multiple versions of 1-103 to 1-104, B-9

replacing 1-103 to 1-104, 6-48 to 6-49.
and the Resource Manager B-8
and the Text Utilities 5-4

international resources cache 6-49
international resources selection fag

6-11, 6-25 to 6-26, 6-62, B-10

1-52, 5-4 to 5-6,

and Int1lScript function 6-22 to 6-24
and StringOrder function 5-58
and TextOrder function 5-59

IN-9

INDEX

International Utilities Package D-3
interword space 1-25
Int1l0ORec data type B-23 to B-27
Int1l1Rec data type B-28 to B-31
Int1lForce global variable 5-4

IntlScript function 6-22 to 6-24, 6-83
IntlTokenize function 6-38 to 6-43, 6-92 to 6-98, B-50

to B-54. See also tokenization
token codes for 6-58 to 6-61

intrinsic fonts

InvertRect
IsMetric

4-8, 4-93

J
Jamo

jumping caret. See single caret
justi ed text 1-24 to 1-26, 1-70, 3-85. See also slop value

drawing lines of 3-42 to 3-43
with DrawJustified procedure 3-79 to 3-81
using kashida 1-26
with MeasureJustified procedure 3-85 to 3-87
measuring before drawing 3-29 to 3-41
and space distribution 3-13

procedure and text highlighting 3-61

function

1-97, B-22

ISO language identi ers 4-87
IsOutline function 4-61
'it10'

resource type. See numeric-format resource

'1t14'

resource type. See tokens resource

Itl1lExtRec data type B-31 to B-34
'it11' resource type. See long-date-format resource
'it12' resource type. See string-manipulation resource
It1l5Record data type B-59
'1t15' resource type. See encoding /rendering resource
ItlbExtRecord data type B-20 to B-21
ItlbRecord data type B-18 to B-19
'itlb' resource type. See international bundle resource
ItlcRecord data type B-10 to B-11
'itlc' resource type. See international con guration
resource
'itlk'
'itlm'

resource type. See key-remap resource
resource type. See script-sorting resource

IUClearCache routine D-4

TIUCompPString routine D-4
TUCompString routine D-4
TIUDatePString routine D-4
IUDateString routine D-5
TUEqualPString routine D-5
TUEqualString routine D-5

IUGetInt1 routine D-5
IUGetIt1Table routine D-5

TIULangOrder routine D-5
IULDateString routine D-5
TULTimeString routine D-5
TUMagIDPString routine D-5
TUMagIDString routine D-5
TIUMagPString routine D-5
TUMagString routine D-5

IUMetric routine D-5

IUScriptOrder routine

D-5

TUStringOrder routine

D-5

IUSetInt1 routine D-5

IUTextOrder routine D-5

TUTimePString routine D-5
IUTimeString routine D-5

IN-10

1-23, 1-60

Jamo to Hangul conversion tables B-73
Japanese calendar 1-33
Japanese character encoding 1-58 to 1-59
Japanese input method 1-92, 1-93

K
Kana

Kanji

1-53, 6-30

1-22, 1-58

kashida

1-26

Katakana 1-53, 1-58
KbdType global variable

C-4, C-16

'KCAP' resource type. See key-caps resource
'KCHR' resource type. See keyboard-layout resource
'kes#' resource type. See keyboard icon family
'kes4' resource type. See keyboard icon family
'kes8' resource type. See keyboard icon family
KernEntry data type 4-50
kerning 4-12
kerning subtable record 4-50
KernPair data type

4-50, 4-107

KernTable data type 4-49, 4-107
key (in a dictionary record) 8-5, 8-7
Keyboard control panel, icons in C-26
keyboard equivalents 1-91
keyboard icon family

for input methods

1-105, C-8, C-25 to C-26

7-39 to 7-40

resource ID as script variable

6-14, 6-71, B-19

keyboard-layout ('KCHR') resource 1-12, C-7, C-18 to
C-24
completion table C-18
dead-key table C-18
installing a custom 'KCHR! C-22
pointer to data, as Script Manager variable 6-12, 6-64
resource ID as a script variable 6-71
resource ID as script variable 6-14, B-19
U.S. A-19
keyboard layouts
de

ned

1-12 to 1-13, 6-80

enabling and disabling 6-18
setting 6-17 to 6-19, 6-80 to 6-81
switching 6-18

INDEX

L

Keyboard menu 1-105 to 1-106
icons for C-26
showing 6-64
keyboard resources 1-12, 1-15, C-3 to C-35
ID ranges for B-6 to B-8, C-4
list of 1-42 to 1-44, C-7

and localized system software A-23 to A-24, C-8

keyboards 1-11, 1-87 to 1-88, C-4 to C-6
disable state 6-12, 6-64

list of types C-4
modi er keys 1-11
non-ADB C-15

keyboard script

ned

1-51 to 1-52, 1-90, 2-8

1-15, 1-52

switching 6-18, C-26 to C-27
synchronizing with font script

1-14, 1-90 to 1-91,

1-107, 2-8 to 2-9, 6-19 to 6-21
and the TEKey procedure 2-38
keyboard-swap ('KSWP') resource C-8, C-26 to C-27
handle to, as Script Manager variable 6-11, 6-64
key-caps ('KCAP') resource C-8, C-28 to C-34
Key Caps desk accessory

1-12 to 1-13, 1-107, C-28, C-32

to C-34
key codes
raw 1-12, 1-87, C-6, C-8 to C-9, C-14 to C-15
1-12, 1-87, C-6, C-8 to C-9, C-15

key-down transition code C-6

key length (in a dictionary) 8-13, 8-14, 8-21, 8-25
key-map ('KMAP') resource 1-12, C-7, C-11 to C-16

for Apple Extended keyboard C-13
exception array C-12
reassigning right-hand key codes C-14
KeylTrans global variable C-8, C-9
key-remap ('it1lk') resource C-7, C-16 to C-17
KeyScript procedure

'itlm'

resource

B-14 to B-17

and Text Utilities 5-55, 5-56 to 5-59

and monostyled TextEdit 6-69
previous 6-63
as Script Manager variable 6-11
setting 6-17 to 6-19, 6-80 to 6-81

virtual

sorted, in

for sorting strings 5-56

language identi ers (ISO) 4-87

and caret position 3-59
current 6-63
de

language codes 1-15, 1-48 to 1-49
implicit 5-55
in 'itlb' resource B-19
list of 6-54 to 6-57
as script variable 6-14, 6-70

6-17 to 6-19, 6-80 to 6-81

selectors for code parameter 6-18

KeyTranslate function

1-88, C-9 to C-10, C-16, C-17,

C-19 to C-24
calling from an application C-22 to C-24
use for Command-key equivalents C-23
use with custom 'KCHR' resource C-22

key translation 1-12, 1-88 to 1-89, C-8 to C-10
KeyTrans routine D-5

_KeyTrans trap C-9
Key2Trans global variable C-8, C-9
'KMAP' resource type. See key-map resource
Korean character encoding 1-60
Korean input method 1-93
'KSWP' resource type. See keyboard-swap resource

LanguageOrder function

5-11, 5-56

languages 1-34
Larger (point sizes) command 4-32
last FOND global variable 4-17
layer for fSoating service windows 7-14
laying out a line of text. See display of text
leading
altering for glyphs 4-35
de ned 4-12
leading edge (of a glyph) 1-68, 1-75, 2-13, 3-49
leadingEdge fag

3-49, 3-92

left-aligned text. See alignment
left-side bearings of glyphs 4-10, 4-57
levels of text handling for applications 1-18 to 1-21
ligatures 1-27
ligatures setting (script variables) 6-69
line breaking 1-99, 3-30, 5-24 to 5-28, 5-79 to 5-81, 6-37,
6-92
and TextEdit

2-6, 2-60, 2-115

of scaled text 3-45
of unscaled text 3-31
line breaks 1-30 to 1-31

line direction 1-7, 1-14, 1-67 to 1-68
bidirectional 1-24, 1-71

current 1-77
primary 1-67
of writing systems

line height

1-23 to 1-24

eld (for scrolling)

line height table
and font ascent values 2-27
introduced

2-31

2-18, 2-64

and scrolling 2-31
line layout. See display of text
line length in TextEdit 2-62
line spacing. See leading
line starts array 2-70
lineStarts data type 2-70
list separators B-24
localization

1-14, 1-18

of international and keyboard resources A-23 to A-24
of system software 1-100

LongDate2Secs

routine

D-5

IN-11

INDEX

long-date-format ('it11') resource
B-28 to B-34

abbreviated days table B-34

maximum key length (in a dictionary)

abbreviated months table B-34
calendar codes B-33
converting dates, use in 5-32, 5-87, 5-90

day names

B-29, B-34

extensions to 5-30

extra days table B-34
extra months table

B-34

extra separators table B-34
formatting information in 5-35
month names B-29, B-34
order of date elements B-30

resource ID as script variable

6-14, 6-68, B-18

suppressing date elements B-29
ned in 5-30

long date formats 5-30, B-30 to B-31
LongDateRec data type 5-32, 5-34, 5-84
LongDateString procedure
B-28

5-34 to 5-35, 5-89 to 5-90,

LongDateTime data type 5-34, 5-89, 5-90
LongDateToSeconds procedure 5-34, 5-89, 5-91
LongSecondsToDate procedure 5-34, 5-89, 5-91
LongSecsToDate routine D-5
LongTimeString procedure 5-34 to 5-35, 5-90 to 5-91,
B-22

low-ASCII character set 1-9, 1-15, 1-19, 1-54, 1-58, 1-62,
A-4
low caret. See dual caret
lowercase characters 1-30. See also case; case conversion

LowercaseText procedure
LowerText routine

D-5

8-25
maximum y-value 4-10

MeasureJustified procedure

8-13, 8-14, 8-21,

3-85 to 3-87, A-26, A-37

MeasureJust routine D-5
MeasureText procedure 3-84 to 3-85, A-27
measuring fonts 4-8 to 4-12
measuring text 3-27 to 3-47, 3-81 to 3-87. See also
display of text
menu commands for fonts
Larger (point sizes) 4-32

punctuation for date elements B-30 to B-31, B-34
region code B-31
values de

sorting. See sorting
word boundaries. See word selection; line breaking

6-33 to 6-34, B-5,

5-65, B-39

M

Smaller (point sizes) 4-32
message

eld of event record

metric system 1-97, B-27
missing-character glyphs 4-6
mixed-directional text
de ned 2-8

C-9

modi er keys 1-11, C-4, C-6
modifiers
eld of event record

C-6, C-9

modifying script systems 1-103 to 1-104
modifying text. See manipulating text
monospaced fonts. See xed-width fonts
monostyled edit records 2-16
monostyled text (TextEdit) 2-7
month names

B-29, B-34

mouse-down region 1-83
MoveTo procedure 3-42
moving caret 1-78, 2-11

multibit fonts and QuickDraw

3-27

multistyled edit records 2-16
multistyled text (TextEdit)
checking the attributes 2-102
continuous attributes 2-44
de ned 2-7
modifying the attributes of 2-44
setting the attributes of 2-54, 2-99
Munger function

5-21, 5-75 to 5-77

Macintosh character set 1-9, 1-54, 5-16, 5-60, A-4

Macintosh script management system 1-15, 1-35 to 1-45
main dictionary 1-39, 8-3
manipulating text 1-94 to 1-99, 5-3 to 5-115
analyzing characters. See characters, character type
converting text. See tokenization, transliteration
dates and times. See formatting dates and times
inserting and deleting 2-43
modifying text. See case conversion; diacritical
marks; searching text; replacing text; truncating
strings
numbers and currency. See formatting numbers and
currency

IN-12

N
NameTable data type 4-49, 4-102

native characters
de ned 1-53
nding, ina script run

5-28, 5-81

NBreakTable data type B-44 to B-46
NChar2Pixel routine D-5
NDrawJust routine D-5

negative slop value 3-39
neighborhood base font 4-34

NewServiceWindow function

7-48, 7-80 to 7-81

INDEX

NewString function 5-8, 5-47
NewTSMDocument function 7-18 to 7-19, 7-50

NFindWord routine D-5
'NFNT' resource type. See bitmapped font ('NFNT')
resources
NIt14Rec data type B-51 to B-52
NMeasureJust routine D-5

no-match character

A-19, C-20

nonprinting characters A-6 to A-8
NPixel2Char routine D-6
NPortionText routine D-6
null events 2-32 to 2-33
null scrap. See TextEdit null scrap
NullstRec. See style scrap record
null style record
number formats

NumToString procedure

2-18, 2-65, 2-74
1-32 to 1-34, 1-97, 6-33 to 6-34

number format speci cation strings 5-39 to 5-44, 5-94
to 5-98
control characters in 5-42
converting into internal representation 5-43
de ned 5-36
digit placeholders in 5-41 to 5-42
examples of 5-40
literals in 5-40 to 5-41
quoting mechanisms in 5-42
symbols in 5-42 to 5-43
using 5-39 to 5-43
number formatting speci cation record 5-45
NumberParts data type B-55 to B-57
number parts separators 5-40, B-23
number parts table 6-34 to 6-35, 6-92, B-55 to B-57
use in ExtendedToString function 5-100
use in FormatRecToString function 5-97
use in StringToExtended function 5-99

Numbers control panel 1-109

numeral codes 6-14, 6-70, B-19
numerals, alternate

availability, in script fags 6-69
in number parts table B-57
and tokenization 6-42

numeric-format ('it10') resource
B-22 to B-27

6-33 to 6-34, B-5,

constants for numeric separators B-23
converting dates, use in 5-87, 5-90

converting dates and times, use in 5-29
converting times, use in 5-88, 5-91
currency format B-25
currency symbol B-24
decimal separator B-24
formatting information in 5-35
list separator B-24
region code B-27
resource ID as script variable

short date format B-25 to B-26
thousands separator B-24

time format B-26 to B-27
unit of measure B-27
values de ned in 5-29
numeric separators 5-40, B-23
numeric strings 5-91 to 5-101
converting from numeric values 5-35
converting to numeric values 5-35
formats of 5-39
formatting 5-35 to 5-44
routines for 5-91 to 5-101
separators in B-23
NumFormat StringRec data type 5-36, 5-43, 5-45

6-14, 6-68, B-18

5-35, 5-38, 5-92

O
off-curve points 4-25 to 4-30
OffPair data type 5-44
OffsetArray data type 7-71
offset pair record. See Of Pair data type
OffsetTable data type 5-24, 5-44
Offset To Position Apple event 7-32 to 7-36, 7-74 to 7-76
on-curve points 4-25 to 4-30
1-byte character encoding 1-54 to 1-57
1-byte complex script systems 1-46
1-byte fonts 1-7
1-byte simple script systems 1-46
OpenDictionary function 8-13, 8-22 to 8-23
OpenText Service function 7-41, 7-42, 7-60

Option Space bar (restart) key combination
Or transfer mode. See transfer modes
outline font ('sfnt') resources

1-103

4-72 to 4-89

additional tables for 4-73
character-code mapping table 4-76 to 4-77
control-value table 4-77
de ned 4-13
font directory 4-74 to 4-76
font header table 4-79 to 4-82
font program table 4-77
glyph data table 4-78
horizontal device metrics table 4-78
horizontal header table 4-83
horizontal metrics table 4-83
instructions 4-30
instruction set 4-72
kerning table 4-84
location table 4-84
maximum pro le table 4-84
naming table 4-85 to 4-88
optional tables 4-73
PostScript table 4-89
preprogram table 4-89
tag names of 4-73

IN-13

INDEX

outline fonts 1-7, 1-44, 2-58, 3-15
B zier curves of 4-25

choosing 4-35
compared to bitmapped

4-19

de ned
glyphs from 4-7
mathematical basis of 4-25 to 4-26
preserving shape of glyphs from 4-35 to 4-36, 4-62
rendering of 4-25 to 4-30

scaling 4-62 to 4-63

outline highlighting of text 2-11, 2-108
OutlineMetrics function 4-34, 4-35, 4-56

outline points 4-25

overview of text handling

primary script. See system script

primary sorting order 1-34, 5-12, 5-52 to 5-63, B-38
print action vector 6-11, 6-14, 6-63, 6-71

printing text 1-85 to 1-86, A-35
private scrap. See TextEdit private scrap
proportional fonts 4-10, 4-16

Q
QDProcs record 3-62
QuickDraw 1-5, 1-37, 3-4 to 3-108

application-supplied routine 3-100 to 3-101

1-3 to 1-21

bottleneck routines for text 3-62 to 3-63
data structures in 3-66
initializing 3-18
and multibit fonts 3-27

P

for non-text drawing 1-5, 3-3
and pictures 3-63 to 3-65
requesting fonts 4-16 to 4-17

Pack 6 resource A-20
ParseTable routine D-6
Pascal strings

5-50, 5-55, 5-60

comparing 5-50 to 5-53, 5-57 to 5-58, 5-60 to 5-62
de ned 5-6
measuring 3-28, 3-82
pasting text 2-9, 2-39 to 2-42
pen position 1-6
determining the vertical coordinate for text 3-43
determining using Get Font Info 3-43
pHiliteBit

selector

Pinyin

1-93, 7-6

PixelToChar function

3-44 to 3-47, 3-49 to 3-59, 3-91 to

3-94, A-26, A-37
Pixel2Char routine D-6
planning text handling capabilities 1-18 to 1-21
platform identi ers 4-86
points
off-curve 4-25 to 4-30
on-curve 4-25 to 4-30
outline 4-25
point size 4-11
PortChanged procedure 3-20
PortionLine function

3-40, 3-90 to 3-91, A-26, A-37

PortionText routine D-6
positioning the pen. See display of text
Position To Offset Apple event 7-29 to 7-32, 7-72 to 7-74
preferred application font 6-15
preferred system font 6-15
primary caret position 1-77, 2-11
primary line direction

1-67, 2-6, 6-76

and system direction 6-10
toggling 6-18

IN-14

and styles 4-7, 4-44
testing for version of 3-18
QuickDraw patches in WorldScript I 6-50 to 6-51, A-27

classi cation by function A-34
replacing

A-32, A-34 to A-35

QuickDraw pictures 3-66

3-62

phonetic conversion. See transliteration
pixels 1-6

routines in 3-67 to 3-100

R
raw data (ina

dictionary entry) 8-6, 8-7

raw key codes 1-12, 1-87, C-6, C-8 to C-9, C-14 to C-15
raw text (in inline input) 7-12
RealFont function 4-32, 4-52

rectangles

destination 2-16, 2-26, 2-28
view 2-14, 2-16

Rect Ptr data type 4-57
region codes 1-15, 1-48 to 1-49
for 'it10' resource B-27
for 'it1l1' resource B-31
list of 6-57 to 6-58
sorted, in 'itlm'

resource

B-14 to B-17

for system script 6-12, 6-64
for system script, in 'itlc! resource B-11
regions 1-35
RelString function

5-18, 5-60 to 5-61, A-20

reordering text 3-76, 6-69

and the PixelToChar function

setting (in script variables) 6-69

3-44 to 3-46, 3-94

turning reordering off 3-45, 3-94
ReplaceText function 5-74 to 5-75

INDEX

replacing text 1-98 to 1-99, 5-21, 5-74 to 5-77
requested attributes table 8-15
resolution of screens

1-6, 4-7, 4-29

resource ID numbers and script codes 1-49 to 1-50, B-6
to B-7
resources. See also font resources; international

resources; keyboard resources
string 5-49
string list 5-50
used by Text Utilities 5-4
response code C-6
restart key combinations 1-103
reusing text records 2-30
reversing text. See reordering text
right-aligned text. See alignment
right-hand key code reassignment C-14
Romaji 1-58
Roman characters
nding, innon-Roman script runs

in non-Roman character sets 1-62

5-28, 5-81

in non-Roman text 1-71, A-35

Roman script system 1-45, A-4 to A-24
case conversion A-23
diacritical stripping A-23
standard Macintosh sorting routines A-20 to A-22
Standard Roman character set A-4 to A-18
US. international and keyboard resources for A-23
to A-24
ROMFont0 global variable 4-38
RuleBasedTrslRecord data type B-72 to B-73
runs (of text)

1-10

script-defaulted result Sag 6-11, 6-22, 6-63
script extensions. See WorldScript I; WorldScript II
script fags 6-14, 6-68, B-18
script-forced result fSag 6-11, 6-22, 6-63
script-language record 7-42
ScriptLanguageRecord data type 7-42
ScriptLanguageSupport data type 7-43

script-language support record 7-42
script management system 1-15, 1-35 to 1-45
Script Manager 1-36 to 1-37, 6-3 to 6-127
analyzing characters 6-26 to 6-31
constants de ned for 6-52 to 6-73
data structures in 6-73 to 6-75
evolution of 6-6 to 6-7
features of 6-4 to 6-5
initializing 6-8
and other managers 6-4
and system extensions 6-8
testing for version number 6-8, 6-62
Script Manager general fSags 6-11, 6-64, B-11, C-26
Script Manager variables

1-19, 1-37, 6-11 to 6-13, 6-61 to

6-65
bidirectional Sag 6-11, 6-62
font force fag

6-11, 6-24 to 6-25, 6-62, B-10

general fags 6-11, 6-64, B-11
intercharacter and interword spacing 6-12, 6-64
international resources selection fag 6-11, 6-25 to
6-26, 6-62, B-10
'KCHR' data pointer 6-12, 6-64
keyboard disable state 6-12, 6-64
keyboard script (current) 6-11, 6-19, 6-63
keyboard script (previous) 6-11, 6-63

'KSWP' resource handle 6-11, 6-64
modi cation count 6-11, 6-62
print action vector 6-11, 6-63

S
SANE numbers. See Soating-point numbers
scaling fonts. See font scaling
scrap
desk 2-15
null. See TextEdit null scrap
private. See TextEdit private scrap
style. See TextEdit style scrap
scrap style element record 2-18, 2-65
scrap style table 2-18, 2-65, 2-75
script-aware 1-15
script codes 1-15, 1-48 to 1-49
determining 6-21 to 6-26, 6-81 to 6-83
and font family IDs 4-14 to 4-15
implicit 6-52
list of 6-52 to 6-53
and resource ID ranges 1-49 to 1-50, B-6 to B-7
sorted, in 'itlm'

resource

B-14 to B-17

and Text Utilities 5-6, 5-57, 5-59
script con guration table A-32, B-60 to B-63

region code for system script 6-12, 6-64, B-11
script count 6-11, 6-62
script-defaulted result fag 6-11, 6-63
script-forced result fsag 6-11, 6-63
script override fags 6-12, 6-64
System Folder volume reference number 6-11, 6-63
system script code 6-11, 6-63, B-10
2-byte fag 6-12, 6-64

version number 6-11, 6-62
ScriptOrder function 5-11, 5-55 to 5-56
script preferences le 1-112, A-29, A-31 to A-32, B-60,

B-63

script record

6-14, 6-71, A-28, A-39

script-redraw fsag 6-14, 6-67
script runs 1-70 to 1-71
and line breaking 5-23 to 5-28, 5-79 to 5-81
ScriptRunStatus data type 5-29, 5-46
script run status record. See ScriptRunStatus data
type

script. See script systems

IN-15

INDEX

script settings controlled by user 1-107 to 1-112
script-sorting ('itlm') resource B-5, B-12 to B-17
use in sorting strings 5-10, 5-55
script systems 1-15, 1-40 to 1-112. See also system script;
font script; keyboard script
automatic initialization 6-69
auxiliary scripts

1-15, 1-51, 1-102 to 1-103

character encoding in 1-52 to 1-60
classi cation of 1-45 to 1-52
components of 1-40 to 1-45
current

1-15, 1-52, 5-4 to 5-6, 6-22. See also font script;

font force Sag; international resources selection
Sag

default settings for A-29, A-31 to A-32, B-63

de ned 1-15
determining the number of active 6-9
disabling at startup 1-103

dispatching 6-51, A-28, A-39
enabling 1-15, 1-100, 6-8

functioning of 1-52 to 1-99
initializing

1-100, 6-8, A-28 to A-29, A-38

installing 1-100 to 1-104

international resources in 1-41 to 1-42, B-3 to B-86

keyboard resources in 1-42 to 1-44, C-3 to C-35
modifying 1-103 to 1-104
replacing default routines for 6-50 to 6-51, 6-101 to
6-106
replacing international resources of 6-48 to 6-49
Roman A-4 to A-24
script codes, language codes, and region codes 1-48
to 1-49
script record 6-14, 6-71, A-28, A-39
switching 1-104 to 1-107, 6-17 to 6-19, 6-80 to 6-81

types of 1-46 to 1-48
user control of settings for 1-107 to 1-112
script utilities A-25, A-36
classi cation by function A-33
de ned 6-50
dispatching method A-28, A-39 to A-40
for 1-byte script systems A-25 to A-26
replacing, in WorldScript I 6-50 to 6-51, A-32, A-33 to
A-35
selectors for A-28
for 2-byte script systems A-37
_ScriptUtil trap 6-50, 6-76, A-30
script variables 1-19, 1-37, 6-13 to 6-17, 6-65 to 6-73
alignment Sag 6-14, 6-67
application font, preferred 6-14, 6-15, 6-67, 6-72, B-21
xed-width font, preferred 6-15, 6-71, B-20
Help font, preferred 6-15, 6-72, B-21
'i1t10' resource ID 6-14, 6-68, B-18
'it11' resource ID 6-14, 6-68, B-18
'i1t12' resource ID 6-14, 6-68, B-18
'1t14' resource ID 6-14, 6-69, B-19
'at15' resource ID 6-14, 6-70, B-19

IN-16

'KCHR!' resource ID 6-14, 6-71, B-19
'kes#!/'kes4'/'kes8'resourcelID

language code for script 6-14, 6-70, B-19
modi cation count 6-66
name of script system 6-15, 6-71
numeral code and calendar code

print action vector 6-14, 6-71
private selectors for 6-73
right-to-left Sag 6-14, 6-67
script-enabled fsag 6-14, 6-66
script le creator 6-14, 6-71
script lename 6-14, 6-71
script fags 6-14, 6-68, B-18
script-record entry 6-14, 6-71
script-redraw fsag 6-14, 6-67

6-14,6-71,B-19

6-14, 6-70, B-19

small text font, preferred 6-15, 6-72, B-21
styles, valid for script 6-15, 6-72, B-21
styles for aliases 6-15, 6-73, B-21
system font, preferred 6-14, 6-15, 6-67, 6-72, B-21
version number 6-14, 6-66

scrolling text, automatic 2-31 to 2-32, 2-61 to 2-62
ScrpSTElement. See scrap style element record
scrpStyleTab. See scrap style table

search criteria (in a dictionary) 8-13, 8-14, 8-21, 8-25
searching text 1-98 to 1-99, 5-21, 5-74 to 5-77, 6-26 to
6-27

secondary caret position 1-78, 2-11
secondary scripts. See auxiliary scripts
secondary sorting order

1-34, 5-12, 5-57 to 5-63, B-38

SecondsToDate routine 5-34
Secs2Date routine D-6
selection range 1-74, 2-85
de ned 2-10
setting in TextEdit 2-34, 2-52
selectors
de ned 6-11
for KeyScript procedure 6-18
private 6-73
for QuickDraw patches 6-101
for Script Manager variables 6-11 to 6-12, 6-61 to 6-65
for script utilities 6-101, A-28
for script variables 6-14 to 6-15, 6-65 to 6-73
SendAEFromTSMComponent function

7-44 to 7-48, 7-77

SetClikLoop routine D-6
SetDefaultInputMethod function

7-25, 7-63

to 7-79

SetEnvirons routine D-6
Set FontLock procedure 4-37, 4-65
SetFractEnable procedure 4-38, 4-58
Set FScaleDisable procedure 4-38, 4-59
SetOutlinePreferred procedure 4-35, 4-60
Set Port procedure 3-19
Set PreserveGlyph procedure

2-112, 4-36, 4-62

INDEX

SetScriptManagerVariable

6-19, 6-78

function

6-11 to 6-13,

selectors for 6-61 to 6-65
SetScriptManagerVariable procedure
calling with smFont Force 6-62
calling with smIntlForce 6-63
don't call with smEnabled 6-62

SetScriptQDPatchAddressprocedure
A-26, A-33

selectors for 6-101
SetScript routine D-6
SetScriptUtilityAddress procedure

A-33

selectors for 6-101
SetScriptVariable function

6-80, A-26, A-37, B-60
script codes for 6-52 to 6-53

6-105to6-106,

6-103, A-26,

6-13 to 6-17, 6-79 to

6-10, 6-76 to 6-77

SetSysJust routine D-6
SetTextServiceCursor function 7-41, 7-88 to 7-89
SetTextServiceLanguage function 7-25,7-64 to 7-65
SetTSMCursor function 7-22, 7-42, 7-55 to 7-56
SetWordBreak routine D-6

'sfnt' resource type. See outline font
resources
Shift-(restart) key combination 1-103
short date formats

('sfnt')

5-29, B-25 to B-26

Show/Hide Input Window Apple event 7-36, 7-76 to
7-77
simple glyphs

4-84

size, of font. See font sizes
Size menu

adding font sizes 4-32 to 4-33
skipping digits. See number format speci
slop value 1-72
ned

cation strings

3-39

distributing throughout a line of text 3-39
positive or negative 3-13, 3-39
used to justify text 3-13, 3-39 to 3-42, 3-79 to 3-81,

3-85 to 3-87, 3-90 to 3-91
Smaller (point sizes) command

implicit script code

4-32

small text font (preferred, for a script)

6-52

and case conversion

1-98 to 1-99, 5-14, 5-51, 5-61

with resource tables

5-52, 5-53, 5-62, 5-63

for different languages 5-54 to 5-59
for different script systems 5-55 to 5-59
by lesystem rules 5-16 to 5-17
ignoring characters while 5-14
and language ordering 5-55
for Pascal strings 5-57 to 5-58

of Roman ligatures A-22
in the same language 5-12 to 5-18, 5-59 to 5-63
and script ordering 5-55
special cases 5-14
stripping diacritical marks for 1-98 to 1-99, 5-14,
5-51, 5-61
for text strings 5-58 to 5-59
sorting hooks in 'it12' resource B-37 to B-39, B-43 to
B-44
sorting order 1-34, 5-12 to 5-13
built-in (U.S. Roman) A-20 to A-22
primary 1-34, 5-12, 5-52 to 5-63, B-38
secondary 1-34, 5-12, 5-57 to 5-63, B-38

variations in 5-15

source mask for transliteration

single caret 1-78, 2-11

de

smSystemScript

sorting 1-94 to 1-95, 5-9 to 5-18
built-in standard routines for A-20 to A-22

selectors for 6-65 to 6-73
Set String procedure 5-8, 5-47, 5-48 to 5-49
SetStylHandle routine D-6
SetStylScrap routine D-6

SetSysDirection procedure

smsfIntell1CP bit in script fags 6-68
smsfLigatures bit in script fags 6-69
smsfNatCase bit in script fags 6-68
smsfNoForceFont bit in script Sags 6-69
smsfReverse bit in script Sags 3-44, 6-69
smsfSingByte bit in script fags 6-68, A-28
smsfSynchUnstyledTE bit in script Sags 6-69
smsfUnivExt bit in script Sags 6-69, A-28

6-15, 6-72, B-21

smCurrentScript implicit script code 6-52
smfDualCaret bit in general fags 6-64
smf£ShowIcon bit in general fags 6-64
smsfAutolInit bit in script fags 6-69
smsfBODigits bitin script fags 6-69
smsfContext bit in script Sags 6-68
smsfForms bitin script Sags 6-69

6-45, 6-46, B-71

SpaceExtra procedure 3-20 to 3-22, 3-74
split caret. See dual caret
srcOr transfer mode. See transfer modes
ssUninterp script code 6-53
standard date-time representation 5-34

Standard Roman character set 1-9, 1-54 to 1-56, 4-6, A-4

to A-18
fonts with unique glyphs A-18
list of nonprinting characters A-6 to A-8
list of printing characters A-8 to A-16
unavailable characters A-5
variations in A-16 to A-18
static text, displaying with TextEdit 2-24
StdText procedure

3-42, 3-62, 3-98 to 3-99, A-27

StdTxMeas function 3-39, 3-46, 3-62, 3-99 to 3-100, A-27
STElement data type 2-72
storage of text 1-5, 1-9 to 1-11
storage order 1-10, 1-66
'STR

' resource type. See string resources

'STR#' resource type. See string list resource

IN-17

INDEX

string handles 5-8
string list 6-95
string list resource 5-9
string-manipulation ('it12') resource B-5, B-34 to
B-50
converting case with

5-19, 5-66, 5-67, 5-70

nding word boundaries with 5-24, 5-78

resource ID as script variable

6-14, 6-68, B-18

script run tables in B-40 to B-43
sorting hooks in B-37 to B-39, B-43 to B-44
stripping diacritical marks with 5-68, 5-70

tables in B-39 to B-43, B-44 to B-50
word-break tables in 6-37, 6-92, B-44 to B-50
StringOrder function 5-10, 5-57 to 5-58

string resources 5-9, 5-49
strings
changing contents of 5-48
comparing. See sorting
converting from foating-point numbers 5-44
converting from integers 5-38 to 5-39
converting to fSoating-point numbers 5-43, 5-98
converting to integers 5-38 to 5-39, 5-93 to 5-94
copying 5-47, 5-48
date and time 5-29 to 5-35
nding word boundaries in. See word selection, line
breaking
modifying. See manipulating text
numeric. See numeric strings
1-byte and 2-byte characters in 1-9
with 1-byte and 2-byte characters 5-6, 6-26 to 6-27
Pascal

5-6, 5-50

routines for 5-47 to 5-101
sorting. See sorting
specifying 5-8 to 5-9, 5-47 to 5-50
subscript blocks in. See subscripts
text 5-6, 5-50

types of 5-6

StringToDate function

B-28, B-34

5-31 to 5-33, 5-83, 5-84 to 5-85,

B-55

StringToFormatRec function

B-55

5-36, 5-43, 5-95 to 5-96,

StringToNum procedure 5-35, 5-38, 5-93 to 5-94
StringToTime function 5-31 to 5-33, 5-83, 5-85 to 5-86,

B-22

String2Date routine D-6
String2Time routine D-6
StringWidth function 3-28, 3-82

StripDiacritics procedure 5-68 to 5-69, B-39
stripping diacritical marks 5-19, 5-68 to 5-70

IN-18

routine

D-6

Str2Format routine D-6
StScrpRec. See style scrap record
Style data type 3-66
StyledLineBreakCode data type 5-27, 5-81
styled line break code. See StyledLineBreakCode
data type 5-81
StyledLineBreak function

5-24 to 5-27, 5-79 to 5-81

style element record 2-17
style element table 2-64
style handle 2-71
style-mapping table record 4-49
style record 2-17, 2-71 to 2-72
style runs

1-10 to 1-11, 1-70 to 1-71, 2-7

bidirectional 1-71
de ned 1-70
style run table 2-64
styles 1-6, 1-31 to 1-32

for aliases 6-15, 6-73, B-21
de ned 3-6, 4-7

in font input record 4-40
in QuickDraw 3-5, 3-8
in TextEdit 2-43, 2-44

in Text Face procedure

valid, for a script system

3-70

6-15, 6-72, B-21

style scrap record 2-18, 2-65, 2-72
getting a handle to 2-51
style table 2-17, 2-72
StyleTable data type 4-49, 4-100
subscripts. See also Roman characters
de ned 1-53
nding runs of, ina script run

switching script systems
6-80 to 6-81
syllabic characters 1-22

D-6

5-28, 5-81

1-104 to 1-107, 6-17 to 6-19,

synchronizing font script and keyboard script

1-90 to 1-91, 1-107, 2-8 to 2-9, 6-19 to 6-21
synthetic font 4-25
SysDirection global variable

StringToDateStatus values 5-33
StringToExtended function 5-36, 5-43, 5-98 to 5-99,

StripText routine

StripUpperText

1-14,

1-68, 6-10, 6-76, B-11

SysFont Fam global variable 4-38
SysFontSize global variable 4-38, 4-53
system date, obtaining 5-86 to 5-88
system direction

1-68, 6-10, 6-76, B-11

and style run display order 3-33
system font 1-61 to 1-62, 3-69, 4-14

actual ID number of 1-62, 4-38, 6-67

default size of 3-22

preferred, for a script system

6-14, 6-15, 6-67, 6-72,

B-21
special character codes in A-8
system script 1-15, 1-51
installed components 1-101 to 1-102
script code as Script Manager variable 6-11, 6-63
switching to 6-18

INDEX

T

TESetJust routine D-6

TableDirectoryRecord data type B-59

target format for transliteration

target modi

6-45, 6-46 to 6-47, B-71

er for transliteration 6-45, 6-47

TEActivate procedure

2-33, 2-68, 2-80

TEAutoView procedure

2-31, 2-92

TECalText procedure 2-29, 2-73, 2-89 to 2-90
TEClick procedure 2-34 to 2-36, 2-61, 2-85
TEContinuousStyle function 2-39, 2-43 to 2-45, 2-49,

2-102 to 2-103

TECopy procedure 2-39, 2-95
TECustomHook procedure 2-56, 2-57, 2-110 to 2-115
TECut procedure 2-30, 2-39, 2-94 to 2-95
TEDeactivate procedure 2-33 to 2-34, 2-68, 2-80 to
2-81

TEDelete procedure 2-43, 2-93
TEDispatchRec data type. See TextEdit dispatch record
TEDispose procedure

2-15, 2-32, 2-79

TEDoText global variable 2-56, 2-63
TEFeatureFlag function

2-92, 2-107 to 2-109

and automatic scrolling 2-31
and text buffering 2-32

TEFindWord global variable 2-60, 2-116
TEFromScrap function 2-97 to 2-98
TEGetHeight function 2-49, 2-90
TEGetOffset function 2-106
TEGet Point function 2-106
TEGetScrapLength function 2-98
TEGetScrapLen routine D-6
TEGetStyleHandle function 2-84
TEGetStyleScrapHand1le function 2-51, 2-103 to

2-104

TEGetText function 2-83
TEIdle procedure 2-32, 2-84, 3-47
TEInit procedure 2-15, 2-77

TEInsert procedure 2-43, 2-94
TEKey procedure 2-36 to 2-38, 2-81 to 2-82
TENew function 2-78 to 2-79
TENumStyles
function 2-41, 2-105

TEPaste procedure

2-39, 2-95 to 2-96

TEPinScroll procedure

2-31, 2-91

TERecal global variable 2-89
TERec data type. See edit records
TEReplaceStyle procedure 2-101

TerminateTextService function
TEScrapHand1le function 2-98

TEScrpLength global variable 2-39, 2-98
TESelView procedure 2-31, 2-92
TESetClickLoop procedure

2-87

TESetStyleHandle procedure 2-83
TESetStyle procedure 2-43, 2-99 to 2-100
TESet Text procedure 2-29, 2-82
TESetWordBreak procedure 2-115 to 2-116
TEStyleInsert procedure 2-43, 2-103
TEStyleNew function

2-61, 2-117

2-15, 2-25, 2-78

TEStylePaste procedure 2-39, 2-96
TEStyleTable data type. See style table

TEStyliInsert routine D-6
TESty1New routine D-6
TeStylPaste routine D-7
TETextBox procedure 1-17, 2-24, 2-88 to 2-89
TEToScrap function 2-97

TEUpdate procedure

2-88

TEUseStyleScrap procedure

2-51, 2-54, 2-104 to 2-105

text alignment. See alignment
TextBox routine D-7
text buffering 2-108
text buffering in TextEdit 2-14 to 2-15
Text control panel 1-107 to 1-108
text direction. See line direction
text drawing. See display of text
TextEdit

1-16 to 1-17, 2-5 to 2-134

customizing 2-56 to 2-63, 2-110 to 2-117
data structures in 2-17 to 2-20, 2-64 to 2-76

handling undo 2-55 to 2-56
hook routines, replacing default 2-56 to 2-60
initializing 2-22 to 2-23
and Macintosh User Interface Guidelines 2-6
and null events 2-32 to 2-33
null scrap 2-15
private scrap 2-23
restoring existing documents 2-53 to 2-55
routines in 2-76 to 2-117
synchronizing font with keyboard script 6-69
testing for features 2-23
and Text Utilities routines 2-6
32KB text limit 2-21
versions of 2-23
TextEdit dispatch record 2-17, 2-65
DRAWHook

7-42, 7-86 to 7-87

TEScroll procedure 2-31, 2-91
TEScrpHand1e global variable 2-98
TESetAlignment procedure

TESetScrapLength procedure 2-99
TESetScrapLen routine D-6
TESetSelect procedure 2-30, 2-52, 2-86

2-58

HITTESTHook

2-60

TextEdit null scrap 2-15, 2-74
TextEdit private scrap 2-23, 2-77, 2-98

TextEdit style scrap 2-40, 2-74
TextFace procedure

3-20, 3-21, 3-69 to 3-70

TextFont procedure 3-20, 3-69
text input. See input of text
text layout 1-71 to 1-74. See also display of text

IN-19

INDEX

text manipulation. See manipulating text
text mask mode. See transfer modes

TextMode procedure 3-20, 3-24, 3-70 to 3-73
TextOrder function 5-11, 5-58 to 5-59

text overview 1-3 to 1-21
TextRange data type 7-70
text segments 1-72, 3-11

text service component routines

7-37, 7-40 to 7-44, 7-84

to 7-91
text service components 1-38, 7-14 to 7-16
activating 7-41, 7-85
Apple events sent by 7-10, 7-25 to 7-36, 7-44 to 7-48,
7-65 to 7-77
closing 7-42, 7-86 to 7-87
con rming input explicitly

7-42, 7-90

constructing and sending an Apple event 7-77 to
7-79
creating amenu 7-38 to 7-39, 7-89
deactivating 7-41, 7-85 to 7-86
de ned 7-6
direct calls to 7-36 to 7-37

handling events
hiding windows

7-21 to 7-22, 7-41, 7-87
7-41, 7-86

icon for menu title 7-39
initiating a text service 7-41, 7-84 to 7-85
interactive versus batch 7-16
interface type for 7-15
keyboard icons 7-39 to 7-40
making available to the user 7-20
menu handle disposing 7-39
menu handling

7-22, 7-41, 7-88

opening a Soating utility window 7-48, 7-80 to 7-83
requiring an active TSM document 7-53
routines. See text service component routines
scripts and languages supported by 7-16, 7-25, 7-42
to 7-44, 7-90 to 7-91. See also input methods, text
services
setting the cursor

7-22, 7-41, 7-88 to 7-89

text service component type 7-15
TextServiceEvent

function

7-41, 7-87 to 7-88

TextServicelInfo data type 7-59
text service information record 7-59
TextServiceList data type 7-59
text service list record 7-59
TextServiceMenuSelect

function

7-41, 7-88

text services 7-6
listing in a menu 7-20
other than input methods 7-20
Text Services Manager 1-38 to 1-39, 7-9 to 7-107. See also
client applications; TSM-aware applications;
Apple events to client applications; text service
component routines

application interface to 7-10
component interface to 7-10
Soating window service

IN-20

7-24

high-level routines. See Text Services Manager,
routines for client applications
low-level routines. See text service component
routines
routines for client applications 7-17 to 7-25, 7-48 to
7-65
routines for components 7-44 to 7-48, 7-77 to 7-83
testing for availability 7-17
TextSize procedure 3-20, 3-22, 3-73 to 3-74
text storage. See storage of text

text strings. See also strings
de

ned

1-95, 5-6

TextStyle data type. See text style record

text style record

2-18, 2-65, 2-76

text styles. See styles
Text Utilities 1-16, 1-38, 5-3 to 5-115
data structures used with 5-44 to 5-47
routines in
for date strings 5-82 to 5-91
for modifying text 5-64 to 5-82
for numeric strings 5-91 to 5-101
for sorting 5-50 to 5-63
for specifying strings 5-47 to 5-50
for strings 5-47 to 5-63
for time strings 5-82 to 5-91
TextWidth function

3-31, 3-39, 3-83

TextWidthHook registers 2-114
thousands separators B-24

time formats 1-96 to 1-97, 5-29 to 5-31, 6-33 to 6-34,
B-26 to B-27

times (converting)
routines for 5-82 to 5-91
from strings 5-31 to 5-33, 5-85
into strings 5-34 to 5-35, 5-89 to 5-91
TimeString procedure

5-34 to 5-35, 5-88, B-22

TokenBlock data type 6-74
token block record

6-40, 6-74, 6-93 to 6-94

tokenCenterDot token code 6-61

tokenEllipsis token code 6-61
tokenization 1-99, 6-38 to 6-43, 6-92 to 6-98

alphanumeric tokens 6-42, 6-94
of alternate numerals 6-42
appending results of 6-42, 6-93, 6-96
data structures

de ned 6-38

6-40, 6-74 to 6-75

delimiters for literals and comments 6-41, 6-94, 6-96
escape character for delimiters 6-41, 6-94, 6-97

nested comments, support for 6-41, 6-94
string generation

6-42, 6-93, 6-96

token list 6-95
TokenRec data type 6-75, 6-95
token record

6-40, 6-74 to 6-75, 6-95, 6-95 to 6-96

tokens
de ned 6-38
delimPad token code 6-58

INDEX

tokens

xed

(continued)
B-54

list of types and codes for 6-58 to 6-61

tokenCenterDot token code 6-61
tokenEllipsis token code 6-61
tokens ('i1t14') resource B-5, B-50 to B-58

extension-fetching routine B-54

truncating strings 1-98 to 1-99, 5-19 to 5-21, 5-71 to 5-74
TruncCode data type 5-71 to 5-73
TruncString function 5-19, 5-71 to 5-72
TruncText function 5-19, 5-72 to 5-74

TSM-aware applications. See also client applications;
TSM documents
activating a TSM document 7-20 to 7-21, 7-51 to 7-52
closing 7-24, 7-50
con rming text explicitly

number parts table 6-34 to 6-35, 6-92, B-55 to B-57
resource ID as script variable 6-14, 6-69, B-19

token-string copy routine 6-42, B-54

and tokenization 6-95
token table B-53
untoken table 6-35 to 6-37, 6-92, B-54 to B-55
whitespace table 6-37, 6-92, B-58

token-string copy routine B-54
token strings 6-42
token table

B-53

token types. See tokens

trailing edge (of a glyph) 1-68, 1-75, 2-13, 3-49
transfer modes 3-24 to 3-27, 3-70 to 3-73
arithmetic 3-25, 3-72

Bic

3-24, 3-72

Copy 3-71
grayishTextOr 1-86, 3-26, 3-72
and PICT
les 3-63

NotBic

NotCopy

3-72

3-72

NotoOr 3-72
NotXor

3-72

Or 3-24, 3-71

src 3-71
text mask

initializing

7-18, 7-49

requiring an active TSM document
TSM documents
activating 7-20 to 7-21
creating 7-18 to 7-19
deactivating 7-20 to 7-21
de ned 7-18
deleting 7-24

7-53

TSMEvent function 7-21 to 7-22, 7-42, 7-54
TSMMenuSelect function 7-22, 7-42, 7-55

2-byte character encoding 1-57 to 1-60
2-byte fonts 1-7
2-byte script systems 1-46
typefaces. See also fonts
de ned 4-7
types of script systems 1-46 to 1-48

3-26

transparent 3-27, 3-73

Xor 3-24, 3-72
Transliterate routine D-7
TransliterateText function

U
5-19, 6-43 to 6-47, 6-98

to 6-100, A-26, A-37, B-70 to B-73

and LowercaseText, UppercaseText 6-47
transliteration 1-99, 6-43 to 6-47, 6-98 to 6-100

across separate script systems 6-99

in Arabic and Hebrew
de ned 6-43

6-100

transliteration ('trs1') resource

B-5, B-70 to B-73

property fSag for preconversion B-71
rule-based format B-72 to B-73
table-based format B-73

TripleiInt data type 5-46, 5-97

resource type. See transliteration resource

TrueType fonts. See outline fonts

1-53, 4-86, A-6

uninterpreted symbols

1-64, 6-53

units of measure 1-97, B-27
units per em 4-72, 4-78, 4-80

universal script extensions. See WorldScript I;
WorldScript II

untoken table

source mask 6-45, 6-46, 6-99, B-71
target format 6-45, 6-46 to 6-47, 6-99, B-71

target modi er 6-45, 6-47
2-byte script systems 6-46

Unicode

universal scripts A-25

and input methods 6-44
1-byte script systems 6-100

'trsl'

7-23, 7-56 to 7-57

creating a TSM document 7-18 to 7-19, 7-50 to 7-51
deactivating a TSM document 7-20 to 7-21, 7-52 to
7-53
de ned 7-9
deleting a TSM document 7-24, 7-53

6-35 to 6-37, 6-92, B-54 to B-55

UntokenTable data type B-54 to B-55
Update Active Input Area Apple event 7-26 to 7-29,
7-45 to 7-48, 7-68 to 7-72
uppercase characters 1-30. See also case; case
conversion
UppercaseStripDiacritics
procedure

B-39

5-69to5-70,

UppercaseText procedure 5-67 to 5-68, B-39
UpperString procedure 5-64 to 5-65
UpperText routine D-7
UprString routine D-7

U.S. diacritical stripping and case conversion
routines

A-23

IN-21

INDEX

UseInputWindow function

7-24, 7-62

user control of script settings 1-107 to 1-112
user dictionary 1-39, 8-3
U.S. international and keyboard resources A-23 to A-24
U.S. 'KCHR' resource A-19
U.S. sorting routines A-20 to A-22
utilities. See script utilities; Text Utilities

width tables 1-73, 4-68 to 4-71, 4-83. See also global
width table; width/ offset table; glyph-width
table
word boundaries 1-30 to 1-31. See also word-break
tables
nding. See word selection, line breaking
offsets to, in offset table 5-44
in TextEdit 2-6, 2-61
word-break tables 6-37, 6-92, B-44 to B-50

WordRedraw global variable 2-90

V

word selection

verbs. See selectors
version

of the Dictionary Manager
of QuickDraw

8-11

3-18

regional, of a script system 6-57 to 6-58
of the Script Manager 6-8, 6-11, 6-62
of ascript system 6-14, 6-66
of TextEdit 2-23
of the Text Services Manager 7-17

view rectangle

2-16, 2-27 to 2-29, 2-68

viewRect. See view rectangle

virtual key codes

1-12, 1-87, C-6, C-8 to C-9

hardware dependencies C-14 to C-15
for non-ADB keyboards C-15

VisibleLength function

2-14, 3-89 to 3-90, A-26, A-37

W
WaitNextEvent function 2-36
white space 1-25
whitespace table

6-37, 6-92, B-58

wide character array B-57
wide characters B-57
WideCharArr data type B-57
WideChar data type B-57
WidEntry datatype 4-48, 4-99
WidTable data type 4-48, 4-99
WIDTHHook registers 2-112
WidthListHand global variable 4-37
width measurement 2-58
width-measuring hook routines, replacing 2-58 to 2-60
width/offset table

4-24, 4-71

de ned 4-69
offset to 4-71
WidthPtr global variable 4-37
WidthTabHand1e global variable 4-37
WidthTable data type 4-43

IN-22

1-99, 5-23, 5-77 to 5-79, 6-37, 6-92

customizing in TextEdit 2-60 to 2-61
word wrap. See line breaking
WorldScript I 1-40, A-25 to A-35

contextual formatting routines in A-27
dispatching method A-28, A-29 to A-31
le creator for 6-14, 6-71

initialization A-28 to A-29
QuickDraw patches in A-27, A-31

replacing routines in 6-50 to 6-51
script utilities in A-25 to A-26, A-30
table-based script behavior of A-27
testing for 6-69

WorldScript I

1-40, A-36 to A-40

dispatching method

A-39 to A-40

le creator for 6-14, 6-71

initialization A-38
script utilities in A-37
table-based script behavior of A-38
testing for 6-69
writing direction. See line direction
writing systems

1-7, 1-14 to 1-15, 1-21 to 1-35

alignment of text in 1-24 to 1-26
bidirectional 1-24
character reordering in 1-28 to 1-29
character representation in 1-22 to 1-23
contextual forms in 1-26 to 1-29
currency formats of 1-32 to 1-34
date formats of 1-32 to 1-34
de

ned

1-14, 1-21

diacritical marks in 1-29
justi ed text 1-24 to 1-26
line direction of 1-23 to 1-24
number formats of 1-32 to 1-34
sorting order for 1-34
styles used in 1-31 to 1-32
uppercase and lowercase characters in 1-30
variations in 1-34 to 1-35
word boundaries and line breaks in 1-30 to 1-31

INDEX

X
Xor transfer mode. See transfer modes

Y
year, determining in date conversion 5-32, 5-84
y-values, minimum and maximum

4-10

Z
zero digits. See number format speci
zero-width characters 1-73, 3-10
Zhuyinfuhao 1-93, 7-6

cation strings

IN-23

