Apple’ Inside Macintosh
Supplements Inside

Volume

V

gs

gs

wz

~

ses

SBS

£= 3

sss

Ss

ss =

a

Sf

i

aS

=

computers

G
Job Titles

P

i
a

al

f

= Accounts =

rarer

Soeocemnnerresaenana neal

Serer

0,0,65535 = blue

0,0.0 = black

0,65535,0 = green

65535,0,0 = red
65535,65535,65535 = white

RGB Color Cube (see page V-43)

Color art was created on a Macintosh II computer and an AppleColor™
high-resolution RGB monitor using Modern Artist™ software by
Computer Friends, Inc. Final color prints were produced by ColorSet™
from ImageSet™ Corporation.

| ?281

Saturation

|56174

Brightness

|57344

Red

|57344

Green | 40960
Blue | 8192

EDERED)

Hue

EDIEDED)

Select a highlight color.

Color Picker Dialog Box (see page V-173)

ctiltem + btnCtr
(items 1,2)
statText (item 8)

%,

iconitem (item 11)

~

piciltem (item 12)

ctilltern + radCtl (items
3 & 4) |
ctrlltem + chkCtrl (item 5)

rint the document

81/2" #11" paper
.» 81/2" 8 14" paper
-

§Stop printing

after each

page

editText (item 6)
statText (item 9)

userltem (item 7)

Ro

n

Bee

statText (item 10)

Progress of printing

Sample Dialog with Color Dialog Items (see page V-282)

4.
é.

Inside Macintosh,
Volume

vv

Addison-Wesley

V

Publishing

Reading, Massachusetts

Wokingham, England

Company,

Menlo Park, California

Amsterdam

Bonn

Inc.

Sydney

New York

Singapore

Don Mills, Ontario

Tokyo

Madrid

San Juan

@ APPLE COMPUTER, INC.
Copyright © 1986 by Apple Computer, Inc.
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or
transmitted, in any form or by any means, electronic, mechanical, photocopying, recording, or
otherwise, without prior written permission of Apple Computer, Inc. Printed in the United States
of America.
Apple, the Apple logo, AppleShare, AppleTalk, Apple IIGS, A/UX, HyperCard, ImageWriter,
LaserWriter, Lisa, MacApp, Macintosh, MacWorks, and SANE are registered trademarks of Apple
Computer, Inc.
APDA, AppleColor, Apple Desktop Bus, Finder, KanjiTalk, MPW, MultiFinder, and Switcher are
trademarks of Apple Computer, Inc.
MacDraw, MacPaint, and MacWrite are registered trademarks of Claris Corporation.
ColorSet and ImageSet are trademarks of ImageSet Corporation.
Helvetica and Times are registered trademarks of Linotype Co.
Microsoft is a registered trademark of Microsoft Corporation.
Modern Artist is a trademark of Computer Friends, Inc.
NuBus is a trademark of Texas Instruments.
POSTSCRIPT is a trademark of Adobe Systems Incorporated.
UNIX is a registered trademark of AT&T Information Systems.
Simultaneously published in the United States and Canada.

ISBN 0-201-17719-6
EFGHIJ-MU-898

Fifth Printing, December 1988

Inside Macintosh
Volume

V

WARRANTY

INFORMATION

ALL IMPLIED WARRANTIES ON THIS MANUAL, INCLUDING IMPLIED
WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE, ARE LIMITED IN DURATION TO NINETY (90)
DAYS FROM THE DATE OF THE ORIGINAL RETAIL PURCHASE OF
THIS PRODUCT.

Even though Apple has reviewed this manual, APPLE MAKES NO WARRANTY OR
REPRESENTATION, EITHER EXPRESS OR IMPLIED, WITH RESPECT TO
THIS MANUAL, ITS QUALITY, ACCURACY, MERCHANTABILITY, OR
FITNESS FOR A PARTICULAR PURPOSE. AS A RESULT, THIS MANUAL
IS SOLD “AS IS,” AND YOU, THE PURCHASER, ARE ASSUMING THE
ENTIRE RISK AS TO ITS QUALITY AND ACCURACY.
IN NO EVENT WILL APPLE BE LIABLE FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES RESULTING
FROM ANY DEFECT OR INACCURACY IN THIS MANUAL, even if advised of
the possibility of such damages.

THE WARRANTY AND REMEDIES SET FORTH ABOVE ARE EXCLUSIVE
AND IN LIEU OF ALL OTHERS, ORAL OR WRITTEN, EXPRESS OR
IMPLIED. No Apple dealer, agent, or employee is authorized to make any modification,
extension, or addition to this warranty.

Some states do not allow the exclusion or limitation of implied warranties or liability for
incidental or consequential damages, so the above limitation or exclusion may not apply to you.
This warranty gives you specific legal rights, and you may also have other rights which vary

from state to state.

Contents
xi
xii
xii
xiii

xvi

xvil_
xvii

Preface
About Inside Macintosh Volume V
What’s New?
The Material in This Volume

The Languages

Version Numbers
Conventions

1
2
2
5
8
0
1

1 Compatibility Guidelines
About This Chapter
Compatibility
Determining the Features of a Machine
Localization
Applications in a Shared Environment
Summary of Compatibility Guidelines

13
14

2 The Macintosh
About This Chapter

21

New Keyboard Keys

14
19

23

27
28

User

Interface

Color
Sound

New Menu Features

User Testing
Bibliography

29
30
30
30
32
34
37

3 The Resource Manager
About This Chapter
The Resource Manager
Resources
Resources in ROM
Resources in the System File
Summary of the Resource Manager

39
41
42
44
47
49
62
64
65
67
78
81
84
96
106

4 Color QuickDraw
About This Chapter
Color Representation
Using Color on the Macintosh II
About Color QuickDraw
The Color Graphics Port
The Color Cursor
Color Icons
Using Color QuickDraw
Color QuickDraw Routines
Color QuickDraw Resource Formats
Using Text with QuickDraw
Color Picture Format
PICT Opcodes
Summary of Color QuickDraw

Guidelines

Inside Macintosh

117
118

5 Graphics Devices
About This Chapter

119
121
122
125
127
129

Device Records
Miultiple Screen Devices
Graphics Device Routines
Drawing to Offscreen Devices
Graphics Device Resources
Summary of Graphics Devices

133

6

141

Color Manager Routines

118

134
134
139

145
148

About Graphics Devices

The Color Manager

About This Chapter
About the Color Manager
Using the Color Manager

Custom Search and Complement Procedures
Summary of the Color Manager

151
152
152
159
160
160
161
167

7 The Palette Manager
About This Chapter
About the Palette Manager
Color Palette Records
Using the Palette Manager
Color Palettes in a Resource File
Palette Manager Routines
Summary of the Palette Manager

171
172
172
172
174
174
176

8 The Color Picker Package
About This Chapter
The Color Picker Package
The Color Picker Dialog Box
Color Picker Package Routines
Conversion Facilities
Summary of the Color Picker Package

179
180
180
180
181
181
187

9 The Font Manager
About the Font Manager
Font Manager Routines
Fractional Character Widths
‘ont Search Algorithm
Font Manager Data Structures
Summary of the Font Manager

189
190
190
193
194
194
196

10 The Toolbox Event Manager
About This Chapter
New Standard Keyboards
The Keyboard Event Message
New Modifier Flag
KeyTrans
Summary of the Toolbox Event Manager

V-vi Contents

Contents

197
198
199
202
204
205
206
211

Color Window Records
Window Color Tables
Using Color Windows
Defining Your Own Windows
Window Manager Routines
Summary of the Window Manager

215
216
216
218
220
221
221
223

About This Chapter
Auxiliary Control Records
Control Color Tables
Using Color Controls
The Control Color Table Resource
Control Manager Routines
Summary of the Control Manager

11

The Window

About This Chapter

12

Manager

The Control Manager

225
226
228
235
238
248
250
256

13 The Menu Manager
About This Chapter
Menu Manager Data Structures
Using the Menu Manager
Menu Manager Routines
The Standard Menu Definition Procedure

259
260
260
267
267
271

14 TextEdit
About This Chapter
Data Structures

277
278
278
279
283

286

The Standard Menu Bar Definition Procedure

Summary of the Menu Manager

Cutting and Pasting

TextEdit Routines
Summary of TextEdit

15

The Dialog Manager

About This Chapter
Color Dialog and Alert Resources
Color Dialog Item Lists
Using Color Dialogs and Alerts
Dialog Manager Routines
Summary of the Dialog Manager

292

16 The International Utilities Package
About the International Utilities Package
International Resources
Formatting Options
Sorting Routines
Summary of the International Utilities Package

293
294
294
297
303

17 The Script Manager
About This Chapter
About the Script Manager
Text Manipulation
Using the Script Manager

287
288
288
290

Contents V-vii

Inside Macintosh

306
316
319

323

324

Script Manager Routines
Hints for Using the Script Manager
Summary of the Script Manager

18

The Control Panel

About This Chapter

324

The Control Panel

347
348
348
349
350
352
357

19 The Start Manager
About This Chapter
Initialization
System Startup
Special Topics
Start Manager Routines
Summary of the Start Manager

361
362
362
367
371
372

20 The Apple Desktop Bus
About This Chapter
About the Apple Desktop Bus
ADB Manager Routines
Writing ADB Device Drivers
Summary of the ADB Manager

375
376
376
377
380
386

21 File Manager Extensions in a Shared
About This Chapter
About the File Manager Extensions
Overview of the New File Access Methods
The Shared Environment
The Shared Environment Calls

407
408
408
409
410
417

22 The Printing Manager
About the Printing Manager
Calling the Printing Manager in ROM
New Low-Level Printer Controls
PrGeneral
Summary of the Printing Manager

421
422
422
425
426
427
428
433

23 The Device Manager
About the Device Manager
The Startup Process
Opening Slot Devices
Slot Device Interrupts
New Routines
Chooser Changes
Summary of the Device Manager

325
329
334
334
336
346

400

Operation
Cdev call
Storage in a Cdev
Cdev Error Checking
Sample Cdev
Summary of the Control Panel

Summary of the File Manager Extensions

V-viii Contents

Environment

Contents

435
436
436
437
458

24

The Slot Manager

465
466
466
467
468

25

About This Chapter
About the Deferred Task Manager
Deferred Task Manager Routine
Summary of the Deferred Task Manager

469
470
470
472

26 The Disk Driver
Changes to the Disk Driver
Using the Disk Driver
Summary of the Disk Driver

473
474
474
476
477
480
482
490
496
502

27 The Sound Manager
About This Chapter
About the Sound Manager
Using the Sound Manager
Sound Manager Routines
Sound Manager Data Structures
Sound Manager Commands
Sound Resources
MIDI Implementation
Summary of the Sound Manager

507
509
510
520
524
530
551

28 The AppleTalk Manager
About This Chapter
Changes to The AppleTalk Manager
New AppleTalk Protocols
Extended Protocol Package Driver

565
566
567
569

29 The Vertical Retrace Manager
Changes to the Vertical Retrace Manager
Vertical Retrace Manager Routines
Summary of the Vertical Retrace Manager

S71.
572

30 The System
New Error Codes

573
574
574
574
575
576
583

31

About This Chapter
Slot Card Firmware
Slot Manager Routines

Summary of the Slot Manager
The Deferred Task Manager

Calling the .XPP Driver

Summary of the AppleTalk Manager

Error

Handler

The SCSI Manager

Changes to the SCSI Manager
Using the SCSI Manager
SCSI Manager Routines
Transfer Modes
Disk Partitioning
Summary of the SCSI Manager

Contents V-ix

Inside Macintosh

585
586
586
586
587
589

32 The Shutdown Manager
About This Chapter
About the Shutdown Manager
Using the Shutdown Manager
Shutdown Manager Routines
Summary of the Shutdown Manager

o91
392
392
594

33

595

34

ao7

Appendix

A:

Result

601

Appendix

B:

Routines That May

603

Appendix

C:

System Traps

609

Appendix

D:

Global

611

Glossary

617

Index

The

Operating

System

Utilities

Changes to the Operating System Utilities

Operating System Utility Routines
Summary of the Operating System Utilities
The Floating-Point
Packages

V-x Contents

Arithmetic

and

Transcendental

Functions

Move

or Purge Memory

Codes

Variables

PREFACE
xii
xii
xiii
xiii
XiV
X1V
XV
XV
XV
xvi
XV
XVi
XV1
XVil
XVil

About Inside Macintosh Volume V
What’s New?
The Material in This Volume
New Features of General Interest
Extensions and Enhancements

Sophisticated Color Management
Using Multiple Displays

Slot Card Management

International Localization
Sound Creation

Using Different Keyboards
Calling the Operating System
The Languages
Version Numbers
Conventions

V-xi

Inside Macintosh

Reader’s guide:

Read this preface first, before you go on to the rest of the book.

It contains important general information that will save you time and help you
understand the material that follows.

ABOUT

INSIDE MACINTOSH

VOLUME

V

The first three volumes of /nside Macintosh provided information that everyone needs to

write software for any of the Apple® Macintosh® family of computers. Volume IV
provided additional information specific to the Macintosh Plus and Macintosh 512K

enhanced models. This book, Volume V, presents new material specific to the Macintosh

SE and Macintosh II computers. Familiarity with the material presented in the first four

volumes is assumed, since most of the information presented in Volume V

changes and additions to that original material.

consists of

As in Volume IV, many of the chapters in the first three volumes have a corresponding
chapter in Volume V describing new routines, modified data structures, additional error
codes, and soon. Other chapters describe entirely new parts of the Macintosh toolbox and
operating system.
This volume introduces reader’s guides. They are notes that stand out from the text,
usually placed at the beginning of a chapter or section. Reader’s guides help you decide
whether you need to understand the succeeding material. There is one at the beginning of
this preface.

WHAT’S

NEW?

The Macintosh II and Macintosh SE computers both contain new capabilities not present in
earlier Macintosh models. They include:
= Sophisticated sound. Your application can now generate sophisticated music and
sound effects, using special resource types.
m Enhanced menus.
pop-up menus.

The Macintosh Toolbox now supports hierarchical, scrolling, and

= More flexible text. Your application can now determine the font, size, style, and color
of text on a character-by-character basis.
= More powerful AppleTalk® networking system. A number of new features give
AppleTalk added capabilities as a network interface.
a International localization. Your application can now write and edit scripts such as
Japanese and Arabic, as well as handle accented characters and European date and time
formats.
u New keyboards. The Macintosh SE and Macintosh II accept a variety of plug-in
keyboards and let your application determine their key assignments.

V-xii What's New?

Preface

= Custom control panel. Your application can now customize the Macintosh control
panel.
In addition, the Macintosh II alone supports these new features:
= Color. Your application can determine whether or not the Macintosh II user has a
video card and screen that displays in color. If the required equipment is present, your
application can add color to menus, windows, controls, dialogs, text, and graphic
objects.
= Slot cards. The Macintosh II accepts plug-in cards that can support peripherals such as
video displays, data storage devices, communication equipment, and additional
processors.
= Multiple displays. With the Macintosh II, multiple monitors may now display different
parts of the QuickDraw drawing space.
= Different addressing modes.
addressing modes.

THE MATERIAL

The Macintosh II supports both 24-bit and 32-bit

IN THIS VOLUME

Most programmers will never need to read all the material in this book. While some
chapters are of general interest, others are written only for programmers who are doing
specialized tasks. Many chapters begin with reader’s guides, which help you determine in
advance whether you need to read them.
The following is a summary of the contents of this volume, broken down by areas of
interest.
New

Features

of

General

Interest

The following chapters cover new Macintosh features that most programmers will need to

understand.

u Chapter 1, “Compatibility Guidelines”, provides an overview of the new machines
with an eye to the past and future. It tells how to write code that can determine what
features are available on a given machine, gives guidelines for writing software that
will run on the entire Macintosh family, and provides tips for writing software that can
be easily modified for use in other countries.
= Chapter 2, “The Macintosh User Interface Guidelines”, extends the philosophy set
forth in Volumes I and IV. With the introduction of color graphics and slot devices,
it’s especially important that applications present the user with a consistent and
reasoned interface.
= Chapter 3, “The Resource Manager’, describes several new system resources available
for your use.

The Material in This Volume V-xiii

Inside Macintosh

= Chapter 4, “Color QuickDraw”, tells you how to make QuickDraw calls in color.
Unless your application uses color in a sophisticated way (for example, as a color
drawing program), this chapter gives you all you need to know about adding color to
the content area of the desktop.
a Chapter 11, “The Window Manager”, tells you how to add color to windows.
= Chapter 12, “The Control Manager’, explains how to specify colored controls.
u Chapter 13, “The Menu Manager’, discusses the new hierarchical, scrolling, and popup menus, as well as describing how to add color to menus.
a Chapter 14, “TextEdit”, describes how you can now determine the font, size, style,

and color of text on a character-by-character basis.

a Chapter 15, “The Dialog Manager’, tells you how to display dialog boxes in color.
Extensions

and

Enhancements

The following chapters list ways that features described in Volumes I, II, III, and IV have
been extended or improved.
= Chapter 9, “The Font Manager’, discusses new font handling features and clarifies
some old features.
w Chapter 22, “The Printing Manager”, lists new low-level printer controls.

= Chapter 26, “The Disk Driver’, describes some new advanced control calls.
= Chapter 28, “The AppleTalk Manager’, discusses many new enhancements to the
AppleTalk network interface.
= Chapter 30, “The System Error Handler’, lists new system error codes.
= Chapter 31, “The SCSI Manager’, tells you how the SCSI Manager has been
improved.
= Chapter 34, “The Floating-Point Arithmetic and Transcendental Functions Packages”,
describes briefly the role of the new MC68881 coprocessor in mathematical
calculations.

Sophisticated

Color

Management

Two chapters give you basic information about using color.
w Chapter 4, “Color QuickDraw”, gives you fundamental color theory and tells you how
to add color information to QuickDraw calls.
= Chapter 7, “The Palette Manager”, explains the facilities that help your application
establish a working color environment.
If you are using color in a precise or sophisticated way, rather than as a simple
enhancement for your application, you may need some of the information in two other
chapters:

V-xiv The Material in This Volume

Preface
a Chapter 6, “The Color Manager’, lists the low-level calls that QuickDraw uses to

manage the color responses of Macintosh II video cards. Applications seldom use
these calls.

a Chapter 8, “The Color Picker Package”, describes the new standard interface for color
selection by the user.

Using

Multiple

Displays

Two chapters in this volume discuss new facilities that allow an application to use more
than one display screen.
a Chapter 5, “Graphics Devices”, tells you how to manage more than one output
display.
a Chapter 29, “The Vertical Retrace Manager’, describes how vertical retrace tasks can

be allocated among multiple display screens.

Slot

Card

Management

Three chapters in this volume describe the tools that manage plug-in cards in the NuBus
slots of the Macintosh II. The Macintosh system normally handles all slot card
management; hence most applications do not need to use these tools. The following
chapters are of interest if your application needs to interrogate a slot card directly or change
its operating mode.
a Chapter 23, “The Device Manager’, tells you how slot devices are installed and
opened, as well as how corresponding changes to the Chooser are made.
a Chapter 24, “The Slot Manager’, explains how the system keeps track of slot
resources.
a Chapter 25, “The Deferred Task Manager’, describes how tasks initiated by slot cards
may be deferred until other tasks are completed.
In addition to this material, slot cards are thoroughly discussed in the separate Apple book
Designing Cards and Drivers for Macintosh II and Macintosh SE.
International

Localization

Two chapters in this volume help you write applications for use in foreign countries.
a Chapter 16, “The International Utilities Package”, describes new facilities for handling
accented characters and European date and time formats.
a Chapter 17, “The Script Manager’, explains how applications can now handle text in
such languages as Japanese and Arabic.

The Material in This Volume V-xv

Inside Macintosh

Sound

Creation

Chapter 27, “The Sound Manager’, discusses new facilities for creating music and other
complex sound effects with the Macintosh.

Using

Different

Keyboards

Chapter 10, “The Toolbox Event Manager”, describes new keyboards available for the
Macintosh (including multiple keyboard configurations) and discusses how key layouts can
be changed.

Calling the Operating

System

The following chapters are addressed to programmers who need to write code that calls
parts of the Macintosh operating system directly.
= Chapter 18, “The Control Panel”, tells you how to customize the Control Panel.
a Chapter 19, “The Start Manager’, describes how the Macintosh II and Macintosh SE

start up.

= Chapter 20, “The Apple Desktop Bus”, discusses the operation of the bus that
connects the system to user input devices such as keyboards and the mouse.
= Chapter 21, “File Manager Extensions in a Shared Environment’, explains the new
routines that support file access in a shared environment.
= Chapter 32, “The Shutdown Manager’, describes how the Macintosh II and Macintosh
SE shut down.

= Chapter 33, “The Operating System Utilities”, explains how to switch the Macintosh II
between 24-bit and 32-bit addressing modes.

THE LANGUAGES
The routines described in this book are written in assembly language, but (with a few

exceptions) they’re also accessible from higher-level languages. The first four volumes of

Inside Macintosh document the interfaces to these routines on the Lisa® Workshop
development system. A powerful new development system, the Macintosh Programmers
Workshop (MPW™), is now available. Volume V documents the MPW Pascal interfaces
to the routines and the symbolic identifiers defined for assembly-language programmers
using MPW. These identifiers are usually identical to their Lisa Workshop counterparts. If
you’re using a different development system, its documentation should tell you how to
apply the information presented here to that system.
Inside Macintosh is intended to serve the needs of both high-level language and assemblylanguage programmers. Every routine is shown in its Pascal form (if it has one), but

V-xvi The Languages

Preface
assembly-language programmers are told how they can access the routines. Information of
interest only to assembly-language programmers is set apart and labeled so that other
programmers can conveniently skip it.
Familiarity with MPW Pascal (or a similar high-level language) is recommended for all
readers, since it’s used for most examples. MPW Pascal is described in the documentation
for the Macintosh Programmer’s Workshop.

VERSION

NUMBERS

This edition of Inside Macintosh Volume V describes the following version of the software:
mw version 118 ($76) of the ROM in the Macintosh SE
w version 120 ($78) of the ROM in the Macintosh II
m version 2.0 of the MPW Pascal interfaces and the assembly-language definitions
Some of the RAM-based software is read from the file named System (usually kept in the
System Folder). This manual describes the software in the System file version 4.1. In
certain cases, a feature can be found in earlier versions of the System file; these cases are

noted in the text.

CONVENTIONS
The following notations are used in Volume V to draw your attention to particular items of
information:
Reader’s guide: Advice to you, the reader, that will help you decide whether or
not you need to understand the material in a specific chapter or section.
Note:

An item of technical information that you may find interesting or useful.

Warning: A point you need to be cautious about.
Assembly-language note: Information of interest to assembly-language
programmers only. For a discussion of Macintosh assembly-language
programming, see the chapter “Using Assembly Language” in Volume I.

Conventions V-xvii

Inside Macintosh
[Not in ROM]
Routines marked with the notation [Not in ROM]

are not part of the Macintosh ROM.

Depending on which System file the user has and on how complete the interfaces are

in the development system you’re using, these routines may or may not be available.
They’re available with Version 4.1 and later of the Macintosh System file and in
programs developed with the Macintosh Programmer’s Workshop.
[Macintosh IT]

Routines marked with the name or names of specific models work only on those
machines.

V-xviii Conventions

——

~~
V4
=ee
a

ro]
pS)

—

COMPATIBILITY

1

GUIDELINES

latmal

—
S
me

mes

—

ps

RP OonwMmonhwnnvnnhd

—_

<

About This Chapter
Compatibility
General Guidelines
Memory
Assembly Language
Hardware
Determining the Features of a Machine
Localization
iPero, Se Habla Espafiol?
Non-Roman Writing Systems
Applications in a Shared Environment
Summary of Compatability Guidelines

~

wd

=

=e

Qu.
@

—
so

~
@

wn

V-1

Inside Macintosh

ABOUT

THIS CHAPTER

Compatibility is a concern for anyone writing software.

For some programmers, it’s a

concern because they want to write software that will run, with little or no modification, on

all versions of the Macintosh. Other programmers want to take advantage of particular
software and hardware features; they need to know where and when these features are
available.

This chapter gives guidelines for making it more likely that your program will run on
different versions, present and future, of the Macintosh. It also gives tips for writing
software that can be easily modified for use in other countries. Finally, it explains how to
determine what features are available on a given machine.

COMPATIBILITY
The key to compatibility is not to depend on things that may change. /nside Macintosh
contains hundreds of warnings where information is likely to change; all of these warnings
can be summarized by a single rule: use global variable names and system calls, rather than
addresses and numeric values.
At the most basic level, all of the software and hardware components of the
Macintosh—each line of ROM code, each RAM memory location, each hardware
device—are represented by numbers. Symbolic names have been defined for virtually
every routine, variable, data structure, memory location, and hardware device that your
application will need to use. Use of these names instead of the actual numbers will
simplify the process of updating your application when the numbers change.
General

Guidelines

Any field that’s marked in Jnside Macintosh as “not used” should be considered “reserved
by Apple” and usually be left 0.
While Jnside Macintosh gives the structure of low-level data structures (for instance, file
control blocks, volume control blocks, and system queues), it’s best not to access or
manipulate these structures directly; whenever possible, use the routines provided for doing
this.
You shouldn’t rely on system resources being in RAM; on the Macintosh Plus, Macintosh
SE, and Macintosh II, certain system resources are in ROM.

that you can regain RAM space by releasing system resources.

Don’t assume, for example,

A variety of different keyboards are available for the Macintosh; you should always read
ASCII codes rather than key codes.

V-2 Compatibility

Compatibility Guidelines
Don’t count on the alternate (page 2) sound or video buffers. On the Macintosh II, you can
determine the number of video pages and switch between them; for details, see the Video

Drivers chapter in this volume.

—

°

=
s)

oS)

=.

To be compatible with printers connected directly to the Macintosh or via AppleTalk, use
either the Printing Manager or the Printer Driver’s control calls for text-streaming and
bitmap-printing (as documented in /nside Macintosh). Don’t send ASCII codes directly to
the Printer Driver. In general, you should avoid using printer-specific features and should
not access the fields of the print record directly.

Si
=
‘=
op
=
=
a=
@

4)

Memory
You shouldn’t depend on either the system or application heap zones starting at certain
addresses. Use the global variable App|Zone to find the application heap and the variable
SysZone to locate the system heap. You should not count on the application heap zone
starting at an address less than 65536; in other words, don’t expect a system heap that’s
smaller than 64K in size.
Space in the system heap is extremely limited. In general, avoid using the system heap; if
you must, allocate only very small objects (about 32 bytes or less). If you need memory
that won’t be reinitialized when your application ends, allocate it with an 'INIT" resource;
for details, see the System Resource File chapter in Volume IV.
The high-order byte of a master pointer contains flags used by the Memory Manager. In
the future, all 32 bits of the pointer may be needed, in which case the flags byte will have to
be moved elsewhere. For this reason, you should never set or clear these flags directly but
should instead use the Memory Manager routines HPurge, HNoPurge, HLock, HUnlock,
HSetRBit, HClrRBit, HGetState, and HSetState.

You should allow for a variety of RAM

memory sizes.

While 128K, 512K, 1 MB,

and 2 MB are standard sizes, many other RAM configurations are possible.

NIL handles (handles whose value is zero) are common bugs; they typically come from

unsuccessful GetResource calls and often result (eventually) in address errors. The 68020
does not give address errors when accessing data, so be sure to test your code for NIL

handles and null pointers.

Assembly

Language

In general, you shouldn’t use 68000 instructions that depend on supervisor mode; these

include instructions that modify the contents of the Status Register (SR).

Programmers

typically modify the SR only as a means of changing the Condition Code Register (CCR)
half of the register; an instruction that addresses the CCR directly will work fine instead.
You should also not use the User Stack Pointer or turn interrupts on and off.
Timing loops that depend on the clock speed of a particular processor will fail when faster
processors are introduced. You can use the Operating System Utility procedure Delay for
timing, or you can check the contents of the global variable Ticks. For more precise

Compatibility V-3

Inside Macintosh

timings, you can use the Time Manager (taking advantage of the VIA timers). Several
global variables also contain useful timing information; they're described in the Start
Manager chapter.
If you wish to handle your own exceptions (thereby relying on the position of data in the
exception’s local stack frame), be aware that exception stack frames vary within the 68000
family.
In particular, don't use the TRAP instruction.

Also, the TAS instruction, which uses a

special read-modify-write memory cycle, is not supported by the Macintosh SE and
Macintosh II hardware.

A memory management unit in the Macintosh II may prevent code from writing to
addresses within code segments. Also, the 68020 caches code as it’s encountered. Your
data blocks should be allocated on the stack or in heap blocks separate from the code, and
your code should not modify itself.
Note:

You can determine which microprocessor is installed by calling the

SysEnvirons function; it’s described below.

The Floating-Point Arithmetic and Transcendental Functions Packages have been extended
to take advantage of the MC68881 numerics coprocessor; using the routines in these

packages will ensure compatibility on all current and future versions of the Macintosh.
(For details on these packages, see the Floating-Point Arithmetic and Transcendental
Functions Packages chapter in this volume.)

Memory locations below the system heap that aren’t documented may not be available for
use in future systems. Also, microprocessors in the 68000 family use the exception
vectors in locations $0 through $FF in different ways. In general, don’t depend on any
global variable that isn’t documented in /nside Macintosh.
Don’t store information in the application parameters area (the 32 bytes between the
application globals and the jump table); this space is reserved for use by Apple.
Don’t depend on the format of the trap dispatch table. Use the Operating System Utility
routines GetTrapAddress and SetTrapAddress to access the trap dispatch table. You

should also not use unassigned entries in the trap table, or any other unused low memory

location.

Inside Macintosh documents the values returned by register-based routines; don’t depend
on return values that aren’t documented here.
Hardware

As a general rule, you should never address hardware directly; whenever possible, use the
routines provided by the various device drivers. The addresses of memory-mapped
hardware (like the VIA1, VIA2, SCC, and IWM) are always subject to change, and direct
access to such hardware may not be possible. For instance, the Macintosh II memorymanagement unit may prevent access to memory-mapped hardware. If you must access

V-4 Compatibility

Compatibility Guidelines
the hardware directly, get the base address of the device from the appropriate global

variable; see the Macintosh Family Hardware Reference Manual for details.

—*

©
o

=
SS

a=)

Warning: Although there’s a global variable that contains the SCSI base address,
you should use the SCSI Manager; this is especially important with regard to
asynchronous operation.
Note: Copy-protection schemes that rely on particular hardware characteristics are
subject to failure when the hardware changes.

S.

S.
=
<
@

=F
=
st
=
o

i* 2)

You should avoid writing directly to the screen; use QuickDraw whenever possible. If you

must write directly to the screen, don’t “hard code” the screen size and location.

variable ScreenBits contains a bit map corresponding to the screen being used.

The global

ScreenBits.bounds is the size of the screen, ScreenBits.baseAddr is the start of the screen,

and ScreenBits.rowBytes gives the offset between rows.

Warning: The screen size can exceed 32K; use long word values in screen
calculations. Also, the screen may be more than one pixel in depth; see the
QuickDraw chapter for details.
There are many sizes of disks for the Macintosh from Apple, and more from third-party
vendors. Use the Standard File Package and File Manager calls to determine the number
and size of disk drives.

DETERMINING

THE FEATURES

OF A MACHINE

As the Macintosh family grows, applications need a reliable and comprehensive way of
determining what software and hardware features are available on a given machine.
Although the Operating System Utilities routine Environs indicates the type of machine and
ROM version running, it provides no help in distinguishing between the plethora of
different software feature sets and hardware configurations that an application may
encounter.
A new function, SysEnvirons, provides detailed information about what software
functionality (Color QuickDraw, as an example) is available, as well as what hardware

devices (processors, peripherals, and so on) are installed or connected.

All of the Toolbox Managers must be initialized before calling SysEnvirons. In addition,
the AppleTalk Manager routine MPPOpen must be called if the driver version information
in atDrvrVersNum is desired. SysEnvirons is not intended for use by device drivers, but
can be called from desk accessories. (It does not assume that register A5 has been properly
set up.)

Determining the Features of a Machine V-5

Inside Macintosh
FUNCTION

SysEnvirons

SysEnvRecPtr)

(versRegested:

: OSErr;

Trap macro

_SysEnvirons

On entry

AO:
DO:

On exit

AO: sysEnvRecPtr (pointer)
DO: result code (word)

Result codes

INTEGER;

[Notin

ROM]

VAR

theWorld:

sysEnvRecPtr (pointer)
versRegested (word)

= noErr
envNotPresent
envBadVers
envVersTooBig

No error
SysEnvirons trap not present
Nonpositive version number passed
Requested version of SysEnvirons call not available

In theWorld, SysEnvirons returns a pointer to a system environment record
describing the features of the machine. Designed to be extendible, SysEnvirons will be
updated as new features are added, and the system environment record that’s returned will
be expanded. System File 4.1 contains version 1 of SysEnvirons; subsequent versions
will be incremented by 1.
The system environment record for version 1 of SysEnvirons contains the following
TYPE

SysEnvRec

=

RECORD
environsVersion:

INTEGER;
INTEGER;

hasFPU:

BOOLEAN;

hasColorQD:
keyBoardType:
atDrvrVersNum:
sysVRefNum:
END;
SysEnvPtr

=

INTEGER;

machineType:
systemVersion:
processor:

fields:

INTEGER;

BOOLEAN;
INTEGER;
INTEGER;
INTEGER

“SysEnvRec;

New versions of the call will add fields to this record. To distinguish between different
versions of the call, and thereby between the different sizes of records they return,
SysEnvirons returns its version number in the environsVersion field. If you request

version 2, for instance, but only version 1 is available, the environsVersion field will

contain the value 1, and the result code env VersTooBig will be returned. This tells you that
only the information for version 1 has been returned in SysEnvRec.
The MPW 2.0 interface files contain code, or “glue’”’, for System file versions earlier than
4.1, as well as for the 64K and the Macintosh XL ROMs. The glue checks for the

existence of the trap at runtime; if the call does not exist, the glue fills in all fields of the

record except systemVersion and returns the result code envNotPresent.

V-6 Determining the Features of a Machine

Compatibility Guidelines

=

a
=

Assembly-language note: As with the MoveHHi procedure, assembly-language
programmers using MPW should link with the glue and execute
JSR

a)
=

=A

=F
Ss

SysEnvirons

<<

op

If you’re using another development system, refer to its documentation for details.
The machineType field returns one of the following
CONST

0;

envMachUnknown

env512KE
envMacPlus
envSE
envMacII

1;
2;
3;
4;

=
=
=

e.

2.

ot=

constants:

i$")
Mm

{new version
of Macintosh--not
covered
{ by this version
of SysEnvirons)
{Macintosh
512K enhanced}
{Macintosh
Plus}
{Macintosh
SE}
{Macintosh
IT}

}

In addition to these, the glue for SysEnvirons may return one of the following:
CONST

envMac
envXL

=
=

-1;
-2;

{Macintosh
{Macintosh

with
XL}

64K

ROM}

The systemVersion field returns the version number of the System file represented as two
byte-long numbers, separated by a period. (It is not a fixed point number.) For instance,
System 4.1 returns $0410 or 04.10 in this field. (Applications can use this for compare
operations.) If SysEnvirons is called while a system earlier than System 4.1 is running,
the glue will return a $0 in this field, and the result code envNotPresent will be returned.
The processor field returns one of the following constants:
CONST

envCPUUnknown

=

env68000

=

env68010
env68s020

0;

1;

=
=

2;
3;

{new processor--not
yet covered
of SysEnvirons}
{ version

{MC68000

{MC68010
{MC68020

by

this

}

processor}
processor}
processor}

The hasFPU field tells whether or not a Motorola MC68881 floating-point coprocessor unit
is present. (This field does not apply to third-party memory-mapped coprocessor addons.)

The hasColorQD field tells whether or not Color QuickDraw is present. It does not indicate
whether or not a color screen is present (high-level QuickDraw calls provide this
information).

The keyboardType field returns one of the following
CONST

envUnknownKbd
envMacKbd
envMacAndPad
envMacPlusKbd
envAExtendKbd

envStandADBKbd

=
=
=
=
=

0;
1;
2;
3;
4;
5;

constants:

{Macintosh Plus keyboard with keypad}
{Macintosh keyboard}
{Macintosh keyboard and keypad}
{Macintosh Plus keyboard}
{Apple extended keyboard}
{standard

Apple

Desktop

Bus

keyboard}

Determining the Features of a Machine V-7

Inside Macintosh
If the Apple Desktop Bus™ is in use, this field returns the keyboard type of the keyboard
on which a keystroke was last made.
ATDrvrVersNum returns the version number of AppleTalk, if it’s been loaded (that is, if
MPPOpen has been called); otherwise, 0 is returned in this field.
SysVRefNum returns the working directory reference number (or volume reference
number) of the directory that contains the currently open System file.

LOCALIZATION
Localization is the process of adapting an application to a specific language and country.
By making localization relatively painless, you ensure that international markets are
available for your product in the future. You also allow English-speaking users in other
countries to buy the U.S. English version of your software and use it with their native
languages.
The key to easy localization is to store the country-dependent information used by your
application as resources (rather than within the application’s code). This means that text
seen by the user can be translated without modifying the code. In addition, storing this
information in resources means that your application can be adapted for a different country
simply by substituting the appropriate resources.

éPero,

Se

Habla

Espafiol?

Not all languages have the same rules for punctuation, word order, and alphabetizing. In
Spanish, questions begin with an upside-down question mark. The roles of commas and
periods in numbers are sometimes the reverse of what you may be used to; in many
countries, for instance, the number 3,546.98 is rendered 3.546,98.

Laws and customs vary between countries. The elements of addresses don’t always appear
in the same order. In some countries, the postal zone code precedes the name of the city,
while in other countries the reverse is true. Postal zone codes vary in length and can
contain letters as well as numbers. The rules for amortizing mortgages and calculating
interest rates vary from country to country—even between Canada and the United States.
Units of measure and standard formats for time and date differ from country to country.
For example, “lines per inch” is meaningless in the metric world—that is, almost
everywhere. In some countries, the 24-hour clock prevails.
Words aren’t the only things that change from country to country. Telephones and
mailboxes, to name just two examples often used in telecommunications programs, don’t
look the same in all parts of the world. Either make your graphics culturally neutral, or be
prepared to create alternate graphics for various cultures.

V-8 Localization

Compatibility Guidelines
Mnemonic shortcuts (such as Command-key equivalents for menu items) that are valid in
one language may not be valid in others; be sure all such shortcuts are stored as resources.
Keyboards vary from country to country. Keystrokes that are easily performed with one
hand in your own country may require two hands in another. In France and Italy, for
instance, typing numerals requires pressing the Shift key.
If you rely on properties of the ASCII code table or use data compression codes that
assume a Certain number of letters in the alphabet, remember that not all alphabets have the
same numbers of characters. Don’t rely on strings having a particular length; translation
will make most strings longer. (As an example, the length of Apple manuals has been
known to increase as much as 30% in translation.) Also, some languages require two
bytes instead of one to store characters.

Non-Roman

Writing

Systems

The Script Manager contains routines that allow an application to function correctly with
non-Roman scripts (or writing systems). It also contains utility routines for text processing
and parsing, which are useful for applications that do a lot of text manipulation. General
applications don’t need to call Script Manager routines directly, but can be localized for
non-Roman alphabets through such script interface systems as Apple’s Kanji Interface
System and Arabic Interface System. (Scripts and script interface systems are described in
the Script Manager chapter in this volume.)
The International Utilities Package provides routines for sorting, comparing strings, and
specifying currency, measurements, dates, and time. It’s better to use the routines in this
package instead of the Operating System Utility routines (which aren’t as accurate and can’t
be localized).

You should neither change nor depend upon the system font and system font size. Some
non-Roman characters demand higher resolution than Roman characters. On Japanese
versions of the Macintosh, for instance, the system font must allow for 16-by-16 pixel

characters. You can use the global variables SysFontFam and SysFontSize for determining
the system font and system font size.
The Menu Manager uses the system font and the system font size in setting up the height of
the menu bar and menu items. Because the system font size can vary, the height of the
menu bar can also vary. When determining window placement on the screen, don’t
assume that the menu bar height is 20 pixels. Use the global variable MBarHeight for
determining the height of the menu bar.
Avoid using too many menus; translation into other languages almost always widens menu
titles, forcing some far to the right (possibly conflicting with Switcher™) or even off the
screen.

Most Roman fonts for the Macintosh have space above all the letters to allow for diacritical

marks as with A or N. If text is drawn using a standard font immediately below a dark
line, for example, it will appear to be separated from the line by at least one row of blank
pixels (for all but a few exceptional characters). Pixels in some non-Roman fonts, on the
other hand, extend to the top of the font rectangle, and appear to merge with the preceding

Localization V-9

—.

2)

=

a=)
pS)

ae

S,

=
<<

~~
et 4

=

oy

cs
>
om

i 2)

Inside Macintosh

line. To avoid character display overlap, applications should leave blank space around text
(as in dialog editText or statText items ), or add space between lines of text, as well as
before the first line and after the last line of text.
The choice of script (Roman, Japanese, Arabic, and so on) is determined by the fonts
selected by the user. If an application doesn’t allow the user to change fonts, or allows the
user to select only a global font for the whole document, the user is restricted in the choice
and mix of scripts.
If text must be displayed in either uppercase or lowercase, you should call the Script
Manager Transliterate routine rather than the UprString routine (which doesn’t handle
diacritical marks or non-Roman scripts correctly).

APPLICATIONS

IN

A SHARED

ENVIRONMENT

A number of new products create environments in which users can share information.

Network file servers (like AppleShare®), for instance, make it possible for users to share
data, applications, and disk storage space. Multitasking operating systems and programs
like Switcher can also be considered shared environments, allowing data to be shared
between applications.
To operate smoothly in a shared environment, you’ll need to be sensitive to issues like
multiple file access, access privileges, and multiple launches. For a complete discussion of
how to operate in shared environments, see the File Manager Extensions in a Shared
Environment chapter in this volume.

V-10 Applications in a Shared Environment

Compatibility Guidelines

—_

OQ
=)

SUMMARY

OF

COMPATIBILITY

=|

GUIDELINES

SS

bo)

=

oS:

Data

Type

TYPE

SysEnvRec

=:
<

)

=
=

Q.

ss

RECORD

environsVersion:
machineType:
systemVersion:
processor:
hasFPU:
hasColorQD:
keyBoardType:
atDrvrVersNum:
sysVRefNum:

=%

INTEGER;
INTEGER;
INTEGER;

@
”

INTEGER;
BOOLEAN;
BOOLEAN;
INTEGER;
INTEGER;
INTEGER

END;

SysEnvPtr

=

“SysEnvRec;

Routine
FUNCTION

SysEnvirons

Result

Codes

Name

(versionRequested:

Value

SysEnvRec)

: OSErr;

INTEGER;

[Notin

VAR

theWorld:

ROM]

Meaning
No error

noErr
envNotPresent

—5500

SysEnvirons trap not present (System File earlier than
version 4.1); glue returns values for all fields except
system Version

envBadVers

—5501

A nonpositive version number was passed—no information
is returned

envVersTooBig

—5502

Requested version of SysEnvirons call was not available

Summary

of Compatibility Guidelines V-11

Inside Macintosh

Assembly-Language
Structure

of System

environsVersion
machineType

(word)
(word)

keyBoardType

(word)

systemVersion
processor
hasFPU
hasColorQD

atDrvrVersNum
sysVRefNum

sysEnvRecSize

Information
Environment

Record

(word)
(word)
(byte)
(byte)
(word)
(word)

Size of system environment record

Routine
Trap macro

On entry

On

exit

_SysEnvirons

AO:
DO:

AO:
DO:

sysEnvRecPtr (ptr)
result code (word)

sysEnvRecPtr (ptr)
versRequested (word)

Variables
ApplZone
MBarHeight
MemTop
ScreenBits
SysZone
Ticks

Address of application heap zone
Height of menu bar (word)
Address of end of RAM
Bit map of screen in use (bitMapRec bytes)
Address of system heap zone
Current number of ticks since system startup (long)

V-12 Summary of Compatibility Guidelines

2

THE MACINTOSH
GUIDELINES
14
14
15
15

About This Chapter
Color
Standard Uses of Color
Color Coding

16
17.

Limit Color Use
—_‘ Contrast and Discrimination

16
16
17

17
17

17

17
17
18
18
18
18
18
18
19
19
19
19
19
20
20
20
20
20
20
20
21
21
22
23
23
25
26
27
27
27
28
28

USER

INTERFACE

General Principles of Color Design
Design in Black and White

si
=
g

Colors on Grays

=

Colored Text
Beware of Blue

o
=

Small Objects

e

Specific Recommendations
Color the Black Bits Only
Leave Outlines Black
Highlighting and Selection
Menus
Windows
Dialogs and Alerts
Pointers
Sound
When to Use Sound
Getting Attention
Alerts
Modes
General Guidelines
Don’t Go Overboard
Redundanc
Natural and Unobtrusive
Significant Differences
User Control
Resources
New Keyboard Keys
Control and Escape Keys
Function Keys
New Menu Features
Hierarchical Menus
Pop-Up Menus
— Scrolling Menu Indicator
User Testing
Build User Testing Into the Design Process
~~ Test Subjects
Procedures
Bibliography

V-13

Inside Macintosh

ABOUT
THIS CHAPTER
This chapter describes the following new features of the Macintosh user interface:
= color
m sound
m new keyboard keys
m™ new menu features—hierarchical and pop-up menus and a scrolling menu indicator.
The chapter concludes with some suggestions for user testing.
For more complete information about the Macintosh user interface, see Human Interface
Guidelines: The Apple Desktop Interface (available through APDA). These guidelines are
significantly extended from the guidelines chapter in the original Jnside Macintosh; they
include the principles behind the desktop interface used by both the Macintosh and
Apple IIGS™, as well as specific guidelines for how interface elements should be used.
For more information about color, see the Color Manager and Color Picker Package

chapters.

Some reference works on color in the computer/user interface are listed at the end

of this chapter.

For more information about sound and menus, see the Sound and Menu

Manager chapters, respectively.

COLOR
Apple’s goal in adding color to the desktop user interface is to add meaning, not just to
color things so they “look good”. Color can be a valuable additional channel of

information to the user, but must be used carefully; otherwise, it can have the opposite of

the effect you were trying for, and can be overwhelming visually (or look game-like).

Color is ultimately the domain of the user, who should be able to modify or remove any
coloring imposed by the application. Unless you are implementing a color application such
as a paint or draw program, you should consider color only for the data, not the interface.
In order to successfully implement color in an application, you should understand some of
the complex issues surrounding its use. Many major theories on the proper use of color are
not complete or well defined. The way in which the human eye sees color is not fully
understood, nor are color’s subjective effects.

V-14 Color

The Macintosh User Interface Guidelines

Standard

Uses

of Color

In traditional user interface design, color is used to associate or separate objects and
information in the following ways:
w discriminate between different areas

a show which things are functionally related
m show relationships between things

= identify crucial features

Color

tr
S

Coding

2)

2

—

Different colors have standard associations in different cultures. “Meanings” of colors
usually have nothing to do with the wavelength of the color, but are learned through
conditioning within a particular culture. Some of the more universal meanings for colors
are

a Red: stop, error, or failure.

(For disk drives, red also means disk access in progress;

don’t remove the disk or turn it off.).

u Yellow: warning, caution, or delay.

m Green: go, ready, or power on.
mw Warm versus cold: reds, oranges, and yellows are perceived as hot or exciting colors;
blues and greens are cool, calm colors.

Colors often have additional standard meanings within a particular discipline: in the

financial world, red means loss and black means gain. To a mapmaker, green means
wooded areas, blue means water, yellow means deserts. In an application for a specific
field, you can take advantage of these meanings; in a general application, you should allow
users to change the colors and to turn off any color-coding that you use as a default.
For attracting the user’s attention, orange and red are more effective than other colors, but
usually connote “warning” or “danger”. (Be aware, though, that in some cases, attracting
the eye might not be what you want to do; for example, if “dangerous” menu items are
colored red, the user’s eye will be attracted to the red items, and the user might be more
likely to select the items by mistake.)
Although the screen may be able to display 256 or more colors, the human eye can
discriminate only around 128 pure hues. Furthermore, when colors are used to signify
information, studies have shown that the mind can only effectively follow four to seven
color assignments on a screen at once.

Color V-15

=)

—

a7}

bee

s
oO
@

3

Inside Macintosh

General

Principles

of Color

Design

Two principles should guide the design of your application: begin the design in black and
white, and limit the use of color, especially in the application’s use of the standard
interface.

Design

in Black

and

White

You should design your application first in black and white. Color should be
supplementary, providing extra information for those users who have color. Color
shouldn’t be the only thing that distinguishes two objects; there should always be other
cues, such as shape, location, pattern, or sound. There are several reasons for this:
= Monitors: Most of your users won’t have color. The majority of Macintosh computers
that Apple ships are black and white, and will continue to be so for some time.
m Printing: Currently, color printing is not very accurate, and even when high-quality
color printing becomes available, there is usually a significant change in colors
between media.
= Colorblindness: A significant percentage of the population is colorblind to some
degree. (In Europe and America, about 8% of males and 0.5% of females have some

sort of defective color vision.) The most common form of colorblindness is a loss of

ability to distinguish red and green from gray. In another form, yellow, blue, and
gray are indistinguishable.

= Lighting: Under dim lighting conditions, colors tend to wash out and become difficult
for the eye to distinguish—the differences between colors must be greater, and the
number of colors fewer, for them to be discernable.

under which your application may be used.
Limit

Color

You can’t know the conditions

Use

In the standard interface part of applications (menus, window frames, etc.), color should
be used mimimally or not at all; the Macintosh interface is very succesful in black and

white.

You want the user’s attention focused on the content of the application, rather than

distracted by color in the menus or scroll bars. Availability of color in the content area of
your application depends on the sort of application:
= Graphics applications, which are concerned with the image itself, should take full
advantage of the color capabilities of Color QuickDraw, letting the user choose from
and modify as many colors as are available.

= Other applications, which deal with the organization of information, should limit the
use of color much more than this. Color-coding should be allowed or provided to
make the information clearer. Providing the user with a small initial selection of
distinct colors—four to seven at most—with the capability of changing those or adding
more, is the best solution to this.

V-16 Color

The Macintosh User Interface Guidelines

Contrast

and

Discrimination

Color adds another dimension to the array of possible contrasts, and care must be given to
maintain good readability and discernment.

Colors

on

Grays

Colors look best against a background of neutral gray, like the desktop. Colors within
your application will stand out more if the background and surrounding areas (such as the
window frame and menus) are black and white or gray.

nN
eZ)

Colored

<7)
=

Text

—

=

—

Reading and legibility studies in the print (paper) world show that colored text is harder to
read than black text on a white background. This also appears to be true in the limited

studies that have been done in the computer domain, although almost all these studies have

looked at colors on a black background, not the white background used in the Macintosh.
Beware

of

Blue

The most illegible color is light blue, which should be avoided for text, thin lines, and

small shapes. Adjacent colors that differ only in the amount of blue should also be
avoided. However, for things that you want to go unnoticed, like grid lines, blue is the
perfect color (think of graph paper or lined paper).

Small

Objects

People cannot easily discriminate between small areas of color—to be able to tell what color
something is, you have to have enough of it. Changes in the color of small objects must be
obvious, not subtle.

Specific

Recommendations

Remember that color should never be the only thing that distinguishes objects. Other cues

such as shape, location, pattern, or sound, should always be used in addition to color, for
the reasons discussed above.

Color the

Black

Bits Only

Generally, all interface elements should maintain a white background, using color to

replace black pixels as appropriate. Maintaining the white background and only coloring
what is already black (if something needs to be colored at all) helps to maintain the clarity
and the “look and feel” of the Macintosh interface.

Color V-17

a7)
~

=

i
©
o

Inside Macintosh

Leave

Outlines

Black

Outlines of menus, windows, and alert and dialog boxes should remain in black.

Edges

formed by color differences alone are hard for the eye to focus on, and these objects may
appear against a colored desktop or window.

Highlighting

and

Selection

Most things—menu items, icons, buttons, and so forth—should highlight by reversing the
white background with the colored or black bits when selected.

(For example, if the item is

red on a white background, it should highlight to white on a red background.) However, if

multiple colors of text appear together, Color TextEdit allows the user to set the

highlighting bar color to something other than black to highlight the text better. The default
for the bar color is always black.
Menus

In general, the only use of color in menus should be in menus used to choose colors.
However, color could also be useful for directing the user’s choices in training and tutorial
materials: one color can lead the user through a lesson.
Windows

Since the focus of attention is on the content region of the window, color should be used
only in that area. Using color in the scroll bars or title bar can simply distract the user. (A
possible exception would be coloring part of a window to match the color of the icon from
which it came.)

Dialogs

and

Alerts

Except for dialog boxes used to select colors, there’s no reason to color dialog boxes; they
should be designed and laid out clearly enough that color isn’t necessary to separate
different sections or items. Alert boxes must be as clear as possible; color can add
confusion instead of clarity. For example, if you tried to make things clearer by using red
to mean “dangerous” and green to mean “safe” in the Erase Disk alert, the OK button
(“go”) would be red and the Cancel (“stop”) button would be green. Don’t do this.
Pointers

Most of the time, when the pointer is being used for selecting and pointing, it should
remain black—color might not be visible over potentially different colored backgrounds,
and wouldn’t give the user any extra information. However, when the user is drawing or
typing in color, the drawing or text-insertion pointer should appear in the color that is being
used. Except for multicolored paintbrush pointers, the pointer shouldn’t contain more than
one color at once—it’s hard for the eye to discriminate small areas of color.

V-18 Color

The Macintosh User Interface Guidelines

SOUND
The high-quality sound capabilities of the Macintosh let sound be integrated into the human

interface to give users additional information. This section refers to sound as a part of the
interface in standard applications, not to the way sound is used in an application that uses
the sound itself as data, such as a music composition application.
When

to

Use

Sound

i)

a

There are two general ways that sound can be used in the interface:

77)
7)
lar

a It can be integrated throughout the standard interface to help make the user aware of
the state of the computer or application.
= It can be used to alert the user when something happens unexpectedly, in the
background, or when the user is not looking at the screen.
In general, when you put an indicator on the screen to tell the user something—for
example, to tell the user that mail has come in, or to show a particular state—it’s also

appropriate to use a sound.
Getting

Attention

If the computer is doing something time-consuming, and the user may have turned away
from the screen, sound is a good way to let the user know that the process is finished, or it
needs attention.

(There should also be an indication on the screen, of course.)

Alerts
Common alerts can use sounds other than the SysBeep for their first stage or two before
bringing up an alert box. For example, when users try to paste when there’s nothing in the
Clipboard, or try to backspace past the top of a field, different sounds could alert them.

Modes
If your application has different states or modes, each one can have a particular sound
when the user enters or leaves. This can emphasize the current mode, and prevent
confusion.

Sound V-19

al

|
-_
@
er |
=
be)

O
ras)

Inside Macintosh

General

Guidelines

Although the use of sound in the Desktop Interface hasn’t been investigated thoroughly,
these are some general guidelines to keep in mind.

Don’t

Go

Overboard

Be thoughtful about where and how you use sound in an application. If you overuse
sound, it won’t add any meaning to the interface, and will probably be annoying.
Use

Redundancy

Sound should never be the only indication that something has happened; there should
always be a visible indication on the screen, too, especially when the user needs to know
what happened. The user may have all sound turned off, may have been ont of hearing

range of the computer, or may have a hearing impairment.
Natural

and

Unobtrusive

Most sounds can be quite subtle and still getting their meaning across. Loud, harsh sounds
can be offensive or intimidating. You should always use the sound yourself and test it on
users for a significant period of time (a week or two, not twenty minutes) before including
itin your application—if you turn it off after a day, chances are other people will, too. You
should also avoid using tunes or jingles—more than two or three notes of a tune may
become annoying or sound silly if heard very often.

Significant

Differences

Users can learn to recognize and discriminate between sounds, but different sounds should
be significantly different. Nonmusicians often can’t tell the difference between two similar
notes or chords, especially when the sounds are separated by a space of time.
User

Control

The user can change the volume of sounds, or turn sound off altogether, using the Control
Panel desk accessory. Never override this capability.
Resources

Always store sounds as resources, so users can change sounds and add additional sounds.

V-20 Sound

The Macintosh User Interface Guidelines

NEW KEYBOARD

KEYS

The standard keyboard for the Macintosh SE and Macintosh II includes a Control key and
an Escape key. The optional extended keyboard has in addition 6 dedicated function keys,

15 function keys that are user-definable, and 3 LED indicators for key lock conditions.

The Apple Extended Keyboard is shown in Figure 1.

print scroll
screen lock Pause
Ese

FI]

F2)F3]

undo

cut

F4)

| FS]

F6 | F7]

Fe

FO

JFIOJFIISFI2

“1172131415

[6

[7]

lt]

8]

ins.

op. oy-]e4

9

fro]

- | = pPelete | [helphomelpg

TAR

POTVIETRITIVYIUTITOPETriiriy

Cas

JAILS
Zi}

Shift

[DI
xXxi|C]

ES

FIG]

H]

VIB]

alt

Ctl. Hostion| ©

uv]
NIM]

Space

KYL]:
-]-

| "|
| 7/1]

del.

[>] end Ipgdn

Return

@ae

G | ction| Ctl

a

amd

==
@=

Ged = | / | *

ba| sl

7/8/9]-

ley Mag

1]

ot ee Bh 2

acs Peo

]6)]

4),

Shift

alt

up

2]

+

——

3 Jenter

0

Figure 1. The Apple Extended Keyboard

Control

and

Escape

Keys

The Control and Esc (Escape) keys should be used for their standard meanings; neither
should be used as an additional command-key modifier. Since not all keyboards may have
a Control or Esc key, neither should be depended upon.
The main use of the Control key is to generate control characters for terminal emulation
programs. (The Command key is used for this purpose on terminals lacking a Control
key.) A secondary use that also derives from past practice is calling user-defined functions,
or macros. The varying placement of the Control key on different keyboards means that it
should not be used for routine entry, as touch-typists may find its position inconvenient.
The Esc key has the general meaning
is specific:

“let me out of here”. In certain contexts its meaning

m The user can press Esc as a quick way to indicate Cancel in a dialog box.
m The user can press Esc to stop an operation in progress, such as printing.
this way is like pressing Command-period.)

nN

=.

if 2)

(SS).
ES

Caps Num Scroll
Lock Lock Lock

copy paste

“lTlyJel;*#[$]ae]*]&

Lock

FISIFIGUFI5

Reset

(Using Esc

New Keyboard Keys V-21

=

&
©
@

Inside Macintosh

= If an application absolutely requires a series of dialog boxes (a fresh look at program
design usually eliminates such sequences), the user should be able to use Esc to move
backward through the boxes.
Pressing Esc should never cause the user to back out of an operation that would require

extensive time or work to reenter, and it should never cause the user to lose valuable

information. When the user presses Esc during a lengthy operation, the application should
display a confirmation dialog box to be sure Esc wasn’t pressed accidentally.

Function

Keys

There are two types of function keys: dedicated and user-definable. The user-definable
keys—labeled F1 through F15—are not to be defined by an application. Fl through F4
represent Undo, Cut, Copy, and Paste, respectively, in any applications that use these
commands.
The six dedicated function keys are labeled Help, Del, Home, End, Page Up, and Page
Down. These keys are used as follows:
= Help: Pressing the Help key should produce help (it’s equivalent to pressing
Command-?). The sort of help available varies between applications; if a full,
contextual help system is not available, some sort of useful help screen should be
provided.
= Fwd Del: Pressing Fwd Del performs a forward delete: the character directly to the
right of the insertion point is removed, pulling everything to the right of the removed
character toward the insertion point. The effect is that the insertion point remains
stable while it “vacuums” everything ahead of it.
If Fwd Del is pressed when there is a current selection, it has the same effect as
pressing Delete (Backspace) or choosing Clear from the Edit menu.
= Home: Pressing the Home key is equivalent to moving the scroll boxes (elevators) all
the way to the top of the vertical scroll bar and to the left end of the horizontal scroll
bar.
u End: The flip-side of Home: it’s equivalent to moving the scroll boxes (elevators) all
the way to the bottom of the vertical scroll bar and to the right end of the horizontal
scroll bar.
u Page Up: Equivalent to clicking the mouse pointer in the upper gray region of the
vertical scroll bar.
s Page Down: Equivalent to clicking the mouse pointer in the lower gray region of the
vertical scroll bar.
Notice that the Home, End, Page Up, and Page Down keys have no effect on the insertion
point or on any selected material. These keys change the screen display only, for three
reasons:
u The analogy to scrolling means that the keys behave as users expect.
= Users can easily change the insertion point by clicking in the jumped-to window.

V-22 New Keyboard Keys

The Macintosh User Interface Guidelines
a Window-by-window jumping with a moving insertion point can be done by
Command-arrow key combinations, as described in Volume IV of Jnside Macintosh.
Because the keys are visual only, the Page Up and Page Down keys jump relative to the
visible window, not relative to the insertion point.

NEW

MENU

FEATURES

The Menu Manager now supports two new capabilities: hierarchical and pop-up menus.
addition, scrolling menus, introduced with the Macintosh Plus and Macintosh 512K
Enhanced, are made visible with a scrolling menu indicator.

In

nN
eS

if 2)

©

emt

=)
—

Hierarchical

©
=
$9
O
oe

Menus

Hierarchical menus are a logical extension of the current menu metaphor: another
dimension is added to a menu, so that a menu item can be the title of a submenu.

When the

user drags the pointer through a hierarchical menu item, a submenu appears after a brief
delay.
Hierarchical menu items have an indicator (a small black triangle pointing
indicate “‘more’’) at the edge of the menu, as illustrated in Figure 2.

Font
Size

Ls
ove

“Align

Left

és

“Single Space
1-1/2 Space
Space

Font
Size

EY

b>
>

seelsceppeccaredorsaacors

3€L

Align Middle
Align Right
Justify

Double

>
b

3M
36R
J

“Align

Left

Align Middle
Align Right
Justify

Bold

to the right, to

=

36 L

&#
Ri
#J|

3B

Fe

Underline
Outline
Shadom

“Single Space
1-1/2 Space
Double

Space

Figure 2. Main Menu Before and After Submenu Appears

New Menu Features V-23

Inside Macintosh
One main menu can contain both standard menu items and submenus; both levels can have

Command-key equivalents. (The submenu title can’t have a Command-key equivalent, of
course, because it’s not acommand. Key combinations aren’t used to pull down menus.)

Two delay values enable submenus to function smoothly, without jarring distractions to the
user: The submenu delay is the length of time before a submenu appears as the user
drags the pointer through a hierarchical menu item. It prevents flashing due to rapid
appearance—disappearance of submenus. The drag delay allows the user to drag
diagonally from the submenu title into the submenu, briefly crossing part of the main
menu, without the submenu disappearing (which would ordinarily happen when the pointer
was dragged into another main menu item). See Figure 3.

Font
Style

> |
\

Yflign Left

>|

he

Align Middle

\

es

Align Right

VSingle Space
1-1/2 Space

Double

Space

&#L

\4™

® point
IO

Y12

14

19

20
3&8

36

48

?2

Figure 3. Dragging Diagonally to a Submenu Item

Other aspects of submenus—menu blink for example—behave exactly the same way as in
standard menus.
The original Macintosh menus were designed so that the user could drag the mouse across
the menu bar and immediately see all of the choices currently available. Although
developers have found they need more menu space, and hierarchical menus were designed
to meet that need, it’s important that this original capability be maintained as much as
possible. To keep this essential simplicity and clarity, follow these guidelines:
= Hierarchical menus should be used only for lists of related items, such as fonts or font
sizes (in this case, the title of the submenu clearly tells what the submenu contains).

a Only one level of hierarchical menu should be used, although the capability for more is
provided. This one extra layer of menus potentially increases by an order of
magnitude the number of menu items that can be used; if you need more layers than
that, your application is probably more complex than most users can understand, and
you should rethink your design.

V-24 New Menu Features

The Macintosh User Interface Guidelines

Pop-Up

Menus

A pop-up menu is one that isn’t in the menu bar, but appears somewhere else on the
screen (usually in a dialog) when the user presses in a particular place, as shown in
Figure 4.

Modem

Baud rate:|

setup...

300

nN

M

=

i? 2)

@

ay

Bits per character:|

7?

—

~

—

ak

@

Stop

bits:|

Parity:|

1

b=)
QO
fae)

Even
[ Cancel |

Figure 4. Dialog Box With Pop-Up Menus

Pop-up menus are used for setting values or choosing from lists of related items. The
indication that there is a pop-up menu is a box with a one-pixel thick drop shadow, drawn
around the current value. When the user presses this box, the pop-up menu appears, with
the current value—checked and highlighted—under the pointer, as shown in Figure 5. If
the menu has a title, the title is highlighted while the menu is visible.

Baud

rate:

110
“300
600

:

Baud

rate:

1200
2400
4800

9600
19200

110
Rail
600

1200
2400
4800

9600 .
19200

Figure 5. Dragging Through a Pop-up Menu

New Menu Features V-25

Inside Macintosh

The pop-up menu acts like other menus: the user can move around in it and choose another
item, which then appears in the box, or can move outside it to leave the current value

active. If a pop-up menu reaches the top or bottom of the screen, it scrolls like other

menus.

When designing an application that uses pop-up menus, keep in mind the following points:
= Pop-up menus should only be used for lists of values or related items (much like
hierarchical menus); they should not be used for commands.
= You must draw the shadowed box indicating that there is a pop-up menu, so the user
knows that it’s there—pop-up menus should never be invisible.
mw While the menu is showing, its title should be inverted. If several pop-up menus are
near each other, this lessens ambiguity about which one is being used.
= The current value should always appear under the pointer when the menu pops up, so
that simply clicking the box doesn’t change the item.
m Hierarchical pop-up menus should not be used.
Always consider whether a pop-up menu is the simplest thing to use in each case. For
example, rather than have a pop-up menu choose all paper sizes, icons could represent
commonly used sizes, with a pop-up menu for non-standard sizes.

Scrolling

Menu

Indicator

Scrolling menus were introduced with the Macintosh Plus and Macintosh 512K Enhanced,
but this feature was invisible. When there were more than eighteen items in a menu (which
can happen with fonts on a hard disk), the menu scrolled to show more items as the user
moved the pointer past the last item; but users didn’t know whether there were any more
items in a menu unless they happened to drag past the bottom of it. The scrolling menu
feature is now made visible by an indicator (similar to the hierarchical menu indicator),

which appears at the bottom of the menu when there are more items, as shown in Figure 6.

New

York

Palatino

Palatino

Symbol

Symbol

Times

Times

Venice

ho

WwW

Figure 6. Scrolling Menus: Indicator at Bottom

The indicator area itself doesn’t highlight, but the menu scrolls as the user drags over it.
When the last item is shown, the indicator disappears.

V-26 New Menu Features

The Macintosh User Interface Guidelines
As soon as the menu starts scrolling, another indicator appears at the top of the menu to
show that some items are now hidden in that direction (see Figure 7).

Font |

Athens
Avant Garde
Bookman
Chicago

a
Bookman
Chicago
Courier

Courier

N

Geneva

(mm
D
@
=

Figure 7. Scrolling Menus: Indicator at Top

—

i)
a9)

If the user drags back up to the top, the menu scrolls back down in the same manner.

If the

user releases the mouse button or selects another menu, and then selects the menu again, it

appears in its original position, with the hidden items and the indicator at the bottom.

USER

TESTING

The primary test of the user interface is its success with users: can people understand what
to do and can they accomplish the task at hand easily and efficiently? The best way to

answer these questions is to put them to the users.
Build

User

Testing

Into

the

Design

Process

Users should be involved early in the design process so that changes in the basic concept of
the product can still be made, if necessary. Although there’s a natural tendency to wait for
a good working prototype before showing the product to anyone, this is too late for the
user to have a significant impact on design. In the absence of working code, you can show

test subjects alternate designs on paper or storyboards. There are lots of ways that early

concepts can be tested on potential users of a product. Then, as the design progresses, the
testing can become more refined and can focus on screen designs and specific features of
the interface.

Test

Subjects

There is no such thing as a “typical user”. You should, however, be able to identify some
people who are familiar with the task your application supports but are unfamiliar with the
specific technology you are using. These “naive experts” make good subjects because they

don’t have to be taught what the application is for, they are probably already motivated to
use it, and they know what is required to accomplish the task.

User Testing V-27

at

=
wr)
@

Inside Macintosh

You don’t need to test a lot of people. The best procedure for formative testing (testing
during the design process) is to collect data from a few subjects, analyze the results and
apply them as appropriate. Then, identify new questions that arise and questions that still
need answers, and begin all over again—it is an iterative process.
Procedures
Planning and carrying out a true experimental test takes time and expert training. But many
of the questions you may have about your design do not require such a rigid approach.
Furthermore, the computer and application already provide a controlled setting from which
objective data can be gathered quite reliably. The major requirements are
= to make objective observations
m to record the data during the user-product interaction
Objective observations include measures of time, frequencies, error rates, and so forth.

The simple and direct recording of what the person does and says while working is also an
objective observation, however, and is often very useful to designers. Test subjects can be
encouraged to talk as they work, telling what they are doing, trying to do, expect to
happen, etc. This record of a person’s thinking aloud is called a protocol by researchers in
the fields of cognition and problem-solving, and is a major source of their data.
The process of testing described here involves the application designer and the test subjects
in a regular cycle of feedback and revision. Although the test procedures themselves may
be informal, user-testing of the concepts and features of the interface becomes a regular,
integral part of the design process.

BIBLIOGRAPHY
The following books are recommended reading for those interested in the effective use of
color in the user interface.
Favre, J., and A. November. Color and Communication. Zurich, Switzerland: ABC
Edition, 1979.
Greenberg, D., A. Marcus, A. Schmidt, and V. Gorter. The Computer Image. Menlo

Park, California: Addison-Wesley Publishing Co., 1982.
et J. The Elements of Color, edited by F. Birren.
o., 1970.

New York: Van Nostrand Reinhold

Schneiderman, B. Designing the User Interface: Strategies for Effective Human-Computer
Interaction. Reading, Massachusetts: Addison-Wesley Publishing Co., 1987.

V-28 Bibliography

3

THE

RESOURCE

MANAGER

About This Chapter
The Resource Manager
Routine
Resources
Resources in ROM
Resources in the System File
Packages
Drivers and Desk Accessories
Patches
General Resources
Summary of the Resource Manager

oe)

~
©

<2)

=)
=

bese |

°
©

$9
=
=
ge
©
beer

V-29

|

Inside Macintosh

ABOUT THIS CHAPTER
This chapter describes new resource types, changes to the Resource Manager, and the
contents of the Macintosh SE and Macintosh II ROMs and of System file version 4.1.

THE RESOURCE

MANAGER

As described in chapter 3 of Volume IV, in order to use the ROM resources in your calls to
the Resource Manager, the ROM map must be inserted in front of the map for the System

Resource File prior to making the call. Unless the ROM map is inserted, the GetResource
call will not search the ROM resources. Sometimes, however, you’ll first want to try to get
the resource from any open resource files, and then if it’s not found, to get it from ROM.
A new routine, RGetResource, lets you do this easily. It searches the chain of open

resource files (including the System Resource File) for the given resource; if it’s not there,
it looks in ROM.
Routine
FUNCTION

RGetResource

(theType:

ResType;

theID:

INTEGER)

:

Handle;

RGetResource is identical in function to GetResource except that it looks through the chain

of open resource files for the specified resource, and if it doesn’t find it there, it looks in
the ROM resources.

Note: With System file version 4.1 or later, RGetResource will also work on the
Macintosh Plus.

RESOURCES
The following standard resource types have been defined (System file 4.1 or later). Alluppercase resource types are listed first. Types new with this volume are in boldface.
Resource

Meaning

‘ALRT'

Alert template

'CACH'

RAM cache code

type

"ADBS'
‘BNDL'
'CDEF'

V-30 Resources

Apple Desktop Bus service routine
Bundle

Control definition function

The Resource Manager
Resource

Meaning

‘CNTL'
‘CODE'
‘CURS'
‘DITL’
‘DLOG'
‘DRVR'
'DSAT'
"FKEY'
"FMTR'
"FOND'
"FONT
"FREF'
"FRSV'
‘FWID'
‘ICN#'
‘ICON’
‘INIT'
INTL!
INT#!'

Control template
Application code segment
Cursor

'KCAP'
‘KCHR'
‘KMAP'
‘KSWP'
"LDEF'
'MBAR'

Physical layout of keyboard (used by Key Caps desk accessory)

type

"‘MBDF'
"MDEF'
‘MENU!
‘MMAP'
'NBPC'
"NFENT'
'PACK'
‘PAT'
‘PAT#'
‘PDEF'
‘PICT’
‘PREC’
‘PRER'
‘PRES'
‘PTCH'
"RDEV'
‘ROvr'
"ROv#'
‘SERD'
‘'SICN'
‘STR '
'STR#'
"WDEF'

Item list in a dialog or alert
Dialog template
Desk accessory or other device driver

System startup alert table
Command-Shift-number routine
3 1/2-inch disk formatting code
Font family record
Font
File reference

IDs of fonts reserved for system use

Font widths
Icon list
Icon
Initialization resource

oe

x

International resource
List of integers owned by Find File

o
72)
=)
&
ef
rr)
a>)

ASCII mapping (software)

Keyboard mapping (hardware)
Keyboard script table
List definition procedure
Menu bar
Default menu definition procedure
Menu definition procedure
Menu
Mouse tracking code
Appletalk bundle
128K ROM font
Package
Pattern (The space is required.)
Pattern list

>
=)
&
ge
@

ber

Printing code

Picture
Print record
Device type for Chooser
Device type for Chooser
ROM patch code

Device type for Chooser
Code for overriding ROM resources
List of ROM resources to override
RAM Serial Driver

Script symbol
String (The space is required.)
String list
Window definition function

Resources V-31

|

Inside Macintosh

Resource

Meaning

"WIND'
‘'actb'
‘atpl'
‘bmap'
‘boot'
‘ectb'
‘cicn'
‘clst'
‘clut'
‘ersr'
‘ctab'
‘dctb'
‘fetb'
‘finf'
‘gama’
‘ictb'
‘insc'
‘1t10'
‘itll’
"it12'
‘itlb'
‘itle'
‘Imem'
‘meky'
1
metb'

Window template
Alert color table

'

AppleTalk configuration code

type

1

'

Internal AppleTalk resource
Bit maps used by the Control Panel
Copy of boot blocks
Control color table
Color Macintosh icon

Cached icon lists used by Chooser and Control Panel

Color look-up table
Color cursor

Used by the Control Panel

Dialog color table

Font color table
Font information

Color correction table
Color table dialog item
Installer script

Date and time formats
Names of days and months
International Utilities Package sort hooks

International Utilities Package script bundles

International configuration for Script Manager
Low memory globals
Mouse tracking

Menu color information table
Internal memory requirements for MakeITable

mitq'
mppec'

Rectangle positions
Color palette

nrct'

‘pitt’

ppat’

Pixel pattern
Sound (The space is required.)
Synthesizer
Window color table

snd'

snth'

‘wetb'

RESOURCES

IN ROM

Certain system resources were placed in the 128K ROM for quick access. The Macintosh
SE and Macintosh II ROMs include additional resources in ROM; they’re outlined below.

The following system resources are stored in the Macintosh SE ROM (the resource IDs are

‘CDEF'
‘CDEF'
‘CURS'
‘CURS'

ID

Description

©

Type

Default button definition procedure

Ne
=

in hexadecimal):

IBeamCursor

Default scroll bar definition procedure

CrossCursor

V-32 Resources in ROM

The Resource Manager

Type

ID

Description

'CURS'
‘CURS'

3
4

PlusCursor
WatchCursor

‘DRVR'
'DRVR'
‘DRVR'
"FONT'
‘FONT’
‘FONT’
'FONT'

9
A
28
0
C
189
18C

AppleTalk driver (.MPP)
AppleTalk driver (.ATP)
AppleTalk driver (.XPP)
Name of system font
System font (Chicago 12)
Geneva 9 font
Geneva 12 font

‘DRVR'
'DRVR'

"FONT'

"KMAP'
‘MBDF
"MDEF'

3
4

209

0
0
0

Sound Driver (.Sound)
Disk Driver (.Sony)

Monaco 9 font

Keyboard map for keyboard driver
Default menu bar procedure

Default menu definition procedure

'PACK'

4

Floating-Point Arithmetic Package

‘PACK’

7

Binary-Decimal Conversion Package

'PACK'
'SERD'
"WDEF'

"WDEF'

5

0
0

1

Transcendental Functions Package

Serial Driver
Default window definition function (document window)

Ge
=

Default window definition function (rounded window)

The following system resources are stored in the Macintosh II ROM (the resource IDs are
in hexadecimal):

Type

ID

Description

'CDEF'
'CDEF'

0
1

Default button definition procedure
Default scroll bar definition procedure

®
S

5
2
&

=

a)

‘CURS'
‘'CURS'
'CURS'
'CURS'
'DRVR'

1
2
|
4
3

IBeamCursor
CrossCursor
PlusCursor
WatchCursor
Sound Driver (.Sound)

'DRVR'
‘DRVR'
‘DRVR'
‘FONT'

9
A
28
0

AppleTalk driver (.MPP)
AppleTalk driver (.ATP)
AppleTalk driver (.XPP)
Name of system font

'DRVR'

'FONT'
'FONT'

4

Disk Driver

(.Sony)

&
180

System font (Chicago 12)
Name of Geneva font

‘FONT'
'FONT'
‘FONT’
‘KCHR'

18C
200
209
0

Geneva 12 font
Name of Monaco font
Monaco 9 font
ASCII mapping (software)

"MBDF'
"MDEF'
"NENT'
"NFNT'
"NFNT'
'PACK'

0
0
2
3
22
4

Default menu bar procedure
Default menu definition procedure
Chicago 12 font (4-bit)
Chicago 12 font (8-bit)
Geneva 9 font (4-bit)
Floating-Point Arithmetic Package

‘FONT’

"KMAP'

189

0

=

Geneva 9 font

Keyboard mapping (hardware)

Resources in ROM

V-33

Inside Macintosh

Type

ID

Description

5

Transcendental Functions Package

‘SERD'
"WDEF'
"WDEF'

0
0
1

Serial Driver
Default window definition function (document window)
Default window definition function (rounded window)

‘clut'
‘clut’
‘clut’

2
4
8

‘gama’

0

‘PACK’

‘PACK’

‘cetb'
‘clut’

‘clut’

‘mitq'
‘snd'

‘wetb'

7

0
1

7F
0
1
0

RESOURCES

Binary-Decimal Conversion Package

Control color table
Color look-up table

Color look-up table
Color look-up table
Color look-up table

Color look-up table

Color correction table

Internal memory requirements for MakelTable
Brass horn
Window color table

IN THE SYSTEM

FILE

The System Resource File contains standard resources that are shared by all applications,
and are used by the Macintosh Toolbox and Operating System as well. This file can be
modified by the user with the Installer and Font/DA Mover programs.
Warning: Your program should not directly add resources to, or delete resources
from, the System Resource File.
Applications should not alter resources in the System file, except for resources owned by
the application, as discussed in the Resource Manager chapter of Volume I. With
applications that need to install drivers, fonts, or desk accessories, developers should ship
an Apple-released copy of the file along with either the Installer and a script (for drivers) or
the Font/DA Mover (for fonts and desk accessories).

Note: Some of the resources in the System Resource File are also contained in the
128K and 256K ROMs; they’re duplicated in the System Resource File for
compatibility with machines in which these resources are not in ROM.
The rest of this section presents an overview of the System Resource File’s resources,
grouped by function.

V-34 Resources in the System File

The Resource Manager

Packages
The System Resource File contains the standard Macintosh packages and the resources they
use (or own):
m the List Manager Package ('PACK' resource 0), and the standard list definition
procedure ('LDEF' resource 0)
a the Disk Initialization Package (‘PACK' resource 2), and code (resource type

‘FMTR’) used in formatting disks

m the Standard File Package (‘PACK' resource 3), and resources used to create its alerts
and dialogs (resource types 'ALRT’, 'DITL', and 'DLOG’)
w the Floating-Point Arithmetic Package (‘PACK' resource 4)
a the Transcendental Functions Package (‘PACK' resource 5)
w the International Utilities Package (‘PACK'’ resource 6)

a the Binary-Decimal Conversion Package ('PACK' resource 7)
m the Color Picker Package
Drivers

and

Desk

toe

('PACK' resource 12)

~
oS2)
Sc
=

Accessories

°
i)

er

Certain device drivers (including desk accessories) and the resources they use or own are

found in the System Resource File; these resources include

w the PRINT driver (‘DRVR' resource 2) that communicates between the Print Manager

and the printer.

a the .MPP, .ATP, and .XPP drivers (‘DRVR' resources 9, 10, and 28 respectively)

used by version 42 of AppleTalk.

u the Control Panel desk accessory (‘DRVR' resource 18) and the resources used in
displaying its various options. The Control Panel also uses a resource of type 'clst' to
list the cached icons of the devices in order to improve performance.
m the Chooser desk accessory, which uses the same class of resources as the Control
Panel, including its own 'clst'.

Resources in the System File V-35

=

he

=

a

ge

©
=

|

Inside Macintosh

Patches
For each ROM (64K, 128K, 256K) there are two patch resources of type 'PTCH' that
provide updates for ROM routines. At startup, the machine’s ROM is checked and the

appropriate 'PTCH' resources are installed and locked in the system heap. The 'PTCH'
resources are:
All ROMS
64K ROM
128K ROM
256K ROM (Macintosh SE)
256K ROM (Macintosh II)
General

'PTCH'
‘PTCH’
‘PICH
'PTCH'
'PTCH'

0
105
1i7
630
376

Resources

Other resources contained in the System Resource File include
u Standard definition procedures for creating windows, menus, controls, and lists.

= System fonts and font families (resource types 'FONT' and 'FOND’).
m System icons.
u The screen utility resources 'FKEY' 3 and 4, which execute a MacPaint screen
snapshot when Command-Shift-3 is pressed, and print a screen snapshot when
Command-Shift-4 is pressed, respectively. Note that Command-Shift-4 only works
with the ImageWriter®; it is useful for a quick print, but should not be an application’s
print strategy.
m Mouse tracking resources: 'mcky' 0 to 4, which provide parameters for various mouse
tracking setups; 'MMAP' 0, which provides mouse tracking code for use when it is
not in ROM.
u Key mapping resources, which implement keyboard mapping in conjunction with the
Apple Desktop Bus: 'ADBS' 2, 'KMAP'

each language.

1 and 2, and 'KCHR', which has IDs for

Note that 'INIT' resources 1 and 2, which used to handle key

translation, now point to the 'ADBS'//KCHR' system instead.

= Color resources: ‘wetb' 0, 'cctb' 0, and 'mitq' 0, which implement color tables, and
‘cicn' Q, the color Macintosh icon. See the Color Quickdraw and Color Manager
chapters for more information.

V-36 Resources in the System File

The Resource Manager

SUMMARY

OF

THE RESOURCE

MANAGER

Routine
FUNCTION

RGetResource

(theType:

ResType;

theID:

INTEGER)

:

Handle;

os)

x

ro)
7
—)
i

be

2)
ras)

<
o&

=|

Q
ve

i)
ar

Summary of the Resource Manager V-37

|

4

COLOR

QUICKDRAW

41
42
42
43
44
46
47
47
48
49
52
52
55
57

About This Chapter
Color Representation
RGB Space
Other Color Spaces
Using Color on the Macintosh II
From Color to Pixel
About Color QuickDraw
Drawing Color in a GrafPort
Drawing Color in a CGrafPort
The Color Graphics Port
Pixel Images
_~ Pixel Maps
_— Pixel Patterns
Relative Patterns

59

Arithmetic Drawing Modes

57

61

Transfer Modes

Replace With Transparency

61
62
64
65
67
67
68
69
70
70
72
73
75
76
76
77
78

The Hilite Mode
The Color Cursor
Color Icons
Using Color QuickDraw
Color QuickDraw Routines
Operations on CGrafPorts
Setting the Foreground and Background Colors
Color Drawing Operations
Creating Pixel Maps
Operations on Pixel Maps
Operations on Pixel Patterns
Creating a PixPat
Operations on Color Cursors
Operations on Color Icons
Operations on CGrafPort Fields
Operations on Color Tables
Color QuickDraw Resource Formats

79
80
81
81
83.
83.
84
84
84
85
85

‘ppat' (Pixel Pattern)
‘cicn' (Color Icon)
‘clut' (Color Table)
Using Text with QuickDraw
Text Mask Mode
Drawing with Multibit Fonts
Fractional Character Positioning
Color Picture Format
Differences between Version 1 and Version 2 Pictures
Drawing with Version 2 Pictures in Old GrafPorts
Picture Representation

78

aa

2)

S
i)

=

©

==
~

Ss
oS
=

‘ersr' (Color Cursor)

V-39

Inside Macintosh

86
86
87
87

89
90

_— Picture Parsing
Picture Record Structure
Picture Spooling
Spooling a Picture From Disk

Spooling a Picture to a File
Drawing to an Offscreen Pixel Map

91

New GrafProcs Record

92
93
93
94

Picture Format
Picture Definition: Version 1
Picture Definition: Version 2
PicComments

92

95
96
96
103.
106

V-40

Picture Compatibility

Sample PICT File
Color Picture Routines
PICT Opcodes
The New Opcodes: Expanded Format
Summary of Color QuickDraw

Color QuickDraw

ABOUT THIS CHAPTER
A new version of QuickDraw has been created to take advantage of the capabilities of the
Macintosh II. Color QuickDraw is able to use a very large number of colors and can take
advantage of systems that have one or more screens of any size. This chapter describes the
use of color with one screen. The following chapter, “Graphics Devices”, explains what
your program should do to support more than one screen.
The features of Color QuickDraw implemented for the Macintosh Plus, the Macintosh SE,
and the Macintosh II are

= Text drawing modes are enhanced, and now include a text mask mode, drawing with
multibit fonts, and fractional character positioning.
a The QuickDraw picture format (PICT) has been enhanced, and includes a number of
new opcodes.
Some of the features of Color QuickDraw for the Macintosh II are
a All drawing operations supported by old QuickDraw can now be performed in color.

= Color QuickDraw supports the use of as many as 248 colors. In addition, Color

QuickDraw’s color model is hardware-independent, allowing programs to operate
independently of the display device.

= Color QuickDraw includes several new data types: color tables, color icons, color
patterns, and color cursors. These types can be stored as resources that are easily used
by your program.
u A new set of transfer modes has been added. These modes allow colors to be blended
with or added to the colors that are already on the screen.
= Most Toolbox Managers have been enhanced to use color. Thus you can now add
color to windows, menus, controls, dialog boxes, and TextEdit text. Refer to the
appropriate chapters for more information.
m The QuickDraw picture format (PICT)
images can be recorded in pictures.

has been extended so that Color QuickDraw

This chapter introduces the basic concepts, terminology, and data structures underlying the
Macintosh II approach to graphics. The material presented here assumes familiarity with the
QuickDraw concepts described in Volume I, such as bit maps, graphics ports, patterns,
cursors, and transfer modes. You should also be familiar with the use of resources, as
presented in the Resource Manager chapter.

About This Chapter V-41

ao

OQ

2.
S

=

©

=O°

="

=)

= |

fe

<a
<=

Inside Macintosh

COLOR

REPRESENTATION

The following

sections introduce the basic concepts and terminology used in Color

QuickDraw. It’s important to keep in mind that Color QuickDraw is designed to be device-

independent. The range of colors available is the result of the system configuration: the
screen resolution, the graphics hardware used to produce color, and the software used to
select and store color values. Color QuickDraw provides a consistent way of dealing with
color, regardless of the characteristics of the video card or display device.

The original QuickDraw represents each dot on the screen (known as a pixel) as a single
bit in memory. Each bit can have two values, zero or one. This allows two colors, usually
black and white, to be displayed.

To produce color graphics, more than one bit of memory per pixel displayed is needed. If
two bits per pixel are available, four colors can be displayed. Four bits per pixel provides a
display of 16 colors, and eight bits per pixel provides a display of 256 colors. The bits in a
pixel, taken together, form a number known as the pixel value.

The number of possible colors is related to the amount of memory used to store each pixel.
Since displayed pixels are stored in RAM on the video card, rather than in the RAM in the
Macintosh, the quality of the graphics depends on capabilities of the video card used.

RGB

Space

Color QuickDraw represents colors in RGB space. Each color has a red, a green, and a
blue component, hence the name RGB. These components may be visualized as being
mapped into a color cube, as shown in Figure 1. (See frontispiece for a color representation
of this art.)

V-42 Color Representation

Color QuickDraw
65535,65535,65535 = white
a

eae
iate SS

SE

\

SS

\ f

0,0,65535 = blue

65535,0,0 = red

Figure 1. RGB Color Cube

The data structures used within Color Quickdraw express each RGB component as an
unsigned integer value. Each R, G, and B can have a value from $0000 to $FFFF (or 0 to
65,535). RGB color is additive; that is, as the value of a component is increased, the

Pa

amount of that component in the total color increases. An RGB color is black if all three

o

these two extremes can be combined to represent all the possible colors. For instance, pixel
values that lie along the diagonal between black and white, and for which R = G = B, are
all perceived as shades of gray.

©
=

components are set to 0, or white if each component is set to 65,535. Pixel values between

=

2)

~~
—

dd

“=

Other

Color

=)Aa

Spaces

<

In addition to RGB, several other color models are commonly used to represent colors.

These other models include HSV (hue, saturation, value), HLS (hue, lightness,

saturation), and CMY (cyan, magenta, yellow). If you wish to work in a different color
space in your program, you can use the conversion routines provided in the Color Picker
Package to convert colors to their RGB equivalents before passing them to Color
QuickDraw. Please refer to the Color Picker Package chapter for more details.

Color Representation V-43

Inside Macintosh

USING

COLOR

ON THE MACINTOSH

II

Before you read about the details of how to use Color QuickDraw, it’s useful to understand
the various components of the color system and how they interact with each other. This
section, through a series of rules and examples, attempts to illustrate these interactions.
Rule 1: The user selects the depth of the screen using the Control Panel.
This rule is mentioned first to convey the fundamental need for device independence. Your
application shouldn’t change the depth of the screen, because it must avoid conflicts with
desk accessories or other applications that are using the screen at the same time. Let the
user decide how many colors should be displayed.
Rule 2: Work with colors in RGB space, not with the colors on the screen.
Whenever possible, your application should assume that it’s drawing to a screen that has
248 colors. Let Color QuickDraw determine what colors to actually display on the screen.
This lets your program work better when drawing to devices that support more colors.
The easiest way to follow this rule is for a program to call the Color Picker Package to
select colors. The Color Picker returns an RGB value, which can then be used as the

current color. When Color QuickDraw draws using that color, it selects the color that best
matches the specified RGB.
Rule 3: To ensure good color matching, and to avoid conflict with other applications and
desk accessories, use the Palette Manager.
If your program requires a very specific set of colors not found in the default selection of
colors, for instance 128 levels of gray, then you should use the Palette Manager. The
Palette Manager lets you specify the set of colors that is to be used by a particular window.
When that window is brought to the front, its set of colors is switched in (with a minimal
amount of impact on the rest of the screen).

You should also use the Palette Manager if your application needs to animate colors (that is
to change the colors of pixels that are already displayed).
The Palette Manager is a powerful tool because it makes sure that your application gets the
best selection of colors across multiple screen devices and multiple screen depths. You
don’t have to worry about interactions with desk accessories or other applications. Please
refer to the chapter on the Palette Manager for more information on using the Palette
Manager routines.

V-44 Using Color on the Macintosh II

?

Color QuickDraw

Rule 4: Be aware that systems may have multiple video devices.
Since the Macintosh II is able to support multiple screen devices, make sure your
application takes into account the variable-sized desktop. For instance, a document may
have been dragged to an alternate screen on one system, and then copied and used on
another system. You should leave the document positioned where it is if it lies within the

desktop, but move it to the main screen if it doesn’t. Please refer to the Graphics Devices

chapter for more details.

Figure 2 helps to illustrate the relationships between the various parts of the color system.
f-

Application

Control Panel

L

t

Palette

Color

T

T

Manager

Picker

Col

.
J

\

a

\

~

=| Video
|_| Video
Driver [| Card

a

Manager

=
Color QuickDraw

7

J

pissy

Video
RAM

a
Je

©Q

Figure 2. The Macintosh II Color System

=
S=

©
=OQ

~~

=)
=

S=

Using Color on the Macintosh II V-45

Inside Macintosh

From

Color

to Pixel

To help illustrate the interconnections of the color system, let’s examine the steps from the
specification of a color to the display of that color on the screen. This is an oversimplified
explanation that you should use for conceptual understanding only.
First, you specify the color that you want to display. Color QuickDraw stores the RGB
components so that it knows the exact color that you specified. Let’s assume that the screen
is set to eight bits per pixel. This means that each pixel is able to have 28, or 256, different
values. Associated with the screen is a structure called a color table, which is a list of all

the colors that the screen is currently able to display. So in this case the color table has 256
RGB values in it, one for each possible pixel value. The first entry in the color table
specifies the color of all pixels that have value 0, the second entry specifies the color of

pixels that have value 1, and so on. Thus the color’s position in the table determines the

pixel value that produces that color.

When you use Color QuickDraw to draw something, it retrieves the stored RGB, and asks

the Color Manager to return the pixel value that best represents that color. The Color
Manager effectively searches through the color table for the RGB that most closely matches
your color. The position in the table of the best match determines the pixel value to be
placed on the screen. Color QuickDraw then places that pixel value on the screen.

But how does this pixel cause the assigned color to be displayed? Color QuickDraw has
placed this pixel into the RAM on the video card. While your Macintosh II is turned on, the
video card is continuously redisplaying every pixel that is stored in its RAM (very, very
quickly). Internal to the video card is another color table, the Color Look-Up Table
(CLUT). It is organized exactly like the first one, but is used the other way around. The
video card takes the pixel value and uses it to determine what RGB value that pixel
represents. It then uses that RGB to send off three signals (red, green, and blue) to the
video monitor, indicating exactly what color the current pixel should be.
Some video cards allow you to change the set of colors displayed at a given time. Although
this is normally done transparently through the Palette Manager, it actually happens when
both the screen’s color table and the one that is internal to the video card are changed to
reflect the new set of colors.
A very slight variation of this is used to support the monochrome mode that you can set
from the control panel. When you set monochrome mode, the screen’s color table doesn’t
change: from the application’s point of view, the same set of colors is still available.
Instead, when the video card is told to use monochrome mode, it replaces each entry in the
video card’s internal color table with a level of gray (R=G=B) that matches the luminance
of the color it is replacing. Because of this, the switch between color and monochrome
modes has no effect on a running program.

V-46 Using Color on The Macintosh I]

Color QuickDraw

ABOUT

COLOR

QUICKDRAW

The most fundamental difference between the original QuickDraw and Color QuickDraw is
the environment in which drawing takes place. In the original QuickDraw, all drawing is
performed in a grafPort, the structure that defines the coordinate system, drawing pattern,
background pattern, pen size and location, character font and style, and bit map in which
drawing takes place. In Color QuickDraw, drawing takes place in a color grafPort
(cGrafPort) instead. As described in later sections, most of the fields in a cGrafPort are the

same as fields in a grafPort; however, a few fields have been changed to hold color
information.

When you’re using a grafPort in your application, you can specify up to eight colors.
When drawing to a color screen or printing, these colors will actually be displayed. When
drawing to an offscreen bitmap, the colors will be lost (since an offscreen bitmap only has
one bit for each pixel).
When you’re using a cGrafPort, however, you can specify up to 248 colors. The number
of colors that are displayed depends on the setting of the screen, the capability of the
printer, or the depth of the offscreen bitmap. There is more information about offscreen
bitmaps in the “Drawing to Offscreen Devices” section of the next chapter.
Color grafPorts are used by the system in the same way as grafPorts. They are the same
size as grafPorts, and they are the structures upon which a program builds color windows.
As with a grafPort, you set thePort to be a cGrafPort using the SetPort command.
You can use all old drawing commands when drawing into a cGrafPort, and you can use
all new drawing commands when drawing into a grafPort. However, since new drawing
commands that are used in a grafPort don’t take advantage of any of the features of Color
QuickDraw, it’s not recommended.

eS
2)

=
=;

bee

Drawing

|

©

Color in a GrafPort

O

=,

an

Although the QuickDraw graphics routines were designed mainly for monochrome
drawing, they also included some rudimentary color capabilities. A pair of fields in the
grafPort record, fgColor and bkColor, allow a foreground and background color to be
specified. The color values used in these fields are based on a planar model: each bit
position corresponds to a different color plane, and the value of each bit indicates whether
a particular color plane should be activated. (The term color plane refers to a logical plane,
rather than a physical plane.) The individual color planes combine to produce the full-color
image.
The standard QuickDraw color values consist of one bit for normal monochrome drawing
(black on white), one bit for inverted monochrome (white on black), three bits for the

additive primary colors (red, green, blue) used in video display, and four bits for the
subtractive primary colors (cyan, magenta, yellow, black) used in hardcopy printing. The
original QuickDraw interface includes a set of predefined constants for the standard colors:

About Color QuickDraw V-47

o
=

=

Inside Macintosh
CONST
blackColor
whiteColor
redColor
greenColor

=
=

33;
30;

=

205;
341;

=

blueColor
=
cyanColor
=
magentaColor

yellowColor

409;
273;
= 137;

=

69;

These are the only colors available in the original QuickDraw. All programs that draw into
grafPorts are limited to these eight colors. When these colors are drawn to the screen on the
Macintosh II, Color QuickDraw automatically draws them in color, if the screen is set to a

color mode.

Drawing

Color in a CGrafPort

Color QuickDraw represents color using the RGBColor record type, which specifies the
red, blue, and green components of the color. Three 16-bit unsigned integers give the
intensity values for the three additive primary colors:
TYPE

RGBColor

=

RECORD
red:
green:

INTEGER;
INTEGER;

{red component }
{green component }

blue:

INTEGER

{blue

component }

END;

A color of this form is referred to as an RGB value and is the form in which an
application specifies the colors it needs. The translation from the RGB value to the pixel
value is performed at the time the color is drawn. At times the pixel value is stored in the
fgColor or bkColor fields. Refer to the Graphics Devices chapter for more details.
When drawing is actually performed, QuickDraw calls the Color Manager to supply the
color that most closely matches the requested color for the current device. As described in
the Color Manager chapter, you can replace the method used for color matching if
necessary. Normally pixel values are handled entirely by Color QuickDraw and the Color
Manager; applications only refer to colors as RGB values.
A set of colors is grouped into a structure called a color table:
TYPE
CTabHandle
CTabPtr
ColorTable

=
=
=

“*CTabPtr;
“ColorTable;
RECORD
ctSeed:
LONGINT;

ctFlags:

V-48 About Color QuickDraw

INTEGER;

{unique

identifier

from

table}

{contains flags describing the }
{ specArray;
clear for a pixMap}

Color QuickDraw
ctSize:

INTEGER;

{number of entries
{ in ctTable}
cSpecArray

ctTable:

-1

}

END;

The fields of a color table are fully described in the Color Manager chapter. The ctFlags
field contains flags that differentiate between a device color table and an image color table.
The ctTable field is composed of a cSpecArray, which contains an array of ColorSpec
entries. Notice that each entry in the color table is a ColorSpec, not simply an RGBColor.
The type ColorSpec is composed of a value field and an RGB value, as shown below.
TYPE

cSpecArray

ColorSpec

=

: ARRAY
RECORD

[0..0]

value:

rgb:
END;

of

ColorSpec;

INTEGER;

{pixel

RGBColor

{RGB

value}

value}

Color tables are used to represent the set of colors that a device is capable of displaying,
and they are used to describe the desired colors in an image. If the color table describes an
image’s colors, then a ColorSpec determines the desired RGB for the pixel value stored in
the value field. This is the most common usage, and most of the routines described in this
chapter work with a ColorSpec in this manner.
If the color table describes a device’s colors, then the value field in a ColorSpec is reserved

for use by the Color Manager. In most cases your application won’t change the device
color table. If you want to know more about the device color table, refer to the Color

Manager chapter for more details.

b

o

THE COLOR

GRAPHICS

PORT

As described above, programs designed to take advantage of the more powerful new color
facilities available on the Macintosh II must use a new form of graphics port, the color
graphics port (type cGrafPort). Color grafPorts will generally be created indirectly, as a
result of opening a color window with the new routines NewCWindow,
GetNewCWindow, and NewCDialog.
In addition, the old routines GetNewWindow, GetNewDialog, Alert, StopAlert, NoteAlert,

and CautionAlert will open a color grafPort if certain resources (types 'wetb’, 'dctb', or
‘actb') are present. Refer to the chapters on the Window and Dialog Managers for more
details.

The new cGrafPort structure is the same size as the old-style grafPort and most of its fields
are unchanged. The old portBits field, which formerly held a complete 14-byte BitMap
record embedded within the grafPort, has been replaced by a 4-byte PixMapHandle
(portPixMap), freeing 10 bytes for other uses. (In particular, the new portVersion field, in
the position previously occupied by the bit map’s rowBytes field, always has its two high

The Color Graphics Port V-49

~
=
6S
=
Peey |
=

Inside Macintosh

bits set; these bits are used to distinguish cGrafPorts from grafPorts, in which the two high

bits of rowBytes are always clear. See Figure 3.) Similarly, the old bkPat, pnPat, and
fillPat fields, which previously held 8-byte patterns, have been replaced by three 4-byte
handles. The resulting 12 bytes of additional space are taken up by two 6-byte RGBColor
records.
The structure of the color graphics port is as follows:
CGrafPtr
CGrafPort

=
=

*CGrafPort;
RECORD

device:

INTEGER;

{device
{

ID

for

font

}

selection}

portPixMap:
portVersion:

PixMapHandle;
INTEGER;

{port's pixel map}
{highest 2 bits always
{ set}

grafVars:

Handle;

{handle

chExtra:

INTEGER;

{extra

to

more

}

fields}

characters}

pnLocHF rac:
portRect:
visRgn:
clipRgn:
bkPixPat:

INTEGER;
Rect;
RgnHandle;
RgnHandle;
PixPatHandle;

{pen fraction}
{port rectangle}
{visible region}
{clipping region}
{background pattern}

rgbFgColor:

RGBColor;

{requested

foreground

}

RGBColor;

{ color}
{requested

background

}

rgbBkColor:

{

color}

pnLoc:
pnSize:
pnMode:
pnPixPat:
fillPixPat:
pnVis:
txFont:

Point;
Point;
INTEGER;
PixPatHandle;
PixPatHandle;
INTEGER;
INTEGER;

{pen location}
{pen size}
{pen transfer mode}
{pen pattern}
{fill pattern}
{pen visibility}
{font number for text}

txFace:

Style;

{text's

txMode:
txSize:
SpExtra:
fgColor:

INTEGER;
INTEGER;
Fixed;
LONGINT;

{text's transfer mode}
{font size for text}
{extra space}
{actual foreground color}

bkColor:

LONGINT;

{actual

colrBit:
patStretch:
picSave:
rgnSave:

INTEGER;
INTEGER;
Handle;
Handle;

{plane being drawn}
{used internally}
{picture being saved}
{region being saved}

polySave:

grafProcs:
END;

V-50 The Color Graphics Port

Handle;

CQDProcsPtr

{polygon

character

background

being

style}

color}

saved}

{low-level drawing
{ routines}

}

Color QuickDraw
Field

descriptions

portPixMap

The portPixMap field contains a handle to the port’s pixel map. This

portVersion

The two high bits of the portVersion field are always set. This
allows Color QuickDraw to tell the difference between a grafPort
and a cGrafPort. The remainder of the field gives the version
number of Color QuickDraw that created this port. (Initial release is

is the structure that describes the cGrafPort’s pixels.

version 0.)

grafVars

The grafVars field contains a handle to additional fields.

chExtra

The chExtra field is used in proportional spacing. It specifies a fixed
point number by which to widen every character, excluding the
space character, in a line of text. (The number is in 4.12 fractional

notation: four bits of signed integer followed by 12 bits of fraction.
This number is multiplied by txSize before it is used.) Default
chExtra is 0.
pnLocHFrac

The pnLocHFrac field contains the fractional horizontal pen position
used when drawing text. The initial pen fraction is 1/2.

bkPixPat

The bkPixPat field contains a handle to the background pixel

rgbFgColor

The rgbFgColor field contains the requested foreground color.

rgbBkColor

The rgbBkColor field contains the requested background color.

pattern.

pnPixPat

The pnPixPat field contains a handle to the pixel pattern for pen
drawing.

fillPixPat

The fillPixPat field contains a handle to the pixel pattern for area fill;
for internal use only. Notice that this is not in the same location as
old fillPat.

fgColor

The fgColor field contains the pixel value of the foreground color
supplied by the Color Manager. This is the best available
approximation to rgbFgColor.

bkColor

The bkColor field contains the pixel value of the background color
supplied by the Color Manager. This is the best available
approximation to rgbBkColor.

colrBit

The colrBit field is reserved: not for use by applications.

grafProc

The grafProc field used with a cGrafPort contains
instead of the QDProcsPtr used with a grafPort.

a CQDProcsPtr,

All remaining fields have the same meanings as in the old-style grafPort.

The Color Graphics Port V-51

The Color Graphics Port V-53

Bas

2)
=
==

©
=i)

~~

=
_

=<<
<

Inside Macintosh

Inside Macintosh

Field

descriptions

patType

The patType field specifies the pattern’s type. The possible values
include: 0 = old-style pattern, 1 = full-color pixel pattern,

pattern.

2 = RGB

patMap

The patMap field is a handle to the pixel map describing

patData

The patData field is a handle to the pattern’s pixel image.

patXData

The patX Data

patX Valid

When the pattern’s data or color table change, you can invalidate the
expanded data by setting the patX Valid field to —1.

patX Map

The patXMap field is a handle that is reserved for use by Color

pat1 Data

The pat1Data field contains an old-style 8-by-8 pattern to be used
when this pattern is drawn into old grafPort. NewPixPat sets this
field to 50% gray.

pixel image.

the pattern’s

field is a handle to an expanded pixel image used

internally by Color QuickDraw.

QuickDraw.

Old-style patterns are still supported. When used in a cGrafPort, the QuickDraw routines
PenPat and BackPat store the pattern within pnPixPat and bkPixPat, respectively, and set
the patType to 0 to indicate that the structure contains old pattern data. Such patterns are
limited to the original 8-by-8 dimensions and are always drawn using the values in the
cGrafPort’s rgbFgColor and rgbBkColor fields. Similarly, filled drawing operations, such
as FillRect, are also supported.
In a pixel pattern (patType = 1), the pattern’s dimensions, depth, resolution (only 72 pixels
per inch is supported), set of colors, and other characteristics are defined by a pixel map,
referenced by the patMap handle. Since the pixel map has its own color table, pixel patterns
can consist of any number of colors, and don’t usually use the foreground and background
colors. The section on relative patterns, below, describes an exception to this rule.
Furthermore, patT ype = 1 patterns are not limited to a fixed size: their height and width can
be any power of 2, as specified by the height and width of patMap™.bounds. (Notice that
a pattern eight bits wide—the original QuickDraw size—has a row width of just one byte,
contrary to the usual rule that the rowBytes field must be even.) This pattern type is
generally read into memory using the GetPixPat routine, or set using the PenPixPat or
BackPixPat routines.
Although the patMap defines the pattern’s characteristics, its baseAddr field is ignored; for
a typel pattern, the actual pixel image defining the pattern is stored in the handle in the
pattern’s patData field. The pattern’s depth need not match that of the pixel map it’s painted
into; the depth will be adjusted automatically when the pattern is drawn. Color QuickDraw
maintains a private copy of the pattern’s pixel image, expanded to the current screen depth,
and aligned to the current grafPort or cGrafPort, in the patXData field.

V-56 The Color Graphics Port

Color QuickDraw
The third pattern type is RGBPat (patType = 2). Using the MakeRGBPat routine, the
application can specify the exact color it wants to use. QuickDraw selects a pattern to
approximate that color. In this way, an application can effectively increase the color
resolution of the screen. Pixel patterns are particularly useful for dithering: mixing
existing colors together to create the illusion of a third color that’s unavailable on a
particular device. The MakeRGBPat routine aids in this process by constructing a dithered
pattern to approximate a given absolute color. (See the description of MakeRGBPat in the
“Color QuickDraw Routines” section for more details.) In the current implementation of
ColorQuickDraw, an RGBPat can display 125 different patterns on a 4-bit-deep screen, or
2197 different patterns on an 8-bit-deep screen.
For an RGBPat, the RGB defines the image; there is no image data. An RGBPat has an 8by-8, 2-bit-deep pattern.
A program that creates a pixMap must initialize the pixMap’s color table to describe the
pixels. GetCTable could be used to read such a table from a resource file; you could then
dispose of the pixMap’s color table and replace it with the one returned by GetCTable.
Relative

Patterns

Typel pixel patterns contain color tables that describe the colors they use. Generally such a
color table contains one entry for each color used in the pattern. For instance, if your
pattern has five colors in it, you would probably create a four-bit-per-pixel pattern that uses
pixel values 0-4, and a color table with five entries, numbered 0-4, that contain the RGB

specifications for those pixel values.

When the pattern is drawn, each possible pixel value that isn’t specified in the color table is
assigned a color. The largest unassigned pixel value becomes the foreground color; the
smallest unassigned pixel value is assigned the background color. Remaining unassigned
pixel values are given colors that are evenly distributed between the foreground and
background.
For instance, in the color table mentioned above, pixel values 5—15 are unused. Assume

that the foreground color is black and the background color is white. Pixel value 15 is
assigned the foreground color, black; pixel value 5 is assigned the background color,

white; the nine pixel values between them are assigned evenly distributed shades of gray. If
the pixMap’s color table is set to NIL, all pixel values are determined by blending the
foreground and background colors.
Transfer

Modes

A transfer mode is a method of placing information on the display devices. It involves
an interaction between what your application is drawing (the source) and what’s already
there (the destination). The original QuickDraw offered eight basic transfer modes:
= completely replacing the destination with the source (Copy), and its inverse (NotCopy)
= combining the destination with the source (Or), and its inverse (NotOr)

The Color Graphics Port V-57

des

o

Cyor

©

=:©)
=

i)

Low

i)

=

4

Inside Macintosh
= selectively clearing the destination with the source (Bic, for “bit clear”), and its inverse

(NotBic)

= selectively inverting the destination with the source (Xor), and its inverse (NotXor)
This is how color affects these eight transfer modes when the source pixels are either black
(all 1’s) or white (all 0’s):
Copy

The Copy mode applies the foreground color to the black part of the
source (the part containing 1’s) and the background color to the

white part of the source (the part containing 0’s), and replaces the
destination with the colored source.
NotCopy

The NotCopy mode applies the foreground color to the white part of
the source and the background color to the black part of the source,
and replaces the destination with the colored source. It thus has the
effect of reversing the foreground and background colors.

Or

The Or mode applies the foreground color to the black part of the
source and replaces the destination with the colored source. The
white part of the source isn’t transferred to the destination. If the
foreground is black, the drawing will be faster.

NotOr

The NotOr mode applies the foreground color to the white part of
the source and replaces the destination with the colored source. The
black part of the source isn’t transferred to the destination. If the
foreground is black, the drawing will be faster.

Bic

The Bic mode applies the background color to the black part of the
source and replaces the destination with the colored source. The
white part of the source isn’t transferred to the destination.

NotBic

The NotBic mode applies the background color to the white part of
the source and replaces the destination with the colored source. The
black part of the source isn’t transferred to the destination.

Xor

The Xor mode complements the bits in the destination
corresponding to the bits equal to 1 in the source. When used on a
colored destination, the color of the inverted destination isn’t

defined.
NotXor

The NotXor mode inverts the bits that are 0 in the source. When
used on a colored destination, the color of the inverted destination
isn’t defined.

Pixels of colors other than black and white aren’t all 1’s or all 0’s, so the application of a
foreground color or a background color to the pixel produces an undefined result. For this
reason, and because a pixPat already contains color, the foreground and background colors
are ignored when your application is drawing with a pixPat. When your program draws a
pixMap the foreground and background colors are not ignored. Make sure that the
foreground is black and the background is white before you call CopyBits or the result will
be undefined.

V-58 The Color Graphics Port

Color QuickDraw

If you intend to draw with pixMaps or pixPats, you will probably want to use the Copy
mode or one of the arithmetic modes described in the following section.
To help make color work well on different screen depths, Color QuickDraw does some
validity checking of the foreground and background colors. If your application is drawing
to a cGrafPort with a depth equal to 1 or 2, and if the RGB values of the foreground and

background colors aren’t the same, but both of them map to the same pixel value, then the

foreground color is inverted. This ensures that, for instance, red text drawn on a green
background doesn’t map to black on black.

Arithmetic

Drawing

Modes

Color QuickDraw uses a set of arithmetic drawing modes designed specifically for use with
color. These modes change the destination pixels by performing arithmetic operations on
the source and destination pixels. These drawing modes are most useful in 8-bit color, but
work on 4-bit and 2-bit color as well. If the destination bitmap is one bit deep, the mode
reverts to one of the old transfer modes that approximates the arithmetic mode requested.
Each drawing routine converts the source and destination pixels to their RGB components,
performs an operation on each pair of components to provide a new RGB value for the
destination, and then assigns the destination a pixel value close to the calculated RGB
value. The arithmetic modes listed below can be used for all drawing operations; your
application can pass them as a parameter to TextMode, PenMode, or CopyBits.
addOver

This mode assigns to the destination pixel the color closest to the
sum of the source and destination RGB values. If the sum of any of
the RGB components exceeds the maximum allowable value,
65,535, the RGB value wraps around to the value less 65,536.

AddOver is slightly faster than addPin. If the destination bitmap is
one bit deep, addOver reverts to Xor.

he

OQ

=
o

Lew

addPin

subOver

This mode assigns to the destination pixel the color closest to the
sum of the destination RGB values, pinned to a maximum allowable
RGB value. For grafPorts, the pin value is always white. For
cGrafPorts, the pin value is assigned using OpColor. If the
destination bitmap is one bit deep, addPin reverts to Bic.
This mode assigns to the destination pixel the color closest to the
difference of the source and destination RGB values. If the result is
less than 0, the RGB

value wraps around to 65,536 less the result.

SubOver is slightly faster than subPin. If the destination bitmap is
one bit deep, subOver reverts to Xor.
subPin

This mode assigns to the destination pixel the color closest to the
difference of the sum and the destination RGB values, pinned to a
minimum allowable RGB value. For grafPorts, the pin value is
always black. In a cGrafPort, the pin value is assigned by using
OpColor. If the destination bitmap is one bit deep, subPin reverts to
Or.

The Color Graphics Port V-59

|

©

=iw)

be
=—_~
—,
=
mn

=

Inside Macintosh

adMax

adMin

blend

(Arithmetic Drawing Max) This mode compares the source and
destination pixels, and replaces the destination pixel with the color
containing the greater saturation of each of the RGB components.
Each RGB component comparison is done independently, so the
resulting color isn’t necessarily either the source or the destination
color. If the destination bitmap is one bit deep, adMax reverts to
Bic.
(Arithmetic Drawing Min) This mode compares the source and

destination pixels, and replaces the destination pixel with the color
containing the lesser saturation of each of the RGB components.
Each RGB component is compared independently, so the resulting
color isn’t necessarily the source or the destination color. If the
destination bitmap is one bit deep, adMin reverts to Or.
This mode replaces the destination pixel with a weighted average of
the colors of the source and destination pixels. The formula used to
calculate the destination is:
dest

=

source*weight/65,536

+

cestination*

(1-weight/65,

536)

where weight is an unsigned value between 1 and 65,535. Ina
grafPort, the weight is set to 50% gray, so that equal weights of the

source and destination RGB components are combined to produce

the destination color. In a cGrafPort, the weight is an RGBColor

that individually specifies the weights of the red, green, and blue
components. The weight is assigned using OpColor. If the
destination bitmap is one bit deep, blend reverts to Copy.
Because drawing with the arithmetic modes uses the closest matching pixel values, and not

necessarily exact matches, these modes might not produce the results you expect. For
instance, suppose srcCopy mode is used to paint a green pixel on the screen in 4-bit mode.
Of the 16 colors available, the closest green may contain a small amount of red, as in RGB
components of 300 red, 65,535 green, and 0 blue. AddOver is then used to paint a red

pixel on top of the green pixel, ideally resulting in a yellow pixel. The red pixel’s RGB
components are 65,535 red, 0 green, and 0 blue. Adding the red components together

wraps to 300, since the largest representable value is 65,535. In this case, AddOver would
cause no visible change at all. Using AddPin with an opColor of white would produce the
desired results.

On the Macintosh II the rules for setting the pen mode and the text mode have been relaxed
slightly. It’s no longer necessary to specify a pattern mode or a source mode (patCopy as
opposed to srcCopy) to perform a particular operation. QuickDraw will choose the correct
drawing mode automatically. However, to be compatible with earlier versions of

QuickDraw, you application must specify the correct drawing mode. Text and bitmaps
should always use a source mode; rectangles, regions, polygons, arcs, ovals, round
rectangles, and lines should always use a pattern mode.
The constants used for the arithmetic transfer modes are as follows:

V-60 The Color Graphics Port

Color QuickDraw
The structure of the color cursor is as follows:
TYPE

CCrsrHandle
CCrsrPtr
ll

CCrszr

*“CUrsretr;
“CCrsrvz
RECORD
crsrType:

INTEGER;

{type

crsrMap:

PixMapHandle;

{the

crsrData:

Handle;
Handle;

{cursor's
{expanded
{depth of
{Reserved
{ use}

data}
cursor data}
expanded data}
for future
}

crsrxXData:

of

cursor}

cursor's

pixmap}

crsrxXValid:

INTEGER;

crsrXHandle:

Handle;

crsrlData:

Bits16;
Bits16;

{one-bit

cursor}

{cursor's

mask}

Point;

{cursor's

hotspot}

crsrxXTable:

LONGINT;

{private}

CrsxLp::

LONGINT;

{ctSeed

crsrMask:
crsrHotSpot:

{

for

expanded

}

cursor}

END;

You will not normally need to manipulate the fields of a color cursor. Your application can
load in a color cursor using the GetCCursor routine, and display it using the SetCCursor
routine. When the application is finished using a color cursor, it should dispose of it using
the DisposCCursor routine. These routines are discussed below in the section “Color
QuickDraw Routines”.
Color cursors are stored in resources of type 'crsr'. The format of the 'crsr' resource is
given in the section “Color QuickDraw Resource Formats”.

Field

oo

©=

descriptions

crsrType

The crsrType field specifies the type of cursor. Possible values are:
$8000 = old cursor, $8001 = new cursor.

=
©
==.

crsrMap

The crsrMap field is a handle to the pixel map defining the cursor’s
characteristics.

69

crsrData

The crsrData field is a handle to the cursor’s pixel data.

crsrX Data

The crsrXData field is a handle to the expanded pixel image used
internally by Color QuickDraw (private).

crsrXValid

§ The crsrXValid field contains the depth of the expanded cursor
image. If you change the cursor’s data or color table, you should set
this field to 0 to cause the cursor to be reexpanded. You should
never set it to any other values.

crsrXHandle

The crsrXHandle field is reserved for future use.

The Color Cursor V-63

si
=
<

<=

Inside Macintosh

crsr1Data
crsrMask

The crsr1Data field contains a 16-by-16 one-bit image to be
displayed when the cursor is on 1-bit or 2-bit per pixel screens.
The crsrMask field contains the cursor’s mask data. The same 1-bit-

deep mask is used with crsrData and crsr1Data.

crsrHotSpot

The crsrHotSpot field contains the cursor’s hot spot.

crsrX Table

The crsrXTable field is reserved for future use.

crsrID

The crsrID field contains the ctSeed for the cursor.

The first four fields of the CCrsr record are similar to the first four fields of the PixPat
record, and are used in the same manner by Color QuickDraw. See the discussion of the

patMap field under the section titled “Pixel Patterns” for more information on how the
crsrMap is used.

The display of a cursor involves a relationship between a mask, stored in the crsrMask field
with the same format used for old cursor masks, and an image. There are two possible
sources for a color cursor’s image. When the cursor is on a screen whose depth is one or
two bits per pixel, the image for the cursor is taken from Crsr1Data, which contains oldstyle cursor data. In this case, the relationship between data and mask is exactly as before.
When the screen depth is greater than two bits per pixel, the image for the cursor is taken
from crsrMap and crsrData; the relationship between mask and data is described in the

following paragraph.

The data pixels within the mask replace the destination pixels. The data pixels outside the
mask are displayed using an XOR with the destination pixels. If data pixels outside the
mask are 0 (white), the destination pixels aren’t changed. If data pixels outside the mask
are all 1’s (black), the destination pixels are complemented. All other values outside of the
mask cause unpredictable results.
To work properly, a color cursor’s image should contain white pixels (R

= G = B=

$FFFF) for the transparent part of the image, and black pixels (R = G = B = $0000) for the
inverting part of the image, in addition to the other colors in the cursor’s image. Thus, to
define a cursor that contains two colors, it’s necessary to use a 2-bit-per-pixel cursor image
(that is, a four-color image).
If your application changes the value of your cursor data or its color table, it should set the
crsrX Valid field to 0 to indicate that the cursor’s data needs to be reexpanded, and assign a
new unique value to crsrID (unique values can be obtained using the GetCTSeed routine);
then it should call SetCCursor to display the changed cursor.

COLOR

ICONS

A new data structure, known as ClIcon, supports the use of color icons. The structure of
the color icon is as follows:

V-64 Color Icons

Color QuickDraw
TYPE

CIconHandle

=

“CIconPtr;

CIconPtr
CIcon

=
=

“CIcon;
RECORD

iconPMap:
iconMask:

PixMap;
BitMap;

{the
{the

icon's
icon's

iconBMap:
iconData:
iconMaskData:

BitMap;
Handle;
ARRAY[0..0]

{the icon's bitMap}
{the icon's
data}
OF INTEGER;

{icon's
{

mask

pixMap}
mask bitmap}

and

bitmap

}

data}

END;

You won’t normally need to manipulate the fields of color icons. Your application can load
a color icon into memory using the routine GetClIcon. To draw a color icon that’s already in
memory, use PlotCIcon. When your application is through with a color icon, it can dispose
of it using the DisposCIcon routine. These routines are discussed below in the section
“Color QuickDraw Routines”.
Color icons are stored in a resource file as resource type 'cicn’. The format of the 'cicn'
resource is given in the section “Using Color QuickDraw Resources”.

Field

descriptions

iconPMap

The iconPMap field contains the pixel map describing
that pixMap is inline, not a handle.

the icon. Note

iconMask

The iconMask field contains a bit map for the icon’s mask.

iconB Map

The iconBMap field contains a bit map for the icon.

iconData

The iconData field contains a handle to the icon’s pixel image.

iconMaskData The iconMaskData field is an array containing the icon’s mask data
followed by the icon’s bitmap data. This is only used when the icon
is stored as a resource.
You can use color icons in menus in the same way that you could use old icons in menus.
The menu definition procedure first tries to load in a 'cicn' with the specified resource ID.
If it doesn’t find one, then it tries to load in an 'ICON' with that ID. The Dialog Manager
will also use a ‘cicn' in place of an 'ICON' if there is one with the ID specified in the item
list. For more information, see the Menu Manager and Dialog Manager chapters.

USING

COLOR

QUICKDRAW

This section gives an overview of routines that you will typically call while using Color
QuickDraw. All routines are discussed below in the section “Color QuickDraw Routines”.

Using Color QuickDraw V-65

cS

©
=

Lee |

(=
=
aee
o

65

saw

=

|

Inside Macintosh

Using a color graphics port is much like using an old-style grafPort. The old routines
SetPort and GetPort operate on grafPorts or cGrafPorts, and the global variable ThePort
points to either to a grafPort or a cGrafPort. Color QuickDraw examines the two high bits
of the portBits.rowBytes field (the portVersion field in a cGrafPort). If these bits equal 0,
then it is a grafPort; if they are both 1, then it is a cGrafPort. In Pascal, use type
coercion to convert between GrafPtr and cGrafPtr. For example:
VAR myPort:
CGrafPtr;
SetPort
(GrafPtr(myPort)

);

There’s still a graphics pen for line drawing, with a current size, location, pattern, and
transfer mode; all of the old line- and shape-drawing operations, such as Move, LineTo,

FrameRect, and PaintPoly, still work just as before. However, colors should be set with
the new routines RGBForeColor and RGBBackColor (described below) instead of the old

ForeColor and BackColor routines. If your application is using the Palette Manager, use
the routines PMForeColor and PMBackColor instead.

PenPat and BackPat are still supported, and will construct a pixel pattern equivalent to the
specified bit pattern. The patType field of this pattern is set to 0; thus it will always use the
port’s current foreground and background colors at the time of drawing.
To read a multicolored pattern from a resource file, use the GetPixPat routine. Set these
patterns using PenPixPat and BackPixPat, or pass them as parameters to Color
QuickDraw’s color fill routines (such as FillCRect). These patterns have their own color
tables and are generally not affected by the port’s foreground and background colors (refer
to the earlier discussion of relative patterns).
Most routines that accept bitMaps as parameters also accept pixMaps (not PixMapHandles).
Likewise, any new routine that has a pixMap as a parameter will also accept a bitMap. This
allows one set of routines to work for all operations on images; the high bit of the
rowBytes field distinguishes whether the parameter is a bitMap or a pixMap.
It’s worth noting here that resources are used slightly differently by Color QuickDraw than
they were used by QuickDraw. For instance, with old QuickDraw, your application could
call GetCursor before each SetCursor; the same handle would be passed back to the
application each time. With Color QuickDraw, the color cursor is a compound structure,
more complex than a simple resource handle. Color QuickDraw reads the requested
resource, copies it, and then alters the copy before passing it to the application. Each time
your application calls GetCCursor, it gets a new copy of the cursor. This means that your
program should only call GetCCursor once, even if it does multiple SetCCursor calls. The
new resource types should be marked as purgeable if you are concerned about memory
space. This discussion holds true for color cursor, color pattern, color icon, and color table
resources.

V-66 Using Color QuickDraw

COLOR

QUICKDRAW

ROUTINES

Color QuickDraw continues to support all the original QuickDraw calls described in
Volume I. The following sections describe in detail the new Color QuickDraw routines, as
well as changes to existing routines.

Operations
PROCEDURE

on

CGrafPorts

OpenCPort

(port:

CGrafPtr);

The OpenCPort procedure is analogous to OpenPort, except it opens a cGrafPort instead of
a grafPort. You will rarely need to use this call, since OpenCPort is called by
NewCWindow and GetNewCWindow, as well as by the Dialog Manager when the
appropriate color resources are present. OpenCPort allocates storage for all the structures
in the cGrafPort, and then calls InitCPort to initialize them. The new structures allocated
are the portPixMap, the pnPixPat, the fillPixPat, the bkPixPat, and the grafVars handle.
The GrafVars record structure is shown below:
TYPE
GrafVars

=

RECORD

rgbOpColor:

rgbHiliteColor:
pmFgColor:

RGBColor;
RGBColor;
Handle;

{color

and

}

{color for highlighting}
{Palette handle for foreground
{ color}

}

=
o

{Palette

}

lo

{

for

addPin,

pmFgIndex:

INTEGER;

pmBkColor:

Handle;

pmBk Index:

INTEGER;

{ color}
{index value

pmFlags:

INTEGER;

{Flags

END;

subPin,

blend}

{index

value

for

handle

for

for

foreground}

for

background

background}

Palette

Manager}

The rgbOpColor field is initialized as black, and the rgbHiliteColor field is initialized as the
default HiliteRGB. All the rest of the GrafVars fields are initially zero.
The portPixMap is not allocated a color table of its own. When InitCPort is called, the
handle to the current device’s color table is copied into the portPixMap.
PROCEDURE

InitCPort

(port:

CGrafPtr) ;

The InitCPort procedure does not allocate any storage. It merely initializes all the fields in
the cGrafPort to their default values. All old fields are initialized to the same values as a
grafPort’s fields. New fields are given the following values:

Color QuickDraw Routines V-67

S

=.
x
Sy

<

Inside Macintosh

portPixMap:

copied from theGDevice™.GDPMap

grafVars:

opColor initialized to black, rgbHiliteColor initialized as default HiliteRGB.
All other fields are initialized as 0.
0
1/2
white
black
white
black
black

portVersion:

$C000

chExtra:
pnLocHFrac:
bkPixPat:
rgbFgColor:
rgbBkColor:
pnPixPat:
fillPixPat:

The default portPixMap is set to be the same as the current device’s pixMap. This allows
you to create an offscreen port that is identical to the screen’s grafPort or cGrafPort for
drawing offscreen. If you want to use a different set of colors for offscreen drawing, you
should create a new gDevice, and set it as the current gDevice before opening the
cGrafPort. Refer to the section on offscreen bitMaps in the Graphics Devices chapter for
more details.
As mentioned above, InitCPort does not copy the data from the current device’s color table
to the portPixMap’s color table. It simply replaces whatever is in the pmTable field with a
copy of the handle to the current device’s color table.
If you try to initialize a grafPort using InitCPort, it will simply return without doing
anything.
PROCEDURE

CloseCPort

(port:

CGrafPtr);

CloseCPort releases the memory allocated to the cGrafPort. It disposes of the visRgn, the
clipRgn, the bkPixPat, the pnPixPat, the fillPixPat, and the grafVars handle. It also
disposes of the portPixMap, but doesn’t dispose of the portPixMap’s color table (which is
really owned by the gDevice). If you have placed your own color table into the
|
portPixMap, either dispose of it before calling CloseCPort, or store another reference to it
for other uses.

Setting

the

Foreground

and

Background

PROCEDURE

RGBForeColor

(color

:

RGBColor);

PROCEDURE

RGBBackColor

(color

:

RGBColor);

Colors

These two calls set the foreground and background colors to the best available match for
the current device. The only drawing operations that aren’t affected by these colors are
PlotCIcon, and drawing using the new color patterns. Before you call CopyBits with a
pixMap as the source, you should set the foreground to black and the background to white.
If the current port is a cGrafPort, the specified RGB is placed in the rgbFgColor or
tgbBkColor field (and the pixel value most closely matching that color is placed in the
fgColor or bkColor field). If the current port is a grafPort, fgColor or bkColor is set to the
old QuickDraw color determined by taking the high bit of each of the R, G, and B

V-68 Color QuickDraw Routines

Color QuickDraw
components, and using that three-bit number to select one of the eight QuickDraw colors.
The ordering of the QuickDraw colors is shown in the GetForeColor description.
PROCEDURE
PROCEDURE

GetForeColor
GetBackColor

(VAR
(VAR

color
color

:
:

RGBColor);
RGBColor);

These two calls return the RGB components of the foreground and background colors set
in the current port. The calls work for both grafPorts and cGrafPorts. If the current port is
a cGrafPort, the returned value is taken directly from the rgbFgColor or rgbBkColor field.
If the current port is a grafPort, then only eight possible RGB values can be returned.
These eight values are determined by the values in a global variable named QDColors,
which is a pointer to a color table containing the current QuickDraw colors.
The colors are stored in the following order:
Value

Color

Red

Green

Blue

0

black

$0000

$0000

$0000

2

magenta

$F2D7

$0856

$84EC

1

yellow

3

$FC00

red

4
5
6

$DD6B

cyan
green
blue

7

$F37D
$08C2

$0241
$0000
$0000

white

$052F

$06A2

$AB54
$8000
$0000

$FFFF

$EAFF
$11B0
$D400

$FFFF

$FFFF

This is the set of colors that Color QuickDraw uses to determine precisely what colors
should be displayed by an old grafPort that is using color. The default set of colors has
been adjusted to match the colors produced on the ImageWriter II printer.

-_

-Q

<2

Color

Drawing

=)

Operations

=y

=)

o

=.

Oo

PROCEDURE
PROCEDURE

FillCRect
FillCOval

PROCEDURE

PixPatHandle) ;
FillCArc
(r: Rect;

PROCEDURE

PROCEDURE

PROCEDURE

(r:
(r:

FillCRoundRect

Rect;
Rect;

PixPatHandle) ;

FillCRgn

FillCPoly

(rgn:

(poly:

(r:

ppat:
ppat:

Rect;

PixPatHandle) ;
PixPatHandle);

ovWd,ovHt:

ppat:

PolyHandle;

=)

INTEGER;

startAngle,arcAngle:

RgnHandle;

=)

bee

<

ppat:

INTEGER;

ppat:

PixPatHandle) ;

ppat:

PixPatHandle) ;

These calls are analogous to their similarly named counterparts in QuickDraw. They allow a
multicolored pattern to be used for filling.
PROCEDURE

GetCPixel

(h,v:

INTEGER;

VAR

cPix:

RGBColor);

The GetCPixel function returns the RGB of the pixel at the specified position in the current

port.

Color QuickDraw Routines V-69

|

Inside Macintosh
PROCEDURE

SetCPixel

(h,v:

INTEGER;

cPix:

RGBColor);

The SetCPixel function sets the pixel at the specified position to the pixel value that most
closely matches the specified RGB.

Creating

Pixel

Maps

FUNCTION

NewPixMap

: PixMapHandle;

The NewPixMap function creates a new, initialized pixMap data structure and returns a
handle to it. All fields of the pixMap are copied from the current device’s pixMap except the
color table. A handle to the color table is allocated but not initialized.
PROCEDURE

DisposPixMap

(pm:

PixMapHandle);

The DisposPixMap procedure releases all storage allocated by NewPixMap. It disposes of
the pixMap’s color table, and of the pixMap itself. Be careful not to dispose of a pixMap
whose color table is the same as the current device’s color table.
PROCEDURE

CopyPixMap

(srcPM,dstPM:

PixMapHandle) ;

The CopyPixMap routine is used for duplicating the pixMap data structure. CopyPixMap
copies the contents of the source pixMap data structure to the destination pixMap data
structure. The contents of the color table are copied, so the destination pixMap has its own
copy of the color table. Since the baseAddr field of the pixMap is a pointer, the pointer, but
not the image itself, is copied.

Operations
PROCEDURE

on

Pixel Maps

CopyBits
(srcBits,dstBits: BitMap; srcRect,
Rect;
mode: INTEGER; maskRgn: RgnHandle) ;

dstRect:

CopyBits now accepts either bitMaps or pixMaps as parameters. For convenience, just as
you could pass the current port’.portBits as a parameter to CopyBits, you can now pass
GrafPtr(cPort)’.portBits. (Recall that in a cGrafPort the high two bits of the portVersion

field are set. This field, in the same position in the port as portBits.rowBytes, indicates to
QuickDraw that it has been passed a portPixMap handle.)

This call transfers an image from one bitMap or pixMap to another bitMap or pixMap. The
source and destination may be of different depths, of different sizes, and they may have
different color tables. Note, however, that the destination pixMap is assumed to use the
same color table as the gDevice. (This is because an inverse table is required for translation
to the destination’s color table.)

V-70 Color QuickDraw Routines

Color QuickDraw
During a CopyBits call, the foreground and background colors are applied to the image. To
avoid unwanted coloring of the image, set the foreground to black and the background to
white before calling this routine.
PROCEDURE

CopyMask
(srcBits,maskBits,dstBits:
srcRect,maskRect,dstRect:
Rect);

BitMap;

CopyMask is a new version of the CopyBits procedure, introduced in the Macintosh Plus.
It transfers an image from the source to the destination only where the corresponding bit of
the mask equals 1. The Macintosh II version will accept either a bitMap or pixMap as the
srcBits or dstBits parameters. The maskBits parameter must be a bitMap.
Like the Macintosh Plus version, CopyMask doesn’t send any of its drawing commands
through grafProc routines; thus CopyMask calls are not recorded in pictures. Unlike the
Macintosh Plus version, the Macintosh II version of CopyMask is able to stretch the source
and mask to fit the dstRect. The srcRect and maskRect should be the same size. CopyMask
uses the same low-level code as CopyBits, so all the same rules regarding depth translation
and color table translation apply.
During a CopyMask call, the foreground and background colors are applied to the image.
To avoid unwanted coloring, set the foreground to black and the background to white
before calling this routine.
PROCEDURE

SeedCFill
(srcBits,
dstBits:
BitMap;
srcRect,
dstRect:
Rect;
seedH,
seedV:
INTEGER;
matchProc:
ProcPtr;
matchData:
LONGINT);

The SeedCFill procedure generates a mask for use with CopyMask or CopyBits, with bits
equal to 1 only in those positions where paint can leak from the starting seed point, like the
MacPaint® bucket tool.
Given a rectangle within a source bitMap or pixMap (srcBits), SeedCFill returns a mask
(dstBits) that contains 1’s in place of all pixels to which paint can leak from the specified
seed position (seedH, seedV), expressed in the local coordinate system of the source
pixMap. By default, paint can leak to all adjacent pixels whose RGB value exactly match
that of the seed. To use this default, set matchProc and matchData to zero.

In generating the mask, SeedCFill performs CopyBits to convert srcBits to a one-bit mask.
It installs a default searchProc into the gDevice that returns 0 if the RGB value matches that
of the seed; all other RGB values return 1’s.
If you want to customize SeedCFill, your application can specify a matchProc that is used
instead of the default searchProc. It should return 0’s for RGB values that you want to be
filled, and 1’s for values that shouldn’t be filled. When the matchProc is called, the

GDRefCon field of the current gDevice contains a pointer to a record having the following
structure:

Color QuickDraw Routines

V-71

aS
Q

=
i)=

©
=O°

~*~

=)
=

2=

Inside Macintosh
MatchRec

=

RECORD

red:
green:

INTEGER;
INTEGER;

blue:
matchData:

INTEGER;
LONGINT

END;

In this record the red, green, and blue fields are the RGB of the pixel at the specified seed

location. MatchData is simply whatever value you passed to SeedCFill as a parameter. For
instance, your application could pass a handle to a color table whose entries should all be

filled, and then, in the matchProc, check to see if the specified RGB matches any of the
colors in the table.

No automatic scaling is performed: the source and destination rectangles must be the same

size. Calls to SeedCFill are not clipped to the current port and are not stored into

QuickDraw pictures.
PROCEDURE

CalcCMask
(srcBits,
dstBits:
BitMap;
srcRect,
dstRect:
Rect;
seedRGB:
RGBColor;
matchProc:
ProcPtr;
matchData:
LONGINT) ;

This routine generates a mask (dstBits) corresponding to the area in a pixMap (srcBits) to
which paint cannot leak from outside of the srcRect. The size of srcRect must be the same
as the size of dstRect. By default, paint can leak to all adjacent pixels whose RGB values
don’t match that of the seedRGB. To use this default, set matchProc and matchData to 0.
For instance, if srcBits contains a blue rectangle on a red background, and your application
calls CalcCMask with the seedRGB equal to blue, then the returned mask has ones in the
positions corresponding to the edges and interior of the rectangle, and zeros outside of the
rectangle.
If you want to customize CalcCMask, your application can specify a matchProc that is used
instead of the default searchProc. It should return 1’s for RGB values that define the edges
of the mask, and 0’s for values that don’t.
When the matchProc is called, the GDRefCon field of the gDevice contains a pointer to a
MatchRec record (the structure shown in the SeedCFill description). The red, green, and
blue fields are the RGB of the pixel at the specifed seed location. MatchData is simply
whatever value your application passed to CalcCMask as a parameter. For instance, your
program could pass a handle to a color table whose entries should all be within the mask,
any in the matchProc, check to see if the specified RGB matches any of the colors in
e table.
No automatic scaling is performed: the source and destination rectangles must be the same
size. Calls to CalcCMask are not clipped to the current port and are not stored into
QuickDraw pictures.

Operations
FUNCTION

on

Pixel

NewPixPat:

Patterns
PixPatHandle;

V-72 Color QuickDraw Routines

Color QuickDraw
The NewPixPat function creates a new pixPat data structure, and returns a handle to it. It

calls NewPixMap to allocate and initialize the pattern’s pixMap to the same settings as

theGDevice™.GDPMap, and it sets the type of the pixPat to be a color pattern. The
pat1Data field is initialized to a 50% gray pattern. New handles for data, expanded data,

expanded map, and color table are allocated but not initialized. Including the pixPat itself, it
allocates a total of six handles. You will generally not need to use this routine since the
GetPixPat routine can be used to read in a pattern from a resource file.

The sizes of the pixMap and pixPat handles are the size of their respective data structures

(see the type declarations in the “Summary” section). The other three handles are initially
small in size. Once the pattern is drawn, the size of the expanded data is proportional to the
size of the pattern data, but adjusted to the depth of the screen. The color table size is the
size of the record structure plus eight bytes times the number of colors in the table.

Creating

a

PixPat

To create a color pattern, use NewPixPat to allocate a new PixPatHandle. Set the

rowBytes, bounds, and pixelSize of the pattern’s pixMap to the dimensions of the desired
pattern. The rowBytes should be equal to (width of bounds)*pixelSize/8; it need not be
even. The width and height of the bounds must be a power of two. Each scanline of the
pattern must be at least one byte in length—that is, (width of bounds)*pixelSize must be at
least eight. Set the other fields in the pattern’s pixMap as described in the section on the
pixMap data structure.
Your application can explicitly specify the color corresponding to each pixel value with the
color table. The color table for the pattern must be placed in the pmTable in the pixPat’s
pixMap. Patterns may also contain colors that are relative to the foreground and
background at the time that they are drawn. Refer to the section on the pixPat data structure
for more information on relative patterns.
PROCEDURE

DisposPixPat

(ppat:

de

(2)
=
©

PixPatHandle) ;

The DisposPixPat procedure releases all storage allocated by NewPixPat. It disposes of the
pixPat’s data handle, expanded data handle, and pixMap handle.

“

©
=O

=
—]
—

Lew |

PROCEDURE

CopyPixPat

(srcPP,dstPP:

m

PixPatHandle) ;

=

The CopyPixPat procedure copies the contents of the source pixPat to the destination

pixPat. It entirely copies all fields in the source pixPat, including the contents of the data
handle, expanded data handle, expanded map, pixMap handle, and color table.
FUNCTION

GetPixPat

(patID:

INTEGER):

PixPatHandle;

The GetPixPat call creates a new pixPat data structure, and then uses the information in the
resource of type 'ppat' and the specified ID to initialize the pixPat. The 'ppat' resource
format is described in the section “Color QuickDraw Resource Formats”’. If the resource
with the specified ID is not found, then this routine returns a NIL handle.

PROCEDURE

MakeRGBPat

(ppat:

PixPatHandle;

myColor:

RGBColor) ;

Color QuickDraw Routines

V-73

Inside Macintosh

The MakeRGBPat procedure is a new call which generates a pixPat that approximates the
specified color when drawn. For example, if your application is drawing to a device that
has 4 bits per pixel, you will only get 16 colors if you simply set the foreground color and
draw. If you use MakeRGBPat to select a pattern, and then draw using that pattern, you
will effectively get 125 different colors. More colors are theoretically possible; this
implementation opted for a fast pattern selection rather than the best possible pattern
selection. If the device has 8 bits per pixel, you will effectively get 2197 colors.
Note that these patterns aren’t usually solid; they provide a wide selection of colors by
alternating between colors with up to four colors in a pattern. For this reason lines that are
one pixel wide may not look good using these patterns. For an RGB pattern, the
patMap™.bounds always contains (0, 0, 8, 8), and the patMap™.rowbytes equals 2.
Figure 5 shows how these colors are arranged.
When MakeRGBPat creates a color table, it only fills in the last colorSpec field: the other
colorSpec values are computed at the time the drawing actually takes place, using the
current pixel depth for the system.

Value
0
1
2
3
4

RGB
computed RGB color
computed RGB color
computed RGB color
computed RGB color
RGBColor passed to MakeRGBPat routine

EB]
Each component of the 8 x 8 pattern
is made up of the computed colors
Figure 5. RGB Pattern
PROCEDURE
PROCEDURE

PenPixPat
(ppat: PixPatHandle) ;
BackPixPat
(ppat: PixPatHandle) ;

The PenPixPat and BackPixPat calls are analogous to PenPat and BackPat, but use
multicolor pixel patterns instead of old-style patterns. If you try to use a pixel pattern in a
grafPort, the data in the pat] Data field is placed into pnPat, bkPat, or fillPat.
When your application sets a pixel pattern, the handle you provide is actually placed into
the grafPort or cGrafPort. In this way, QuickDraw can expand the pattern once (saving it in
the patXData field) when the pattern is first set, and won’t have to reexpand it each time
you set the pattern.

V-74 Color QuickDraw Routines

Color QuickDraw

Since your handle is actually stored in the grafPort or cGrafPort, it’s considered bad form
to dispose of a PixPatHandle that is currently set as the pnPixPat or bkPixPat. (Just in case
you forget, QuickDraw will remove all references to your pattern from existing grafPorts or
cGrafPorts when you dispose of it.)
Using the old calls PenPat and BackPat, you can still set old-style patterns in a cGrafPort.
If necessary, it creates a new pixPatHandle in which to store the pattern (because, as
described above, pixPatHandles are owned by the application). As in old grafPorts, oldstyle patterns are drawn using the foreground and background colors at the time of
drawing, not at the time the pattern is set.

Operations
FUNCTION

on

Color

GetCCursor

Cursors
(crsrID:

INTEGER):

CCrsrHandle;

The GetCCursor call creates a new CCrsr data structure, then initializes it using the
information in the resource of type ‘crsr' with the specified ID. The 'crsr' resource format
is described in the section “Color QuickDraw Resource Formats”’. If the resource with the
specified ID isn’t found, then this routine returns a NIL handle.
Since GetCCursor creates a new CCrsr data structure each time it is called, your application
shouldn’t call GetCCursor before each call to SetCCursor (unlike the way
GetCursor/SetCursor were normally used). GetCCursor doesn’t dispose or detach the
resource, so resources of type 'crsr' should typically be purgeable.
PROCEDURE

SetCCursor

(cCrsr:

CCrsrHandle) ;

x

The SetCCursor procedure allows your application to set a multicolor cursor. At the time
the cursor is set, it’s expanded to the current screen depth so that it can be drawn rapidly.

OQ

If your application has changed the cursor’s data or its color table, it must also invalidate
the fields crsrX Valid and crsrID (described in the section on the Color Cursor data
structure), before calling SetCCursor.

©

2
o

=

==

=

o
=y

+S)

=

PROCEDURE

DisposCCursor(cCrsr:

CCrsrHandle) ;

The DisposCCursor procedure disposes all structures allocated by GetCCursor.
PROCEDURE

AllocCursor;

The AllocCursor procedure reallocates cursor memory. Under normal circumstances, you
should never need to use this call, since reallocation of cursor memory is only necessary
after the depth of one of the screens has been changed.

Color QuickDraw Routines

V-75

Inside Macintosh

Operations
FUNCTION

on

Color

GetCIcon(id:

Icons
INTEGER):

CIconHandle;

The GetClIcon function allocates a CIcon data structure and initializes it using the
information in the resource of type ‘cicn' with the specified ID. It returns the handle to the
icon’s data structure. If the specified resource isn’t found, a NIL handle is returned.
The format of the 'cicn' resource is described in the section “Color QuickDraw Resource

Formats”.

Since GetClcon creates a new ClIcon data structure each time it is called, your application
shouldn’t call GetClIcon before each call to PlotCIcon. GetCIcon doesn’t dispose or detach
the resource, so resources of type 'cicn' should typically be purgeable.
PROCEDURE

DisposCIcon(theIcon:

CIconHandle) ;

The DisposClcon procedure disposes all structures allocated by GetCIcon.
PROCEDURE

PlotCIcon(theRect:

Rect;

theIcon:

CIconHandle) ;

The PlotCIcon procedure draws the specified icon in the specified rectangle. The iconMask
field of the CIcon determines which pixels of the iconPMap are drawn and which are not.
Only pixels with 1’s in corresponding positions in the iconMask are drawn; all other pixels
don’t affect the destination. If the screen depth is one or two bits per pixel, the iconBMap is
used as the source instead of the iconPMap (unless the rowBytes field of iconBMap is 0,
indicating that there is no iconBMap.
When the icon is drawn, the boundsRect of the iconPMap is used as the image’s source
rectangle. The icon and its mask are both stretched to the destination rectangle. The icon’s
pixels are remapped to the current depth and color table, if necessary. The bounds fields of
the iconPMap, iconBMap, and iconMask are expected to be equal in size.
PlotClcon is simply a structured call to CopyMask. As such, it doesn’t send any of its
drawing commands through grafProc routines; thus, PlotCIcon calls are not recorded in
pictures.

Operations
PROCEDURE

on

CGrafPort

SetPortPix

(pm:

Fields
PixMapHandle) ;

The SetPortPix call is analogous to SetPortBits, and should be used instead of SetPortBits
for cGrafPorts. It replaces the portPixMap field of the current cGrafPort with the specified
handle. SetPortPix has no effect when used with an old grafPort. If SetPortBits is called
when the current port is a cGrafPort, it does nothing.

V-76 Color QuickDraw Routines

Color QuickDraw
PROCEDURE

OpColor

(color:

RGBColor);

If the current port is a cGrafPort, the OpColor procedure sets the red, green, and blue

values used by the AddPin, SubPin, and Blend drawing modes. This information is

actually stored in the grafVars handle in the cGrafPort, but you should never need to
reference it directly. If the current port is a grafPort, OpColor has no effect.
PROCEDURE

HiliteColor

(color:RGBColor) ;

The highlight color is used by all drawing operations that use the highlight transfer mode.
When a cGrafPort is created, its highlight color is initialized from the global variable
HiliteRGB. The HiliteColor procedure allows you to change the highlighting color used by
the current port. This information is actually stored in the grafVars handle in the cGrafPort,
but you should never need to reference it directly. If the current port is a grafPort,
HiliteColor has no effect.
PROCEDURE

CharExtra

(extra:Fixed) ;

The CharExtra procedure sets the cGrafPort’s charExtra field, which specifies the number
of pixels by which to widen every character excluding the space character in a line of text.
The charExtra field is stored in a compressed format based on the txSize field, so you must
set txSize before calling CharExtra. The initial charExtra setting is 0. CharExtra will accept
a negative number. CharExtra has no effect on grafPorts.
PROCEDURE

SetStdCProcs

(VAR

cProcs:

CQDProcs) ;

This procedure sets all the fields of the given CQDProcs record to point to the standard
low-level routines. You can then change the ones you wish to point to your own routines.
For example, if your procedure that processes picture comments is named MyComments,
you will store @MyComments in the commentProc field of the CQD Procs record.
When drawing
SetStdProcs.

in a cGrafPort, your application must always use SetStdCProcs instead of

rs
2)

2
S
=)
=}w)

bee 4

x

i)

re

Low |

=

Operations
FUNCTION

on

Color

GetCTable

Tables

(ctID:

INTEGER):

CTabHandle;

The GetCTable routine allocates a new color table data structure, and initializes it using the

information in the resource of type 'clut' having the specified ID. If the specified resource

is not found, a NIL handle is returned.

If you place this handle into a pixMap, you should first dispose of the handle that was
already there.
The format of the 'clut' resource is given in the section “Color QuickDraw Resource
Formats’. Resource ID values 0..127 are reserved for system use. Any ‘clut' resources

Color QuickDraw Routines

V-77

Inside Macintosh

defined by your application should have IDs in the range 128..1023. This value must be in
the ctSeed field in the resource, and will be placed in the ctSeed field of the color table (for

color table identification). All other possible seed values are used to identify newly created
color tables, and color tables that have been modified.

If you modify a color table, you should invalidate it by changing its ctSeed field. You can
get a new unique value for ctSeed using the routine GetCTSeed, described in the Color
Manager chapter.
PROCEDURE

DisposCTable(cTable:

CTabHandle) ;

The DisposCTable procedure disposes the handle allocated for a color table.

COLOR

QUICKDRAW

RESOURCE

FORMATS

Several new resource types have been defined for use with Color QuickDraw. They are
‘ers:

Color

cursor

‘ppat'
‘eten'

Pixel
Color

Pattern resource type
Icon resource type

resource

‘elut.!

Color

Look-Up

Table

type

resource

type

The precise formats of resources of these types are given below.
It is important to note that resources are used somewhat differently by Color QuickDraw.
For instance, with old QuickDraw, you could do a GetCursor for each SetCursor, and the
same handle would be passed back to the application each time. With Color QuickDraw,

the color cursor, icon, and pattern are compound structures, more complex than a simple
resource handle. Color QuickDraw reads the requested resource, copies it, and then alters
the copy before passing it to the application. Each time you call GetCCursor, you get a new
copy of the cursor. This means that you should do one GetCCursor call for a cursor, even
if you do multiple SetCCursor calls. These new resource types should be marked as
purgeable if you are concerned about memory space.
Here are the resource formats of the resources used by Color QuickDraw.
measured from the beginning of the resource’s data.
‘ersr'

(Color

CCrsr

Cursor)

crsrType:
crsrMap:
crsrData:
crsrXData:

{data structure describing cursor}
[2 bytes] = $8001
[4 bytes] = offset to pixMap structure
[4 bytes] = offset to pixel data
[4 bytes] =0

crsrXHandle:
crsr1Data:

[4 bytes] =0
[32 bytes] = 1 bit image for cursor

crsrX Valid:

[2 bytes]

V-78 Color QuickDraw Resource Formats

=0

All offsets are

Color QuickDraw
crsrMask:
crsrHotSpot:

[32 bytes] = cursor’s mask
[4 bytes] = cursor’s hotSpot (v,h)

crsrID:

[4 bytes] =0

crsrXTable:
PixMap

[4 bytes] =0

{pixMap describing cursor’s pixel image}

baseAddr:

[4 bytes] = 0

bounds:
pmVersion:

[8 bytes] = boundary rectangle of image
[2 bytes] = 0

rowBytes:

packT ype:

packSize:

hRes:

[2 bytes] = rowBytes of image
[2 bytes] =0
[4 bytes] =0

[4 bytes] = $00480000

vRes:

[4 bytes]

pixelSize:

[2 bytes] = bits per pixel in image

pixelType:
cmpCount:

cmpSize:
planeBytes:
pmTable:
pmReserved:

pixel data

color table data

= $00480000

[2 bytes] = 0 = chunky
[2 bytes] = 1

[2 bytes] = pixelsize
[4 bytes] = 0
[4 bytes] = offset to color table data
[4 bytes] =0

[see below]
[see below]

data for cursor

data for color table

The crsrMap field of the CCrsr record contains an offset to the pixMap record from the

beginning of the resource data. The crsrData field of the CCrsr record contains an offset to
the pixel data from the beginning of the resource data. The pmTable field of the pixMap
record contains an offset to the color table data from the beginning of the resource data. The
size of the pixelData is calculated by subtracting the offset to the pixel data from the offset
to the color table data. The color table data consists of a color table record (ctSeed, ctFlags,
ctSize) followed by ctSize+1 color table entries. Each entry in the color table connects a
pixel value used in the pixel data to an actual RGB.
‘ppat'

(Pixel

b

‘2

<b
oS

=y

Pattern)

©
O°~

=

PixPat record {data structure describing pattern}
patT ype
[2 bytes] = 1 (full color pattern)
patMap
[4 bytes] = offset to pixMap record
patData
[4 bytes] = offset to pixel data
patXData
patX Valid
patX Map

PixMap

pat1 Data

baseAddr
rowBytes
bounds
pmVersion
packType
packSize
hRes
vRes

[4 bytes] = 0
[2 bytes]
=-l
[4 bytes] =0

[8 bytes] = 1 bit pattern data
{ pixMap describing pattern’s pixel image }
[4 bytes] = 0
[2 bytes] = rowBytes of image
[8 bytes] = boundary rectangle of image
[2 bytes] = 0
[2 bytes] = 0
[4 bytes] =0
[4 bytes] = $00480000
[4 bytes] = $00480000

Color QuickDraw Resource Formats V-79

i)

Lor

mS

=

|

Inside Macintosh

pixelType
pixelSize
cmpCount
cmpSize
planeBytes

[2 bytes] = 0 = chunky
[2 bytes] = bits per pixel in image
[2 bytes] = 1
[2 bytes] = pixelsize
[4 bytes] = 0

pmReserved

[4 bytes] =0

pmTable

pixel data

color table data

[4 bytes] = offset to color table data
[see below]

[see below]

data for pattern

data for color table

The patMap field of the pixPat record contains an offset to the pixMap record from the
beginning of the resource data. The patData field of the pixPat record contains an offset to

the pixel data from the beginning

of the resource data. The pmTable field of the pixMap

record contains an offset to the color table data from the beginning of the resource data. The
size of the pixelData is calculated by subtracting the offset to the pixel data from the offset
to the color table data. The color table data consists of a color table record (ctSeed, ctFlags,
ctSize) followed by ctSize+1 color table entries. Each entry in the color table connects a
pixel value used in the pixel data to an actual RGB.
‘cicn'

(Color

Icon)

IconPMap
baseAddr
rowBytes
bounds
pmVersion
packType
packSize

hRes

{pixMap describing icon’s pixel image}
[4 bytes] =0
[2 bytes] = rowBytes of image
[8 bytes] = boundary rectangle of image
[2 bytes] =0
[2 bytes] =0
[4 bytes] =0

[4 bytes] = $00480000

vRes
pixelType
pixelSize
cmpCount
cmpSize
planeBytes
pmTable
pmReserved
IconMask
baseAddr
rowBytes
bounds
IconBMap
baseAddr
rowBytes
bounds
IconData

[4 bytes] = $00480000
[2 bytes] = 0 = chunky
[2 bytes] = bits per pixel in image
[2 bytes] = 1
[2 bytes] = pixelsize
[4 bytes] =0
[4 bytes] =0
[4 bytes] =0
{Mask used when drawing icon}
[4 bytes] =0
[2 bytes] = rowBytes of image
[8 bytes] = boundary rectangle of image
{Image used when drawing to 1 bit screen}
[4 bytes] = 0
[2 bytes] = rowBytes of image
[8 bytes] = boundary rectangle of image
{placeholder for image’s handle}

MaskData

{the icon’s mask data }
[n bytes] n = IconMask.rowBytes*height
{the icon’s bitMap data }
[n bytes] n = IconBMap.rowBytes*height

BMapData

[4 bytes] = 0

V-80 Color QuickDraw Resource Formats

Color QuickDraw

PMapCTab
PMapData

{the icon’s color table }
[n bytes] n = 8+(ColorTable.ctSize+1)*CTEntrySize
{the icon’s image data }
[n bytes] n = IconPMap.rowBytes*height

In the calculations above:
height = IconPMap™.bounds.bottom—IconPMap™.bounds.top.
IconPMap is the pixMap describing the data in the IconData field. IconMask is the mask
that is to be applied to the data when it is drawn. IconBMap is a bitMap to be drawn when
the destination is only one or two pixels deep. If the rowbytes field of IconBMap is 0, then
no data is loaded in for the IconBMap, and IconPMap is always used when drawing the
icon. MaskData is the mask’s data. It is immediately followed by the bitMap’s data (which
may be NIL). Next is the color table describing the IconPMap, as shown below. The final
entry in the resource is the pixMap’s data.
‘clut'

(Color

Table)
ctSeed

[4 bytes] = 0

ctSize

[2 bytes] = #entries — 1

ctFlags
table data

[2 bytes] = $0000 if pixMap color table
= $8000 if device color table
[n bytes] n = 8*(ctSize+1)

The ‘clut' resource format is an exact duplicate of a color table in memory.

Each element in

the table data is four integers (eight bytes): a value field followed by red, green, and blue
values. If the color table is used to describe a pixMap, then ctFlags should be set to 0, and
the value field of each entry contains the pixel value to be associated with the following
RGB.

If the color table is used to describe a device, then ctFlags should be set to $8000,

and the value fields should be set to 0. In this case, the implicit values are based on each
entry’s position in the table.

There are several default color tables that are in the Macintosh II ROMs. There is one for
each of the standard pixel depths. The resource ID for each table is the same as the depth.
For example, the default color table used when you switch your system to 8 bits per pixel
mode is stored with resource ID = 8.
There is one other default color table.

This color table defines the eight QuickDraw colors,

the colors displayed by programs using the old QuickDraw model. This color table has
ID = 127. Its values are given in the section “Setting the Foreground and Background
Colors”’.

USING TEXT WITH QUICKDRAW
This section explains those QuickDraw features which provide enhanced text handling for

the Macintosh Plus, Macintosh SE, and Macintosh II. The drawing mode recommended for

all applications is SrcOr, because it uses the least memory and will draw the entire character

Using Text with QuickDraw V-81

>
OQ
S
=)

=

2

=fo)
~
=
=
po

Kaine

=

Inside Macintosh

in all cases. The SrcOr mode will only affect other parts of existing characters if the
characters overlap. In srcOr mode the color of the character is determined by the
foreground color, although text drawing is fastest when the foreground color is black.
With QuickDraw, characters can kern to the left and to the right. QuickDraw begins
drawing a series of characters at the specified pen position plus the kernMax field (part of
the Font record), plus any kerning below the baseline caused by italicizing the font. (The
kernMax field denotes the kerning allowed by a given font; since its value is normally
negative, most fonts kern to the left. Italicizing also normally moves the pen to the left.)
QuickDraw then draws through the ending pen position, plus any kerning above the
baseline caused by italicizing the font (normally to the right), plus any space required to
handle the outlined or shadowed part of the character.
To draw text in any mode, including the kerned part of the leading and trailing characters, it
is best to draw the entire line of text at once. If the line must be drawn in pieces, it is best to
end each piece with a space character, so that the succeeding piece can harmlessly kern left,
and the last character drawn (a space) will not have any right kerning clipped.
Macintosh Plus and Macintosh SE Note: The Macintosh Plus and Macintosh
SE versions of QuickDraw clip a leading left-kerning character, and do not take
italicizing into account when positioning the pen. Also, it adds a constant of 32 to the
width of the character imaging rectangle, causing large italicized fonts to have the
rightmost character clipped in drawing modes other than srcOr.
The outline and shadow styles cause the outline and shadow of the character to be drawn in
the foreground color. The inside of the character, if drawn at all, is drawn in the

background color. The center of shadowed or outlined text is drawn in a grafPort in scrBic
mode if the text mode is srcOr, for compatibility with old applications. This allows black
text with a white outline on an arbitrary background. If the text mode is srcBic, the center

of shadowed or outlined text is drawn in srcOr.

The style underline draws the underline through the entire text line, from the pen starting
position through the ending position, plus any offsets from font or italic kerning, as
described above. If the underline is outlined or shadowed, the ends aren’t capped, that is,
consecutively drawn pieces of text should maintain a continuous underline.

Macintosh Plus and Macintosh SE Note: QuickDraw clips the right edge of
the underline to the ending pen position, causing outlined or shadowed underlines to
match imperfectly when text is drawn in sections.

One of the reasons that SrcOr is recommended is that the maximum stack space required for
a text font drawing operation can be considerable. Text drawing uses a minimum amount of
stack if the mode is srcOr, the forecolor is black, the visRgn and clipRgn are rectangular
(or at least the destination of the text is contained within a rectangular portion of the
visRgn), the text is not scaled, and the text does not have to be italicized, boldfaced,
outlined, or shadowed by QuickDraw. Otherwise, the amount of stack required to draw all
of the text at once depends most on the size and width of the the text and the depth of the
destination.
If QuickDraw can’t get enough stack space to draw an entire string at once, it will draw the
string in pieces. This can produce disconcerting results in modes other than srcOr or srcBic

V-82 Using Text with QuickDraw

Color QuickDraw
if some of the characters overlap because of kerning or italicizing. If the mode is srcCopy,
overlapping characters will be clipped by the last drawn character. If the mode is srcXor,
pixels where the characters overlap are not drawn at all. If the mode is one of the arithmetic
modes, the arithmetic rules are followed, ignoring that the destination may include part of
the string being drawn.

The stack space required for a drawing operation on the Macintosh II is roughly given by
this calculation:
(text width) * (text height) * (font depth) / (8 bits per byte ) + 3K
Font depth normally equals the screen depth. If the amount of stack space available is
small (less than 3.5K), QuickDraw instead uses a font depth of 1, which is slow, but uses
less stack space.
On the Macintosh Plus, the required stack space is roughly equal to
(text width) * (text height) / (8 bits per byte ) + 2K

Text

Mask

Mode

For the Macintosh II, the maskConstant may be added to another drawing mode to cause
just the character portion of the text to be applied in the current transfer mode to the
destination. If the text font contains more than one color, or if the drawing mode is an

arithmetic mode or hilite mode, the mask mode causes only the portion of the characters not

equal to the background to be drawn.

The arithmetic drawing modes and hilite mode apply the character’s background to the

destination; this can lead to undesirable results if the text is drawn in pieces. The leftmost

part of a text piece is drawn on top of a previous text piece if the font kerns to the left. The
maskMode supplied in addition to these modes causes only the foreground part of the
character to be drawn. The only reasonable way to kern to the right in text mask mode is to
use srcOr, or to add trailing characters. This is because the rightmost kern is clipped.

Drawing

Multibit

=

=
<

=

64;

with

S=
©
=°
=

CONST

=

2

ony |

The constant used with maskMode is

mask

a

Fonts

Multibit fonts may have a specific color. The transfer modes may not produce the desired

results with a multibit font. The arithmetic modes, transparent mode, and hilite mode work

equally well with single bit and multibit fonts.

Unlike single bit fonts, multibit fonts draw quickly in srcOr only if the foreground is white.
Single bit fonts draw quickly in srcOr only if the foreground is black. Grayscale fonts
produce a spectrum of colors, rather than just the foreground and background colors.

Using Text with QuickDraw V-&3

Inside Macintosh

Fractional

Character

Positioning

CGrafPorts maintain the fractional horizontal pen position, so that a series of text drawing
calls will accumulate the fractional position. The horizontal pen fraction is initially set to
1/2. InitPort, Move, MoveTo, Line and LineTo reset the pen position to 1/2. For an old

grafPort, the pen fraction is hard-coded to 1/2.

COLOR

PICTURE FORMAT

With the introduction of the Macintosh II, the QuickDraw picture structure has been
extended to include new color graphics opcodes. The new version 2 pictures and opcodes
solve many of the major problems encountered by developers in using PICT files, and
enable future expandibility. For example, it is now possible to specify the resolution of
bitMap data. Color can also be specified, but only chunky pixels (contiguously stored pixel
components) are currently recognized by Color QuickDraw. Your application only needs to
generate or recognize the chunky pixel format. This format is indicated by an image or
pixMap with a cmpCount = 1.

Most existing applications can use version 2 pictures without modification. On a Macintosh

II, version 2 pictures will draw in color (if drawn directly to the screen). Currently, they
will print using the old QuickDraw colors. Eventually, new print drivers will be able to take
advantage of the new color information.
On a Macintosh 512K enhanced, Macintosh Plus, and Macintosh SE, a patch in the System

file beginning with version 4.1 provides QuickDraw with the capability to convert and
display version 2 pictures. The original Macintosh and Macintosh 512 can’t display version
2 pictures.

Applications that generate pictures in the QuickDraw picture format are free to use any or all
available features to support their particular needs. Some will use only the imaging
features. You may wish to include comments in the picture that are pertinent to the needs of
your application. In general, put a minimal amount of information in your PICT files and
avoid redundancy. It’s reasonable for receiving applications to ignore picture opcodes that
aren’t needed.

Differences

Between

Version

1 and

Version

2 Pictures

The major differences between version 1 and version 2 pictures are listed below.
= Version | opcodes are a single byte; version 2 opcodes are 2 bytes in length. This
means that old opcodes in a version 2 picture take up two bytes, not one.
= Version | data may start on byte boundaries; version 2 opcodes and data are always
word-aligned.
m In version 2, the high bit of the rowBytes field is used to indicate a pixMap instead of
a bitMap; pixData then replaces bitData.

V-84 Color Picture Format

Color QuickDraw
= All unused version 2 opcodes, as well as the number of data bytes associated with
each, have been defined. This was done so that picture parsing code can safely ignore
unknown opcodes, enabling future use of these opcodes in a backward-compatible
manner.

Drawing

With

Version

2 Pictures

in Old

GrafPorts

Enhancements to the DrawPicture routine allow pictures created with Color QuickDraw to
be used in either a cGrafPort or an old-style grafPort. You can create a picture using the
new drawing commands in a cGrafPort, cut it, and then paste it into an application that
draws into an old grafPort. The picture will lose some of its detail when transferred in this
way, but should be sufficient for most purposes. The following considerations apply to the
use of this technique:
a The rgbFgColor and rbgBkColor fields are mapped to the old-style Quickdraw
constant (one of eight) that most closely approximates that color. For a grafPort with
depth greater than one, even old applications will be able to draw color pictures.
a Patterns created using MakeRGBPat are drawn as old-style patterns having
approximately the same luminance as the original pattern.
a Other new patterns are replaced by the old-style pattern contained in the pat1 Data field
of the PixPat data structure. This field is initialized to 50% gray by the NewPixPat
routine, and is initialized from the resource in a GetPixPat call.
w PixMaps in the picture are drawn without interpretation. The CopyBits call performs
all necessary mapping to the destination screen. If the picture is drawn on a Macintosh
Plus or a Macintosh SE, or if the BitsProc routine has been replaced by the
application, the pixMap is converted to a bitMap before it’s drawn.
u Changes to the ChExtra and pnLocHFrac fields, and the Hilite color and OpColor, are
ignored.
A new standard opcodeProc, SetStdCProc, is called by QuickDraw when it is playing back
a color picture and it sees a new opcode that it doesn’t recognize. The default routine
simply reads and ignores all undefined opcodes.

S
2)
2
=)

Lew |

f
=.
O

ee

o

Ler

=

=

Picture

Representation

The PICT file (defined in Macintosh Technical Note #27) is a data fork file with a 512-byte

header, followed by a picture (see Figure 6). This data fork file contains a QuickDraw (and
now, Color QuickDraw) data structure within which a graphic application, using standard
QuickDraw calls, places drawing opcodes to represent an object or image graphic data. In
the QuickDraw picture format, pictures consist of opcodes followed by picture data.

Color Picture Format V-85

|

Inside Macintosh

PICT file
(type=PICT)

Data fork

Resource fork

512-byte
header

picSize
| picFrame

Topcode

4

~=—S | This fork is

| picture data |

empty

fe

PICT files

—

|
®

in

=

| picture data |
EndOfPicture
Figure 6. PICT file format.

Picture

Parsing

The first 512 bytes of a PICT data file contain application-specific header information. Each
QuickDraw (and Color QuickDraw) picture definition consists of a fixed-size header
containing information about the size, scaling, and version of the picture, followed by the
opcodes and picture data defining the objects drawn between the OpenPicture and
ClosePicture calls.
When the OpenPicture routine is called and the port is an old grafPort, a version 1
picture is opened. When the OpenPicture routine is called and the port is a cGrafPort, then
a version 2 picture is opened. If any fields in the grafPort are different than the default
entries, those fields that are different get recorded in the picture.
Version 4.1 of the Macintosh System file incorporates a patch to QuickDraw that will
enable QuickDraw (on machines with 128K or larger ROMs) to parse a version 2 PICT
file, read it completely, attempt to convert all Color QuickDraw color opcodes to a suitable
black-and-white representation, and draw the picture in an old grafPort. If you are trying to
display a version 2 picture on a Macintosh without the system patch, QuickDraw won’t be
able to draw the picture.
Picture

Record

Structure

The Pascal record structure of version 1 and version 2 pictures is exactly the same. In both,
the picture begins with a picSize, then a picFrame (rect), followed by the picture definition

V-86 Color Picture

Format

Color QuickDraw
data. Since a picture may include any sequence of drawing commands, its data structure is
a variable-length entity. It consists of two fixed-length fields followed by a variable-length
field:
TYPE

Picture

=

RECORD

picSize:

INTEGER;

{low
{

picFrame:

{picture

Rect;

definition

order

16

bits

of

picture

}

size}

{picture

frame,

{

reference

{

the

used

for

picture

is

as

}

scaling
drawn

when

}

}

data}

END;

To maintain compatibility with the original picture format, the picSize field has not been
changed in version 2 pictures. However, the information in this field is only useful if your
application supports version | pictures not exceeding 32K bytes in size. Because pictures
can be much larger than the 32K limit imposed by the 2-byte picSize field, use the
GetHandleSize call to determine picture size if the picture is in memory or the file size
returned in pBFGetInfo if the picture resides in a file.
The picFrame field is the picture frame that surrounds the picture and gives a frame of
reference for scaling when the picture is played back. The rest of the structure contains a
compact representation of the image defined by the opcodes. The picture definition data
consists of a sequence of the opcodes listed in Table 3 in the Pict Opcodes section, each
followed by zero or more bytes of data. Every opcode has an implicit or explicit size
associated with it that indicates the number of data bytes following that opcode, ranging

from 2 to 232 bytes (this maximum number of bytes applies to version 2 pictures only).
Picture

pan

Spooling

=

In the past, images rarely exceeded the 32K practical limit placed on resources. Today,
with the advent of scanners and other image input products, images may easily exceed this

size. This increase in image size necessitates a means for handling

pictures that are too

large to reside entirely in memory. One solution is to place the picture in the data fork of a
PICT file, and spool it in as needed. To read the file, an application can simply replace the
QuickDraw default getPicProc routine with a procedure (getPICTData) that reads the
picture data from a disk file; the disk access would be transparent. Note that this technique
applies equally to version 1 (byte-opcode) and version 2 (word-opcode) pictures.

Spooling

a Picture

From

Disk

In order to display pictures of arbitrary size, an application must be able to import a
QuickDraw picture from a file of type PICT. (This is the file type produced by a Save As
command from MacDraw® with the PICT option selected.) What follows is a small
program fragment that demonstrates how to spool in a picture from the data fork of a PICT
file. The picture can be larger than the historical 32K resource size limitation.

Color Picture Format V-87

=

=
=p
OQ
=

o
as
—_

<A

=

Inside Macintosh
{ The following
{ main level of

variable and procedure
the program }

must

be

at

the

}

VAR
globalRef:
PROCEDURE

GetPICTData(dataPtr:

{replacement
VAR

INTEGER;

for

err

getPicProc

:

byteCount:

INTEGER) ;

INTEGER;

longCount:

BEGIN

Ptr;

routine}

LONGINT;

longCount
:= byteCount;
{longCount
is a Pascal VAR parameter
and must
err
:= FSRead(globalRef, longCount, dataPtr) ;

{ignore

errors

here

since

it

is

unclear

from

a

PICT

file

how

be

to

a

LONGINT}

handle

them}

selected

by

user}

Standard

File

CGrafPort

(a

END;
PROCEDURE

{procedure
VAR

GetandDrawPICTFile;

to

draw

in

a

picture

wher: Point;
{where to display
reply: SFReply;
{reply record}
myFileTypes:
SFTypeList;
{more
NumFileTypes:
INTEGER;
err:

OSErr;

myProcs:

QDProcs;

{use

PICTHand:

PicHandle;

{

longCount:
LONGINT;
myPB:
ParamBlockRec;

dialog}
of

CQDProcs

window) }

{we

need

the

the

for
a

a

picture

handle

for

goodies}
color

}

DrawPicture}

BEGIN

wher.h
:= 20;
wher.v := 20;
NumFileTypes
:= 1; {Display PICT files}
myFileTypes[0]
:= 'PICT';
SFGetFile (wher, '',NIL,NumFileTypes,myFileTypes,
NIL, reply) ;
IF reply.good THEN BEGIN
err

:=

FSOpen(reply.fname,

SetStdProcs(myProcs);

{use

reply.vrefnum,globalRef)
SetStdCProcs

myWindow’.grafProcs
:= @myProcs;
myProcs.getPicProc
:= @GetPICTData;
PICTHand

{get

one

:=

the

PicHandle

size

of

(NewHandle

(size

word

(SizeOf

+

frame

for

a

(Picture)

;

CGrafPort}

));

rectangle) }

{skip
(so to speak)
the MacDraw
header block}
err
:= SetFPos(globalRef,fsFromStart,
512) ;

longCount

:=

SizeOf

(Picture)

;

{read in the
(obsolete)
size word and the picture
frame}
err
:= FSRead(globalRef,
longCount, Ptr (PICTHand’%) ) ;

V-88 Color Picture Format

Color QuickDraw
DrawPicture
(PICTHand, PICTHand**.picFrame)
{inside

of

{

getPicProc

{

get

{

we

err

have

DrawPicture,

to

get

intercepted

getPicProc,

:=

QD

makes

actual

picture

repeated

GetPicProc,

instead

of

;

calls

opcodes

QD

will

calling

the

and

call

to

data.

}

myProcs

default

Since
to

procedure}

}

|}

FSClose(globalRef) ;

myWindow*.grafProcs
:= NIL;
DisposHandle
(Handle (PICTHand) ) ;
END;

{IF

reply.good}

END;

Spooling

a Picture

to a File

Spooling a picture out to a file is equally straightforward. By replacing the standard
putPicProc with your own procedure, you can create a PICT file and spool the picture data
out to the file.
Here is a sample of code to use as a guide:
{these variables and PutPICTData must be at the main program
VAR
PICTcount:
LONGINT;
{the current size of the picture}
globalRef:
INTEGER;
{the file system reference number}
newPiCThand:
PicHandle;
{this
is the replacement
for
PROCEDURE
PutPICTData(dataPtr:

VAR

longCount:

longCount

:=

PICTCount

the StdPutPic
routine}
Ptr;
byteCount:
INTEGER) ;

LONGINT;

err:
INTEGER;
BEGIN
{unfortunately,

we

don't

byteCount;

:=

PICTCount

+

level}

know

what

to

do

with

r
O

errors}

o

byteCount;

err := FSWrite(globalRef,
longCount,
dataPtr);
{ignore error...}
IF newPICTHand <> NIL THEN newPICTHand**.picSize
:= PICTCount;

{update
END;

so

QD

can

track

the

size

for

oddness

and

pad

out

to

full

S

words}

{Note that this assumes the picture is entirely in memory which wouldn't
{ always be the case. You could (in effect)
be feeding the StdGetPic
}
{ procedure at the same time,
or simply spooling while drawing. }
PROCEDURE
SpoolOutPICTFile(PICTHand:
VAR
err:
OSErr;
i:

INTEGER;

wher:

Point;

{

reply:

SFReply;

where

longCount,
longZero:
pframe:
Rect;

to

PicHandle

display

{

reply
{use

CQDProcs

wher.h
:= 20;
wher.v
:= 20;
{get a file to output
SFPutFile(wher,
'Save

to}
the

PICT

BEGIN

IF

myProcs:

QDProcs;

reply.good

THEN

dialog

LONGINT;

record

}

as:',

for

a

{the

picture

to

spool});

}

CGrafPort

‘untitled',

(a

NIL,

color

window) }

reply);

Color Picture Format V-89

}

lo
S.
2.
i)
=y

po)

=

Inside Macintosh
BEGIN
err
:= Create(reply.fname,
IF
(err = noerr)
| (err =
BEGIN

{now

open

the

target

reply.vrefnum,
dupfnerr)
THEN

'??7??',

'PICT');

file

to

to

signal (FSOpen(reply.fname,
SetStdProcs(myProcs);
{use

and

prepare

spool

it}

reply.vrefnum,
globalRef));
SetStdCProcs
for a CGrafPort}

myWindow’*.grafProcs
:= @myProcs;
myProcs.putPicProc
:= @putPICTdata;
longZero
:= 0;
longCount

PIcTCount

{now

write

{

out

:=
the

:=

4;

SizeOf (Picture) ;

512

byte

header

and

zero

(initially)

the

}

Picture structure}
FOR i := 1 TO 512 DIV 4 + SizeOf(Picture)
DO
Signal (FSWrite(globalRef,
longCount,
@longZero)
);
{open a new picture and draw the old one to it; this will convert
{ the old picture to fit the type of GrafPort to which we are }
{

currently

set}

pFrame
:= PICThand**.picFrame;
newPICTHand
:= NIL;
newPICTHand
:= OpenPicture(pFrame) ;
DrawPicture (PICTHand, pFrame);
{draw the picture so the
bottleneck will be used. In real life you could be spooling while
doing drawing commands
(you might not use DrawPicture) }
ClosePicture;
Signal (SetFPos(globalRef,
fsFromStart,
512));
{skip the MacDraw header}
longCount
:= SizeOf (Picture) ;
{write

{

the

out

the

correct

(low

word

of

the)

size

beginning}
Signal (FSWrite(globalRef,
longCount,
Signal (FSClose (globalRef) ) ;
myWindow*.grafProcs
:= NIL;
KillPicture (newPICTHand) ;

and

the

frame

at

}

Ptr(newPICTHand™%)
) ) ;

END

ELSE

Signal(err);

END;
{IF reply.good}
END;
{OutPICT}

Drawing

to an

Offscreen

Pixel

Map

With the advent of high resolution output devices such as laser printers, it has become
necessary to support bitmap images at resolutions higher than those supported by the
screen. To speed up the interactive manipulation of high-resolution pixel map images,
developers may want to first draw them into an off screen pixel map at screen resolution
and retain this screen version as long as the document is open.
Note: You can use the formula shown in the section “Sample PICT file” to
calculate the resolution of the source data. How to draw into an offscreen pixmap is

V-90 Color Picture Format

}

Color QuickDraw

described in Macintosh Technical Note #120; the Graphics Devices chapter also
contains a section describing how to draw to an offscreen device.

New

GrafProcs

Record

The entire opcode space has been defined or reserved, as shown in the PICT Opcodes
section in Table 3, and a new set of routines has been added to the grafProcs record. These
changes provide support for anticipated future enhancements in a way that won’t cause old
applications to crash. It works like this: when Color QuickDraw encounters an unused
opcode, it calls the new opcodeProc routine to parse the opcode data. By default, this
routine simply ignores the data, since no new opcodes are defined (other than HeaderOp,
which is also ignored).
Color QuickDraw has replaced the QDProcs record with a CQDProcs record. In a new
grafPort, you should never use the SetStdProcs routine. If you do, it will return the old
QDProcs record, which won’t contain an entry for the stdOpcodeProc. If you don’t use
the new SetStdCProcs routine, the first color picture that you try to display may crash your
system.
The CQDProcs record structure is shown below. Only the last seven fields are new; the rest

of the fields are the same as those in the QDProcs record.
CQDProcsPtr
CQDProcs

=
=

*“CQDProcs
RECORD
textProc:

PCr;

lineProc:

Ptre

rectProc:
rRectProc:

PEX;
PUx?

mS

ovalProc:
arcProc:

Ptr;
Ptr?

QD?
=

polyProc:

Ptr;

=

rgnProc:
bitsProc:
commentProc:

Ptr;
Ptr;
Per;

©
S
o

txMeasProc:

Per;

S

putPicProc:
opcodeProc:

Ptr;
Pur;

{fields

newProcl:
newProc2:
newProc3:
newProc4:
newProcd:

Ptr;
Ptr:
Ptr;
Ptr;
Ptr;

{reserved
{reserved
{reserved
{reserved
{reserved

for
for
for
for
for

future
future
future
future
future

use}
use}
use}
use}
use}

newProcé6:

Ptx;

{reserved

for

future

use}

getPicProc:

Ptr;

=

added

to

QDProcs}

END;

Color Picture Format V-9]1

Inside Macintosh

Picture

Compatibility

Many applications already support PICT resources larger than 32K. The 128K ROMs (and
later) allow pictures as large as memory (or spooling) will accommodate. This was made
possible by having QuickDraw ignore the size word and simply read the picture until the

end-of-picture opcode is reached.

Note: For maximum safety and convenience, let QuickDraw generate and interpret
your pictures.
While the PICT data formats described in this section allow you to read or write picture
data directly, it’s best to let DrawPicture or OpenPicture and ClosePicture process the
opcodes.
One reason to read a picture directly by scanning the opcodes is to disassemble it; for
example, extracting a Color QuickDraw pixel map to store in a private data structure. This
shouldn’t normally be necessary, unless your application is running on a CPU other than
the Macintosh. You wouldn’t need to do it, of course, if you were using Color QuickDraw.
If your application does use the picture data, be sure it checks the version information. You
may want to include an alert box in your application, indicating to users whether a picture
was created using a later version of the picture format than is currently recognized by your
application, and letting them know that some elements of the picture can’t be displayed. If
the version information indicates a QuickDraw picture version later than the one recognized
by your application, your program should skip over the new opcodes and only attempt to
parse the opcodes it knows.
As with reading picture data directly, it’s best to use QuickDraw to create data in the PICT

format. If you need to create PICT format data directly, it’s essential that you understand
and follow the format presented in Table 3 and thoroughly test the data produced on both
color and black and white Macintosh machines.
Picture

Format

This section describes the internal structure of the QuickDraw picture, consisting of a fixedlength header (which is different for version 1 and version 2 pictures), followed by
variable-sized picture data. Your picture structure must follow the order shown in the
examples below.
The two fixed-length fields, picSize and picFrame, are the same for version 1 and version 2

pictures.

picSize:

INTEGER;

{low-order

picFrame:

RECT;

{picture

16
frame,

bits

of

used

picture
as

scaling

size}
reference}

Following these fields is a variable amount of opcode-driven data. Opcodes represent
drawing commands and parameters that affect those drawing commands in the picture. The

V-92 Color Picture

Format

Color QuickDraw

first opcode in any picture must be the version opcode, followed by the version number of
the picture.

Picture

Definition:

Version

1

In a version 1 picture, the version opcode is $11, which is followed by version number
$01. When parsing a version 1 picture, Color QuickDraw (or a patched QuickDraw)
assumes it’s reading an old picture, fetching a byte at a time as opcodes. An end-of-picture
byte ($FF) after the last opcode or data byte in the file signals the end of the data stream.
Picture

Header

(fixed size of 2 bytes):

S11

BYTE

$01

Picture

Definition

Data

opcode

data
.
opcode
data
.

opcode}

{version

number

BYTE

{one

drawing

command}

BYTE

{one

drawing

command}

{end-of-picture

Definition:

of

picture}

(variable sized):

SFF
Picture

{version

BYTE

Version

opcode}

2

In a version 2 picture, the first opcode is a two-byte version opcode ($0011). This is
followed by a two-byte version number ($02FF). On machines without the 4.1 System
file, the first $00 byte is skipped, then the $11 is interpreted as a version opcode. On a

Macintosh II (or a Macintosh with System file 4.1 or later), this field identifies the picture

as a version 2 picture, and all subsequent opcodes are read as words (which are wordaligned within the picture). On a Macintosh without the 4.1 System patch, the $02 is read
as the version number, then the $FF is read and interpreted as the end-of-picture opcode.
For this reason, DrawPicture terminates without drawing anything.

Picture

Header

(fixed

size

$0011

SO2FF

$0C00

24

bytes

of 30

of

{version

opcode}

WORD

{reserved

header

data

{reserved

o

Lome

number
for

of

new

picture}

opcode}

future

Apple

Color Picture

use}

Format V-93

4

©

&=

~~

o

Leow

=

bytes):
{version

©

=

WORD

WORD

fae

4

Inside Macintosh

Picture

Definition

Data

opcode
data
opcode
data
.

WORD
:
WORD

SOOFF

WORD

(variable

sized):

{one

drawing

command}

{one

drawing

command}

{end-of-picture

opcode}

For future expandibility, the second opcode in every version 2 picture must be a reserved
header opcode, followed by 24 bytes of data that aren’t used by your application.
PicComments
If your application requires capability beyond that provided by the picture opcodes, the
picComment opcode allows data or commands to be passed directly to the output device.
PicComments enable MacDraw, for example, to reconstruct graphics primitives not found
in QuickDraw (such as rotated text) that are received either from the Clipboard or from
another application. PicComments are also used as a means of communicating more
effectively with the LaserWriter and with other applications via the scrap or the PICT data
file.
Because some operations (like splines and rotated text) can be implemented more efficiently
by the LaserWriter, some of the picture comments are designed to be issued along with

QuickDraw commands that simulate the commented commands on the Macintosh screen. If

the printer you are using has not implemented the comment commands, it ignores them and
simulates the operations using the accompanying QuickDraw commands. Otherwise, it
uses the comments to implement the desired effect and ignores the appropriate QuickDrawsimulated commands.
Note: The picture comments used by MacDraw are listed and described in
Macintosh Technical Note #27.
If you are going to produce or modify your own picture, the structure and use of these
comments must be precise. The comments and the embedded QuickDraw commands must
come in the correct sequence in order to work properly.
Note: Apple is currently investigating a method to register picComments. If you
intend to use new picComments in your application, you must contact Apple’s
Developer Technical Support to avoid conflict with picComment numbers used by
other developers.

V-94 Color Picture Format

Color QuickDraw

Sample

PICT

File

An example of a version 2 picture data file that can display a single image is shown in Table
1. Applications that generate picture data should set the resolution of the image source data

in the hRes and vRes fields of the PICT file. It’s recommended, however, that you

calculate the image resolution anyway, using
to the following formulas:

the values for srcRect and dstRect according

horizontal resolution (hRes) =

width of srcRect

x 72

vertical resolution (vRes)

heightofsrcRect

x 72

=

width of dstRect

height of dstRect

Table 1. PICT file example
(in

Picture

Size
bytes)

Name

Description

2
8

picSize
picFrame

low word of picture size
rectangular bounding box of picture, at
72 dpi

2
2
2
4.

version op
version
Header op
size

16

fBBox

version opcode = $0011
version number = $02FF
header opcode = $0C00
total size of picture in bytes
(—1 for version 2 pictures)

>
&:

4

reserved

2

opbitsRect

(—1 for version 2 pictures)
reserved for future Apple use
(—1 for version 2 pictures)

©
=.
=
=

8

bounds

2
2
4

pm Version
packType
packSize

integer, must have high bit set to signal
pixMap
rectangle, bounding rectangle at source
resolution
integer, pixMap version number
integer, defines packing format
LongInt, length of pixel data

4

vRes

fixed, vertical resolution (dpi) of source

2
2
2
2

pixelType
pixelSize
cmpCount
cmpSize

Definition

Zz

4

Data:

rowBytes

hRes

fixed-point bounding box

bitMap opcode = $0090

fixed, horizontal resolution (dpi) of

source data

data
integer, defines pixel type
integer, number of bits in pixel
integer, number of components in pixel
integer, number of bits per component

Color Picture Format V-95

S

3

Inside Macintosh

Table 1. PICT file example (Continued)
(in

Size

Name

4

planeBytes

4
2

pmReserved
ctSeed
ctFlags

8

srcRect

bytes)

2
(ctSize+1) * 8

color table = 0

ctSize
ctTable

integer, number of entries in ctTable —1
color lookup table data

8

dstRect

2
see Table 5

mode
pixData

Picture

FUNCTION

LonglInt, offset to next plane

pmTable

2

Color

Description

reserved = 0
LongInt, color table seed
integer, flags for color table

rectangle, source rectangle at source
resolution
rectangle, destination rectangle at 72 dpi
resolution
integer, transfer mode
pixel data

endPICT op

end-of-picture opcode = $00FF

Routines

OpenPicture

(picFrame:

Rect)

:

PicHandle;

The OpenPicture routine has been modified to take advantage of QuickDraw’s new color
capabilities. If the current port is a cGrafPort, then OpenPicture automatically opens a
version 2 picture, as described in the previous section. As before, you close the picture
using ClosePicture and draw the picture using DrawPicture.

PICT OPCODES
The opcode information in Table 3 is provided for the purpose of debugging applicationgenerated PICT files. Your application should generate and read PICT files only by using
standard QuickDraw or Color QuickDraw routines (OpenPicture, ClosePicture).
The data types listed in Table 2 are used in the Table 3 opcode definitions. Data formats are
described in Volume I.

V-96 PICT Opcodes

Color QuickDraw
Table 2. Data types

Type

Size

v1 opcode
v2 opcode
integer
long integer
mode
point
0..255
—128..127
rect
poly
region
fixed-point number
pattern
rowbytes

1 byte
2 bytes
2 bytes
4 bytes
2 bytes
4 bytes
1 byte
1 byte (signed)
8 bytes (top, left, bottom, right: integer)
10+ bytes
10+ bytes
4 bytes
8 bytes
2 bytes (always an even quantity)

Valid picture opcodes are listed in Table 3. New opcodes or those altered for version 2
picture files are indicated by a leading asterisk (*). The unused opcodes found throughout
the table are reserved for Apple use. The length of the data that follows these opcodes is
pre-defined, so if they are encountered in pictures, they can simply be skipped. By default,
Color QuickDraw reads and then ignores these opcodes.
Table 3.

PICT opcodes

Opcode

Name

$0000

$0001
$0002
$0003

$0004
$0005
$0006
$0007
$0008

$0009
SOOOA
$000B
$000C
$000D
$000E
SO00F
$0010
$0011
$0012

NOP

Description

Data

nop

0

Clip
BkPat

clip
background

TxFace
TxMode

text
text

TxFont

text

font

face
mode

(in

region
8

pattern

(word)

(byte)
(word)

PnPat
FillPat
OvSize
Origin
TxSize
FgColor
BkColor
TxRatio
Version
*BkPixPat

pen pattern
fill pattern
oval size
(point)
dh, dv (word)
text size
(word)
foreground color
(long)
background color
(long)
numer
(point),
denom
(point)
version
(byte)
color background pattern

mode

(word)

size

2

space extra
(fixed
pen size
(point)
pen

=

s

point)

S
as
&
=

4
4

2

8
8
4
4
2
4
4
8
1
variable:
see

Oo

Yo

ni
2

SpExtra
PnSize

PnMode

Size

bytes)

Table

4

PICT Opcodes V-97

Inside Macintosh
PICT opcodes (Continued)

Opcode

Name

$0013

*PnPixPat

color

pen

$0014

*Fil1lPixPat

color

fill

$0015

*PnLocHFrac

$0016

$0017

Description

Data Size
(in bytes)
pattern

pattern

fractional

*ChExtra

$001B

*RGBBkCol

RGB

$001C

*HiliteMode
*HiliteColor

hilite mode
flag
RGB hilite
color

$001E
$O001F

*DefHilite

$0020
$0021
$0022

Use default hilite
RGB OpColor for
arithmetic modes

Line
LineFrom
ShortLine

$0023
$0024

ShortLineFrom
*reserved

for

Apple

use

$0025

*reserved

for

Apple

use

$0026

*reserved

for

Apple

use

$0027

*reserved

for

Apple

use

$0028

LongText

length
txLoc

$0029

DHText

Gh

(0..255),

count

2+

text

$002A

DVText

adv

(0..255),

count

2+

text

$002B

DHDVText

$002C

*reserved

for

Apple

use

$002D

*reserved

for

Apple

use

$002E

*reserved

$002F

*reserved

$0030
$0031

paintRect

*OpColor

backColor

pnLoc

(point),

pnLoc

(point,

newPt

length

opcode
length
opcode

frameRect

V-98 PICT Opcodes

for

Apple
Apple

+

t++ttett

opcode

dv

2 bytes
data

data

2

data

2 bytes
data
2 bytes

data

+ data
(point),

text

(0..255),

text

data
count

(0.255),
ESxE
dh, adv (0. .255);,
(0....255),,. test
opcode
length

opcode

use
use

opcode

length
opcode

length
rect
rect

2 bytes
data

2+

data

2+

data

length

length
5 + text

3

data

2+ data
length

2

bytes

data

2

bytes

data

data

2+ data
length
2+ data
length

count

data

data
2 bytes

(point)

variable:
see Table
variable:
see Table
0
variable:
see Table
0
variable:
see Table
8
4
6

2

bytes

data

(0..255),

length

for

dh,

(-128..127)
dh, dv (-128..127)
opcode
length

color

newPt

(point)

t++ettte+et

$001D

use
use
use

character

$0018
$0019

*RGBFgCol

Apple
Apple
Apple

position

*reserved
*reserved
*reserved

SO01A

for
for
for

pen

extra
for each
opcode
opcode
opcode
RGB foreColor

variable:
see Table
variable:
see Table
OOON N

Table 3.

+

text

2+

data

2+

data

2+

data

length
length

data

length

8
8

Color QuickDraw
Table 3.

PICT opcodes (Continued)

Opcode

Name

$0045
$0046
$0047
$0048
$0049

SO04A
$004B
$004c
$004D
$004E
$004F
$0050

$0051

$0052

$0053

$0054
$0055
$0056
$0057
$0058
$0059

SOO5A
$005B
$005C
$005D

SO05E
SOO5F
$0060

$0061
$0062
$0063

use

Apple
Apple

use

use

paintSameRect
eraseSameRect

invertSameRect
£illSameRect
*reserved
for
*reserved
for

*reserved for
frameRRect

Apple

use
use

Apple

use

*reserved
for Apple
*reserved
for Apple
frameSameRRect

use
use

paintSameRRect

invertSameRRect
£i11SameRRect
*reserved for Apple
*reserved

frameOval

for

for

Apple

Apple

use
use
use

paintOval
eraseOval

invertOval
£i110val

*reserved
for
*reserved
for
*reserved
for
frameSameOval

Apple
Apple
Apple

use
use
use

©

bytes

bytes
bytes

data
data
data

opcode

opcode

opcode

opcode

opcode
opcode
rect

(see
(see
(see
(see
(see

+

+
+

8

8
8

Note
Note
Note
Note
Note

bytes
bytes
bytes

eraseSameOval
invertSameOval
£i1l1SameOval
*reserved
for Apple
*reserved
for Apple
*reserved
for Apple
frameArc
paintArc

rect
rect
rect
opcode
opcode

opcode
rect
rect
rect
rect
rect
opcode
opcode
opcode

+
+
+

8
8
8

bytes
bytes
bytes

data
data
data

rect

use
use
use

je

2

cy=

©

=
ms
=

—)

=
a

<A

rect

paintSameOval

eraseArc
invertArc

8

rect

eraseSameRRect

*reserved

+

opcode
+ 8
opcode
+ 8
rect
rect
rect
rect
rectangle

rect
rect
rect
rect
rect

paintRRect

eraseRRect
invertRRect
£i11RRect
*reserved for

opcode

wmowmomwmooonoeococnoocnowmnwmw
oma owmnwmwwmwmooo°neoeo°ceoeo°oeomawn
ea
©
©

$0044

use

Apple
Apple

mom

$0043

Apple

rect
rect

Size

bytes)

oooooooowmom

$0042

rect

SE SE OSE

$0040
$0041

*reserved
for
*reserved
for
frameSameRect

(in

SE

$003F

eraseRect
invertRect
fillRect
*reserved for

Data

Se

$0032
$0033
$0034
$0035
$0036
$0037
$0038
$0039
SOO3A
$003B
$003C
$003D
S003E

Description

rect
rect
rect
opcode
opcode
opcode
rect,
startAngle,
rect,
StartAngle,
rect,
startAngle,
rect,
startAngle,

arcAngle
arcAngle

arcAngle
arcAngle

12
12

12
12

PICT Opcodes V-99

<

Inside Macintosh

Table 3. PICT opcodes (Continued)

startAngle,
+ 12 bytes
opcode
+ 12 bytes
opcode + 12 bytes
rect,

use

opcode

$0067
$0068
$0069

paintSameArc

SOO6F

eraseSameArc
invertSameArc
£i11SameArc
*reserved
for
*reserved for
*reserved for

$0070

framePoly

poly

$0071

paintPoly

poly

$0072

erasePoly

poly

$0073

invertPoly

poly

$0074

£il1Poly

poly

$0075
$0076
$0077
$0078

*reserved for
*reserved for
*reserved
for
frameSamePoly

$0079

paintSamePoly

$007C

invertSamePoly
fillSamePoly

SOO6A
$006B
$006C
$006D
SO06E

SOO7A
$007B
$007D
SOO7E
SOO7F
$0080
$0081

$0082

*reserved
*reserved
*reserved
frameRgn

for
for
for

$0089

paintSameRgn

$0086

SOO08A
$008B
$008C

rect

Apple
Apple

Apple

Apple
Apple
Apple

use
use
use

Apple
Apple
Apple

eraseSameRgn

invertSameRgn
£i11SameRgn

V-100 PICT Opcodes

Apple
Apple
Apple

rect
opcode
opcode
opcode

opcode
opcode

+
+
+

4
4

4

bytes
bytes

bytes

+
+

use
use

opcode

use
use

use

use
use
use

12
12
12
12
4

size
polygon
size
polygon
size
polygon
size
polygon
size
polygon
size

poly
poly
opcode word + poly
(not yet implemented:
same as 70,
etc)
(not yet implemented)
(not yet implemented)
(not yet implemented)
(not. yet implemented)
opcode

use

paintRgn

$0087
$0088

$0084
$0085

rect
rect
rect

eraseSamePoly

eraseRgn
invertRgn
£i11Rgn
*reserved
for
*reserved
for
*reserved
for
frameSameRgn

$0083

use

arcAngle

LS

Apple

use

PH

Apple
Apple

opcode

rgn
rgn
rgn
rgn
rgn
opcode
+
opcode
+
opcode
+
(not yet
same as
(not yet
(not yet
(not yet
(not yet

SP

fillArc
*reserved
for
*reserved
for
*reserved
for
frameSameArc

Pe

$0065
$0066

Data Size
(in bytes)

oooococoo°c”jo

$0064

Description

Name

region
region
region
region
rgn
rgn
rgn
implemented-80,

etc.)

implemented)
implemented)
implemented)
implemented)

region

region

region

region
0
oo°oo

Opcode

size

size
size
size
size
size
size
size

Color QuickDraw
Table 3.

PICT opcodes (Continued)

Opcode

Name

$008D
S008E

$008F

*reserved
*reserved
*reserved

$0091

*BitsRgn

$0092

*reserved

for

Apple

use

opcode

+

$0093

*reserved

for

Apple

use

opcode

+

$0094

*reserved

$0095

*reserved

for

$0096

*reserved

$0097

*reserved

$0098

*PackBitsRect

$0099

*PackBitsRgn

SO09A

*reserved

for

Apple

use

$009B

*reserved

for

Apple

use

$009C

*reserved

for

Apple

use

$009D

*reserved

for

Apple

use

$009E

*reserved

for

Apple

use

SOO09F

*reserved

for

Apple

use

SOO0A0

ShortComment

$0090

*BitsRect

for
for
for

Apple
Apple
Apple

use
use
use

Description

Data Size
(in bytes)

opcode
opcode
opcode

0
0
0
variable:
see Table
variable:
see Table
2+ data
length
2+ data
length
2+ data

copybits,

rect

clipped

copybits,

rgn

clipped

length

2

bytes

data

2

bytes

data

+

data

length

data

use

opcode

+

bytes

data

Apple

use

length
opcode
length

+
+
+

data
2 bytes
data

data

for

Apple

use

length

+

data

for

Apple

use

for

Apple

opcode

+

2

2

bytes

data

word

+

2

bytes

length

+

data

opcode
data

packed copybits,
clipped

LongComment

SO0A2

*reserved

SOOAF

*reserved

for

Apple

use

$00B0

*reserved

for

Apple

use

SOOCF
$00D0

*reserved

for
for

Apple
Apple

use

*reserved

Apple

use

copybits,

rgn

opcode
length
opcode
length

+
+
+
+

data

opcode

+

2 bytes
data
2 bytes
data

2

bytes

data

data

length
+ data
opcode
+ 2 bytes data
length
+ data
opcode
+ 2 bytes data
length + data
opcode
+ 2 bytes data
length
+ data
kind
(word)
kind
(word),
size
(word),
data

+

+

data

bytes

data

2+ data
length

opcode
length
opcode

+
+

2 bytes
data

data

2+ data
length
0

+
+

4 bytes
data

data

opcode
opcode
length

2

4

length

2+ data
length
2+ data
length
2+ data
length
variable:
see Table
variable:
see Table
2+ data
length
2+ data
length
2+ data
length
2+ data
length
2+ data
length
2+ data
length
2
4+data

opcode

length

use

rect

packed

clipped

SO0A1

for

+

4

4
4

0

4+ data
length

PICT Opcodes V-101

ES
OQ

S
o

Ler

|

(=)
=
o
x

o

bw

69
=

4

Inside Macintosh

Table 3. PICT opcodes (Continued)
Opcode

Name

SOOFE

*reserved

for

Apple

use

opcode

+

4 bytes

data

SOOFF
$0100

opEndPic
*reserved

for

Apple

use

end of
opcode

picture
+ 2 bytes

data

2
2

SO1FF

*reserved

for

Apple

use

use

opcode

opcode

+ 2 bytes
+

4

bytes

data

2

SOBFF
$0C00
$0C01:

*reserved
HeaderOp
*reserved

for

Apple

use

+

4

bytes

data

for

Apple

use

opcode
opcode
opcode

+

4

bytes

data

2a
24
24

S7F00

*reserved

for

Apple

use

opcode

+

254

bytes

data

254

*reserved

for

Apple

use

opcode

+ 254

bytes

data

254

$0200

$7FFF

Description

*reserved

for

*reserved

$80FF

*reserved

*reserved

for

for

Apple

use

opcode

opcode
length

+
+

SFFFF

*reserved

for

Apple

use

opcode

+

Notes

to Table

Apple
Apple

use
use

opcode

+

$8000

$8100

for

Apple

length

length

+

Data

data

data

4 bytes
data

data

4

data

bytes

data

Size

(in

bytes)

4+

data

length

4

0

0

4+ data
length

4+

data

length

3

1. The opcode value has been extended to a word for version 2 pictures. Remember,
opcode size = 1 byte for version 1.
2. Because opcodes must be word aligned in version 2 pictures, a byte of 0 (zero) data is
added after odd-size data.
3. The size of reserved opcodes has been defined. They can occur only in version 2
pictures.
4. All unused opcodes are reserved for future Apple use and should not be used.
5. For opcodes $0040-$0044: rounded-corner rectangles use the setting of the ovSize
point (refer to opcode $000B)
6. For opcodes $0090 and $0091: data is unpacked. These opcodes can only be used for
rowbytes less than 8.

7. For opcodes $0100-$7FFF: the amount of data for opcode $nnXX = 2 * nn bytes.

V-102 PICT Opcodes

Color QuickDraw

The

New

Opcodes:

Expanded

Format

The expanded format of the version 2 PICT opcodes is shown in Table 4 below.
Table 4. Data Format of Version 2 PICT Opcodes
Opcode

Name

Description

Reference

$0012
$0013
$0014
$0015

BkPixPat
PnPixPat
FillPixPat
PnLocHFrac

color background pattern
color pen pattern
color
fill pattern
fractional pen

See Note
1
See Note 1
See Note 1
If pnLocHFrac

position

is

(word)

always

picture
ChExtra

SOO1A

RGBFgCol

$001B

RGBBkCol

$001D

extra
for each
character
(word)

OpColor

$001C

HiliteMode

$OO1E

it

Use

DefHilite

default

No

BitsRect

$0091

BitsRgn

$0098

PackBitsRect

$0099

PackBitsRgn

hilite

copybits,
rect
clipped
copybits,
rgn
clipped
packed copybits,
rect clipped
packed copybits,

rgn

<>

1/2,

it

each

text

to

the

operation.

chExtra

put

to

changes,

picture

data;

this

opcode

is

sent before a drawing
operation
that uses the
hilite mode.
No data;
set hilite
to default
(from low
memory).
See Note 2,4,5

color

$0090

is

Notes

before
next text drawing
operation.
desired RGB for foreground
desired RGB for background

RGB foreColor
(RBGColor)
RGB backColor
(RGBColor)
RGB hilite color
RGB OpColor
for
arithmetic modes
hilite mode flag

HiliteColor

$001F

After

put

before

drawing
$0016

to

clipped

See

Note

3,4,5

See

Note

2,4

See

Note

3,4

co

2)

=
i)

Lew

—

=)
-y

~

Notes

to Table
1.

if

a
<=

4

patType

=

ditherPat

then

PatType:

word;

PatlData:

Pattern;

RGB:

RGBColor;

{pattern type = 2}
{old pattern
data}
{desired RGB for pattern}

else
PatType:

word;

PatliData:

Pattern;

4

©
=2)

pixMap:
colorTable:

{pattern type = 1}
{old pattern data}
{described
in Table
{described
in Table

5}
5}

pixData:

{described

5}

in

Table

end;

PICT Opcodes V-103

Inside Macintosh
26

3:5

pixMap:

{described

colorTable:
srcRect:
dstRect:

Rect;
Rect;

{described
in Table
5}
{source
rectangle}
{destination
rectangle}

mode:

Word;

{transfer

mode

(may

PixData:

{ modes) }
{described

in

Table

5}

pixMap:
colorTable:

{described
{described

in
in

Table
Table

5
5

Table

srcRect:

Rect;

Rect;

{destination

mode:

Word;

maskRgn:

Rgn;

{transfer
mode
(may
{ modes) }
{region
for
masking}

dstRect:

PixData:

{source

in

5}

include

new

transfer

}

new

transfer

}

}
}

rectangle}

{described

rectangle}

in

include

Table

5}

4. These four opcodes ($0090, $0091, $0098, $0099) are modifications
of existing (version 1) opcodes. The first word following the opcode
is the rowBytes. If the high bit of the rowBytes is set, then it is a
pixMap containing multiple bits per pixel; if it is not set, it is a
bitMap containing one bit per pixel. In general, the difference
between version 1 and version 2 formats is that the pixMap replaces
the bitMap, a color table has been added, and pixData replaces the
bitData.
5. Opcodes $0090 and $0091 are used only for rowbytes less than 8.

Table 5. Data Types Found Within New PICT Opcodes Listed in Table 4
Data Type

Field

pixMap

baseAddr:
rowBytes:
Bounds:

long;
word;
rect;

{unused =
{rowBytes
{bounding

packType:

word;

{packing

fixed;

{horizontal

=

Definitions

version:

packSize:
hRes:

vRes:
pixelType:

pixelSize:
cmpCount :

cmpSize:

planeBytes:
pmTable:
pmReserved:
end;

V-104 PICT Opcodes

word;

long;

Comments
0}
w/high byte
rectangle}

{version

number

=

{packed

size

0}

format
=

0}

= 0}

resolution

word;

{ $0048.0000) }
{vertical resolution
{ $0048.0000) }
{chunky format = 0}

word;

{size

of

{

chunky}

fixed;
word;
word;

long;
long;
long;

{#
{#

set}

(default

(default=

bits per pixel
(1,2,4,8) }
components
in pixel = 1}

for

each

component

{offset to next plane
{color table = 0}
{reserved = 0}

=

}

= pixelSize

=

0}

}

}

Color QuickDraw

Table 5. Data Types Found Within New PICT Opcodes Listed in Table 4 (Continued)
Data Type

Field

Definitions

colorTable

= ctSeed:

ctFlags:
ctSize:

long;

{id

word;

{number of ctTable entries-1
}
{ ctSize + 1 color table entries
{ each entry = pixel value,
red,
{ green,
blue:
word}

word;

end;
pixData:

{the

If
If

following

Comments
number

{flags

pseudocode

word

for

=

describes

0}

color

the

table

pixData

=

0}

data

rowBytes < 8 then data is unpacked
data size = rowBytes* (bounds.bottom-bounds.top) ;
rowBytes >= 8 then data is packed.

}
}

type}

Image contains
(bounds.bottom-bounds.top)
packed
scanlines.
Packed scanlines are produced by the PackBits

routine.

Each

If

end;

scanline

rowBytes >
else it is

consists

250 then
a byte.

of

[byteCount]

byteCount

is

a

[data].

word,

te

Q
=)
S
©
=
©
e.
—,

Lear |

&

S

PICT Opcodes V-105

Inside Macintosh

SUMMARY

OF COLOR

QUICKDRAW

Constants
CONST

{ Old-style

blackColor
whiteColor
redColor

grafPort
=
=
=

greenColor

=

blueColor

=

cyanColor
magentaColor
yellowColor
{

Arithmetic
blend
addPin
addOver
subPin
adMax
subOver
adMin

=
=
=

mode

transparent

=

mask

Highlight

=

pHiliteBit

Constant

for

defQDColors

}

}

64;

=

50;

0;

resource
=

}

36;

constants

hilite

{

constant

constant

mask
{

409;

273:
137;
69;

Il

Text

}

341;

transfer modes
= 32;
= 33;
= 34;
= 35;
= 37;
= 38;
= 39;

{ Transparent

{

colors

33;
30;
205;

}

{this

{
{

is

the

correct

value

for

use

when

}

calling the BitClear trap.
BClr must use
the assembly language equate hiliteBit}

IDs

127;

V-106 Summary of Color QuickDraw

}

}

Color QuickDraw

Data

Types

TYPE
RGBColor

=

ColorSpec

RECORD

red:
green:
blue:
END;
=

INTEGER;
INTEGER;
INTEGER

{red component }
{green component }
{blue component }

RECORD
value:

INTEGER;

{index

or

rgb:

RGBColor

{true

color}

other

value}

END;

cSpecArray

: ARRAY

CTabHandle
CTabPtr
ColorTable

=
=
=

[0..0]

“*“CTabPtr;
“ColorTable;
RECORD

of

ColorSpec;

ctSeed:
ctFlags:

LONGINT;
INTEGER;

ctSize:

INTEGER;

{unique identifier
{high bit is 1 for
{ for pixMap}
{number of entries
{

ctTable:

from table}
device,
0 }
-1

in

}

ctTable}

cSpecArray

END;

CGrafPtr

CGrafPort

= *CGrafPort;

= RECORD

=

device:

INTEGER;

portPixMap:

PixMapHandle;

portVersion:
grafVars:

chExtra:

pnLocHFrac:
portRect:
visRgn:

clipRgn:
bkPixPat:
rgbFgColor:

INTEGER;

{port's

{handle

INTEGER;

{extra
{

pnLoc:
pnSize:

Point;
Point;

=
oD

map}

to

more

on

the

characters

string}

}

always

}

fields}
end

}

{clipping region}
{background pattern}
{requested foreground

of

}

}

color}

{requested background
{ color}
{pen location}
{pen size}

e,

3

4

<

{pen fraction}
{port rectangle}
{visible region}

{

RGBColor;

a

font

2 bits

{ placed

RgnHandle;
PixPatHandle;
RGBColor;

rgbBkColor:

pixel

{highest

{ set}

Handle;

INTEGER;
Rect;
RgnHandle;

{device ID for
{ selection}

©

}

Summary of Color QuickDraw V-107

Inside Macintosh

pnMode:

pnPixPat:
£illPixPat:
pnVis:
txFont:
txFace:
txMode:
txSize:

INTEGER;

PixPatHandle;

INTEGER;

INTEGER;
Style;
INTEGER;
INTEGER;

spExtra:

Fixed;

colrBit:

INTEGER;

fgColor:
bkColor:

patStretch:

picSave:
rgnSave:
polySave:

grafProcs:

{pen transfer mode}
{pen pattern}
{fill pattern}
{pen visibility}
{font number for text}

PixPatHandle;

{text's
{text's

{font

{extra

PixMapPtr

PixMap

style}

mode}

text}

foreground
background

being

drawn}

{region

being

saved}

{polygon being saved}
{low-level drawing }

CQDProcsPtr

{

routines}

rgbOpColor:

RGBColor;

{color

rgbHiliteColor:
pmFgColor:

RGBColor;
Handle;

{color

pmF'gIindex:

INTEGER;

pmBkColor:

Handle;

{ foreground color}
{index value for }
{ foreground}
{palette handle for

pmBkIndex:

INTEGER;

{index

pmF lags:

INTEGER;

{

baseAdadr :
rowBytes:

bounds:
pmVersion:
packType:
packSize:

hRes:
vRes:

pixelType:

V-108 Summary of Color QuickDraw

Ptr;
INTEGER;

Rect;
INTEGER;
INTEGER;
LONGINT;

Fixed;
Fixed;

INTEGER;

for

addPin,
}
and blend}
for hiliting}

subPin,

{palette

handle

{ background
value

for

for

Manager}

}

}

color}

{ background}
{flags for Palette
{

= “PixMapPtr;
= “PixMap;
= RECORD

color}
color}

{used internally}
{picture being saved}

Handle;
Handle;
Handle;

END;

PixMapHandle

for

space}

{plane

INTEGER;

RECORD

size

{actual
{actual

LONGINT;
LONGINT;

END;
GrafVars

character

transfer

}

}

{pointer to pixMap data}
{offset to next row}
{boundary rectangle}
{color QuickDraw version
{

number}

{packing
{size of

format}
data in

packed

{format

of

image}

{ state}
{horizontal resolution}
{vertical resolution}

pixel

}

}

Color QuickDraw
pixelSize:

INTEGER;

cmpCount

INTEGER;

:

cmpSize:

{physical
{ pixel}
{logical

{ pixel}
{logical

INTEGER;

{

planeBytes:
pmTable:

LONGINT;
CTabHandle;

pmReserved:

LONGINT

bits

per

}

components

bits

per

per

}

}

component}

{offset to next plane}
{absolute colors for }
{ this image}
{reserved for future
}
{ expansion}

END;

“PixPatPtr;
“PixPat;

PixPatHandle
PixPatPtr

RECORD

PixPat

patType:

INTEGER;

patData:

Handle;

{pattern }
{ characteristics}
{pixel image defining

patXData:
patXValid:

Handle;
INTEGER;

{expanded pixel image}
{flags for expanded }

patXMap:

Handle;

{

Pattern;

il
iow

}

pattern}

{ pattern data}
{handle to expanded
{

pattern

{

color}

{old-style

END;
CCrsrPtr
CGrsr

type}

PixMapHandle;

patlData:

CCrsrHandle

{pattern

patMap:

}

data}

pattern/RGB

}
pa

“CCrsxrPtx;

SSCrery
RECORD
crsrType:
crsrMap:

crsrData:
crsrXData:

S

INTEGER;
PixMapHandle;

{type of cursor}
{the cursor's pixMap}

Handle;
Handle;

{cursor's
{expanded

data}
cursor

crsrXValid:

INTEGER;

{depth

expanded

crsrXHandle:

Handle;

crsrlData:
crsrMask:

Bits16;
Bitsl16;

crsrXTable:
ersriD;

LONGINT;
LONGINT;

crsrHotSpot:

END;

Point;

=
=
S.
>

{ data}

of

{ data}
{reserved

for

future

{ use}
{one-bit cursor}
{cursor's mask}
{cursor's

S
©

}

>

}
}

hotspot}

{private}
{ctSeed for
{ cursor}

expanded

}

Summary of Color QuickDraw V-109

Inside Macintosh
CIconHandle
CIconPtr
CIcon

=
=
=

*CIconPtr;
“CIcon;
RECORD

iconPMap:
iconMask:
iconBMap:
iconData:

PixMap;
BitMap;
BitMap;
Handle;

iconMaskData:

ARRAY[0..0]

=

RECORD
red:
green:
blue:
matchData:
END;

CQDProcsPtr =
CQDProcs
=

INTEGER;
INTEGER;
INTEGER;
LONGINT;

*“CQDProcs
RECORD
textProc:

Ptr;

lineProc:

Ptr;

rectProc:

Ptr?

rRectProc:

PEL;

arcProc:

Ptr;

ovalProc:

polyProc:

icon's
icon's
icon's
icon's

{ mask

END;
MatchRec

{the
{the
{the
{the

OF

and

pixMap}
mask bitMap}
bitMap}
data}

INTEGER;

bitMap

{icon's

data}

{red component }
{green component }
{blue component}

Ptr:

Ptr;

rgnProc:
PUT?
bitsProc:
Ptr;
commentProc:
Ptr;
txMeasProc:
Ptr;
getPicProc:
Ptr;

putPicProc:

END;

opcodeProc:
newProcl:
newProc2:
newProc3:
newProc4:
newProcS5:
newProcé6:

Ptr;

Ptr;
Pir;
Ptr;
Ptr;
PEE?
Ptr;
Ptr;

Routines

Operations
PROCEDURE
PROCEDURE
PROCEDURE

on

cGrafPorts

OpenCPort
InitCPort
CloseCPort

(port:
CGrafPtr);
(port:
CGrafPtr);
(port:
CGrafPtr);

V-110 Summary of Color QuickDraw

{fields added
{reserved for
{reserved for
{reserved for
{reserved for
{reserved for
{reserved for

to QDProcs}
future use}
future use}
future use}
future use}
future use}
future use}

}

Color QuickDraw

Setting

the

Foreground

and

Background

(color
RGBColor) ;
(color
RGBColor) ;
(VAR color
: RGBColor);
(VAR color
: RGBColor);

PROCEDURE
PROCEDURE

RGBForeColor
RGBBackColor

Creating

Pixel

FUNCTION

NewPixMap

PixMapHandle;

PROCEDURE

CopyPixMap

(srcPM,dstPM:

PROCEDURE
PROCEDURE

PROCEDURE

GetForeColor
GetBackColor

Operations

Maps

DisposPixMap

on

Colors

Pixel

(pm:

PixMapHandle) ;

PixMapHandle) ;

Maps

PROCEDURE

CopyBits

(srcBits,

PROCEDURE

CopyMask

PROCEDURE

SeedCFill

PROCEDURE

CalcCMask

(srcBits,maskBits,dstBits:
BitMap;
srcRect,
maskRect,
dstRect:
Rect);
(srcBits,
dstBits:
BitMap;
srcRect,
dstRect:
Rect;
seedH,
seedV:
INTEGER;
matchProc:
ProcPtr;
matchData:
LONGINT) ;
(srcBits,
dstBits:
BitMap;
srcRect,
dstRect:
Rect;
seedRGB:
RGBColor;
matchProc:
ProcPtr;
matchData:
LONGINT);

Operations
FUNCTION
PROCEDURE
FUNCTION

PROCEDURE
PROCEDURE

PROCEDURE
PROCEDURE

Color

on

Pixel

NewPixPat

Rect;

BitMap;

INTEGER;

srcRect,

maskRgn:

dstRect:

RgnHandle) ;

Patterns

DisposPixPat

PixPatHandle;

(ppat:

GetPixPat

(patID:

CopyPixPat
MakeRGBPat

PixPatHandle) ;
INTEGER):

(srcPP,dstPP:

(ppat:
(ppat:
(ppat:

PenPixPat

BackPixPat

Drawing

dstBits:

mode:

pan

PixPatHandle;

PixPatHandle) ;

PixPatHandle; myColor:
PixPatHandle) ;
PixPatHandle) ;

2)

RGBColor);

Operations

Lew

PROCEDURE

FillCRect

(cr:

PROCEDURE

FillCRoundRect

(r: Rect; ovWd,ovHt:
INTEGER;
ppat:
PixPatHandle);
(r: Rect;
startAngle,arcAngle:
INTEGER;
ppat:
PixPatHandle) ;
(rgn: RgnHandle;
ppat:
PixPatHandle) ;
(poly:
PolyHandle;
ppat:
PixPatHandle) ;
(h,v:
INTEGER;
VAR cPix:
RGBColor);
(h,v:
INTEGER;
cPix:
RGBColor);

PROCEDURE

FillCOval

PROCEDURE

FillCArc

PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE

FillCRgn
FillCPoly
GetCPixel
SetCPixel

Operations
FUNCTION

on

Color

GetCCursor

S
S
~
=
CO
x
=
$5
2

(xr:

Rect;

Rect;

ppat:

PixPatHandle);

ppat:

PixPatHandle) ;

Cursors
(crsrID:

INTEGER):

CCrsrHandle;

Summary of Color QuickDraw V-111

|

Inside Macintosh
PROCEDURE
PROCEDURE
PROCEDURE

SetCCursor
(cCrsr:
CCrsrHandle);
DisposCCursor
(cCrsr: ‘CCrsrHandle) ;
AllocCursor;

Operations
FUNCTION

DisposCIcon
PlotCIcon

Operations
PROCEDURE
PROCEDURE

on

INTEGER):

(theIcon:
(theRect:

CIconHandle;

CIconHandle) ;
Rect;
theIcon:

CIconHandle) ;

Fields

(pm:
PixMapHandle) ;
(color:
RGBColor) ;

HiliteColor
(color:RGBColor) ;
CharExtra
(extra:Fixed) ;
SetStdCProcs
(VAR cProcs:
CQDProcs);

Operations
FUNCTION

on

Color

GetCTable

PROCEDURE

DisposCTable

Picture

FUNCTION

Tables
(ctID:

(ctTab:

INTEGER):

CTabHandle;

CTabHandle) ;

Operations

OpenPicture

(picFrame:

Rect)

:

PicHandle;

Variables

HiliteMode
HiliteRGB

{if the hilite mode is set, highlighting
{default highlight color for the system}

Assembly-Language
HiLite

(id:

cGrafPort

SetPortPix
OpColor

PROCEDURE
PROCEDURE
PROCEDURE

Global

Icons

GetCIcon

PROCEDURE
PROCEDURE

Color

on

is

on}

in

assembler

Interface

Constant

hiliteBit

Equates

EQU

7

;flag bit in HiliteMode
; this is the correct value
; programs

for Resource

defQDColors

EQU

127

RGBColor

structure

red

EQU

S10)

for

use

IDs
resource

; [word]

V-112 Summary of Color QuickDraw

red

ID

of

clut

channel

for

default

intensity

QDColors

Color QuickDraw
green

EQU

ColorSpec

structure

blue
rgbColor

$2

EQU
EQU

value

; [word] green channel intensity
; [word] blue channel intensity
;size of record

$4
$6

EQU

rgb
colorSpecSize

10)
$2
$8

EQU
EQU

; [short]
value field
; [cgbColor]
rgb values
;size of record

Additional

Offsets

portPixMap

EQU

portBits

; [long]

grafVars

EQU

portVersion+2

;[long] handle to new fields
; [word] extra characters placed
; the end of a string

portVersion
chExtra

EQU
EQU

pnLocHFrac

in a cGrafPort
portPixMap+4
grafVars+4

EQU

chExtra+2

pixelMap

; [word]

port

7,

; [word]

pen

handle

version

number

fraction

rgbFgColor
rgbBkColor

EQU
EQU

EQU.

bkPat

; [long] handle
;[6 bytes] RGB
;[6 bytes] RGB

to bk pattern
components of
components of

pnPixPat
fillPixPat

EQU
EQU

S$3A
pnPixPat+4

; [long]

to

bkPixPat

Offsets

Within

bkPixPat+4
RGBFgColor+6é

handle

; [long]

at

handle

pen's

to

fg
bk

color
color

pattern

fill

pattern

GrafVars

rgbOpColor

EQU

0

; (6

rgbHiliteColor

EQU

EQU

rgbOpColor+6
rgbHiliteColor+6

pmF'gIndex

EQU

pmFgColor+4

;([6 bytes]
color for hiliting
;[4 bytes] Palette handle for
; foreground color
;([2 bytes] index value for

O
=}
S
L

pmBkColor

EQU

pmFgIndex+2

pmBkIndex

EQU

pmBkColor+4

;(4 bytes] Palette handle for
; background color
; (2 bytes]
index value for

<2
=
=

pmF lags

EQU

pmBkIndex+2

grafVarRec

EQU

pmF lags+2

pmFgColor

PixMap

field

color

subPin,

and

;

foreground

for

blend

; background

;[2 bytes] Flags
; manager
;Size of grafVar

for

addPin,

Palette

record

offsets

pmBaseAddr
pmNewF lag
pmRowBytes
pmBounds
pmVersion
pmPackType

EQU
EQU
EQU
EQU
EQU
EQU

$0
$4
$4
$6
SE
$10

pmHRes

EQU

$16

pmPackSize

bytes]

;

EQU

$12

; [long]

; (1 bitJupper
; [word]
; [rect]

; [word]

; [word]
; [long]
;(fixed]

bit

pixMap

of

rowbytes

version

is

flag

number

defines packing format
size of pixel data
h. resolution
(ppi)

Summary of Color QuickDraw V-113

=

=

°

Inside Macintosh
pmVRes

EQU

pmCmpCount

EQU

pmPixelType
pmPixelSize

EQU
EQU

pmCmpSize

EQU

pmP laneBytes
EQU

pmTable

EQU

pmReserved
pmRec

PixPat

EQU
EQU

field

EQU
EQU
EQU
EQU

patxXMap

EQU

EQU

patlData
ppRec

Pattern

EQU
EQU

; [word]
; [word]
; [word]
; [word]

$26
$2A
$2E
$32

EQU

newPat
GitherPat
oldCrsrPat
CCrsrPat

; [long]
color map
; [long]
must be 0
; [long]
; size of pixMap record

$0
$2
$6
SA
SE
$10
$14
$1C

; [word] type of pattern
; [long] handle to pixmap
; [long] handle to data
; [long] handle to expanded pattern data
; [word] flags whether expanded pattern valid
; [long] handle to expanded pattern data
; (8 bytes] old-style pattern/RGB color
; size of pixPat record

EQU
EQU
EQU
EQU

0
a
2
$8000
$8001

;foreground/background pattern
;self-contained color pattern
;xrgb value to be dithered
;old-style cursor
;new-style cursor

(Color

Cursor)

field

offsets

crsrType
crsrMap
crsrData

EQU
EQU
EQU

0
crsrTypet2
crsrMap+4

ersrXData
crsrXValid

EQU
EQU

crsrDatat4
ecrsrXDatat4

crsrxXHandle
crsrlData
crsrMask
crsrHotSpot

EQU
EQU
EQU
EQU

EQU
EQU

crsrXValid+2
crsrXHandle+4
crsrlData+32
crsrMask+32
crsrHotSpott+4
crsrXTablet+4

EQU

crsriD+4

ersrXTable
ersrID
crsrRec

Cicon

v. resolution
(ppi)
defines pixel type
# bits in pixel
# components in pixel
# bits per field
offset to next plane

Types

oldPat

CCrsr

; [fixed]

SIE
$20
$22
$24

offsets

patType
patMap
patData
patxXData

patXValid

S1A

(Color

Icon)

field

; [word]

cursor

;{long]

handle

; [long]

private

type

to

cursor's

pixmap

;({long]
handle to cursor's color
; data
; [long]
handle to expanded data
; [word]
handle to expanded data
; (0 if none)
;({long]
handle for future use
; [16 words]
one-bit data
; (16 words]
one-bit mask
; [point]
hot-spot for cursor
; [long]
color table seed for
; expanded cursor
;size of cursor save area

offsets

iconPMap
iconMask

EQU
EQU

0
iconPMap+pmRec

iconBMap

EQU

iconMask+bitmapRec

V-114 Summary of Color QuickDraw

;[pixmap]
icon's pixMap
; [bitmap]
1-bit version
; 1-bit mask
; [bitmap]

l1-bit

version

of

icon

of

icon

Color QuickDraw
iconData

EQU

iconBMap+bitmapRec

;[long]

iconRec

EQU

iconDatat4

;Size

Extensions

to

the

opcodeProc
newProcl
newProc2
newProc3

EQU
EQU
EQU
EQU

newProc5
newProc6é
cqdProcsRec

EQU
EQU
EQU

newProc4

MatchRec

EQU

$34
$38
$3C
$40
$44
$48
$4C
$50

Handle

followed

of

by

icon

to

bMap

pixMap

header

and

data

mask

data

record

; [pointer]
; [pointer]

; [pointer]

; [pointer]
; [pointer]
; [pointer]
; [pointer]
,

size

.

of

QDProc Ss

record

structure

red

EQU

green
blue
matchData
matchRecSize

Global

QDProcs

;

EQU
EQU
EQU
EQU

$0
$2
$4
$6

SA

.
,
‘
.
‘
.
,
.
,

[word]
[word]
[word]
[long]

size

of

defined in
define d in
define dad in

RGBColor
RGBColor
RGBColor

record

Variables

HiliteMode
HiliteRGB

EQU
EQU

$938

SDAO

;if the hilite bit
;default highlight

is set,
highlighting
color for the system

is

on

aS
OQ

=
©

=¥

©
=oO

an

o
=
$9

=

Summary of Color QuickDraw V-115

GRAPHICS
118
118
119
121
122
125
125
126
126
127
129

DEVICES

About This Chapter
About Graphics Devices
Device Records
Multiple Screen Devices
Graphics Device Routines
Drawing to Offscreen Devices
Optimizing Visual Results
Optimizing Speed
Imaging for a Color Printer
Graphics Device Resources
Summary of Graphics Devices

un
Q
2
=

"S

=f
a
7©
Ss:
°o
nN

i? 2)

V-117

Inside Macintosh

ABOUT THIS CHAPTER
Because the Macintosh II supports a variable sized screen, different screen depths, and

even multiple screens, a new set of data structures and routines has been introduced to
support, in a general way, the use of graphics devices (called gDevices). These data
structures and routines are logically a part of Color QuickDraw, but because they are
functionally quite independent of QuickDraw, they appear here in a separate chapter.
A graphics device is used to
m associate a driver with a particular graphics output device
m define the size and color capabilities of the device
m define the position of a video screen with respect to other screens
m change the default matching routine used by the Color Manager
= keep track of the cursor for that device
a allocate a set of colors used by an offscreen bitMap
Reader’s guide: Graphics devices are generally used only by the system. You might
need to use the information in this chapter, for example, if your application needs explicit
knowledge of the pixel depth of the screen(s) it is drawing to, or if it wants to bring up a
window on a particular screen. You might also use the information in this chapter if you
want to allocate and maintain an offscreen bitMap.
Before reading this chapter you should be familiar with the material in the chapter on Color
QuickDraw. Some of the routine descriptions in this chapter also refer to the Color
Manager, the Slot Manager, and the Device Manager chapters; you will only need to refer
to those chapters if you are using those routines.

ABOUT

GRAPHICS

DEVICES

When the system is started up, one handle to a gDevice record (described below) is
allocated and initialized for each video card found by the system. These gDevice records

are linked together in a linked list, which is called the DeviceList.

By default, the gDevice record corresponding to the first video card found is marked as an
active device (a device your program can use for drawing); all other devices in the list are
marked as inactive. The ways that other devices become active are described below. When
drawing is being performed on a device, that device is stored as theGDevice.
If you want your application to write into an offscreen pixMap whose pixel depth or set of
colors is different from that of the screen, your program must allocate a gDevice to describe
the format of the offscreen pixMap. Your application could describe the set of colors that a

V-118 About Graphics Devices

Graphics Devices
printer can support, or represent an offscreen version of an image that spans multiple
screens. More details of this technique are given below.

GDevices that correspond to video devices have drivers associated with them. These

drivers are used, for example, to change the mode of the device from monochrome to
color, or to change the pixel depth of the device. GDevices that your application creates
won’t generally require drivers. The set of calls supported by a video driver is defined and
described in Designing Cards and Drivers for Macintosh II and Macintosh SE.

DEVICE

RECORDS

All information that is needed to communicate with a graphics device is stored in a handle
to a gDevice record, called a gdHandle. This information may describe many types of
devices, including video displays, printers, or offscreen drawing environments.
The structure of the gDevice record is as follows:
TYPE
GDHandle

GDPtr
GDevice

=

=
=

“GDPtr;

“GDevice;
RECORD
gdRefNum:

gdID:

INTEGER;

{reference

number

INTEGER;

{client ID for
{ procedure}
{device type}

gdResPref:

‘INTEGER;

{preferred

gdSearchProc:
gdCompP roc:

gdFlags:
gdPMap:

gdType:

gdiITable:

INTEGER;

driver}

}

{inverse

table}

§$ProcHndl;
CProcHndl;

{list
{list

search procedures}
complement
}

_—
INTEGER;
PixMapHandle;

{ procedures}
{grafDevice flags word}
{pixel map for displayed
{ image}

gdRefCon:

LONGINT;

{reference

gdNextGD:

GDHandle;

{handle

gdRect:
gdMode:

Rect;
LONGINT;

{device's
{device's

{rowBytes of expanded
{ cursor data}

}

i=
=

gdCCDepth:

INTEGER;

{rowBytes

}

=

gdCCxData:

Handle;

{handle

gdCCXMask:

Handle;

gdReserved:

LONGINT

gdCcBytes:

ITabHandle;

of

search

INTEGER;

of
of

{ cursor

resolution}

}

value}

of

next

gDevice}

global
bounds}
current mode}

of

data}

to

{ expanded

expanded

cursor's

data}

}

{handle
to cursor's
}
{ expanded mask}
{reserved
for future
}

{

expansion}

END;

Device Records V-119

3}

o

=

&

Inside Macintosh

Field

descriptions

gdRefNum

The gdRefNum is a reference number of the driver for the display device
associated with this card. For most display devices, this information is set
at system startup time.

gdID

The gdID field contains an application-settable ID number identifying the
current client of the port. It is also used for search and complement
procedures (see “The Color Manager: Search and Complement
Procedures’).

gdType

The gdType field specifies the general type of device. Values include:
0 = CLUT device (mapped colors with lookup table)
1 = fixed colors (no lookup table)

2 = direct RGB
These device types are described in the Color Manager chapter.
gdITable

The gdITable contains a handle to the inverse table for color mapping
“The Color Manager: Inverse Tables”).

(see

gdResPref

The gdResPref field contains the preferred resolution for inverse tables (see

gdSearchProc

The gdSearchProc field is a pointer to the list of search procedures (see
“The Color Manager: Search and Complement Procedures’’); its value is
NIL for a default procedure.

gdCompProc

The gdCompProc field is a pointer to a list of complement procedures (see
“The Color Manager: Search and Complement Procedures”; its value is NIL
for a default procedure.

gdFlags

The gdFlags field contains the gDevice’s attributes. Do not set these flags
directly; always use the procedures described in this chapter.

gdPMap

The gdPMap field is a handle to a pixel map giving the dimension of the
image buffer, along with the characteristics of the device (resolution,
storage format, color depth, color table). For gDevices, the high bit of
theGDevice™.gdPMap™.pmTable™.ctFlags is always set.

gdRefCon

The gdRefCon is a field used to pass device-related parameters (see
SeedCFill and CalcCMask in the Color QuickDraw chapter). Since a device
is shared, you shouldn’t store data here.

gdNextGD

The gdNextGD field contains a handle to the next device in the deviceList.
If this is the last device in the deviceList, this is set to zero.

gdRect

The gdRect field contains the boundary rectangle of the gDevice. The

“The Color Manager: Inverse Tables’”’).

screen with the menu bar has topLeft = 0,0.

it.

V-120 Device Records

All other devices are relative to

Graphics Devices
gdMode

The gdMode field specifies the current setting for the device mode.
the value passed to the driver to set its pixel depth, etc.

gdCCBytes

The gdCCBytes field contains the rowBytes of the expanded cursor.
Applications must not change this field.

gdCCDepth

The gdCCDepth field contains the depth of the expanded cursor.
Applications must not change this field.

gdCCxXData

The gdCCXData field contains a handle to the cursor’s expanded data.
Applications must not change this field.

gdCCXMask

The gdCCXMask field contains a handle to the cursor’s expanded mask.
Applications must not change this field.

gdReserved

The gdReserved field is reserved for future expansion; it must be set to zero
for future compatibility.

MULTIPLE

SCREEN

This is

DEVICES

This section describes how multiple screen devices are supported by the system.
how they are initialized, and once initialized, how they’re used.

It tells

When the system is started up, one of the display devices is selected as the startup
screen, the screen on which the “happy Macintosh” icon appears. If a startup screen has
been indicated in parameter RAM, then that screen is used. Otherwise, the screen whose
video card is in the lowest numbered slot is used as the startup screen. By default, the
menu bar is placed on the startup screen. The screen with the menu bar is called the main
screen.
The user can use the Control Panel to set the desired depth of each screen, whether it
displays monochrome or color, and the position of that screen relative to the screen with the
menu bar. Users can also select which screen should have the menu bar on it. See the
Control Panel chapter for more information. All this information is stored in a resource of
type ‘scrn' (ID=0) in the system file.
When the InitGraf routine is called to initialize QuickDraw, it checks the System file for this

resource. If it is found, the screens are organized according to the contents of this
resource. If it is not found, then only the startup screen is used. The precise format of a
‘scrn' resource is described in the “Graphics Device Resources” section.

When InitWindows is called, it scans through the device list and creates a region that is the
union of all the active screen devices (minus the menu bar and the rounded corners on the

outermost screens). It saves this region as the global variable GrayRgn, which describes
and defines the desktop, the area on which windows can be dragged. Programs that paint
the desktop should use FillRgn(GrayRgn,myPattern). Programs that move objects around
on the desktop should pin to the GrayRgn, not to screenBits.bounds.

Multiple Screen Devices V-121

Nn
am
wt 4
-

=

—

we
=

ee

°
2)
cm

=
@
<=

2)
@
i 4)

Inside Macintosh

Since the Window Manager allows windows to be dragged anywhere within the GrayRgn,
windows can span screen boundaries, or be moved to entirely different screens. Despite
this fact, QuickDraw can draw to the window’s port as if it were all on one screen. In
general terms, it works like this:

when an application opens a window, the window’s

port.portBits.baseAddr field is set to be equal to the base address of the main screen.
When QuickDraw draws into a grafPort or cGrafPort, it compares the base address of the
port to that of the main screen. If they are equal, then QuickDraw might need to draw to
multiple screens.
If there are multiple screens, QuickDraw calculates the rectangle, in global coordinates, into
which the drawing operation will write. For each active screen device in the device list,
QuickDraw intersects the destination rectangle with the device’s rectangle (gdRect). If they
intersect, the drawing command is issued to that device, with a new pixel value for the
foreground and background colors if necessary. In addition, patterns and other structures
may be reexpanded for each device.

GRAPHICS

DEVICE ROUTINES

The following set of routines allows an application to create and examine gDevice records.
Since most device and driver information is automatically set at system startup time, these
routines are not needed by most applications that simply draw to the screen.
FUNCTION

NewGDevice(refNum:

INTEGER;

mode:

LONGINT)

GDHandle;

The NewGDevice function allocates a new gDevice data structure and all of its handles,
then calls InitGDevice to initialize it for the specified device in the specified mode. If the
request is unsuccessful, a NIL handle is returned. The new gDevice and all of its handles
are allocated in the system heap. All attributes in the GDFlags word are set to FALSE.
If your application creates a gDevice without a driver, the mode parameter should be set to
—1. In this case, InitGDevice is not called to initialize the gDevice. Your application must
perform all initialization.
A graphics device’s default mode is defined as 128, as described in the Designing Cards
and Drivers manual; this is assumed to be a monochrome mode. If the mode parameter is
not the default mode, the giDevType attribute is set TRUE, to indicate that the device is
capable of displaying color (see the SetDeviceAttribute call).
This routine doesn’t automatically insert the gDevice into the device list. In general, your
application shouldn’t add devices that it created to the device list.

V-122 Graphics Device Routines

Graphics Devices
PROCEDURE

InitGDevice(gdRefNum:
GDHandle) ;

INTEGER;

mode:

LONGINT;

gdh:

The InitGDevice routine sets the video device whose driver has the specified gdRefNum to
the specified mode. It then fills out the gDevice record structure specified by the gdh
parameter to contain all information describing that mode. The GDHandle should have been
allocated by a call to NewGDevice.
The mode determines the configuration of the device; possible modes for a device can be
determined by interrogating the video card’s ROM via calls to the Slot Manager (refer to the
Slot Manager chapter and the Designing Cards and Drivers manual). Refer to the Device
Manager chapter for more details about the interaction of devices and their drivers.
The information describing the new mode is primarily contained in the video card’s ROM.
If the device has a fixed color table, then that table is read directly from the ROM. If the

device has a variable color table, then the default color table for that depth is used (the ‘clut’

resource with [D=depth).

In general, your application should never need to call this routine. All video devices are

initialized at start time and their modes are changed by the control panel. If your program is
initializing a device without a driver, this call will do nothing; your application must
initialize all fields of the gDevice. It is worth noting that after your program initializes the
color table for the device, it needs to call MakelITable to build the inverse table for the
device.
FUNCTION

GetGDevice:

GDHandle;

The GetGDevice routine returns a handle to the current gDevice. This is useful for
determining the characteristics of the current output device (for instance its pixelSize or
color table).

Note that since a window can span screen boundaries, this call does not return

the device that describes a port.

Ss

Assembly-language note: A handle to the currently active device is kept in the
global variable TheGDevice.

SetGDevice(gdh:

GDHandle);

)

PROCEDURE

=3

The SetGDevice procedure sets the specified gDevice as the current device. Your
application won’t generally need to use this call except to draw to offscreen gDevices.
FUNCTION

DisposGDevice:

$9

~~

a5
O

*”

—
©
==
©2)

GDHandle;

The DisposGDevice function disposes of the current gDevice and releases the space
allocated for it, and all data structures allocated by NewGDevice.

Graphics Device Routines V-123

Inside Macintosh
FUNCTION

GetDeviceList:

GDHandle;

The GetDeviceList function returns a handle to the first device in the DeviceList.

Assembly-language note:

A handle to the first element in the device list is kept

in the global variable DeviceList.

FUNCTION

GetMainDevice:

GDHandle;

The GetMainDevice function returns the handle of the gDevice that has the menu bar on it.
Your application can examine this gDevice to determine the size or depth of the main

screen.

Assembly-language note: A handle to the current main device is kept in the
global variable MainDevice.

FUNCTION

GetNextDevice

(gdh:

GDHandle):

GDHandle;

The GetNextDevice function returns the handle of the next gDevice in the DeviceList.
there are no more devices in the list, it returns NIL.
PROCEDURE

SetDeviceAttribute:
value:
BOOLEAN) ;

(gdh:

GDHandle;

attribute:

If

INTEGER;

The SetDeviceAttribute routine can be used to set a device’s attribute bits. The following

attributes may be set using this call:
gdDevType

ramiInit
mainScreen
allInit

=

=
=
=

0;

screenDevice
noDriver
screenActive

=
=
=

13;
14;
15;

FUNCTION

{0

10;
11;
12;

= monochrome,

{set if
{set if
{set if
{ 'sern'
{set if
{set if
{set if

TestDeviceAttribute

INTEGER)

:

BOOLEAN;

1 =

color}

device has been initialized from RAM}
device is main screen}
devices were initialized from a }
resource}
device is a screen device}
device has no driver}
device is active}

(curDevice:

GDHandle;

attribute:

The TestDeviceAttribute function tests a single attribute to see if it is true or not. If your
application is scanning through the device list, it would typically use this routine to test if a
device is a screen device, and if so, test to see if it’s active. Then your application can draw
to any active screen devices.

V-124 Graphics Device Routines

Graphics Devices
FUNCTION

GetMaxDevice

(globalRect:

Rect)

:GDHandle;

The GetMaxDevice routine returns a handle to the deepest device that intersects the
specified global rectangle. Your application might use this routine to allocate offscreen

pixMaps, as described in the following

DRAWING

TO OFFSCREEN

section.

DEVICES

It’s sometimes desirable to perform drawing operations offscreen, and then use CopyBits
to transfer the complete image to the screen. One reason to do this is to avoid the flicker
that can happen when your program is drawing overlapping objects. Another reason might
be to control the set of colors used in the drawing (for instance, if your application
performs imaging for a printer that has a different set of colors than the screen). For both
these examples, your application needs control of the color environment, and thus needs to
make use of gDevices.
First, let’s look at the example of drawing a number of objects offscreen, and then
transferring the completed image to the screen. In this case, the complicating factor is the
possibility that your program may open a window that will span two (or more) screens
with different depths. One way to approach the problem is to allocate the offscreen pixMap
with a depth that is the same as the deepest screen touched by the window. This allows
your program to perform offscreen drawing with the maximum number of colors that is
used by any window, giving optimal visual results. Another approach is to allocate the
offscreen pixMap with the depth of the screen that contains the largest portion of the
window, so that transfers to the screen will be as fast as possible. You might want to
alternate between these techniques depending on the position of the window.

Optimizing

Visual

Results

When allocating a pixMap for the deepest screen, your application should first allocate an
offscreen grafPort that has the depth of the deepest screen the window overlaps. To do
this, your application must save the current gDevice (GetGDevice), get the deepest screen

Next, your application must allocate storage for the pixels by setting portPixMap™.bounds
to define the height and width of the desired image, and setting rowBytes to
((width*portPixMap™. pixelSize)+15)DIV 16*2. (Note that rowBytes must be even, and
for optimal performance should be a multiple of four. Your application can adjust
portPixMap™. bounds to achieve this.) Next, define the interior of portPixMap.bounds to
which your application can write by setting portRect. Now that the size of the pixMap is
defined, the amount of storage is simply the height*portPixMap™.rowBytes. It is
generally better to allocate the storage as a handle. Before writing to it, your application
should lock the handle, and place a pointer to the storage in portPixMap™.baseAddr.

Drawing to Offscreen Devices V-125

IS

a new cGrafPort

(OpenCPort), and then restore the saved gDevice (SetGDevice again). Since OpenCPort
initializes its pixMap using TheGDevice, the current grafPort is the same as the deepest
screen.

x
N

(GetMaxDevice), set that to be the current gDevice (SetGDevice), create

£9
a=]
=F
bor

©
nn

=©
<
o©
”

|

Inside Macintosh

All that remains is to draw to the grafPort. Before drawing, your program should save the
current gDevice, and then set TheGDevice to be the maximum device (which was

determined earlier). Your application can use SetPort to make this port the current port,
and then perform all drawing operations. Remember to have your application restore

TheGDevice after drawing is complete.

Keep in mind that all this preparation can be invalidated easily. If the user changes the
depth of the screen or moves the window, all your carefully allocated storage may no
longer be appropriate. Both changing the depth of the screen and moving the window
across device boundaries will cause update events. In your application’s update routine,
include a test to see if the environment has changed. One good test is to determine whether
the color table has changed. Your application can compare the ctSeed field of the new
maximum device with that of the old maximum device. (See the Color Manager chapter for
more information on this technique.) If ctSeed has changed, your application should check
the screen depth, and if it has changed, reallocate the pixMap (possibly repeating the entire
process above). If the depth hasn’t changed, but the color table has, then your application
can just redraw the objects into the offscreen pixMap.

Optimizing

Speed

If you decide to optimize for speed instead of appearance, then your application should
examine each element in the device list to see how much of the window it intersects. Your
application can do this by getting the device list (GetDeviceList), intersecting that device’s
rectangle with your window’s rectangle, and then repeating the examination for each device
by calling GetNextDevice. Before examining a device, your application can ensure that it is
an active screen device using GetDeviceAttribute. The procedure for allocating the
cGrafPort is the same as described above.

Imaging

for a Color

Printer

Finally, let’s look briefly at the example of imaging into an offscreen device that isn’t the
same as one of the screen devices, which you might do if you were imaging for a color
printer. In this case the process is much the same, but instead of relying on an existing
gDevice to define the drawing environment, your application must set up a new one. To do
this, simply call NewGDevice to allocate a new gDevice data structure. Your application
must initialize all fields of the pixMap and color table, as described in the Color QuickDraw
chapter. It should call then MakeITable to build the device’s inverse table, as described in

the Color Manager chapter. As with the example above, your application should set its
gDevice as the current device before drawing to the offscreen pixMap. This will guarantee
that drawing is done using the set of colors defined by your application’s gDevice.

V-126 Drawing to Offscreen Devices

Graphics Devices

GRAPHICS

DEVICE

RESOURCES

A new resource type has been added to describe the setup of graphics devices:
"sern'

Screen resource type

The 'scrn' resource contains all the screen configuration information for a multiple screen
system. Only the 'scrn' resource with ID = 0 is used by the system. Normally your
application won’t have to alter or examine this resource. It’s created by the control panel,
and is used by InitGraf.
The 'scrn' resource consists of a sequence of records, each describing one screen device.
In the following description this sequence of records is represented by a Pascal FOR loop
that repeats once for each screen device.

'‘scrn'

(Screen

configuration)

ScrnCount
[word]
FOR i := 1 to ScrnCount DO

number of devices in resource

slot
dCtlDevBase

[word]
[long]

slot number
dCtlDevBase from DCE

[word]

=$77FE

spDrvrHw

[word]

mode

[word]

flagMask
flags

colorTable

[word]

[word]

gammaTable
[word]
global Rect
[rect]
ctlCount
[word]
FOR j := 1 to ctlCount DO
csCode
[word]
length
[word]
param blk
[length]

END;
END;

Slot Manager hardware ID

Slot Manager ID for screen’s mode

indicates device state

bit 0 = 0 if monochrome; 1 if color
bit 11=1 if device is main screen
bit 15=1 if device is active
resource id of desired 'clut’

resource id of desired 'gama'
device’s global rectangle
number of control calls

control code for this call
number of bytes in param block
data to be passed in control call

ui
~~
“4
=
)

The records in the 'scrn' resource must be in the same order as cards in the slots (starting
with the lowest slot). InitGraf scans through the video cards in the slots, and compares
them with the descriptors in the 'scrn' resource. If the spDrvrHw, slot, and dCtlIDevBase
fields all match for every screen device in the system, the 'scrn' resource is used to

initialize the video devices.

Otherwise the 'scrn' resource is simply ignored. Thus if you

move a video card, or add or remove one, the 'scrn' resource will become invalid.

SpDrvrHw is a Slot Manager field that identifies the type of hardware on the card. (The
spDrvrSw field on the card must identify it as an Apple-compatible video driver.) Slot is

Graphics Device Resources V-127

—
a
—

ewe

i)

ie
=

i)
‘4°,
<

ae
ig]

wn

Inside Macintosh

the number of the slot containing the card. DCtlDevBase is the beginning of the device’s
address space, taken from the device’s DCE.
If all video devices match, the rest of the information in the 'scrn' resource is used to

configure the video devices. The mode is actually the slot manager ID designating the
descriptor for that mode. This same mode number is passed to the video driver to tell it
which mode to use.
The flags bits are used to determine whether the device is active (that is, whether it will be
used), whether it’s color or monochrome, and whether it’s the main screen (the one with
the menu bar). The flagMask simply tells which bits in the flags word are used.
To use the default color table for a device, set the colorTable field to —1. To use the default
gamma table for a device, set the gammaTable field to —1. (Gamma correction is a
technique used to select the appropriate intensities of the colors sent to a display device.
The default gamma table is designed for the Macintosh II 13-inch color monitor; other
manufacturers’ color monitors might incorporate their own gamma tables.)
The global rect specifies the coordinates of the device relative to other devices. The main
device must have topLeft = 0,0. The coordinates of all other devices are specified relative to
this device. Devices may not overlap, and must share at least part of an edge with another
device. To support future device capabilities, a series of control calls may be specified.
These are issued to the driver in the given order.

V-128 Graphics Device Resources

Graphics Devices

SUMMARY

OF GRAPHICS

DEVICES

Constants
{ Values

clutType

for

fixedType
directType

GDFlags
=

0;

= 1;
= 2;
for

ramiInit
mainScreen
alliInit

=
=
=

10;
11;
12;

screenDevice
noDriver
screenActive

=
=
=

13;
14;
15;

TYPE

if

{1
{2

{ Bit assignments
gdDevType
= 0;

Data

}

{0

{0

if
if

lookup

table}

fixed table}
direct values}

GDFlags }
= monochrome,

{set if device
{set if device
{set if devices
{ resource}
{set if device
{set if device
{set if device

1 =

color}

has been initialized from RAM}
is main screen}
were initialized from a “scorn
is a screen device}
has no driver}
is active}

Types

GDHandle
GDPtr
GDevice

=
=
=

“GDPtr;
“GDevice;
RECORD

gdRefNum:

INTEGER;

gdID:

INTEGER;

gdType:
gdIiTable:

INTEGER;
ITabHandle;

gdResPref:
gdSearchProc:

INTEGER;
SProcHndl;

gdCompProc:

CProcHndl;

gdFlags:
gdPMap:

INTEGER;
PixMapHandle;

gdRefCon:

LONGINT;

gdNextGD:

GDHandle;

gdRect:

Rect;

gdMode:

LONGINT;

gdCCBytes:

INTEGER;

{reference number of }
{ driver}
{client
ID for search
}
{ procedure}
{device type}
{inverse table}

{preferred

resolution}

{list of search
}
{ procedures}
{list of complement
}
{ procedures }
{grafDevice
flags word}
{pixel map for }

{ displayed

image}

{reference
{handle
of

value}
next
}

{ gDevice}
{device's global
{ bounds}
{device's

{rowBytes
{

cursor

current

of

data}

1S

QQ
—s

pt)
a)

=F

aw
o
©
=a
ow

}
mode}

expanded

}

Summary of Graphics Devices V-129

Inside Macintosh
gdcCcDepth:

INTEGER;

gdCCxData:

Handle;

gdCCxMask:

Handle;

gdReserved:

LONGINT

{depth of expanded
{ cursor data}

}

{handle to cursor's }
{ expanded data}
{handle to cursor's }
{ expanded mask}
{reserved for future }
expansion}

{

END;

Routines
mode:

INTEGER;

FUNCTION

NewGDevice

(refNum:

PROCEDURE

InitGDevice

FUNCTION
PROCEDURE

PROCEDURE
FUNCTION
FUNCTION
FUNCTION
PROCEDURE

GetGDevice:
SetGDevice

INTEGER;
(gdRefNum:
gdh: GDHandle) ;

DisposGDevice
GetDeviceList:
GetMainDevice:
GetNextDevice
SetDeviceAttribute

GDHandle;
(gdh: GDHandle) ;

FUNCTION

TestDeviceAttribute

(gdh:

FUNCTION

GetMaxDevice

Global

LONGINT)

mode:

LONGINT;

(gdh: GDHandle) ;
GDHandle;
GDHandle;
(curDevice:GDHandle) : GDHandle;
(gdh: GDHandle; attribute:
INTEGER;
value:

BOOLEAN) ;

GDHandle;

attribute:

BOOLEAN;
(globalRect:Rect):

INTEGER) :

GDHandle;

Variables

DeviceList
GrayRgn
TheGDevice
MainDevice

Assembly

Values

GDHandle;

{handle

to

{handle
{handle

to
to

{contains

Language

the

size

first

and

EQU
EQU.
EQU

0
1
2

Information

70
;1
;2

if
if
if

V-130 Summary of Graphics Devices

of

in

the

current

current active device}
the current main device}

for GDTypes

clutType
fixedType
directType

element

shape

lookup table
fixed table
direct values

device

desktop}

list}

Graphics Devices

Bit Assignments

for GDFlags

gdDevType

0
10
ji
12

EQU
EQU
EQU
EQU

ramInit
mainScreen
allInit
screenDevice
noDriver
screenActive

abe tt2F mle
aie 212eq/4/
b fr

+ (30/2

bir

13

;set

gdRefNum
gdID

EQU
EQU
EQU
EQU
EQU

$0
$2

EQU
EQU
EQU
EQU

SC
$10

EQU

EQU
EQU

S1A
S1E
$22

EQU
EQU
EQU
EQU
EQU

$2E
$30
$32
$36
$3A
$3E

gdPMap

gdRefCon
gdNextGD
gdRect
gdMode
gdCCBytes
gdCCDepth
gdCCxData

gdCCxMask

gdReserved
gdRec

Global

EQU
EQU

1

=

color

if
if
if

device has been initialized from
device is main screen
devices were initialized froma

if

device

RAM

"scrn'
resource
;set
if device
is a screen
device
;set
if device
has
no driver

13
14
15

field offsets

gdSearchProc
gdCompProc
gdFlags

monochrome,

.
’,

GDevice

gdType
gdITable
gdResPref

"2dH

EQU
EQU
EQU

70 =
;set
;set
;set

$4

$6

SA

$14
$16

S2A

is

active

; [word]

unitNum

; [long]
; [word]

handle to
preferred

; [word]
; [word]
;

tables

; [long]

; [long]

; [word]

; [long]
;

device

; [long]

;handle

of

driver

client ID for search
fixed/CLUT/direct

search

inverse table
resolution for

proc

(list?)

inverse

pointer

complement

proc

(list?)

handle

pixMap

describing

grafDevice

to

reference

of

next

flags

word

of

pointer

value

gDevice

;device's global bounds
;device's current mode
;rowBytes of expanded cursor
jhandle to cursor’s expanded

;depth

procs

expanded

;handle to cursor's
; [long]
MUST BE 0
;size of GrafDevice

cursor

data

expanded

data
data

mask

record

Variables

DeviceList

EQU

S8A8

GrayRgn

EQU

SORE

TheGDevice
MainDevice

EQU

EQU

$CC8

S8A4

;handle to the
; device list

;contains

; desktop
;handle to
;handle to

size

first

and

element

shape

of

in

the

current

nn
oo

wid
=

current active device
the current main device

iS)

s

3

i?)
if 2)
—
—
@

<

tor)

@

wn

Summary of Graphics Devices V-131

6

THE
134
134
135.
135.
137
139
141
141
143.
145
145
147
148

COLOR

MANAGER

About This Chapter
About the Color Manager
Graphics Devices
Color Table Format
Inverse Tables
Using the Color Manager
Color Manager Routines
Color Conversion
Color Table Management
‘Error Handling
Custom Search and Complement Procedures
Operations on Search and Complement Procedures
Summary of the Color Manager

Nn

QD

=
)

=

>

=

&

ge

©

Lew 4

V-133

Inside Macintosh

ABOUT THIS CHAPTER
The Color Manager supplies color-selection support for Color QuickDraw on the
Macintosh II. The software described in this chapter allows specialized applications to finetune the color-matching algorithms, and also provides utility functions that are rarely used
by applications.
An understanding of Color QuickDraw concepts, terminology, and data structures is
essential when using the material in this chapter. You should be familiar with RGB color,
pixel maps, pixel patterns, and other material introduced in the Color QuickDraw chapter.
You should also be familiar with the material in the Graphics Devices chapter, since the
Color Manager routines work on the device level.
Keep in mind that Color Manager routines are the intermediary between high-level software
such as Color QuickDraw, the Palette Manager, and the Color Picker, and the lower-level

video devices. The majority of applications will never need to use the Color Manager
routines directly.

Reader’s guide: The material in this chapter is largely for informational purposes
only, since Color QuickDraw, the Palette Manager, and the other color Toolbox routines
provide a detailed and consistent way to add color to Macintosh programs.

ABOUT THE COLOR

MANAGER

The Color Manager is optimized to work with graphics hardware that utilizes a Color
Look-up Table (CLUT), a data structure that maps color indices, specified using
QuickDraw, into actual color values. The exact color capabilities of the Macintosh II
depend on the particular video card used. There are three kinds of devices:
a CLUT devices contain hardware that converts an arbitrary pixel value stored in the
frame buffer to some actual RGB video value, which is changeable. The pixel value
could be the index to any of the colors in the current color set for the device, and the
color set itself can be changed.
= Fixed devices also convert a pixel value to some actual RGB video value, but the
hardware colors can’t be changed. The pixel value could be the index to any of the
colors in the color set, but the color set itself always remains the same.
= Direct devices have a direct correlation between the value placed in the frame buffer
and the color you see on the screen. The value placed in the frame buffer would
produce the same color every time. Direct devices aren’t supported in the initial release
of Color QuickDraw.
Applications that limit themselves to a small set of colors can use them simply and easily
from QuickDraw, with a minimum of overhead. Color QuickDraw accesses the Color
Manager to obtain the best available color matches in the lookup table. Applications such as
color painting and animation programs, which need greater control over the precise colors

V-134 About The Color Manager

The Color Manager
they use, can use the Palette Manager to allocate part of the color table for their own
exclusive use. The Palette Manager, described in a later chapter, is useful for most
applications that use shared color resources, imaging, or color table animation. The Palette
Manager is used whenever color is used for objects within windows, while the Color
Manager operates on the device level.
Note: Palette Manager routines operate transparently across multiple screens, while
Color Manager routines do not. Therefore, always use Palette Manager routines for
applications that will run on multiple screens or in a multitasking environment.
The sections that follow describe how the Color Manager converts the RGB values
specified using Color QuickDraw into the actual colors available on a device. The pixel
value, specifying the number of bits per pixel, is set using the Control Panel.

Graphics

Devices

As with Color QuickDraw, the Color Manager accesses a particular graphics device
through a data structure known as a gDevice record. Each gDevice record stores
information about a particular graphics device; after this record is initialized, the device
itself is known to the Color Manager and QuickDraw as a gDevice. See the Graphics
Devices chapter for more details on gDevice format and on the routines that allow an
application to access a given device. Remember that a gDevice is a logical device, which the
software treats the same whether it is a video card, a display device, or an offscreen pixel
map.
Color

Table

Format

The complete set of colors in use at a given time for a particular gDevice is summarized in a
color table record. Its format is as follows:
TYPE

CTabHandle
CTabPtr
ColorTable

=
=
=

“CTabPtr;
“ColorTable;
RECORD

ctSeed:

LONGINT;

ctSize:
ctTable:

INTEGER;
cSpecArray

ctFlags:

INTEGER;

{unique

identifier

from

table}

{high bit is set for a gDevice,
{ clear for a pixMap}
{Number of entries
in table-1}

}

END;

a
©

=
SLr |
£9
=|
o>
ge@
Lee

About The Color Manager V-135

|

Inside Macintosh

Field

descriptions

ctSeed

The ctSeed field is similar to a version identifier number for a color

table. If a color table is created by an application, it should call

GetCTSeed to obtain this identifier. The ctSeed should be some

unique number higher than minSeed, a predefined constant with a

value of 1023. If a color table is created from a resource, its
resource number will be used as the initial ctSeed. For 'CLUT'

resource, the range of resource numbers should be 0—1023.
ctFlags

The ctFlags field is significant for gDevices only. It contains flags
that describe the format of the ctTable. Currently, only the high bit is
defined; all others are reserved. Color tables that are part of the
gDevice structure always have this bit set. Color tables that are part
of pixMaps have this bit clear. Each gDevice has its own pixMap,
which has a color table.

ctSize

The ctSize field contains the number of entries in the color table
minus one. All counts on color table entries are zero based.

ctTable

The ctTable field contains a cSpecArray, which is an array of
ColorSpec entries. Notice that each entry in the color table is a
ColorSpec, not simply an RGBColor. The type ColorSpec is
composed of an integer value and an RGB color, as shown in the
following specification. A color table may include a number of
ColorSpec records.

TYPE

cSpecArray

ColorSpec

=

=

ARRAY

RECORD
value

rgb

END;
RGBColor

=

RECORD
red

green
blue

END;

[0..0]

OF

ColorSpec;

:

INTEGER;

{Color

:

INTEGER;

{Red

: RGBColor

:
:

INTEGER;
INTEGER

{Color

representation}

value}

component}

{Green component}
{Blue component}

In gDevice color tables, the colorSpec.value field is reserved for use by the Color Manager
and Palette Manager. Their interpretation and values are different than the color tables
contained in pixMaps.

V-136 About The Color Manager

The Color Manager

«——minimum seed value 2 1024

ctSeed

(long word)

ctFlags
ctSize

(word)
(word)

value

(word)

Red (word)

value

(word)

| Red (word)

value

(word)

Red (word)

/-—— significant for gDevices only; otherwise 0
}—— number of color table elements -1
| Green (word)

| Blue (word)

| Green (word) | Blue (word)
| Green (word)

| Blue (word)

RGBColor
i—— ctTable
(cSpecArray)
Figure 1. Color Table Format

Note that the colorSpec.value field of the record is only word size (16 bits), even though
color index values (as returned by Color2Index) may be long words. The current
implementation of Color QuickDraw only supports 16 bits. The components in an
RGBColor are left-justified rather than right-justified in a word. Video drivers should
respect this convention and extract the appropriate number of bits from the high order side
of the component. For example, the Apple Graphics Card uses only the most significant
eight bits of each component of the RGBColor record.
Inverse

Tables

Reader’s guide: The material in this section is provided for informational and
debugging purposes, since most programs won’t need to use inverse tables.
For normal drawing, Color QuickDraw takes all specifications as absolute RGB triples, by
means of the RGBColor record. Internally, these absolute specifications are converted to
the appropriate values to be written into the video card. For direct devices, the RGB is
separated into its red, green, and blue components, and each of these is written to the video

card. On CLUT and fixed devices, however, there isn’t always a direct relationship
between the specified RGB and the index value written into the frame buffer; in fact, on

CLUT devices, the best-match index value may change dynamically as the colors available
in the hardware are changed. On these types of devices, Color QuickDraw uses the Color
Manager to find the best matches among the colors currently available.
The method used to determine the best available match can be specified by the application
or the system on a gDevice by gDevice basis. By default, on CLUT and fixed devices, a
special data structure called an inverse table is created. An inverse table is a table
arranged in such a manner that, given an arbitrary RGB color, the pixel value can be very
rapidly looked up.

—
OQ

o
S

=

mS
=

fo
©

GQ

=

About The Color Manager V-137

Inside Macintosh
In the default case, a certain number of the most significant bits of red, green, and blue are
extracted, then concatenated together to form an index into the inverse table. At this location

is the “best” match to the specified color. The number of bits per color channel that are used
to construct this index is known as the resolution of the inverse table, and can be 3, 4, or 5
bits per channel. As the resolution of the inverse table increases, the number of

permutations of possible colors increases, as does the size of the inverse table. Three-bit
tables occupy 512 bytes, 4-bit tables (the default) occupy 4K bytes, and 5-bit tables occupy
32K bytes.
A disadvantage of this method is that certain colors that are “close” together can become
hidden when they differ only in bits that weren’t used to construct the inverse table index.
For example, even if the color table were loaded with 256 levels of gray, a 4-bit inverse
table can only discriminate among 16 of the levels. To solve this problem without having to
use special-case sets of colors with hidden colors, inverse tables carry additional
information about how to find colors that differ only in the less significant bits. As a result,
when the Color2Index routine is called, it can find the best match to the full 48-bit
resolution available in a colorSpec. Since examining the extra information takes time,
certain parts of Color QuickDraw, notably drawing in the arithmetic transfer modes, don’t
use this information, and hence won’t find the hidden colors.

In most cases, when setting colors using RGBForeColor and RGBBackColor, and when
using CopyBits to transfer pixMaps, inverse tables of four bits are sufficient. When using
arithmetic transfer modes with certain color tables that have closely-spaced colors, the
screen appearance may be improved by specifying inverse tables at 5-bit resolution.
Because the format of inverse tables is subject to change in the future, or may not be
present on certain devices, applications should not assume the structure of the data.

The data in inverse tables remains valid as long

as the color table from which it was built

remains unchanged. When a color table is modified, the inverse table must be rebuilt, and

the screen should be redrawn to take advantage of this new information. Rather than being
reconstructed when the color table is changed, the inverse table is marked invalid, and is
automatically rebuilt when next accessed.
Rather than testing each entry of the color table to see if it has changed, the color-matching
code compares the ctSeed of the current gDevice’s colorTable against the iTabSeed of that
gDevice’s inverse table. Each routine that modifies the colorTable (with the exception of
RestoreEntries) increments the ctSeed field of that colorTable. If the ctSeed and the
iTabSeed don’t match, the inverse table is reconstructed for that gDevice.
Note: Under normal circumstances, all invalidations are posted and serviced
transparently to the application. This method of invalidation is the same as that used
to invalidate expanded patterns and cursors elsewhere in Color QuickDraw.
In certain cases, it may be useful to override the inverse table matching code with custom

routines that have special matching rules. See the section titled “Custom Search and
Complement Procedures” for more details.
The Color Manager performs a color table look-up in the following manner:
1. Builds a table of all possible RGB values;
2. For each position in the table, attempts to get the closest match;

V-138 About The Color Manager

The Color Manager
3. Reduces the resolution of the lookup to four bits when constructing the table, but later
adds information to get a better resolution.
The Color Manager performs this table-building sequence whenever colors are requested

by Color QuickDraw, the Color Picker, or the Palette Manager. This isn’t the only color
matching method available; a custom search procedure, for example, may not have an

inverse table. (See the section titled “Custom Search and Complement Procedures” for
more information.) However, inverse tables are the default method for color matching.

When using an inverse table, the table is indexed by concatenating together the high-order
bits of the three desired color components; iTabRes tells how many bits of each component
are significant. The format of an inverse table is shown below:
TYPE

ITabHandle
ITabPtr

=
=

“ITabPtr;
“ITab;

ITab

=

RECORD

iTabSeed:

LONGINT;

iTTable:

ARRAY[0..0]

iTabRes:

INTEGER;

{copy

of

color

{resolution
{

OF

of

SignedByte

table

index

table

seed}

{byte

color

table}
values}

}

END;

The size of an index table in bytes is 23*iTabRes, The table below shows a sample index
table:

resolution
4-bit

RGB color

size

$0159

212

$0953

215 = 32K bytes

red=$1234,

green=$5678,

blue=$9ABC
5-bit

inverse-table
index

= 4K bytes

red=$1234,

green=$5678,

blue=$9ABC

MakelITable only supports 3-bit, 4-bit, and 5-bit resolution. Five bits is the maximum
possible resolution, since the indices into a 6-bit table would have to be 18 bits long, more
than a full word.

USING THE COLOR

MANAGER

In the simplest cases, use of the Color Manager is transparent when invoking the new
Color QuickDraw routines. Using RGBForeColor and RGBBackColor, the program
requests an RGB color for either the foreground or background. For instance, the
following code requests an RGB color of red and sets it in the cGrafPort:

ON

2)

=

SLear |

<

oomal

n
=
a

FQ

@Lae |

Using the Color Manager V-139

Inside Macintosh
myColor.red:=$FFFF;
myColor.green:=0;
myColor.blue:=0;

RGBForeColor(myColor);
{set
FrameRect (myRect);
{draw in

pen red}
red}

Internally the Color Manager finds the best match to a color in TheGdevice’s current color
table, and sets up the current cGrafPort to draw in this color. At this point, drawing
operations can proceed using the selected colors.
The Color Manager routines described in this chapter are designed to operate on a single
gDevice. The Palette Manager can perform most of these operations across multiple
gDevices. Since the Palette Manager provides more general and portable functionality,
applications should use Palette Manager routines whenever possible.
The SetEntries routine is used to change any part of or all of the entries in a device’s
hardware Color Look-Up Table. The SaveEntries and RestoreEntries routines can make
temporary changes to the color table under very specialized circumstances (such as a color

selection dialog within an application). These routines aren’t needed under normal

application circumstances.

SaveEntries allows any combination of colorSpecs to be copied into a special colorTable.
RestoreEntries replaces the table created by SaveEntries into the graphics device. Unlike
SetEntries, these routines don’t perform invalidations of the device’s colorTable, so they
avoid causing invalidations of cached data structures. When these routines are used, the

application must take responsibility for rebuilding and restoring auxiliary structures as
necessary.

By convention, when using SetEntries or RestoreEntries, white should be located at color

table position 0, and black should be stored in the last color table position available,
whether it is 1, 3, 15, or 255. The Palette Manager also enforces this convention.

For precise control over color, or for dedicated color table entries, the Color Manager

routines maintain special information in device color tables. Using ProtectEntry and
ReserveEntry, an entry may be protected, which prevents SetEntries from further changing
the entry, or reserved, which makes the entry unavailable to be matched by RGBForeColor
and RGBBackColor. Routines that change the device table (SetEntries, ProtectEntry, and
ReserveEntry, but not RestoreEntries) will perform the appropriate invalidations of
QuickDraw data structures. The application must then redraw where necessary.
To inquire if a color exists in a color table, use RealColor. This tells whether an arbitrary
color actually exists in the table for that gDevice.
Color2Index returns the index in the current device’s colorTable that is the best match to the
requested color. Index2Color performs the opposite function—it returns the RGB of a
particular index value. These routines can be useful when making copies of the screen
frame buffer. InvertColor finds the complement of the provided color. GetSubTable
performs a group Color2Index on a colorTable.
The error-handling routine QDError returns the error result from the last QuickDraw or
Color Manager call.

V-140 Using the Color Manager

The Color Manager

COLOR

MANAGER

ROUTINES

The routines used for color drawing are covered in the chapter “Color QuickDraw”’. The
Color Manager includes routines for color conversion, color table management, and error
handling.
Color

Conversion

FUNCTION

Color2Index

(rgb:

RGBColor):

LONGINT;

The Color2Index routine finds the best available approximation to a given absolute color,
using the list of search procedures in the current device record. It returns a longint, which
is a pixel value padded with zeros in the high word. Since the colorSpec.value field is only
a word, the result returned from Color2Index must be truncated to fit into a colorSpec. In

pixMaps the .value is the low-order word of this index.

Color2Index shouldn’t be called from a custom search procedure.
PROCEDURE

Index2Color

(index:

LONGINT;

VAR

rgb:

RGBColor) ;

The Index2Color routine finds the RGB color corresponding to a given color table index.
The desired pixel value is passed and the corresponding RGB value is returned in RGB.
The routine takes a longint, which should be a pixel value padded with zeros in the high
word (normally the compiler does this automatically). Normally, the RGB from the current
device color table corresponding to the index is returned as the RGBColor. Notice that this
is not necessarily the same color that was originally requested via RGBForeColor,
RGBBackColor, SetCPixel, or Color2Index. This RGB is read from the current gDevice

color table.

PROCEDURE

InvertColor

(VAR

theColor:

RGBColor);

The InvertColor routine finds the complement of an absolute color, using the list of
complement procedures in the current device record. The default complement procedure
uses the 1’s complement of each component of the requested color.
FUNCTION

RealColor

(color:

RGBColor)

:

BOOLEAN;

The RealColor routine tells whether a given absolute color actually exists in the current

device’s color table. This decision is based on the current resolution of the inverse table.
For example, if the current iTabRes is four, RealColor returns TRUE if there exists a color

that exactly matches the top four bits of red, green, and blue.

a
OQ

=
}

=y

fs
=
mS
ga@
bee

Color Manager Routines V-141

|

Inside Macintosh
PROCEDURE

GetSubTable

targetTbl:

(myColors:

CTabHandle) ;

CTabHandle;

iTabRes:

INTEGER;

The GetSubTable routine takes a ColorTable pointed at by myColors, and maps each RGB
value into its nearest available match for each target table. These best matches are returned
in the colorSpec.value fields of myColors. The values returned are best matches to the
RGBColor in targetTbl and the returned indices are indices into targetTbl. Best matches are
calculated using Color2Index and all applicable rules apply. A temporary inverse table is

built, and then discarded. ITabRes controls the resolution of the iTable that is built. If
targetTbl is NIL, then the current device’s color table is used, and the device’s inverse table

is used rather than building a new one. To provide a different resolution than the current
inverse table, provide an explicit targetTbl parameter; don’t pass a NIL parameter.
Warning: Depending on the requested resolution, building the inverse table can
require large amounts of temporary space in the application heap: twice the size of
the table itself, plus a fixed overhead for each inverse table resolution of 3—15K

bytes.

PROCEDURE

MakeITable
res:

(colorTab:

CTabHandle;

inverseTab:

ITabHandle;

INTEGER);

The MakelITable routine generates an inverse table based on the current contents of the
color table pointed to by CTabHandle, with a resolution of res bits per channel. Reserved
color table pixel values are not included in the resultant color table. MakeITable tests its
input parameters and will return an error in QDError if the resolution is less than three or
greater than five. Passing a NIL parameter to CTabHandle or ITabHandle substitutes an
appropriate handle from the current gDevice, while passing 0 for res substitutes the current
gDevice’s preferred table resolution. These defaults can be used in any combination with
explicit values, or with NIL parameters.

This routine allows maximum precision in matching colors, even if colors in the color table
differ by less than the resolution of the inverse table. Five-bit inverse tables are not needed
when drawing in normal QuickDraw modes. However, the new QuickDraw transfer modes
(add, subtract, blend, etc.) may require a 5-bit inverse table for best results with certain
color tables. MakeITable returns a QDError if the destination inverse table memory cannot
be allocated. The 'mitq' resource governs how much memory is allocated for temporary
internal structures; this resource type is for internal use only.

Warning: Depending on the requested resolution, building the inverse table can
require large amounts of temporary space in the application heap: twice the size of
the table itself, plus a fixed overhead for each inverse table resolution of 3-15K
bytes.

V-142 Color Manager Routines

The Color Manager

Color

Table

FUNCTION

Management

GetCTSeed

:

LONGINT;

The GetCTSeed function returns a unique seed value that can be used in the ctSeed field of
a color table created by an application. This seed value guarantees that the color table will
be recognized as distinct from the destination, and that color table translation will be
performed properly. The return value will be greater than the value stored in minSeed.
PROCEDURE

ProtectEntry

(index:

INTEGER;

protect:

BOOLEAN) ;

The ProtectEntry procedure protects or removes protection from an entry in the current
device’s color table, depending on the value of the protect parameter. A protected entry
can’t be changed by other clients. It returns a protection error if it attempts to protect an
already protected entry. However, it can remove protection from any entry.
PROCEDURE

ReserveEntry

(index:

INTEGER;

reserve:

BOOLEAN) ;

The ReserveEntry procedure reserves or dereserves an entry in the current color table,
depending on the value of the reserve parameter. A reserved entry cannot be matched by
another client’s search procedure, and will never be returned to another client by

Color2Index or other routines that depend on it (such as RGBForeColor, RGBBackColor,

SetCPixel, and so forth). You could use this routine to selectively protect a color for color
table animation.
ReserveEntry copies the low byte of gdID into the low byte of ColorSpec.value when
reserving an entry, and leaves the high byte alone. It acts like a selective protection, and
does not allow any changes if the current gdID is different than the one in the
colorSpec.value field of the reserved entry. If a requested match is already reserved,
ReserveEntry returns a protection error. Any entry can be dereserved.
PROCEDURE

SetEntries(start,

count:

INTEGER;

aTable:

CSpecArray);

The SetEntries procedure sets a group of color table entries for the current gDevice, starting
at a given position for the specified number of entries. The pointer aTable points into a
cSpecArray, not into a color table. The colorSpec.value field of the entries must be in the
logical range for the target card’s assigned pixel depth. Thus, with a 4-bit pixel size, the
colorSpec.value fields should be in the range 1 to 15. With an 8-bit pixel size the range is 0
to 255. Note that all values are zero-based; for example, to set three entries, pass two in
the count parameter.
Note: Palette Manager routines should be used instead of the SetEntries routine for
applications that will run in a multiscreen or multitasking environment.
The SetEntries positional information works in logical space, rather than in the actual
memory space used by the hardware. Requesting a change at position four in the color table

>)

©=—
ns
=
oe
ve
om
ae

Color Manager Routines V-143

4

Inside Macintosh

may not modify color table entry four in the hardware, but it does correctly change the
color on the screen for any pixels with a value of four in the video card. The SetEntries

mode characterized by a start position and a length is called sequence mode. In this case,

new colors are sequentially loaded into the hardware in the same order as the aTable, the
clientID fields for changed entries are copied from the current device’s gdID field, and the
colorSpec.value fields are ignored.
The other SetEntries mode is called index mode. It allows the cSpecArray to specify where
the data will be installed on an entry-by-entry basis. To use this mode, pass —1 for the start
position, with a valid count and a pointer to the cSpecArray. Each entry is installed into the
color table at the position specified by the colorSpec.value field of each entry in the
cSpecArray. In the current device’s color table, all changed entries’ colorSpec.value fields
are assigned the gdID value.
When color table entries are changed, all cached fonts are invalidated, and the seed number

is changed so that the next drawing operation will rebuild the inverse table. If any of the
requested entries are protected or out of range, a protection error is returned, and nothing
happens. If a requested entry is reserved, it can only be changed if the current gdID
matches the low byte of the intended ColorSpec.value field.
PROCEDURE

SaveEntries

CTabHandle;

(srcTable:

VAR

CTabHandle;

selection:

ResultTable:

ReqListRec) ;

SaveEntries saves a selection of entries from srcTable into resultTable. The entries to be set
are enumerated in the selection parameter, which uses the ReqListRec data structure shown
below. (These values are offsets into colorTable, not the contents of the colorSpec.value
field.)
TYPE

ReqListRec

= RECORD
reqLSize:

INTEGER;

reqLData:

ARRAY

[0..0]

of

INTEGER

{request
list
{ size -1}

{request
{

data}

list

}

}

END;

If an entry is not present in srcTable, then that position of the requestList is set to

colReqEnr, and that position of resultTable has random values returned. If one or more

entries are not found, then an error code is posted to QDError; however, for every entry in
selection which is not colReqErr, the values in resultTable are valid. Note that srcTable and
selection are assumed to have the same number of entries.
SaveEntries optionally allows NIL as its source color table parameter. If NIL is used, the
current device’s color table is used as the source. The output of SaveEntries is the same as
the input for RestoreEntries, except for the order.

V-144 Color Manager Routines

The Color Manager
PROCEDURE

RestoreEntries
(srcTable:CTabHandle;DstTable:CTabHandle;
VAR
selection:RecListRec);

RestoreEntries sets a selection of entries from srcTable into dstTable, but doesn’t rebuild
the inverse table. The dstTable entries to be set are enumerated in the selection parameter,

which uses the ReqListRec data structure shown in the SetEntries routine description.
(These values are offsets into the srcTable, not the contents of the colorSpec.value field.)
If a request is beyond the end of the dstTable, that position of the requestList is set to
colRegErr, and an error is returned. Note that srcTable and selection are assumed to have
the same number of entries.
If dstTbl is NIL, or points to the device color table, the current device’s color table is
updated, and the hardware is updated to these new colors. The seed is not changed, so no
invalidation occurs (this may cause RGBForeColor to act strangely). This routine ignores
protection and reservation of color table entries.
Generally, the Palette Manager is used to give an application its own set of colors; use of
RestoreEntries should be limited to special-purpose applications. RestoreEntries allows you
to change the colorTable without changing the ctSeed for the affected colorTable. You can
execute the application code and then use RestoreEntries to put the original colors back in.
However, in some cases things in the background may appear in the wrong colors, since
they were never redrawn. To avoid this, the application must build its own new inverse
table and redraw the background. If RestoreEntries were then used, the ctSeed would have

to be explicitly changed to clean up correctly.

Error

Handling

FUNCTION

QDError:

INTEGER;

The QDError routine returns the error result from the last QuickDraw or Color Manager
call.

CUSTOM

SEARCH

AND

COMPLEMENT

PROCEDURES

Custom search and complement procedures allow an application to override the inverse
table matching code. The desired color is specified in the RGBColor field of a ColorSpec
record and passed via a pointer on the stack; the procedure returns the corresponding pixel
value in the ColorSpec.value field.
A custom search procedure routine can provide its own matching rules. For instance, you
might want to map all levels of green to a single green on a monitor. To do this, you could
write and install a custom search procedure that is passed the RGB under question by the
Color Manager. It can then analyze the color, and if it decides to act on this color, it can

a)

OQ

=
=

oy

ce

=

ge

o
=

Custom Search and Complement Procedures V-145

Inside Macintosh

return the index of the desired shade of green. Otherwise, it can pass the color back to the
Color Manager for matching, using the normal inverse table routine.
Many applications can share the same graphics device, each with its own custom search
procedure. The procedures are chain elements in a linked list beginning in the
gdSearchProc field of the gDevice port:
TYPE
SProcHndl
SProcPtr
SProcRec

=
=
=

“SProcPtr;
*“SProcRec;;
RECORD
nxtSrch:
srchProc:

SProcHndl;
ProcPtr

{handle to next sProcRec}
{pointer to search
}
{ procedure}

END;

Any number of search procedures can be installed in a linked list, each element of which
will be called sequentially by the Color Manager, and given the chance to act or pass on the
color. Since each device is a shared resource, a simple method (the gdID) is provided to
identify the caller to the search procedures, as well as routines to add and delete custom
procedures from the linked list.
The interface is as follows:
FUNCTION

SearchProc

(rgb:

RGBColor;

VAR

position:

LONGINT) :

BOOLEAN;

When attempting to approximate a color, the Color Manager calls each search procedure in
the list until the boolean value returns as TRUE. The index value of the closest match is
returned by the position parameter. If no search procedure installed in the linked list
returns TRUE, the Color Manager calls the default search procedure.
The application can also supply a custom complement procedure to find the complement of
a specified color. Complement procedures work the same as search procedures, and are
kept in a list beginning in the gDevice port’s gd/CompProc field.
TYPE

CProcHndl
CProcPtr
CProcRec

=
=
=

“CProcPtr;
“CProcRec;
RECORD

nxtComp:

CProcHandle;

compProc:

ProcPtr

END;

V-146 Custom Search and Complement Procedures

{pointer

to

next

}

{ CProcRec}
{pointer to complement
{ procedure}

}

The Color Manager
The default complement procedure simply uses the 1’s complement of the RGB color
components before looking them up in the inverse table. The interface is as follows:
PROCEDURE

Operations
PROCEDURE
PROCEDURE

CompProc

on

(VAR

Search

AddSearch
AddComp

rgb:

and

RGBColor);

Complement

Procedures

(searchProc:
ProcPtr);
(compProc:
ProcPtr);

The AddSearch and AddComp routines add a procedure to the head of the current device
record’s list of search or complement procedures. These routines allocate an SProcRec or
CProcRec.
PROCEDURE

DelSearch

(searchProc:

PROCEDURE

DelComp

(compProc:

ProcPtr);
ProcPtr);

The DelSearch and DelComp procedures remove a custom search or complement procedure
from the current device record’s list of search or complement procedures. These routines
dispose of the chain element, but do nothing to the procPtr.
PROCEDURE

SetClientID

(id:

INTEGER);

The SetClientID procedure sets the gdID field in the current device record to identify this
client program to its search and complement procedures.

5
OQ

ca
S

Lew

4

bs)

=
9
geom
Lew

Custom Search and

Complement Procedures V-147

4

Inside Macintosh

SUMMARY

OF THE COLOR

MANAGER

1023;

value

Constants
CONST
minSeed

Data

=

{minimum

seed

for

ctSeed}

Types

TYPE

ITabHandle
ITabPtr

=
=

“ITabPtr;
“ITab;

ITab

=

RECORD

iTabSeed:
iTabRes:

iTTable:

LONGINT;
INTEGER;

{copy of color
{resolution of

ARRAY[0..0]

OF

table
table}

SignedByte
{

seed}

{byte

table

color

index

}

values}

END;

SProcHndl
SProcPtr

=
=

*SProcPtr;
“SProcRec;;

SProcRec

=

RECORD

NxeESTCh:
srchProc:

SProcHndl;
ProcPtr

{handle to next sProcRec}
{pointer to search
}
{ procedure}

END;

CProcHndl
CProcPtr

=
=

*CProcPtr;
*CProcRec;

CProcRec

=

RECORD

nxtComp:

CProcHandle;

compProc:

ProcPtr

END;

ReqListRec

=

{pointer to
{ CProcRec}
{pointer to

next

{ procedure}

}

complement

}

RECORD
reqLSize:
reqLData:

INTEGER;
{request
list
size
-1}
ARRAY
[0..0]
of INTEGER {request
list

END;

V-148 Summary of the Color Manager

{

data}

}

The Color Manager
Routines
Color

Conversion

FUNCTION
PROCEDURE

Color2Index
Index2Color

(VAR rgb: RGBColor):
(index:
LONGINT;
VAR

PROCEDURE
FUNCTION

PROCEDURE

InvertColor
RealColor

GetSubTable

(VAR theColor:
RGBColor);
(color:
RGBColor)
: BOOLEAN;

PROCEDURE

MakeITable

(colorTab:

(myColors: CTabHandle;
iTabRes:
targetTbl:CTabHandle) ;
res:

Color

Table

GetCTSeed:

PROCEDURE

RestoreEntries

PROCEDURE

SaveEntries

ProtectEntry
ReserveEntry
SetEntries

Operations

CTabHandle;

on

Search

LONGINT;

(index:
(index:
(start,

ITabHandle;

INTEGER;
protect:
BOOLEAN) ;
INTEGER;
reserve:
BOOLEAN) ;
count:
INTEGER;
aTable:

cSpecArray) ;

(srcTable:CTabHandle; dstTable:CTabHandle;
VAR selection:ReqListRec) ;
(srcTable:CTabHandle; resultTable:CTabHandle;

VAR

and

selection:ReqListRec)

Complement

AddSearch

(searchProc:

PROCEDURE

AddComp

(compProc:

PROCEDURE

DelSearch

(searchProc:

PROCEDURE

SetClientID
(id:

Error

inverseTab:

INTEGER);

PROCEDURE

PROCEDURE

INTEGER;

Management

FUNCTION

PROCEDURE
PROCEDURE
PROCEDURE

LONGINT;
rgb:
RGBColor);

DelComp

(compProc:

Procedures

ProcPtr) ;

ProcPtr);
ProcPtr);

ProcPtr) ;

INTEGER);

Handling

FUNCTION

Assembly

QDError:

INTEGER;

Language

Information

EQU

;minimum

Constants
minSeed

1023

ctSeed

value
N

©

S
o

-“

Z)
=
Ey
ge
©
bea

Summary of the Color Manager V-149

|

Inside Macintosh
ITab

structure

iTabSeed

iTabRes
iTTable

EQU

EQU
EQU

$0
$4
$6

SProcRec

structure

nxtSrch
srchProc

EQU
EQU

CProcRec

structure

nxtComp
compProc

EQU
EQU

Request
reqLSize
reqLData

$0
$4

$0
$4

; [Long]

ID

of

owning

; [word]
client ID
;table of indices
jin this version,

color

table

starts here
entries are

; [pointer]
; [pointer]

link to
pointer

next

; [pointer]
; [pointer]

Link: ‘C6
pointer

next proc
to routine

to

proc

routine

list structure
EQU
EQU

0
2

; [word]
; [word]

V-150 Summary of the Color Manager

request
request

list
list

size
data

-1l

BYTE

I
oat

ww

a
©
o
=
-

==|

7

THE

PALETTE

baw

MANAGER

152
152
153.
154
154
155
156
156
157

About This Chapter
About the Palette Manager
~The Color Index Model
Color Usage
Courteous Colors
Tolerant Colors
Animating Colors
Explicit Colors
Palette Prioritization

159
160
160
161
161
162
163
164
164
167

Color Palette Records
Using the Palette Manager
Color Palettes in a Resource File
Palette Manager Routines
Initialization and Allocation
= Interacting With the Window Manager
Drawing With Color Palettes
~=Color Table Animation
Manipulating Palette Entries
Summary of the Palette Manager

158

>
ge
©

Black, White, and Palette Customization

V-I5]

4

Inside Macintosh

ABOUT THIS CHAPTER
This chapter describes the Palette Manager, a new Toolbox addition for the Macintosh II.
The Palette Manager, as its name implies, supports the use of a collection of colors when
you draw objects with Color QuickDraw. The Palette Manager provides routines your
application can call to manage shared color resources, to provide exact colors for imaging,
or to initiate color table animation. It also describes the data structures of color palettes and
how the Palette Manager communicates with Color QuickDraw.
You should already be familiar with
m the Resource Manager
w the basic concepts and structures behind Color QuickDraw, particularly the calls that

set RGB colors and use color patterns

w the Color Manager and the RGB color model used by Color QuickDraw
a the Window Manager

ABOUT THE PALETTE

MANAGER

The Palette Manager is responsible for monitoring and establishing the color environment
of the Macintosh II. It gives preference to the color needs of the front window, making the
assumption that the front window is of greatest interest to the user.
The Palette Manager is initialized during the first InitWindows call after system startup, and
continues to run as needed whenever windows are moved. If the front window is an oldstyle window, or if it has no assigned palette, the Palette Manager establishes the color
environment using a default palette.
For many simple applications, the colors in the default palette will suffice. This is
especially true of applications that use no color, for the Palette Manager ensures that black
and white are always available.
Suppose, as an example, that you wish to draw an object using 32 different shades of gray.
The default palette won’t provide enough different levels of gray. Color QuickDraw will
match your request as well as it can, so the object will look something like you expected,
but probably not exactly the way you wanted. What you need is a convenient way to
change the color environment for this window automatically, so that plenty of gray colors
will be available each time your window comes to the front. The Palette Manager was
designed to solve this problem.
You begin by creating a data structure called a color palette. This is normally done by
creating a resource of type 'pltt', but you can create it within your application using the
Palette Manager routines if you prefer. In the palette for the gray drawing, you would
include 32 palette entries, each one specifying a different shade of gray. In addition, each

V-152 About the Palette Manager

~I
a}

=
®

The Palette Manager
entry would contain information telling the Palette Manager that you require the color to be
an exact match, a process that is described later in this chapter.
You next use a Palette Manager routine to associate your palette with a particular window.

If that window is the front window, or whenever it becomes the front window, the Palette

Manager checks the current color environment to determine if the 32 shades of gray are
available, exactly as requested. If they aren’t available, the Palette Manager changes the
color environment, adding as many colors as it can, at the expense of windows in the
background. Finally, if the color environment has changed, the Palette Manager updates the
background windows.
The Palette Manager routines make each step of this process reasonably simple. The Palette
Manager also handles multiple devices and different screen resolutions, so your application
need not attempt to provide for all possible machine configurations. In addition, the Palette
Manager routines provide for several different uses of color, for example color table
animation, by building a color index mode upon the more general Color QuickDraw RGB
Model. This color index model is described in the following section.
The

Color

Index

Model

Many video devices implement color using an indexed color model: a pixel value in the
video device’s memory is used as an index into a color table. The RGB value found in the
table at that index position appears on the display device. In general, the resolution of the
values in the video card’s color look-up table is much higher than the resolution provided
by the index itself.
The Palette Manager is primarily designed for use with this indexed color model; it can also
be used with direct or fixed video devices. (See the Color Manager chapter for an
explanation of the different video device types.) However, the indexed color model has
several advantages. It requires less memory than a direct color model. It is also faster
because less information must be written to the display device, due to the reduced
resolution. In addition, it allows the use of a technique called color table animation.
Color table animation involves changing the index entries in the video device’s color table
to achieve a change in color, as opposed to changing the pixel values themselves. All pixel
values corresponding to the altered index entries suddenly appear on the display device in
the new color. By careful selection of index values and the corresponding colors, you can
achieve a number of special animation effects.
The indexed color model also has several disadvantages. Because the range of pixel values
is generally low, the number of colors that can be shown at any one time is
correspondingly low. Colors on such devices are a shared resource, just as the visible area
of a display device is shared by several windows. If desk accessories and application
windows wish to use different sets of colors, a problem of color contention arises. If color
table animation is also used (assuming the target display device supports it), the problem of
contention can become acute.
Although the problems presented by color table animation and color contention can be
solved using Color QuickDraw and Color Manager routines, the available solutions are
somewhat cumbersome. The Palette Manager handles these problems for your application
by providing an indexed color model built upon the more general RGB model. Your

About the Palette Manager V-153

—_
-_-

@

=
=)
i)

io)
©

bee

|

Inside Macintosh

application allocates a Palette object and fills it with RGB colors, along with information
describing how each color should be managed. When the Palette Manager detects that the
target display device allows an indexed color model, it manages the allocation of that
device’s color resources. As colors are requested and allocated, it updates its information

and adjusts the color matching scheme accordingly.

Color

Usage

The Palette Manager uses one of four methods for selecting

colors:

= Courteous colors have no special properties. For such colors, the Palette Manager
relies upon Color QuickDraw to select appropriate pixel values. Colors with specified
usages that can’t be satisfied by the Palette Manager will default to courteous colors.

This occurs, for example, when drawing to a device with no color look-up table, such

as a direct or fixed device. Courteous colors don’t change the color environment in any
way.

a Tolerant colors cause a change in the color environment unless the fit to the best
matching available color falls within a separately specified tolerance value.
a Animating colors are reserved by a palette and are unavailable to (and can’t be
matched by) any other request for color.
a Explicit colors always generate the corresponding entry in the device’s color table.
These color types are specified when using Palette Manager routines by using the following
constants:

CONST

{

Usage

constants

}

pmCourteous = $0000;
pmDithered = $0001;
pmTolerant = $0002;
pmAnimated = $0004;

pmExplicit

{reserved

for

future

use}

= $0008;

When you specify colors for a palette within a 'pltt' resource, you will usually assign the
same usage value to each color in the palette. However, if for some reason a particular
color must be used differently than the other colors in the palette, it can be assigned a
different usage value, either within the resource file, or within the application through use
of the SetEntryUsage routine.
The sections that follow provide more information on these color types.
Courteous

Colors

Courteous colors are provided for two reasons. First, they are a convenient placeholder.
If your application uses only a small number of colors you can place each of them ina
palette, ordered according to your preference. Suppose you have a palette resource which
consists of a set of eight colors, namely white, black, red, orange, yellow, green, blue, and

V-154 About the Palette Manager

~
—

w

e
@

~-

The Palette Manager
violet, in that order, each with a usage specified as courteous. Assuming further that the
palette resource ID number matched that of a color window (myColorWindow) you opened
earlier, the following calls will paint a rectangle (myRect) in yellow (palette entry 4, where
white is 0):
SetPort
(myColorWindow)
PmForeColor
(4);

PaintRect

;

(myRect) ;

This is exactly analogous to the following sequence of calls made using Color Quickdraw
routines, where yellowRGB is of type ColorSpec:
with

yellowRGB do begin
red := $FFFF;

green

blue
end;

:=

:=

{done

once

during

your

initialization}

SFFFF;

$0000

SetPort
(myColorWindow) ;
RGBForeColor
(yellowRGB) ;
PaintRect
(myRect) ;

The second reason for providing courteous colors is not immediately apparent. It involves
how colors are selected for palettes which use animation. The Palette Manager has access
to all palettes used by all windows throughout the system. When deciding which of a
device’s colors to allocate for animation, it checks each window currently drawn on that
device to see which colors the windows are using. It then chooses the color which is least
used and reserves that for animation.

In the first example shown above, the Palette

Manager would try to avoid the eight colors used in your palette, even though they are just
courteous colors. In the second example it would have no knowledge of your colors and
might steal them unnecessarily, and when your window is redrawn the selected colors
might not be as close to the desired colors as they previously were. If you intend to use
only a limited number of colors it is therefore best to place them in the window’s palette so
the Palette Manager will know about them.
Tolerant

Colors

Tolerant colors allow you to change the current color environment according to your needs.
When your window becomes the frontmost window on a device its palette and the colors
contained therein are given preference. Each tolerant color is compared to the best unique
match available in the current color environment (for each device on which the window is

drawn). When the difference between your color and the best available match is greater
than the tolerance you have specified the Palette Manager will modify the color environment
to provide an exact match to your color.
The tolerance value associated with each palette entry is compared to a measure of the
difference between two RGBColor values. This difference is an approximation of the
distance between the two points as measured in a Cartesian coordinate system where the

About the Palette Manager V-155

~-

as)

&
=
es)
ge
ia)
_

Inside Macintosh

axes are the unsigned red, green, and blue values. The distance formula used is shown
below:
A RGB

= maximum of (abs(Red1—Red2), abs(Green1—Green2), abs(Blue1—Blue2))

A value of $5000 is generally sufficient to allow matching without updates in reasonably
well-balanced color environments. A tolerance value of $0000 means that only an exact
match is acceptable. Any value of $0xxx, other than $0000, is reserved, and should not be
used in applications.
If your palette requires more colors than are currently available the Palette Manager will
check to see if any other palette has reserved entries for animation. If so it will dereserve
them and make them available for your palette. If you ask for more than are available on a
device, the Palette Manager cannot honor your request. However, you can still call

PmForeColor for such colors; as mentioned earlier, such colors default to courteous colors.

Color QuickDraw will still select the best color available, which of course must match one
of the colors elsewhere in your palette since the Palette Manager will only run out of colors
after it has given your palette all that it has. Two exceptions to this rule are noted below.
See the “Black, White, and Palette Customization” section and the “Palette Prioritization”
section describing the interaction among colors of different usages in a single palette.

Animating

Colors

Animating colors allow you to reserve device indexes for color table animation. Each
animating color is checked to see if it already has a reserved index for the target device. If
it does not, the Palette Manager attempts to find a suitable index. This is done by checking
all windows to see what colors they use, and which device indexes match those colors.

The least frequently used indexes are then reserved for your palette. The reservation
process is analogous to the Color Manager call ReserveEntry. The device index and its
corresponding color value is removed from the matching scheme used by Color
Quickdraw; you cannot draw with it by calling RGBForeColor. However, when you call
PmForeColor the Palette Manager will locate the reserved index and configure your
window’s port to draw with it. On multiple devices this will likely be a different index for
each device, but this process will be invisible to your application.
After reserving one or more device indexes for each animating entry it detects, the Palette
Manager will change the color environment to match the RGB values specified in the
palette. To use an animating color you must first draw with it using PmForeColor or
PmBackColor. To effect color table animation you can use either AnimateEntry (for a
single color) or AnimatePalette (for a contiguous set of colors).

in the section titled “Palette Manager Routines”.
Explicit

These calls are described

Colors

Explicit colors are provided as a convenience for users who wish to use colors in very
special ways. The RGB value in a palette is completely ignored if a color is an explicit
color. Explicit colors cause no change in the color environment and are not counted for
purposes of animation. Explicit colors always match the corresponding device index. A

PmForeColor call with a parameter of 12 will place a value of (12 modulo (MaxIndex+1))

V-156 About the Palette Manager

~l

~~

=

s°)

The Palette Manager
into the foreground color field of your window’s cGrafPort, where MaxIndex is the

maximum available index for each device under consideration. When you draw with an
explicit color, you get whatever color the device index currently contains.
One interesting use for explicit colors is that it allows you to monitor the color environment
on a device. For example, you could draw a grid of 256 explicit colors, 16-by-16, in a
small window. The colors shown are exactly those in the device’s color table. If color
table animation is taking place simultaneously the corresponding colors in the small
window will animate as well. If you display such a window on a 4-bit device, the first 16
colors will match the 16 colors available in the device and each row thereafter will be a
copy of the first row.
However, the main purpose for explicit colors is to provide a convenient indexed color
interface. Using the Color Manager, you can establish a known color environment using
the SetEntries routine on each device of interest. You can then easily select any of these
colors for drawing by setting your window’s palette to contain as many explicit colors as
are in the target device with the greatest number of indexes. PmForeColor will configure
the cGrafPort to draw with the index of your choice.
Warning: You should not use explicit colors in this fashion if you intend your
application to coexist in multi-application environments such as those provided by
MultiFinder™ or A/UX™ or when using color desk accessories that depend upon the
Palette Manager. However, for certain types of applications, especially those which
are written for a known device environment, explicit colors will tend to make indexed
color manipulation much more convenient.
Palette

Prioritization

To make the best use of the Palette Manager you should understand how it prioritizes the
colors you request. Prioritization is important only when the ActivatePalette routine is
called. This occurs automatically when your window becomes the front window, or when
you call ActivatePalette after changing one or more of the Palette’s colors or usage values.
Explicit and courteous colors are ignored and are not considered during prioritization.
They are important only during calls to PmForeColor and PmBackColor, or when scanning
all palettes to check which colors are in use. Of the remaining two types of colors,
animating colors are given preference. Starting with the first entry in your window’s
palette (entry 0), the Palette Manager checks to see if it is an animating entry. It checks
each animating entry to see if the entry has a reserved index for each appropriate device. If
the animating entry has no reserved index, the Palette Manager selects an index and
reserves it for animation. This process continues until all animating colors have been
satisfied or until the available indexes are exhausted.
Tolerant entries are handled next. Each tolerant entry is assigned its own, unique index
until all tolerant colors have been satisfied. The Palette Manager then calculates for each
entry the difference between the desired color and the color associated with the selected
index. If the difference exceeds the tolerance you have specified, the selected device entry
is marked to be changed to the desired color.

About the Palette Manager V-157

ss
~~

@

+)
=)
is)
ge
9)

ber

4

Inside Macintosh

When as many animating and tolerant entries have been matched as are possible, the Palette
Manager checks to see if the color environment needs to be modified. If modifications are
needed, it forces the device environment to a known state (overriding any calls made to the

Color Manager outside the Palette Manager) and calls the Color Manager to change the

device’s color environment accordingly (with the SetEntries routine).

Finally, if the color environment on a given device has changed, the Palette Manager
checks to see if this change has impacted any other window in the system. If another
window was affected, that window is checked to see if it specifies an update in the case of
such changes. Applications can use the SetPalette routine to specify if a window should be
updated. If so, an InvalRect is performed using the bounding rectangle of the device which
has been changed.
As mentioned earlier, when you specify a sequence of tolerant entries, the indexes assigned
are guaranteed to be unique provided there are sufficient indexes available. If you specify a
pair of tolerant entries that can match each other within tolerance, they will each be matched
to a different index, and the color environment changed accordingly (if necessary). If this
is not the result you desire, then you should convert one of the two to a courteous entry. In
the best case the courteous color will, at drawing time, match the exact color you have
requested for it, a service provided automatically by Color Quickdraw. In the worst case,
the courteous color will match its tolerant counterpart, because that color is at least
guaranteed to be provided when your window is frontmost (again assuming enough entries
are available).

Black,

White,

and

Palette

Customization

Due to the “first-come, first-served” nature of the Palette Manager, you can prioritize your
palettes to customize the color environment automatically for a variety of display depths.
Black and white should generally be the first two colors in your palette. Color Quickdraw,
in order to support standard Quickdraw features, works best when black and white are
located at the end and beginning, respectively, of each device’s color table. The Palette
Manager enforces this rule, and thus the maximum number of indexes available for
animating or tolerant colors is really the maximum number of indexes minus two.
However, if black or white are present in your palette, they won’t be counted as unique
indexes if any of your tolerant entries match them within the specified tolerance.
With black and white as the first two colors in your palette, you have matched the two
colors the Palette Manager will allow for a 1-bit device. The next two colors should be
assigned to the two you wish to have should the device be a 2-bit device. Likewise the first
16 colors should be the optimal palette entries for a 4-bit device. And, for future
expandability, the first 256 colors (if you need that many) should be the optimal palette
entries for an 8-bit device. A palette is limited to 4095 entries.

V-158 Color Palette Records

~—
—

—@

The Palette Manager

COLOR

PALETTE

RECORDS

TYPE

=

RECORD
CiRGB:
ciUsage:
ciTolerance:
ciFlags:
ciPrivate:

RGBColor;
INTEGER
INTEGER;
INTEGER;
LONGINT;

{absolute RGB values}
{color usage information}
{tolerance value}
{private field}
{private field}

END;

Field

descriptions

ciRGB

The ciRGB is the absolute RGB value defined by Color QuickDraw.

ciUsage

The ciUsage field contains color usage information that determines
the properties of a color.

ciTolerance

The ciTolerance is a value used to determine if a color is close
enough to the color chosen; if the tolerance value is exceeded, the

preferred color is rendered in the device’s color table for the selected
index.

ciFlags

The ciFlags field is used internally by the Palette Manager.

ciPrivate

The ciPrivate field is used internally to store information about color
allocation: not for use by application.

The data structure for a color palette is made up of an array of ColorInfo records, plus other
information relating to the use of the colors within the palette. The 'pltt' resource is an
image of the Palette data structure.
Note: The palette is accessed through the Palette Manager routines only: do not
attempt to directly access any of the fields in this data structure.
TYPE

PaletteHandle = *PalettePtr;
PalettePtr
= “Palette;
Palette = RECORD

pmEntries:

pmDataFields:

pminfo:

END;

integer;

array

array

”
tee

La*)

=

=
=
ge
oLord

The basic data structure for a color palette is the ColorInfo record. It consists of the
following:
ColorInfo

ww

[0..6]

[0..0]

of

of

integer;

ColorInfo;

{entries
{private

in

pmInfo}

fields}

Color Palette Records V-159

Inside Macintosh
Field

descriptions

pmEntries

The pmEntries field contains the number of entries in the pmTable.

pmDataFields

The pmDataFields field contains an array of integers that are used
internally by the Palette Manager.

pminfo

The pmInfo field contains an array of ColorInfo records.

USING THE PALETTE

MANAGER

The InitPalettes routine is always called before any other Palette Manager routines. It_
initializes the Palette Manager, if necessary, and searches the device list to find all active
CLUT devices.
Normally, a new color palette is created from a 'pltt' resource, using GetNewPalette. To
create a palette from within an application, use NewPalette. Whichever method is used to
create the palette, the SetPalette routine can then be used to render the Palette on the display
device. The DisposePalette procedure disposes of the entire palette.
The ActivatePalette routine is called by the Window Manager every time your window’s
status changes. When using the Palette Manager routines, you should use ActivatePalette
after you have made changes to a palette. GetPalette is used to return a handle to the palette
currently associated with a specified window.
To use color table animation, you can change the colors in a palette and on corresponding
devices with the AnimateEntry and AnimatePalette routines. GetEntryColor,
SetEntryColor, GetEntryUsage, and SetEntryUsage allow an application to access and
modify the fields of a palette.
CTab2Palette copies the specified color table into a palette, while Palette2CTab does the
opposite, and copies a palette into a color table. Each routine resizes the target object as
necessary.

COLOR

PALETTES

IN A RESOURCE

FILE

The format of a palette resource (type 'pltt’) is an image of the palette structure itself. The
private fields in both the header and in each ColorInfo record are reserved for future use.

The following table shows a sample palette resource with 16 entries as it would appear
within a resource file.

V-160 Color Palettes in a Resource File

|
a}

=

ta)

The Palette Manager

eee
~-

@

=<

ml

Table

6-1.

Resource
data

Sample

Palette

Format

‘pltt'

(1,

i
=
=
ge
@

Resource
Description

"My

palette

resource")

beer

{

$"0010
S"FFFF

0000
FFFF

0000
FFFF

0000
0002

0000
0000

0000
0000

0000
0000

0000"
0000"

/*
/*

header
white

-

$"0000
$"FCOO

0000
F37D

0000
O52F

0002
0002

0000
0000

0000
0000

o000
0000

0000"
0000"

/*
/*

black
yellow

*/
-

S"FFFF
$"0371

648A
Cé6FF

028C
9EC9

0002
0002

0000
0000

0000
0000

0000
0000

0000"
0000"

/*
/*

orange
*/
blue
green

$"0000
$"0000
$"DD6B
$"C000
$"8000
S"FFFF
S"93FF
$"6524
$"0000
S"65DE
$"8000

AOO0O
0000
O8C2
C000
8000
C3DC
281A
C2FF
FFFF
AD85
0000

0000
D400
OGA2
C000
8000
8160
12CC
0000
O4F1
FFFF
FFFF

0002
0002
0002
0002
0002
0002
0002
0002
0002
0002
0002

0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000

0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000

0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000

0000"
0000"
0900"
0000"
0000"
0000"
0000"
oO000"
O000"™
0000"
0000"

/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*

green
*/
blue
*/
red
*/
light
gray
*/
medium
gray
*/
beige
*/
brown
*/
olive
green
*/
bright
green
*/
sky
blue
*/
violet
*/

PALETTE MANAGER

/*depths
/*
/*>=

-

*/

$0010
(16)
used
in
all

bits/pixel
4

entries
screen

used

in

depths

-

used

in

*/

bits/pixel

*/

*/
*/

>=

2*/

depths

*/

ROUTINES

The Palette Manager routines described in this section are designed for use with the
Macintosh II.
Initialization
PROCEDURE

and

Allocation

InitPalettes;

InitPalettes initializes the Palette Manager.

It searches for devices which support a Color

Look-Up Table (CLUT) and initializes an internal data structure for each one.

made by InitWindows and should not have to be made by your application. |
FUNCTION

This call is

NewPalette
(entries:
INTEGER;
srcColors:
CTabHandle;
srcUsage,
srcTolerance:
INTEGER)
: PaletteHandle;

NewPalette allocates a new Palette object which contains a table of colors with enough
room for “entries” colors. It fills the table with as many RGB values from srcColors as it
has or as it can fit. It sets the usage field of each color to srcUsage and the tolerance value
of each color to srcTolerance. If no color table is provided (srcColors = NIL) then all
colors in the palette are set to black (red = $0000, green = $0000, blue = $0000 ).

Palette Manager Routines V-161

|

Inside Macintosh
(paletteID:

GetNewPalette

FUNCTION

INTEGER)

:

PaletteHandle;

GetNewPalette fetches a Palette object from the Resource Manager and initializes it. If you
open a new color window with GetNewCWindow, this routine is called automatically with
paletteID equal to the window’s resource ID. A palette resource is identified by type ‘pltt.
A paletteID of 0 is reserved for the system palette resource which is used as the default
palette for noncolor windows and color windows without assigned palettes.
PROCEDURE

DisposePalette

(srcPalette:

PaletteHandle) ;

DisposePalette disposes of a Palette object. If the palette has any entries allocated for
animation on any display device, these entries are relinquished prior to deallocation of the
object.

Interacting
PROCEDURE

With

the

Window

ActivatePalette

Manager

(srcWindow:

WindowPtr) ;

ActivatePalette is the routine called by the Window Manager when your window’s status
changes:

for example, when it opens, closes, moves, or becomes frontmost.

You should

call ActivatePalette after making changes to a palette with the utility routines described
below. Such changes do not take effect until the next call to ActivatePalette, thereby
allowing you to make a series of palette changes without any immediate change in the color
environment.
If srcWindow is frontmost, ActivatePalette examines the information stored in the palette
associated with srcWindow and attempts to provide the color environment described
therein. It determines a list of devices on which to render the palette by intersecting the port
rect of the srcWindow with each device. If the intersection is not empty, and if the device
has a Color Look-Up Table (CLUT), then ActivatePalette checks to see if the color
environment is sufficient. If a change is required, ActivatePalette calls the Color Manager
to reserve or modify the device’s color entries as required. It then generates update events
for all affected windows which desire color updates.
PROCEDURE

SetPalette

(dstWindow:

PaletteHandle;

cUpdates:

WindowPtr;

srcPalette:

BOOLEAN) ;

SetPalette changes the palette associated with dstWindow to srcPalette. It also records
whether the window wants to receive updates as a result of a change to its color
environment. If you want dstWindow to be updated whenever its color environment
changes, set cCUpdates to TRUE.

V-162 Palette Manager Routines

~I

~

=

oy
roe

The Palette Manager

=

@
=

FUNCTION

GetPalette

(srcWindow:

WindowPtr)

:

PaletteHandle;

GetPalette returns a handle to the palette associated with srcWindow.

If no palette is

associated with srcWindow, or if srcWindow is not a color window, GetPalette returns

NIL.

Drawing

With

Color

Palettes

These routines enable applications to specify foreground and background drawing colors
with the assistance of the Palette Manager. Substitute these for Color Quickdraw’s
RGBForeColor and RGBBackColor routines when you wish to use a color from a palette.
You may still use RGBForeColor and RGBBackColor in the normal way whenever you
wish to specify drawing colors, for example when you wish to use a color which is not
contained in your palette.
PROCEDURE

PmForeColor

(dstEntry:

INTEGER) ;

PmForeColor sets the RGB and index forecolor fields of the current cGrafPort according to
the palette entry of the current cGrafPort (window) corresponding to dstEntry. For
courteous and tolerant entries, this call performs an RGBForeColor using the RGB color of
the palette entry. For animating colors it will select the recorded device index previously
reserved for animation (if still present) and install it in the cGrafPort.

The RGB forecolor

field is set to the value from the palette entry. For explicit colors PmForeColor places
(dstEntry modulo (MaxIndex+1)) into the cGrafPort, where MaxIndex is the largest index
available in a device’s CLUT. When multiple devices are present with different depths,
MaxIndex varies appropriately for each device.
PROCEDURE

PmBackColor

(dstEntry:

INTEGER) ;

PmBackColor sets the RGB and index backcolor fields of the current cGrafPort according
to the palette entry of the current cGrafPort (window) corresponding to dstEntry. For
courteous and tolerant entries, this call performs an RGBBackColor using the RGB color
of the palette entry. For animating colors it will select the recorded device index previously
reserved for animation (if still present) and install it in the cGrafPort.

The RGB backcolor

field is set to the value from the palette entry. For explicit colors PmBackColor places

(dstEntry modulo (MaxIndex+1)) into the cGrafPort, where MaxIndex is the largest index

available in a device’s color table. When multiple devices are present with different depths,
MaxIndex varies appropriately for each device.

Palette Manager Routines V-163

=

a

ge
@=

Inside Macintosh

Color

Table

PROCEDURE

Animation

AnimateEntry
(dstWindow:
srcRGB:
RGBColor) ;

WindowPtr;

dstEntry:

INTEGER;

AnimateEntry changes the RGB value of dstEntry in the palette associated with dstWindow
to the color specified by srcRGB. Each device for which an index has been reserved is
immediately modified to contain the new value. This is not considered to be a change to the
device’s color environment since no other windows should be using the animated entry. If
the palette entry is not an animating color, or if the associated indexes are no longer
reserved, no animation is performed.
If you have blocked color updates in a window, by using SetPalette with CUpdates set to

FALSE, you may observe undesired animation.

This will occur when ActivatePalette

reserves device indexes for animation which are already used in the window. Redrawing
the window, which normally occurs as the result of a color update event, will remove any
animating colors which do not belong to it.
PROCEDURE

AnimatePalette
(dstWindow:
WindowPtr;
srcCTab:
CTabHandle;
srcIndex,dstEntry,dstLength:
INTEGER) ;

AnimatePalette performs a function similar to AnimateEntry, but it acts upon a range of
palette entries. Beginning at srcIndex (which has a minimum value of 0), the next
dstLength entries are copied from srcCTab to dstWindow’s palette, beginning at dstEntry.
If srcCTab is not sufficiently large to accommodate the request, as many entries are
modified as possible and the remaining entries are left unchanged.

Manipulating
PROCEDURE

Palette

GetEntryColor
INTEGER;

VAR

Entries
(srcPalette:

dstRGB:

PaletteHandle;

RGBColor);

srcEntry:

GetEntryColor allows your application to access the color of a palette entry. The color may
be modified by using the SetEntryColor routine described below.

V-164 Palette Manager Routines

a |
eS

=@

The Palette Manager

=
=

®
a

PROCEDURE

SetEntryColor
(dstPalette:
PaletteHandle;
INTEGER;
srcRGB:
RGBColor);

dstEntry:

™

SetEntryColor provides a convenient way for your application to modify the color of a
single palette entry. When you perform a SetPaletteEntry, the entry is marked as having
changed, but no change occurs in the color environment. The change will be effected upon
the next call to ActivatePalette. Modified entries are marked such that the palette will be
updated even though no update might be required by a change in the color environment.
PROCEDURE

GetEntryUsage
INTEGER;

VAR

(srcPalette:

PaletteHandle;

dstUsage,dstTolerance:

srcEntry:

INTEGER) ;

GetEntryUsage allows your application to access the usage fields of a palette entry, namely
ciUsage and ciTolerance. These fields may be modified by using the SetEntryUsage
routine described below.
PROCEDURE

SetEntryUsage
(dstPalette:
PaletteHandle;
INTEGER;
srcUsage,srcTolerance:
INTEGER) ;

dstEntry:

SetEntry Usage provides a convenient way for your application to modify the color of a
single palette entry. When you perform a SetEntryUsage, the entry is marked as having
changed, but no change occurs in the color environment. The change will be effected upon
the next call to ActivatePalette. Modified entries are marked such that the palette will be
updated even though no update might be required by a change in the color environment. If
either myUsage or myTolerance are set to $FFFF (—1) they will not be changed.
This call is provided to allow easy modifications to a palette created with NewPalette or
modified by CTab2Palette. In such cases the ciUsage and ciTolerance fields are
homogeneous since only one value can be designated for each. You will typically call
SetEntryUsage after those calls in order to adjust and customize your palette.
PROCEDURE

=

is)
ge
@

CTab2Palette
(srcCTab:
CTabHandle;
dstPalette:
PaletteHandle;
srcUsage,srcTolerance:
INTEGER) ;

CTab2Palette is a convenience procedure which copies the fields from an existing
ColorTable record into an existing Palette record. If the records are not the same size then
the Palette record is resized to match the number of entries in the ColorTable record. If
dstPalette has any entries allocated for animation on any display device, these entries are
relinquished prior to copying the new colors. If you wish to effect color table animation
you can change the colors in a palette, and on corresponding devices, with the
AnimateEntry and AnimatePalette routines described above. Changes made to a palette by
CTab2Palette don’t take effect until the next ActivatePalette is performed. If either the color
table handle or the palette handle are NIL, no operation is performed.

Palette Manager Routines V-165

Inside Macintosh
PROCEDURE

Palette2CTab
CTabHandle) ;

(srcPalette:

PaletteHandle;

dstCTab:

Palette2CTab is a convenience procedure which copies all of the colors from an existing
Palette record into an existing ColorTable record. If the records are not the same size then
the ColorTable record is resized to match the number of entries in the Palette record. If
either the palette handle or the color table handle are NIL, no operation is performed.

V-166 Palette Manager Routines

~—I

ac)

me
4°]

-_

The Palette Manager

SUMMARY

OF THE PALETTE

{

Usage

constants

MANAGER

Data

=

implemented}

Types

TYPE

ColorInfo

= RECORD
CiRGB:

ciUsage:

ciTolerance:

ciFlags:

ciPrivate:

RGBColor;

{absolute

INTEGER;

{tolerance

INTEGER

INTEGER;

LONGINT;

{color

RGB

values}

usage

{private

{private

information}

value}

field}
field}

END;

PaletteHandle = “*PalettePtr;
PalettePtr
= “Palette;
Palette = RECORD
pmEntries:
integer;

pmDataFields:

array

[0..6]

of

pminfo:

array

[0..0]

of

integer;

{entries in
{ pmInfo}

{private

{
ColorInfo;

fields}

}

}

END;

Routines
Initialization

and

Allocation

PROCEDURE
FUNCTION

InitPalettes;
NewPalette

FUNCTION

GetNewPalette

PROCEDURE

DisposePalette

(entries:
INTEGER;
srcColors:
CTabHandle;
srcUsage, srcTolerance:
INTEGER)
PaletteHandle;
(paletteID:

(srcPalette:

INTEGER)

<=

@

}

pmCourteous = $0000;
pmDithered = $0001;
{not
pmTolerant = $0002;
pmAnimated = $0004;
pmExplicit = $0008;

®

=
ge

Constants
CONST

=

:

PaletteHandle;

PaletteHandle) ;

Summary of the Palette Manager V-167

Inside Macintosh

Interacting
PROCEDURE

with

the

Window

ActivatePalette

PROCEDURE

SetPalette

Manager

(srcWindow:

(dstWindow:

GetPalette

Drawing

with

Color

Palettes

PROCEDURE
PROCEDURE

PmForeColor
PmBackColor

(myEntry:
(myEntry:

Table

(srcWindow:

AnimateEntry

PROCEDURE

AnimatePalette

Manipulating

(dstWindow:

WindowPtr;

PROCEDURE

SetEntryColor

(dstPalette:

PROCEDURE

GetEntryUsage

(srcPalette:

PROCEDURE

SetEntryUsage

PROCEDURE

CTab2Palette

PROCEDURE

Palette2CTab

Assembly

Language

pmAnimated
pmExplicit

BOOLEAN) ;

PaletteHandle;

dstEntry:

INTEGER;

Palettes
(srcPalette:

pmTolerant

:

sxrcRGB: RGBColor);
(dstWindow:
WindowPtr;
srcCTab:
CTabHandle;
srciIndex, dstEntry,dstLength:
INTEGER) ;

GetEntryColor

pmCourteous
pmDithered

WindowPtr)

INTEGER) ;
INTEGER) ;

PROCEDURE

Palette

srcPalette:

cUpdates:

Animation

PROCEDURE

;

WindowPtr;

PaletteHandle;

FUNCTION

Color

WindowPtr);

Manager

VAR

dstRGB:

SrcRGB:

PaletteHandle;

srcEntry:

INTEGER;

PaletteHandle;

dstEntry:

INTEGER;

PaletteHandle;

srcEntry:

INTEGER;

RGBColor) ;

RGBColor);

VAR dstUsage,dstTolerance:
INTEGER) ;
(dstPalette:
PaletteHandle;
dstEntry:
srcUsage,srcTolerance:
INTEGER) ;
(srcCTab:
CTabHandle;
dstPalette:
PaletteHandle;
srcUsage, srcTolerance:
INTEGER) ;

(srcPalette: PaletteHandle;
CTabHandle) ;

dstCTab:

Information

Equates

EQU
EQU

$0000
$0001

;courteous colors
;reserved for future

EQU
EQU

$0004
$0008

;animating colors
;explicit colors

EQU

$0002

V-168 Summary of the Palette Manager

;tolerant

colors

use

INTEGER;

~I
=

w

<b
@—

The Palette Manager
s

CoéolorInto

ciRGB

ciUsage

ciTolerance
ciFlags
ciPrivate
ciSize
;

Palette

structure

pmEntries

EQU
EQU
EQU

pminfo
pmHdrSize

$0000

$0006
$0008

;absolute RGB values
;color usage information
;tolerance value

$000C
$0010

;Ssize

SOOOA

$0000
$0010
$0010

;private
;private

the

;entries

in

;color

;size

™

field

of

info

of

ColorInfo

data

structure

pmiInfo

Palette

@®
~
|
os)
ge
@

structure

EQU
EQU
EQU
EQU
EQU
EQU

=

header

Summary of the Palette Manager V-169

8

THE

COLOR

PICKER

PACKAGE

o°
OQ

172
C72
172
174
174
176

J
°

About This Chapter
The Color Picker Package
The Color Picker Dialog Box
Color Picker Package Routines
Conversion Facilities
Summary of the Color Picker Package

bea |

an(er)

~_

is)
*

V-171

Inside Macintosh

ABOUT

THIS CHAPTER

This chapter describes the Color Picker, a new package that allows applications to present
users with a standard interface for color selection. You should be familiar with color on the
Macintosh and graphic devices, as discussed in the Color QuickDraw and Graphic Devices
chapters of this volume.

THE COLOR

PICKER PACKAGE

The Color Picker Package is a tool that applications can use to present a standard user
interface for color selection. It also provides routines for converting color values between
several different color systems. The Color Picker Package does not alter the Color LookUp Table (CLUT), if any, associated with the current graphics device.
Once the user chooses a color, Color Picker returns it to the application, in the form of an

RGBColor value, leaving the graphics device in its original state. The application can do
what it likes with the color selection, with as much or as little attention to the available
graphics hardware as it deems appropriate. On black and white hardware (or in less

than 4-bit mode), the display is in black and white; Color Picker returns the value selected,

but does not call any color routines.

On direct device hardware the exact color can be used without extra effort, while on fixed

CLUT hardware it can only be approximated. On most hardware, such as Apple’s TFB
graphics card, which has a variable CLUT, the application decides how faithfully to
reproduce the color, because it can replace an entry in the device’s CLUT to show it
exactly, or treat the table as fixed and approximate the color. Color Picker itself takes
advantage of the hardware on such devices, displaying the exact color by borrowing a color
table entry. As result, applications that are content to approximate the color will show
users colors that differ somewhat from the ones picked.

THE COLOR

PICKER DIALOG

BOX

Developers can present the Color Picker dialog box, shown in Figure 1 (See frontispiece
for a color representation of this dialog box.) to a user by means of the Color Picker
routine, described later in this chapter.

V-172 The Color Picker Dialog Box

The Color Picker Package

e
2)

S.
S

Select a highlight color.

=y

a
ay
@

ie)

| 7281

Saturation

|56174

Brightness

|57344

Red

|57344

Green

| 40960

Blue

|81924

EDEDED

Hue

ECHEDEY

Ler

Figure 1. Color Picker Dialog Box

When called by an application, the Color Picker supplies the prompt text, which appears in
the upper-left corner, and the initial color, which appears in the bottom of the two
rectangles below the prompt. The color being picked, in the upper rectangle, ranges
rapidly over the entire color space, in response to the controls in the rest of the dialog. The
calling application also supplies the location of the top-left corner of the dialog window.
The user is allowed to select a single color, from the entire range the hardware can produce.
The wheel allows users to select a given hue and saturation simultaneously. The center of
the wheel displays zero saturation (no hue mixed in); the outer boundary is maximum
saturation (no gray mixed in); colors on the edge of the wheel are pure hues. The scroll bar
at right controls the brightness (value) of the wheel.
The two groups of text fields (Hue/Saturation/Brightness and Red/Green/Blue) show the

parameters of the color being picked in two independent color systems.
represents value in the HSV model.

Brightness

The HSV values are the primary color system, which correspond to the controls in the
dialog box.

The RGB values are the alternate color system, and the way they vary in

response to the dialog controls is not intuitive. Only users who understand both color
systems will understand how the RGB values vary in relation to the rest of the dialog. (See
the Color Quickdraw chapter for more information.) The alternate color system is intended
to make life easier for users accustomed to something other than the HSV model.

The Color Picker Dialog Box V-173

|

Inside Macintosh

The range for all of the component values is 0 to 65,535. Larger values are clipped to the
maximum after the user exits the field. When incrementing or decrementing the hue via the
arrow controls, 0 wraps around to 65,535, and vice versa, so the user can circumnavigate
the wheel unimpeded. The hue value for red is 0; green is 21,845; blue is 43,690.

COLOR

PICKER PACKAGE

ROUTINES

FUNCTION

GetColor(where:
Point;
prompt:
Str255;
VAR outColor:
RGBColor)
: BOOLEAN;

inColor:

RGBColor;

GetColor displays the Color Picker dialog box on the screen, with its top-left corner located
at where. (The where Point should be on the main gDevice.) If where = (0,0), the dialog
box is positioned neatly on the screen, centered horizontally, and with one third of the

empty space above the box, two thirds below, whatever the screen size.

The prompt string is displayed in the upper-left corner of the dialog box. InColor is the
starting color, which the user may want for comparison, and is displayed immediately
below the current output color (the one the user is picking). OutColor is set to the last color
value the user picked, if and only if the user clicks OK.

On entry, it is treated as

undefined, so the output color sample originally matches the input. While the color being
picked may vary widely, the input color sample remains fixed, and clicking in the input
sample resets the output color sample to match it.
GetColor returns TRUE if the user exits via the OK button, or FALSE if the user cancels.

Assembly-language note: the trap macro for the Color Picker Package is
_Pack12. The routine selectors are as follows:
Fix2SmallFract
SmalilFract2Fix

CMY2RGB
RGB2CMY
HSL2RGB
RGB2HSL
HSV2RGB
RGB2HSV

GetColor

COLOR

.EQU
.EQU

.EQU
-EQU
-EQU
.EQU
.EQU
-EQU

.EQU

i
yd

3
4
5
6
z
8

9

PICKER CONVERSION

FACILITIES

The Color Picker provides six procedures for converting color values between CMY and
RGB, and between HSL or HSV and RGB.
routines.

V-174 Color Picker Conversion Facilities

Most developers will not need to use these

The Color Picker Package
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE

CMY2RGB
RGB2CMY
HSL2RGB
RGB2HSL
HSV2RGB
RGB2HSV

(cColor:
(rColor:
(hColor:
(rColor:
(hColor:
(rColor:

CMYColor;
RGBColor;

HSLColor;
RGBColor;
HSVColor;
RGBColor;

VAR
VAR
VAR
VAR
VAR
VAR

rColor:
cColor:
rColor:
hColor:
rColor:
hcolor:

RGBColor) ;

CMYColor) ;
RGBColor) ;
HSLColor) ;
RGBColor) ;
HSVColor) ;

For developmental simplicity in switching between the HLS and HSV models, HLS is
reordered into HSL. Thus both models start with hue and saturation values;
value/lightness/brightness is last.
The CMY, HSL, and HSV structures are defined by ColorPicker with SmallFract values

rather than INTEGER values (as in RGBColor).

of a Fixed number, which is the low-order word.

A SmallFract value is the fractional part

The INTEGER values in RGBColor are

actually used as unsigned integer-sized values; by using SmallFracts, ColorPicker avoids
sign extension problems in the conversion math.

The Color Picker provides two functions for converting between SmallFract and Fixed
numbers. Most developers will not need to use these facilities.
FUNCTION
FUNCTION

Fix2SmallFract(f:
SmallFract2Fix(s:

Fixed):
SmallFract;
SmallFract):
Fixed;

A SmallFract can represent a value between 0 and 65,535. They can be assigned directly
to and from INTEGERs.

Color Picker Conversion Facilities V-175

oe
OQ

=

=

ber

aCG

|

rae

©&

Inside Macintosh

SUMMARY

OF THE COLOR

PICKER

PACKAGE

{maximum

SmallFract

Constants
CONST
MaxSmallFract

Data

=

SOQOOFFFF;

value,

as

LONGINT}

Types

TYPE

SmallFract

=

INTEGER;

HSVColor

=

RECORD

{unsigned

hue:

SmallFract;

value:

SmallFract;

Saturation:

fraction

{fraction

SmallFract;

{0-1,

0

{0-l,

{

0

is

is

between

of

intensity}

circle,

gray,

black,

1

1

0

is

and

red

is

1}

at

pure
max

0}

color}
}

END;
HSLColor =

RECORD

hue:
Saturation:
lightness:

SmallFract;
SmallFract;
SmallFract;

{fraction of circle,
red at 0}
{0-1,
0 is gray,
1 is pure color}
{0-1,
0 is black,
1 is white}

END ;

CMYColor
=
cyan:
magenta:
yellow:
END;

RECORD
{CMY and
SmallFract;
SmallFract;
SmallFract;

RGB

are

complements}

Routines
FUNCTION

GetColor(where:

VAR

Conversion
FUNCTION

FUNCTION

outColor:

Point;

RGBColor):

prompt:

Str255 ;

BOOLEAN;

Functions

Fix2SmallFract(f:

SmallFract2Fix(s:

Fixed):

SmallFract;

SmallFract):

V-176 Summary of the Color Picker Package

Fixed;

inColor:

RGBColor;

The Color Picker Package
Color

Conversion

PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE

Procedures

CMY2RGB (cColor:
RGB2CMY (rColor:
HSL2RGB (hColor:
RGB2HSL(rColor:
HSV2RGB (hColor:
RGB2HSV (rColor:

CMYColor;
RGBColor;

HSLColor;

RGBColor;

HSVColor;

RGBColor;

VAR
VAR
VAR
VAR
VAR
VAR

rColor:

cColor:
EColor:
hColor:
rColor:
hColor:

RGBColor) ;
CMYColor) ;
RGBColor) ;
HSLColor) ;
RGBColor) ;
HSVColor) ;

KH

OQ
S
°

=

—

=e

e)
oa

©

Le

Assembly-Language

Information

Constants
Fix2SmallFract
SmallFract2Fix

.EQU
.EQU

GetColor

.EQU

CMY2RGB
RGB2CMY
HSL2RGB
RGB2HSL
HSV2RGB
RGB2HSV

.EQU
.EQU
.EQU
.EQU
.EQU
.EQU

1
2

3
4
5
6
7
8

9

Macro
_PACK12

Summary of the Color Picker Package V-177

4

9

THE

FONT

MANAGER

180
180
180

About the Font Manager
Font Manager Routines
Fractional Character Widths

181
183
184

Font Manager Data Structures
Font Color Tables
Font Records

181

185

187

Font Search Algorithm

N=)
_

=)
=|

Family Records

_

Summary of the Font Manager

$9
—}
£9
i)
fo)

er |

V-179

Inside Macintosh

ABOUT THE FONT MANAGER
The Font Manager has been enhanced. Multibit pixel description for fonts provides color
support on the Macintosh II; this includes the ability to create “gray-scale” fonts—character
images with shades of gray (instead of merely black and white).
The SetFractEnable routine has been put into ROM, various bugs have been fixed, and a

better font search algorithm has been implemented.

FONT MANAGER

ROUTINES

One Font Manager routine, SetFractEnable, that was not in the 128K ROM (but was
available in the Pascal interfaces) has been added to both the Macintosh SE and Macintosh
II ROMs.

Assembly-language note:
Assembly-language programmers should call
SetFractEnable rather than change the value of the global variable FractEnable.

FRACTIONAL

CHARACTER

WIDTHS

One correction and two cautionary points should be added to the discussion in Volume IV
of how the Font Manager communicates character widths:
m You will get accurate character widths using the QuickDraw routine MeasureText
(rather than TextWidth as stated in Volume IV), or by looking in the global width
table.
= A font request made with scaling disabled will not necessarily return the same result as
an identical request with scaling enabled. The widths are sure to be the same only if
fractional widths are enabled, and if the font does not have a font character-width table

and is a member of a family record with a family character-width table.

a A font request with either twice the point size or a numerator/denominator scale factor
of 2 is not guaranteed to double the widths of the characters exactly. Instead, the
widths returned accurately describe how QuickDraw measures and spaces the
characters. This is especially noticeable for algorithmically-applied style modifications
like boldfacing. Boldfacing makes the character strike one pixel wider, regardless of
point size. A font with a family character-width table, however, describes the spacing
of the characters correctly.

To cause two different font requests to measure the same, or proportionately, use the
QuickDraw routines SpaceExtra and CharExtra to adjust the widths of the spaces and other

V-180 Fractional Character Widths

The Font Manager
characters. In most cases, it’s sufficient to simply pass the difference of the two measures
divided by the number of spaces on the line to SpaceExtra. If the difference is too large or
small, or if the line does not contain any spaces, you can adjust the line length with the
CharExtra routine.

FONT SEARCH

ALGORITHM

When passed a font request, the Font Manager takes a number of steps to provide the
desired font; if the font can’t be found, it looks for other fonts with which to fill the

request. The search order is as follows:

=

ss

w a'FOND' resource. It first checks the last used '"FOND', then checks the most
recently-used width tables (a handle to them is contained in the global variable
WidthListHand), and finally calls GetResource (looking through the chain of open

resource files, beginning with the application resource file). The width table it checks
is that of the nearest size and font that it found.

ms a'FONT' resource without a corresponding 'FOND' (again calling GetResource)
m the application font
m a “neighborhood” base font. For fonts numbered below 4096, the neighborhood base
font is 0. For fonts numbered 4096 and above, it is the next lower font whose number
is a multiple of 512.
m the system font
a the Chicago 12 font

FONT MANAGER

DATA STRUCTURES

This section describes support for fonts with depth on the Macintosh II; most of the
information presented here is useful only to assembly-language programmers.
Just as the Color QuickDraw pixel image lets you use multiple bits to describe each pixel,
the Font Manager lets you create fonts whose character images contain multiple bits per
pixel. The number of bits per pixel, or the font depth, is specified in the font record
(outlined below); font depths of one, two, four, and eight bits are supported.
Drawing to the screen is considerably faster if the font depth matches the screen depth
specified by the user in the Control Panel. For speedy access, 4-bit and 8-bit versions of
the system font, as well as a 4-bit Geneva font, are stored in the Macintosh II ROM

"NENT' resources.

—)

Ce

i

as

It’s not necessary, however, to create separate resources matching each of the possible
screen depths for every font family. If a resource (either of type 'FONT' or 'NFNT’) with

Font Manager Data Structures V-181

<

+S)
|
i)
ge
@

= |

Inside Macintosh

a depth corresponding to the current screen depth can’t be found, the Font Manager
expands the 1-bit font into a synthetic font matching the current screen depth.
A synthetic font list contains information about each synthetic font; the format of an entry in
this list is given in Figure 1. The global variable SynListHandle contains a handle to the
synthetic font list.
handle to font record (long word)

resource ID of font (word)
foreground color (8 bytes)
background

color (8 bytes)

Figure 1. Synthetic Font List Entry
Figure 2 shows the relationship between the Font Manager data structures, modifying the
figure that was given in Volume IV and adding the synthetic font list.
synthetic font list
(synthetic

font

oer

PE COPS)

i

ferveseserefeeesseeseessseeeetserenennneeetunnenenssnseneennsncenanasneeneunnneas x

4
width

t

able

ro)

:

b

K: evercescces :

width table

-

width table

=

width list

Secccncce

| SynListHandle|

font

record

font record

wr

j

FMOutRec

cnfODtHENM
|e fmm
ey family record

(up to 12 handles)}
c
4

ke 7:

FMInRec

= |
2 | cavactssnaioss widthTabHandle
lastEOND

——

system heap

;
:
seen?

| Tamily record

widthListHand

low memory
Figure 2. Font Manager Data Structures

V-182 Font Manager Data Structures

PaMuly reeare

application heap

The Font Manager

Font

Color

Tables

With resources of type 'NFNT', you can specify absolute colors for the font by also
supplying a color table. Stored as a resource of type ‘fctb' with the same ID as the

associated 'NFNT' resource, this table is simply the ColorTable record described in the

Color Manager chapter.

MN

purple

D

fuchsia

OF

foreground color

-F>-

gold

WD

yellow

yn

A 4-bit font depth provides index values for a color table containing 16 entries. If there are
index values for which no corresponding entries are found in the associated color table, the
Font Manager assigns colors based on the current port’s foreground and background
colors. If only one entry is missing, it’s assigned the background color. If two entries are
missing, the higher index value is assigned the foreground color and the lower value is
given the background color. If more than two values are missing, the entries are given
shades ranging between the foreground and background colors. Figure 3 shows a
hypothetical color table for a 2-bit font in which only five entries have been supplied in the
‘fctb' resource.

1/2 foregd, 1/2 backgd

1

background color

0

red

Figure 3. Hypothetical Font Color Table Entries
If no color table is provided, the highest and lowest possible index values for any given
screen depth (with a 2-bit screen depth, for example, values 7 and 0) are assigned the

foreground and background colors respectively, with the remaining entries given shades in
between. This allows gray-scale fonts to be created with as many levels of gray as are
needed (since each gray is just a color in between a foreground of black and a background
of white) without needing a color table.

Font Manager Data Structures V-183

‘Se

2)

So

mn)

rh

=

=
=
=
tjo)
@

=

Inside Macintosh

Font

Records

Several previously unused bits of the fontT ype field specify the font depth and other related

information (the new bits are marked by an asterisk):

*
et
"
*

*

Bit

Meaning

0

Set if there’s an image-height table

2-3

Font depth (Macintosh II only—must be 0 otherwise)

|

Set if font has an 'fctb' resource (Macintosh II only—must be 0 otherwise)
Set if a synthetic font (Macintosh II only—must be 0 otherwise)
Set if font contains colors other than black (Macintosh II only—must be 0
otherwise)
Reserved (should be 0)
Reserved (should be 1)
Set for fixed-width font, clear for proportional font
Set if font is not to be expanded (Macintosh II only—must be 0 otherwise)

1

4-6

2
9

10-11
12
13
14
15

Set if there’s a character-width table
Reserved (should be 0)

Reserved (should be 1)

Bit 2 and 3 specify the font depth and can contain the following values:
Value

Font depth

0
l
2
3

1-bit
2-bit
4-bit
8-bit

The font depth is normally 0, indicating a font intended for a screen one bit deep. If bit 7 is
set (and the font is an 'NFNT' resource), a resource of type ‘fctb' with the same ID as the

font can optionally be provided to assign RGB colors to specific pixel values.

Bit 8 is used only by the Font Manager to indicate a synthetic font, created dynamically
from the available font resources in response to a certain color and screen depth
combination.
Bit 9 is set if the font contains other than black.

Setting bit 14 indicates that the font should not be expanded by the Font Manager to match

the screen depth; some international fonts, such as kanji, are too large for synthetic fonts to

be effective or meaningful.

To accommodate multibit font depths, the owTLoc field has been changed to a long word,
the nDescent field becoming the high-order word. (For backward compatibility, nDescent
is ignored if it’s negative.)

V-184 Font Manager Data Structures

The Font Manager
Note: The 128K ROM version of the Font Manager limits the strike for a 1-bit font
to not quite 128K; this limits the largest practical font to about 127 points. The
Macintosh II ROM limits the largest practical font to about 255 points, regardless of
the font depth.

Family

Records

For Macintosh II only, bits 8 and 9 of the font style word within each font association table
specify the font depth; they must contain the same value as bits 2 and 3 of the fontType
field of the font record. All other undefined bits remain 0.
The format for resources of type 'FOND' has been extended.
following (with extension fields indicated by asterisks):
Number

of bytes

2 bytes
2 bytes
2 bytes
2 bytes
2 bytes
2 bytes
2 bytes
2 bytes
4 bytes
4 bytes
4 bytes
24 bytes
4 bytes
2 bytes
m bytes
2 bytes
4 bytes
n bytes
p bytes
q bytes
r bytes

The new format is the

©
=

)

=
=
|

Contents

a

FONDFlags field of family record
FONDFamiID field of family record
FONDFirst field of family record
FONDLast field of family record
FONDAscent field of family record
FONDDescent field of family record
FONDLeading field of family record
FONDWidMax field of family record
FONDWTabOff of family record
FONDKernOff of family record
FONDS tylOff of family record
FONDProperty field of family record
FONDIntl field of family record
*Version number ($02)
FONDAssoc field of family record (variable length)
*Number of offsets minus 1
*Offset to bounding box table
*Bounding box table
FONDWidTable field of family record (variable length)
FONDStyITab field of family record (variable length)
FONDKenrntab field of family record (variable length)

Font Manager Data Structures V-185

Inside Macintosh

The bounding box table has an entry for each style available in the family. The table as a
whole has this form:
Number

of bytes

2 bytes
10 bytes
10 bytes

Contents
Number of entries minus 1
First entry
Second entry...

Each bounding box entry has this form, giving the bounding box position with respect to
the origin of the characters:
Number

of bytes

2 bytes
2 bytes
2 bytes
2 bytes
2 bytes

Contents
Style word
Lower left x coordinate
Lower left y coordinate
Upper right x coordinate
Upper right y coordinate

V-186 Font Manager Data Structures

The Font Manager

SUMMARY

OF THE FONT MANAGER

Variable
SynListHandle

Handle to synthetic font list
NA)
co)

5

—_

3
=
SS
ga
©

Summary of the Font Manager V-187

10
190
190
192
193
193
194
194
196

THE

TOOLBOX

EVENT

MANAGER

About This Chapter
New Standard Keyboards
The Apple Extended Keyboard
Reassigning Right Key Codes
The Keyboard Event Message
New Modifier Flag
KeyTrans
Summary of the Toolbox Event Manager

noms

=

|

oS

e.
ao
i)
~~

cs)

<
@o

=

—s

V-189

Inside Macintosh

ABOUT THIS CHAPTER
This chapter describes four changes that enhance the ability of the Macintosh II and

Macintosh SE to respond to keyboard events:

= Your application can now work with the Macintosh Plus, Macintosh II, and Apple
Extended Keyboards, all of which offer several new key functions.
m The event message for keyboard events now distinguishes multiple keyboards.

= A new modifier flag detects the state of the control key on the Macintosh Plus and
Apple Extended Keyboards.
= A new Toolbox routine, KeyTrans, helps your application convert key codes into
ASCII codes.

NEW STANDARD KEYBOARDS
Three keyboards are now available as standard equipment with Macintosh computers sold
in the U.S. They are
= The Macintosh Plus Keyboard, which includes cursor control keys and an integral
keypad. Its layout and key coding is shown in Figure 1.
w The Macintosh II Keyboard, also shipped with the Macintosh SE, which adds Esc
(Escape) and Control keys and is connected to the Apple Desktop Bus. Its layout and
key coding is shown in Figure 2.
mw The Apple Extended Keyboard, which the user may connect to the Apple Desktop
Bus of any Macintosh II or Macintosh SE computer. Its layout and key coding is
shown in Figure 3.
These figures show the virtual key codes for each key; they are the key codes that
actually appear in keyboard events. In the case of the Macintosh II and Apple Extended
Keyboards, however, the hardware produces raw key codes, which may be different.
Raw key codes are translated to virtual key codes by the 'KMAP' resource in the System
Folder. By modifying the 'KMAP' resource you can change the key codes for any keys.
Similarly, you can change the ASCII codes corresponding to specific key codes by
modifying the 'KCHR' resource in the System Folder. The 'KMAP' and 'KCHR'
resources are described in the Resource Manager chapter of this volume.

V-190 New Standard Keyboards

The Toolbox Event Manager
With both the Macintosh II and the Apple Extended keyboards, the standard 'KMAP'
resource supplied in the system folder reassigns the following raw key codes to different
virtual key codes:
Key

Raw

Control
Left cursor
Right cursor
Down cursor
Up cursor

key

code

Virtual

36
3B
3C
3D
3E

key code

3B
7B
7c
7D
7E

The standard 'KMAP'’ resource leaves all other raw key codes and virtual key codes the
same.
With the Apple Extended Keyboard, the virtual key codes for three more keys may be
easily reassigned, as described below under “Reassigning Right Key Codes”.

:

1

24S

1481s

Orr

Sees

ai.

=

[Delete

32] 12] 13]14]15]17] 16] 1A] 1c] 19] 1D] 1B] 18] 33
Tb
JOT WLETRIT[y];uyi1fyo]vep]sct]]
30 | 0C|OD] OE} OF J 11410 | 20] 22] IF | 23 | 21] 1e

CapsLock]

A] S| D[

F/G]

HJ

UY] KILI

|

! | Return

V\le]

aga

39 | 00] 01 | 02] 03] 05] 04] 26} 28,25|29}27]|
24
Shift
Z2,X
CT ViBINIM,,
[fs | 7 [Shift] 4
38
06 [07 | 08] 09 | OB] 2D |2E | 28] 2F |}2C | 38
|4p

Option | 3

3A

SP ACE

37

31

2A] 46 | 42]

Clear}

=

| / | *

=
=
a

56 |57 |58 | 46
1 | 2 | 3 [Enter
53 | 54155 | 4c

=|

4/5

|+

.

fe)

48

]6

52:

1 At

Figure 1. Macintosh Plus Keyboard

colt
}23
141510171819
101-1
= Ielete
z5}12/13 |} 14]15]17] 161 1a] tc] 19] 1] 1B] 18] 33
TS
TOUWPETR
ITTY
TULlITopeirctl
zo | oc} op | o£ | of | 11410 | 20| 22] iF | 23 | 21 | te
contrat PAT S1TDTELTOTAHTOPeT
LTS
T° | Return

Cleal =\v
lx
47151 | 4B | 43
7Telo|+
59 |58 | 5c | 45
7 es re

Shift
Z)XTcT)YITBINIMIT»
1: 1/1 shit
3g
06 107 | 08 }o9 | op} 2p J2e | op Jar fac | se
CAP] Oot | 3 4] \
SPACE
We as De
39 | 3A] 37 2A
31
241781 7C1 7D | 7e

11212 lenter
53154] 55] 4c
0
;
52
«141

3B

00}

01

| 02

| 03

| OS

| 04

| 26

| 28

| 25

| 29

| 27

24

=

47 | 48 | 4D | 42
7/slol[59 |5B | 5c | 4E

56

157

158

| 4E

Figure 2. Macintosh II Keyboard

New Standard Keyboards V-191

<

Inside Macintosh
rint scroll

dein lock Pause

Esc

FLY

F2)

FS)

F4]

35|

| 7Al 781 63] 76|

32

12

| FS}

undo cut copy paste

“ll

Tr]

TH

13

16

1A

1C

74]5

]6]

7]

8]

$S[s]*7a&y*#]

level

273

] Fe]

[FS

162164)

17

15

14

FOF?

|60] 61

19

FIO} FIIFI2

[65/60]

oO 7

oy-]+

1F | 23]

21]

Cock39] 00 | 01 | 02 | o3 }05 | 04 | 26| 28 | 25]29

27]

cas

JAILSTDIFIGIT

HI]

ul

22]

KILI:

|]: |] 7]
zixilclyvyi[BINnIMI06 | 07 | 08 | 09 | 08 | 2D | 2E | 2B | 2F | 2C}

Shift
38

alt ©
ctl. lostion|
38

20]

10|

of | 11]

463A

Space

O37

72.73

ins.

74

9 fro] - | = pPetete | |helphomefpouy
vy |

IOTVIEIRITIVYIULILI@OTeRTEri

|oc|op | o£]

30

leslesia}

33

18

1B

1D

FISIFIGUFIS

67ler|]

:

16 | 2A)

|" | Retun|

24

fee.

[Depend jpgan

75

Shift
38(3Cc)

alt Cl)
© Jastionl

37

3A

(3D)

36

77

4
7E

79

¢|+\¥
[ae lrc}7> |

Reset

—

Caps Num Scroll
Lock Lock Lock

chad

=| /]*

7F7F

[47]511 4B | 43 |
T/8]9]-

=

~ ——

+

196 [57 ]58 | 45

1 | 2] 3 [Enter
93 [54 | 95

(52eB [41 J 4c

(3)

Figure 3. Apple Extended keyboard

The

Apple

Extended

Keyboard

Apple now offers the Extended Keyboard as an option. Besides all the key functions of the
present U.S. keyboard and keypad, it contains the following new ones:
Fifteen general Function keys, labeled F1 through F15. Applications that use Undo,
Cut, Copy, and Paste should assign keys Fl through F4 to these operations. Keys F5
through F15 are intended to be defined by the user, not by the application.
A Control key. This is included for compatibility with applications requiring a Control
key, which the Macintosh might access through communication with another operating
system. It should not be used by new Macintosh applications. Pressing it sets bit 12
of the modifiers field of the event record for keyboard events, as described below

under “New Modifier Flag”.

A Help key. This key is available to the user to request help or instructions from your
application.
A Forward Delete (Fwd Del) key. Pressing this key performs a forward text delete:
the character immediately to the right of the insertion point is removed and all
subsequent characters are shifted left one place. When the Fwd Del key is held down,
the effect is that the insertion point remains stationary while everything ahead of it is

“vacuumed” away.

selected text.

If it is pressed while there is a current selection, it removes the

A Home key. Pressing the Home key is equivalent to moving the vertical scroll box to
the top and the horizontal scroll box to the far left. It has no effect on the current
insertion point or on any selected material.

V-192 New Standard Keyboards

The Toolbox Event Manager
u An End key. Pressing the End key is equivalent to moving the vertical scroll box to
the bottom and the horizontal scroll box to the far right. It has no effect on the current
insertion point or on any selected material.
u A Page Up key. Pressing the Page Up key is equivalent to clicking in the page-up
region of the vertical scroll bar of the active window. It has no effect on the current
insertion point or on any selected material.
u A Page Down key. Pressing the Page Down key is equivalent to clicking in the pagedown region of the vertical scroll bar of the active window. It has no effect on the
current insertion point or on any selected material.
s Duplicated Shift, Option, and Control Keys. On the Apple Extended Keyboard, the
Shift, Option, and Control keys occur both to the right and to the left of the space bar.
Normally they have the same key codes. However, it is possible to send the keyboard
a command that changes the key codes for the keys on the right side. This possibility
is discussed under “Reassigning Right Key Codes”, below.

Reassigning

Right

Key

Codes

It is possible to reassign the key codes for the Shift, Option, and Control keys on the right
side of the Apple Extended keyboard to the following:
Right

key

Raw

Shift

Option
Control

key

$7B

$7C
$7D

code

Virtual

key code

3C

—)

a

=

3D
3E

Changing these key codes requires changing the value of the Device Handler ID field in the
Apple Extended Keyboard’s register 3 from 2 to 3. The Device Handler ID is described in
the Apple Desktop Bus chapter of this volume.
Warning: This capability is included for compatibility with certain existing
operating systems that distinguish the right and left keys. Its use by new applications
violates the Apple user interface guidelines and is strongly discouraged.

THE KEYBOARD

=
=
es

EVENT MESSAGE

The Apple Desktop Bus chapter of this volume describes how the Macintosh II and
Macintosh SE can be connected to multiple keyboards. To identify the origin of keyboard
events, the keyboard event message contains a new ADB address field. It now has the
structure shown in Figure 4.

The Keyboard Event Message V-193

Inside Macintosh

31

24 23

reserved

16 15

ADB address

8 7
virtual

key code

0
ASCII

character

Figure 4. Event Message for Keyboard Events

Warning: The high byte of the event message for keyboard events is reserved for
future use, and is not presently guaranteed to be zero.
The event message for non-keyboard events remains the same as described in the Toolbox
Event Manager chapter of Volume I.

NEW

MODIFIER

FLAG

The Modifier Flag structure shown in the Toolbox Event Manager chapter of Volume I has
been extended to record the status of the Control key on the Macintosh II and Apple
Extended keyboards. The current structure is shown in Figure 5.
15

131211109

8

7

6

1

0

1 if Control key down, O if not i
1 if Option key down, O if not

1 if Caps Lock key down, 0 if not
1 if Shift key down, O if not
1 if Command key down, 0 if not
1 if mouse button up, O if not :
1 if window being activated, O if deactivated ——

Figure 5. Modifier flags

KEYTRANS
A new routine in the 256K ROM lets your application convert key codes to ASCII values
as determined by a 'KCHR' resource. The 'KCHR' resource type is discussed in the
Resource Manager chapter of this volume.

V-194 KeyTrans

The Toolbox Event Manager
FUNCTION

KeyTrans
(transData:
LONGINT)
: LONGINT;

Ptr;

keycode:

Integer;

VAR

state:

TransData points to a 'KCHR' resource, which maps virtual key codes to ASCII values.
The keycode parameter is a 16-bit value with the structure shown in Figure 6.

1D

8

7

high byte of
modifier flags

6

—

0

virtual key code
;

;

up stroke
down

stroke

Figure 6. Keycode parameter structure

The state parameter is a value maintained by the Toolbox. Your application should save it
between calls to KeyTrans. If your application changes transData to point to a different
'KCHR' resource, it should reset the state value to 0.
KeyTrans returns a 32-bit value with the structure shown in Figure 7.

In this structure,

ASCII 1 is the ASCII value of the first character generated by the key code parameter;
reserved! is an extension for future “16-bit ASCII” coding. ASCII 2 and reserved2 have
the same meanings for a possible second character generated by key code—for example, if
key code designates an alphabetic character with a separate accent character.

3]

24
reserved

|

23

16
ASCIl 1

15
reserved

8 7
2

0
ASCIl 2

Figure 7. KeyTrans return structure

Assembly-language note: The macro you invoke to call KeyTrans from
assembly language is named _KeyTrans. Its parameters are passed on the stack.

KeyTrans V-195

—

fe)

oer
©

2.
a
i)
a

S3)
<

@

i)

—

Inside Macintosh

SUMMARY

OF THE TOOLBOX

EVENT MANAGER

Constant
ControlKey

=

4096;

{set

if

Control

key

down}

Routine
FUNCTION

KeyTrans

(transData:
VAR state:

Ptr;
keycode:
Integer;
LONGINT)
: LONGINT;

V-196 Summary of the Toolbox Event Manager

11
198
199
200
202
204
205
206
206
208
210
2d

THE

WINDOW

MANAGER

About This Chapter
Color Window Records
Auxiliary Window Records
Window Color Tables
Using Color Windows
Defining Your Own Windows
Window Manager Routines
New Window Manager Routines
Modifications to Existing Routines
Advanced Routines
Summary of the Window Manager

—
—

==
=

z

=<
=
5
ge
a
bea

V-197

|

Inside Macintosh

ABOUT THIS CHAPTER
This chapter describes the enhancements to the Window Manager provided for the

Macintosh Plus, the Macintosh SE, and the Macintosh II. A new set of Window Manager
routines for the Macintosh II supports the use of multiple screen desktops and color
windows. New data structures and a new resource type, 'wctb', have been introduced to
store color window information. All handling of color windows and multiple screens is
transparent to applications that aren’t using the new features.

To make use of the information in this chapter, you should be familiar with
a the drawing environment described in the Color QuickDraw chapter
m the use of resources in an application program, described in the Resource Manager
chapter
For the Macintosh Plus, the Macintosh SE, and the Macintosh II, the following Window

Manager routines were changed to support hierarchical menus:

a The InitWindow routine now calls the Menu Manager to calculate menu bar height,
and to draw the empty menu bar. The FindWindow routine also makes a call to the
Menu Manager when testing to see if a point on the screen has been selected.
For the Macintosh II, the Window Manager has been enhanced to support multiple screen
desktops and color windows:
= Color windows can now be created within an application program.
= Because window content regions may be colored on the Macintosh II, each window’s
area is now erased separately. Formerly, the Window Manager collected the update
region of multiple windows into a single region, then erased this single region to
white.
m The standard desktop pattern may be a binary deskPattern or a color deskCPattern. If
the color desktop pattern is enabled, InitWindows loads the default desktop pixel
pattern as well as the standard binary pattern.
= Windows may be dragged from one screen to another on a system configured with
multiple screens. Changes to the DragGrayRgn routine allow the object being dragged
to be positioned anywhere on the multiscreen desktop. The GetGrayRgn routine
provides a handle to the global variable GrayRgn, which contains information about
the current desktop.
a The MoveWindow, GrowWindow, and ZoomWindow routines have been modified to

ensure that windows will perform properly in a multiscreen environment.

V-198 About This Chapter

The Window Manager

COLOR

WINDOW

RECORDS

The Window Manager keeps all the information required for drawing color windows in a
color window record. The structure and size of a color window record are the same as a
regular window record, except that it’s now optionally based on a cGrafPort instead of an
old-style grafPort. This allows the window structure and content to use the color capability
of the Macintosh II.
All standard window definition procedures can now draw window structure information
into a color window port, called the WmgrCPort. The WMerCPort is analogous to the
WMsgrPort. See the section “Defining Your Own Windows” for more information on how
to use the WMerCPort correctly.
The new data type CWindowRecord is identical to the old WindowRecord except that its
port field is a cGrafPort instead of a grafPort. Because both types of port are the same size
and follow the same rules, the old-style and new-style window records are also the same

size and have all their fields at the same locations within the record. You can access most of
the fields of a window record with Window Manager routines, so for most applications
you won’t need to use the fields listed below.
TYPE

CWindowPtr
CWindowPeek

CWindowRecord

=
=

=

CGrafPtr;
“CWindowRecord;

RECORD

{all

fields

remain

the

same

as

before}

port:
windowKind:
visible:

CGrafPort;
INTEGER;
BOOLEAN;

{window's
CGrafPort}
{window class}
{TRUE
if visible}

{TRUE

if

highlighted}

=F

goAwayFlagc:

BOOLEAN;

{TRUE

if

has

>

SpareFlag:

BOOLEAN;

for

strucRgn:

RgnHandle;

{reserved
{ use}

contRgn:

RgnHandle;

{content

region}

dataHandle:

Handle;

titleHandle:

StringHandle;

{data used by}
{ windowDefProc}

titleWidth:

INTEGER;

hilited:

updateRgn:
windowDefProc:

controlList:

BOOLEAN;

{ away

{structure

RgnHandle;
Handle;

CWindowPeek;

windowPic:

PicHandle;

}

future

{window's

title}

{width

title

of

{

pixels}

{

list}

{

window}

{window's

control

}

=

=
=

region}

es
3

{update region}
{window definition}
{ function}

ControlHandle;

nextWindow:

region}

go-

fol
=

in}

}

{next window in }
{ window list}
{picture for drawing}

Color Window Records V-199

Inside Macintosh
refCon:

LONGINT

{window's
{ value)

reference}

END;

All of the old Window Manager routines now accept a CWindowPtr in place of a
WindowPtr. If necessary, high-level languages may use type coercion to convert one
data type to another. (Another method that allows the use of both types is to define a
duplicate set of interfaces, substituting a CWindowPtr for a WindowPtr for convenience or
code efficiency.) The two types of window may even be mixed on the same screen; the
Window Manager will examine each window’s port field to see which type it is, and draw
it in full RGB colors or the original eight QuickDraw colors.

Auxiliary Window

Records

As described in the Window Manager chapter of Volume I, windows consist of two parts:
a structure region that includes the frame, titlebar, and other window elements, and a
content region enclosed within the frame. Applications draw within the content region, and
may draw in color by using the NewCWindow routine. Use of the NewWindow routine

limits drawing within the contents region to the eight original QuickDraw colors. On the

Macintosh I], the structure region is always drawn in the WMgrCPort and has full color
capability, independent of the content region.
A new data structure, the auxiliary window

record, stores the color information

needed for each color window in an independent list. A number of auxiliary window
records may exist as a linked list, beginning in the global variable AuxWindowHead. Each
auxiliary window record is a relocatable object residing in the application heap. Figure 1
shows an example of a set of auxiliary window records that could be used for an
application using a separate window color table for each of the windows. This data
structure is known as the AuxWinList, and is simply a linked list where each additional
auxiliary window record points to the one after it.
first AuxRec

second AuxRec

default Rec

> awNext

> avNext ———

dialogCltem

dialogC Item

dialogCltem

awReserved
awRefCon

awReserved
awRefCon

AuxWinHead——> awNext

awOwner
awCTable

awFlags

awOwner
awCTable

awOwner
awCTable

awF lags

awFlags

awReserved
awRefCon

first

second

ColorTable

ColorTable

window’s

window's

Figure 1. An AuxWinList Structure

V-200 Color Window Records

NIL

default

ColorTable

The Window Manager
The AuxWinRec structure includes a handle to the window’s individual color table (see
“Window Color Tables” below), as well as the handle to the dialogCItem list. The rest of

the record consists of a link to the next record in the list, a pointer to the owning window,
and several reserved fields.
TYPE

AuxWinHandle
AuxWinPtr
AuxWinRec

=
=
=

“*AuxWinPtr;
“AuxWinRec;
RECORD
awNext:

awOwner:

AuxWinHandle;

{handle
to
{ in list}

WindowPtr;

{pointer
{

next

to

record

owning

}

}

window}

awCTable:

CTabHandle;

{handle
{ color

dialogCItem:

CTabHandle;

{private
{ Dialog

awF lags:

LONGINT;

{reserved

for

future

use}

awReserved:
awRefCon:

CTabHandle;
LONGINT

{reserved
{reserved

for
for

future
}

use}

{

to window's
table}

storage for
Manager}

application

}

}

use}

END;

Field

descriptions

awNext

The awNext field is a handle to the next record in the
auxiliary window list. If this record is the default
auxWinRec, this value will be NIL.

awOwner

awCTable

The awOwner field is a pointer to the window to which
this record belongs. The default auxWinRec awOwner
field is always set to NIL.
The awCTable is a handle to the window’s color table.

Normally these are five-element color tables (see “Window
Color Tables” below).

dialogCltem

The dialogClItem field contains private storage for the
Dialog Manager.

awFlags

The awFlags field is reserved for future expansion.

awReserved

The awReserved field is reserved for future expansion.

awRefCon

The awRefCon field is a reference constant for use by the
application.

The default colors for all windows are loaded from a 'wctb' resource = 0 when
InitWindows is called. First the application is checked for a 'wctb' resource, then if none is
found, the System file is checked, and finally, ROM Resources is checked for an existing
‘wetb'. To change the default colors for any of the windows, use SetWinColor. The
standard colors on the system are identical to black-and-white Macintosh windows.

Color Window Records V-201

—
ic

<
=
—)

=
S

=
2
=

i)
—}
a
Te

O

Inside Macintosh

An AuxWinRec specifies the default colorTable for the application’s window list. For most
types of applications, several windows can use the same auxiliary window record and
share the same color table. Separate auxiliary window records are needed only for
windows whose color usage differs from the default. Each such nonstandard window must
have its own auxiliary record, even if it uses the same colors as another window. Two or
more auxiliary records may share the same color table. If a window uses a color table
resource, the resource must not be purgeable, and the color table won’t be disposed when
Dispose Window is called. However, for an auxiliary record using any color table that is
not a resource, the application must avoid deallocating the color table if another window is
still using it.
The AuxWinRec is deallocated when Dispose Window is called. If the resource bit of a
color table’s handle is set, the color table can only be disposed using the Resource Manager
routine ReleaseResource.
A window created with the NewWindow routine will initially have no auxiliary window
record. If it is to use nonstandard colors, it must be given an auxiliary record and a color
table with SetWinColor (see the “Window Manager Routines” section). Such a window
should normally be made invisible at creation and then displayed with ShowWindow or
ShowHide after the colors are set. For windows created from a template resource, the
color table can be specified as a resource as well.

A/UX systems:

For systems using 32-bit mode, each window will have an

AuxWinRec. The default AuxWinRec structure is present at the end of the
AuxWinList, but is not used. The variant code for the window is no longer stored in
the high byte of the windowDefProc field, but is stored in the awFlags field. This
allows the defproc to occur anywhere within the 32-bit address space.

WINDOW

COLOR

TABLES

The contents and meaning of a window’s color table are determined by its window
definition function (see the “Defining Your Own Windows” section later in this chapter).
The CTabHandle parameter used in the Window Manager routines provides a handle to the
window color table. The color table containing the window’s colorSpecs can have any
number of entries, but standard window color tables as stored in the system resource file
have five colorSpecs.
The components of a window color table are defined as follows:
TYPE

WTabHandle

=

“WCTabPtr;

WCTabPtr
WinCTab

=
=

“WinCTab;
RECORD

wCSeed:

LONGINT;

{unique
{

wCReserved:
ctSize:

V-202 Window Color Tables

INTEGER;
INTEGER;

identifier

from

}

table}

{not used for windows}
{number of entries
in
{ table
-1}

}

The Window Manager
ctTable:

cSpecArray;

{array of ColorSpec
{ records}

}

END;

Field

descriptions

wCSeed

The wCSeed field is unused in window color tables, and
is reserved for Apple’s use.

wCReserved

The wCReserved field is unused in window color tables,

and is reserved for Apple’s use.

ctSize

The ctSize field defines the number of elements in the
table, minus one. If your application is building a color
table for use with the standard definition procedure, this
field is always 4. Custom window definition procedures
can allocate color tables of any size.

ctTable

The ctTable field is made of an array of colorSpec records.
Each colorSpec contains the partIdentifer and partRGB
field, as shown below. The PartIdentifier field holds an
integer which associates a colorSpec to a particular part of
the window. The definition procedures attempt to find the
appropriate partIdentifier when preparing to draw a part. If
that partIdentifier is not found, the first color in the table is
used to draw the part. The partIdentifiers can appear in any
order in the table. The partRGB field specifies a standard
RGB color record, indicating what RGB value will be
used to draw the window part found in partIdentifier.

coal
—

The standard window type uses a five-element color table with part identifiers as shown in
Figure 2.
wCSeed

(long word)

wCReserved

ctSize

(word)

=
<

[+

(word)

value

oo)
=

Is always 0

m

/-——vYalue is 4 for standard window defproc
Red (word)

Green (word) |

Blue (word)

wFrameColor

(word)

| Red (word)

| Green (word) | Blue (word)

> wTextColor

(word)

Red (word)

Green (word) | Blue (word)

WHiliteColor
(word) | Red (word)
+ wTitleBarColor (word) | Red (word)

| Green (word) | Blue (word)
| Green (word) | Blue (word)

I

Partldentifier

F

=

wContentColor (word)

——

=

value supplied by constants

|

PartRGB

value supplied by application

Figure 2. A Window Color Table

Window Color Tables V-203

ge
©

Inside Macintosh

|

Fe
WN
Pm

wTitleBarColor

|

wContentColor
wFrameColor
wTextColor
wHiliteColor

©

The following constants are used for the partIdentifiers in a window color table:
,
‘

.
,
’

The default color table read into the heap at application startup simply contains the right
combination of black and white to produce standard black-and-white Macintosh windows.
The last record in the auxiliary window list holds a handle to this default color table. Before
drawing a window, the standard window definition function searches the list for an
auxiliary record whose awOwner points to the window to be drawn. If it finds such a
record, it uses the color table designated by that record; if it doesn’t find one before
reaching the default record at the end of the list, it uses the default color table instead. The
default record is recognized by NIL values in both its awNext and awOwner fields; your
program must not change these fields.
When creating a color window, the background color is set to the content color. Old-style
windows should use a content color of white.
A nonstandard window definition function can explicitly declare a color table of any desired
size and define its contents in any way it wishes, except that part identifiers 1 to 127 are
reserved for system definition. For compatibility with the defaulting mechanism described
above, the customized definition function should either use indices 0 to 4 in the standard
way, or else bypass the default by allocating an explicit auxiliary record for every window
it creates. To access a nonstandard window color table from Pascal, the handle must be
coerced to WCTabHandle.
The 'wetb' resource is an exact image of the window table data structure. This resource is
stored in a similar format as ‘clut' color table resources. The partIdentifier and partCode
fields are stored as the colorSpec.value and colorSpec.RGBColor fields.

USING

COLOR

WINDOWS

Each color window (excluding those using a colored default) should have its own color
table. When an application is initialized, the default colorTable field used is the 'wctb'

resource = () in the application’s resource fork. This allows you to set default window
colors on an application basis. If a 'wctb' resource = 0 is not found in the application, or in
the System file, a nonchangeable resource is loaded from ROM resources. Normally, the
default window colors will be the correct combination of black and white to create standard
Macintosh windows.
The GetAuxWin routine is used to return the handle to an individual window color table.

CloseWindow will dispose of a window’s AuxWinRec, if present.

When a new window is created with the NewCWindow or NewWindow routine, no entry

is added to the AuxList, and the window will use the default colors. If SetWinColor is used

V-204 Using Color Windows

The Window Manager
with a different color table for a window, a new AuxList will be allocated and added to the
head of the list. To avoid having a visible window flash to a different color, it is useful to
call NewCWindow or NewWindow with the visible field set to FALSE, then to call

SetWinColor to change the colors, and finally to call ShowHide to make it visible.

Within an application, a new window is usually created from a resource by using
GetNewCWindow or GetNewWindow. GetNewCWindow will attempt to load a 'wetb'
resource if it is present. It then executes the SetWinColor call. A new AuxRec is allocated if
the resource file contains the 'wctb' resource with the same ResId as the 'WIND' template.
Otherwise, the default window colors are used. The Window Manager automatically hides
specially-colored visible windows so that they won’t flash to a different color.
Any windows created with NewWindow will contain an old-style grafPort in the
windowRec, and only the eight original QuickDraw colors can be displayed in the window
content. NewCWindow creates a window record based on a cGrafport, thus allowing full
use of the Macintosh II color capability.
Advanced Window Manager routines include SetDeskCPat, which allows the Control
Panel to set the desktop pattern to a color pattern. This routine should not be used in
application programs, but its description here will help you understand how the Window
Manager manages desktop patterns. The GetCWMgrPort routine returns the address of the
WMerCPort. In most cases this won’t be necessary, since applications should avoid
drawing in the Window Manager ports.
Color QuickDraw on the Macintosh II supports drawing to multiple screens that have been
configured to act as a single large screen. All window dragging and sizing operations,
including the MoveWindow, DragGrayRgn, GrowWindow, SizeWindow, and
ZoomWindow routines, have been modified to allow windows to perform properly when
dragged across a multiple-screen desktop. If a portion of a window moves across screen
boundaries, update events are automatically generated to ensure that the window’s contents
are drawn in the correct colors.
A special Window Manager variable, the GrayRgn, describes the size and shape of the
desktop on all Macintoshes. On a multiple-screen Macintosh II, the GrayRgn variable
contains information on all the screens configured into the system. Your application can
determine the size of the desktop by checking the GrayRgn’s bounding box, and should
use this rectangle for dragging and sizing bounds. The GetGrayRgn routine returns a
handle to the current desktop GrayRgn. Zooming should be restricted to using the full size
of only one screen by using screenbits.bounds for the main screen, or the appropriate
GDRect for any other screens. See the section titled “Modifications to Existing Routines”
for more details.

DEFINING

YOUR

OWN

WINDOWS

Like standard windows, custom window structures can be drawn in full color. On the

Macintosh II, a new data structure known as the WMgrCPort, which opens a cGrafPort, is
introduced. This data structure is analogous to the existing WMgrPort, and defines the
desktop area of the Window Manager, allowing desktop objects (such as window frames)

Defining Your Own Windows V-205

—
—

=

=

=
<)
=

oe

ge

io)
=

Inside Macintosh

to be drawn in full color. The standard defprocs included in the Macintosh II ROM and on
the system disk, are universal defprocs —that is, they support the full color capabilities of
the Macintosh II while maintaining full compatibility on noncolor Macintoshes. Since
applications can be transported between color and noncolor Macintoshes on disk, custom
defprocs associated with applications should be written in this same universal style.
To write a universal defproc, the defproc should, upon entry, identify the capabilities of the
machine on which it is running by using the _SysEnvirons call. If the machine doesn’t
support color, then all previous rules for writing defprocs should be followed as explained
in Volume I.
If the machine is equipped with Color QuickDraw, then a number of extra steps should be
performed:
u First, the defproc should change the current port from the WMgrPort to the
WMerCPort, to allow the system to draw in the full range of RGBColors.
w Next, the defproc should update certain fields in the WMgrCPort to the values of the
corresponding fields in the WMgrPort. The fields that should be updated are the pen
attributes, the text attributes, and bkPat.

transferred by the Window Manager.

The vis and clip regions are automatically

Note: The parallelism of the WMgrPort and the WMgrCPort is maintained only by
the defprocs. All defprocs that draw in the WMgrPort should follow these rules even
if the changed fields don’t affect their operation.
When the two ports are in parallel, the color defproc can proceed with its drawing.

Note

that the GetAuxWin routine, described below, can be used to get the intended colors for the

window parts from the AuxWinList. As with all color objects, highlighting shouldn’t be
performed by inverting; the forecolor and backcolor should be reversed and the highlighted
item redrawn. No special steps need be taken on exit from the defproc. All other features
and requirements of defprocs are unchanged and remain as documented in Volume I.
Note: For compatibility with systems using MultiFinder™, no drawing should take
place in either the WM¢grPort or the WMegrCPort unless the drawing occurs within a
definition procedure.

WINDOW

MANAGER

ROUTINES

This section describes six new routines, modifications to eight existing routines, and two
advanced routines.

New

Window

Manager

Routines

The following new routines have been added to the Window Manager:

V-206 Window Manager Routines

The Window Manager
FUNCTION

NewCWindow
(wStorage: Ptr; boundsRect: Rect; title:
Str255; visible: BOOLEAN; procID:
INTEGER; behind:

WindowPtr;

CWindowPtr;

goAwayFlag:

BOOLEAN;

[Macintosh II]

refCon:

LONGINT)

The NewCWindow routine creates a new color window. This routine is similar to the old
routine NewWindow, but creates a window based on a cGrafPort instead of an old-style
grafPort.
FUNCTION

GetNewCWindow
CWindowPtr)
:

(windowID:
INTEGER; wStorage:
CWindowPtr; [Macintosh IJ]

Ptr;

behind:

The GetNewCWindow routine creates a new color window from a template in a resource
file. It’s analogous to the old routine GetNewWindow, but it creates

a window based on a

cGrafPort instead of an old-style grafPort. GetNewCWindow checks the 'wctb' resource,
and if it contains the same resource ID, it colors the window. The backColor of the

window is set to the new content color. This allows an application to begin its update with
an EraseRect without changing the background color.
PROCEDURE

SetWinColor

(theWindow:

newColorTable:

WindowPtr;

CTabHandle)
; [Macintosh II]

The SetWinColor routine sets a window’s color table. If the window currently has no

auxiliary window record, a new one is created with the given color table and added to the

head of the auxiliary window list. If there is already an auxiliary record for the window, its
color table is replaced by the contents of newColorTable. The window is then automatically
redrawn in the new colors. If SetWinColor is performed on a cWindow, it sets the
backColor of the window to the new content color. This allows an application to begin its
update without changing the background color.
If newColorTable has the same contents as the default color table, the window’s existing
auxiliary record and color table are removed from the auxiliary window list and deallocated.
If theWindow = NIL, the operation modifies the default color table in memory. The system
never disposes of color tables that are resources when the resource bit is set; 'wctb'
resources can’t be purgeable.
FUNCTION

GetAuxWin

VAR

colors:

(theWindow:

CTabHandle)

WindowPtr;

: BOOLEAN;

[Macintosh

II]

The GetAuxWin routine returns a handle to a window’s auxiliary window record:
w If the given window has an auxiliary record, its handle is returned in colors and the
function returns TRUE.
a If the window has no auxiliary record, a handle to the default record is returned in
colors and the function returns FALSE.
m If theWindow = NIL, a handle to the default record is returned in colors and the
function returns TRUE.

Window Manager Routines V-207

tt
—

=)
Q.
°

=

<

pe)
i)
pS)
tjo}
@
baw

4

Inside Macintosh

FUNCTION

GetWVariant

(whichWindow:WindowPtr):

Macintosh SE, Macintosh IT]

INTEGER;

[Macintosh Plus,

GetW Variant returns the variant code for the window described by whichWindow. See the

Window Manager chapter in Volume I for more information about variants.
FUNCTION

GetGrayRgn

: regionHandle;

SE, Macintosh IT]

[Notin ROM] [Macintosh Plus, Macintosh

The GetGrayRgn function returns a handle to the current desktop region stored in the
global variable GrayRgn.

Modifications

to Existing

Routines

The following Window Manager routines are modified to support hierarchical menus
within windows, color windows, and multiple-screen desktops:
PROCEDURE

InitWindows;

[Macintosh Plus, Macintosh SE, Macintosh II]

The InitWindow procedure now calls the new Menu Bar definition procedure to calculate
menu bar height, and to draw the empty menu bar. Since the menu bar definition procedure
(“MBDF'’) actually performs these calculations, InitWindows now calls InitMenus directly.

InitMenus has been modified so that it can be called twice in a program without ill effect.

For the Macintosh I], if the color desktop pattern is enabled, InitWindows loads the default
desktop pixel pattern as well as the standard binary pattern. It allocates both the
WMerCPort and the WMgrPort, then calculates the union of all active screen devices, and
saves this region in the global variable GrayRgn.
PROCEDURE

FindWindow

(thePoint:

whichWindow:windowPtr)
Macintosh II]

Point;

VAR

: INTEGER;

;

[Macintosh Plus, Macintosh SE,

The FindWindow procedure now calls the new menu bar definition procedure to determine
whether the point where the mouse button was pressed lies in the menu bar.
PROCEDURE

PaintOne

(window:

{Macintosh II]

WindowPeek;

clobberedRgn:RgnHandle) ;

The PaintOne routine is modified to improve the performance of updates when differently
colored windows are in use. Formerly, the Window Manager collected the update region of
multiple windows into a single region, then erased this single region to white. In a color
environment, different windows may need to be erased to different colors, so the

previously used monochrome optimization is disabled. Each uncovered window is now
erased separately, as if the PaintWhite global variable was always set to TRUE. Software

V-208 Window Manager Routines

The Window Manager
that uses the PaintWhite and SaveUpdate flags may appear slightly different when update
events are being processed.
PaintOne tests to see if a window has an old or new grafPort, and sets either the wMgrPort
or wMegrCPort as appropriate. This allows color windows the full RGB range when being
erased to their content color.
PROCEDURE

MoveWindow

front:

(theWindow:windowPtr;

BOOLEAN);

[Macintosh II]

hGlobal,

vGlobal:

INTEGER;

The MoveWindow routine formerly copied a window’s entire structure region. On
multiple-screen systems, Move Window now copies only the portion of the window that
will remain on the same screen. All other parts of the window are not copied, and are

redrawn on the next update event. When a window’s content crosses screen boundaries,
MoveWindow may post additional updates on multiple screen systems.
For new applications, the specified dragging bounds should be the bounding box of the
GrayRgn. To support existing programs, if the dragging bounds passed to MoveWindow
are within six pixels of the current screenbits.bounds on the left, right, and bottom, and are
within thirty-six pixels of the screenbits.bounds.top, the GrayRgn’s bounding box is
substituted.
FUNCTION

DragGrayRgn
(theRgn:
RgnHandle;
SlopRect:
Rect;
axis:
INTEGER;

actionProc:ProcPtr)

:LONGINT;

startPt:

Point;

lmitRect,

[Macintosh II]
=

On multiple-screen systems, the Window Manager now checks the screen rectangle
(screenBits.bounds) when the DragGrayRgn routine is called. This allows the object being
dragged to be positioned anywhere on the multiscreen desktop. If the dragging bounds are
based on screenBits.bound, the dragging boundsRect will be changed to the bounding box
of the grayRgn. The Window Manager’s criteria for modifying the bounds are (1) the left,
bottom, and right are within six pixels of screenBits.bound, and (2) the top is within 36
pixels of screenBits.bounds.top. If the dragging bounds are modified, the ImitRect
parameter is also similarly modified.
FUNCTION

GrowWindow

Rect)

(theWindow:windowPtr:

:LONGINT;

[Macintosh IJ]

startPt:Point;

sizeRect:

On multiple-screen systems, the GrowWindow routine is modified so that windows can be
stretched only a small amount onto other screens. This restriction can be removed by
holding down the command key while growing the window, allowing windows to cover
the full extent of the multiscreen desktop.

Window Manager Routines V-209

—

=

5
3
S
<=

=

£9
=|
$9
ge
@

Low

3

Inside Macintosh
PROCEDURE

ZoomWindow(theWindow:windowPtr;

BOOLEAN) ; [Macintosh II]

partCode:

INTEGER;

front:

On multiple-screen systems, applications that call ZoomWindow with a new size based on
the screen rectangle (screenBits.bounds) will now cause any windows not on the main
screen to zoom to full size on the main screen. To perform properly in a multiscreen
environment, these applications should test which screen contains the greatest area of the
window to be zoomed, and then zoom to the screen rectangle (GDRect) for that screen

device. See the Graphics Devices chapter for information on obtaining the GDRect value
for a device.
Advanced

Routines

PROCEDURE

GetCWMgrPort

(VAR

wport:

CGrafPtr);

[Macintosh
II]

The WMegrCPort is a parallel structure to the WMgrPort. The GetCWMgrPort returns the
address of the WMgrCPort. In Apple-provided 'WDEF' resources, all drawing is done in
the WMgrCPort to allow full color drawing, rather than just the eight QuickDraw colors.
PROCEDURE

SetDeskCPat

(deskPixPat:

PixPatHandle) ; [Macintosh II]

Note: This routine is not for use by applications, and its description is only
included for informational purposes.
The SetDeskCPat procedure sets the desktop pattern to a given pixel pattern, allowing it to
be drawn in more than two colors if desired. The desktop is automatically redrawn in the
new pattern. If deskPixPat is an old-style binary pattern (patT ype = 0), it will be drawn in
the current foreground and background colors. If the pixPatHandle is NIL, the standard
binary deskPat (‘ppat' resource = 16) will be used.
The standard desktop painting routines can paint either in the existing binary pattern (kept
in global variable DeskPat) or in a new pixel pattern. The desk pattern used at startup is
determined by the value of another bit flag called pCDeskPat. If this is pCDeskPat = 0, the
new pixel pattern is used; for all other values, the binary pattern is used by default. The
color pattern can be changed through use of the Control Panel or through the use of
ee
but only the Control Panel changes the value of pCDeskPat in parameter

V-210 Window Manager Routines

The Window Manager

SUMMARY

OF THE WINDOW

MANAGER

Constants
{
{

Window
Part
with
window

Identifiers
elements
}

wContentColor
wFrameColor
wTextColor
wHiliteColor
wlitleBarColor

Data

=
=
=
=
=

which

correlate

color

table

entries

}

0;
+
at
a
4;

Types

TYPE
CWindowPtr
=
CWindowPeek
=
CWindowRecord =

CGrafPtr;
*CWindowRecord;
RECORD
{all fields remains
CGrafPort;
port:
windowKind:
visible:
hilited:

INTEGER;
BOOLEAN ;
BOOLEAN ;

goAwayFlag:

BOOLEAN ;

spareFlag:

BOOLEAN ;

strucRgn:
contkRgn:
updateRgn:

RgnHandle;
RgnHandle;

the

windowDefProc:

RgnHandle;
Handle;

dataHandle:

Handle;

titleHandle:

StringHandle;

titleWidth:

INTEGER;

same as before}
{window's
}
{ CGrafPort}
{window class}
{TRUE if visible}
{TRUE

{

if

—
—

}

highlighted}

{TRUE if has go-}
{ away region}
{reserved for
{ future use}

=

jon

=

}

<
y

{structure region}
{content region}
{update region}

x
qe
&

{window definition
{ function}
{data used by }
{ windowDefProc}
{window's title}

}

{width

}

{

of

pixels}

controlList:

ControlHandle;

nextWindow:

{window's
{ list}

CWindowPeek;

{next

windowPic:

PicHandle;

title

in

control

window

in

}
}

{ window list}
{picture for }
{ drawing window}

Summary of the Window Manager V-211

Inside Macintosh
}

reference

{window's
{ value}

LONGINT

refCon:
END;

AuxWinHandle=
=
AuxWinPtr
=
AuxWinRec

“*AuxWinPtr;
“AuxWinRec;
RECORD
awNext:
awOwner:

WindowPtr;

awCTable:

CTabHandle;

dialogCItem:

CTabHandle;

awF lags:

LONGINT;

awReserved:

CTabHandle;

awRefCon:

LONGINT

}

{handle to next record
{ in list}
}
{pointer to owning
{ window}
}
{handle to window's
{ color table}
{private storage for }
{ Dialog Manager}
}
{reserved for future
{ use}

AuxWinHandle;

future

for

{reserved

{ use}
{reserved

for

{ application

}

}

use}

END;

WTabHandle

=

WCTabPtr

=

WinCTab

=

“WCTabPtr;
“WinCTab;

RECORD
wCSeed:
wCReserved:

ctSize:
ctTable:

identifier

LONGINT;

{unique

INTEGER;

{ table}
used
{not

INTEGER;
cSpecArray;

for

from

windows}

in table -1}
{number of entries
{array of ColorSpec records}

END;

Routines
FUNCTION

NewCWindow

(wStorage: Ptr; boundsRect: Rect; title:
Str255; visible: BOOLEAN; procID:
INTEGER;
behind: WindowPtr; goAwayFlag: BOOLEAN;
refCon: LONGINT)
: CWindowPtr;

FUNCTION

GetNewCWindow

(windowID:
INTEGER;
wStorage:
CWindowPtr)
: CWindowPtr;

PROCEDURE

SetWinColor

(theWindow:

WindowPtr;

Ptr;

FUNCTION

GetAuxWin

(theWindow:
WindowPtr;
VAR
CTabHandle)
: BOOLEAN;

FUNCTION

GetWVariant

(whichWindow:WindowPtr):

FUNCTION

GetGrayRgn:

PROCEDURE

GetCWMgrPort

(VAR

wport:

V-212 Summary of the Window Manager

[Notin ROM]
CGrafPtr);

behind:

newColorTable:

CTabHandle) ;

regionHandle;

}

colors:

INTEGER;

The Window Manager
PROCEDURE

SetDeskCPat

(deskPixPat:

PixPatHandle) ;

Variables
GrayRgn

{Contains

AuxWinHead

Assembly-Language
;
;

Window
window

EQU
EQU
EQU
EQU
EQU

structure

nextAuxWin
auxWinOwner
awCTable
dialogCItem

EQU
EQU
EQU
EQU

So
$4
$8
SC

awF lags
awResrv

EQU
EQU

$10
$14

;

Global

EQU

the

size
head

and
of

shape

the

of

the

auxiliary

current
window

}
}

that

correlate

color

table

entries

with

0
1
2
3
4

auxWinRec

awRefCon

to

on

Information

Part
Identifiers
elements

wContentColor
wFrameColor
wTextColor
wHiliteColor
wTitleBarColor
;

information

{ desktop}
{Contains handle
{ list}

$18

s;next in chain
[Handle]
;owner ID [WindowPtr]
;color table
[CTabHandle]
;handle to dialog manager
structures
; [handle]
;handle for QuickDraw
[handle]
;for expansion
[longint]
;user

constant

[longint]

EQU
EQU

=

=
S

low]

=

<

variables

AuxWinHead
GrayRgn

~~

pe)

SOCDO
S$9EE

; [handle]
;contains

;

of

the

Window Aux List head
information on size and

current

desktop

=
>
ge@
bee

shape

Summary of the Window Manager V-213

4

12

THE

216

About This Chapter

216
218
220
221
221
223

CONTROL

MANAGER

Auxiliary Control Records
Control Color Tables
Using Color Controls
The Control Color Table Resource
Control Manager Routines
Summary of the Control Manager

—"

nN

2)
i)
~fo
“

S
&
~
S
ge

oe
=

V-215

Inside Macintosh

ABOUT THIS CHAPTER
This chapter describes the enhancements to the Control Manager provided for the

Macintosh Plus, Macintosh SE, and Macintosh II. A new set of Control Manager routines

now supports the use of color controls. All handling of color controls is transparent to
applications that aren’t using the new features.

The structure and size of a control record are unchanged. A new data structure, the
auxiliary control record, has been introduced to carry additional color information for a
control, and a new system resource, ‘cctb’, stores control color table information. Three
new routines have been added to support the use of color.

AUXILIARY CONTROL

RECORDS

The information needed for drawing controls in color is kept in a linked list of auxiliary
control records, beginning in the global variable AuxCtlHead. (Notice that there is just one
global list for all controls in all windows, not a separate one for each window.) Each
window record has a handle to the list of controls. Figure 1 shows the auxiliary control list
structure.
first AuxRec

AuxCtlHead

——>

second

AuxRec

default

Rec

—————
acNext
acOwner
acCTable ——

—————>
acNext
acOwner
acCTable ——

——— NIL
acNext
acOwner
=acCTable ——\

acReserved

acReserved

acReserved

acFlags

acRefCon

acFlags

acRefCon

acFlags

acRefCon

first

second

default

control’s

control’s

ColorTable

ColorTable

ColorTable

Figure 1. Auxiliary Control List

Each auxiliary control record is a relocatable object residing in the application heap. The
most important information it holds is a handle to the control’s individual color table (see
the “Control Color Tables” section).

The rest of the record consists of a link to the next

record in the list, a field that identies the control’s owner, a 4-byte field reserved for future
expansion, and a 4-byte reference constant for use by the application:

V-216 Auxiliary Control Records

The Control Manager
TYPE

AuxCtlHandle

=

“*AuxCtlPtr;

AuxCt1Ptr
AuxCt1Rec

=
=

*AuxCtlRec;
RECORD

acNext:

AuxCtlHandle;

{handle

acOwner:
acCTable:

ControlHandle;
CCTabHandle;

list}
{handle
{handle

to

next

record

in

to
to

owning control}
control's
color

}

{

{

acFlags:
acReserved:

acRefCon:

INTEGER;

{miscellaneous

flags;

LONGINT;

{ reserved}
{reserved
for

future

LONGINT

{ expansion}
{reserved for

application

{

}

table}

}
}

}

use}

END;

Field

descriptions

acNext

The acNext field contains a handle to the next record in the auxiliary
control list.

acOwner

The acOwner field contains the handle of the control to which this

acCTable

The acCTable contains the handle to the control’s color table (see
“Control Color Tables” below).

acFlags

The acFlags field contains miscellaneous flags for use by the Control
Manager; this field is reserved.

acReserved

The acReserved field is reserved for future expansion; this must be
set to 0 for future compatibility.

acRefCon

The acRefCon field is a reference constant for use by the application.

auxiliary record belongs. Used as an ID field.

Not every control needs an auxiliary control record.

When an application is started, a

resource containing a default color table is loaded from the system resource file; this
resource defines a standard set of control colors. Since there is no InitControls routine, this

happens when an application calls InitWindows.

—

N

OQ
=)
oo
om
ior]

cE

Separate auxiliary control records are needed only for controls whose color usage differs
from the default. Each such nonstandard control must have its own auxiliary record, even
if it uses the same colors as another control. This allows two or more auxiliary records to
share the same control color table. If the control color table is a resource, it won’t be

deleted by DisposeControl. When using an auxiliary record that is not stored as a resource,
the application should not deallocate the color table if another control is still using it.
A control created from scratch will initially have no auxiliary control record. If it is to use

nonstandard colors, it must be given an auxiliary record and a color table with SetCtlColor

Auxiliary Control Records V-217

i

=

me

ge
©

Leow |

Inside Macintosh
(see the “Control Manager Routines” section).

Such a control should normally be made

invisible at creation and then displayed with ShowControl after the colors are set. For
controls created from a 'CNTL' resource, the color table can be specified as a resource as
well. See the section titled “The Control Color Table Resource”.
A/UX systems:

When using 32-bit mode. every control has its own auxiliary —

record. If there is no specific set of control colors for this control, the acCTable will

point to the default color table.

CONTROL

COLOR

TABLES

The contents and meaning of a control’s color table are determined by its control definition
function (see “The Control Color Table Resource” section). The CTabHandle parameter
used in the Color Control Manager routines provides a handle to the control color table.
The components of a control color table are defined as follows:
TYPE

CCTabHandle

=

CCTabPtr

=

*CCTabPtr;
“*CtlCTab;

Ctl1CTab

=

RECORD

ccSeed:
ccReserved:

LONGINT;
INTEGER;

{not
{not

ctSize:

INTEGER;

{number

cSpecArray

{ table
-1}
{array of ColorSpec

ctTable:

used
used

of

for
for

controls}
controls}

entries

in

END;

Field

descriptions

ccSeed

The ccSeed field is unused in control color tables.

ccReserved

The ccReserved field is unused in control color tables.

ctSize

The ctSize field defines the number of elements in the table, minus

one. For controls drawn with the standard definition procedure, this
field is always 3.

V-218 Control Color Tables

}

records}

» The Control Manager
ctTable

The ctTable field holds an array of colorSpec records. Each
colorSpec is made up of a partIdentifier field and a partRGB field.
The partIdentifier field holds an integer which associates an
RGBColor to a particular part of the control. The definition
procedures attempt to find the appropriate part identifier when
preparing to draw a part. If that part identifier is not found, the first
color in the table is used to draw the part. The part identifiers can
appear in any order in the table. The partRGB field specifies a
standard RGB color record, indicating what absolute color will be
used to draw the control part found in the partIdentifier field.

A standard control color table is shown in Figure 2.

ccSeed (long word)

i

ctSize

«—— value

(word)

ccReserved

(word)

cFrameColor
cBodyColor
cTextColor

(word)
(word)
(word)

cThumbColor

(word)

value is always 0

| Red (word)
| Red (word)
| Red (word)

Red (word)

I
valle

een

is 3 for standard controls

by constants

| Green (word) | Blue (word)
| Green (word) | Blue (word)
| Green (word) | Blue (word)

Green (word) | Blue (word)

[
value suppile ie

J
ane

toation

Figure 2. Control Color Table
The 'cctb' resource is an exact image of this control table data structure, and is stored in the
same format as ‘clut' color table resources.

Standard buttons, check boxes, and radio buttons use a four-element color table with part
identifiers as shown below:
cFrameColor (0)

Frame color

cBodyColor (1)

Fill color for body of control

cTextColor (2)

Text color

cThumbColor (3)

Unused

—

nN

OQ
©
=

=

—

=
=
SS
ge

When highlighted, plain buttons exchange their body and text colors (colors 1 and 2);
check boxes and radio buttons change their appearance without changing colors. All three
types indicate deactivation by dimming their text with no change in colors.

Control Color Tables V-219

)

Lew

4

Inside Macintosh

Standard scroll bars use a four-element color table with part identifiers as shown below:
cFrameColor (0)

Frame color, foreground color for shaft and arrows

cBodyColor (1

Background color for shaft and arrows

cTextColor (2)

Unused

cThumbColor (3)

Fill color for thumb

When highlighted, the arrows are filled with the foreground color (color 0) within the _

arrow outline. A deactivated scroll bar shows no indicator, and displays its shaft in solid

background color (color 1), with no pattern.

The 'cctb' resource = 0 is read into the application heap when the application starts, and
serves as the default control color table. The last record in the auxiliary control list points to
the default 'cctb' resource. When drawing a control, the standard control definition
function searches the list for an auxiliary control record whose acOwner points to the
control being drawn. If it finds such a record, it uses the color table designated by that
record; if it doesn’t find one before reaching the default record at the end of the list, it uses

the default color table instead. All types of controls share the same default record. The
default auxiliary control record is recognized by NIL values in both its acNext and acOwner
fields; the application must not change these fields.
A nonstandard control definition function can use color tables of any desired size and
define their contents in any way it wishes, except that part indices 1 to 127 are reserved for
system definition. Any such nonstandard function should take care to bypass the
defaulting mechanism just described, by allocating an explicit auxiliary record for every
control it creates.

USING

COLOR

CONTROLS

The following caveats apply to the use of color with controls:
= Each colored control (excluding those using the default colors) should have its own
color table.
= Controls are drawn in the window port, which by default is an old-style grafPort. This
limits color matching to the eight old QuickDraw colors. To achieve full RGB display
with controls, the window must be opened with a cGrafPort, using the NewCWindow
routine.
Since there is no “InitControls” call, a default AuxCtlRec is created and intialized on the

application heap when InitWindows is executed. When a new control is created with the

NewControl routine, no entry is added to the AuxList, and the control will use the default
colors. If SetCtlColor is used with a different color set of a control, a new AuxList will be

allocated and added to the head of the list. The CloseControl routine disposes of the
AuxCtlRec.

V-220 Using Color Controls

The Control Manager
Often a new control is created from a 'CNTL' resource, using GetNewControl. A new
AuxRec is allocated if the resource file contains a ‘cctb' resource type with the same
resource ID as the 'CNTL' resource. Otherwise, the default colors are used.
The Control Manager supports controls that have color tables with more than four
elements. To create a control with more than four colors, you must create a custom 'CDEF'
that can access a larger color table.The interpretation of the partIdentifiers is determined by
the 'CDEF'. If your application includes a 'CDEF' that recognizes more than four

partidentifiers, it should use partIdentifiers 0-3 in the same way as the standard control

defprocs. An application with a custom 'CDEF" should use the _SysEnvirons routine upon
entry to the defproc to determine the configuration of the system.

THE CONTROL COLOR TABLE RESOURCE
The system default control colors are stored in the System file and ROMResources as 'cctb'
resource = 0. By including a 'cctb' resource = 0 in your application, it is possible to change
the default colors that will be used for all controls, unless a specific 'cctb' exists for a

control defined within the application.

When you use GetNewControl for the control resource 'CNTL', GetNewControl will

attempt to load a ‘cctb' resource with the same ID as the 'CNTL' resource ID, if one is
present. It then executes the SetCtlColor call.
The following part identifiers for control elements should be present in the ColorSpec.value
field:
cFrameColor (0)

Frame color

cBodyColor (1)

Fill color for body of control

cTextColor (2)

Text color

cThumbColor (3)

Thumb color

These identifiers may be present in any order; for instance, the text or indicator color values
may be stored before the fill and frame colors in the ColorSpec record structure. If a part

identifier is not found, then the first color in the color table will be used.

—_

tr

O
©

—|

aan

pe |
S

CONTROL

MANAGER

ROUTINES

a
S
m
ge

The following new Control Manager routines can be used as noted below for the Macintosh
Plus, the Macintosh SE, and the Macintosh II.

Control Manager Routines V-221

©
=

Inside Macintosh
FUNCTION

GetCVariant

(theControl:

ControlHandle)

:

[Macintosh Plus, Macintosh SE, and Macintosh IT]

INTEGER;

The GetVariant function returns the variant control value for the control described by
theControl. This value was formerly stored in the high four bits of the control defproc
handle; for future compatibility, use the GetC Variant routine to access this value.
PROCEDURE

SetCtlColor

CCTabHandle) ;

(theControl:

[Macintosh II]

ControlHandle;

newColorTable:

The SetCtlColor procedure sets or modifies a control’s color table. If the control currently
has no auxiliary control record, a new one is created with the given color table and added to
the head of the auxiliary control list. If there is already an auxiliary record for the control,
its color table is replaced by the contents of newColorTable.

If newColorTable has the same contents as the default color table, the control’s existing
auxiliary record and color table are removed from the auxiliary control list and deallocated.

If theControl = NIL, the operation modifies the default color table itself. If the control is
visible, it will be redrawn by SetCtlColor using the new color table.
FUNCTION

GetAuxCtl

AuxCtlHndl)

(theControl:

: BOOLEAN;

ControlHandle;

[Macintosh II]

VAR

acHndl:

The GetAuxCtl function returns a handle to a control’s color table:

u If the given control has its own color table, the function returns TRUE.
u If the control used the default color set, the function returns FALSE.
u If the control asked to receive the default color set (theControl = NIL), then the
function returns TRUE.

V-222 Control Manager Routines

The Control Manager

SUMMARY

OF THE CONTROL

MANAGER

Constants
CONST

Data

cFrameColor
cBodyColor
cTextColor
cThumbColor

=
=
=
=

0;
Li
ai
3}

Types

TYPE
AuxCtlHandle=
AuxCtl1Ptr
=
AuxCt1lRec
=

*AuxCtlPtr;
“AuxCtlRec;
RECORD
acNext:

AuxCtlHandle;

{handle
{

acOwner:

ControlHandle;

acCTable:

CCTabHandle;

acFlags:

INTEGER;

acReserved:

LONGINT;

next

record

{miscellaneous

flags;

{reserved

future

{

LONGINT

to

}

list}

{handle to owning
}
{ control}
{handle to control's
{ color table}

{

acRefCon:

in

reserved}

for

}

}
}

expansion}

{reserved for
{ application

}
use}

END;

CCTabHandle = “CCTabPtr;
CCTabPtr
= “CtlCTab;

Ct1CTab

= RECORD

ccSeed:

ccReserved:
ctSize:
ctTable:

END;

LONGINT;

INTEGER;
INTEGER;
cSpecArray

{not

used

for

controls}

{not used for controls}
{number of entries
in table -1}
{array of ColorSpec records}

<

O
=
=

o
=
m

=

Routines

a“

‘

PROCEDURE
FUNCTION
FUNCTION

SetCtlColor

(theControl:

CCTabHandle);

GetAuxCtl

(theControl:

AuxWinHndl):
GetCVariant

BOOLEAN;
(theControl:

ControlHandle;
ControlHandle;
ControlHandle)

newColorTable:
VAR

acHndl:

:

INTEGER;

Summary of the Control Manager V-223

Inside Macintosh

Global

Variables

AuxWinHead

Contains a pointer to the linked list of auxiliary control records.

Assembly

Language

jauxCtlRec

structure

acFlags
acReserved
acRefCon
auxWinSize
;

Equates

EQU
EQU
EQU

EQU
EQU
EQU
EQU
for

the

cFrameColor

EQU

cTextColor

EQU

cBodyColor

cThumbColor
;

Global

EQU

EQU

$0
$4
$8

; [handle]
next in chain
; [ControlHandle]
owner ID
; [CTabHandle]
color table

$18
Sic

; [LONGINT]
user
;size of record

SC
SE

; [word] miscellaneous flags
; [LONGINT] for expansion

colors

of

control

constant

parts

WHR ©

acnext
acOwner
acCTable

Information

variable

AuxCtlHead

EQU

SOCD4

;Control

V-224 Summary of the Control Manager

Aux

List

head

13
226

THE

MENU

MANAGER

About This Chapter

227
227
227

~—‘~ Hierarchical Menus
~+Pop-Up Menus
Color Menus

228
231
234
235
235
235
235
235

Data Structures for Hierarchical Menus
Color Menu Data Structures
Menu Color Information Table Resource Format
Using the Menu Manager
Enable and Disable
_—‘ Fonts
Custom Menu Bars
_—_— Highlighting

237
238
238
242
243
248
250
251
256

Color
Menu Manager Routines
| New Menu Manager Routines
Drawing the Pop-Up Box
Changes to Existing Routines
The Standard Menu Definition Procedure
The Standard Menu Bar Definition Procedure
Parameters for Menu Bar Defproc Messages
Summary of the Menu Manager

228

236

Menu Manager Data Structures

Hierarchical and Pop-Up Menus

V-225

Inside Macintosh

ABOUT THIS CHAPTER
This chapter describes the enhancements to the Menu Manager for the Macintosh II. All
changes are backward-compatible with the Macintosh Plus and the Macintosh SE, so your
existing programs using Menu Manager routines will continue to work and produce the
same screen display as before. All new features, except for color menus, will work on the
Macintosh Plus and Macintosh SE using System 4.1 and later.
To best use the material presented in this chapter, you should be familiar with QuickDraw,
and should also know how to use resources in your application programs.
For the Macintosh Plus, Macintosh SE,

provides these features:

and Macintosh II, the new Menu Manager

= Menus can include submenus. This feature is known as hierarchical menus.
Hierarchical menu items have a small filled black triangle pointing to the right,
indicating that a submenu exists.
= Pop-up menus are supported.
w Scrolling menus are marked with a filled black triangle indicator at the top or bottom of
the menu, to indicate which direction the menu may scroll.
ws Within menus, font names for international scripts are printed in the actual script rather
than in the system font when the Script Manager is installed.
= A new definition procedure (defproc), called the Menu Bar Defproc, handles such

functions as drawing the menu bar and saving and restoring bits behind a menu.

w It is now possible to determine if a user has chosen a disabled menu item.
For the Macintosh IJ, the new Menu Manager provides these features:
w Color can be added to menus. When the menu title is the appleMark, a color apple is
displayed instead of the system font appleMark. Applications may provide additional
colors in menus if desired.
A bug in the DrawMenuBar procedure has been fixed; formerly, DrawMenuBar would
redraw incorrectly when a menu was highlighted. If your application called HiliteMenu or

FlashMenuBar to correct this, the result will now be overcompensation, and the menu title

will be unhighlighted. Another change overcomes a limitation in the original menu data

structure; the EnableItem and DisableItem routines now refer to the menu title and the first

31 items only, and all items beyond 31 are always enabled.

The following sections define and describe the new hierarchical, pop-up, and color menus.
The remainder of the chapter describes the data structures and routines used to implement
the new Menu Manager features.

V-226 About This Chapter

The Menu Manager
Hierarchical

Menus

A hierarchical menu is a menu that includes, among its various menu choices, the ability
to display a submenu. In most cases the submenu appears to the right of the menu item

used to select it, and is marked with a filled triangle indicator. Throughout this chapter,

there is a distinction made between a menu and a hierarchical menu. If the word hierarchical

is not used, then the reference is to a nonhierarchical menu. At times, though, the term

normal or regular menu may appear when referring to a nonhierarchical menu. The term
submenu is used to describe any menu that is the “offspring” of a previous menu.
Several illustrations of hierarchical menus appear in the Macintosh User Interface

Guidelines chapter, with recommendations for their use.

Pop-Up

Menus

The PopUpMenuSelect routine allows an application to create a pop-up menu. A pop-up
menu is one that isn’t in the menu bar, but appears somewhere else on the screen (usually
in a dialog box) when the user presses in a particular place. A pop-up menu may be colored
like any other menu, and it may have submenus. Pop-up menus are typically used for lists
of items, for example, a list of fonts. See the Macintosh User Interface Guidelines chapter
for a more complete description of how to use pop-up menus in your application.
Color

Menus

For the Macintosh II, color can be added to menus in video modes with a resolution of two
bits or greater. Your application can specify the menu bar color, menu title colors, the
background color of a pulled down menu, and a separate color for each menu item’s mark,
name, and command character. As the Macintosh II is shipped, the only user observable
menu color is the color Apple symbol, which appears in the 4-bit and 8-bit modes. If the
menu title is the appleMark (a one-character string containing the appleMark character $14)
the color Apple symbol appears instead of the system font appleMark.
Multicolor menus should be used with discretion: user testing has shown that the use of
many arbitrary colors can cause user confusion and slow down menu item recognition. See
the Macintosh User Interface Guidelines chapter for more information on using color in
applications.
The user can specify system-wide menu colors along with a colored desktop pattern with
the Control Panel, and applications should avoid overriding the user choices. The systemwide menu colors are specified in the 'mctb' resource = 0 in the System file, and include
m the menu bar color
= a default color for menu titles

oe
=

a a default color for the background of a pulled-down menu

<©
=
=

= a default color for menu items.

=
=

te

7)
beg |

About This Chapter V-227

Inside Macintosh

The user-specified default colors may be overridden by a separate 'mctb' resource = 0 in
the application’s resource file.
Of course, a user can also use a resource editor to completely color an application’s menus
by adding or changing its 'mctb' resource(s). If your application doesn’t need color menus,
it should not try to override the user’s default color choices. However, if the application

needs specific colors that might clash with a user’s default choices, the user should be

prompted for an alternate choice of colors. An application should only override a user’s
choices as a last resort; let the user’s color preferences prevail.

MENU

MANAGER

DATA STRUCTURES

There are two existing Menu Manager data structures. The MenuList contains data
describing which menus are in the menu bar. Each menu has a Menulnfo structure
describing the items in that menu. For backward compatibility, the Menulnfo structure has
not been changed, although several of its fields have new meanings for hierarchical menus.
The MenuList has also kept its general structure to provide backward compatibility, and

still contains six bytes of header information and six bytes of information for each menu;

however, each menu entry is now allocated dynamically. There is also additional storage at
the end of the MenuList for hierarchical and pop-up menus.
Except where explicitly noted, the data structures in this section are listed for information
only; applications should never interrogate or change them directly. The Menu Manager
routines provide all needed functions.
Data

Structures

for

Hierarchical

Menus

A new MenuList data structure accommodates hierarchical menus. It dynamically allocates
storage space as menus and hierarchical menus are added and deleted.
Warning: The MenuList data structure is listed for information only; applications
should never access it directly.

The following TYPE definition is for conceptual purposes only; there is no such data
structure in the Menu Manager:
TYPE

InitialMenuList

= RECORD
lastMenu:
lastRight:

mbResID:

lastHMenu:

V-228 Menu Manager Data Structures

INTEGER;
INTEGER;

INTEGER;

INTEGER;

{offset}
{pixels}

{upper

13

bits

used

as

{
{

mbarproc resource
ID
low 3 bits used as }

{

mbVariant

{offset}

}

}

}

The Menu Manager
menuTitleSave:

pixMapHandle
{
{

END;

Field

bits
menu

{handle

behind
title}

to

}

inverted

}

descriptions

lastMenu

The lastMenu field contains the offset to the last regular menu in the
MenuList.

lastRight

The lastRight field contains the pixel location of the right edge of the
rightmost menu in the menu bar.

mbResID

The mbResID field stores the resource ID of the menu bar defproc
used by the application. Its default value is zero. The upper 13 bits
are used as the resource ID. The low three bits are passed to the
menu bar defproc (MBDF'’) as the mbVariant.

lastHMenu

The lastHMenu field contains the offset to the last hierarchical menu
in the MenuList.

menuTitleSave

The menuTitleSave field stores a PixMapHandle to the saved “bits
behind” the selected menu title.

When the MenuList data structure is initialized, there is no space allocated for menu handles
or hierarchical menu handles. When a menu is allocated, six bytes are inserted between the
mbResID and lastHMenu fields. As each menu is allocated or deleted, the space between
mbResID and lastHMenu grows or shrinks accordingly. Space is allocated for hierarchical
menus after the MenuTitleSave field, and its space is also dynamic.
A sample MenuList Data Structure with X menus and Y hierarchical menus appears below.
Warning: The sample MenuList structure is not a valid Pascal type because of its
dynamic size; it’s shown for conceptual purposes only.
TYPE

MenuRec

=

RECORD
menuOH:
menuLeft:
END;

HMenuRec

=

Menuhandle;
INTEGER;

{menu's
data}
{pixels}

Menuhandle;

{hierarchical

menu's

}

INTEGER;

{ data}
{reserved

future

}

RECORD
menuHOH:

reserved:

{

for

use}

END;

DynamicMenuList = RECORD
lastMenu:

—

oe

<=

INTEGER;

{offset}

i)
=
=

=

~~
Fo
@

ar

Menu Manager Data Structures V-229

Inside Macintosh
lastRight:

INTEGER;

mbResID:
menu:

INTEGER;
ARRAY
[1..X]

lastHMenu:

INTEGER;

menuTitleSave:
hMenu:

{pixels}

PixMapHandle

ARRAY

[1..Y]

OF

MenuRec;

{X is the
{ menus}
{offset}
{

{handle

number

to

bits

inverted

OF

menu

of

}

behind

}

title}

HMenuRec;

{Y is the number
{ submenus used}

of

}

END;

The initial MenuList data structure is allocated by InitMenus each time an application is
started. Any subsequent calls to InitMenus, while the application is running, don’t cause
the MenuList data structure to be reallocated.
The Menulnfo data structure is shown below; this version is similar to what is shown in
Volume 1, but includes additional information about menu items.

Warning: The Menulnfo data structure is listed for information only; applications
should never access it directly. This structure is not a valid Pascal type because of its
dynamic size; it’s shown for conceptual purposes only.
TYPE

MenuInfo

= RECORD

menulD:
menuWidth:
menuHeight:
menuProc:
enableFlags:

INTEGER;
INTEGER;
INTEGER;
Handle;
LONGINT;

{menu ID}
{pixels}
{pixels}
{handle}
{bit string}

itemData:

ARRAY

OF

menuTitle:

String;

[1..X]

itemString:

name}

char;

{item

cmd

itemMark:

char;

itemStyle:

Style;

{iconnum-256}

V-230 Menu Manager Data Structures

key}

{item mark is a }
}
{ byte value
{ for hierachical
{

menus}

{bit

string}

{zero-length
}

}

{

string

indicates

no

{

more

items}

{
END;

name}

{item

BYTE;

Byte;

title

string;

itemIcon:

itemCmd:

endMarker:

{menu

menu

}

}

The Menu Manager

Field

descriptions

menulID

The menulD field contains the menu ID of the menu.

menuWidth

The menuWidth field contains the width in pixels of the menu.

menuHeight

The menuHeight field contains the height in pixels of the menu.

menuProc

The menuProc field contains a handle to the menu’s definition

enableFlags

The enableFlags field is a bit string which allows the menu and the
first 31 items to be enabled or disabled. All items beyond 31 are
always enabled.

menuTitle

The menuTitle field is a string containing the menu title.

itemData

The itemData field is an array containing the following information

procedure.

for each menu item: item name, item icon number, item command
key equivalent, item mark, and item style. For hierarchical menus,

the itemMark field is a byte value.

endMarker

The endMarker field is a byte value, which contains zero if there are
no more menu items.

The contents of the itemData array are the same for hierarchical and nonhierarchical menus,
but for hierarchical menus the itemMark field is a byte value, which limits hierarchical

menu menulD values to between 0 and 255. Hierarchical menus numbered 236 to 255 are
reserved for use by desk accessories. Desk accessories must remove their hierarchical
menus from the MenuList each time their window is not the frontmost, to prevent
hierarchical menu collisions with other desk accessories.
Color

Menu

Data

Structures

For the Macintosh II, menus can be colored in 2-bit mode or higher, in both color and

gray-scale. The menu color information is contained in a table format, but because this

format is different from the standard color table format, it is referred to as the menu color
information table, rather than the menu color table. A menu color information table is

composed of several entries, each of which is an MCEntry record. These data structures
are shown below:

TYPE MCEntryPtr

MCEntry

=

“MCEntry;

= RECORD

mctID:

INTEGER;

mctiItem:

INTEGER;

mctRGB1:

RGBColor;

{menu

ID.

{

menu

0

is

}

{menu entry.
Item
{ is a title}

=

0

the

{usage

{

and

ID

=

bar}

depends

Item}

on

ID

}

}

—

we
=

a)

=)
—

a
mat

i
=
i)
ge
@

Lear |

Menu Manager Data Structures V-23 1

Inside Macintosh
mctRGB2:

RGBColor;

mctRGB3:

RGBColor;

mctRGB4:

RGBColor;

{usage
{

{usage

INTEGER;

depends
Item}

depends

{ and Item}
{usage depends
{

mctReserved:

and

and

ID

}

on

ID

}

on

ID

}

Item}

{reserved

{

on

for

internal

}

{The menu entries are
{ represented in this

}
}

use}

END;

MCTable

=

ARRAY

[0..0]

of

MCEntry;

{ array}
MCTablePtr
=
MCTableHandle

Field

“MCTable;
= “MCTablePtr;

descriptions

mctID

The mctID field contains the menu ID of the menu. A value of

mcetltem

The mctltem field contains the menu item. A value of item = 0
means that the item is a menu title.

mctRGB1

The mctRGBI1 field contains a color value which depends on the
mctID and mctlItem. See the description in the following section.

mctRGB2

The mctRGB2 field contains a color value which depends on the
mctID and mctlItem. See the description in the following section.

mctRGB3

The mctRGB3 field contains a color value which depends on the
mctID and mctlItem. See the description in the following section.

mctRGB4

The mctRGB4 field contains a color value which depends on the
mctID and mctlItem. See the description in the following section.

mctReserved

The mctReserved field is used internally; applications must not use
this field.

mctID = 0 means that this is the menu bar.

The color information table is created at InitMenus time, and its handle is stored in the

global variable MenuCInfo ($D50). Like the MenuList data structure, it is only created the

first time InitMenus or InitProcMenu is called for an application.
A menu color information table is shown in Figure 1.

V-232 Menu Manager Data Structures

The Menu Manager
Menu

Menu Color Table Entries

Elements

ID

ltem

menu bar

0

0

RGB1
default

title

RGB2

RGB3

default

default

back-

ground

Noo

O

title

color

color

item

N<>O

M<>O_

mark

name

last entry

-99

reserved reserved

default

ber

title

color

items

items

com-

color

mand

reserved

reserved

color

RGB4_

Reserved

bar

reserved

back-

reserved

color

ground
color

= back. _— reserved

= ground

color

reserved

reserved

Figure 1. Menu Color Information Table

There is always at least one entry in the color table, the last entry, which has the arbitrary
value —99 in the ID field as an “‘end-of-table” marker. (This means that the value —99 cannot
be used as an ID by an application.) Note that the other fields in the “‘end-of-table” entry are
reserved by use for Apple. Each entry in the color information table has seven fields.
The first two fields define the entry’s menu and item. The last field is used internally and
has no information for use by programmers. The other fields define colors depending on
what type of menu element the entry describes. All colors are specified as RGB colors.
There are three types of entries in the menu color information table: one type for the menu
bar, one type for menu titles, and one type for menu items.
The menu bar entry has ID = 0, Item = 0. There will be at most one menu bar entry in
the color information table. If there is no menu bar entry, the default menu bar colors are
black text on a white background. The fields in a menu bar entry are as follows:
m= mctRGB1 is the default color for menu titles. If a menu title doesn’t have an entry in
the table, then this is the color used to draw the title.

= mctRGB2 is the default color for the background of a pulled down menu. If a menu
title doesn’t have an entry in the table, this color is used as the menu’s background
color.
= mctRGB3 is the default color for the items in a pulled down menu. If a menu item

doesn’t have an entry in a table, and if the title for that menu item doesn’t also have an
entry, this color will be used to color the mark, name, and Command-key equivalent

of the item.

= mctRGB4 is the menu bar color.

—

The menu title entry has ID <> 0, Item = 0. There will be at most one title entry for each
menu in the color information table. If there is no title entry, the title, menu background,

we
@
=
—

<

=
=
i)
ve
@

=y

Menu Manager Data Structures V-233

Inside Macintosh

and menu items are drawn using the defaults found in the menu bar entry. If there is no
menu bar entry, the default colors are black on white. The fields in a title entry areas
follows:
= mctRGBGI

is the title color.

= mctRGB2 is the menu bar color. This is duplicated here from the menu bar entry to
speed menu drawing.
= mctRGB3 is the default color for the menu items. If a menu item doesn’t have an entry
in the table, this color will be used to color the mark, name, and Command-key

equivalent of the item.

= mctRGB4 is the menu’s background color.
The menu item entry has ID <> 0, Item <> 0. There will be at most one item entry for
each menu item in the color information table. If there is no entry for a particular item, the
item mark, name, and Command-key equivalent are drawn using the defaults found in the
title entry. If there is no title entry, the information in the menu bar entry is used. If there is
no menu bar entry, the mark, name, and Command-key equivalent are drawn in black. The

fields in an item entry are as follows:
= mctRGB1 is the mark color.
= mctRGB2 is the name color.

=» mctRGB3 is the Command-key equivalent.
= mctRGB4 is the menu’s background color. It’s duplicated here to speed menu
drawing.
It’s not possible to specify an icon’s color. Black and white icons are drawn in the item’s
name color. Icons may be colored using a 'cicn' resource instead of an 'ICON' resource.
When an icon is drawn in a menu, the menu defproc attempts to load the 'cicn' resource
first, and if it isn’t found, searches for the 'ICON' resource. The menu defproc checks a
color icon’s size, and won’t display it if it’s larger than 32-by-32. See the QuickDraw
chapter for more information on color icons.
Menu

Color

Information

Table

Resource

Format

The resource type for a menu color information table is 'mctb'. Once read into memory,
this data is transferred into the application’s menu color information table. The resource
data format is identical to an MCTable, with the addition of a leading word that contains the
number of entries in the resource:
TYPE MenuCRsre = RECORD
numEntries:
integer;
data:
array
[1..numEntries]
END ;

of

MCEntry;

The 'mctb' resource is loaded automatically by two routines. InitMenus attempts to load an
‘mctb' resource = 0, and if it is successful, adds the colors to the application’s menu color

information table. GetMenu attempts to load an 'mctb' resource with the same resource ID

V-234 Menu Manager Data Structures

The Menu Manager
as the menu it has loaded, and if it succeeds, it adds the colors to the application’s menu
color information table.

USING THE MENU

MANAGER

This section describes how to use the new Menu Manager routines implemented for the
Macintosh Plus, Macintosh SE, and Macintosh II. It also explains how changes to
previously existing routines affect Menu Manager functions. Several of the new features
and calls have interesting side effects that aren’t immediately obvious. If your application is
running on a machine that can only produce a black-and-white display, any color
information is ignored, and color icons won’t be displayed.
Enable

and

Disable

The Enableltem and DisableItem routines have been changed so that they affect only the
menu and the first 31 items. All items beyond 31 are always enabled. The DrawMenuBar
routine properly highlights the selected menu title, if one exists.
When a user chooses a disabled menu item—that is, when the mouse-up event occurs over
a disabled item—MenuSelect returns a zero result. In the past, there was no way for an
application to determine which disabled item was chosen. A new routine, MenuChoice, can
now be called after MenuSelect returns a zero result, to determine if the mouse was over a
disabled item, and if so, what were the menu ID and item number.
Fonts

The AddResMenu and InsertResMenu routines can recognize when an added 'FONT' or
‘FOND' resource is the name of an International font. If the Script Manager is installed, the
font name will be displayed in the actual script. GetIltemIcon may be used to determine the
script number of a font item that names an International script. SetItemIcon should never be
called for font items that are International scripts.
Custom

Menu

Bars

You should only use the InitProcMenu routine if your application has a custom menu bar
defproc. The effect of this routine lasts for the duration of the application program only,
and the default menu bar defproc is used afterwards.

Highlighting

Oo

Menu highlighting has been modified, and this affects the MenuSelect, MenuKey,
HiliteMenu, and FlashMenuBar routines. Previously, a menu title was selected by inverting

<=<7)

>
=

=
=a

ye
&
=

Using the Menu Manager V-235

Inside Macintosh
the rectangle that contained the menu title; when the menu became deselected, the same

rectangle was merely inverted again, returning the title to its original state. This menu title
inversion was changed for color menus. In the color world, it is no longer proper to merely
invert the title’s rectangle. Color inversion often produces unpleasing and/or unreadable
results. Your application should set the foreground and background colors before drawing
a selected menu, and then reset the foreground and background colors before drawing the
deselected (i.e., normal) menu. One important result of this new highlighting scheme is that
only one menu may be highlighted at a time.

Hierarchical

and

Pop-up

Menus

Using hierarchical menus in an application is straightforward. Hierarchical menus may be
stored as 'MENU' resources, just as regular menus are. To specify that a particular menu is
hierarchical, pass a “beforeID” of —1 to the InsertMenu routine. When InsertMenu gets a
—1, it places the menu in the hierarchical portion of the MenuList. Pop-up menus are also
stored in the hierarchical portion of the MenuList, and like hierarchical menus, are specified

by passing a “beforeID” of —1 to InsertMenu. DeleteMenu may be used to remove a
hierarchical or pop-up menu from the MenuList.

A submenu is associated with a menu item by reusing two of the fields in the MenuInfo

data structure. When the itemCmd field has the hex value $1B, the itemMark field contains

the menulID of the associated hierarchical menu. (These two fields are used because an item
with a submenu never has a check mark, and doesn’t have a Command-key equivalent.)

The itemMark field is a byte value, which limits hierarchical menu menuIDs to values
between 0 and 255. The menuIDs 0-235 (inclusive) may be used by applications; numbers
236-255 are reserved for desk accessories.
Because there is no way to arbitrate among desk accessories, each desk accessory is
responsible for inserting its hierarchical menus when it becomes active, and deleting them
when it is deactivated. The problem with this scheme is that some desk accessories, such as
a spelling checker, need to be activated all the time; this kind of desk accessory can’t use
hierarchical menus, since it has no way to determine when it should add or delete its

menus.

Attaching a submenu to a menu item is done in one of two ways. One way is to place a $1B
in the Command-key equivalent byte in the 'MENU' resource. To specify which
hierarchical menu is the submenu, the hierarchical menu’s resource ID is placed in the
character mark byte in the 'MENU' resource.
The other way to attach a submenu to a menu item is to call AppendMenu or
InsMenultem.The value $1B may be placed after the Command key metacharacter (/) to
signify that an item has a submenu. The value of the character following the mark
metacharacter (!) is taken as the menu ID of the submenu.

The MenuKey routine has been modified to search for Command-key equivalents in
hierarchical menus. To accomodate future extensions to the Menu Manager, the Command
key values $1B (Control-[ ) through $1F (Control-_ ) are reserved for use by Apple
Computer. The MenuKey procedure ignores these five values as Command-key
equivalents. Until the Apple Standard Keyboard was implemented, it was impossible for

V-236 Using the Menu Manager

The Menu Manager

the user to type a Control-key sequence, so reserving these five values will not impose
limitations on existing applications.
Two new procedures, GetItemCmd and SetItemCmd, have been included to facilitate

hierarchical menu manipulation. GetItemCmd can be used to determine if a menu item has a

submenu attached. SetItemCmd can be used to attach a submenu to a menu item.
GetItemMark can be used to determine the ID of the hierarchical menu associated with an
item. SetItemMark can be used to change the ID of the hierarchical menu associated with an
item. The GetMHandle routine can be used to get a menu handle for a menu, pop-up menu,
or hierarchical menu.
Color
A number of existing routines have been modified for color menus; these changes affect
only the Macintosh II. The InitMenus routine attempts to load a menu color resource,
‘mctb' resource = 0, and if it succeeds, stores those colors in the application’s menu color
information table. This allows the user to specify a set of menu colors that will exist across
all applications.
Calling the GetMenu, GetMenuBar, SetMenuBar, and GetNewMBar routines affects the
menu color information table. Clear MenuBar disposes both the current MenuList and the
current menu color information table.
GetMenu has been modified: it looks for a 'MENU' resource with the resource ID equal to
the parameter “menuID” and returns a handle to the menu. It also looks for a 'mctb'
resource with the resource ID equal to the parameter “menuID”, and if one is found, adds
the colors to the current menu color information table. DeleteMenu removes all entries from
the menu color information table for the menuID specified.

A set of new routines provides access to the menu color information table. SetMCEntries
allows an application to add new menu colors and GetMCEntry allows the application to
query a particular menu color. De/MCEntries deletes specified menu color information table
entries.
GetMCInfo makes a copy of the current menu color information table, and returns a handle
to the copy. While GetMenuBar returns the handle to the current MenuList, you must also
call GetMCInfo if you want the handle to the current menu color information table.
SetMCInfo copies a table of menu color entries into the current table, after first disposing

of the current table; this routine can be used to set a new menu color information table, or

restore a table previously saved by GetMCInfo. SetMenuBar first disposes of the current
MenuList, then makes a copy of the MenuList passed as a parameter and makes it the
current MenuList. If you also want to set the menu color information table, your application
must call SetMCInfo.
GetNewMBar first calls GetMenuBar to store the current MenuList. Next, it calls

ClearMenuBar, thus disposing of the current MenuList as well as the current menu color
information table. Then it calls GetMenu and InsertMenu for every menu in the menu bar.

This builds not only a new MenuList, but a new menu color information table. Finally,

GetNewMBar restores the old MenuList by calling SetMenuBar. Notice that it doesn’t store

Ge
<@
=
=
<
fe
=i)
geo
—

fs.

Using the Menu Manager V-237

Inside Macintosh

the current menu color information table before it begins, nor does it restore it upon
leaving. Applications should bracket a call to GetNewMBar with calls to GetMCInfo and
SetMCInfo, as shown in the following example:
CurMCTable

:=

GetMCInfo;

NewMenuBar

:=

GetNewMenuBar
(4);

NewMCTable
SetMCInfo

MENU

:=

GetMCInfo;

(CurMCTable) ;

MANAGER

{save current
{ table}
{get new menu

{get

new

{restore
{ table}

menu

menu
bar

color
#4}

color

previous

info

menu

info

}

table}

color

info

}

ROUTINES

The Menu Manager routines listed in the following sections are implemented for the
Macintosh Plus, Macintosh SE, and Macintosh II where noted.

New

Menu

PROCEDURE
Note:

Manager

Routines

InitProcMenu
(mbResID:
SE, Macintosh II]

INTEGER) ; [Macintosh Plus, Macintosh

The mbVariant field is contained in the low three bits of the mbResID. The

high order 13 bits are used to load the proper 'MBDF'.

The InitProcMenu routine is called when an application has a custom menu bar defproc,
'MBDF'. InitProcMenu allocates a new MenuList if it hasn’t already been allocated by a
previous call to InitMenus, and the mbResID is stored in the mbResID field in the
MenuList (note that InitWindows calls InitMenus, so that it can obtain the menu bar
height).
The effect of InitProcMenu lasts for the duration of the application only; the next InitMenus
call will replace the mbResID field in the MenuList with the default value of zero. This
affects applications such as development systems, which use multiple heaps and whose
“applications” call InitMenus.

Note:

Apple reserves mbResID values $000-$100 for its own use.

PROCEDURE

DelMCEntries

(MenuID,

menuItem:

INTEGER);

[Macintosh II]

The DelMCEntries routine deletes entries from the menu color information table based on
the given menuID and menultem. If the entry is not found, no entry is removed. If the
menultem is mctAllItems (—98), then all Items for the specified ID are removed.
Applications must, of course, never delete the last entry in the menu color information
table.

V-238 Menu Manager Routines

The Menu Manager
FUNCTION

GetMCInfo:

MCTableHandle;

[Macintosh II]

The GetMCInfo routine creates a copy of the current menu color information table and
returns a handle to the copy. It doesn’t affect the current menu color information table. If
the copy fails, a NIL handle is returned.
PROCEDURE

SetMCInfo

(menuCTbl

: MCTableHandle);

[Macintosh
II]

The SetMCInfo routine copies the given menu color information table to the current menu
color information table. It first disposes of the current menu color information table, so
your application shouldn’t explicitly dispose the current table. If the copy fails, the global
variable MemErr contains the error code, and the procedure doesn’t dispose the current
menu color information table. Applications should call the MemError function to determine
if this call failed.
You can use this procedure to restore a menu color information table previously saved by
GetMClInfo. Be sure to call DrawMenuBar to update the menu bar if a new menu bar color
or menu title colors have been specified.
PROCEDURE

DispMCInfo

(menuCTbl

: MCTableHandle);

[Macintosh
II]

Given a handle to a menu color information table, the DispMCInfo routine disposes of the
table. No checking is done to determine whether the handle is valid. While this procedure
currently only calls DisposHandle, to ensure compatibility with any updates to the color
portion of the menu manager, it’s a good idea to use this call.
FUNCTION

GetMCEntry

[Macintosh II]

(menuID,

menuItem

:

INTEGER):

MCEntryPtr;

The GetMCEntry routine finds the entry of the specified menuID and menultem in the
menu color information table, and returns a pointer into the table. If the entry is not found,
a NIL pointer is returned.
Note: Entries are not removed from the table. Applications must not remove entries
from the table directly; they should always use the procedure DeIMCEntries to
remove entries.
Warning: The menu color information table is relocatable, so the GetMCEntry
return value may not be valid across traps that move or purge memory. Applications
should make a copy of the record in this case.
PROCEDURE

SetMCEntries

MCTablePtr)

(numEntries:

; [Macintosh II]

INTEGER;

menuCEntries:
—

Ge

The SetMCEntries procedure takes a pointer to an array of color information records. The
array may be of any size, so it’s necessary to also pass the number of entries in the array.

<=9°)
~
i=}

<

+)
—|
=
ge

a")
am |

Menu Manager Routines V-239

Inside Macintosh

The ID and Item of each entry in the color information record array are checked to see if the
entry already exists in the menu color information table. If it exists, the information in the

entry is used to update the entry in the color table. If the entry doesn’t exist in the color
information table, the entry is added to the table.
Warning:

SetMCEntries makes memory management calls that may move or purge

memory; therefore the array menuCEntries should be nonrelocatable for the duration

of this call.
FUNCTION

MenuChoice

: LONGINT;

[Macintosh IT]

The MenuChoice routine is called only after the result from MenuSelect is zero. It

determines if the mouse-up event that terminated MenuSelect was in a disabled menu item.

When the mouse button is released over a disabled item in an application menu,
MenuChoice returns a long integer whose high-order word is the menuID of the menu, and
whose low-order word is the menu item number for the disabled item “chosen”’. If the item
number is zero, then the mouse-up event occurred when the mouse was either in the menu
title or completely outside the menu; there is no way to distinguish between the two.
Note: This information is available on the Macintosh Plus and Macintosh SE by
directly querying the long word stored in the global variable MenuDisable ($B54).
This feature has been added to MenuChoice to make it possible for applications to provide
better help facilities. For example, when the Finder calls MenuChoice, and determines that
a user has chosen the disabled menu item “Empty Trash” with the Finder, the application
could display a message telling the user that it can’t empty the trash because there is nothing
currently in the trash.
The new MenuChoice capability is implemented by continual updates of the global variable
MenuDisable ($B54) whenever a menu is down. As the mouse moves over each item,
MenuDisable is updated to reflect the current menu and item ID. The code that changes the
value in MenuDisable resides in the standard menu defproc. The return value is undefined
when the menu uses a custom menu defproc, unless the custom defproc also supports this
feature.
PROCEDURE

GetItemCmd

(theMenu:

emdChar:Char);

menuHandle;

item:

INTEGER;

VAR

[Macintosh Plus, Macintosh SE, Macintosh IT]

The GetItemCmd routine may be used to determine whether a menu item has a submenu

attached. For a menu item with a submenu, the returned cmdChar will have the value $1B.
PROCEDURE

SetItemCmd

(theMenu: _menuHandle;

emdChar:Char);

item: INTEGER;

[Macintosh Plus, Macintosh SE, Macintosh II]

The SetItemCmd routine allows the application to attach a submenu to a menu by passing
the character $1B. You should be careful about arbitrarily adding or removing a submenu
from a menu item; see the Macintosh User Interface Guidelines chapter for

V-240 Menu Manager Routines

The Menu Manager
recommendations. Notice that SetItemMark can be used to change the ID of the submenu
that is associated with the menu item.
Note: SetItemCmd must never be used to change the Command-key value of a
menu item that doesn’t have a submenu; users must always be free to change their
Command-key preferences.
FUNCTION

PopUpMenuSelect

Top,

Left,

(theMenu:menuHandle;

PopUpItem: INTEGER):

Macintosh SE, Macintosh IT]

LONGINT;

[Macintosh Plus,

The PopUpMenuSelect routine allows an application to create a pop-up menu anywhere on
the screen. This menu may be colored like any other menu, and it may have submenus. The
return value is the same as that for MenuSelect, where the low word is the menu item
selected, and the high word is the menu ID. Unlike MenuSelect, PopUpMenuSelect
doesn’t highlight any of the menus in the menu bar, so HiliteMenu(0) doesn’t have to be
called after completing the chosen task.
Pop-up menus are typically used for lists of items, for example, fonts. See the Macintosh
User Interface Guidelines chapter for a description of how to use pop-up menus in your
application. See MenuSelect for information about the return value when the menu chosen
is a hierarchical menu.
TheMenu is a handle to the menu that you want “popped up”. The PopUpltem is typically
the currently selected item, that is, the last item selected, or the first item if nothing was

selected. Doing this allows the user to click on a pop-up menu and release again quickly,
without changing the item selection by mistake. The parameters Top and Left define where
the top left corner of the PopUpltem is to appear, in global coordinates. Typically, these
will be the top left coordinates of the pop-up box, so that the menu item appears on top of
the pop-up box. See Figure 2 for an example.
Pop-up Title

Baud

rate:|

Pop-up box

Inverted

|

300

Before Selection

Pop-up Title

4

Baud

Top, Left
rate:

PopUp|tem
v300
600
1200
2400
4800
9600
19200

After Selection
Figure 2. Pop-up Box Parameters

Menu Manager Routines V-241

Inside Macintosh

Drawing

the

Pop-Up

Box

Your application is responsible for drawing the pop-up box. A pop-up box is a rectangle
that is the same height as the menu item, is wide enough to show the currently selected
item, and has a one-pixel-wide drop shadow.
The pop-up box must be the same height as a menu item so that when the menu appears,
the cursor will be in the previously chosen item. If the pop-up box is too tall, the user could

click once quickly in a pop-up box and unintentionally choose a different menu item. The
height of a menu item in the system font is the ascent + descent + leading.

The pop-up box has a title to its left. The application is responsible for recognizing a
mouse-down event in the pop-up box, and highlighting the title to the left of the pop-up

menu box before calling MenuSelect. Similarly, the application is responsible for
highlighting the title if the pop-up menu has Command-key equivalents.

Before calling PopUpMenuSelect, the pop-up menu must be installed in the hierarchical
portion of the MenuList by passing a value of —1 as the “beforeID” to InsertMenu.
The following is a sample psuedocode stub that might be used to track a pop-up menu:
if

mouse is in popUpMenuRect then
myInvertPopUpTitle();
InsertMenu (popupMenuHandle,
-1);
Result

=

PopUpMenuSelect

{invert title of pop-up menu}
{-1 means hierarchical menu}

(popUpMenuHandle,

popUpRect.Left,
DeleteMenu

(popUpMenulID)

myInvertPopUpTitle()
endif

;

popUpRect.Top,

lastItemSelected) ;

;

{return

pop-up

title

to

normal}

Notice that PopUpMenuSelect’s sole function is to display the pop-up menu and track the
mouse during a mouse-down event. It is the application’s responsibility to handle all other
pop-up menu functions, such as drawing the pop-up box, drawing and highlighting the
title, and changing the entry in the pop-up box after an item has been chosen from the popup menu. This could all be handled by creating a pop-up menu control within the

application.

When calling PopUpMenuSelect, the pop-up menu must be in the MenuList for the
duration of the call. The code above shows a call the InsertMenu before, and a call to
DeleteMenu after, the call to PopUpMenuSelect. The InsertMenu must be used at some
time before the call to PopUpMenuSelect, but it’s not necessary to call DeleteMenu
immediately afterwards; the pop-up menu may be left in the MenuList if desired.
Pop-up menu items can have Command-key equivalents. The application must provide
sufficient visual feedback, normally provided by using MenuKey, by inverting the pop-up
title.

V-242 Menu Manager Routines

The Menu Manager

Changes

to

Existing

PROCEDURE

InitMenus;

Routines

The InitMenus routine now allocates a dynamic MenuList structure with no menus or

hierarchical menus. After allocating the initial MenuList, it attempts to load an 'mctb'

resource = 0. If the user has chosen default menu color values, this 'mctb' resource = 0
will exist in the System file. If the 'mctb' is loaded, the information contained in the
resource is added to the menu color information table by making a call to SetMCEntries. If
there is an 'mctb' resource = 0 among the application’s resources, this will be loaded
instead of the default 'mctb' in the System file.
FUNCTION

GetMenu

(resourceID:

INTEGER)

:

MenuHandle;

After loading a 'MENU' resource, GetMenu attempts to load an 'mctb' resource with the

same resource ID. If an 'mctb' is loaded, all of the entries are added to the application’s
menu color information table by making a call to SetMCEntries.
PROCEDURE

AppendMenu

(theMenu:

MenuHandle;

data:

Str255);

PROCEDURE

InsNewItem
(theMenu:
afterItem) ;

MenuHandle;

itemString:

Str255;

When adding an item to a menu using the AppendMenu or InsMenultem routines, a
submenu may be attached to the item by using $1B as the command character, and the
menu ID of the attached submenu as the mark character.
PROCEDURE

AddResMenu

(theMenu:

PROCEDURE

InsertResMenu
(theMenu:
afterItem:
INTEGER) ;

MenuHandle;

theType:

MenuHandle;

theType:

ResType);
ResType;

When AddResMenu or InsertResMenu is called for '"FONT' or 'FOND' resources, special
processing occurs for fontNumbers greater than or equal to $4000, as is the case for
international fonts. If the script associated with the font is currently active, then the
ItemCmd and ItemIcon fields are used to store information allowing the font names to be
displayed in the correct script.
There is a known problem with the AddResMenu and InsertResMenu routines, and with
the menu enable flags, when the number of items is greater than 31. Applications should
explicitly reenable or redisable all items after calling AddResMenu or InsertResMenu. This
is because only the first 31 items are affected by the enable flags: all items 32 and greater
are always enabled.

—

)

=om
=)
=

=S)
=

is)

itjo)

i)

=

Menu Manager Routines V-243

Inside Macintosh
PROCEDURE

InsertMenu

(theMenu:

MenuHandle;

beforeID:

INTEGER);

The InsertMenu routine can be used to add a hierarchical menu to the Menulist. If beforeID

is equal to —1, the menu is a hierarchical menu. If beforeID is greater than or equal to zero,
the menu is a nonhierarchical menu.

It isn’t necessary for every menu in the hierarchical menu portion of the MenuList to be
currently in use; that is, attached to a menu item. Hierarchical menus that are currently
unused, but may be used some time later by the application, may be stored there, and
attached to menu items only as needed. You should realize that this can cause problems if
the unattached submenus have items with Command-key equivalents, because MenuKey
will find these equivalents even though the menu is unattached.
PROCEDURE

DrawMenuBar;

The warning about DrawMenuBar in Volume I is no longer true; DrawMenuBar now
properly highlights the selected menu title, if there is one. If your application program
assumed that DrawMenuBar would redraw the menu incorrectly, and called HiliteMenu or
FlashMenuBar to compensate, what happens now is that the menu bar is redrawn properly,
and the next call to HiliteMenu or FlashMenuBar causes the highlighted title to become
unhighlighted.
PROCEDURE

DeleteMenu

(menuID:

INTEGER) ;

The DeleteMenu routine removes all color entries from the menu color information table for

the specified menulD. It first checks the hierarchical portion of the MenuList for the

menulD and, if it finds it, deletes the menu; it then returns. If the menu is not found in the

hierarchical portion of the MenuList, the regular portion is checked.

The hierarchical portion of the MenuList is always checked first, so that any desk
accessories whose hierarchical menu IDs conflict with an application’s regular menu IDs
can call DeleteMenu without deleting the application’s menus.
PROCEDURE

DelMenuItem

(menuItemID:

INTEGER) ;

DelMenultem removes the item’s color entry from the menu color information table, and

then deletes the item.
FUNCTION

MenuSelect

(startPt:

Point)

:

LONGINT;

If the user chooses an item with a submenu, MenuSelect returns zero, meaning that no item

was selected. If the user selects an item from a hierarchical menu, the menulD of the
hierarchical menu and the menultem of the item chosen are returned, just as though the item

had been in a regular menu.

V-244 Menu Manager Routines

The Menu Manager
If MenuSelect returns zero, an application may call MenuChoice to determine whether the
mouse was released over either a disabled menu item or an item with a submenu.
Note: The global variable TheMenu contains the ID of the highlighted menu in the

menu bar. If an item from a hierarchical menu is chosen, TheMenu contains the ID of
the “owner” menu, not the ID of the hierarchical menu.
FUNCTION

MenuKey

(ch:

CHAR)

:

LONGINT;

The MenuKey routine first searches for the given key in the regular portion of the

MenuList, and if it doesn’t find it there, searches for the key in the hierarchical portion of

the MenuList. If the key is in a hierarchical menu, MenuKey highlights the menu title of the
menu that “owns” the hierarchical menu. Ownership in this case means the menu in the
menu bar that the user would first encounter on the way to the item with the given
Command-key equivalent. Because several levels of hierarchy are possible, this traversal
may not always be obvious to the user. As before, after performing the chosen task, your
application should call HiliteMenu(0) to remove the highlighting from the menu title.
Note:

The Command-key codes $1B (Control-[ ) through $1F (Control- _ ) are

reserved by Apple Computer to indicate meanings other than Command-key

equivalents. These key codes are ignored by MenuKey, and a result of zero is always
returned. Applications must never use these codes for their own use.
The global variable TheMenu contains the ID of the highlighted menu in the menu

bar. If an item from a hierarchical menu is chosen, TheMenu contains the ID of the
“owner” menu, not the ID of the hierarchical menu.

It’s possible, although undesirable, to define so-called “circular” hierarchical menus. A
circular hierarchical menu is one in which a submenu has an “ancestor” that is also one of
its “offspring”. If MenuKey detects circular hierarchical menus, a SysError = 86 =
#DSHMenuFndErr is generated.
PROCEDURE

HiliteMenu

(menuID:

INTEGER);

Previously, highlighting a menu title meant inverting the title rectangle, and dehighlighting

it meant reinverting

it, so that it returned to normal.

With color titles, color inversion is

usually aesthetically unacceptable, so there is a need to draw the highlighted menu title.

HiliteMenu begins by restoring the bits behind the currently highlighted title (if there is
one). It then saves the bits behind the title rectangle, and draws the highlighted title.
HiliteMenu(0) dehighlights the currently highlighted menu by restoring the bits behind the
title.
Note: Because an application can only save the bits behind the menu title, only one
menu title can be highlighted at a time.

—
ty

<@
|
|

<

a)
=
ee)
t=)
@

Lor |

Menu Manager Routines V-245

Inside Macintosh
PROCEDURE
PROCEDURE

DisableItem
(theMenu:
EnableItem
(theMenu:

MenuHandle;
item:
MenuHandle;
item:

INTEGER);
INTEGER);

The EnableItem and DisableItem routines provide enable flags that can handle the title and
31 menu items. All items greater than 31 will be ignored by these calls and will always be
enabled.
PROCEDURE

SetItemMark

(theMenu:

markChar:

MenuHandle;

item:

INTEGER;

CHAR);

The SetItemMark procedure allows the application to change the submenu associated with a
menu item.
PROCEDURE

GetItemMark

(theMenu:

markChar:

MenuHandle;

item:

INTEGER;

VAR

CHAR);

The GetItemMark procedure may be used to determine the ID of the hierarchical menu
associated with a menu item.
PROCEDURE

SetItemIcon

(theMenu:

MenuHandle;

item:

INTEGER;

icon:

Byte) ;

The SetItemIcon procedure should never be called for font items that are international
scripts, unless the intention is to change the script number (there should never be any need
to do this).

PROCEDURE

GetItemIcon

icon:

(theMenu:

MenuHandle;

item:

INTEGER;

VAR

Byte);

The GetItemIcon procedure may be used to determine the script number of a font item that
is the name of an international script.
FUNCTION

GetMHandle

(menuID:

INTEGER)

:

MenuHandle;

The GetMHandle routine looks for the menu in the hierarchical portion of the MenuList

first, and if it isn’t found, looks in the regular portion of the MenuList. The routine has no

way to determine whether the returned menu is associated with a menu, pop-up, or
hierarchical menu. Presumably the application will contain that information.
PROCEDURE

FlashMenuBar

(menuID:

INTEGER);

FlashMenuBar(0) still inverts the complete menu bar. Strange colors may result if
HiliteMenu, or FlashMenuBar with a nonzero parameter, are called while the menu bar is
inverted.

V-246 Menu Manager Routines

The Menu Manager
FlashMenuBar has been modified so that only one menu may be highlighted at a time (see
HiliteMenu). If no menu is currently highlighted, calling FlashMenuBar with a nonzero

parameter highlights that menu. If the highlighted menu is different than the one being

“flashed”, the previously highlighted menu is first restored to normal, and the new menu is
highlighted.
PROCEDURE

ClearMenuBar

(menuID:

INTEGER) ;

ClearMenuBar clears both the MenuList and the application’s menu color information table.
FUNCTION

GetNewMBar

(menuID:

INTEGER):

Handle;

GetNewMBar begins by calling ClearMenuBar, which clears both the MenuList and the
application’s menu color information table. Before returning the Handle to the new
MenuList, it restores the previous MenuList. It doesn’t restore the previous menu color
information table. If that is desired, the application must use GetMCInfo before calling
GetNewMBar, and call SetMCInfo afterwards.
PROCEDURE

GetItemStyle
(theMenu:
chStyle: Style);

MenuHandle;

item:

INTEGER;

VAR

There is a possible bug in this routine, depending on the interpretation of the address of the
VAR parameter chStyle. GetItemStyle assumes that the address on the stack points to a
word with chStyle in the low byte. MPW Pascal passes the byte address of chStyle
regardless of whether it’s in the high or low byte of a word. Since there has never been a
bug report for this “problem”, it is listed here for information only.

—

ww
<—
o
=
=
<2
—
=
=
SS
ge
©
="

Menu Manager Routines V-247

Inside Macintosh

THE STANDARD

MENU

DEFINITION PROCEDURE

This section describes changes made to the default menu definition procedure 'MDEF'

resource = (), for all Macintoshes except the 64K and 512K versions. The 'MDEF'
resource has been modified to ignore all undefined messages. Any custom 'MDEF' should
do the same. This allows Apple to define new messages (as described below for pop-up
menus) without impacting custom 'MDEF' resources. Apple recognizes that applications
may want to call their custom defprocs for information, and has reserved all messages

above and including 128 for application use. Apple’s defprocs will ignore all messages
above and including 128.

For the latest standard 'MDEF'’, the version number = 10. Version 10 and all later versions
include the features listed below.

For

hierarchical

menus:

w The triangular marker indicating that an item has a submenu appears in the location

where the Command-key equivalent is normally shown.

a The Command-key values $1B (Control-[ ) through $1F (Control-_ ) are reserved by

Apple to have meanings other than command keys.

For

scrolling

menus:

= When a menu is scrollable, scrolling indicators appear. If the menu scrolls up, a
triangular indicator appears in place of the last item in the list, and if the menu scrolls
down, an indicator appears in place of the first item in the list. The menu scrolls when
the cursor is moved into the area of the indicator, or is directly above or below the
menu.
For

pop-up

menus:

= A new message has been added to the standard 'MDEF' resource. Message #3, pop-up
menu placement, asks the defproc to calculate the menu rectangle of the pop-up menu.
Parameter
message

theMenu
menuRect

hitPt
whichItem

On Entry

Return

Value

3

menuHandle

Top left of PopupItem
PopupItem

Pop-up menu’s rectangle

Top of menu if menu scrolls

When a pop-up menu appears, the menu is adjusted on the screen so that the previously
selected item appears on top of the pop-up menu box. The previously selected item is
passed in the parameter whichItem, and the top left corner of the pop-up menu box is
passed in hitPt. On exit, the rectangle in which the pop-up menu is to appear is returned

V-248 The Standard Menu Definition Procedure

The Menu Manager
in menuRect. If the menu is so large that it scrolls, then the actual top of the menu is
returned in whichlItem.
ua When a defproc draws a pop-up menu, its scrolling information must be placed in the
global variables TopMenultem and AtMenuBottom.
For

color menus

(Macintosh

II only):

= When menu items are drawn, the background of the menu has already been erased to
the color specified for that menu in the menu color information table, or to white if
none is specified. When the mark, item, and Command-key equivalent fields are
drawn, the menu defproc checks the menu color information table for the colors to

use. If there is an item entry, those colors are used. If there is no item entry, then the
default from the title entry is used. If there is no title entry, then the default from the
menu bar entry is used. If there is no menu bar entry, then black on white is used.

= When an item is chosen, the background color and the item color are reversed, and the
item is redrawn in those colors. When an item is chosen, the background color and
item color are reset, and the item is redrawn in those colors.

= If your application uses the standard menu bar defproc to draw menu items into menus
after saving the bits behind and drawing the drop shadow, it must erase the menu’s
background to the correct color. If this isn’t done when the user has set default menu
colors, incorrect colors and unreadable items can result.

= Custom menu defprocs that use color items must provide the menu background color.

When the standard 'MBDF' clears the menu background and draws the drop shadow,

it clears the menu background to whatever color is specified in the menu color
information table. Custom menu defprocs should either (1) support color items by
accessing the menu color information table or (2) erase the background of the menu to
white before drawing color items.

All

menus:

= The menu defproc sets the global variable MenuDisable ($B54) each time a new item is
highlighted. After MenuSelect returns a zero, your application can query MenuDisable
directly, or use MenuChoice, to determine which menu ID and menu item were
chosen.
m The value returned by MenuChoice will be undefined if the last menu displayed has a
custom 'MDEF'. When including a custom 'MDEF' in your application, you should
consider supporting MenuChoice so that desk accessories providing on-line help for
the application will be able to support all its menus.
w Any application that uses the standard 'MDEF' to draw menu items must set the global
variable TopMenultem ($A0A). This variable is used by the standard 'MDEF' to

determine if scrolling is necessary. If TopMenultem isn’t set properly, scrolling might
occur when it shouldn’t. TopMenultem should contain global coordinates indicating
where the first item in the menu is to be drawn; typically this is the same as the top of
the menu rectangle. However, your application can use other coordinates if you don’t
want the first menu item to appear at the top of the menu rectangle.

=

Lo)

<

@
=
=

<

a)
=)
=

ge

@o

~*~

The Standard Menu Definition Procedure V-249

Inside Macintosh

THE STANDARD

MENU

BAR DEFINITION PROCEDURE

To give application writers more control over custom menus, a default menu bar definition
procedure has been added. This section describes the default menu bar definition procedure
(‘MBDF' resource = 0). On the Macintosh II, the menu bar defproc provides support for
color, pop-up, and hierarchical menus, as well as standard menus. This new defproc
supplements the existing standard 'MDEF' resource.
All menu drawing-related activities, previously included in the routines DrawMenuBar,
MenuSelect, MenuKey, HiliteMenu, and FlashMenuBar, have been removed from the

menu manager code, and placed in the menu bar defproc. Using the menu bar defproc with
the menu defproc gives the application writer complete control over the appearance and use
of menus.
An application that specifies its own menu bar defproc should call InitProcMenu instead of
InitMenus, which then loads the appropriate 'MBDF' resource.
There are currently 13 messages defined for the menu bar defproc:
Msg
0
1
2
3
4
5
6
7
8
9
10
11
12

#

Msg

Description

Draw
Hit

Draws the menu bar or clears the menu bar.
Tests to see if the mouse is in the menu bar or any currently
displayed menus.
Calc
Calculates the left edges of each menu title in the MenuList data
structure.
Init
Initializes any menu bar defproc data structures.
Dispos _ Disposes of any menu bar defproc data structures.
Hilite
Highlights the specified menu title, or inverts the whole menu bar.
Height
Returns the menu bar height.
Save
Saves the bits behind a menu and draws the menu structure.
Restor
Restores the bits behind a menu.
Rect
Calculates the rectangle of a menu.
SaveAlt
Saves more information about a menu after it has been drawn.
ResetAlt
Resets information about a menu.
MenuRgn Returns a region for the menu bar.

Custom 'MBDF' defprocs should ignore messages that are not currently defined in this
documentation. Messages numbered 128 and above are reserved for custom defprocs.
You may choose any name you wish for the menu bar defproc. The following example
declares a menu bar defproc named MyMenuBar:

V-250 The Standard Menu Bar Definition Procedure

The Menu Manager
FUNCTION

MyMenuBar
( selector:
message:
INTEGER;
parameterl:
INTEGER:
parameter2:
LONGINT):

Parameters

for

Menu

Bar

INTEGER;

LONGINT;

Defproc

Messages

This section lists the parameters for each message. Note that the menu bar defproc draws
directly into the window manager port, or color window manager port if there is one. Any
time the menu bar defproc draws in the Window Manager port (or color port) it clips the
port to full open before it returns. Full open is defined to be the portRect of the Window
Manager, or the color Window Manager port. The exception to this rule is that the Draw
message leaves the Window Manager port (or color port) clipped to the menu bar when
parameter2 =—1. See the individual message descriptions for more information.

Message #0: Draw:
Called

By

Selector

Parameterl

Parameter2

Result

Window Manager
DrawMenuBar

mbVariant

none

—1 =clear bar
0 = draw bar

none

When parameter2 = 0 (zero), the menu bar is cleared to the proper color, the titles are
drawn, and the window manager port clip region is set to full open. After all of the titles
are drawn, if one of the titles is currently selected (its menulD is contained in the global
variable TheMenu ($A26)), then the title is highlighted.

= 0.

DrawMenuBar passes parameter2

When parameter2 = —1 the menu bar is cleared to the proper color, no titles are drawn, and
the Window Manger port clip region is set to the menu bar. The Window Manager passes
parameter2 = —1.
Message

#1:

Hit

Called

By

Selector

Parameterl

Parameter2

Result

FindWindow

mbVariant

none

mouse pt

0 = in bar, no
title hit
—1 = not in bar
<pos> =
six-byte offset

MenuSelect

The mouse point to be tested for its location is passed in parameter2.
checks to see whether the mouse point is in the menu bar.

First this message

If it is in the menu bar, then the

message further checks whether the mouse is in any menu title. If the mouse is in the menu
bar but not in a title, the result is 0. If the mouse is in a title, the result is the offset of the

title in the menuList. The notation <pos> refers to a result which is a positive value (greater
than zero). A six-byte offset refers to the offset of a menu in the menuList data structure.

—

ee)

©
=
=

<—
o>
=
2
Te
©

Loew |

The Standard Menu Bar Definition Procedure V-251

Inside Macintosh

If the mouse is not in the menu bar, this message tests whether mouse point is in any

currently visible menu.

If more than one menu is visible—that is, one or more hierarchical

menus are visible—the message searches through those menus backwards, checking the
topmost hierarchical menu first. If the mouse pcint is found to be in a currently visible

menu, the result is the six-byte offset of that menu in the menuList.
Message #2:
Called

Calc

By

Selector

Parameter!

Parameter2

Result

InsertMenu
DeleteMenu

mbVariant

none

0 =all
<pos> = six-byte
offset

none

This message calculates the lastRight and menuLeft fields in the menuList.

If parameter2 =

O then the calculation is done for all of the menus. If parameter2 = the offset of a title in the
menuList, then the calculation begins with that menu and continues for all following
menus. A six-byte offset refers to the offset of a menu in the menuList data structure. The
notation <pos> refers to a result which is a positive value (greater than zero).
Message

#3:

Called

By

Init

InitMenus
InitProcMenu

Selector

Parameterl

Parameter2

Result

mbVariant

none

none

none

This message creates a data structure in the system heap the first time it is called after
System startup. It clears the field lastMBSave in that data structure at every call thereafter.

This message is called by InitProcMenu if the MenuList data structure hasn’t been
allocated. Applications that switch menu defprocs on the fly, and call InitProcMenu to do
so, will need to call the 'MBDF' with the “Init” message to execute this message.
Message

#4:

Called

By

Dispose

—

Selector

Parameterl

Parameter2

Result

mbVariant

none

none

none

Currently, this message does nothing.
Message

#5:

Hilite

Called

By

Selector

Parameter!

Parameter2

MenuSelect
HiliteMenu

Result

mbVariant

none

<packed>

none

FlashMenuBar

V-252 The Standard Menu Bar Definition Procedure

The Menu Manager
Parameter2 contains a packed value: the high word contains the highlight state desired, and
the low word contains the menu to be highlighted, which is its six-byte offset in the
menuList. The <packed> notation refers to the following: high word 0 = normal, high
word 1 = selected, low word 0 = flipbar. A highlight state of 1 (one) means the title is to be
selected, and a highlight state of 0 (zero) means that the title is to be returned to normal.
When a menu is selected, the bits behind the title are saved. Next, the color of the title and
the color of the menu bar are reversed, and the title is redrawn in these reversed colors.

Reversing the colors simply means setting the background color to the title color and the
foreground color to the menu bar color. This is necessary because merely inverting the title
rectangle with a call to InvertRect, as was done on previous machines, often produces
unpleasing and/or unreadable results.
When a menu is deselected—that is, the highlight state is 0 (zero)—the bits behind the title
are restored. If there was not enough memory to save the bits behind the title,
DrawMenuBar is called to redraw the whole menu bar.
If the low word of parameter2 is zero, the whole menu bar is inverted. FlashMenuBar uses
this feature.
Message

#6:

Height

Called

By

Selector

Parameterl

Parameter2

Result

Window Manager

mbVariant

none

none

none

This calculates the menu. bar height by looking at the size of the system font, and stores that
value in the global variable MBarHeight ($BAA). Note that the Window Manager assumes
that the menu bar is at the top of the screen.
Message

#7:

Save

Called

By

Selector

Parameterl

Parameter2

Result

MenuSelect
PopUpMenuSelect

mbVariant

_six-byte offset

menuRect

none

Parameter2 is the rectangle into which the menu is to be drawn. Parameter] is the offset
into the menuList of the menu to be drawn. A six-byte offset refers to the offset of the
menu into the menuList data structure. First the bits behind the menu are saved. Next the
menu rectangle is erased to the proper background color, and the menu structure (i.e.,
shadow) is drawn. Finally, various information about the menu is stored in the menu bar
defproc’s data structure.

—

i)
7)
~
c

<=

=
i)
ga
@

ce

The Standard Menu Bar Definition Procedure V-253

Inside Macintosh

Message

#8:

Restore

Called

By

Selector

Parameterl

Parameter2

Result

MenuSelect
PopUpMenuSelect

mbVariant

none

none

none

No parameters are passed; the assumption is that the last displayed menu will always be the
first one restored. If there was not enough memory to save the bits behind the menu, an
update event is generated for the menu rectangle.
Message

#9:

GetRect

Called

By

Selector

Parameterl

Parameter2

Result

MenuSelect
PopUpMenuSelect

mbVariant

none

<packed2>

menuRect

Parameter2 contains the offset into the menuList data structure for the menu whose

rectangle is to be calculated, as well as information about whether this is for a regular menu
or a hierarchical menu. The <packed2> notation refers to the following: high word 0 =
regular menu, high word nonzero = mouse pt/hierarchical menu, low-word = six-byte
offset of a menu in the MenuList. If the menu is currently showing on the screen, then its

rectangle need not be recalculated, since it is stored in the menu bar defproc’s data
structure.

If the menu is not currently showing on the screen, the rectangle is calculated. If it is the
first menu up, the menu drops from the menu bar. If it is a hierarchical menu, an attempt is

made to line up the top of the hierarchical menu with the item that is the “parent” of this
submenu.

Message

#10:

SaveAlt

Called

By

Selector

Parameterl

Parameter2

Result

MenuSelect
PopUpMenuSelect

mbVariant

none

six-byte offset

none

This message is called after message #7 (Save) has been executed and the menu defproc

has been called to draw the menu items. It currently saves data about the menu’s scrolling
position. A six-byte offset refers to the offset of the menu into the menuList data structure.
Message

#11:

ResetAlt

Called

By

Selector

Parameterl

Parameter2

Result

MenuSelect
PopUpMenuSelect

mbVariant

none

six-byte offset

none

V-254 The Standard Menu Bar Definition Procedure

The Menu Manager
This message is currently used to restore the global variables TopMenultem ($A0A) and
AtMenuBottom ($A0C) for the menu where the mouse is currently located. When a
hierarchical menu is drawn, its scrolling information will be in the global variables

TopMenu Item and AtMenuBottom. For menu scrolling to work properly, the scrolling
information for the menu where the mouse is currently located must be in those global
variables. A six-byte offset refers to the offset of menu into the menuList data structure.
Message

#12:

Called

By

—

MenuRgn
Selector

Parameterl

Parameter2

Result

mbVariant

none

region handle

region handle

A handle to an empty region is passed in parameter2. The same handle is returned as the

result, and the region is the menu bar’s region.

The Standard Menu Bar Definition Procedure V-255

Inside Macintosh

SUMMARY

OF THE MENU

MANAGER

Constants
CONST
hMenuCmd

=

$1B;

hierMenu

=

-l;

hPopUpMsg
mctAlliItems
mctLastIDIndic

dsMBarNFnd

dsHMenuFindErr

Data

Types

TYPE

MCEntryPtr

MCEntry

=
=
=

=
=

=

=

3;

{itemCmd
== $1B ==> hierarchical menu
}
{ attached to this item}
{for use as “beforeID" with InsertMenu}

{pop-up

menu

{ pop-up

menu}

{SysErr

code

{SysErr

code

{

-98;
-99;

85;

86;

calculate

{for use as
{last color

placement,

the

menu

asks

rectangle

the

defproc

of

the

to

}

}

a "menuItem"
with DelMCEntries}
table entry has this in ID field}

indicating

{

by

InitProcMenu

{
{

hierarchical
MenuKey. }

and

indicating
menus

MBDF

not

found.

InitMenu}

recursive

defined.

Used

}

by

Used

}

}

*“MCEntry;

RECORD
mctID:

INTEGER;

mctItem:

INTEGER;

mctRGB1:

RGBColor;

mctRGB2:

RGBColor;

mctRGB3:

RGBColor;

mct RGB4:

RGBColor;

mctReserved:

INTEGER;

END;
MCTable

=

ARRAY

[0..0]

MCTablePtr
MCTableHandle

=
=

“MCTable;
*MCTablePtr;

V-256 Summary of the Menu Manager

of

{menu ID.
ID
{ menu bar}
{menu entry.
{ a title}

=

0

is

the

Item

=

0

}
is

}

{usage

depends

on

ID

and

}

{usage

depends

on

ID

and

}

{

Item}

{ Item}
{usage depends on ID and
{ Item}
{usage depends on ID and
{ Item}
{reserved for internal
}
{ use}

MCEntry;

{the menu entries are
{ represented in this
{

array}

}
}

}
}

The Menu Manager
Routines
PROCEDURE
PROCEDURE
FUNCTION
PROCEDURE
PROCEDURE
FUNCTION
FUNCTION
PROCEDURE

InitProcMenu
DelMCEntries
GetMCInfo:
SetMCInfo
DispMCInfo
GetMCEntry
MenuChoice:
SetMCEntries

PROCEDURE

GetItemCmd

PROCEDURE

SetItemCmd

FUNCTION

PopUpMenuSelect

Global

(mbResID:
INTEGER) ;
(menulID,
menuItem:
INTEGER) ;
MCTableHandle;
(menuCTbl:
MCTableHandle) ;
(menuCTbl:
MCTableHandle) ;
(menuID,
menuItem:
INTEGER):
MCEntryPtr;
LONGINT;
(numEntries:
INTEGER;
menuCEntries:
MCTablePtr) ;
(theMenu:MenuHandle;
item:INTEGER;
VAR
cmdChar:
CHAR);
(theMenu:MenuHandle;
item: INTEGER;
cmdChar:

CHAR);

(theMenu:
MenuHandle;
PopupiItem:
INTEGER;)

Top,
Left,
LONGINT;

Variables

MBarHeight

ns

MenuClInfo
MenuDisable

Contains handle to the menu color information table.
Contains the menu ID for last menu item chosen, whether or not
it’s disabled.
Contains the ID of the highlighted menu in the menu bar.
Contains information on top menu item for menu scrolling.
Contains information on bottom menu item for menu scrolling.

ont.

TheMenu
TopMenultem
AtMenuBottom

Assembly-Language
Menu

Color

Information

Information

mctID
mctiItem

EQU
EQU

$0
$2

mctReserved
mctEntrySize

EQU
EQU

Sic
S1E

mctRGB1
mctRGB2
mctRGB3
mctRGB4

EQU
EQU
EQU
EQU

menu bar height derived from the size of the system

Table

Structure

$4
SA
$10
$16

—

oe)

=
Ss

—_

=

=
=

ee

=

tr)
fc)
a

Summary of the Menu Manager V-257

Inside Macintosh

Miscellaneous
HMenuCmd

EQU

$1B

;itemCmd

ScriptMenuCmd

EQU

$1C

;itemCmd

AltMenuCmdl

EQU

AltMenuCmd2

this

;

$1B

==>

hierarchical

==

$1C

==>

item

for

future

==>

unused

indicator

==>

unused

indicator

item

$1D

font
== $1D

EQU

$1E

;itemCmd

==

AltMenuCmd3

EQU

S1F

hierMenu

EQU

-1l

hPopUpMsg

EQU

3

table

mctAlliItems

search

mctLastIDIndic

Global

EQU

EQU

reserved

;

$1E

displayed

be

to

for

menu

==

; script
;itemCmd

Color

menus

for hierarchical

equates

in

use

Apple

; reserved for future Apple use
;itemCmd == $1F ==> unused indicator

; reserved for future Apple use
when
hierMenu),
;InsertMenu(handle,
the handle is
; beforeID ==hierMenu,
; inserted in the hierarchical menuList

;pop-up menu placement,
asks the defproc to
; calculate the menu rectangle of the pop-up
; menu

messages
-98

;search

-99

;last
;

for

all

entry

in

field

items

color

for

table

the

has

given

ID

this

in

Variables

MBarHeight

EQU

SBAA-

MenuCIinfo
MenuDisable

EQU
EQU

S$0D50
$0B54

TheMenu

EQU

SA26

TopMenuItem

EQU

SA0OA_

AtMenuBottom

EQU

SA0C

;contains menu bar height derived from the
; size of the system font
;handle to menu color information table
;contains the menu ID for last menu item
; chosen,
whether or not it's disabled

;contains
;

in

the

;pixel

;pixel

V-258 Summary of the Menu Manager

the

menu

value
value

ID

of

the

top

of

bar

of

of

bottom

highlighted

scrollable

of

menu

menu

scrollable

menu

ID

—

che.
—

om

*%

-

eo

a

oe

14
260
260
260
261
262
263
264
265
265
267
267
271

TEXTEDIT
About This Chapter
Data Structures
The Edit Record
The Style Record
The Style Table
The Line-Height Table
The Null-Style Record
Text Styles
The Style Scrap
Cutting and Pasting
TextEdit Routines
Summary of TextEdit

V-259

Inside Macintosh

ABOUT THIS CHAPTER
This chapter describes the enhanced version of TextEdit for the Macintosh Plus, the

Macintosh SE and Macintosh II. The new TextEdit routines allow text attributes such as
font, size, style, and color to vary from one character to another. The changes are
backward compatible with earlier Macintosh versions: all existing programs using TextEdit
routines should still work. TextEdit is also fully compatible with the Script Manager.

DATA STRUCTURES
The structure and size of the edit record are unchanged, but a few of its fields are
interpreted in different ways. All records have a 32K maximum size. A new data structure,
the style record, has been introduced to carry the style information for the edit record’s text,
along with various subsidiary data structures: the style run, the style table and its style
elements, the line-height table and its line-height elements, and the null-style record. In
addition, there is the text style record for passing style information to and from TextEdit
routines, and the style scrap record for writing style information to the desk scrap.
The

Edit

Record

Most fields of the edit record have the same meanings as in the old TextEdit, with the
following exceptions:
txSize

Used as a flag telling whether the edit record has style
information associated with it:

>0

Old-style edit record; all text set in a single font, size,
and face; all fields (including txSize itself) have their
old, natural meanings.

—|

Edit record has associated style information; the

txFont and txFace fields have new meanings as

described below.

txFont, txFace

Combine to hold a handle to the associated style

record (see “The Style Record” below).

Use new

routines GetStylHandle and SetStylHandle to access
or change this handle in Pascal.

lineHeight
fontAscent
>0

Controls whether vertical spacing is fixed or may vary
from line to line, depending on specific text styles:
Fixed line height or font ascent, as before.

V-260 Data Structures

—

Ss

=

@
ras
om.

TextEdit
—1

Line height or font ascent calculated independently for
each line, based on maximum value for any individual
style on that line.

The new routine TEStylNew, which creates a new edit record with style information, sets

txSize, lineHeight, and fontAscent to —1, allocates a style record, and stores a handle to the

style record in the txFont and txFace fields. The old routine TENew still creates a new edit
record without style information, initializing these fields from the current graphics port as
before.

The

Style

Record

The style record, located via a handle kept in the txFont and txFace fields of the edit

record, specifies the styles for the edit record’s text. The text is divided into runs of
consecutive characters in the same style, summarized in a table in the runs field of the style
record. Each entry in this table gives the starting character position of a run and an index
into the style table (described in the next section). The length of the run is found by
subtracting its start position from that of the next entry in the table. A dummy entry at the
end of the table delimits the length of the last run; its start position is equal to the overall
number of characters in the text, plus 1.
TYPE
TEStyleHandle = *“TEStylePtr;
TEStylePtr
= “TEStyleRec;
TEStyleRec
= RECORD
nRuns:

INTEGER;

nStyles:

INTEGER;

styleTab:
lhTab:

STHandle;
LHHandle;

teRefCon:

LONGINT;

nullStyle:

nullSTHandle;

runs:

ARRAY

[0..0]

{number

of

style

{number
{

styles

of

{

style

table}

runs}

distinct

stored

in

}

}

{handle to style table}
{handle to line-height
{ table}
{reserved for }
{ application use}
{handle

to

style

set

}

}

{ at null selection}
OF StyleRun

END;

StyleRun

=

RECORD

startChar:

styleIndex:

INTEGER;

INTEGER

{starting
{index

in

character
style

position}

table}

END;

Data Structures V-261

le]
ce.
=:

Inside Macintosh

Field

descriptions

nRuns

The nRuns field specifies the number of style runs in the text.

nStyles

The nStyles field contains the number of distinct styles used in the
text; this forms the size of the style table.

styleTab

The StyleTab field contains a handle to the style table (see “The Style

IhTab

The lhTab field contains a handle to the line-height table (see “The

teRefCon

The teRefCon field is a reference constant for use by applications.

nullStyle

The nullStyle field contains a handle to a data structure used to store
the style information for a null selection.

runs

The runs field contains an indefinite-length array of style runs.

The

Table” below).

Line-Height Table” below).

Style Table

The style table contains one entry for each distinct style used in an edit record’s text. The
size of the table is given by the nStyles field of the style record. There is no duplication;
each style appears exactly once in the table. A reference count tells how many times each
style is used within the text.
TYPE
STHandle

=

STPtr
=
TEStyleTable=
STElement

=

“STPtr;

“TEStyleTable;
ARRAY
[0..0]
OF

STElement;

RECORD

stCount:

INTEGER;

stHeight:

INTEGER;

stFont:
stFace:
stSize:

INTEGER;
Style;
INTEGER;

stAscent:

stColor:
END

V-262 Data Structures

;

;

INTEGER;

RGBColor

{number of runs
{ this style}

{line
{font

in

}

height}

ascent}

{font
(family) number}
{character style}
{size in points}
{absolute

(RGB)

color}

TextEdit

Field

descriptions

stCount

The stCount field contains a reference count of character runs using
this style.

stHeight

The stHeight field contains the line height for this style, in points.

stAscent

The stAscent field contains the font ascent for this style, in points.

stFont

The stFont field is the font (family) number.

stFace

The stFace field is the character style (bold, italic, and so forth).

stSize

The stSize field is the text size in points.

stColor

The stColor field is the RGB color; see Chapter 6, “The Color

The

Manager’, for further information.

Line-Height

Table

The line-height table holds vertical spacing information for an edit record’s text. This table
parallels the lineStarts table in the edit record itself. Its length is given by the edit record’s
nLines field plus 1 for a dummy entry at the end, just as the line starts array ends with a
dummy entry that has the same value as the length of the text. The table’s contents are
recalculated whenever the line starts themselves are recalculated with TECalText, or
whenever an editing action causes recalibration.

The line-height table is used only if the lineHeight and fontAscent fields in the edit record
are negative; positive values in those fields specify fixed vertical spacing, overriding the
information in the table.
TYPE

LHHandle

=

LHPtr

=

LHTable

=

LHElement =

“LHPtr;
“LHTable;

ARRAY

[0..0]

OF

LHElement;

RECORD

lhHeight:

INTEGER;

{maximum

height

in

line}

lhAscent:
END;

INTEGER

{maximum

ascent

in

line}

Data Structures V-263

Inside Macintosh

Field

descriptions

lhHeight

The lhHeight field contains the line height in points; this is the
maximum value for any individual style in a line.

lhAscent

The lhAscent field contains the font ascent in points; this is the

maximum value for any individual style in a line.

If you want, you can override TextEdit’s line-height calculation and store your own height
and ascent values into the line-height table. Any table entry with the high bit set in the
lhHeight field will be used as-is (both height and ascent), overriding whatever values
TextEdit would have used. The high bit of IhHeight is masked out to arrive at the true line
height, but the high bit of IhAscent is not masked, so you should never set it; the one in
IhHeight serves as a flag for both fields. Notice that you can selectively set some lines for
yourself and let TextEdit do the rest for you. This technique is intended to be used for

Static, unchanging text, such as in text boxes; if you use it on text that can change
dynamically, be sure to readjust your line-height values whenever the line breaks in the text
are recalculated. Otherwise, if new lines are created as a result of a text insertion, their line
heights and ascents will be computed by TextEdit.

The

Null-Style

Record

The null-style record is used to store the style information for a null selection. If
TESetStyle is called when setStart equals setEnd, the input style information is stored in the
nullStyle handle. The nStyles field of nullScrap is set to 1, and the style information is
stored as the ScrpSTElement. If text is then entered (pasted, inserted, or typed), the style is
entered into the runs array, and nStyles is reset to 0. The nStyles field is also reset if the
selection offsets are changed (by TEClick, for example).
TYPE
NullSTHandle=
“NullSTPtr;
NullSTPtr
= “NullSTRec;
NullSTRec = RECORD
TEReserved: LONGINT;
nullScrap:
END;

V-264 Data Structures

STScrpHandle

{reserved

for

{ expansion}

{handle to
{ table}

future

scrap

style

}
}

—

rs
=
©
*
-

TextEdit

Field

descriptions

teReserved

The teReserved field is reserved for future expansion.

nullScrap

The nullScrap field contains a handle to the scrap style table.

Text

Styles

Text style records are used for communicating style information between the application
program and the TextEdit routines. They carry the same information as the STElement
records in the style table, but without the reference count, line height, and font ascent:
TYPE

TextStyle=

RECORD
tsFont:

tsFace:
tsSize:

tsColor:

INTEGER;

{Font

RGBColor

{Absolute

Style;
INTEGER;

(family)

number}

{Character style}
{Size in points}
(RGB)

color}

END;

Field

descriptions

tsFont

The tsFont field is the font (family) number.

tsFace

The tsFace field is the character style (bold, italic, and so forth).

tsSize

The tsSize field is the text size in points.

tsColor

The tsColor field contains the RGB color; see Chapter 6, “The Color

The

Manager”, for further information.

Style Scrap

A new scrap type, ‘styl’, is used for storing style information in the desk scrap along with
the old "TEXT' scrap. The format of the style scrap is defined by a style scrap record:
TYPE
StScrpHandle=
StScrpPtr
=
StScrpRec
=

“StScrpPtr;
“StScrpRec;
RECORD

scrpNStyles:

INTEGER;

scrpStyleTab:

ScrpSTTable

END;

{number

of

distinct

{ styles in scrap}
{table of styles for
{ scrap}

}
}

Data Structures V-265

co)

a

=

Inside Macintosh

Field

descriptions

scrpNStyles

The scrpNStyles field is the number of distinct styles used in text,
this forms the size of the style table.

scrpSTTable

The scrpSTTable is the table of text styles: see the data structure
shown below.

Unlike the main style table for an edit record, the table in the style scrap may contain
duplicate elements; the entries in the table correspond one-to-one with the character runs in

the text. The scrpStartChar field of each entry gives the starting character position for the

run.

The ScrpSTTable is a separate data structure defined for style records in the scrap. Its
format is:
TYPE

ScrpSTTable

=

array

[0..0]

of

ScrpSTElement = RECORD
scrpStartChar:

scrpHeight :
scrpAscent:

scrpFont:
scrpFace:

scrpSize:
scrpColor:

END;

Field

ScrpSTElement;
LONGINT;

INTEGER;
INTEGER;

INTEGER;
Style;

INTEGER;
RGBColor;

{offset

to

start

{ style}
{line height}
{font ascent}

}

{font
(family)
number}
{character style}

{size in points}
{absolute
(RGB) color}

descriptions

scrpStartChar The scrpStartChar field is the offset to the beginning of a style
record in the scrap.
scrpHeight

The scrpHeight field contains the line height.

scrpAscent

The scrpAscent field contains the font ascent.

scrpFont

The scrpFont is the font’s family number.

scrpFace

The scrpFace is the character style for the style scrap.

scrpSize

The scrpSize field contains the size in points.

scrpColor

The scrpColor field contains the RGB color for the style scrap.

V-266 Data Structures

of

—_
ie

oe,

ie)
*
a

TextEdit

CUTTING

AND

PASTING

For new TextEdit records created using TEStylNew, the routines TECut and TECopy will
write both the text and its associated style information directly to the desk scrap, under
scrap types "TEXT" and 'styl', respectively. (For compatibility with existing applications,
they also write a handle to the text to the old global TEScrapHandle.) For old TextEdit
records, TECopy and TEPaste will work as they did before, copying and pasting via the
private TextEdit scrap only.
A new routine, TEStylPaste, reads both text and style back from the desk scrap and pastes
them into the document at the current selection range or insertion point. The old TEPaste
reads the text only, ignoring any style information found in the scrap; instead it uses the
style of the first character in the selection range being replaced, or that of the preceding
character if the selection is an insertion point. (TEStylPaste defaults to the same behavior if
it doesn’t find a 'styl' entry in the desk scrap.) The old routines TEFromScrap and
TEToScrap, for transferring text between the desk and internal scraps, are no longer
needed, but are still supported for backward compatibility. The GetStylScrap and
TEStylInsert routines can now be used to access the text and style information associated
with a given selection without destroying the current contents of the desk scrap.

TEXTEDIT

ROUTINES

The Macintosh Plus, Macintosh SE, and Macintosh II versions of TextEdit support all
previous TextEdit routines, as well as the new routines described below.
Assembly-language note: All but two of the new routines share a single trap,
_TEDispatch ($A83D). The routines are distinguished by an integer routine selector
passed on the stack, after the last argument:
TEStylPaste
TESetStyle
TEReplaceStyle
TEGetStyle
GetStylHandle
SetStylHandle
GetStylScrap
TEStylInsert
TEGetPoint
TEGetHeight

0
1
2
3
4
5
6
f
8
9

The Pascal interface supplies the routine selectors automatically, as do the macros for
calling these routines from assembly language. The remaining two new TextEdit
routines have traps of their own: _TEStylNew ($A83E) and _TEGetOffset ($A83C).

TextEdit Routines V-267

—
ic)

Qa

—s

Inside Macintosh
FUNCTION

TEStylNew

(destRect,

Rect)

viewRect:

:

TEHandle;

The TEStylNew routine creates a new-style edit record with associated style information. It
initializes the new record’s txSize, lineHeight, and fontAscent fields to —1; allocates a style
record and stores a handle to it in the txFont and txFace fields.
PROCEDURE

(theHandle:

SetStylHandle

hTE:

TEStyleHandle;

TEHandle) ;

The SetStylHandle procedure sets an edit record’s style handle, stored in the txFont and
txFace fields. SetStylHandle has no effect on an old-style edit record. Applications should
always use SetStylHandle rather than manipulating the fields of the edit record directly.
FUNCTION

GetStylHandle

(hTE:

TEHandle)

:

TEStyleHandle;

The GetStylHandle function gets an edit record’s style handle, stored in the txFont and
txFace fields. GetStylHandle returns NIL when used with an old-style edit record.
Applications should always use this function rather than manipulating the fields of the edit
record directly.
FUNCTION

GetStylScrap

(hTE:

TEHandle)

:

StScrpHandle;

The GetStylScrap routine allocates a block of type StScrpRec and copies the style
information associated with the current selection into it. This is the same as TECopy,
except that no action is performed on the text, and the handle to the 'styl' scrap is output in

this case. Unlike TECopy, the StScrpRec is not copied to the desk scrap.

GetStylScrap will return a NIL value if called with an old style TEHandle, or if the
selection is NIL (stylStart equals stylEnd).
PROCEDURE

TEStylInsert

stScrpHandle;

(text:
hTE:

Ptr;

length:

TEHandle) ;

LONGINT;

hST:

The TEStylInsert procedure takes the specified text and inserts it just before the selection
range into the text indicated by hTE, redrawing the text as necessary. If hST is not NIL and
hTE is a TextEdit record created using TEStylNew, the style information indicated by hST
will also be inserted to correspond with the inserted text. When hST is NIL and/or hTE has
not been created using TEStylNew, there is no difference between this procedure and
TEInsert. TEStylInsert does not affect either the current selection range or the scrap.
FUNCTION

TEGetOffset

(pt:

Point;

hTE:

TEHandle)

:

INTEGER;

The TEGetOffset routine finds the character offset in an edit record’s text corresponding to
the given point. TEGetOffset works for both old-style and new-style edit records.

V-268 TextEdit Routines

—
i

oe
©
*
=
—_—

FUNCTION

TEGetPoint

(offset:

INTEGER;

hTE:

The TEGetPoint routine returns the point corresponding

TEHandle)

:

POINT;

to the given offset into the text.

The point returned is to the bottom (baseline) left of the character at the specified offset.

TEGetPoint works for both old- and new-style edit records.
FUNCTION

TEGetHeight

(endLine,

startLine:

LONGINT;

hTE:

TEHandle)

INTEGER;

The TEGetHeight routine returns the total height of all the lines in the text between and
including startLine and endLine. TEGetHeight works for both old- and new-style edit
records.
PROCEDURE

TEGetStyle

VAR

(offset:

INTEGER;

lineHeight,fontAscent:

VAR

theStyle:

INTEGER;

hTE:

TextStyle;

TEHandle);

The TEGetStyle procedure returns the style information, including line height and font
ascent, associated with a given character in an edit record’s text. For an old-style edit
record, it returns the record’s global text characteristics.
PROCEDURE

TEStylPaste

(hTE:

TEHandle) ;

The TESty]lPaste procedure pastes text from the desk scrap into the edit record’s text at the
current insertion point or replaces the current selection. The text is styled according to the
style information found in the desk scrap; if there is none, it is given the same style as the
first character of the replaced selection (or that of the preceding character if the selection is
an insertion point). In an old-style edit record, just the text is pasted without its
accompanying style.
PROCEDURE

TESetStyle

BOOLEAN;

(mode:

hTE:

INTEGER;

TEHandle);

newStyle:

TextStyle;

redraw:

The TESetStyle procedure sets the style of the current selection to that specified by
newStyle. (It has no effect on an old-style edit record.) The mode parameter controls
which style attributes to set; it may be any additive combination of the following constants:
CONST

Le

{set

font

doFace

doFont
=

2;

{set

character

(family)

doSize
doColor

=
=

4;
8;

{set
{set

type size}
color}

doAll

=

15;

{set

all

addSize

=

16;

{adjust

number}

style}

attributes}

type

size}

TextEdit Routines V-269

ws

jIp

TextEdit

Inside Macintosh

In the last case (addSize), the value of newStyle.tsSize is added to all type sizes within the
current selection instead of replacing them; this value may be either positive or negative. (If

present, addSize overrides doSize.)

the new style.
PROCEDURE

If redraw

= TRUE, the affected text will be redrawn in

TEReplaceStyle (mode: INTEGER; oldStyle,newStyle:
TextStyle; redraw: BOOLEAN; hTE: TEHandle);

The TEReplaceStyle procedure replaces the style specified by oldStyle with that given by
newStyle within the current selection.

(It has no effect on an old-style edit record.)

The

mode parameter takes the same values as TESetStyle (above), except that addSize has no
meaning here. All styles for which the combination of attributes designated by mode have
the values given by oldStyle are changed to have the corresponding values from newStyle
instead. Style changes are made directly to the style-table elements within the table itself.
If mode = doAll, newStyle simply replaces oldStyle outright.

V-270 TextEdit Routines

TextEdit

SUMMARY

OF TEXTEDIT

Constants
CONST
doFont
doFace

doSize
doColor
doAll
addSize

Data

=
=

1;
2;

=
=
=
=

{set
{set

4;
8;
15;
16;

font
(family)
number}
character
style}

{set type. size}
{set color}
{set all attributes}
{adjust type size}

Types

TYPE

TEStyleHandle =
TEStylePtr
=
TEStyleRec
=

“TEStylePtr;
“TEStyleRec;
RECORD
nRuns:
nStyles:
styleTab:
lhTab:

INTEGER;
INTEGER;
STHandle;
LHHandle;

{number of style runs}
{size of style table}
{handle to style table}
{handle to line-height

teRefCon:

LONGINT;

nullStyle:

nullSTHandle;

{reserved for }
{ application use}
{handle to style set

ARRAY

OF

StyleRun

{starting

character

runs:
END;
StyleRun

=

RECORD

SstartChar:

styleIndex:

END;

INTEGER;
INTEGER

STHandle
= “STPtr;
STPtr
= “TEStyleTable;
TEStyleTable = ARRAY
[0..0]
OF
STElement

=

[0..0]

{index

{ table}

{ null

in

style

selection}

}

at

position}

table}

STElement;

RECORD

stCount:
stHeight:
stAscent:
stFont:

stFace:

stSize:
stColor:

END;

INTEGER;
INTEGER;
INTEGER;
INTEGER;

{number of runs in this
{line height}
{font ascent}
{font
(family)
number}

INTEGER;
RGBColor

{size in points}
{absolute
(RGB)
color}

Style;

{character

style}

style}

Summary of TextEdit V-271

}

Inside Macintosh
LHHandle
LHPtr
LHTable

=
=
=

“LHPtr;
“LHTable;
ARRAY
[0..0]

LHElement

=

RECORD

lhHeight:

lhAscent:

OF

LHElement;

INTEGER;
INTEGER

{maximum

{maximum

height

in

ascent

line}

in

line}

END;

NullSTHandle=
NullSTPtr
=

*“NullSTPtr;
“NullSTRec;

NullSTRec

RECORD

=

TEReserved:

LONGINT;

nullScrap:

STScrpHandle

{reserved for future
}
{ expansion}
{handle to scrap style
{ table}

}

END;

TextStyle

=

RECORD
tsFont:

tsFace:

tsSize:
tsColor:

INTEGER;

{font

INTEGER;
RGBColor

{size in points}
{absolute
(RGB)
color}

Style;

(family)

number}

{character

style}

{number

of

distinct

of

styles

END;

StScrpHandle=
StScrpPtr
StScrpRec

=
=

“StScrpPtr;

“StScrpRec;
RECORD

scrpNStyles:

INTEGER;

scrpStyleTab:

ScrpSTTable

{

in

scrap}

{

scrap}

{table

styles
for

}

END;

ScrpSTTable

= ARRAY

ScrpSTElement = RECORD

[0..0]

OF

scrpSTElement;

scrpStartChar: LONGINT;
scrpHeight:
INTEGER;
scrpAscent:
scrpFont:
scrpFace:
scrpSize:
scrpColor:

END;

V-272 Summary of TextEdit

INTEGER;
INTEGER;
Style;
INTEGER;
RGBColor;

{offset to start
{line height}

of

style}

{font ascent}
{font
(family)
number}
{character
style}
{size in points}
{absolute
(RGB)
color}

}

TextEdit

Routines
FUNCTION
PROCEDURE
FUNCTION
FUNCTION
PROCEDURE

TEStylNew
SetStylHandle
GetStylHandle
GetStylScrap
TEStylInsert

(destRect, viewRect:
Rect)
(theHandle:
TEStyleHandle;

FUNCTION
FUNCTION
FUNCTION

TEGetOffset
TEGetPoint
TEGetHeight

(pt:

PROCEDURE

TEGetStyle

PROCEDURE
PROCEDURE

TEStylPaste
TESetStyle

PROCEDURE

TEReplaceStyle

fontBit

faceBit
sizeBit
clrBit
addSizeBit
teStylesH

style
EQU
EQU
EQU
EQU
EQU
EQU

TEHandle)

TEStyleHandle;

(hTE: TEHandle)
StScrpHandle;
(text: Ptr;
length:
LONGINT;
hST:

stScrpHandle;
Point;

hTE:

hTE:

TEHandle);

TEHandle)

INTEGER;

(offset:
INTEGER;
hTE: TEHandle)
:
(endLine,
startLine:
LONGINT;
hTE:
TEHandle)

Assembly-Language

Set/Replace

(hTE:

TEHandle;
hTE:
TEHandle) ;

POINT;

INTEGER;

(offset:
INTEGER;
VAR theStyle:
TextStyle;VAR lineHeight, fontAscent:
INTEGER;
hTE:
TEHandle);
(hTE:

TEHandle) ;

(mode:
INTEGER;
newStyle:
TextStyle;
redraw:
BOOLEAN;hTE:
TEHandle);
(mode:
INTEGER; oldStyle,newStyle:
TextStyle;redraw:
BOOLEAN;
hTE:
TEHandle);

Information

modes

0
1
2
3
4
teFont

;set
;set
;set

;set
;add

font

face

size
color
size mode

;replaces

teFont/teFace

Summary of TextEdit V-273

Inside Macintosh

Offsets

into TEStyleRec

nRuns

EQU

styleTab

EQU

nStyles
lhnTab

teRefCon
nullStyle
runs

0

; [integer]

4

; [STHandle]

EQU

2

EQU

8

EQU
EQU-

12
16

EQU

20

#

; [integer]

; [LHHandle]

jarray

of

startChar

EQU

0

styleIndex
stStartSize

EQU
EQU)

2
4

; [INTEGER]
; style
; [INTEGER]
;size of a

EQU
EQU

stFace

EQU

EQU
EQU

stSize
stColor
stRecSize

Offsets

EQU
EQU
EQU-

distinct

handle

handle

to

to

in

styleStarts

styles

distinct
line

heights

styles

to

style

set

array

at

null

offset

into

text

style index
styleStarts

entry

to

start

of

0
2

; [integer]
; [integer]

8

;(style]

4
6

; [integer]
; [integer]

10
12
18

# of
line

ascent
font

times this
height

style

is

used

face

; [integer]
size
; [RGBColor]
color
;size of a teStylesRec

into TextStyle

tsFont

EQU

tsSize

EQU

tsFace
tsColor

styleSize

Offsets

entries

STElement

stCount
stHeight
stAscent
stFont

of

styles

array

into

of

; [longint] reserved
; [nullSTHandle]
Handle
; selection

Offsets into StyleRun

Offsets

#

0

; [integer]

4

; [integer]

EQU

2

EQU

6

EQU

; [style]

font

face

; [RGBColor]

12

;size

of

a

size

color

StylRec

into StScrpRec

scrpNStyles
scrpStyleTab

EQU
EQU

0
2

V-274 Summary of TextEdit

;[integer]
# of styles
in scrap
;([ScrpSTTable]
start of scrap styles

array

TextEdit

Offsets

into

scrpSTElement

scrpStartChar
scrpHeight
scrpAscent
scrpFont
scrpFace
scrpSize
scrpColor

EQU
EQU
EQU
EQU
EQUEQU
EQU

0
4
6
8
10
12
14

;{longint]
char where this
;{[integer]
line height
;[integer]Jascent
; [integer] font
; [style]
face
; (integer]size
;{[RGBColor]
color

scrpRecSize

EQU

20

;size

of

a

scrap

style

starts

record

Summary of TextEdit V-275

7
—

15
278
278
Z19
283
283
283
284
286

THE

DIALOG

—

=

MANAGER

=
ae
g
3
6
i)@

About This Chapter
Color Dialog and Alert Resources
Color Dialog Item Lists
Using Color Dialogs and Alerts
Dialog Manager Routines
New Dialog Manager Routine
Modifications to Existing Routines
Summary of the Dialog Manager

Lew

V-277

|

Inside Macintosh

ABOUT THIS CHAPTER
This chapter describes the enhancements to the Dialog Manager for the Macintosh II. A
new Dialog Manager routine now provides color dialog and item support. The new
resource types 'dctb', 'actb', and ‘ictb', which are auxiliary data structures to 'DITL’,

‘ALRT’, and 'DLOG’, allow color dialog boxes and alert boxes to be stored as resources.

If the 'ALRT', 'DLOG'’, or 'DITL' resources are missing, the Dialog Manager will
gracefully return from the Alert, NoteAlert, CautionAlert, StopAlert, and GetNewDialog
calls.

COLOR

ALERT AND DIALOG

RESOURCES

You don’t have to call any new routines to create color alert or dialog boxes. Additional

resources of types 'actb’, ‘dctb', and ‘ictb' complement the existing 'ALRT', 'DLOG’, and
'DITL' resources, and provide all the information needed to color dialog windows,
controls, and text.

To create a dialog or alert box, the Dialog Manager needs the same information about the
box as the Window Manager needs when it creates a new window. The structure of dialog
color tables and alert color tables is similar to the window color table described in the
Window Manager chapter, as shown in Figure 1.

wCSeed (long word)

i

ctSize

(-—value is -1 for default window colors

yy

wCReserved

wy

(word)

wContentColor (word)
wFrameColor

(word)

WHiliteColor

> wTextColor
4

(word)

value is always 0

| Red (word)

Blue (word)

(word)

Red (word)

| Red (word)

| Green (word) | Blue (word)

(word)

Red (word)

Green (word) | Blue (word)

wTitleBarColor (word) | Red (word)

I

—— Partldentifier
value supplied by constants

(see Window

Green (word) |

Manager

chapter)

| Green (word) | Blue (word)

| Green (word) | Blue (word)

J

PartRGB
value supplied by application

Figure 1. Color Table for Dialogs and Alerts

The calls Alert, CautionAlert, StopAlert, and NoteAlert look for a resource of type ‘actb'
with the same resource ID as the alert. GetNewDialog looks for a resource of type ‘dctb'

V-278 Color Alert and Dialog Resources

The Dialog Manager
with the same resource ID as the dialog. These resources contain color tables identical to
the 'wctb' color tables described in the Window Manager GetNewCWindow call. If an
‘actb' or ‘dctb' resource is present, then the window created will be a cGrafPort, created
with a NewCWindow call. If the ctSize field of a ‘dctb' or 'actb' resource is —1, the default
window colors will be used.
To include a color icon in a dialog box, add a resource of type 'cicn' with the same
resource ID as an old-style icon. The Dialog Manager will then access the icon with the

~QuickDraw routine GetClIcon.

To include a version 2 picture in a dialog, create a color table for the dialog to cause the
dialog to use a cGrafPort. See the Color QuickDraw chapter for more information on the
use of color pictures.
To color controls in a dialog, or to change the color, style, font, or size of text within a
dialog, include an ‘ictb' resource as described in the following section.

Color table resources ‘actb' and 'dctb' are treated the same as 'ALRT"' resources and
‘DLOG' resources. The ‘ictb' resource is handled just like the 'DITL' resource. These
resources are preloaded and made nonpurgeable by CouldAlert and CouldDialog, and their
original purge state is restored by FreeAlert and FreeDialog.

COLOR

DIALOG

ITEM LISTS

This section discusses the contents of an item list after it’s been read into memory from a
resource file. If a resource of type ‘ictb' is present with the same resource ID as the 'DITL'
resource (in addition to the presence of the 'dctb' or 'actb' resources), then the statText,

editText, and control items in the dialog or alert boxes are drawn using the colors and text
styles indicated by the item color table record contained in the resource.
Note: Neither the display device nor the dialog box needs to be in color, but a
dialog or alert color table must exist to include an item color table (even if the item
color table only describes statText and editText style changes and has no actual color
information).

Color Dialog Item Lists V-279

—

nn

ad

=
ve

pe)
=
ee)
tj=)
@
Lewy

§

Inside Macintosh

Figure 2 shows how a dialog color table stores item color table records.
dctb

p
control
color
table

itemCData

(word)

itemCData

(word)

(one for each item)
ccSeed (long word)

ccReserved
_

—

(word)

|

ctSize(word)

cFrameColor

(word) | R (word)}G (word)|/B (word)

cBodyColor

(word) | R (word)|G (word)|B (word)

cTextColor

(word) | R (word)|G (word)|B (word)

cThumbColor

(word)|R (word)}G (word)|B (word)

ooo

text
style
record

itemCOffset (word)
itemCOffset (word)

diFont

(word)

diStyle (word)

—-

diSize

(word)

R (word)

G (word)

B (word)

- foreground

R (word)

G (word)

B (word)

-background

diMode (word)
(one for each text style )

fontName

af

(string)

(one for each font name)

‘i
j

Figure 2. Color Table for Dialogs and Alerts

The record starts with an array of two-word entries for each item in the matching dialog
item list. The first word (itemCData) is the length of the entry if the item is a control, or it is

a word of flags if the item is an editText or statText item. The second word (itemCOffset) is

an offset from the beginning of the record to the color item entry. This color record is used
only for controls and text; icons and pictures have a different method of describing
associated colors. Set the itemCData and itemCOffset fields to zero for controls or text
without colors or font changes.
If the item is an editText or statText item, the bits in the itemCData field determine which
fields of the text style record to use; these bit equates are listed in the following table.

V-280 Color Dialog Item Lists

The Dialog Manager
Bit

Meaning

—

Mm

0
1

Change the font family
Change the font face

2
3
4
13
14
15

Note:

=~
—

=
—
ge

Change the font size
Change the font forecolor
Add the font size
Change the font backcolor
Change the font mode
The font field is an offset to the name.

<—
5

=
eS)

5

io
“

Multiple text items can share the same font name.

The itemCData field for text items contains a superset of the flags passed as the mode word
to the TextEdit routine TESetStyle.

The constants defined for that routine include:

CONST

{

Constants
TEdoFont

for TextEdit and dialog boxes
= 1;
{set font
(family)

TEdoSize
TEdoColor

=
=

TEdoFace

TEdoA11
TEaddSize
{ Constants

= 2;
=
=

for

doBColor
=
doMode
=
doFontName =

{set

4;
8;

15;
16;
dialog

8192;
16384;
32768;

{set
{set

character

type size}
foreground

}
number}

style}

color}

{set all attributes}
{adjust type size}

boxes
{set
{set
{set

only

}

backgound color}
txMode}
txFont from name}

The text style record indicated by itemCOffset must be 20 bytes long, as shown in
Figure 2. Multiple statText and editText items can use the same text style record. To display
text in the standard font, color, size, and style, set the itemCData and itemCOffset to zero.

Allocate space for all fields in the style table, even if they are not used. Even if only the first
few items of the dialog box have color style information, there must be room for all of the
items actually in the box (with the data and offset words of the unused entries set to zero).
For controls, the colors are described by a color table identical to the contents of a 'cctb'
resource used by a GetNewCControl call. Multiple controls can use the same color table.

To display a control in the default colors, set the itemCData and itemCOffset fields to zero.

The length of the control color table should be the header size of eight bytes plus the eightbyte ColorSpec record for each entry in the color table.

The doFontName array is optional. However, it’s important to point to the name of the font
instead of just including the font number. Fonts may be renumbered by font installers like
the Font/DA Mover as the fonts are moved, so it is safest to rely on getting the right font by
referring to the name.

Color Dialog Item Lists V-281

Inside Macintosh
ctiltem + btnCtr
(items 1,2)

statText (item 8)

2.

iconitem (item 11)

7

Print the document

picitem (item 12)

rs

3 & 4) a
em (items
+ radCtr
ctrlit

Chita
+ chkCw diem 6)

8 Non
8 1/2"

(‘0K

# 11" paper
# 14" paper

&] Stop printing after each page

editText (iter 6)

na

statText (item 9)

Title:|

Annual

Report

useriltem (item 7)
statText (item

The radio buttons
and checkboxes

10)

Progress of printing

Colortablelength
ey

share the same

0000:[0040

Zeroed entry for

ae
0000
0020:(0009

color table.

useritemn.

The color table

0008:
0010:

0040
0040

0028:

0000

0030
0050
0050

0040

/

fromthebeginning

0040
AOOF

0050
of theictb.
0070—— TheeditText item

0000 | 0009
0084 0009

0084
0084

np
$70. The font family,

0000

0000

0000

size, style, fore-

0000

0000

0002

ground

0038:|0000

FFFF

0000

0000

ground colors are

0048:|

0002

0000

0000

FFFF

0060:
0068:

0001
0002

O000
FFFF

FFFF
0000

FFFF
FFFF

0000

0000

0000

7F7F\\

\ Changed.

61

=

0040:|0001

green body and
blue text.

0050:
0058:
0070:

0078:

0000
0000
0098

0000

FFrFF

0000
FFFF

0000
FFFF

0100

000C

The font is changed

0080: 0000
0088:[0000

0001 | 0001
0000
0000

font (1) and the

0098:

6562

foreground color is

0030/

buttons use the

same color table,
with a length of $40
and an offset of $30

0030:}0000

desrisacc pation

with a red frame, a

The OK and Cancel

Color table offset

0647

6576

0000]
0002|
0000]
7F7F

0000
7F7F
0001

set to dark blue.

and

back-

\ Changed.

Three statText items

(8.9and10)usethe
Samestylerecord
starting at $84, Only
the font family
number
and fore-

ground color are

The control color
table
used by the
radio buttons and
F

The text style record

used by the editText

Font name ("Geneva")

item: the font name

is at offset $98, the

style is bold, the size
is 12, the foreground
color is dark red, the
background color is
dark green.

Figure 3. Sample Dialog with Color Dialog Items

V-282 Color Dialog Item Lists

)

The Dialog Manager

USING COLOR

DIALOGS AND ALERTS

nr
_—

The dialog box shown in Figure 3 contains 12 different dialog items. Some of these
items—the OK and Cancel buttons, the radio buttons and the check box, and the editText
and statText items—contain color information. The table shown in the figure contains the

hexadecimal description of the dialog items. PicItems, iconItems, resCtrls and userItems
should have zeroed entries for both fields. All items in the dialog should have a field,
whether or not the item uses the new features.

Your application can create a dialog or alert, with color dialog items, within a resource file,

and then use the GetNewDialog routine with the dialog’s resource ID. You can also use the

NewCDialog routine to create a dialog or alert within an application, passing a handle to the
dialog’s item list.

MANAGER

ROUTINES

A new routine, NewCDialog, has been created, and several existing routines have been
modified for use with color.
New

Dialog

FUNCTION

Manager

Routine

NewCDialog
(dStorage:
Ptr; boundsRect:
Rect;
title:
Str255; visible:
BOOLEAN; procID:
INTEGER;
behind:
WindowPtr;
goAwayFlag:
BOOLEAN; refCon:
LONGINT;
items:
Handle)
:
CDialogPtr;

A new Dialog Manager routine has been added to support color dialogs: NewCDialog.

parameters are identical to NewDialog, except that a cGrafPort is allocated through a

=
S
ve
$9
=|
>
ge
©
=y

Note: The dialog box shown in Figure 3 is just a colored version of the original
sample dialog box given in Chapter 13 of Volume I (Figure 5). It does not illustrate
a standard printer dialog and does not conform to the current Macintosh user interface
guidelines set forth in Chapter 2.

DIALOG

o

Its

NewCwWindow call instead of a call to NewWindow.

NewCbDialog creates a dialog box as specified by its parameters and returns a cDialogPtr to
the new dialog. The first eight parameters (dStorage through refCon) are passed to the
Window Manager function NewCWindow, which creates the dialog window. The items
parameter is a handle to the dialog’s item list. You can get the items handle by calling the
Resource Manager to read the item list from the resource file into memory.
After calling NewCDialog, you can use SetWinColor to add a color table to the dialog. This
creates an auxiliary window record (auxWinRec) for the dialog window. You can access
this record with the GetAuxWin routine. The dialogCItem handle within the auxWinRec
points to the dialog item color table.

Dialog Manager Routines V-283

Inside Macintosh

If the dialog’s content color isn’t white, it’s a good idea to call NewCDialog with the
visible flag set to FALSE. After the color table and color item list are installed, use
ShowWindow to display the dialog if the dialog is the frontmost window. If the dialog is

not in front, use ShowHide to display the dialog.
Modifications
FUNCTION

to

Existing

GetNewDialog

Routines

(dialogID:

WindowPtr)

: DialogPtr;

INTEGER;

dStorage:

Ptr;

behind:

The GetNewDialog routine will attempt to load a 'dctb' resource and returns a pointer to a
color grafPort if the resource exists. If no 'dctb' resource is present, GetNewDialog returns
a pointer to an old grafPort.

The dialog color table is copied before it is passed to SetWinSize unless its ctSize field is
equal to —1, indicating that the default window colors are to be used instead. The copy is
made so that the color table resource can be purged without affecting the dialog.
The color dialog item list resource is duplicated as well, so it can be purgeable.
FUNCTION

Alert

(alertID:

INTEGER;

filterProc:

ProcPtr)

:

INTEGER;

The Alert function looks for a resource of type ‘actb' with the same ID as the alert. The

alert color table is copied before it is passed to SetWinSize unless its ctSize field is equal to

—1, indicating that the default window colors are to be used instead. The copy is made so
that the color table resource can be purged without affecting the alert.
The color dialog item list resource is duplicated as well, so it can be purgeable.
FUNCTION

FUNCTION

CautionAlert

StopAlert

(alertID:

INTEGER;

INTEGER;

(alertID:

filterProc:

ProcPtr)

INTEGER;

filterProc:

ProcPtr)

INTEGER;

filterProc:

ProcPtr)

INTEGER;

FUNCTION

NoteAlert

(alertID:
INTEGER;

The calls CautionAlert, StopAlert, and NoteAlert look for a resource of type 'actb' with the
same ID as the alert.

PROCEDURE

CouldDialog

(dialogID:

INTEGER) ;

The CouldDialog procedure makes the dialog color table template unpurgeable (reading it

into memory if it isn’t already there), if it exists. It does the same for the dialog’s color item
list, if it has one.

Warning: CouldDialog doesn’t load or make 'FONT' or 'FOND' resources
indicated in the color item list unpurgeable.

V-284 Dialog Manager Routines

The Dialog Manager
PROCEDURE

FreeDialog

(dialogID:

INTEGER);

—

Given the resource ID of a dialog template previously specified in a call to CouldDialog, the
FreeDialog routine undoes the effect of CouldDialog, by restoring the original purge state
of the color table and color item list resources.
PROCEDURE

CouldAlert

(alertID:

INTEGER) ;

it has one.

Warning: Like CouldDialog, CouldAlert doesn’t load or make 'FONT' or 'FOND'
resources indicated in the color item list unpurgeable.
FreeAlert

(alertID:

S

oy
=

re
>
=
$9
Ms)
co)
=

The CouldAlert routine makes the alert color table template unpurgeable (reading it into
memory if it isn’t already there), if it exists. It does the same for the alert’s color item list, if

PROCEDURE

uw

INTEGER);

Given the resource ID of an alert template previously specified in a call to CouldAlert, the
FreeAlert routine undoes the effect of CouldAlert, by restoring the original purge state of
the color table and color item list resources.

Dialog Manager Routines V-285

Inside Macintosh

SUMMARY

OF THE DIALOG

MANAGER

Constants
CONST

{

Constants

TEdoFont

for

TEdoFace
TEdoSize
TEdoColor
TEdoA11

=
=
=
=

TEaddSize

{ Constants

doBColor
doMode
doFontName

=-

=

for

=
=
=

TextEdit

and

dialog

{set
{set
{set
{set

character style}
type size}
foreground color}
all attributes}

1;

{set

16;

{adjust

2;
4;
§8;
15;

dialog

8192;
16384;
32768;

boxes

{set
{set
{set

boxes

font

only

(family)

type

}

number}

size}

}

background color}
txMode}
txFont from name}

Routines
FUNCTION

NewCDialog

(dStorage:
Ptr; boundsRect:
Rect; title:
Str255; visible:
BOOLEAN; procID:
INTEGER;
behind:
WindowPtr; goAwayFlag:
BOOLEAN;
refCon:

LONGINT;

CDialogPtr;

V-286 Summary of the Dialog Manager

items:

Handle)

16

THE

INTERNATIONAL

288
288

About the International Utilities Package
International Resources

290

Formatting Options

289

290
290
290
291
291
292

UTILITIES

PACKAGE

Using the Internacional Resources

a
=
=

Time Cycle
= Short Date Format
Long date Format
Suppress Day
Sorting Routines
Summary of the International Utilities Package

Comal
-_-

7)
i)

5
=
=
S
5
=

(=

=.

=i¢*]
~”

V-287

Inside Macintosh

ABOUT THE INTERNATIONAL

UTILITIES PACKAGE

The International Utilities Package has been extended to work in conjunction with the
Script Manager, described in this volume. In addition, several new formatting options
provide added flexibility in specifying exactly how dates and times are to be displayed. The
string comparison capabilities have also been extended to handle non-Roman writing
systems, such as Arabic and Japanese.
Reader’s guide: You need the information in this chapter if you are using one or more
of the following in your application:
= anon-Roman writing system
= non-English date or time formats
= routines that compare strings containing accented characters

INTERNATIONAL

RESOURCES

The 'INTL' resources with ID numbers 0 and 1 have been used in the past for international
formats. The Script Manager now allows multiple formats to be used with the same system
by adding multiple international script resources, as described in the Script Manager chapter
of this volume. The new international resources are of types 'itlO'", ‘itl1', ‘itl2', ‘itlb', and
‘itlc'. Each installed script has an associated list of international resource numbers,

generally in the range used for its fonts. For example, the Arabic script has the resources

‘1t10'" ‘itl1', and ‘itl2' with numbers in the range $4600 to $47FF; the Roman
resources ‘itlO'" 'itl1', and ‘itl2' with numbers in the range $2 to $3FFF.

script has the

In the default case, the resources used by the International Utilities package are determined
by the script designated for the system font. However, you can force them to be
determined by the font script (the script of the font in thePort), by clearing the IntlForce
flag to 0. You can set and clear the IntlForce flag by using the SetEnvirons routine

described in the Script Manager chapter of this volume. The selected resources will then be
used internally by the International Utilities package.

The ‘itl0' and ‘itll' resources basically correspond to the former 'INTL' 0 and 1; the ‘itl2'
resource contains new procedures for sorting, which are discussed below. The IUSetIntl
call described in the International Utilities chapter of Volume I still uses the 'INTL' 0 and 1
resources. [UGetIntl, however, uses the 'itl0', ‘itl1' and ‘itl2' resources.

For compatibility, the 'INTL' 0 and 1 resources are still present in the System file and
remain the same; an 'INTL' 2 has been added to correspond to the ‘itl2'. Applications can
access these resources by means of GetResource.
Note: The one exception to the correspondence between an ‘itl0' or ‘itl1' and
‘INTL’ 0 or INTL’ 1 is that the lengths of the former may be increased at some

V-288 International Resources

The International Utilities Package
future date: they are not guaranteed to remain the same length, although the positions
of the existing fields will not change.
The ‘itlb' resource is a script bundle resource that determines which keyboard and which
international formats are to be used. The ‘itlc' resource determines the system script.

Using

the

International

Resources

Note: Before using any of the international resources, or using the Binary to

Decimal routines, verify that the thePort and thePort’.txFont are set correctly, or that
the intlForce flag is on.
To make it easy to localize your application to different scripts and languages, use the
international utilities for Date/Time/Number formatting.When formatting numbers, use the
fields in the international resources to find out the decimal, thousands or list separators for
the given script.

os

a

—

=

a

@see
=
oe

=.
Sc

=

=

=
=
=

{Make

sure

myHandle

myDecimal

:=

the

:=

font

is

set

properly

intl0Hndl(IUGetInt1(0));
myHandle**.decimalPt;

myThousands
:= myHandle**.thousSep;
myList
:= myHandle**.listSep;

in

thePort,

then}

ig")

{don't

use

{as
{as

1,234,567 in English}
(3;4;5) in English}

{as

in

in
in

1.234

GetResource! }
in

English}

These three separators should always be distinct; they can be used for parsing.
Programs that do not support input of numbers with thousands separators may
want to override the list separator and use commas. The program should keep any
overriding characters in a resource, so they can be changed if necessary. Before
using the resource, it should first check to see that the decimal separator is not the
same.
When sorting a list of text items having different scripts, first sort the items by
script, producing sublists. Then within each sublist sort the text items, using the
International Utilities comparison routine described later in this chapter, with the

intlForce off and the font in thePort set to one of the fonts in the sublist.

Where performance is critical, such as when you are sorting very large amounts of
data in memory, it may be advantageous to use a straight ASCII comparison instead
of the International Utilities comparison routines. In this case, give the user a choice
of sorting style (quick versus accurate) in a preferences dialog. The stored default
setting can be determined when localizing the application.

International Resources V-289

2)

Inside Macintosh

FORMATTING

OPTIONS

New options are available for time cycle and dates.

Time

Cycle

A new constant value, zeroCycle, is provided for the timeCycle field in the IntlORec data
structure to allow specification of 0:00 AM/PM rather than 12:00 or 24:00.

Short

Date

Format

Three new constant values, MYD, DYM, YDM, for the dateOrder field in the IntlORec data
structure now allow the exact specification of the short date format, as follows:
Constant

Format

MYD
DYM
YDM

Month Year Day
Day Year Month
Year Day Month

Long

Date

Format

New values allow specification of the exact order of the elements in the long date format.

If the byte value of the IngDateFmt field in the Intll Rec data structure is neither 0 nor $FF,

then its value is divided into four fields of two bits each. The least significant bit field (bits
0 and 1) corresponds to the first element in the long date format, while the most significant
bit field (bits 6 and 7) specifies the last (fourth) element in the format.

Four new constants

(longDay, longWeek, longMonth, longYear) may be used to set each bit field to the
appropriate value.

For example, to specify the order day-of-week/day-of-month/month/year, you would set
the value of IngDateFmt to:
longWeek* 1
+ longDay*4
+ longMonth*16
+ long Year*64

{sets bits 0 and 1 to longWeek}
{sets bits 2 and 3 to longDay}
{sets bits 4 and 5 to longMonth}
{sets bits 6 and 7 to longYear}

V-290 Formatting Options

The International Utilities Package

Suppress

Day

New values are available for the suppressDay field in the Intl1Rec data structure to enable
suppression of any part of the date. If its value does not equal 0 or $FF, the field is treated
as a bitmap. The values supDay, supWeek, supMonth and sup Year may be used to set the
appropriate bits in the suppressDay byte. For example, to suppress both the month and the
year, the value of suppressDay would be: supMonth + sup Year.
—"

>

SORTING

=

ROUTINES

=a

<7)
Lew 4

=

The international sorting routines handle cases where letters are equal in primary
ordering but different in secondary ordering (e.g., ‘a’ and ‘a’). They also handle

cases where one character sorts as if it were two (e.g., “e’ as ‘ae’). The ‘itl2'’ resource has

been added to generalize the sorting process for non-Roman scripts.

This is the process that the International Utilities Package now uses to compare two strings:
w Starting with the first character, it fetches corresponding
strings and compares them.

characters from the two

w If the characters are identical, the comparison continues.

w If the characters are not identical, and if one or both is part of a secondary ordering
(e.g., ‘a’ and ‘a’), their primary characters are compared.
If the characters are not identical but their primary characters are equal, the comparison
continues.
w If neither the original characters nor their primary characters are equal, the comparison
ends and the ordering of the original characters is returned.
u If the foregoing comparison continues and one string ends before the other, then the
shorter string is less.
a If the comparison continues to the end of strings that are the same length and if the
strings contain no characters that are equal in primary ordering but different in
secondary ordering, then the strings are identical.
= If the comparison continues to the end of strings that are the same length and contain
one or more characters that are equal in primary ordering but different in secondary
ordering, then the first such pair of characters is compared by secondary ordering to
determine the final ordering.
Note: It is possible to create your own ordering routine, using hook routines
contained in the ‘itl2' resource. For guidance on doing this, contact Apple Technical
Support.

Sorting Routines V-29]

&

=.
o
=)

=

(‘=
=.

=i$")

i]

Inside Macintosh

SUMMARY

OF THE INTERNATIONAL

UTILITIES

Constants
zeroCycle

=

1;

{0:00

MYD
DYM
YDM

=
=
=

3;
4;
5;

{month,
day,
year}
{day,
year,
month}
{year,
day,
month}

longDay

=

=
=
=

0;

1;
2;
3;

{day

supDay
supWeek
supMonth
supYear

=
=
=
=

1;
2;
4;
8;

{suppress
{suppress
{suppress
{suppress

longWeek
longMonth
longYear

Assembly-Language

AM/PM

of

format}

the

month}

{day of the week}
{month of the year}
{year}
day of
day of
month}
year}

month}
week}

Information

zeroCycle

EQU

i

;use

0:00

MYD
DYM
YDM

EQU
EQU
EQU

3
4
5

;use
;use
;use

month,
year,
day
day,
year,
month
year,
day,
month

longDay
longWeek

EQU
EQU

0
uf

;day
;day

of
of

longYear

EQU

3

;year

longMonth
supDay
supWeek

supMonth
supYear

EQU
EQU
EQU

EQU
EQU

2

0
2

4
8

;month

AM/PM

month
week

of

year

;suppress
;suppress

day
day

;suppress
;suppress

V-292 Summary of the International Utilities

format

of
of

month
year

month
week

17

THE

SCRIPT

MANAGER

294
294
297
297
298
299
300

About This Chapter
About the Script Manager
Text Manipulation
Determining the Script in Use
Drawing and Measuring
__—s— Parsing
Character Codes

301
301
302
303

Writing Direction
Partitioning Text
Numeric Strings
Using the Script Manager

303
304
305
305
306
306
306
307
308
309
310
310
311
311
312
313
313.
314
314
314

Character Information
= Text Editin
Advanced
Routines
System Routines
Script Manager Routines
arByte
CharType
~—~Pixel2Char
Char2Pixel
FindWord
HiLiteText
DrawJust
MeasureJust
Transliterate
GetScript
= SetScript
GetEnvirons
SetEnvirons
~~ FontScript
—IntlScript

315
315
315
315
315
315
316
316
316
317
319

Font2Script
GetDefFontSize
GetSysFont
GetAppFont
GetMBarHleieht
GetSysJust
SetSysJust
Hints for Using the Script Manager
Testing for the Sorin Manaver
Setting the Keyboard Script
Summary of the Script Manager

300

303

314

Key-Down Event Handling

= Script Information

—

|

2)
OQ
tale
a=}f
=|
f9

ve
@
aw

KeyScript

V-293

|

Inside Macintosh

ABOUT

THIS CHAPTER

This chapter describes the Script Manager, a set of general text manipulation routines that
let applications function correctly with non-Roman writing systems such as Japanese and
Arabic, as well as Roman (or Latin-based) alphabets such as English, French, and

German. The Script Manager works with one or more Script Interface Systems, each of
which contains the rules for a specific method of writing.

Reader’s guide: Most applications do not need to call the Script Manager routines
directly, since they can handle text by means of TextEdit, which functions correctly
with the Script Manager. Applications that need to call the new routines are those
that directly manipulate text, such as word processors or programs that parse
ordinary language.

You should already be familiar with
= QuickDraw’s text manipulation functions
u the International Utilities package

a the Binary-Decimal Conversion package
It may also be helpful to have a general understanding of how the Font Manager provides
font support for QuickDraw and how TextEdit handles word selection and justification.
The process of adapting an application to different languages, called localization, is made
easier if certain principles are kept in mind when you create the application. For example,
you should place quoted strings in resources separate from program code, and you should
avoid implicit assumptions about the language that the application uses, such as the number
of characters in its alphabet. General guidelines for writing applications that are easy to
localize are presented in Human Interface Guidelines, available through the Apple
Programmers and Developers Association (APDA).

“Compatibility Guidelines” chapter of this volume.

They are summarized in the

ABOUT THE SCRIPT MANAGER
The Script Manager 1s a set of extensions to the standard Macintosh Toolbox and operating
system that does two things:
= It provides standard, . . y-to-use tools for the sophisticated manipulation of ordinary
text.

u It makes it easy to translate an application into another writing system.
A script is a writing system. Roman scripts are writing systems whose alphabets have
evolved from Latin. Non-Roman scripts, (such as Japanese, Chinese, and Arabic) have
quite different characteristics. For example, Roman scripts generally have less than 256

V-294 About the Script Manager

The Script Manager
characters, whereas the Japanese script contains more than 40,000.

Characters of Roman

scripts are relatively independent of each other, but Arabic characters change form

depending on surrounding characters.

For example, Figure 1 shows how Key Caps looks in Arabic script.

2 SSS

=

Ke

£

Sete tecateleleleleleleleteleletelele
lel alelalalelalalelelelelelele

Srsserersgess
SEefelssesetetereresesessse
ESTES eT eLe Siler
terete erate
teteratet ate
tetetetetesetesetetese
et eta te

t eter ete tet ew ete tet eters tet at ett eee®
wdetetetetalelelelereletetetetetelelelererete
eeleteeleletelaleteletetelalelelelelelaleletersrelelelelalelececeresece
Reece
eesce reset eles
etecececeececetecssecssescsssscesssssssssssssesss
ste

—

slelefelets $

—I

sleleleleteleleleleteteseteteteteleselereteserssesese
SESsigsgigessessssiscsseessess
peeseessesseressrisstisstesst
sister sesisey
sietetetetaletererecesececesereseneressseseresers

PN
if)

LP

Figure 1. Key Caps in Arabic Script

z=)
a

The Script Manager is the low-level software that enables Macintosh applications to work
with such different scripts. It includes utilities and initialization code to create an
environment in which scripts of all kinds can be handled. In order for an application to use

oy)
=
ee)

a particular script, a Script Interface System to support that script must also be present.
All the currently available Script Interface Systems are written by Apple. Macintosh

computers normally use the Roman script, so the Roman Interface System (RIS) is in the

System file and always present. On some models it may be in ROM. Other Script Interface
Systems are the Kanji Interface System (KIS, also called KanjiTalk™), which allows
applications to write in Japanese; the Arabic Interface System (AIS); and the Hanze
Interface System (HIS) for Chinese.

A Script Interface System typically provides the following:
= fonts for the target language
u keyboard mapping tables
m special routines to perform character input, conversion, sorting, and text manipulation
m adesk accessory utility for system maintenance and control
The Script Manager calls a Script Interface System to perform specific procedure calls for a
given script. How a typical call (in this case, Pixel2Char) is passed from an application
through the Script Manager to a Script Interface System and back is shown in Figure 2.

About the Script Manager V-295

=

Te
@

Inside Macintosh

Application
Pixel2Char

Result

.

Script Manager
Pixel2Char

Roman

uses font script to determine

which script interface system
to call

Result

Kanji

Interface System

Interface System

Arabic

Interface System

Figure 2. Example of a Procedure Call

In many cases the versatility provided by Script Interface Systems allows applications to be
localized for non-Roman languages with no change to their program code (assuming they
were written to permit localization to Roman script). Up to 64 different Script Interface
Systems can be installed at one time on the Macintosh, allowing an application to switch
back and forth between different scripts. When more than one Script Interface System is
installed, an icon symbolizing the script in use appears at the right side of the menu bar.
The Script Manager provides the functions needed to extend Macintosh’s text manipulation
capabilities beyond any implicit assumptions that would limit it to Roman scripts. The
areas in which these limitations appear are:
u Character set size. Large character sets, such as Japanese, require two-byte codes
for computer storage in place of the one-byte codes that are sufficient for Roman
scripts. Script Manager routines permit applications to run without knowing whether
one-byte or two-byte codes are being used.
a Writing direction. The Script Manager provides the capability to write from right
to left, as required by Arabic, Hebrew, and other languages, and to mix right-to-left
and left-to-right directions within lines and blocks of text.
= Context dependence. Context dependence means that characters may be modified
by the values of preceding and following characters in the input stream. In Arabic, for
example, many characters change form depending on other characters nearby. Context
analysis is usually handled by the appropriate Script Interface System under the control
of the Script Manager.
= Word demarcation. Words in Roman scripts are generally delimited by spaces and
punctuation marks. In contrast, Japanese scripts may have no word delimiters, so the
Script Manager provides a more sophisticated method of finding word boundaries.
TextEdit calls may be intercepted by the Script Manager, which calls the appropriate

V-296 About The Script Manager

The Script Manager
Script Interface System routines to perform selection, highlighting, dragging, and
word wrapping correctly for the current script.
us Text justification. Justification (spreading text out to fill a given line width) is
usually performed in Roman text by increasing the size of the interword spaces.
Arabic, however, inserts extension bar characters between joined characters and
widens blank characters to fill any remaining gap. The Script Manager provides
routines that take these alternate justification methods into account when drawing,
measuring, or selecting text.

TEXT MANIPULATION
Applications that do extensive text handling and analysis, such as word processors, may
need to use Script Manager routines directly and work in close interaction with Script
Interface Systems. This section describes some potential problems with such applications
and provides general guidelines for handling them.

Determining

the

Script

in Use

=

|

ZN

smChinese
smKorean

smArabic
smHebrew
smGreek
smRussian
smReserved1

smDevanagari
smGurmukhi
smGujarati
smOriya
smBengali
smTamil
smTelugu
smKannada
smMalayalam
smSinhalese

Normal ASCII alphabet

WNFR

smKanji

Script

Korean

Reserved

zh

<
i}
=

Chinese
Arabic
Hebrew
Greek
Cyrillic

OQ

ne)
—

&
ge
@

Japanese

NNNK HR

smRoman

Value

oOo

Constant

©

The characteristics of different scripts require that text manipulation functions be handled
according to the script in use. Every script has a unique identification number, as shown in
the following list:

Devanagari
Gurmukhi
Gujarati
Oriya
Bengali
Tamil
Telugu
Kannada
Malayalam
Sinhalese

Text Manipulation V-297

Inside Macintosh

Constant

Value

Script

smBurmese
smKhmer
smThai
smLaotian

19
20
Z1
22

Burmese
Cambodian
Thai
Laotian

smGeorgian
smArmenian

23
24

Georgian
Armenian

smMaldivian
smTibetan

25
26

Maldivian
Tibetan

smSlavic

29

Non-Cyrillic Slavic

smUninterp

32

Uninterpreted symbols (such as MacPaint palette symbols)

smMongolian
smAmharic

27
28

sm Vietnamese
smSindhi

30
31

Mongolian
Ethiopian
Vietnamese
Sindhi

The Script Manager looks for one of these values in the font field of the current grafPort
(thePort) to determine which script the application is using. The script specified by the font
of thePort is referred to as the font script. For example, if thePort’s font is Geneva, the
font script will be Roman. If thePort’s font is Kyoto, the font script will be Japanese. If
the mapping from font to script results in a request for a Script Interface System that is not
available, the font script defaults to Roman.
Note: Be sure to set the font in the current grafPort correctly so the Script Manager
will know what script it is working with. Otherwise the results it returns will be
meaningless (for example, if a block of Arabic text is treated as if it were kanji).
The font script is not to be confused with the key script, which is maintained by the
system. The key script value determines which keyboard layout and input method to use,
but has no effect on characters drawn on the screen or on the operations performed by the
Script Manager routines. The key and font scripts are not always the same. For example,
while an international word processing application is using the Arabic Interface System for
keyboard input, it may also be drawing kanji and Roman text on the screen. For further
information about keyboard characters translation, see the System Resource File chapter in
this volume.

Drawing

and

Measuring

The drawing and measuring of Roman and non-Roman text is handled correctly by
standard Toolbox routines working in conjunction with the current Script Interface System
and the Script Manager. For example, the QuickDraw routine TextWidth can always be
used to find the width of a given line of text, since the Script Interface System that is
currently in use modifies the routine if necessary to give proper results.

V-298 Text Manipulation

The Script Manager

For an application to be able to handle non-Roman as well as Roman scripts, however, it is
important for text to be drawn and measured in blocks, rather than as individual characters.
Warning: Since non-Roman scripts can have multibyte characters, breaking apart a
string into individual bytes will have unpredictable results. This is not a good idea
even on standard Roman systems: scaled or fractional-width characters cause
incorrect results if measured and/or drawn one at a time. Also, it takes longer to
measure the widths of several characters one at a time (using CharWidth) than it does
to measure them together (using TextWidth or MeasureText).
In addition to supporting the standard trap routines for drawing and measuring text, the
Script Manager provides routines for handling text that is fully justified. These routines
behave the same as the standard drawing and measuring routines, but they have the extra
ability to spread the text out evenly on the line.

Parsing
One problem in evaluating or searching non-Roman text is that the low byte of a double-

byte character may be treated as though it were a valid character. For example, 93 (the
ASCII code for a right bracket) is the value of the low byte for up to 60 double-byte kanji
characters. If an application uses this character as a delimiter and searches through doublebyte text, it can produce invalid results. To prevent invalid character evaluation results,

applications should use the Script Manager routine CharByte to determine whether the
character in question is one byte of a double-byte character.

A related problem occurs when text is broken up into arbitrary chunks. This is a problem
for scripts whose characters are more than one byte long, or that change their appearance
based on surrounding context. The best solution is to avoid breaking text into physical
chunks. If it is necessary to draw the text in sections, it should be done using the clipping
facility of QuickDraw.
For example, suppose a graphics program needs to draw a string that has been rotated to
45°, and it must use a temporary buffer to draw the original text before drawing the rotated
text on the screen. The solution is to create a grafPort whose bit image is the buffer and set
the clipping region or bitmap bounding rectangle to the dimensions of the buffer. The text
can then be drawn into the grafPort, with the starting pen position set up so that the desired
segment of the text appears in the buffer. The text can be drawn in the buffer as many
times as is necessary, with a different starting pen position for each segment, until the
entire text has been drawn on the screen.
This method lets the Script Interface System correctly draw the characters each time,

regardless of any double-byte character or context problems.
width characters will be drawn correctly.

It also ensures that fractional

Text Manipulation V-299

raat

a |

2)

OQ

=F

a)ss

=

=
=
a
ge
7)

a

Inside Macintosh

Character

Codes

An application may, for some reason, need to use a character code or range of codes to
represent non-character data (such as field delimiters). Character codes below $20 are
never affected by the Script Interface System, and therefore can be used safely for these
special purposes. Note, however, that certain characters in this range are already assigned

special meanings by parts of the Macintosh Toolbox (TextEdit) or certain languages (C).

The following low-ASCII characters should be avoided:
Character

ASCII

Null

0

Enter

Code

3

Backspace

8

Tab
Line feed

9
10

System characters
Clear

17, 18, 19, 20
Zi

Carriage return
Cursor keys

Key-Down

13

28, 29, 30, 31

Event

Handling

Double-byte characters are passed to an application by two key-down events. With doublebyte scripts, the Script Interface System extends TextEdit as necessary to handle character
buffering.
Text-processing routines should check to see whether a key-down event is the first byte of
a double-byte character by using CharByte. If so, they should buffer the first byte and wait
for the second byte. When the second byte arrives, the character can be inserted in the text
and drawn correctly.
TextEdit performance can be improved significantly, even with Roman scripts, if the
application program buffers characters. Each time through the event loop, if the current
event is a keyDown or autoKey, place the byte in a buffer. Whenever the event is anything
else (including the null event), insert the buffer (call TEDelete to remove the current
selection range, call TEInsert to add the buffered characters, then clear the buffer).

V-300 Text Manipulation

The Script Manager

Writing

Direction

The standard writing direction at a given time is determined by the low-memory global
teSysJust. Setting teSysJust is handled by the Script Interface System, which provides
user control through a desk accessory. For Roman text teSysJust is set to 0; if it is —1, the
user (or the Script Interface System) has specified right-to-left as the standard system
direction. The value of this global has two results:
m TextEdit, the Menu Manager, and the Control Manager’s radio buttons and check

boxes will all justify on the right instead of the left. For compatibility, the meaning of

teJustLeft (0) changes. In that case, 0 causes the text to be right-justified, so teJustLeft
actually represents default justification. The parameter teForceLeft should be used if
the application really needs to force the justification to be left. This is also the case for
the TextEdit routine TextBox.
= Bidirectional fonts, such as Arabic and Hebrew, will draw blocks from right to left.
Within blocks of Arabic or Hebrew, QuickDraw is patched to order text from right to

left. That is, text is drawn from the given penLoc towards the right as normal, but the
order of the characters within that text may be reversed.

When constructing dialog boxes, if the user sets teSysJust through the Script Interface
System desk accessory, everything in dialog boxes will be lined up on the right edges of
the individual item rectangles. If a column of buttons, for example, is supposed to line up
in either writing direction, both the left and the right boundaries should be aligned.
When a word processor displays different text fonts and styles within a line, the pieces
should be drawn (and measured) in different order, depending on the teSysJust value.

a

~I
2)

O
mate

=)

-

X)
=
$9
ge
©
bw

Partitioning

Text

You should be careful when text needs to be partitioned or analyzed. With the Script
Manager, bytes may be mapped to different fonts in order to display non-Roman
characters. This mapping is also not fixed, because it can depend on the context around the
byte. Moreover, with Japanese and Chinese double-byte characters, a single byte may be
only part of a character. Here is a list of situations requiring extra care:
m Applications should not assume that a given character code will always have the same
width. With certain scripts, for example, using the new Font Manager cached width
tables may give inaccurate results. The new QuickDraw routine MeasureText will
return correct results with all current scripts.
a Applications should not assume that a monospaced font always produces monospaced
text. For example, the user might insert a wide Japanese character within a line of
Monaco text.

Text Manipulation V-301

4

Inside Macintosh

w Applications should be capable of processing zero-width characters. Zero-width
characters should never be divided from the previous character in the text when
partitioning text. When truncating a string to fit into a horizontal space, the correct
algorithm is to truncate from the end of the string toward the beginning, one byte at a
time, until the total width is small enough. This avoids cutting text before a zero-width
character.
= Script Manager utility routines should be used any time a line of text is to be
partitioned, as in selection, searching, or word wrapping. If a line is to be truncated
within a cell, for example, Pixel2Char should be used to find the point where the line
should be broken. If a line of text is broken into pieces, as when a word processor
displays different text fonts and styles within a line, Pixel2Char and Char2Pixel can be
applied to each piece in succession to find the character offset or pixel width.
= Applications should use the FindWord routine for word selection and word wrapping,
since some languages do not use spaces between words. TextEdit breaks words
properly because it is extended by the Script Interface System to handle the current
script.

Numeric

Strings

The characters that can appear in a numeric string depend on the script in which the string is
written. Applications that want to check ASCII strings to see if they are valid numeric

fields, or convert ASCII strings into their equivalent numeric values, should use the

SANE® routines to do so. These routines will always return the correct result, regardess
of the script in which the number is written. SANE routines are described in the Apple
Numerics Manual.
Note:

As with the international sorting and date/time routines, the interpretation of

numbers depends on the font for the current port. See “Script Information”, later in
this chapter.

V-302 Text Manipulation

The Script Manager

USING THE SCRIPT MANAGER
This section outlines the routines provided by the Script Manager and explains some of the
basic concepts you need to use them. The actual routines are presented later in this chapter.

Script

Information

FontScript tells your application to which script the font of the current grafPort belongs.
IntlScript is similar to FontScript but is used by the International Utilities package to

determine the number, date, time, currency, and sorting formats.

Note: Application programs can examine the international parameter blocks that
determine the number, date, time, currency, and sorting formats by calling the
JUGetIntl routine in the International Utilities package. Applications should not try
to access the international parameter blocks directly (via the Resource Manager
routine GetResource).
KeyScript is used to change the keyboard script, which determines the layout of the
keyboard. Word processors and other text-intensive programs should use this routine to
change the keyboard script when the user changes the current font. For example, if the
user selects Al Qahira (Cairo) as the current font or selects a run of text that uses the Al

Qahira font, the application should set the keyboard script to Arabic. This can be done by
using FontScript to find the script for the font, then using KeyScript to set the keyboard.
Note: With many scripts, the user can also change the keyboard script by using the
script desk accessory. Alternatively, your application can check the keyscript (using
GetEnvirons) in its main event loop; if it has changed, the application can set the
current font to the system font of the new keyscript (determined by a call to
GetScript). This saves the user from having to do it manually.

Character

Information

With scripts that use two-byte characters, such as kanji, it is necessary to be able to
determine what part of a character a single byte represents. CharByte tells you whether a
particular byte is the first or second byte of a two-byte character, or a single-byte character
code.
Here is an example of adding an extra step to a search procedure, similar to a check for
whole words, to handle double-byte characters:

Using the Script Manager V-303

—

~l

WN
(2)

mA

SS

—

a
=
a

ge

om

eer

|

Inside Macintosh
{Search

for

text

done
:= false;
newLocation
:=
repeat
newLocation

at

keyPtr

with

size

keySize}

-1;
:=

Munger(mainHandle,

newLocation+l,

keyPtr, keySize,
nil, 0); {find the
if newLocation < 0 then done := true
{only use CharByte when ScriptManager
else if (scriptsInstalled <= 1) |
(CharByte

until

if

{note

done;

newLocation

raw

text}

is

installed}

(mainHandle*,newLocation)

<=

>=

it,

that

0

CharByte

doesn't

touch

then

really

got

{we

0)

then

so

do

the

heap}

done

:=

true

something}

To make an extra test for whole words, the following code can be inserted instead of the

done := true statement after CharByte:
if not testWord
else begin

then

done

:=

true

{if no word
{test whole

testing}
word}

HLock (mainHandle) ;
{FindWord may touch heap}
FindWord(mainHandle*,
GetHandleSize(mainHandle),
newLocation,
false,
nil,
myOffsets);
if myOffsets[0]
= newLocation then
if myOffsets[1]
= newLocationt+keySize
then done:= true;
HUnlock (mainHandle) ;
{restore}
end;
{whole word test}

The CharType routine is similar to CharByte; it tells you what kind of character is indicated
given a text buffer pointer and an offset. CharType returns additional information about the
character, such as to which script it belongs and whether it’s uppercase or lowercase.

Text

Editing

Pixel2Char converts a screen position (given in pixels) to a character offset. This is useful

for determining

the character position of a mouse-down event.

The Char2Pixel routine finds the screen position (in pixels) of insertion points, selections,

and so on, given a text buffer pointer and a length.

The FindWord routine can be used to find word boundaries within text. It takes an optional
breakTable parameter which can be used to change its function for a particular script. For
word wrapping or selection, application programs can call Pixel2Char to find a character
offset and FindWord to find the boundaries of a word.
The HiliteText routine is used to find the appropriate sections of text to be highlighted. It
allows applications to be independent of the direction of text. The right-to-left languages are
actually bidirectional, with mixed blocks of left-to-right and right-to-left text. Using this
routine allows applications to highlight properly with left-to-right or with bidirectional
scripts.

V-304 Using the Script Manager

The Script Manager
The DrawJust and MeasureJust routines can be used to draw and measure text that is fully
justified. These routines take a justification gap argument, which determines how much
justification is to be done. The justification gap is the difference between the normal width
of the text, as measured by TextWidth, and the desired margins after justification has taken
place. A justification gap of zero causes these routines to behave like the QuickDraw
DrawText and MeasureText routines.
Pixel2Char and Char2Pixel also take the justification gap argument, so they can be used on
fully justified text.
Advanced

Routines

The Transliterate routine converts text to the closest approximation in a different script or
type of character. The primary use of this routine for developers is to convert uppercase
text to lowercase and vice versa.
The Font2Script routine can be used to map an arbitrary font number to the appropriate
script. By using Font2Script and KeyScript, for example, your program can set the
keyboard to correspond to the user’s font selection.
—

a |

System

i? 2)

Routines

(2)

fas

Ss—

The GetEnvirons and SetEnvirons routines can be used to retrieve or to modify the global
variables maintained for all scripts. Each script also has its own set of local variables and
routine vectors. The GetScript and SetScript routines perform the same functions as
GetEnvirons and SetEnvirons, but they work with the local area of the specified script.
Warning: Changing the local variables of a script while it is running can be
dangerous. Be sure you know what you are doing before attempting it, following
the guidelines in the documentation for the particular Script Interface System. Save
the original values of the variables you change, and restore them as soon as possible.
The GetEnvirons and SetEnvirons routines either pass or return a long integer. The actual
values that are loaded or stored can be long integers, integers, or signedBytes. If the value
is not a long integer, then it is stored in the low-order word or byte of the long integer. The
remaining bytes in the value should be zero with SetScript and SetEnvirons, and are set to
zero with GetScript and GetEnvirons.
The GetDefFontSize, GetSysFont, GetAppFont, GetMBarHeight, and GetSysJust
functions return the current values of specific Script Manager variables. SetSysJust is a
procedure that lets you adjust the system script justification.

Using the Script Manager V-305

SS

=

pe)

ge
@

Law 4

Inside Macintosh

SCRIPT MANAGER

ROUTINES

The Script Manager provides routines that support text manipulation with scripts of all
kinds.
Assembly-language note:

You can invoke each of the Script Manager routines

with a macro of the same name preceded by an underscore.

These macros, however,

aren’t trap macros themselves; instead they expand to invoke the trap macro
_ScriptUtil. The Script Manager then determines the routine to execute from the
routine selector, a long integer that’s pushed on the stack. The routine selectors
are listed in the Script Manager equates included with the Macintosh Programmer’s
Workshop, Version 2.0 and higher.

CharByte
FUNCTION

CharByte

(textBuf:

Ptr;

textOffset:

Integer)

:

Integer;

CharByte is used to check the character type of the byte at the given offset (using an offset
of zero for the first character in the buffer). It can return the following values:
Value

Meaning

—l
0
1
2

First byte of a multibyte character
Single-byte character
Last byte of multibyte character
Middle byte of multibyte character

CharType
FUNCTION

CharType

(textBuf:

Ptr;

textOffset:

Integer)

:

Integer;

CharType is an extension of CharByte which returns more information about the given
byte.
Note: If the byte indicated by the offset is not the last or the only byte of a
character, the offset should be incremented until the CharType call is made for the
lowest-order byte.
The format of the return value is an integer with the following structure:

V-306 Script Manager Routines

The Script Manager
Bits

Contents

0-3

Character type

4-7
8-11
12
13
14
15

Reserved
Character class (subset of type)
Reserved
Direction
Character case
Character size

Each Script Interface System defines constants for the different types of characters. The

following predefined constants are available to help you access the CharType return value
for the Roman script:
CONST

{ CharType

smCharPunct
smCharAscii
smCharEuro

character
=
=
=

types

0;
1;
7;

}

{ CharType character classes
smPunctNormal = $0000;
smPunctNumber = $0100;
smPunctSymbol = $0200;
smPunctBlank
= $0300;
{ CharType directions }
smCharLeft
= $0000;
smCharRight
= $2000;
{ CharType character case }

smCharLower

}
<
y
=
=
=
oS

= $0000;

smCharUpper
= $4000;
{ CharType character size
smCharlbyte
= $0000;
smChar2byte
= $8000;

(1

a

or

2 byte)

}

For example, if the character indicated were an uppercase “A” (single-byte), then the value
of the result would be smCharAscii + smCharUpper. Blank characters are indicated by a
type smCharPunct and a class smCharBlank.
Pixel2Char
FUNCTION

Pixel2Char

Integer;

VAR

(textBuf:

leftSide:

Ptr;

textLen,

Boolean)

:

slop,

Integer;

pixelWidth:

Pixel2Char should be used to find the nearest character offset within a text buffer

corresponding to a given pixel width.

It returns the offset of the character that pixelWidth

is closest to. It is the inverse of the Char2Pixel routine.

The leftSide flag is set if the pixel width falls within the left side of a character. This flag
can be used for word selection, and for positioning the cursor correctly at the end of lines.
For example, during word selection if the character offset is at the end of a word and the

Script Manager Routines V-307

Inside Macintosh

leftSide flag is on, then the double click was actually on the following character, and the
preceding word should not be selected.

,

The slop argument is used for justified text. It specifies how many extra pixels must be
added to the length of the string. If the text is not justified, pass a slop value of zero.
Char2Pixel
FUNCTION

Char2Pixel
direction:

(textBuf:
Ptr;
textLen,
SignedByte):
Integer;

slop,

offset:

Integer;

Char2Pixel is the inverse of Pixel2Char ; it should be used to find the screen position of

carets and selection points, given the text and length. For left-to-right scripts (including
kanji), this routine works the same way as TextWidth. For other scripts, it works
differently. The parameters are the same as in Pixel2Char, except for the direction.

The direction argument indicates whether Char2Pixel is being called to determine where the
caret should appear or to find the endpoints for highlighting. For unidirectional scripts such
as Roman, it should have the value 1. The following predefined constants are available for
specifying the direction:
CONST

smLeftCaret
smRightCaret
smHilite

=
=
=

0;
-1;
1;

{place caret for left block}
{place caret for right block}
{direction is TESysJust}

Like Pixel2Char, this routine can handle fully justified text. If the text is not justified, pass
a Slop value of zero.

Although Char2Pixel uses TextWidth (with Roman script), the arguments passed are not
the same. TextWidth, for ease of calling from Pascal, takes a byteCount argument which is
redundant. The length and offset for Char2Pixel are not equivalent; the routine needs the
context of the complete text in order to determine the correct value. For example, if myPtr

is a pointer to the text ‘abcdefghi’, with the cursor between the ‘d’ and the ‘e’ (and no

justification), the call would be
pixelWidth

:=

Char2Pixel(myPtr,

9,

0,

4,

1);

When Char2Pixel is used to blink the insertion, the direction parameter to Char2Pixel
should depend on the keyboard script. The call can look like this:
keyDirection

pixelWidth

:=

:=

GetScript

(GetEnvirons

Char2Pixel(myPtr,

9,

0,

(smKeyScript)
4,

,smScriptRight)

keyDirection) ;

;

However, the keyboard script may change between drawing and erasing the insertion
point. An application should remember the position where it drew the cursor, then erase
(invert) at that position again. This can be done by remembering the keyDirection, the pixel
width, or even the whole rectangle. For example, if the application remembers the
keyDirection by declaring it as a global variable, code like this could be used:

V-308 Script Manager Routines

The Script Manager
drawingInsertion

{to

IF

blink

the

:=

true;

insertion

{when

window

is

activated}

point}

drawingInsertion THEN
BEGIN {drawing}
keyDirection
:= GetScript (GetEnvirons(smKeyScript),smScriptRight) ;
pixelWidth

:=

Char2Pixel(myPtr,

{Get the vertical
{ the appropriate

END
ELSE
BEGIN

position for
rectangle}

myLength,

the

mySlop,

insertion

point,

keyDirection) ;

then

invert

}

{erasing}

pixelWidth
:= Char2Pixel(myPtr, myLength, mySlop, keyDirection) ;
{Get the vertical position for the insertion point, then invert }

{ the appropriate rectangle}
END;
{blinking}
drawingInsertion
:= not drawingInsertion;

FindWord
—

~I

PROCEDURE

FindWord (textPtr:
leftSide:
Boolean;
OffsetTable) ;

Ptr;
textLength,
offset:
breaks:
BreakTable;
var

Integer
offsets:

the boundaries of the word selected by the offset and leftSide. For example, if the text
“This is it” were passed with an offset and leftSide that selected the first word, the offset

pair returned would be (0,4).

FindWord uses a break table—a list of word-division templates—to determine the

If the breaks parameter is NIL, the default word-selection break

table for the current script is used. If itis POINTER(-1), then the default word-wrapping
break table is used. If the breaks parameter has another value, it should point to a valid
break table, which will be used in place of the default table. For information about
constructing alternate break tables, contact Apple Technical Support.
Word-selection break tables are used to find boundaries of words for word selection,
dragging, spelling checking, and so on. Word-wrapping break tables are used to
distinguish words for finding the widths of lines for wrapping. Word selection generally
makes finer distinctions than word wrapping. For example, the default word-selection
break table for Roman script yields three words in the string

OQ

eee

a]

-_-

FindWord takes a text string, passed in the textPtr and textLength parameters, and a
position in the string, passed as an offset. The leftSide flag has the same meaning here as
in the Pixel2Char routine. FindWord returns two offsets in the offset table which specify

boundaries of a word.

WM

(here): (, here, and ). For

word wrapping, on the other hand, this string is considered to be one word.

Script Manager Routines V-309

+S)
=}
iy

ge
@

r

Inside Macintosh

HiLiteText
PROCEDURE

HiliteText
(textPtr:
Ptr;
textLength,
firstOffset,
secondOffset:
Integer;
VAR offsets:
OffsetTable) ;

HiliteText is used to find the characters between two offsets that should be highlighted.
The offsets are passed in firstOffset and secondOffset, and returned in offsetTable.
The offsetTable can be thought of as a set of three offset pairs. If the two offsets in any
pair are equal, the pair is empty and can be skipped. Otherwise the pair identifies a run of
characters. Char2Pixel can be used to convert the offsets into pixel widths, if necessary.
The offsetTable requires three offset pairs because in bidirectional scripts a single selection
may comprise up to three physically discontinuous segments. In the Arabic script, for
example, Arabic words are written right-to-left while English words in the same line are
written left-to-right. Thus the selection of a section of Arabic containing an English word
can appear as shown in Figure 3.

O

=>

2

cS

5

cs

13
16

&

18

&
Figure 3. Example of Bidirectional Selection

HiLiteText returns the specific regions to be highlighted in this case as an offset table.
DrawJust
PROCEDURE

DrawJust

(textPtr:

Ptr;

textLength,

slop:

Integer) ;

DrawJust is similar to the QuickDraw DrawText routine. It draws the given text at the
current pen location in the current font, style, and size. The slop parameter indicates how

V-310 Script Manager Routines

The Script Manager
many extra pixels are to be added to the width of the string when it is drawn. This is useful
for justifying text.
MeasureJust
PROCEDURE

MeasureJust
(textPtr:
charLocs:
Ptr);

Ptr;

textLength,

slop:

Integer;

MeasureJust is similar to the QuickDraw MeasureText routine. The charLocs parameter
should point to an array of textLength+1 integers; MeasureJust will fill it with the
TextWidths of the first textLength characters of the text pointed to by textPtr. The first
entry in the array will return the width of zero characters, the second the width of the first
character, the third the width of the first and second characters, and so forth.

Transliterate
FUNCTION

Transliterate

Integer;

(srcHandle,

srcMask:

Longint):

dstHandle:

Handle;

Integer;

target:
aeal

Transliterate converts the given text to the closest possible approximation in a different
script or type of character. It is the caller’s responsibility to provide storage and dispose of
it. The srcMask indicates which character types (scripts) in the source are to be converted.
For example, Japanese text may contain Roman, hiragana, katakana, and kanji characters.
The source mask could be used to limit transliteration to hiragana characters only.
The target value specifies what the text is to be transliterated into. The low byte of the
target is the format to convert to. A value of —1 means the system script. The high byte
contains modifiers, which depend on the specific script number. The following predefined
constants are available to help you specify target values:

Constant

Value

Meaning

smTransAscii
smTransNative
smTransCase

0
1
2

Target is Roman script
Target is non-Roman script
Switch case for any target

smTransLower
smTransUpper

16384
32768

Target becomes lowercase
Target becomes uppercase

smMaskAscii
smMaskNative
smMaskAll

1
2
—1

Convert only Roman script
Convert only non-Roman script
Convert all text

The result is 0 for noErr or —1 for transliteration not available.

Transliteration is performed on a “best effort” basis: typically it will be designed to give a
unique transliteration into the non-Roman script. This may not be the most phonetic or
natural transcription, since those transcriptions are usually ambiguous (for example, in
certain transcriptions “th” may refer to the sound in the, the sound in thick, or the sounds in
boathouse).

Script Manager Routines V-311

—I

2)

i)
=F

=

=

=

fe

re
fo)
|

Inside Macintosh

On Roman systems, this routine is typically used to change case. For example, to convert
all the characters in a block of text to single-byte Roman (uppercase), the value of srcMask
would be smMaskAll, and target would be smTransUpper+smTransAscii. Each of the
Script Interface Systems defines additional target constants to be used during
transliteration.
Here are some examples of the effects of transliteration:

to uppercase
TO LOWERCASE

Mixed 3
romajh

=RY

----- >
----- >

8 ----- >

MIXED Je >

~~

~~

(HEAL

TO UPPERCASE
to lowercase

roma

----- >

(IEA

sii

nihonn

wee +

GetScript
FUNCTION

GetScript

(script,

verb:

Integer)

: LongInt;

GetScript is used to retrieve the values of the local script variables and routine vectors. The
following predefined constants are available for the verb parameter:
Constant

Value

Meaning

smScriptVersion
smScriptMunged
smScriptEnabled
smScriptRight
smScriptJust

0
2
4
6
8

Software version
Script entry changed count
Script enabled flag
Right-to-left flag
Justification flag

smScriptSysFond
smScriptAppFond

12
14

Preferred system font
Preferred application font

smScriptNumber
smScriptDate
smScriptSort
smScriptRsvd1
smScriptRsvd2
smScriptRsvd3
smScriptRsvd4
smScriptRsvd5
smScriptKeys
smScriptIcon

16
18
20
22
24
26
28
30
32
34

Script 'itl0' ID, from dictionary
Script ‘itl1' ID, from dictionary
Script 'itl2' ID, from dictionary
Reserved
Reserved
Reserved
Reserved
Reserved
Script 'KEYC' ID, from dictionary
Script 'SICN' ID, from dictionary

smScriptPrint
smScriptTrap

36
38

Script printer action routine
Trap entry pointer

smScriptCreator

40

Script file creator

smScriptRedraw

10

Word redraw flag

V-312 Script Manager Routines

The Script Manager
smScriptFile

smScriptName

42
+4

Script file name

Script name

Verb values unique to a script are defined by the applicable Script Interface System.

GetScript returns 0 if the verb value is not recognized or if the specified script is not
installed.

SetScript
FUNCTION

SetScript

(script,

verb:

Integer;

param:

LongInt)

:

OSErr;

SetScript is the opposite of GetScript. It is used to change the local script variables and
routine vectors and uses the same verb values as GetScript. The value smVerbNotFound is
returned if the verb value is not recognized or the script specified is not installed.

Otherwise, the function result will be noErr. It is a good idea to first retrieve the original

value of the global variable that you want to change, using GetScript. The original value
can then be restored with a second call to SetScript as soon as possible.

GetEnvirons

cent

~I

2)

FUNCTION

GetEnvirons

(verb:

Integer)

;

Longint.;

GetEnvirons is used to retrieve the values of the global Script Manager variables and

routine vectors. The following predefined constants are available for the verb argument:
Constant

Value

Meaning

smEnabled
smBiDirect

Environment version
Globals changed count
Environment enabled flag
Set if scripts of different directions are installed together

smFontForce
smIntlForce
smForced
smForced

Force font flag
Force international utilities flag
Current script forced to system script
Current script defaulted to Roman script

smPrint

Printer action routine

smSysScript
smAppScript
smKeyScript

System script
Application script
Keyboard script

smSysRef
smKeyCache
smKeySwap

System folder reference number
Keyboard table cache pointer
Swapping table pointer

smVersion

smMunged

This routine returns 0 if the verb is not recognized.

Script Manager Routines V-313

°
te

a=)
—_

=

a

=

f
ge
fc)
=

Inside Macintosh

SetEnvirons
FUNCTION

SetEnvirons

(verb:

Integer;

param:

LongInt)

:

OSErr;

SetEnvirons is the opposite of GetEnvirons. It is used to change the global Script Interface
System variables and routine vectors; it uses the same verbs as GetEnvirons. The value
smVerbNotFound is returned if the verb is not recognized. Otherwise, the function result
will be noErr.
It is a good idea to first retrieve the original value of the global variable that you want to

change, using GetEnvirons. The original value can then be restored with a second call to
SetEnvirons as soon as possible.

FontScript
FUNCTION

FontScript:

Integer;

FontScript returns the script code for the font script. The font script is determined by the
font of the current grafPort.

IntlScript
FUNCTION

IntlScript:

Integer;

IntlScript returns the script code for the International Utilities script.

Like the font script,

the International Utilities script is determined by the font of the current grafPort. If the
Script Manager global IntlForce is off, then IntlScript is the same as the font script; if
IntlForce is on, IntlScript is the system script.

For further information, see the

International Utilities Package chapter in this volume.

KeyScript
PROCEDURE

KeyScript

(scriptCode:

Integer) ;

KeyScript is used to set the keyboard script. This routine also changes the keyboard layout

to that of the new keyboard script and draws the script icon for the new keyboard script in

the upper-right corner of the menu bar.

Warning: Applications can also change the keyboard script without changing the
keyboard layout or the script icon in the menu bar, by calling the SetEnvirons routine
with the smKeyScript verb. However, this method should only be used to
momentarily change the keyboard script to perform a special operation. Changing
the keyboard script without changing the keyboard layout violates the user interface
paradigm and will cause problems for other Script Manager routines.

V-314 Script Manager Routines

The Script Manager

Font2Script
FUNCTION

Font2Script

(fontNumber:

Integer):

Integer;

Font2Script translates a font identification number into a script code. This routine is useful
for determining to which script a particular font belongs and which fonts are usable under a

particular script.

GetDefFontSize
FUNCTION

GetDefFontSize:

Integer;

GetDefFontSize fetches the size of the current default font. This routine is in the Pascal
interface, not in ROM; it cannot be used with the 64K ROM.

GetSysFont
FUNCTION

GetSysFont:

Integer;

—"

a |

GetS ysFont fetches the identification number of the current system font. This routine is in
the Pascal interface, not in ROM; it cannot be used with the 64K ROM.

NM
OQ

me

<—)

es

eS)
=

GetAppFont

a

itj=)

@
=“

FUNCTION

GetAppFont:

Integer;

GetAppFont fetches the identification number of the current application font. This routine
is in the Pascal interface, not in ROM.

GetMBarHeight
FUNCTION

GetMBarHeight:

Integer;

GetMBarHeight fetches the height of the menu bar as required to hold menu titles in its

current font.
64K ROM.

This routine is in the Pascal interface, not in ROM; it cannot be used with the

GetSysJust
FUNCTION

GetSysJust:

Integer;

GetSysJust returns the value of a global variable that represents the direction in which lines
written in the system script are justified: 0 for left justification (the default case) or —1 for

Script Manager Routines V-315

Inside Macintosh

right justification. This routine is in the Pascal interface, not in ROM; it cannot be used
with the 64K ROM.
SetSysJust
PROCEDURE

SetSysJust

(newJust:

Integer) ;

GetSysJust sets a global variable that represents the direction in which lines written in the
system script are justified: 0 for left justification (the default case) or —1 for right
justification. This routine is in the Pascal interface, not in ROM; it cannot be used with the
64K ROM.

HINTS FOR USING THE SCRIPT MANAGER
This section contains two programming suggestions you may find useful when using the
Script Manager.
Note:

In a work of this scope it is impossible to cover all aspects of script

manipulation. It is strongly advised that you obtain the latest version of the Script

Manager Developer’s Package before trying to write an application that uses the
Script Manager. This documentation is available through the Apple Programmer’s
and Developer’s Association (APDA).

Testing

for the Script Manager

Verify that the Script Manager is installed by checking to see if the Script Manager trap is
implemented. To identify the number of scripts currently enabled, use the verb smEnabled.
There is always at least one enabled script—Roman. Programs can use this information to
optimize performance for the Roman version:
{

Globals

}

Const
UnimplCoreRoutine
Var

{

ScriptUtil

=

scriptsInstalled

Initialization:

scriptsInstalled
if GetTrapAddress

=

$B5;

:

find

$9F;

{unimplemented

{the

Integer;

out

core

Manager

{global for testing
{ application}

whether

:= 0;
(UnimplCoreRoutine)

GetTrapAddress
(ScriptUtil)
then scriptsInstalled
:= GetEnvirons

V-316 Hints for Using the Script Manager

Script

we

can

use

the

<>
(smEnabled)

;

routine}

trap}

throughout

Script

}

Manager

}

The Script Manager

{
{

Code:
we can then
Script Manager
}

bracket

if scriptsInstalled
then begin
end
end;

{use

else

>

sections

of

the

code

that

use

the

}

1

CharByte}

{don’t

begin
use

CharByte}

Most script systems other than Roman will not install themselves on 64K ROMs, but the
Roman interface system and utility routines will always be present if the Script Manager is

installed.

Setting

the

Keyboard

Script

When the user selects a font from a menu, or clicks in text of a different script, the

application should set the keyboard script. Key Caps Version 2.0 does this, for example.
Use the following code:
{
{

Set
Set

if

the
the

font for
keyboard

the item
to agree

scriptsInstalled
if

myFont

<>

1

oldFont

newScript

if

>

:=

newScript
if

or port to myFont
}
with the current
script,

then

begin

then

begin

Font2Script

<>

or

(GetEnvirons
then
end;

end;

KeyScript

oldScript

oldFont

(myFont)

oldScript

multiFont

:=

:= myFont;

{only

then

begin

(smKeyScript)

(newScript)

newScript;

;

{

<>

{

~—I

if

different}

if

2+

always

mixed

smRoman)

a

=
i
ge

switch

fonts}

}

}

{don't

{ switch if not}
{switch the }
{ keyboard}
{save global}
{save

2)
)
=
‘—>

}

{ scripts}
{quick check for
{ speed}
{find the
}
{ script}
{if different}

;

=a

global}

end;

Roman script is a special case with single-script text. Non-Roman scripts typically include
the 128 ASCII characters, and users will alternate between the Roman keyboard and the
native keyboard. Hence the Roman keyboard should be left alone when switching. With
mixed-script text this is not true, since users will be using a Roman font when they want
Roman text. For this case, you do not need to test for Roman.

Hints for Using the Script Manager V-317

}

@

=

Inside Macintosh

To get the current keyboard script, and the system or application font for that script, use the
code:
{

For

the

system

font

}

if scriptsInstalled <= 1 then scriptFont
:= systemFont
{default to system font}
else scriptFont
:= GetScript (GetEnvirons (smKeyScript),
smScriptSysFond) ;
{ For the application font }
if scriptsInstalled <= 1 then scriptFont
:= applFont
{default to application font}
else scriptFont
:= GetScript (GetEnvirons (smKeyScript),
smScriptAppFond) ;

This code can be used if your application does not have an interface that lets users change

fonts but still needs to provide for different scripts.

V-318 Hints for Using the Script Manager

The Script Manager

SUMMARY

OF THE

SCRIPT MANAGER

Constants
{

Values

of

thePort.font

smRoman

=

smKan ji
smChinese
smKorean
smArabic
smHebrew
smGreek
smRussian
smReservedl
smDevanagari
smGurmukhi

=
=
=
=
=
=
=
=
=
=

smBengali

=

smGujarati
smOriya

0;

{Bengali}

=
=
=

smSinhalese
smBurmese
smKhmer
smThai
smLaotian

{

=
an

14;
15;
16;

{Tamil}
{Telugu}
{Kannada}

3
K
=

=
=
=
=
=

18;
19;
20;
215
22:

{Sinhalese}
{Burmese}
{Khmer }
{Thai}
{Laotian}

©

=
=
=
=
=
=
=
=

24;
Zo
26;
27;
28;
29;
30;
31;

=

smUninterp

=

17;

smCharPunct

=

{

CharType

=
=

{Armenian}
{Maldivian}
{Tibetan}
{Mongolian}
{Ethiopian}
{non-Cyrillic
{Vietnamese}
{Sindhi}

{uninterpreted
types

Slavic}

symbols}

}

0;

1;
7;

character

smPunctNormal
smPunctNumber

Ax

{Georgian}

32;

character

S.

{Malayalam}

23;

CharType

smCharAscii
smCharEuro

alphabet}

{Gujarati}
{Oriya}

=

smGeorgian

ASCII

I3;

smTamil
smTelugu
smKannada

smArmenian
smMaldivian
smTibetan
smMongolian
smAmharic
smSlavic
smVietnamese
smSindhi

{normal

{Japanese}
{Chinese}
{Korean }
{Arabic}
{Hebrew}
{Greek}
{Cyrillic}
{reserved}
{Devanagari}
{Gurmukhi }

11;
12;

smMalayalam

}

1;
2;
3;
4;
5;
6;
7;
8;
9;
10;

=
=

oil

CONST

classes

}

$0000;
$0100;

Summary of the Script Manager V-319

Inside Macintosh
il

smPunctSymbol

smPunctBlank

{ CharType

directions

smCharRight
CharType

}

$0000;

smCharLeft
{

$0200;
$0300;

$2000;
character

}

$0000;
$4000;

smCharLower

smCharUpper

{ CharType

case

character

size

(1

or

smCharlbyte

$0000;

{ Transliterate

targets

}

smTransAscii
smTransNative

0
1
16384
32768
i
2
=]

{target

smChar2byte

}

woud

$8000;

smTransLower

ibd’

t

smTransUpper
smMaskAscii
smMaskNative
smMaskAll1

{ GetScript

2 byte)

verbs

{target

{target

{target

{convert
{convert
{convert

is

is

Roman

script}

non-Roman

becomes

becomes

uppercase}

only Roman script}
only non-Roman script}
all text}

}
{software

smScriptVersion
smScriptMunged

version}

{script entry changed
{script enabled flag}
{right-to-left flag}

smScriptEnabled
smScriptRight

smScriptJust

{justification

flag}

{script

'itl0'

ID,

ID;

smScriptRsvd2
smScriptRsvd3

{seript
"itl2*
{reserved}
{reserved}
{reserved}

smScriptRsvd5

{reserved}

smScriptSysFond
smScriptAppFond
smScriptNumber

smScriptDate

{sGriIpt

smScriptSort
smScriptRsvdl

{seript:

smScriptKeys
smScripticon
smScriptPrint
smScriptTrap
smScriptCreator
smScriptFile
smScriptName

{script

ID;

from

from
from

*KEYC*

dictionary}

dictionary}
dictionary}

ID, from dictionary}
ID, from dictionary}
printer action routine}
*SICN*

{trap entry pointer}
{script file creator}

{script

{script
verbs
oil

smMunged

{seript

file

name}

name}

}

NO

smVersion

"At

{reserved}

smScriptRsvd4

GetEnvirons

count}

{word redraw flag}
{preferred system font}
{preferred application font}

smScriptRedraw

{

script}

lowercase}

V-320 Summary of the Script Manager

{environment

{globals

version}

changed

count}

The Script Manager
smEnabled
smBiDirect

{environment

enabled

smFontForce
smiIntlForce
smForced

{force font flag}
{force intl flag}
{current script forced to
{ script}
{current
script defaulted

to

{system

number}

{set if scripts
{ installed}

smForced

of

flag}

both

directions

{ script}
{printer action routine}
{system script}
{application script}
{keyboard script}

smPrint

smSysScript
smAppScript
smKeyScript
smSysRef

{keyboard
{swapping

smKeyCache
smKeySwap

folder

table
table

reference

system

are

}

}

Roman

}

cache pointer}
pointer}

Routines

Script

Information

FUNCTION

FUNCTION
PROCEDURE

Routines

FontScript

Integer;
Integer;

IntlScript
KeyScript (scriptCode:

~—I

ve

C3

Integer);

mf

a
2
SS
=|
&
Tece

oe

Character
FUNCTION
FUNCTION

Text

Information
CharByte

CharType

Editing

Routines

(textBuf:
(textBuf:

Ptr;

Ptr;

textOffset:

textOffset:

Integer)
Integer)

:
:

Integer;

Integer;

Routines

FUNCTION

Pixel2Char

FUNCTIC.W

Char2Pixel

PROCEDURE

FindWord

PROCEDURE

HiliteText

PROCEDURE
PROCEDURE

DrawJust
MeasureJust

(textBuf:
Integer ;

Ptr; textLen,
VAR leftSide:

leftSide:

Boolean;

slop,pixelWidth:
Boolean): Integer;

(textBuf:
Ptr; textLen,
slop,offset:
Integer;
direction:
SignedByte)
: Integer;
(textPtr:
Ptr; textLength,
offset:
Integer;

breaks:

offsets:
OffsetTable) ;
(textPtr:
Ptr; textLength,
secondOffset:
Integer;
VAR
OffsetTable);
(textPtr:
Ptr; textLength,
(textPtr:
Ptr;
textLength,
charLocs:
Ptr);

BreakTable;

var

firstOffset,
offsets:
slop:
slop:

Integer) ;
Integer;

Summary of the Script Manager V-321

Inside Macintosh

Advanced

Routines

FUNCTION

Transliterate

FUNCTION

Font2Script

System

Routines

FUNCTION
FUNCTION
FUNCTION

FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
PROCEDURE

(srcHandle,

dstHandle:

(fontNumber:

Integer)

Integer;

GetScript
(script,
SetScript
(script,
GetEnvirons
(verb:

srcMask:

:

:

target:

Integer;

Integer;

verb: Integer)
: LongInt;
verb: Integer; param: LongInt)
Integer)
: LongIint;

SetEnvirons
(verb:
Integer;
param:
GetDefFontSize:
Integer;
GetSysFont:
Integer;
GetAppFont:
Integer;
GetMBarHeight:
Integer;
GetSysJust:
Integer;
SetSysJust
(newJust:
Integer) ;

Assembly-Language

Handle;

Longint)

LongInt)

:

: OSErr;

OSErr;

Information

Constants
;

Routine

selectors

for

_ScriptUtil

smFontScript

EQU

0

smKybdScript
smFont2Script
smGetEnvirons
smSetEnvirons
smGetScript
smSetScript
smCharByte
smCharType

EQU
EQU
EQU
EQU_
EQU)
EQUEQUEQU-)

4
6
8
10
12
14
16
18

smIntlScript

smPixel2Char
smChar2Pixel
smTranslit
smFindWord
smHiliteText
smDrawJust
smMeasureJust

Trap

Macro

EQU

EQU
EQU
EQU
EQU
EQU
EQU
EQU

trap

2

20
22
24
26
28
30
32

Name

_ScriptUtil

Note: You can invoke each of the Script Manager routines with a macro that has
the same name as the routine preceded by an underscore.

V-322 Summary of the Script Manager

18
324
324
325
327
aoe
327
328
329
329
329
331
|
332
B32
332
332
332
333
333
333
334
334
334
336
346

THE

CONTROL

PANEL

About This Chapter

The Control Panel

Operation
Contents of Cdev Files
'BNDL',

'ICN#',

and

'FREF'

Resources

‘DITL' Resource
‘mach' Resource
‘nrct' Resource
‘cdev' Code Resource
Cdev Call
Messages
The macDev Message
The initDev Message
The activDev Message
The updateDev Message
The nullDev Message
The hitDev Message
The keyEvtDev Message
The deActivDevMessage
The closeDev Mesage
The standard Edit Menu Messages
Storage in a Cdev
Cdev Error Checking

Sample Cdev

Cal

Summary of the Control Panel

io)

‘2
oS
=

—>

=

=

a=}

=
=

2

V-323

Inside Macintosh

ABOUT

THIS CHAPTER

The Control Panel has been made extendible: developers can now supply new user controls
for the Control Panel to display.

The new Control Panel presents a scrollable list of control devices, or edevs, rather than a
single panel. Each cdev is self-contained. When the user selects a control device, controls
for the previous cdev disappear and most of the Control Panel’s window is turned over to
the newly selected one.

This chapter describes how to write a cdev that the new Control Panel will recognize and
allow users to access. It concludes with the code for a very simple example cdev. (Several
cdevs are standard on the System Disk; they contain all of the functions that were in the old
Control Panel, and more.)

THE CONTROL

PANEL

Rather than presenting a fixed set of controllable items displayed in a single, sectioned
window, the new Control Panel presents a scrollable list of cdevs in the left quarter of the
window. Selecting an icon in the list brings up the controls for that cdev on the right side

of the panel. When the Control Panel is opened, it searches the System Folder for cdevs.
Since each cdev appears with its own icon in the System Folder, users can easily add or
throw away items as they need.

Before going into the details of their construction, you should consider the most basic fact
about cdevs: they are parts of the Control Panel, and should perform functions that belong
there—primarily the occasional setting and resetting of machine or system preferences.
Before designing something as a cdev, you should think carefully about whether it belongs
in the Control Panel.
You should also think carefully about the user interface. If the default settings are well
chosen, most users will rarely need to use the Control Panel. Because cdevs are not used
routinely, designers should make the user interface to their cdevs as straightforward as
possible.

Figure 1 shows the new, extendible Control Panel.

V-324 The Control Panel

The Control Panel

Control

Panel
Rate of Insertion

Point Blinking

Be
ARS

o

:

Calor

Desktop Pattern

O
Slow

:] Menu Blinking | Time

O

©
Fast

@

t 1225: 1.4.4M

E

P|

q

1O

©OO)oate

Mouse

BE
iy]

Keyboard

eq

eOff

1 2

| @12hr.
© 24 br.
3)

RAM Cache [768K

=

12/
8)

faz

3/86
~~O

@

| Speaker
volume

3.0
Figure 1. Extendible Control Panel

OPERATION

—

When the Control Panel is opened it scans the System Folder for resource files of type
cdev. Upon finding a cdev file it takes the file’s icon and name and adds it to the list at the
left quarter of the Control Panel window. When the Control Panel has found all the cdev
files, it puts General at the top of the list and opens the General cdev.

The factory-issue Control Panel has six cdevs in the scrollable list. The initial cdevs are, in

order of appearance:
a General

(all Macintoshes)

mw Keyboard

(all Macintoshes)

a Monitors

(Macintosh II only)

= Mouse

(all Macintoshes)

w Sound

(Macintosh II only)

m Startup device

(Macintosh SE and II )

Operation V-325

oo
2)
°
=!
—_
=

cs

~~
nS

=|
2:

Inside Macintosh

The General cdev is always first, and comes up selected the first time the user opens the

Control Panel.

Each cdev is self-contained, with a standard structure and interface that is supported by the
Control Panel.

The Control Panel handles actions that are common to all cdevs, such as

putting up a dialog window and responding to window-related events, displaying dialog
items and tracking controls. The cdev itself simply describes what’s in the dialog (except
the cdev icon), and contains code for controlling whatever that cdev was designed to do.
The division of labor between Control Panel and the individual cdevs follows.
The Control Panel will
m manage the modeless dialog window for the Control Panel as a whole, and respond to
events for the window, such as dragging or closing it
m query cdevs initially, to see if they should be displayed on the current hardware
m manage the list of cdev icons, and respond to user actions on the list, such as picking
which cdev to run
w track user actions on cdev controls

w if requested by a cdev, draw rectangles within the cdev portion of the window, and
blank out (with light gray) any area of the window not needed by the current cdev
w if requested by a cdev, display selected error conditions
a draw dialog items belonging to the cdev that’s displayed
w signal the current cdev to do its part in responding to specific events
The cdev should
m supply the standard resources that the Control Panel needs to run any cdev (described
below)

m draw and respond to user items
m be prepared to handle errors, as described later in this chapter
m initialize and shut down when signalled by Control Panel to do so

m do any updating, activating, deactivating that can’t be done automatically for dialog
items
= respond to user keystrokes and hits on dialog items or controls, when signalled by the
Control Panel
m perform whatever actions that cdev was designed to do
When the user clicks a new control device to select it, the Control Panel signals the current
cdev to shut down and removes any items in the dialog that belong it. For the new cdev,
the Control Panel then loads its code, splices its dialog items into the dialog’s item list and
draws them, signals the cdev to initialize, and begins signalling the new cdev, as needed, in
response to user actions.

V-326 Operation

The Control Panel

Contents

of

Cdev

Files

The cdev interface to the Control Panel has two parts: a standard set of resources that

describe the cdev, and are contained in the cdev resource file; second, one of those
resources is code, which contains a function that must respond to a well-defined set of

messages that may be passed to the cdev by the Control Panel.

To be adopted by the Control Panel, a cdev file must contain at least these seven resources:

. 'DITL' (ID = -4064)
NAN
ff WN

.'mach' (ID = -4064)
.'nrct' (ID = —-4064)

. ICN#' (ID = -4064)

. 'BNDL' (ID = -4064)
. 'FREF' (ID = —4064)
. 'cdev' (ID = -4064)

the code resource

These standard resources, and others that are unique to the cdev, fall in two halves of the

same resource ID range, 4033 through 4064.

IDs that fall in the range -4064 through

—4049 are reserved for the resources in the Control Panel’s cdev interface. IDs in the range
—4048 through -4033 can be used by individual cdevs. Cdevs that encroach on the Control
Panel’s range risk conflicting with future releases of the Control Panel.
The rest of this subsection describes the standard cdev resources and the messages that the
cdev can expect from the Control Panel. The sample cdev file at the end of this chapter has
examples of the seven resources.
—

oo)

"BNDL',

ICN#',

and

'FREF'

‘2.

Resources

S

~

—s
a!

The 'BNDL', 'ICN#' and 'FREF' resources enable the cdev to appear both in the Finder™
and Control Panel displays. (An owner resource is also needed for the cdev to display its
correct icon in the Finder.)
"‘DITL'

Resource

The 'DITL' is a standard dialog item list, including all of the items in your cdev. When a
cdev is opened, the Control Panel concatenates the 'DITL' to its own. The coordinates of a
cdev’s dialog items are relative to the entire Control Panel window, not just the cdev
portion of the window to the right of the list. To fall in the cdev section of the window,
items must be entirely within the rectangle (1, 89, 253, 320).

Operation V-327

ca

ay)
a
=}

=

Inside Macintosh
|S)

S==

Control

.

General
=
a3

oo

°
Color

Mouse

|

A

7

#24

se

0

Very Slow

Slow

O

2 2)

(Mouse)

OOO

¥v

HEH

ae

Tracking

(Tablet)

a

Keyboard

Panel

v

¥O

VO

SSHNESE

@

JESSHIEE

Fast

| J:isftSh

v

see agate:

VO

Double-Click Speed

See

HEHEHES
sepmseteceles
Sete Stceteres
gisiegatasese

ELBE:

22):

Sun SE

VEEEieeeusshstCrewencceetOn
SEUSS Caeere U tessSe ers Eee
sees cowl heres resp caer

3.0
wy

oF

= Y

Control Panel

2

edev Dialog Items

Dialog Items

Figure 2. Dialog Items
‘mach’

Resource

The 'mach' resource is used by the Control Panel to determine the machines on which this
cdev can run. It contains two word-sized masks: the Softmask is compared to the global
variable ROM85

to test for toolbox features (such as Color Quickdraw); the Hardmask is

compared to the low memory global HwCfgFlgs to determine which hardware features are
available. The cdev will show up if every bit that is 0 in the Softmask is 0 in ROM85 and
every bit that is 1 in the Hardmask is | in HwCfgFlgs. If the Softmask is 0 and the
Hardmask is $FFFF then the Control Panel sends the cdev a macDev call (described

below), otherwise it does not. Mask examples:
Softmask

Hardmask

Action

0

$FFFF

always call cdev with macDev message

$FFFF
$7FFF
$3FFF

V-328 Operation

$0000
$0400
$0000

appear on all machines
appear on machines with ADB
appear on Macintosh II only

The Control Panel

The 'mach' resource enables the Control Panel to cache information about each cdev. (The
user can force a rebuild of the cache by holding down Command-Option while opening the
Control Panel.)
‘nrct’'

Resource

The 'nrct' resource is a list of rectangles. The first word of the resource is the number of
rectangles in the list; the rest of the resource contains the rectangle definitions, using eight
bytes per rectangle in (top, left, bottom, right) order.
The Control Panel starts out with a light gray background pattern and then uses the
rectangles to clear white space for the controls and to draw frames around them. The 'nrct'

resource, along with the 'DITL' resource, defines the look of the cdev panel.

Rectangle coordinates are relative to the entire Control Panel window.

To use all of the

available space in the cdev area, use one rectangle with coordinates (—1, 87, 255, 322).

(The coordinates differ from those given in 'DITL' by exactly two pixels, which is the
width of the frame Control Panel draws around each rectangle.) To join two panels neatly,
overlap their rectangles by one pixel on the side where they meet, so that the rectangle
frames overlap too. For example, the two cdev rectangles in Figure 2 have the coordinates

(—1, 87, 100, 266) and (98, 87, 159, 266).

If the number or sizes of rectangles you want varies (as in the Macintosh II Monitors cdev),
the easiest way to manage it is to define rectangles covering the maximum area, and paint
out those you don’t want at run time with the same gray pattern Control Panel uses, or
frame them yourself.
‘cdev'

Code

Resource

a

oo)

The ‘cdev' code resource contains all of your code to handle the other part of the cdev
interface, the events that are passed to you by Control Panel. The very first piece of code
in this resource must be the cdev function, as described below.

2)
=)
=

as
=

S

a”

+s)

=

©

CDEV

CALL

The cdev function should be the first piece of code in your 'cdev' resource.
sequence is as follows:
FUNCTION

cdev(message,
VAR theEvent:

Its calling

Item,
numItems,
CPanelID:
INTEGER;
EventRecord;
cdevValue:
LONGINT;
CPDialog:
DialogPtr)
: LONGINT;

Cdev Call V-329

Inside Macintosh

Field

descriptions

message

A message number, from the list defined below, that allows the Control
Panel to tell the cdev what event has just taken place.

Item

For hitDev messages only: the dialog item number of the item that was hit.
Since the cdev’s DITL is appended to the Control Panel’s DITL, the number
of items preceding the cdev’s must be subtracted to get a value that is
meaningful to the cdev.

(See the hitDev message, described below.)

numItems

The number of items in the DITL, belonging

to the Control Panel, that

CPanelID

The base resource ID of the Control Panel driver. This value is private to
the Control Panel.

theEvent

For hit, null, activate, deactivate, and key events: the event record for the
event that caused the message. See the Toolbox Event Manager in Volume I
for details of the EventRecord structure.

cdevValue

The value the cdev returned the last time it was called by the Control Panel,

precede the cdev’s dialog items in the item list.

or a return message from the Control Panel. When a cdev is initialized it

typically allocates some storage for state information or other data it needs to
run. Since desk accessories in general and the Control Panel in
particular—and therefore cdevs—cannot have global variables, the
cdevValue, which is passed to the cdev for every message, is often used for
storing data. The cdevValue is also used by the Control Panel to
communicate error handling action to the cdev. See “Storage in a Cdev”
and “Cdev Error Checking” later in this chapter.
CPDialog

The Control Panel DialogPtr. This may be a color dialog on Macintoshes
that support color windows.

The function value returned will be one of three kinds. The Control Panel’s initial call to a
cdev will be a macDev call, described below. The cdev responds with a function value that
tells the Control Panel whether the cdev should be displayed or not. In subsequent calls the
cdev function result may be an error code, or data that needs to be kept until the Control
Panel’s next call. The function result is generally passed back to the cdev in the cdevValue
parameter at the next cdev function call.
The cdev will be called with the current resource file set to the cdev file, the current
grafPort set to the Control Panel’s dialog, and the default volume set to the System Folder
of the current startup disk. The cdev must preserve all of these. Also note that the Control
Pancl sets the cursor to the cross cursor whenever it is above the cdev area of the Control
Panel window. Your cdev thus has control of the cursor only during the call; if you change
it, the Control Panel will immediately reset it.
Your cdev may be reentered, especially if you put up dialog or alert boxes. The Dialog
Manager calls SystemEvent and SystemTask, which may cause a deactivate message to be
sent while your cdev is still processing the previous message.

V-330 Cdev Call

The Control Panel

Messages
The following cdev message values have been defined:
CONST
initDev
hitDev
closeDev

nulDev
updateDev

=
=

=
=

0;
1;
2;

3;
4;

{desk accessory
{update event}

7;

{key-down

or

{standard
{standard

Edit
Edit

activDev
= 5;
deActivDev=6;

keyEvtDev

macDev

undoDev

cutDev

copyDev
pasteDev

clearDev

=

{initialization}
{user clicked dialog item}
{user selected another cdev

8;
9 ;
=10;
0
=11;
1

=12;
=13;

run}

{activate event}
{deactivate event}

auto-key

or

characteristics}
menu undo}
menu cut}

{standard

menu

Edit

closed}

event}

{check machine
{standard Edit
{standard Edit

menu
menu

CP

copy}
paste}

clear}

The messages are described below.
Before dispatching to handle a specific message, all cdevs should have some common
defensive behavior, for example ensuring that they have enough memory torun. Publicminded cdevs keep a minimum of memory allocated between calls, and memory that was
free may be consumed by other applications while Control Panel is inactive, so it is
important to check that there is enough memory available on every message.
As part of their memory check, cdevs that depend on various Toolbox packages should
ensure that there’s still room to load them. Cdevs should also ignore any messages (except
macDev) received before initialization, or after shutdown or an error.

See the sample cdev for examples.
macDev

oo

‘2
o

Your cdev, as part of a desk accessory that may move from one invocation to another,
cannot use global variables. This in turn means that you cannot set user item procedures
for drawing user items in the 'DITL', because the procedure pointers will dangle if the code
moves. Instead, you must draw your user items in response to update messages. Also,
you must find Quickdraw globals by means of thePort if you need to reference them.

The

—

Message

If the 'mach' resource has a 0 in Softmask and a —1 ($FFFF) in Hardmask, the first

message a Cdev will get is a macDev message. This is an opportunity for the cdev to
determine whether it can run, and whether it should appear in the Control Panel’s cdev list.
The cdev can do its own check to see which machine it is being run on, what hardware is

connected, and what is in the slots (if it has slots). The cdev must then return a function
result of 1 or 0. If a0 is returned, the Control Panel will not display the cdev in the icon

Cdev Call V-331

=

ms

ms

=

=
~~)

bs)
|

5

Inside Macintosh

list. (Note that the Control Panel does not interpret this 0 or 1 as an error message as
described under “Cdev Error Checking”’.)
The macDev call happens only once, and only when Softmask and Hardmask are 0 and
FFFF. It is always the first call made to the cdev.
The

initDev

Message

InitDev is an initialization message sent to allow the cdev to allocate its private storage (if
any) and do any initial settings to buttons or controls. This message is sent when the user
clicks on the cdev’s icon.
Note that the dialog, cdev list, and all of the items in the cdev’s 'DITL' except user items

will already have been drawn when the initDev message is sent.

If your cdev doesn’t need any storage it should return the value that was passed to it in
cdevValue.

The

activDev

Message

An activDev message is sent to the cdev on every activate event. It allows the cdev to reset
any items that may have changed while the Control Panel was inactive. It also allows the
cdev to send things such as “lists activate” messages.

The

updateDev

Message

An updateDev message is sent to the cdev on every update event. It allows the cdev to
perform any updating necessary aside from the standard dialog item updating provided by
the Dialog Manager. For example, if the cdev resource contains a picture of the sound
control bar, it will probably be a user item, and the picture of the control bar and the
volume knob should be redrawn in response to update events.
Note that there is no mechanism for determining what to update, as the update region has
already been reset. You must redraw all of your user items completely.

The

nulDev

Message

A nulDev message is sent to the cdev on every Control Panel run event. This allows the
cdev to perform tasks that need to be executed continuously (insertion point blinking, for
example).
A cdev cannot assume any particular timing of calls from applications. Don’t use nulDev to
refresh settings; see activDev, above.

V-332 Cdev Call

The Control Panel

The

hitDev

Message

A hitDev message is sent when the user has clicked an enabled dialog item that belongs to
the cdev. The dialog item number of the item hit is passed in the Item parameter.
Remember that the Control Panel’s items precede yours, so you’ll want (Item — numItems)
to determine which of your items was hit. If the Control Panel itself has n items, the first
of the cdev’s items will be n+1 in the combined dialog item list. A cdev should not depend
on any hardcoded value for numItems, since the number of items in Control Panel’s
'DITL ' is likely to change in the future.
Factoring in numItems need not mean an increase in your code size, or passing and adding
numlItems everywhere, or foregoing the constants that most developers use to identify
specific items. You can do it easily, and neatly, as follows:
1. Subtract numItems from Item right away, and refer to your dialog items with
constants as usual throughout the cdev.
2. Write simple envelope routines to enclose Dialog Manager procedures that require item
number arguments. Add numlItems only locally, within those routines and for the
Dialog Manager calls only.
This is demonstrated in the sample cdev.
The

keyEvtDev

Message

A keyEvtDev message is sent to the cdev on every keyDown event and autoKey event. It
allows the cdev to process key events. On return to the Control Panel, the key event will
be processed by a call to dialogSelect in the Dialog Manager. A cdev that does not want the
Toolbox Event Manager to do any further processing should change the what field of the
EventRecord to nullEvent before returning to the Control Panel.

—

oe)

2)
=)
—}

The

deActivDev

noe
oe

S.

Message

a")

A deActivDev message is sent to the cdev on every deactivate event. It allows the cdev to
send deactivate messages to items such as lists.
The

closeDev

Message

A closeDev message is sent to the cdev when either the Control Panel is closed or the user
selects another cdev. When a cdev receives a closeDev message it should dispose of any
storage it has allocated, including the handle stored in cdevValue, if any.

Cdev Call V-333

&
=

=;

Inside Macintosh

The

Standard

Edit

Menu

Messages

Values 9 through 13 have been defined in order to provide the standard Edit menu

functions of Undo, Cut, Copy, Paste, and Clear for applications that need to implement
them.

STORAGE

IN A CDEV

Since normal global storage is not available, the Control Panel, like all desk accessories,
uses a special mechanism to store values between calls. The cdevValue parameter in the
cdev call extends this storage mechanism to cdevs.
If a cdev needs to store information between calls it should create a handle during the
initDev call, and return it as the cdev function result.

The Control Panel always returns

such handles in the cdev Value parameter at the next call.

If the cdev is called with a closeDev message, or if it needs to shut down because of an
error, then this handle and any pointers or handles within the storage area should be
disposed of before returning to the Control Panel.

CDEV

ERROR

CHECKING

Because a desk accessory may be called into many strange and wonderful situations,
careful attention must be paid to error checking. The two most common error conditions
are missing resources and lack of memory. Some error reporting and recovery facilities
have been provided in the Control Panel to help with errors encountered in a cdev.
Because the Control Panel has no direct information about the cdev, the cdev’s code must

be able to detect and recover from error conditions on its own. If the recovery cannot be
effected the cdev must dispose of any memory it has allocated, and exit back to the Control
Panel with an error code.
Following a shutdown, the Control Panel can help report the error condition to the user and
prevent accidental reentry into the cdev that might result from such things as an update
event. A cdev can request three different error reporting mechanisms from the Control
Panel:
w If a memory error has occured, then, after the cdev has safely shut itself down, it may
request the Control Panel to issue an out-of-memory error message and gray out (paint
over with the background pattern) the cdev area of the Control Panel window. It will
remain grayed until another cdev is selected. The Control Panel window itself is not
closed since other cdevs may still be able to function in the environment.
w If a resource error is detected, the cdev may request that a can’t-find-needed-resource

error message be issued.

V-334 Cdev Error Checking

The Control Panel

w The cdev may display its own error message and then call on the Control Panel to gray
its area.
The Control Panel uses the cdevValue parameter to send status information to the cdev, and
a proper cdev uses its function value to send information back to the Control Panel. In the
absence of errors, the same value passes back and forth: the Control Panel puts the last
function value it received into cdev Value when it calls the cdev; the cdev returns the value it
finds there as the function value. The cdev may want to keep a handle to its own storage,
in which case passing it as the function value ensures its availability, since the Control
Panel will pass it back in cdevValue at the next call.
Four constants have been defined for this cdev/Control Panel communication:
CONST

cdevUnset
=
cdevGenErr =

3;
-1;

{initial
{generic

value passed
cdev error}

cdevResErr=

1;

{missing

resource

cdevMemErr=

0;

{insufficient

memory

in
for

needed

cdevValue}
cdev

by

execution}

cdev}

After the macDev call, the Control Panel sends cdevUnset in cdev Value, so that until an
error occurs or the cdev uses its function value as a handle, cdevUnset is passed back and
forth. If the cdev encounters an error, it should dispose of all handles and pointers it has
set up, strip the stack back to the same position as a normal exit, and return one of the three
error codes as the function result. The Control Panel will respond as follows:

Function
Result

Message to
Control Panel

Control Panel Action

cdevGenErr

The cdev has encountered an

Gray out the cdev’s area, send

error from which it cannot
recover, but do not put up
an error dialog.

a () in cdevValue in succeding
cdev calls.

cdevMemErr

_ Thecdev has determined that
there is not enough memory to
execute; please put up a
memory error dialog.

Gray out cdev’s area, put up
error dialog, send a 0 in
cdev Value in succeeding cdev
calls.

cdevResErr

The cdev can’t finda needed
resource; please put up a
resource error dialog.

Gray out cdev’s area, put up
error dialog, send a 0 in
cdev Value in succeeding cdev
calls.

all other values,
either handles
or cdevUnset

No error conditions.

Send the value back in
cdev Value.

The cdev code should check cdevValue at entry. A 0 means that the Control Panel has
responded to a cdev error message by shutting down the cdev and displaying an error
dialog if one was requested. The cdev should immediately exit.
Once the Control Panel has responded to an error message from a cdev it will no longer
respond to any return values until another cdev is launched.

Cdev Error Checking V-335

x
O
=
S
~
3

Inside Macintosh

The sample cdev code presented next includes error checking.

SAMPLE

CDEV

Following is a REZ resource file containing resource definitions for a sample cdev. The

cdev code resource is provided by the Pascal code that follows. When executed, the cdev
puts up a control window that has two buttons, and displays how many messages it has
received, as shown in Figure 3.

=|SSB

Control

oy

Panel

Messages received by Sample:

1.0d2

-

@ Show

Handled:

2

General

© Hide

Ignored:

42

pr Lgeaitbaysceier
ietees oe aeenr te ey ataen stata

Keyboard | PEC SEHL SHENias
B
SEEEEESEEEEEEEEEEECEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
Mouse | Pl cUHEI HH eee ESS
ee
3.1

wd PORCPERE
SerreDS Peti ceepie Re Pee
teaae eee cece
ee oe NOME PM UP LIMC PS
Figure 3. Sample cdev

/x

1987

Apple

Computer,

+

+

+

File Sample.r
Copyright © 1986,

*/

Sample

#include

cdev

file

"Types.r"

type

‘samp'

type

‘nrct'

integer

array

rez

as

=

‘STR

';

{

$S$CountOf (RectArray)

RectArray

V-336 Sample Cdev

{

rect;

};

;

Inc.

All

rights

reserved.

The Control Panel
yy
type

'mach'

unsigned

}y

unsigned

/*

{

hex

integer;

hex

/*

integer;

/*

Softmask

Hardmask

*/
*/

The

owner resource
(related to the BNDL below).
Macintosh Volume IV for more information.
*/
resource
'samp'
(0, purgeable)
{
"Sample cdev 1.0d2,
June 23,
1987"

See

Inside

}3

resource
'BNDL'
‘samp',
0,
{
‘'ICN#',
{0,
'FREF',
{0,

}?

{

/*

'ICN#'

S"FFFF
S"800E
S"800E

FFFF
0001
0000

S"FOFE
$"8000
$"8000
S"FFFF

7F1E
0001
0001
FFFF

S"FFFF

FFFF

y*

7F33

[2]

*/

S"FFFF
S"FFFF
S"FFFF
S"FFFF

FFFF
FFFE
FFFF
FFFE

S"FFFF

FFFF

S"FFFF

FFFF

S"FFFF

}

(-4064,

array: 2 elements
f* [i] *7

S"E1CE

resource

FFFF

'FREF'

'cdev',

0;

purgeable)

{

purgeable)

{

-4064},
-4064}

}

resource

}3

(-4064,

*/

8000
800E
78FE

0001
0001
3E33

8000
800E
FOFE

0001
0001
7F33

8000
800E
FOFE

0001"
0001"
6333"

78FE
8000
8000
0000

3F0C
0001
0001
0000

8000
8000
8000
0000

0001
0001
0001
0000

8000
8000
8000
0000

0001"
0001"
0001"
0000",

FFFF

FFFF

FFFF

FFFF"

E1CE

FFFF

7F33

FFFF

FFFF
7FFF
FFFF
7FFF

FFFF
FFFF
FFFF
FFFE

FFFF

FFFF

FFFF

0000

E1CE

FFFF
FFFF
FFFF
FFFF

FFFF

FFFF

0000

0000

FFFF

603F

FFFF
FFFF
FFFF
FFFF

FFFF

FFFF

0000

(-4064,

purgeable)

{

(-4064,

purgeable)

{

(-4064,

purgeable)

{

FOFE

FFFF
FFFF
FFFF
FFFF

FFFF

FFFF

0000

7F1E"

oC
—

FFFF"
FFFF"
FFFE"
FFFF"

O
5=
S
=

FFFF"

~~

y
5

FFFF"

0000"

al

We

3
resource

OxFFFF,

};

'mach'

0

resource

{

}

/*

'nrct'

array

{=1y

87,

RectArray:
19;

1 elements

*/

322}

Sample Cdev V-337

Inside Macintosh
}?
resource

{

/*

}

};
/*

'DITL'

array

287,
92,

16,
16,

320},
280},

{26;,
{42,
{29,
{45,
{29,
{45,

122,
122,
190,
190,
240,
240,

43;
59,
41,
57,
39,
55,

170},
170},
230},
230},
300},
300},

Resources
must fall
to -4049)

resource

'CNTL'

{

"Show"

StaticText
StaticText

*/

Contzol
Contxrel
StaticText
StaticText
UserItem
UserItem

{disabled,
"1.0d2"};
{disabled,
"Messages
}
{ received by Sample:"};
{enabled,
-4048};
{enabled,
-4047};
{disabled,
"Handled:"};
{disabled,
"Ignored:"};
{disabled};
{disabled}

==SS5==

*/

122,

{

8 elements

that are private to the Sample cdev
(IDs for these
in the range -4048 to -4033).
All those above
(-4064
are standard for every cdev,
and specified by Control

* Panel.
{26,

purgeable)

{4,
{4,

al

*
*
*

(-4064,

DITLarray:

43,

(-4048,

170},

0,

purgeable)
visible,

1,

(-4047,
purgeable)
170},
0, visible,

1,

{

0,

radioButProcUseWFont,

0,

}

0,

radioButProcUseWFont,

0,

}

};
resource
'CNTL'
{42,
122,
59,
{

"Hide"

ha

V-338 Sample Cdev

{

The Control Panel

The

Pascal

{Copyright

mn

et,

eatin,

ay

pi,

on,

{Sample:
cdev

four

source
©

A

has

code

1986,

small

two

for the

1987

cdev

Apple

code

radio

‘cdev’

Computer,

resource

buttons,

code

labeled

Inc.

for

use

"Hide"

resource:
All

by

other

items

to

be

visible

or

invisible.

something

that's

really

useful

in

Control

rights

reserved. }

Control

Panel

The

}

and

"Show",

four

which

3.0.

The

cause

}

visible/hidden
items
are the number
of messages
handled by the cdev,
the number
ignored,
and titles
for those two counts.
Note that
}
Sample
violates
the prime directive
for cdevs,
i.e.
that
it do
}

{$D+}
UNIT

{turn

debugging

symbols

}
}

Panel...}

on}

cdev;

INTERFACE
USES

MemTypes,

FUNCTION

QuickDraw,

Sample

OSIntf,

(message,

ToolIntf,

item,

numItems,

CPDialog:

DialogPtr)

theEvent:

PackIntf;

CPanelID:

EventRecord;

:

INTEGER;

cdevValue:

LONGINT;

LONGINT;

IMPLEMENTATION

CONST
{ Constants
iVersion =

iTitle

for

=

all
a

of

Sample's

{ staticText}
{title for Sample
{ staticText}

ai

iShowCounts
iHideCounts

=
=

iTitleHandled
iTitleIgnored

iHandled

=

iIgnored

=

=
=

dialog
items
}
{cdev's
version
number

3
4;

53
6;
8;

just

just

}

}

on

{show
{hide

the
the

events
events

{user

item

for

number

of events

}

{user

item

for

number

of

}

{title
{title

7;

is

is

for
for

{

handled}

{

ignored}

events
events

handled/ignored}
handled/ignored}
handled
ignored

count}
count}

events

o
A

TYPE

SampleStorage

dlgPtr:

=

dlgItems:
countShown:
msgHandled:
msgIgnored:

RECORD

DialogPtr;
INTEGER;
BOOLEAN;
INTEGER;
INTEGER;

END;

SamplePtr
SampleHdl

=
=

*“SampleStorage;
*SamplePtr;

Sample Cdev V-339

3
—

=

&

Inside Macintosh
InitSample

FUNCTION
FUNCTION
PROCEDURE

(CPDialog:

DialogPtr;

numItems:

INTEGER):

LONGINT;

FORWARD;

EnoughRoomToRun
(VAR cdevValue:
LONGINT)
: BOOLEAN;
FORWARD;
CountMessage
(ourHandle:
SampleHdl;
handledIt:
BOOLEAN) ;
FORWARD;

PROCEDURE
PROCEDURE
FUNCTION

HitSample
(ourHandle:
SampleHdl;
item:
INTEGER);
FORWARD;
DrawSampleItem
(ourHandle:
SampleHdl;
item:
INTEGER);
FORWARD;

PROCEDURE

IGetRect

PROCEDURE
PROCEDURE
PROCEDURE

IHide

IGetCtlHand

{

(ourHandle:

IShow

the

function
jumps to

cdev

to

(ourHandle:

dispatch

the

Sample

cdev.

}

as

FORWARD;

INTEGER);

item:

FORWARD;

INTEGER);

documented

above.

FORWARD;

The

cdev

the code resource;
Control Panel
'cdev' code resource to dispatch

numItems,

cdevValue:

CPanelID:

LONGINT;

INTEGER;

CPDialog:

}

}
}

theEvent:

DialogPtr)

LONGINT;

VAR
as
handledIit:

INTEGER;
BOOLEAN;

storageExpected:

BOOLEAN;

ourHandle:
BEGIN

item,

EventRecord;

INTEGER);

item:

SampleHdl;

function,

(message,

item:

SampleHdl;

MUST be the first code in
the first location in the

messages

FUNCTION

SampleHdl;

(ourHandle:

IInvalidate

{Sample:

{
{

(ourHandle:
SampleHdl;
item:
INTEGER):
ControlHandle;
FORWARD;
(ourHandle:
SampleHdl;
item:
INTEGER;
VAR itemRect:
Rect);
FORWARD;

{Do

{

{

a

validity

cdevValue
is

the

new

is

SampleHdl;

check

before

initialized

cdevValue

trying

to

after

any

storageExpected
:= NOT
((message
OR
(message
= macDev));

IF

storageExpected
OR

(cdevValue

AND
=

((cdevValue

cdevUnset) )

THEN
cdevValue
:= 0
{Equally important,
we must
{

{

{

{

to

cdevUnset

check

handle

by

error
=

the

message.

Control

return. }

}

Panel;

zero

initDev)

=
that

0)
there's

still

enough

}

memory available
for Sample to run,
on every message.
Memory
can easily be consumed by other apps,
etc,
between messages,
and
(to be neighborly)
we don't
keep anything
around between
messages
except
the handle
in cdevValue. }

ELSE

IF storageExpected
BEGIN

&

{ squeeze.
END

now,

{We're

past

NOT

EnoughRoomToRun

initialization,

Escape

and

averting

have

V-340 Sample Cdev

:=
:=

TRUE;
SampleHdl

been

mayhem. }

ELSE
BEGIN
handlediIt
ourHandle

}

(cdevValue) ;

(cdevValue)

hit

with

}

}
}

THEN

a

memory

}

The Control Panel
CASE

message
OF
initDev:

IF

EnoughRoomToRun

(cdevValue)

BEGIN

cdevValue

:=

InitSample

(CPDialog,

ourHandle
closeDev:

IF

ourHandle

END;

<>

:=

THEN

numItems) ;

SampleHdl

(cdevValue) ;

NIL

THEN

BEGIN

DisposHandle
(Handle
(ourHandle)
);
cdevValue
:= 0;
ourHandle

:=

NIL;

END;

hitDev:

HitSample

OTHERWISE

handledIt

updateDev:

FOR

i

(ourHandle,

:=

:=

END;
IF
ourHandle

<>

CountMessage

(ourHandle,

NIL

item

-

numItems) ;

iHandled TO iIgnored DO
DrawSampleItem
(ourHandle,

i);

FALSE;

THEN

handledIt);

END ;

Sample

{InitSample:
FUNCTION
VAR

BEGIN

:=

cdevValue;

Initialize

InitSample

i:

the

cdev}

(CPDialog:

DialogPtr;

—

ourHandle
:=
IF ourHandle

SampleHdl
(NewHandle
<> NIL THEN

©

BEGIN
WITH ourHandle**
BEGIN

dlgPtr

msgHandled

i

numItems;

:=
:=

iShowCounts

ORD4

a
=

=
co

:=

SetCtlValue

:=

=I

(SampleStorage)
));

CPDialog;
:=

msgignored
countShown
END;

:=

(SIZEOF

DO

:=

digItems

END;

LONGINT;

-

SampleHdl;

InitSample

INTEGER):

INTEGER;

ourHandle:

FOR

numItems:

0;

0;
TRUE;

TO

iHideCounts

(IGetCtlHand

DO

(ourHandle,

iShowCounts));

i),

ORD

(i

=

(fourHandle);

END;

{EnoughRoomToRun:

check

that

we

still

have

room

to

run;

close

up

if

not

Sample Cdev V-341

}

Inside Macintosh

FUNCTION

EnoughRoomToRun

(VAR

cdevValue:

LONGINT)

:

BOOLEAN;

VAR

BEGIN

error:
packHand:

INTEGER;
Handle;

{Make sure there
is still
room for the
needed to process
any event,
AND for
resources
you need at the same time.
storage,
you should account
for that

maximum amount
of memory
}
any packages
or other
}
If you allocate
lots
of
}
also
if it hasn't
been
}

{ the fact that PACK 7 may be in
packHand
:= GetResource
('PACK',

it

allocated yet.
Sample needs the Binary/Decimal
conversion
}
package to display the event counts.
}
In the interest of simplicity,
this does NOT take into account

IF

packHand

<>

NIL

THEN

ROM;
7);

really

}

should. }

BEGIN

EnoughRoomToRun

EXIT

:=

TRUE;

(EnoughRoomToRun) ;

END

ELSE

IF

ResError

THEN

ELSE
{There's

error

too

gracefully,

{

will

IF

resNotFound

:=

cdevMemErr;

:=

error

{

{

=

cdevResErr

little

memory

because

the

disposing

allocated,

replace

<>

DisposHandle

PROCEDURE

the

package.

error

code

we

return

cdevUnset)

ourHandle

WITH

<>

if

(Handle

from

Control

it's

Panel

SampleHdl;

Try

to

as

is

to

<>

handledIt:

:=

msgHandled

+

:=

msgIgnored

+

(ourHandle,

1;

END

ELSE
BEGIN
msgIignored

DrawSampleItem
END

{HitSample:

Handle

V-342 Sample Cdev

a

hit

in

one

of

our

(ourHandle,

DITL

items}

NIL)

THEN

Panel

BOOLEAN) ;

iHandled);

1;

iIgnored) ;

}

}

handled/ignored}

THEN

DrawSampleItem

fail

been

Control

ourHandle** DO
IF handledIt THEN
BEGIN
msgHandled

missing}

otherwise}

already

(cdevValue)

(cdevValue)
) ;

(ourHandle:
NIL

storage

AND

(Handle

message

CountMessage

BEGIN

IF

count

resource

memFull

load

our

cdevValue
:= error;
EnoughRoomToRun
:= FALSE;

{CountMessage:

needed

{assume

to

of

cdevValue. }

(cdevValue

{a

}

The Control Panel

PROCEDURE

HitSample

(ourHandle:

SampleHdl;

item:

INTEGER) ;

VAR
i's

INTEGER;

BEGIN

WITH

FOR
FOR

ourHandle**
DO
IF countShown

i
i

:=

<>

countShown

ELSE

EXIT

iShowCounts

SetCtlValue

:=

(item

THEN

=

iShowCounts)

:=

(item

=

iShowCounts)

(HitSample) ;

TO

iHideCounts

(IGetCtlHand

iTitleHandled

TO

DO

(ourHandle,

iIgnored

DO

item = iShowCounts
THEN IShow
(ourHandle,
ELSE
IHide
(ourHandle,
IInvalidate
(ourHandle,
i);

i)
i);

i),

ORD

(i

=

item));

BEGIN

IF

END;

{DrawSampleItem:

PROCEDURE

Draw

one

of

DrawSampleItem

our

DITL

(ourHandle:

user

items}

SampleHdl;

item:

INTEGER) ;

VAR

itemRect:
s%
BEGIN

Rect;
Stx2S5;3

{Note that Sample draws its user items explicitly,
rather than }
{ installing a pointer to the draw procedure in the dialog item.
{

{
{

Since

the

would

cdev's

become

manager

invalid

may

move

(Control

between

Panel

the

cdev,

so

IGetRect
(ourHandle,
WITH ourHandle**
DO

item,

itemRect) ;

{ pointer

before

code

either).}

BEGIN

SetPort

IF

there's

messages,

often

no

calls

chance

to

the

the

pointer

dialog

refresh

the

}

}

Se

}

=]

ELSE

NumToString

itemRect

(msgHandled,

(msgIgnored,

s)

s);

DO

MoveTo
(left,
TextMode
(srcCopy) ;

DrawString
TextMode

a

©

END;
WITH

‘2
=
-

(dlgPtr);

item = iHandled
THEN NumToString

be

}

bottom);

(s);

(srcOr);

END;

Sample Cdev V-343

Inside Macintosh
{Simple routines enclosing the dialog manager functions we need,
{ tack on numItems
(so we can refer to our items with constants
{ everywhere else).
}
{IGetCtlHand:
get control handle for given dialog
{IGetRect:
get rectangle for given dialog item}
{IHide: hide dialog item}
{IShow:
show dialog item}
{IInvalidate:
erase & invalidate dialog item}

item}

FUNCTION

INTEGER) :

IGetCtlHand

(ourHandle:

SampleHdl;

item:

}

to}

ControlHandle;
VAR

itemHand:
itemRect:
itemType:

Handle;
Rect;
INTEGER;

BEGIN

WITH

ourHandle**

GetDItem
IGetCtlHand

DO

(dlgPtr,

item + dlgItems,
itemRect) ;
ControlHandle
(itemHand) ;

:=

itemType,

itemHand,

INTEGER;

VAR

END;

PROCEDURE

IGetRect

(ourHandle:

SampleHdl;

item:

itemRect:

Rect) ;
VAR

itemType:
itemHand:

INTEGER;
Handle;

BEGIN

WITH

ourHandle**
GetDItem

DO
(dlgPtr,

item + dlgItems,
itemRect) ;

itemType,

itemHand,

END;

PROCEDURE

IHide

(ourHandle:

SampleHdl;

item:

INTEGER) ;

BEGIN

WITH

ourHandle**

HideDItem

END;
PROCEDURE

IShow

DO

(dlgPtr,

(ourHandle:

item

+

SampleHdl;

dlgItems) ;

item:

INTEGER) ;

BEGIN

WITH

ourHandle**
ShowDItem

DO
(dlgPtr,

item

+

dlgItems) ;

END;

PROCEDURE

IInvalidate

VAR

itemRect:

V-344 Sample Cdev

Rect;

(ourHandle:

SampleHdl;

item:

INTEGER);

The Control Panel
BEGIN

IGetRect

EraseRect
InvalRect

(ourHandle,

item,

itemRect) ;

(itemRect) ;
(itemRect) ;

END;
END.

—

i
©Q

S—

Loew

|

cs,
~~

=
=

oe

Sample Cdev V-345

Inside Macintosh

SUMMARY

OF

THE CONTROL

PANEL

Constants
CONST
{

messages

}

initDev
hitDev
closeDev

=
=
=

nulDev
updateDev
activDev

=
=
=

deActivDev

=

undoDev

=

keyEvtDev
macDev

=
=

cutDev
copyDev
pasteDev
Special

{initialization}
{user clicked on dialog
item}
{user selected another
cdev or

6;

{deactivate

9;

{standard

Edit

menu

{standard

Edit

menu

3;
4;
5;

7;
8;

=10;
=11;
=12;

clearDev

{

0;
1;
2;

cdevValue

values

cdevGenErr

=

-1;

cdevResErr
cdevUnset

=
=

1;
3;

cdevMemErr

=

0;

event}

Edit
Edit
Edit

undo}

menu
menu
menu

cut}
copy}
paste}

clear}

}

{general

{memory

error;

gray

shortfall;

{couldn't
get
{cdevValue
is

cdev

alert

w/o

user

alert}

please}

a needed resource;
alert}
initialized to this}

Routines
FUNCTION

cdev(message,
INTEGER;

cdevValue

closed}

{key down or autokey event}
{check machine characteristics}
{standard
{standard
{standard

=13;

CP

{desk accessory run}
{update event}
{activate event}

Item,
numItems,
VAR theEvent
:

:

LONGINT;

LONGINT;

V-346 Summary of the Control Panel

CPanelID
EventRecord;

CPDialog

:

DialogPtr)

19
348
348
349
350
350
352
352
352
357

THE

START

MANAGER

About This Chapter
Initialization
System Startup

Special Topics

System Startup Information
‘INIT’ Resource 31
Timing Information
Start Manager Routines
Summary of the Start Manager

—

Oo
if— 2)
~

=

=
=
ow
ga
om

=y

V-347

Inside Macintosh

ABOUT

THIS CHAPTER

This chapter describes the Start Manager, which coordinates the initialization and system

startup procedures of the Macintosh SE and Macintosh II.

Reader’s guide: The Start Manager is operated entirely by the standard
Macintosh operating system. The only time you might need to understand the Start
Manager is if you were implementing a different operating system on the
Macintosh.

INITIALIZATION
When the Macintosh SE or Macintosh II are turned on or restarted, the Start Manager goes

through the following initialization procedures (steps specific to the Macintosh II are noted
as such):
a A

set of diagnostic routines test the critical hardware components (VIA1, VIA2, SCC,

IWM, SCSI, and ASC); if the diagnostics succeed, the familiar startup tone is issued
and the hardware components are initialized.

= Memory is tested in two stages, depending on whether the machine is being turned on
or the system is being restarted. A complete test of RAM is done only when the
system is first turned on; on a system restart, only a quick 1K RAM test is performed.

m The Start Manager determines which microprocessor is installed and the rate at which

it’s running. The global variable CPUFlag will contain the value 0, 1, or 2, indicating
that the processor is an MC68000, 68010, or 68020 respectively. If the MC68020 is
present, the instruction cache is enabled. Several global variables are initialized with
timing information (see below for details).

a Global variables needed by the system and interrupt dispatch tables are initialized.
m On the Macintosh II, the system is put in 24-bit mode for compatibility with existing
Macintosh software. (For information on how to convert to 32-bit address mode, see

the Operating System Utilities chapter in this volume.)

u A small system heap is created; this heap will grow in order to accommodate additional
drivers.
m The ROM resources, Package Manager, and Time Manager are initialized.
m On the Macintosh II, the Slot Manager is initialized and the initialization code on the
declaration ROM of each inserted card is executed.
m The Apple Desktop Bus Manager is initialized.
w On the Macintosh II, the Start Manager looks for a video card to use as the main video
display. It first tries the device specified by the user via the Control Panel. If no
device has been specified, or if the specified card isn’t found, it looks for the first

V-348 Initialization

The Start Manager
available video sResource. (SResources are described in the Slot Manager chapter.)
QuickDraw is initialized and the desktop is drawn.
a The SCSI Manager, Disk Manager, and Sound Manager are initialized.
a The cursor is made available.
ScrnBase is set to 0.)

SYSTEM

(If no video card was found, the global variable

STARTUP

After initialization has been completed, the Start Manager performs the following system
startup procedures:
= The drive number of the internal SCSI drive is obtained from parameter RAM. The
Start Manager then pauses from 15 to 31 seconds to allow the device to power up.
(The amount of time that the system waits can be obtained and changed with the
GetTimeout and SetTimeout procedures, described below.)
a The Start Manager looks for an appropriate start device.

It first checks the 3.5-inch

drives, starting with the internal drive; if no disk is found, the device specified as the

default start device by the user (via the Control Panel) is used. If no default is
specified, or if the specified device is no longer connected, it checks for devices on the
SCSI bus, beginning with the internal drive (the drive number of the internal drive is
contained in parameter RAM). The remaining drives are then checked, beginning with
drive 6 and ending with drive 0. For each device, the appropriate driver is read in and
entered in the drive queue.
= Once a start device has been selected, system startup information is read from the
device. On the Macintosh II, a slot device may take over the system startup process
instead of providing system startup information; for details, see the Device Manager
chapter in this volume.
a If the system startup information is dispatchable (version $44), the code is executed;
otherwise, the information is read in. (The format of the system startup information is
given below.)
u Using this information, the System file is used to initialize the Resource Manager, and
the System Error Handler and Font Manager are then initialized.
u The system startup screen, if present, is displayed (the name of the startup screen,
typically “StartUpScreen”, is contained in the system startup information).
u The debugger, if present, is loaded (the name of the debugger, typically “MacsBug”,
is contained in the system startup information).
= ROM patches are loaded from resources of type 'PTCH'.

—

\o

WN
oe
~

sew

7

+S)
=
i)
ge
@

Lew

m If the machine uses the Apple Desktop Bus, all resources of type 'ADBS' are loaded
and executed.
m Tracking of mouse movement begins.
= Drivers read in from slot devices are opened if the flag fOpenAtStart in the
sRsrc_Flags field of the device’s sResource is set. This flag is discussed under

System Startup V-349

|

|

Inside Macintosh
“Installing a Driver at Startup” in the Driver Design chapter of Designing Cards and
Drivers for Macintosh IT and Macintosh SE.

m The RAM cache specified in the Control Panel is installed, and the application heap is
initialized.

w All 'INIT' resources are loaded and executed (see below for details).
u The system heap size (determined by the system startup information) and default folder

are set.

m The startup application is launched; if this fails, the Finder is launched.

SPECIAL TOPICS
This section gives additional information about various aspects of initialization and system

startup.

System

Startup

Information

Each Macintosh-initialized volume must contain system startup information in logical

blocks 0 and 1 (sometimes referred to as the “boot blocks’’). This information consists of

certain configurable system parameters, such as the capacity of the event queue, the initial
size of the system heap, and the number of open files allowed. Figure 1 gives the format
of the first 16 fields of this system startup information.

V-350 Special Topics

The Start Manager
byte 0

system startup

information

ID (word)

2

entry point of boot code (long word)

6

system startup version number (word)

8

used internally - should be 0 (word)

A

name

1A

name of system shell (bytes)

2A

name of debugger (bytes)

3A

name of debugger (bytes)

4A

name of system startup screen (bytes)

SA

name of first program to run (bytes)

of system resource code file (bytes)

6A

| name of scrap file on disk (bytes)

7A

| number of file control blocks (word)

Pie

number

of events

in event queue (word)

7E

system heap size for 128K system (long word)

82

reserved (long word)

86

system heap size for 512K system (long word)
Figure 1. System Startup Information

The System file contains standard values for these fields that are used in formatting a
volume.

(The values for certain fields, such as the number of file control blocks and the

system heap size, depend on the machine that’s running and are computed at system startup
time.) You should have no reason to access the information in these fields; they’re shown
only for your information.

The system startup information ID is used to verify that the blocks contain system startup
information.
The version number distinguishes between different versions of system startup
information. A version number of $44 means that the blocks contain executable code. The
code typically directly follows the startup information, and the entry code for such code is
stored just before the version number (at byte 2).

Special Topics V-351

ros

=)

2)
—
be

er!

—

i
=
a

ge
©

|

Inside Macintosh
Following the version number are a number of names that identify standard files used or

executed during system startup. These names can be up to 15 characters long, and must be
preceded by a length byte.
‘INIT’

Resource

31

The 'INIT' 31 resource (introduced in chapter 29 of Volume IV) has been modified to
provide a way for 'INIT' resources to request space in the system heap zone. Whenever
‘INIT’ 31 opens your file of type 'INIT’ or "RDEV'’, it now looks for a resource of type
'sysz' with an ID = 0. The 'sysz' resource can be any size you like, as long as the first
long word contains the number of bytes of system heap space needed by the ‘INIT’
resources in your 'RDEV' or 'INIT' file. 'INIT' 31 calls the SetApplBase procedure as
needed to meet the space request. For each 'INIT' resource loaded from the "RDEV' or
‘INIT’ file, 'INIT' 31 guarantees at least 16K of contiguous space in the system heap.
Although chapter 29 of Volume IV discussed allocation of space from the address
contained in the global variable BufPtr, programmers are encouraged to take advantage of
the 'sysz' resource for the memory needs of their 'INIT' resources.

Timing

Information

At system startup, a number of global variables are initialized with timing information
useful to assembly-language programmers:

Variable

Contents

TimeDBRA

The number of times the DBRA instruction can be executed per
millisecond.
The number of times the SCC can be accessed per millisecond.
—_The number of times the SCSI can be accessed per millisecond.

TimeSCCDB
TimeSCSIDB

Access of the SCC and SCSI chips consists of the following two instructions (where
register AQ points at the base address of the respective chips):
@1

START

BTST

DBRA

#0, (AO)

DO, @1

MANAGER

ROUTINES

The routines described below are used by the Start Manager for configuring the system
startup process. Only a very few advanced programmers who wish to implement a
different operating system on the Macintosh will ever need to use these routines.

V-352 Start Manager Routines

The Start Manager
GetDefaultStartup, SetDefaultStartup, GetTimeout, and Set Timeout are implemented for
both the Macintosh SE and the Macintosh IJ. GetVideoDefault, Set VideoDefault,
GetOSDefault, and SetOSDefault are implemented only on the Macintosh II.
Routine parameters for GetDefaultStartup, SetDefaultStartup, GetVideoDefault,

SetVideoDefault, GetOSDefault, and SetOSDefault are passed and returned using

parameter blocks.

Assembly-language note:

When you call GetDefaultStartup, SetDefaultStartup,

GetVideoDefault, SetVideoDefault, GetOSDefault, and SetOSDefault, AO must point

to a parameter block that will contain the parameters passed to, or returned by, the
routine.

The DefStartRec parameter block used by GetDefaultStartup and SetDefaultStartup has the
following structure:
TYPE

DefStartType

(slotDev,

DefStartRec

=

scsiDev)

;

RECORD
CASE DefStartType
slotDev:

sdExtDevID:
sdPartition:
sdSlotNum:
sdSRsrcID:
scsiDev:
sdReservedl:
sdReserved2:
sdRefNum:

OF

SignedByte;
SignedByte;
SignedByte;
SignedByte;

{external device
{reserved}
{slot number}
{SResourceID}

SignedByte;
SignedByte;
INTEGER

{reserved}
{reserved}
{driver reference
{

number}

ID}

}

END;

DefStartPtr

=

“DefStartRec

The two variants of the StartDevPBRec correspond to two types of devices that can
currently be connected. The slotDev variant contains information about slot devices, while
the scsiDev variant describes a device connected through the SCSI port.

re
PROCEDURE

—

0

«<

2.

e

GetDefaultStartup

sdExtDevID

byte

1

sdPartition

byte

3

sdSRsrcID

byte

sdSlotNum

byte

(paramBlock:

or

DefStartPtr) ;

z

c-

0

sdReservedl

byte

2

«<

2.

sdRefNum_

word

vr

e

1

sdReserved2

byte

GetDefaultStartup returns information about the default startup device from parameter
RAM. To determine which variant to use, you need to look at the sdRefNum field. If this
field contains a negative number, it’s the driver reference number for an SCSI device,

which is all you need to know.

use.)

(SDReserved1 and sdReserved2 are reserved for future

Start Manager Routines V-353

=

=

Inside Macintosh

If sdRefNum contains a positive number, you’ll need to access the information in the

slotDev variant. SDExtDevID is specified by a slot’s driver; it identifies one of perhaps
several devices that are connected through a single slot. SDSlotNum is the slot number

($9 thru E) and sdSRsrcID is the sResource ID; see the Slot Manager chapter for details.
PROCEDURE

—
>
>
>

0
1
2
3

SetDefaultStartup

(paramBlock:

sdExtDevID
byte
sdPartition _ byte
sdSlotNum
byte
sdSRsrcID
byte

or

>
~
=>

DefStartPtr);

0
1
2

sdReservedl
byte
sdReserved2 byte
sdRefNum — word

SetDefaultStartup specifies a device as the default startup device. For a slot device,

sdExtDevID (specified by the slot’s driver) identifies one of perhaps several devices that
are connected through a single slot. SDSlotNum is the slot number

($9 thru E) and

sdSRsrcID is the sResource ID; see the Slot Manager chapter for details.

In the case of an SCSI device, sdRefNum contains the reference number; to specify no

device as default (meaning that the first available device will be chosen at startup), pass 0 in
sdRefNum. SDReserved1 and sdReserved2 are reserved for future use and should be 0.
The GetVideoDefault and SetVideoDefault calls use the following parameter block to pass
information about the default video device:
TYPE

DefVideoRec

=

RECORD
sdSlot:
sdSResource:

SignedByte;
SignedByte;

{slot number}
{sResource ID}

END;

DefVideoPtr

PROCEDURE

Trap macro

=

“DefVideoRec

GetVideoDefault

(paramBlock:

DefVideoPtr) ;

_GetVideoDefault

Parameter block
fo
0 — sdSlot
=
1
sdSResource

byte
_ byte

GetVideoDefault returns the slot number and sResourceID of the default video device. If
eee returns 0, there is no default video device and the first available video device will be
chosen.

V-354 Start Manager Routines

The Start Manager
PROCEDURE

SetVideoDefault

Trap macro

(paramBlock:

DefVideoPtr) ;

_SetVideoDefault

Parameter block
ace
0 — sdSlot
=
]
sdSResource

byte
__ byte

SetVideoDefault makes the device with the given slot number and sResourceID the default
video device.

TYPE

DefOSRec

ll

The GetOSDefault and SetOSDefault calls use the following parameter block to pas
information about the default operating system:
RECORD

sdReserved:
sdoOStType:

END;
DefOSPtr

PROCEDURE

be 0}
type}

(paramBlock:

DefOSPtr);

_GetOSDefault

Parameter block

—
e

{reserved--should
{operating system

“DefOSRec

GetOSDefault

Trap macro

SignedByte;
SignedByte;

QO
1

sdReserved
sdOSType

byte
byte

GetOSDefault returns a value in sdOSType identifying the operating system to be used at
startup. The sdReserved parameter currently returns 0; it’s reserved for future use. This
call is generally used only with partitioned devices containing multiple operating systems;
for more details, see the SCSI Manager chapter in this volume.
PROCEDURE

SetOSDefault

Trap macro

=

DefOSPtr);

_SetOSDefault

Parameter block
Sea

(paramBlock:

0)

]

sdReserved

sdOSType

—

\o
72)
=
=)

byte

=

—

byte

SetOS Default specifies in sdOSType the operating system to be used at startup. The
sdReserved parameter is reserved for future use and should be 0. This call is generally
used only with partitioned devices containing multiple operating systems; for details, see
the SCSI Manager chapter in this volume.

Start Manager Routines V-355

==
_

ge
@
La

4

Inside Macintosh
PROCEDURE

GetTimeout

(VAR

count:

Trap macro

_GetTimeout

On exit

DO: count (word)

INTEGER) ;

Note: The _GetTimeout macro is actually not a trap, but expands to invoke the trap
macro _InternalWait with a routine selector of 0 pushed on the stack.
GetTimeout returns in count the number of seconds the system will wait for the internal
hard disk to respond. A value of 0 indicates the default timeout of 15 seconds.
PROCEDURE

SetTimeout

(count:

INTEGER) ;

Trap macro

_SetTimeout

On entry

DO: count (word)

Note: The _SetTimeout macro is actually not a trap, but expands to invoke the trap
macro _InternalWait with a routine selector of 1 pushed on the stack.
SetTimeout lets you specify in count the number of seconds the system should wait for the
internal hard disk to respond. The maximum value is 31 seconds; a value of 0 indicates the
default timeout of 15 seconds.

V-356 Start Manager Routines

The Start Manager

SUMMARY
Data
TYPE

OF THE START MANAGER

Types
(slotDev,

DefStartType
DefStartPtr
DefStartRec

=
=

scsiDev) ;

“DefStartRec
RECORD
CASE DefStartType
slotDev:

OF

sdExtDevID:
sdPartition:

SignedByte;
SignedByte;

{external device
{reserved}

sdSRsrcID:
scsiDev:
sdReservedl:

SignedByte;

{SResourceID}

sdSlotNum:

sdReserved2:

sdRefNum:

SignedByte;

{slot

number}

SignedByte;

{reserved}

INTEGER

{driver

SignedByte;

ID}

{reserved}
{

number}

reference

}

END;

DefVideoPtr
DefVideoRec

=

=

“DefVideoRec

RECORD

sdSlot:
sdSResource:

SignedByte;
SignedByte;

{slot number}
{sResourceID}

END;

DefOSPtr
DefOSRec

=
=

“DefOSRec
RECORD
sdReserved:
sdoOStType:

SignedByte;
SignedByte;

{reserved--should
{operating
system

be 0}
type}

END;

Routines
PROCEDURE

e
e
oa
-

GetDefaultStartup

Q
1
2
3

PROCEDURE
—>

+
=
—

0
1
2
3.

sdExtDevID
byte
sdPartition _ byte
sdSlotNum
byte
sdSRsrcID
byte

(paramBlock:

or

e

QO
1
2

sdReservedl
sdReserved2
sdRefNum

—

byte
byte
word

‘©
eZ
_
=

a

-_

<
Sy
o>
ge
io)
=
—

—
eal

SetDefaultStartup

(paramBlock:

sdExtDevID
sdPartition _
sdSlotNum
sdSRsrcID

or

byte
byte
byte
byte

DefStartPtr) ;

>
‘=
>

DefStartPtr);

0
1
2

sdReservedl
sdReserved2
sdRefNum

byte
byte
word

Summary of the Start Manager V-357

Inside Macintosh
PROCEDURE

—
<

GetVideoDefault

0
1

PROCEDURE

~

>

0

sdSlot

1

PROCEDURE

aca
a

(paramBlock:

sdReserved
sdOSType

(paramBlock:

GetTimeout

(VAR

PROCEDURE

SetTimeout

(count:

Assembly-Language
of Default

count:

Information
Startup

Device

External device ID (byte)

sdSlotNum

Slot number (byte)

of

Default

Startup

Device

Reserved—should be 0 (byte)

sdRefNum

Driver reference number (word)

sdReserved2

of

sdOSType

Parameter

Block

(SCSI)

Default

Video

Device

Parameter

Slot number (byte)

sdS Resource

sdReserved

(Slot)

Reserved—should be 0 (byte

sdSlot

Structure

Block

SResource ID (byte)

sdReserved1

Structure

Parameter

Reserved—should be 0 (byte)

sdSRsrcID

Structure

INTEGER);

INTEGER) ;

sdExtDevID
sdPartition

DefOSPtr);

byte
byte

PROCEDURE

Structure

DefOSPtr);

byte
byte

SetOSDefault

0
1

DefVideoPtr) ;

byte

GetOSDefault

sdReserved
sdOSType

(paramBlock:

byte

sdSResource

0
1

DefVideoPtr) ;

byte
byte

SetVideoDefault

PROCEDURE

(om

= sdSlot
sdSResource

(paramBlock:

SResource ID (byte)
of

Default

OS

Parameter

Reserved—should be 0 (byte)

Operating system type (byte)

V-358 Summary of the Start Manager

Block

Block

The Start Manager

Routines
Trap macro

On entry

On

_GetVideoDefault

AO: ptr to param block

AO: ptr to param block

_SetVideoDefault

AO: ptr to param block

AO: ptr to param block

_GetOSDefault

AO: ptr to param block

AO: ptr to param block

_SetOSDefault

AO: ptr to param block

AO: ptr to param block

_GetTimeout
_SetTimeout

Exit

DO: count (word)
DO:

count (word)

Note: The GetTimeout and SetTimeout macros expand to invoke the trap macro
_InternalWait with routine selectors of 0 and 1 respectively pushed on the stack.)

Variables
CPUFlag
TimeDBRA
TimeSCCDB
TimeSCSIDB

Microprocessor in use (word)
Number of times the DBRA instruction can be executed per millisecond
(word)
Number of times the SCC can be accessed per millisecond (word)
Number of times the SCSI can be accessed per millisecond (word)

mes

—)

NM
—s

&

=e

—

pw)
=
a
ge
@

be

Summary of the Start Manager V-359

|

20
362
362
363
364
364
364
364
364
365
365
366
366
367
371
371
372

THE

APPLE

DESKTOP

BUS

About This Chapter
About the Apple Desktop Bus
Bus Commands
SendReset
Flush
Listen
Talk
Device Registers
Register 0
Register 3
Device Addressing
Standard ADB Device Drivers
ADB Manager Routines
Writing ADB Device Drivers
Installing an ADB Driver
Summary of the ADB

to
—
>

—
an
4°)

o
@
”

~~

S
s

-_-

=

V-361

=

+ 2)

Inside Macintosh

ABOUT

THIS CHAPTER

This chapter tells you how to accomplish low-level communication with peripheral devices
that are connected to the Apple Desktop Bus (ADB).
Reader’s guide: The standard mouse and keyboard drivers automatically take care
of all required ADB access functions. When the user manipulates the mouse or
keyboard, the system calls the appropriate driver and the application never uses the ADB
Manager. Hence you need the information in this chapter only if you are writing a
special driver, such as a driver for a new user-input device.
The ADB is a simple local-area network that connects low-speed input-only devices to the
operating system. In the Macintosh II and Macintosh SE computers, the ADB is used to
communicate with one or more keyboards, the mouse, and other user input devices.
Keys located on multiple keyboards are distinguished by the keyboard event message, as
described in the Toolbox Event Manager chapter of this volume.
Note: An ADB, using the same operating protocols, is also part of the Apple IIGS
computer.
This chapter contains three principal sections:
m a description of the Apple Desktop Bus and how it works
= adescription of the ADB Manager. This section of system ROM contains the routines
that a driver must use to access devices connected to the ADB.
m a discussion of the special requirements for drivers that support devices connected to
the ADB
You should already be familiar with
a the hardware interface to the Apple Desktop Bus, described in the Macintosh Family
Hardware Reference
m events generated by ADB keyboard devices (described in the Toolbox Event Manager
chapter in this volume) if your driver communicates with one or more keyboards

ABOUT THE APPLE

DESKTOP

BUS

The Apple Desktop Bus connects up to 16 low-speed input-only devices to the Macintosh
II or Macintosh SE computer. Each device can maintain up to four variable-size registers,
whose contents can be read from or written to by the ADB network. Each register may
contain from two to eight bytes. Two of the device registers have an assigned meaning and
a standardized format: register 0, used for interrupt information, and register 3, containing

V-362 About the Apple Desktop Bus

The Apple Desktop Bus

the device’s identification number. The other two device registers have no assigned

meaning, and may have different meanings for read and write operations.

The system communicates with the Apple Desktop Bus through the system’s Versatile

Interface Adapter chip (VIA). The VIA is described in the Macintosh Hardware chapter of

Volume III.

Warning: The ADB does not support connecting a device while the computer is
running. The result may be to reinitialize all devices on the bus without informing the
system.
The system always controls the bus. It issues commands to specific devices on the bus and
they respond by accepting data, sending data, or changing their configuration. These
commands are discussed below.
Note:

Devices connected to the ADB contain their own single-chip

microprocessors, which handle both device routines and the ADB interface. If the
system sends commands to a device with a duty cycle of more than 50%, the
device’s microprocessor may become overloaded.

Bus

Commands

Each bus command consists of a byte that the system sends to a device connected to the
ADB. Applications may place bus commands on the network by calling the routine
ADBOp, discussed under “ADB Manager Routines” later in this chapter. There are four
bus commands; their bit layouts are shown in Figure 1. All other bit layouts are reserved.

3

2

1

0

1

Flush

Network

Address

0

0

0

Listen

Network Address

|

0

Register

Talk

Network

1

1

Register

Address

Figure 1. ADB Command Formats
The individual commands are discussed below.

i)
)

>

wc

gcd
@

o

om

a

a

=

=)

o~)

About the Apple Desktop Bus V-363

=

77)

Inside Macintosh

Warning: Values of the low bytes of the ADB command formats other than those
shown in Figure 1 are reserved, and should not be used.
SendReset

The SendReset command forces a hardware reset of all devices connected to the ADB.
Such a reset clears all pending device actions and places the devices in their startup state.
All devices are able to accept new ADB commands and user inputs immediately thereafter.
All devices ignore the high-order four bits of the SendReset command.
Flush
The Flush command flushes data from the single device specified by the network address
in its high-order four bits. Network addresses are discussed below, under “Device
Addressing”. It purges any pending user inputs and make the device ready to accept new
commands and input data.
Listen
The Listen command is used to send instructions to devices connected to the ADB. It
transfers data from a buffer in system RAM to a register in the device specified by the
network address in its high-order four bits. The device register is specified by the loworder two bits of the Listen command.
Talk
The Talk command is used to fetch user inputs from devices connected to the ADB. It is the
complement of the Listen command. It transfers data from a register in the device specified
by the network address in its high-order four bits to a buffer in system RAM. The device
register is specified by the low-order two bits of the Talk command.

Device

Registers

Each device connected to the ADB contains four registers, each of which may store from
two to eight bytes of data. Each register is identified by the value of the low-order two bits
in a Listen or Talk command. Registers 0 and 3 have dedicated functions; registers 1 and 2
are used for purposes specific to each device, and need not be present in a device.
Note: ADB device registers are virtual registers; they need not be implemented
physically. The device firmware must only respond to register commands as if a
register were present.

V-364 About the Apple Desktop Bus

The Apple Desktop Bus

Register

0

Device register 0 is reserved for input data. If the device has user-input data to be fetched, it
places the data in register 0 and initiates an interrupt. It continues to generate interrupts until
the system retrieves its data. The system responds to data-input interrupts with the
following polling sequence:
¢ It generates a Talk command for register 0 in each device connected to the ADB.
¢ If the device has data to send, it responds.

The system does not poll the next device

until the data is exhausted.

¢ If the device has no data to send, or if its data is exhausted, the VIA generates an

interrupt. The system then polls the next device.

Register

3

Device register 3 is reserved for device identification data and operating flags. Application
programs may set this data with Listen commands and read it with Talk commands.

Register 3 stores 16 bits, divided into the fields shown in Figure 2.
IS

14.3312

11.10.90

0

ce

l

.&

7

0
Device

Handler ID

Reserved
Service Request Enable
Exceptional Event
Figure 2. Format of Device Register 3

Except for commands that contain certain reserved device handler ID values (listed below),

every command to register 3 changes the entire register contents. Hence to change part of
the register, you should first fetch its current contents with a Talk command and then send
it an updated value with Listen. You can change part of the contents of register 3 by using
special device handler ID values, as described below.

The device handler ID field indicates the device’s type. With certain devices, an
application can change the device’s mode of operation by sending it a new ID value. If the
device supports the new mode, it stores the new value in this field.
Warning: You must register new device handler ID values with Apple, so they do
not conflict with the values of other devices that may be connected to the ADB at the
same time.

bt
=

>
<—

i
@

—)
i$")
eZ)
=
—

©
|

a

About the Apple Desktop Bus V-365

7

wn

Inside Macintosh

When certain reserved values are sent to the device handler ID field by a Listen command,

they are not stored in the field; instead, they cause specific device actions. Hence these
values cannot be used as device ID values. They are the following:

Value

Action

$00

Change bits 8—13 of register 3 to match the rest of the command; leave Device
Handler ID value unchanged.

$FD

Change Device Address to match bits 8-11 if the device activator has been
depressed; leave Device Handler ID value and flags unchanged.

$FE

Change Device Address to match bits 8—11 if the result produces no address
duplication on the bus; leave Device Handler ID value and flags unchanged.

$FF

Initiate device self-test. If self-test succeeds, leave register 3 unchanged; if
self-test fails, clear Device Handler ID field to $00.

Other Device Handler ID values may be stored in the field.
Note:

Device Handler ID values below $20 are reserved by Apple.

The Device Address field indicates the device’s location within the 16 possible device
locations of the ADB. An application may change its value with a Listen command. When
this field is interrogated with a Talk command, it returns a random value. This helps you
separate multiple devices that have the same ADB address; for further information, see

“Device Addressing”, below.

The Service Request Enable bit is set by the device to request an interrupt poll.

Device

Addressing

There are 16 possible direct addresses, $00-$0F, for devices connected to the ADB.

However, it is possible to connect more than one device to an address; this might happen,
for example, in a system with two alternate keyboards.
When several devices share a single ADB address, but there are free addresses available in
the net, the system will automatically reassign addresses until they are all different. It will
do this every time the ADB Manager is initiated or reinitiated. To find out a device’s new
address, use the calls GetIndADB or GetADBInfo, described later in this chapter.

Standard

ADB

Device

Drivers

The Macintosh II and Macintosh SE systems contain two standard ADB drivers:
m the mouse driver, which supports the ADB mouse. The Apple mouse normally has an
ADB address of 3.
a the universal keyboard driver, which supports all Apple ADB keyboards. The Apple
keyboard normally has an ADB address of 2, with a Device Handler ID of 1 for the

V-366 About the Apple Desktop Bus

The Apple Desktop Bus

Macintosh II keyboard and 2 for the Apple Extended Keyboard. These keyboards are
described in the Toolbox Event Manager chapter of this volume.
These drivers reside in the system ROM. In addition, ADB address 0 is reserved for the
ADB chip itself. You can change the ADB addresses of the mouse or keyboard, as
described above under “Device Registers”.
Assembly-language note: The ADB address of the keyboard on which the
last-typed character was entered is now stored in the global variable KbdLast. The
type of the keyboard on which the last-typed character was entered is stored in the
global variable KbdType. The value of KbdType is the Device Handler ID value in
Register 3 of the device; values below $20 are reserved by Apple.
The requirements for writing new ADB device drivers are discussed later in this chapter.

ADB MANAGER

ROUTINES

The ADB Manager consists of six routines located in the 256K ROM. You would use them
only if you needed to access bus devices directly or communicate with a special device.
Some of these routines access and update information in the ADB device table, a
structure placed in the system heap by ROM code during system startup. It lists for each
device the device’s type, its original ADB address, its current ADB address, the address of
the routine that services the device, and the address of the area in RAM used for temporary
data storage by its driver. The ADB device table is accessible only through ADB Manager
routines.
PROCEDURE

‘Trap macro

ADBReInit;

_ADBReInit

ADBRelnit reinitializes the entire Apple Desktop Bus. It clears the ADB device table to
zeros and places a SendReset command on the bus to reset all devices to their original
addresses. ADBRelInit has no parameters.
ADBRelnit is intended to be used only by installer programs that permit a new device to be
connected to the ADB while the system is running. Because it does not deallocate ADB
resources on the system heap, ADBRelnit should not be used for routine bus initialization.
ADBRelnit also calls a routine pointed to by the low memory global JADBProc at the
beginning and end of its execution. You can insert your own preprocessing/
postprocessing routine by changing the value of JADBProc; ADBRelnit conditions it by
setting DO to 0 for preprocessing and to 1 for postprocessing. Your procedure must restore

nN
oS
>
<=)

=
@

=)

@

”A

~

——

—)
i)

_—

we

ADB Manager Routines V-367

i
77)

Inside Macintosh

the value of DO and branch to the original value of JADBProc on exit. The complete
ADBRelnit sequence is therefore the following:
a JSR to JADBProc with DO set to 0
m reinitialize the Apple Desktop Bus
= clear the ADB device table
a JSR to JADBProc with DO set to 1
FUNCTION

ADBOp
(data:
Ptr;
compRout:
ProcPtr;
commandNum:
INTEGER)
: OSErr;

Trap macro
On entry:

Ptr;

_ADBOp
AO:

pointer to parameter block

DO:

commandNum (byte)

Parameter block
=
O
buffer
>
4
compRout
->
8
data
On exit:

buffer:

DO:

pointer
pointer
pointer

result code (byte)

The completion routine pointed to by compRout will be passed the following
parameters on entry:
DO:

AO:

commandNum

(byte)

pointer to data stored as a Pascal string (maximum
8 bytes data preceded by one length byte)
Al: pointer to completion routine
A2: pointer to optional data area

ADBOp transmits over the bus the command byte whose value is given by commandNum.
The structure of the command byte is given earlier in Figure 1. ADBOp executes only when
the ADB is otherwise idle; otherwise it is held in a command queue. It returns an error if
the command queue is full. The length of the data buffer pointed to by buffer is contained
in its first byte, like a Pascal string. The optional data area pointed to by data is for local
storage by the completion routine pointed to by compRout.
Result codes

noErr
—1

V-368 ADB Manager Routines

No error
Unsuccessful completion

The Apple Desktop Bus
FUNCTION

CountADBs:

INTEGER;

Trapmacro

_CountADBs

On exit:

DO:

number of devices (byte)

CountADBs returns a value representing the number of devices connected to the ADB by
counting the number of entries in the device table. It has no arguments and returns no error
codes.
FUNCTION

GetIndADB

(VAR

info:

ADBDataBlock;

devTableIndex:

INTEGER)

ADBAddress;

Trapmacro

_GetIndADB

On entry:

AO: pointer to parameter block
DO: entry index number; range = 1..CountADBs (byte)

Parameter block
Q
device type
byte
on
1
original ADB address __ byte
e
2
service routine address __ pointer

e

On exit:

6

data area address

pointer

DO: positive value: current ADB address (byte)
negative value:

error code (byte)

GetIndADB returns information from the ADB device table entry whose index number is
given by devTableIndex. ADBDataBlock has this form:
TYPE

ADBDataBlock
PACKED

=
RECORD

devType:

SignedByte;

{device

type}

origADBAddr:
SignedByte; {original ADB address}
abServiceRtPtr: Ptr;
{service routine address}
dbDataAreaAddr: Ptr
{data area address}
END;

GetIndADB returns the current ADB address of the device. If it is unable to complete
execution successfully, GetIndADB returns a negative value.
tr

=>

>

—

=a)

=)
3°)

a
=
—

=

—

=

ADB Manager Routines V-369

—
”

Inside Macintosh
FUNCTION

GetADBInfo
OsErr;

(VAR

info:

ADBDataBlock;

Trap macro

_GetADBInfo

On entry:

AO: pointer to parameter block
DO:

ADBAddr:

ADBAddress)

ADB address of the device (byte)

Parameter block
i
0
device handler ID
byte
—
1
original ADB address _ byte
oo
2
service routine address _ pointer
—
6
data area address
pointer
On exit:

DO:

result code (byte)

GetADBInfo returns information from the ADB device table entry of the device whose
ADB address is given by ABDAddr. The structure of ADBDataBlock is given above under

“GetIndADB”.
Result codes

FUNCTION

noErr

No error

SetADBInfo
ADBAddress)

(VAR info:
: OsErr;

ADBSetInfoBlock;

Trap macro

_SetADBInfo

On entry:

AO: pointer to parameter block
DO: ADB address of the device (byte)

Parameter block

>
~

0
4

On exit:

— service routine address
data area address

ADBAddr:

pointer
pointer

DO: result code (byte)

SetADBInfo sets the service routine address and the data area address in the ADB device

table entry for the device whose ADB address is given by ABDAddr. ADBSetInfoBlock
has this form:
TYPE

ADBSetInfoBlock

=

RECORD

siServiceRtPtr:

Ptr;

{service

siDataAreaAddr:

Ptr

{data

END;

V-370 ADB Manager Routines

area

routine

address}

address}

The Apple Desktop Bus
Result codes

noErr

No error

Warning: You should send a Flush command to the device after calling it with
SetADBInfo, to prevent it sending old data to the new data area address.

WRITING

ADB DEVICE

DRIVERS

Drivers for devices connected to the ADB have the following special requirements:
m Each ADB device driver must reside in a resource of type 'ADBS'. This type has two
sections: initialization and driver code.
a The initialization section of each ADB device driver must support the installation
procedure described below.
When the system calls an ADB device driver, it passes it the following values:
u Register AO points to the data buffer, which is formatted as a Pascal string.

a Register Al points to the driver’s completion routine.
m Register A2 points to the optional data area.
= Register DO contains the ADB command that resulted in the driver being

called.

The ADB driver should handle the ADB command passed to it and store any resulting input
data by an appropriate action, such as by posting an event or moving the cursor.
Note:

Events posted from keyboards connected to the ADB now have an expanded

structure. For more information, see the Toolbox Event Manager chapter in this

volume.

Installing

an

ADB

Driver

The Start Manager (described in this volume) finds all the ADB devices connected to the
system and places their device types and ADB addresses in the ADB device table. It then
calls the initialization section of each ADB device driver by executing the initialization code
in its 'ADBS' resource.
As a minimum, the initialization section of each ADB device driver must do the following:
m The driver must allocate all the memory required by the driver code in one or more
nonrelocatable blocks in the system heap area.
w The driver must install its own preprocessing/postprocessing routine (if any) as
described above under “ADBRelInit”.

to

u Finally, the driver must initialize the service routine address and data area address of
its entry in the ADB device table, using SetADBInfo.

Ss

7

>

=©

o
©wm

~~

Comal

=)

is |
=~)

Writing ADB Device Drivers V-371

=

DM

Inside Macintosh

SUMMARY
Data
TYPE

OF

THE ADB MANAGER

Types
ADBDataBlock

PACKED

=

RECORD

devType:
origADBAddr:

SignedByte;
SignedByte;

dbServiceRtPtr:

Ptr;

dbDataAreaAddr:

Ptr

{device type}
{original ADB

}

{ address}
{service routine
}
{ address}
{data area address}

END;

ADBSetInfoBlock

=

RECORD

siServiceRtPtr:
siDataAreaAddr:
END;

Ptr;
Ptr

{service routine address}
{data area address}

Routines
Initializing
PROCEDURE

the

ADB

ADBReInit;

Manager
INLINE

Communicating

Through

FUNCTION

ADBOp

(data:

Getting

ADB

FUNCTION
FUNCTION

CountADBs:
GetIndADB

FUNCTION

GetADBInfo

the

Ptr;

commandNum:

Device

$A07B;

ADB
compRout:
INTEGER)

FUNCTION

ADB

Device

SetADBInfo

:

buffer:

OSErr;

Ptr;

Information
INTEGER;
(VAR info:
ADBDataBlock;
INTEGER)
: ADBAddress;
(VAR info: ADBDataBlock;
OsErr;

Setting

ProcPtr;

devTableIndex:
ADBAddr:

ADBAddress)

Information
(VAR info:
ADBSetInfoBlock;
: OsErr;
ADBAddress)

V-372 Summary of the ADB Manager

ADBAddr:

The Apple Desktop Bus

Assembly-Language

Information

Variables
JADBProc
KbdLast
KbdType

Pointer to ADBRelInit preprocessing/postprocessing routine
ADB address of the keyboard last used (byte)
Keyboard type of the keyboard last used (byte)

Routines
Trap macro

On entry

On Exit

AO: pointer to parameter block
buffer (pointer)
compRout (pointer)
data (pointer)
DO: commandNum (byte)

DO:

result code (byte)

DO:

result code (byte)

_ADBRelInit
_ADBOp

_CountADBs
_GetIndADB

AO: pointer to parameter block
device type (byte)
original ADB address (byte)

DO: positive value: current ADB
address (byte)
negative value: error code

(byte)

service routine address (pointer)
data area address (pointer)
DO: entry index number;
range = 1..CountADBs (byte)
_GetADBInfo

AO: pointer to parameter block
device handler ID (byte)
original ADB address (byte)
service routine address (pointer)
DO:

_SetADBInfo

result code (byte)

DO:

result code (byte)

data area address (pointer)

ADB address of the device (byte)

AO: pointer to parameter block

service routine address (pointer)

DO:

DO:

data area address (pointer)
ADB address of the device (byte)

ho

—

>

i)

re
@

i)

@
i? 2)

~~

<s

o
iam]

<=)

Summary of the ADB Manager V-373

=

1? 2)

'S)
——

=}

>

21 FILE MANAGER
SHARED

376

376
377
377

377
378

EXTENSIONS IN A

ENVIRONMENT

About This Chapter

About the File Manager Extensions
Overview of the New File Access Methods
Opening Files

Browsing
Exclusive Access

378
378
379
380
380
381
381

Single Writer, Multiple Readers
Shared Access
Translation of Permissions
The Shared Environment
AppleShare
Resource Availability
Sharing

383
384
384
385
386
387

Sharing Applications
Shared Environment Guidelines
Things to Do
Things to Avoid
The Shared Environment Calls
HFS Support

388
391
392
400

Data Structures
Modified Existing HFS Call
New Shared Volume HFS Calls
Summary of the File Manager Extensions

382

387

fg
=
gS
ge
=

Range Locking

Error Reporting

V-375

Inside Macintosh

ABOUT

THIS CHAPTER

This chapter presents a set of new file access routines that support application execution in
a shared environment. A shared environment can mean a number of workstations
connected to a file server; it can also mean a multitasking operating system or a system
program that allows sharing applications or data. The discussion in this chapter focuses on
AppleShare™. This chapter describes how the old access modes are translated into the

new ones, discusses some aspects of file access implementation in a shared environment,
and presents the format of the routines.

Reader’s guide: Since virtually any application may someday find itself executing in a
shared environment, all developers should have some understanding of the information
in this chapter. Readers should be familiar with the following chapters from /nside

Macintosh:

mw Volume II and V: The AppleTalk Manager
= Volume II and V: The Device Manager
= Volume IV: The File Manager and The Standard File Package
Further information on Apple networking

and file servers may be obtained from

u Inside AppleTalk, Section XI: AppleTalk Session Protocol (ASP)
a AppleTalk Filing Protocol, Version 1.1
mw AppleShare User’s Guide
w AppleShare Administrator’ s Guide

ABOUT THE FILE MANAGER

EXTENSIONS

Warning: Currently, only a startup volume with the AppleShare file located in its
System Folder supports the File Manager extensions. Future versions of the File
Manager may or may not support these calls.
When the File Manager was originally designed, only three file-access modes were thought
to be necessary: read/write, read only, and whatever’s available (of the first two).

These

modes operated under a basic rule of file access known as “single writer and/or multiple
readers”. In a world with file servers and multitasking systems, where more than one
application might have access to a document simultaneously, this rule and these access
modes are not sufficiently flexible.

In addition to specifying the access required by the caller, the new access modes give the
caller the ability to deny access to other users. The new modes are therefore known as deny
modes. They operate by setting bits in the permissions byte instead of using a constant

V-376 About the File Manager Extensions

File Manager Extensions In a Shared Environment
value as a message. The new access modes are implemented by ten new calls and one
modified call (PBGetCatInfo) described later in this chapter.

So that existing applications will work, the external file system used by AppleShare
translates the old modes into the new. For the majority of applications, this translation will
be sufficient.

OVERVIEW

OF THE

NEW

FILE ACCESS

METHODS

This overview first describes the new access modes and how they might be used, and then
how the old permissions are translated into the new.

Opening

Files

The combination of access and deny requests in the new open calls creates four opening
possibilities: browsing, exclusive access, single writer with multiple readers, and multiple
writers. The best way to open a file depends on how the application is going to use it.
Figure 1 charts the opening possibilities, including whether range locking is needed.
(Range locking is described later in this chapter.)
Application

Write

Read

LockRng

browsing only

none allowed

read/

no

none allowed

no

exclusive access
(one at a time)
single writer,

deny write

| read/write/
deny read/deny write

multiple readers

deny write

read/write/

read

yes

shared
(many writers)

read/write

read

yes

Figure 1. Opening Files

Browsing
Browsing is traditional read-only access. Browsing access permits multiple readers but no
writers. Browsing access is useful for common files, such as help files, configuration files
that don’t often change, and dictionaries. Developers may wish to add a “Browse Only”
checkbox to the SFGetFile dialog, so that the user may explicitly open a file in this manner.

Overview of the New File Access Methods V-377

Inside Macintosh

Note that the new deny flags take into account both existing access paths to a file and future
attempts to open new paths. For example, if you attempt to open a file for browsing

(read/deny-write permission), your call will succeed only if no write access paths currently

exist to the file. Also, all future attempts to open the file with write access will fail (with a

message that you already have a read/deny-write path) until you close the first read/denywrite path.
Exclusive

Access

This is the access mode that most unshared-data applications will use. (Most existing
applications use fsCurPerm permissions, which are translated to exclusive access if it’s
available, as described below.)

An exclusive-access open call will succeed only if there are

no existing paths to the file. All future attempts to establish access paths to the file will be
denied until the exclusive-access path is closed.
AppleShare note: an exclusive-access open call will fail if you try to open a path
to a file in a folder to which you do not have both “see files” and “make changes”
privileges. In such a case, you could offer the user the choice of opening a browseonly copy of the file, and try again using browsing access. Or you could attempt
browsing access as soon as exclusive access fails, to avoid offering a choice that
won’t work. If the browsing access fails, report that the file cannot be opened; if it
succeeds, offer the user the browse-only file.

Single

Writer,

Multiple

Readers

This access method allows additional users to gain read-only access to browse a document
being modified by the initial writer. The writer’s application is responsible for rangelocking the file before writing to it, to protect the readers from reading when the file is
inconsistent. Likewise, the reader’s application must explicitly check for errors in reading
os file, to warn the user that the file was in the process of being updated and to try again
ater.
Single writer, multiple readers is a step toward shared data, one that may be easy to
accomplish for existing applications, especially those that are memory based. (A memorybased application is one that, when it opens a document, reads the entire document into
memory. Note that it should not close the document’s file, as this could lead to checkout
problems, as described below under “Network Programming Guidelines”’.)
Shared

Access

Shared access should be used by an application that supports full multi-user access to its
documents. Range locking is needed by each user’s application to prevent other users from
accessing information undergoing change. Each user must check for and handle errors
resulting from other users’ access. Some applications may prefer to use a semaphore to
flag records in a document as checked out, rather than using range locking exclusively.

V-378 Overview of the New File Access Methods

File Manager Extensions In a Shared Environment
Shared access is usually designed into an application. It is not easy to modify an existing
application to support full multi-user access to documents, except for memory-based
applications, as discussed above.
Translation

of

Permissions

AppleShare uses the deny-mode permissions exclusively. So that old applications will
work, the external file system used by AppleShare (on each workstation) translates the
classic permissions into the new permissions.
To keep applications from damaging each other’s files, the basic rule of file access (in
translating permissions for AppleShare volumes) was changed to “single writer OR
multiple readers, but not both.” Because of this change, two applications cannot both have
access to the same file unless both are read only; this eliminates the danger of reading from
a file when it is inconsistent.
Note: This change in the basic rule currently applies only to AppleShare volumes.
Should a future version of the File Manager incorporate this change for local
volumes, then an application expecting to get more than one path to a file (with at
least one read/write) will fail.
Figure 2 shows how the classic permissions described in the File Manager chapter of
Volume IV are translated into the new deny-mode permissions.

Standard HFS Permissions | Deny-Mode Permissions
fsRdPerm (read only)

browsing (read/deny write)

fsRdWrPerm (read/write)
fsWrPerm (write only)
fsCurPerm (whatever's available)

exclusive (read/write/deny read/deny write)
or
browsing (read/deny write)

fsRdWrShPerm (shared read/write)

shared (read/write/deny none)

Figure 2. Access Mode Translations

FsRdPerm acts as you would expect: browsing access is achieved if there is no existing
write access path to the file.
The or in the middle translations means that if the call cannot be completed successfully
with exclusive access, it is automatically retried using browsing access.
For fsCurPerm, this is also what you’d expect: “whatever’s available” has always meant
“read/write if you can, otherwise, read only”. The deny portions of the translation are
important for enforcing the updated basic rule of file access: if there’s an existing read or
write access path to a file being opened with fsCurPerm, the first set of permissions will
fail; the second set, browsing access, will then succeed only if there is no existing write
access path to the file.

Overview of the New File Access Methods V-379

Inside Macintosh
Both fsRdWrPerm and fsWrPerm (which has always been translated into fsRdWrPerm,

since write-only access has little utility) are also retried as read-only, to simulate the case
where a file is being opened from a locked disk. Volume IV points out that fsRdWrPerm is

granted even if the volume is locked, and that an error won’t be returned until a PBWrite

(or SetEOF or PBAllocate) call is made. The same is now true for a read-only folder on an
AppleShare volume. (An exception is that if you eject a disk, you can then write to an open
file on it; changing access privileges of a folder does not change the access established for
an open path to a file in that folder.)

THE SHARED

ENVIRONMENT

A file server such as AppleShare allows users to share data, applications, and disk storage
over a network. A file server is a combination of a computer, special software, and one or
more large-capacity disks attached to other computers via a network. In the file server
context, the other computers are known as workstations.

The computer network allows

communication between the file server and the workstations.
programs, data, and disk storage provided by the file server.

Users have easy access to

AppleShare
The server application available from Apple Computer is AppleShare. Explanation of the
AppleShare file server environment should provide parallels for other shared environments.
Each hard disk attached to the server’s computer is called a file server volume. A selected
server volume will appear on the workstation’s desktop as an icon and can be used just like
any Macintosh disk.
Access to the information contained in folders on the disk can be controlled by use of
access privileges. In the AppleShare file server environment, access privileges control who
has what kind of access to the contents of the folders contained on a volume. The access
privileges are assigned on a folder-by-folder basis. A folder may be kept private, shared
by a group of registered users, or shared with all users on the network.
New users are registered, given passwords, and organized into groups. Users can belong
to more than one group. Information about users and groups is stored in a data base on the
server and is used to determine the access privileges the user or group has when they
access an object on the server. The owner of a folder specifies that folder’s access
privileges for the following user categories:
= Owner—the user who owns the folder (or who currently holds ownership)
ws Group—any group established by the AppleShare administrator (folders have only one
group designation per folder)
m Everyone—every user who has access to the file server (registered users and guests)
m See Folders—see other folders in the folder

V-380 The Shared Environment

nN
pd

2)

File Manager Extensions In a Shared Environment
_m See Files—see the icons and open documents or applications in that folder as well
um Make Changes—create, modify, rename, or delete any file or folder contained in the
particular folder (Note: folder deletion requires other privileges as well.)
An extensive discussion of access privileges can be found in the AppleShare User’ s Guide.

Resource

Availability

The availability of resources in a network or shared environment cannot be assumed.
Certain file system operations taken for granted in a single-user environment must be
monitored to ensure their successful completion, and appropriate error messages should be
returned to the user if they fail. Some examples of failure are
w a file read or write fails because the file has been removed, the file server has been shut
down, or a break in the network has occurred

= creation of a file on the server fails due to an existing duplicate name that is invisible to
the user (it’s in a folder to which the user does not have search access)

w a file cannot be opened for use because another user has already opened the file or the
user does not have the proper access privileges
Preflighting system operations becomes important in the shared environment. Preflighting,
a term derived from the careful world of aviation, means checking the availability of a

resource before you attempt to use it. For example, if an application creates temporary

files, the application should check to see if the names it gives to the temporary files already
exist. If the name already exists, the application can then give the temporary files other
names or warn the user of the impending problem. This example is especially relevant for
computers attached to a network because file storage may not be local to the computer.

Sharing
Sharing may mean sharing both data and the application itself:
mw An example of data file sharing would be a project schedule that would be read by
many users simultaneously but could be updated by only one user at a time.
Simultaneous updates to such a file must be prevented in order to protect the data.
= An example of application file sharing would be a word processor shared as a read
only file among many users. A correctly written application, with a proper site
license, would allow many users to use the same copy of the application at the same
time.
Data files may be shared at the file or subfile level. The latter would be appropriate for
applications such as data bases and spreadsheets in which several parts of the file could be
updated by users simultaneously, but each part of the file can be updated by only one user
at a time.

The Shared Environment V-381

oO
=)
|
iY)
re
@

=y

Inside Macintosh

Range

Locking

Range locking is available through the PBLockRange function (_LockRng macro)
described in Volume IV. By using byte-range locking
m you can lock and unlock ranges within a file at any time while you have it open
mw you can keep other users from reading from or writing to a range
m all range locks set by you are removed automatically when you close the file
The LockRng call locks a range of bytes in an open file opened with shared read/write
permission. Calling LockRng before writing to the file prevents another user from reading
from or writing to the locked range while you are making your changes.
On a file opened with a shared read/write permission, LockRng uses the same parameter
block (HParamBlockRec) as both the Read and Write calls; by calling it immediately before
Read or Write, you can use the information present in the parameter block for the Read or
Write call. When calling LockRng, the ioPosMode field of HParamBlockRec specifies the
position mode; bits 0 and 1 indicate how to position the start of the range.
When your application finishes using the range, be sure it calls UnlockRng to free up that
portion of the file for other users. Since the ioPosOffset field is modified by the Read and
Write calls it must be set up again before making an UnlockRng call.
When updating a particular record and that update affects other records within the file, first
determine the range of bytes affected by the updated information. Then call LockRng to
lock out any other user from accessing this range of data. If the lock request succeeds, the
required changes to the data can be made. Then release the lock and make the data available
to other users again.

If the lock fails, several retries should be done.

After several

unsuccessful retries, an error message could be issued to indicate that the file is busy and
the user should try again later.
To append data to a file, lock a range including the logical end-of-file and the last possible
addressable byte of the file ($7 FFFFFFF-Hex), and then write to that range. This actually
locks a range where data does not exist. Practically speaking, locking the entire unused
addressable range of a file prevents another user from appending data until you unlock it.
To truncate a file, lock the entire file, truncate the data, and then unlock the file. This will

prevent another user from using a portion of the file while you are in the process of
truncating it.

V-382 The Shared Environment

File Manager Extensions In a Shared Environment

Sharing

Applications

The shared environment may involve not only applications that allow multiple access to a
file, but applications that themselves have multiple users. Some definitions may help sort
this out:
a Single-user (private data) applications allow only one user at a time to make changes
to a file.
a Multi-user (shared data) applications allow two or more users to concurrently make
changes to the same file.
a Single-launch applications allow only one user at a time to launch and use a single
copy of the application.
a Multi-launch applications allow two or more users at a time to launch and use a
single copy of the application.
When single-user and multi-user are seen as describing data file sharing modes and singlelaunch and multi-launch describe the launching characteristic of the applications, four
categories of network applications emerge, as shown in Figure 3.

File Sharing Mode
Single User (private)
Multi-User (shared)
=

The single launch / single user | The single launch / single user

oO

application follows

application follows

=
=)

=
pa

H

m

=)

D

>

c
es
2

=

®

=
a

a

Cc
J
yr

c
oO

=
=
<

©
_
ar

iu]

—

Only one user at a time to
launch and use a single copy

of the application

;

@ Only one user at a time to
make changes to a file.
The multi-launch / single user
application follows

Only one user at a time to
launch and use a single copy

of the application

m

Two or more users to
concurrently make changes
to the same file.

| The multi-launch / single user
application follows

=

m

Two or more users to

@

Two or more users to

=
=

m@ Only one user at a time to
make changes to the file.

m

Two or more users to
concurrently make changes
to the same file.

concurrently launch and
use a single copy of the
application

concurrently launch and
use a single copy of the
application

Figure 3. Sharing Applications

The Shared Environment V-383

Inside Macintosh
The multi-user application needs to
= Lock records correctly while they are being modified. Allowing and coordinating
multiple writers to a single document can be accomplished by keeping the document
open while it is in use and by using an open mode in the file system that specifically
allows subsequent users of the document write access.
m Include an update mechanism so that all users of a document receive updates when a
record is changed.
u Use byte-range locking to permit only one writer in a byte range at a time.

The multi-launch application needs to
= Use ResEdit or FEdit to set the multi-launch or shared bit in the application’s finder
information.
= Consider limiting the total number of concurrent users of a given copy of the
application.
Limiting the number of concurrent users requires that the application implement some
method to count the users as they launch and quit the application. Counting can become
complex; for example, counting temporary files is a workable approach, but the temporary
files may not all be in the same place and may in fact be in the user’s boot volumes.
Counting temporary
files would also require checking whether or not the temporary files in
existence were really in use or merely the remnants of a user crash.
One method to make things easier for the programmer is to require that a multi-launch
application be able to create temporary files in the folder containing the application. You
would, of course, have to document this so users would know that the application could
not be launched from a read-only folder.

Shared

Environment

Guidelines

This section contains some do’s and don’t’s for developers working in a network

environment. Keep in mind that for most applications, the translated standard permissions
will work fine.

Things

to Do

1. If using the new calls, try them first.
Structure your code such that you try the new open calls first, then check to see if
paramErr is returned. A paramErr indicates that the file does not reside on a server
volume. If that is the case, make the equivalent old style open call. Attempts to make
the new calls specifyin é a local (non-AppleShare) volume will return a paramErr
indicating that the local file system does not know how to handle the call.
2. Inform the user what access was granted during the open process.
Shared environment applications should respond appropriately to errors returned by
the file system. A more precise error reporting mechanism is used to communicate
between the file server and an application program running in a workstation.

V-384 The Shared Environment

ta

mes

=

File Manager Extensions In a Shared Environment
Applications should be prepared to respond to this error reporting mechanism
correctly.

3. Use the Scrap Manager to access the Scrapbook.
Don’t implement your own scrap mechanism. Use the ROM Scrap Manager so that
resources in the scrap can be shared among applications.
4. Keep program segmentation swapping to a minimum.
The effect of program segmentation swapping is exaggerated when the application is
launched from the file server, because segments are dynamically swapped in over the
network. This can reduce the performance of the file server.

Things

to Avoid

1. An application should not write to itself (either to data or to resource forks).
Applications should not save information by writing into their own file. When
information specific to one user is saved in the the application’s own file and that
application is shared by two or more users, information owned by the first user may
be overwritten by the second user, and so on.
2. Multi-user applications should not use the Resource Manager to structure their data in
a resource fork.
The Resource Manager assumes that when it reads the resource map into. memory

(during OpenResFile), it will be the only one modifying that file. If two write-access
paths existed to a resource fork, neither would have any way of notifying the other
that the file had changed (and in fact, no way to reread the map). If your application
uses resource files for document storage, you cannot share data (for multi-user

access); if you want to create a multi-user or multi-launch version of your application
you must find another way to store your data.

3. Don’t close a file while in the process of making changes to its contents.
An application that opens a file, reads the file’s contents into memory, and then closes
the file, has checked out a copy of the file. After the file is closed, another user can
open the file, read the contents of the file into memory, and then close it. Two copies
of the file are now checked out to two different users. Each user, after changing the
checked-out copy of the file, may decide to save the changes to the original file: user
one opens the file and writes the changes back into the original and closes the file,
then user two does the same thing. The second user’s write operation wipes out the
first. Neither user is aware of what has happened and neither has a way of finding
out.

Applications should keep the file open while in use. This will prevent other users
from obtaining an access path and modifying the file while it’s currently open.
4. Don’t give temporary files fixed names.
Many programs that create and open temporary files give them fixed names. If such
an application is shared by many users, the program may attempt to create temporary
files with duplicate names. One solution is not to create any temporary files on disk,
holding all information in memory. Another is to save them in the System Folder of
the user’s boot volume (startup disk) which is usually available for the System file

The Shared Environment V-385

o

<—

~

=
=
gv
@

=

Inside Macintosh

writing. This solution is not perfect, however, since a person’s boot volume may be a
disk with extremely limited space.
5. Do not directly examine or manipulate system data structures, such as file control
blocks (FCB) or volume control blocks (VCB), in memory.
Use File Manager calls to access FCB and VCB information.

When the application directly examines the list of data structures related to volumes

that are currently mounted without using the appropriate calls to the File Manager, it is

possible that these structures will not accurately reflect the structure of the data on file
server volumes.

To give the file system the opportunity to update information, use Get VolInfo to
determine volume information and GetFCBInfo to determine open file information.
6. The Allocate function is not supported by AppleShare.
Instead, use SetEOF to extend a file by setting the logical end-of-file.

THE SHARED

ENVIRONMENT

CALLS

This section describes the interface to the new calls used in supporting shared
environments. Though the calls are not necessarily specific to AppleShare, the example

descriptions keep the implementation of AppleShare in mind.

For AppleShare startup volumes, these calls get installed by an 'INIT' resource patch
contained within the AppleShare file. This means that only startup volumes with the
AppleShare file located in its System Folder will support the shared environment calls.
Since the patch currently handles only external file system volumes, making the new calls
to local volumes will return with an error; however, the AppleShare external file system
code will get all calls made to AppleShare volumes.

Assembly-language note:

You can invoke each of these routines with a macro,

whose name is presented with the call description. The macros expand to

HFSDispatch ($A260) calls with an index value passed in register DO. (The File
Manager chapter of Volume IV describes how to make HFSDispatch calls.) The
routine selectors are as follows:

V-386 The Shared Environment Calls

nN
—"

a

File Manager Extensions In a Shared Environment
Macro Name

Call number

_GetCatInfo

$09

_GetVolParms

$30

_GetLogInInfo

$31

_GetDirAccess

$32

_SetDirAccess

$33

_MapID

$34

_MapName

$35

_CopyFile
_MoveRename

$36
$37

_OpenDeny
_OpenRFDeny

$38
$39

HFS

=}

&

Support

set the correct parameters, then the volume does not support these new calls.

Making successive PBHGetVolParms calls to each mounted volume is a good way to tell if
any of the volumes support these calls. Once you find a volume that returns noErr to the
call, examine the information to see if that volume supports various functions (such as
access privileges and PBHCopyFile) that you may need.

Reporting

Most error codes returned by these calls map directly into existing Macintosh error equates,
but some cannot, and new error equates have been defined for them:
VolGoneErr

AccessDenied
DenyConflict
NoMoreLocks
RangeNotLocked
RangeOverlap

—124

<p=)
rT
o)
=

The simplest way to determine if your HFS supports these new calls is to make the
PBHGetVolParms call to a mounted volume. If a paramErr error is returned and you have

Error

oO

Connection to the server volume has been disconnected, but the VCB

is still around and marked offline.
—5000
The operation has failed because the user does not have the correct
access to the file/folder.
—5006
The operation has failed because the permission or deny mode
conflicts with the mode in which the fork has already been opened.
-5015 _ Byte range locking has failed because the server cannot lock any
additional ranges.
-—5020
User attempted to unlock a range that was not locked by this user.
—5021
User attempted to lock some or all of a range that is already locked.

The Shared Environment Calls V-387

Inside Macintosh

The AppleTalk AFP protocol returns errors in the range of -S000 to -5030. Since it is
possible, though unlikely, to receive error codes in this range, it would be wise to handle
these undocumented error codes in a generic fashion. If you require it, the complete list of
these error codes can be found in the AppleTalk AFP Protocol specification document.
Data

Structures

Some of the new data structures used by these calls are described below. Specific
information about the placement and setting of parameters is described with the call.
For PBHGetLogInInfo, ioObjType contains the log in method, where the following values
are recognized:
1
2
3
4-127

128-255

guest user
registered user—clear text password
registered user—scrambled password
reserved by Apple for future use
user-defined values

For PBHMapName and PBHMapID, ioObjType contains a mapping code. The
PBHMapID call recognizes these codes:
1
2

map owner ID to owner name
map group ID to group name

and MapName recognizes these codes:
3
4

map Owner name to owner ID
map group name to group ID

For PBHGetDirAccess and PBHSetDirAccess, ioACAccess is a long integer that contains

access rights information in the format uueeggoo, where uu = user’s rights, ee =
everyone’s rights, gg = group’s rights, and 00 = owner’s rights.
Note:

In AppleShare 1.0 and 1.1, the Write bit represents Make Changes

privileges, the Read bit represents See Files privileges, and the Search bit represents
See Folders privileges.

Unused bits should always be cleared. A pictorial representation is shown in Figure 4
(high-order bit on the left).

V-388 The Shared Environment Calls

nN
—

a

File Manager Extensions In a Shared Environment
,

Oo
i

|

eS)

directory owner

ge

i.

=y

X1O/0O/}0]

0]

xX]

xX]

xX

01}0/0]0]

0]

xX]

xX]

x

User’s rights
Everyone’s rights

0};0}0]}0]0]|

xX]

xX]

x

Group’s rights

0O|}O0|}0/0]

XxX]

xX]

X

Owner’s rights

t

|

Write
Read

0]

Search

Figure 4. Access Rights in loACAccess
Bit

7
6—3

2

1
0

If set, user is not the owner of the directory.
If clear, user is the owner of the directory.
Reserved; this is returned set to zero.

If set, user does not have Write privileges to the directory.
If clear, user has Write privileges to the directory.
If set, user does not have Read privileges to the directory.
If clear, user has Read privileges to the directory.
If set, user does not have Search privileges to the directory.
If clear, user has Search privileges to the directory.

The User’s rights information is the logical OR of Everyone’s rights, Group’s rights, and
Owner’s rights. It is only returned from the GetDirAccess call; it is never passed by the
SetDirAccess call. Likewise, the Owner bit is only returned in the GetDirAccess call. To
change a folder’s owner, you must change the Owner ID field of the SetDirAccess call.
For PBHOpenDeny and PBHOpenRFDeny, ioDenyModes contain a word of permissions
information, as pictured in Figure 5 (high order bit on the left).
01010/0/}0/0/0)}0/0]/0]}
xX} x] O]| OT XTX
deny other writers

4

it

deny other readers
request write permission

request read permission

Figure 5. Permission Bits
15-6
OrwhN

Bit

—2

Reserved; this should be set to zero.
If set, deny other writers to this file.
If set, deny other readers to this file.
Reserved; this should be set to zero.

If set, requesting write permission.
If set, requesting read permission.

The Shared Environment Calls V-389

Inside Macintosh

For PBGetCatInfo, ioACUser (a new byte field) returns the user’s access rights

information for a directory whose volume supports access controls in the format shown in
Figure 6.

_

directory owner

x}O0}0/0]
0] xX] xX] x

write privileges
read privileges
search privileges
Figure 6. Access Rights in ioACUser

Bit

7

If set, user is not the owner of the directory.
If clear, user is the owner of the directory.
Reserved; this is returned set to zero.

6-3

2

If set, user does not have Write privileges to the directory.

If clear, user has Write privileges to the directory.
If set, user does not have Read privileges to the directory.
If clear, user has Read privileges to the directory.
If set, user does not have Search privileges to the directory.
If clear, user has Search privileges to the directory.

l
0

HParamBlockRec, described in the File Manager chapter of Volume IV, has been extended
by the addition of AccessParam, ObjParam, CopyParam, and WDParam, as shown below.
(The complete HParamBlockRec data type is shown in the summary.)
AccessParam:

(filler3:
ioDenyModes:
filler4:
filler5:
ioACUser:
filleré:

INTEGER;
INTEGER;
INTEGER;
Signed Byte;
Signed Byte;
LONGINT;

ioACGroupID:

LONGINT;

ioACOwnerID:

ioACAccess:

ObjParam:
(filler7:
ioObjType:
ioObjNamePtr:
ioObjID:
ioReqCount

ioActCount

:

:

LONGINT;
LONGINT)

INTEGER;
INTEGER;
Ptr;
LONGINT ;

LONGINT ;

LONGINT)

CopyParam:
(i1oDstVRefNum: INTEGER;
fillers:
INTEGER;
ioNewName:
Ptr;

ioCopyName:

;

{access

rights

data}

{access

rights

for

{owner

ID}

{access

rights}

{group

directory

ID}

{function code}
{ptr to returned creator/group
{creator/group ID}
;

Ptr;

V-390 The Shared Environment Calls

{size

of

{length

buffer

of

{destination
{ptr

{ptr

only}

to

to

vol

area}

parms

vol

identifier}

destination

optional

data}

pathname}

name}

name}

File Manager Extensions In a Shared Environment
ioNewDirID:

LONGINT)

(filler9:
ioWDIndex:
ioWDProcID:

INTEGER;
INTEGER;
LONGINT;

WDParam:

1oWDVRefNum:

ID}

LONGINT;
LONGINT) ;

Existing

HFS

Call

PBGetCatiInfo(paramBlock:

OSErr;

Trap macro

directory

INTEGER;
LONGINT;
LONGINT;

fillerl3:
1LOWDDirID:

FUNCTION

{destination

INTEGER;

fillerl0:
fillerlil:
fillerl2:

Modified

;

CInfoPBPtr;

aSync:

BOOLEAN) :

_GetCatInfo

Parameter block
om

31

ioACUser

byte

access rights for directory only

PBGetCatInfo returns information about the file and directories in a file catalog. See the
File Manager chapter of Volume IV for the exact format of the parameter block.
For server volume directories, in addition to the normal return parameters the ioACUser

field returns the user’s access rights in the following format:
Bit

7
6-3

2
l
0

if set, user is not the owner of the directory.
if clear, user is the owner of the directory.
Reserved; this is returned set to zero.

If set, user does not have Make Changes privileges to the directory.
If clear, user has Make Changes privileges to the directory.
If set, user does not have See Files privileges to the directory.
If clear, user has See Files privileges to the directory.
If set, user does not have See Folders privileges to the directory.
If clear, user has See Folders privileges to the directory.

For example, if ioACUser returns zero for a given server volume directory, you know that
the user is the owner of the directory and has complete privileges to it.

The Shared Environment Calls V-391

Inside Macintosh

New

Shared

Volume

HFS

(paramBlock:

PBHGetVolParms

FUNCTION

Calls
HParmBlkPtr;

async:

BOOLEAN):

OSErr;

Trap macro

_GetVolParms

Parameter block
am
.>
>
-

12
16
18
Due
32

ioCompletion
ioResult
ioFileName
ioVRefNum
ioBuffer

long
optional completion routine ptr
word error result code
long
volume name specifier
word volume refNum
long _ ptr to vol parms data

e

40

ioActCount

long

>

36

ioReqCount

long _ size of buffer area

length of vol parms data

The PBHGetVolParms call is used to return volume level information. ioVRefNum or
ioFileName contain the volume identifier information. ioReqCount and ioBuffer contain

the size and location of the buffer in which to place the volume parameters. The actual size
of the information is returned in ioActCount.

The format of the buffer is described below. Version (1 of the buffer is shown below
along with offsets into the buffer and their equates:
offset

0

vMVersion

6

vMLocalHand long

2

10

vMAttrib

vMServerAdr

word
long

long

version number (currently 01)
attributes (detailed below)

handle used to keep information necessary
for shared volumes
AppleTalk server address (zero if not supported)

On creation of the VCB (right after mounting), vMLocalHand will be a handle to a 2 byte
block of memory. The Finder uses this for its local window list storage, allocating and
deallocating memory as needed. It is disposed of when the volume is unmounted.
For AppleTalk server volumes, vMServerAdr contains the AppleTalk internet address of
the server. This can be used to tell which volumes are for which server.
vMAttrib contains attributes information (32 flag bits) about the volume.
their equates are defined as follows:
bit

31

bLimitFCBs

30

~=— bLocalWList

29
28

~bNoMiniFndr
bNoVNEdit

27

~bNoLclSynce

These bits and

If set, Finder limits the number of FCBs used during

copies to 8 (instead of 16).
If set, Finder uses the returned shared volume handle for
its local window list.
If set, Mini Finder menu item is disabled.
If set, volume name cannot be edited.

If set, volume’s modification date is not set by any

Finder action.

V-392 The Shared Environment Calls

tw
=)

File Manager Extensions In a Shared Environment

26

bTrshOffLine

25

bNoSwitchTo

24-21

20
19

bNoDeskItems
bNoBootBlks

18

bAccessCntl

If set, anytime volume goes offline, it is zoomed to the

Trash and unmounted.
If set, Finder will not switch launch to any application on
the volume.
Reserved—server volumes should return these bits set,
all other disks should return these bits cleared.
If set, no items may be placed on the Finder desktop.

If set, no boot blocks on this volume—not a startup

volume. SetStartup menu item will be disabled;
bootblocks will not be copied during copy operations.
If set, volume supports AppleTalk AFP access control
interfaces. The calls GetLoginInfo, GetDirAccess,
SetDirAccess, MapID, and MapName are supported.

Special folder icons are used. Access Privileges menu

17

bNoSysDir

16

bExtFS Vol

15

bHasOpenDeny

14

bHasCopyFile

13
12

bHasMoveRename
bHasNewDesk

write/deny read and write.

If set, CopyFile call supported. _CopyFile is used in
copy and duplicate operations if both source and
destination volumes have same server address.
If set, MoveRename call supported.
If set, all of the new desktop calls are supported (for
example, OpenDB, AddIcon, AddComment).

Reserved—these bits should be returned cleared.

11-0
FUNCTION

item is enabled for disk and folder items. The privileges
field of GetCatInfo calls are assumed to be valid.
If set, volume doesn’t support a system directory; no
switch launch to this volume.
If set, this volume is an external file system volume.
Disk init package will not be called. Erase Disk menu
item is disabled.
If set, supports _OpenDeny and _OpenRFDeny calls.
For copy operations, source files are opened with enable
read/deny write and destination files are opened enable

PBHGetLoginInfo
; OSErr;

Trap macro

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_GetLogInInfo

Parameter block

~
on
=
oo
é-

12
16
22
26
28

ioCompletion
ioResult
ioVRefNum
ioObjType
ioObjNamePtr_

long
word
word
word
long

optional completion routine ptr
error result code
volume refNum
log in method
ptr to log in name buffer

The Shared Environment Calls V-393

oD
9
=
fo
ge
©

bere |

Inside Macintosh

PBHGetLogInInfo returns the method used for log-in and the user name specified at log-in

time for the volume. The log-in user name is returned as a Pascal string in ioObjNamePtr.
The maximum size of the user name is 31 characters. The log-in method type is returned in
ioObjType.
FUNCTION

PBHGetDirAccess
OSErr;

‘Trap macro

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN) :

_GetDirAccess

Parameter block
=>
e
>
=
=
on

on
>

12
16
18
22
36
40

ioCompletion
ioResult
ioFileName
ioVRefNum
ioACOwnerID
ioACGroupID

44
48

long
word
long
word
long
long’

ioACAccess
ioDirID

long
long

optional completion routine ptr
error result code
directory name
volume refNum
ownerID
group ID

access rights
directory ID

PBHGetDirAccess returns access control information for the folder pointed to by the
ioDirID/ioFlleName pair. ioACOwnerID will return the ID for the folder’s owner.
ioACGroupID will return the ID for the folder’s primary group. The access rights are
returned in ioACAccess.

A fnfErr is returned if the pathname does not point to a valid directory. An AccessDenied
error is returned if the user does not have the correct access rights to examine this directory.
FUNCTION

PBHSetDirAccess

:

OSErr;

Trap macro

(paramBlock:

HParmBlkPtr;

async:

_SetDirAccess

Parameter block
>
—
>
>
>
3
>
~

12
16
18
22
36
40
44
48

ioCompletion
ioResult
ioFileName
ioVRefNum
ioACOwnerID
ioACGroupID
ioACAccess
ioDirID

V-394 The Shared Environment Calls

long
word
long
word
long
long’
long
long

optional completion routine ptr
error result code
pathname identifier
volume refNum
ownerID
group ID
access rights
directory ID

BOOLEAN)

')
ae

=}

File Manager Extensions In a Shared Environment
PBHSetDirAccess allows you to change the access rights to a folder pointed to by the

ioFileName/ioDirID pair. [OACOwnerID contains the new owner ID. IOACGroupID

contains the group ID. IOACAccess contains the folder’s access rights. You cannot set the
owner bit or the user’s rights of the directory. To change the owner or group, you should
set the iocACOwnerID or ioACGroupID field with the appropriate ID of the new
Owner/group. You must be the owner of the directory to change the owner or group ID.
A fnfErr is returned if the pathname does not point to a valid directory. An AccessDenied
error is returned if you do not have the correct access rights to modify the parameters for
this directory. A paramErr is returned if you try to set the owner bit or user’s rights bits.
FUNCTION

PBHMapID

Trap macro

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN):

OSErr;

_MapID

Parameter block
aa
e
=
>

12
16
18
22

ioCompletion
ioResult
ioFileName
ioVRefNum

long
word
long
word

optional completion routine ptr
error result code
pathname identifier
volume refNum

—
_

28
32

ioObjNamePtr_
ioObjID

long
long

ptr to retrnd creator/group name
_creator/group ID

>

26

ioObjType

word

function code

PBHMapID returns the name of a user or group given its unique ID. IOObjID contains the
ID to be mapped. The value zero for ioObjID is special cased and will always return a NIL
name. AppleShare uses this to signify <Any User>. IOObjType is the mapping function
code; it’s 1 if you’re mapping an owner ID to owner name or 2 if you’re mapping a group
ID toa group name. The name is returned as a Pascal string in ioObjNamePtr. The
maximum size of the name is 31 characters.
A fnfErr is returned if an unrecognizable owner or group ID is passed.
FUNCTION

PBHMapName
OSErr;

Trap macro

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_MapName

Parameter block
>
om
>
>

12
16
18
22

ioCompletion
ioResult
ioFileName
ioVRefNum

long
word
long
word

optional completion routine ptr
error result code
volume identifier (may be NIL)
volume refNum

The Shared Environment Calls V-395

Oo
=—

fo
=
>
ga
iS
be

|

Inside Macintosh

>
—
—

ioObjNamePtr
ioObjType
ioObjID

28
26
32

long
word
long

owner or group name
function code
_creator/group ID

PBHMapName returns the unique user ID or group ID given its name. The name is passed
as a string in ioObjNamePtr. If a NIL name is passed, the ID returned will always be zero.
The maximum size of the name is 31 characters. IOObjType is the mapping function code;
it’s 3 if you’re mapping an owner name to owner ID or 4 if you’re mapping a group name
to a group ID. IOObjID will contain the mapped ID.
A fnfErr is returned if an unrecognizable owner or group name is passed.
FUNCTION

PBHCopyFile

OSErr;

Trap macro

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_CopyFile

Parameter block
>
ce
>
>
~
>
_

12
16
18
22
24
28
32

ioCompletion
ioResult
ioFileName
ioVRefNum
ioDstVRefNum
ioNewName
ioCopyName

long
optional completion routine ptr
word error result code
long _ ptr to source pathname
word source vol identifier
word destination vol identifier
long
ptr to destination pathname
long __s ptr to optional name (may be NIL)

>

48

ioDirID

long

+

36

ioNewDirID

long

destination directory ID
source directory ID

PBHCopyFile duplicates a file on the volume and optionally renames it. It is an optional
call for AppleShare file servers. You should examine the returned flag information in the
PBHGetVolParms call to see if this volume supports CopyFile.
For AppleShare file servers, the source and destination pathnames must indicate the same
file server; however, it may point to a different volume for that file server. A useful way to
tell if two file server volumes are on the same file server is to make the GetVolParms call
and compare the server addresses returned. The server will open source files with
read/deny write enabled and destination files with write/deny read and write enabled.
IOVRefNum contains a source volume identifier. The source pathname is determined by
the ioFileName/ioDirID pair. I[ODstVRefNum contains a destination volume identifier.
AppleShare 1.0 required that it be an actual volume reference number; however, on future
versions it can be a WDRefNum. The destination pathname is determined by the
ioNewName/ioNewDirID pair. IOCopyName may contain an optional string used in
renaming the file. If it is non-NIL then the file copy will be renamed to the specified name
in ioCopyName.

V-396 The Shared Environment Calls

tw
=

File Manager Extensions In a Shared Environment
A fnfErr is returned if the source pathname does not point to an existing file or the
destination pathname does not point to an existing directory. An AccessDenied error is
returned if the user does not have the right to read the source or write to the destination. A
dupFnErr is returned if the destination already exists. A DenyConflict error is returned if
ae the source or destination file could not be opened under the access modes described
above.
FUNCTION

PBHMoveRename
OSErr;

Trap macro

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_MoveRename

Parameter block

>

~
aaa
>
>
~
>

12

16
18
22
28
32
36
48

ioCompletion
ioResult
ioFileName
ioVRefNum
ioNewName
ioBuffer
ioNewDirID
ioDirID

long

optional completion routine ptr

word error result code
long
ptr to source pathname
word
source vol identifier
long _ ptr to destination pathname
long _ ptr to optional name (may be NIL)
long
destination directory ID
long
source directory ID

PBHMoveRename allows you to move (not copy) an item and optionally to rename it. The
source and destination pathnames must point to the same file server volume.
IOVRefNum contains a source volume identifier. The source pathname is specified by the
ioFileName/ioDirID pair. The destination pathname is specified by the ioNewName/
ioNewDirID pair. IOBuffer may contain an optional string used in renaming the item. If it
is non-NIL then the moved object will be renamed to the specified name in ioBuffer.
A fnfErr is returned if the source pathname does not point to an existing object. An
AccessDenied error is returned if the user does not have the right to move the object. A
dupFnErr is returned if the destination already exists. A badMovErr is returned if an
attempt is made to move a directory into one of its descendent directories.
FUNCTION

Trap macro

PBHOpenDeny
OSErr;

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN):

_OpenDeny

The Shared Environment Calls V-397

==
o
£9
=
£9
ge
©
seer

|

Inside Macintosh

Parameter block
~
oa
~
>
e
—
3

12
16
18
22
24
26
48

ioCompletion
ioResult
ioFileName
ioVRefNum
ioRefNum
ioDenyModes
ioDirID

long
optional completion routine ptr
word error result code
long _ ptr to pathname
word vol identifier
word file refNum
word access rights data
long
directory ID

PBHOpenDeny opens a file’s data fork under specific access rights. It creates an access
path to the file having the name pointed to by ioFileName/ioDirID. The path reference
number is returned in ioRefNum.
IODenyModes contains a word of access rights information.
rights is:
15-6

Reserved—should be cleared.
If set, other writers are denied access.
If set, other readers are denied access.
Reserved—should be cleared.

WwhMN

bits

The format for these access

—2

Or

If set, write permission requested.
If set, read permission requested.

A fnfErr is returned if the input specification does not point to an existing file. A permErr
is returned if the file is already open and you cannot open it under the deny modes that you
have specified. An opWr Err is returned if you have asked for write permission and the file
is already opened by you for write. The already opened path reference number is returned
: ioRefNum. An AccessDenied error is returned if you do not have the right to access the
ile.
FUNCTION

PBHOpenRFDeny

OSErr;

Trap macro

(paramBlock:

HParmBlkPtr;

async:

_OpenRFDeny

Parameter block
->
oa
>
>
on
>
>

12
16
18
22
24
26
48

ioCompletion
ioResult
ioFileName
ioVRefNum
ioRefNum
ioDenyModes
ioDirID

V-398 The Shared Environment Calls

long
word
long
word
word
word
long

optional completion routine ptr
error result code
ptrto pathname
vol identifier
file refNum
access rights data
directory ID

BOOLEAN)

File Manager Extensions In a Shared Environment
PBHOpenRFDeny opens a file’s resource fork under specific access rights. It creates an
access path to the file having the name pointed to by ioFileNamefioDirID. The path
reference number is returned in ioRefNum. The format of the access rights data contained

in ioDenyModes is described under the OpenDeny call.

A fnfErr is returned if the input specification does not point to an existing file. A permErr
is returned if the file is already open and you cannot open it under the deny modes that you
have specified. An opWrErr is returned if you have asked for write permission and the file
is already opened by you for write. The already-opened path reference number is returned
in ioRefNum. An AccessDenied error is returned if you do not have the right to access the
file.

The Shared Environment Calls V-399

Inside Macintosh

SUMMARY
Result

OF THE

FILE MANAGER

EXTENSIONS

Codes

Name

Value

Meaning

VolGoneErr

—124

AccessDenied

-—5000

Connection to the server volume has been disconnected, but the
VCB is still around and marked offline.

DenyConflict

| -—5006

NoMoreLocks

-5015

RangeNotLocked —5020
RangeOverlap

-5021

The operation has failed because the user does not have the
correct access to the file/folder.

The operation has failed because the permission or deny mode
conflicts with the mode in which the fork has already been
opened.
Byte range locking has failed because the server cannot lock any
additional ranges.
User has attempted to unlock a range that was not locked by this
user.
User attempted to lock some or all of a range that is already
locked.

Constants

;

Bits

in

vMAttrib

about

bHasNewDesk

-EQU

12

bHasMoveRename
bHasCopyFile

.EQU
-EQU

13
14

bHasOpenDeny

-EQU

15

the

;If set,
all of the new desktop calls are
; supported
(for example,
OpenDB,
AddIco,
; AddComment).

;If set, _MoveRename call supported.
;If set, _CopyFile call supported.
; _CopyFile is used in copy and duplicate

; operations
if both source and
; destination volumes have same server
; address.
;If set,
supports OpenDeny and
_OpenRFDeny calls.
Fd;
For copy operations,
7
,
,

bEXtFSVol1

-EQU.

16

-EQU

17

source files are opened with enable
read/deny write and destination files
are opened enable write/deny read and

write.
;I£f set,
; system

,
’

;

bNoSysDir

volume

not

be

this volume is an
Disk init
volume.

called.

; disabled.
7If set,
volume
directory;
no
; volume.

V-400 Summary of the File Manager Extensions

Erase

Disk

external file
package will

menu

item

is

doesn't
support a system
switch launch to this

bo

—

<

o

File Manager Extensions In a Shared Environment
;

GetLogininfo,

;
;

enabled for disk
privileges
field

;
;
;

bNoBootBlks

-EQU

;

19

assumed

;

item

will

;

Finder

;

any

bNoDeskItems

-EQU

20

bNoSwitchTo

-EQU

25

;If

set,

bTrshOffLine

-EQU

26

;If

set,

-EQU

27

bNoVNEdit
bNoMiniFndr

-EQU
-EQU

28
29

bLocalWList

-EQU

30

bLimitFCBs

-EQU

31

Data

be

valid.

be

disabled;

on this volume-SetStartup menu

boot

blocks

will

copied during copy operations.
no items may be places on the

desktop
Finder

application
anytime

will

not

on

the

volume

switch

volume.

goes

launch

offline,

is zoomed to the Trash and unmounted
;If set, volume's modification date is
; set by any Finder action.

to
it

.
,

not

;If set,
volume name cannot be edited.
;If set, MiniFinder menu item is
; disabled.
;If set,
Finder uses the returned shared
; volume handle for its local window list.
;If set,
Finder limits the number of FCBs

;

used

during

file

system}

copies

to

8

(instead

of

16).

or

none}

Types

HParamBlockRec

{12

to

and folder items.
The
of GetCatInfo calls are

;I£ set,
no boot blocks
; not a startup volume.
; not be
;If set,

bNoLclSync

GetDirAccess,

SetDirAccess, MapID, and MapName are
supported. Special folder icons are
used. Access Privileges menu item is

byte

header

=

qLink:
qType:

header

by

the

QElemPtr;
INTEGER;

ioTrap:
ioCmdAddr:

{common

RECORD

used

INTEGER;
PEx;

to

ioCompletion:

all

variants}

ProcPtr;

{completion

StringPtr;

{ptr

ioResult:

OSErr;

ioVRefNum:

INTEGER;

ioNamePtr:

{different
components
CASE ParamBlkType
OF
IOParam:

for

the

{result

to

{volume
different

code}

routine,

NIL

if

pathname}
refnum}

type

of

parameter

blocks}

(ioRefNum:
ioVersNum:
ioPermssn:
ioMisc:

INTEGER;
SignedByte;
SignedByte;
Ptr;

ioBuffer:

Ptr;

{refNum for I/O operation}
{version number}
{Open: permissions
(byte) }
{HRename:
new name}
{ HOpen: optional ptr to buffer}
{data buffer Ptr}

ioActCount:
ioPosMode:

LONGINT;
INTEGER;

{actual byte count completed}
{initial file positioning}

ioReqCount:

ioPosOffset:

LONGINT;

LONGINT)

{requested

;

{file

byte

position

count}

offset}

Summary of the File Manager Extensions V-40]

=

f>
=
eS
tf
c)
“

Inside Macintosh
FileParam:
(ioFRefNum:
ioFVersNum:
fillerl:
ioFDirIndex:
ioFlAttrib:
ioFlVersNum:
ioFlFndriInfo:

ioDirID:

ioF1StBlk:

INTEGER;

{reference
number}
{version number,
normally

INTEGER;

{HGetFInfo
directory
index}
in-use bit=7,
{HGetFInfo:
lock

SignedByte;
SignedByte;
SignedByte;
SignedByte;

INTEGER;

ioF1lRLgLen:
ioF1RPyLen:
ioFlCrDat:

LONGINT;

LONGINT;
INTEGER;
LONGINT;
LONGINT;

ioVClpSiz:
ioA1B1St:

INTEGER;

ioVBitMap:

ioAllocPtr:
ioVNmAL1Blks:
ioVA1LB1kSiz:

LOVNXtCNID:
ioVFrBlk:

LONGINT;
INTEGER;

iovSigWord:

INTEGER;
INTEGER;
INTEGER;
INTEGER;

ioVDrvinfo:
ioVDRefNum:
ioVFSID:

LONGINT;

iovSeqNum:

INTEGER;

ioVvWrCnt:

LONGINT;
LONGINT;
LONGINT;

ioVFilCnt:

iovDirCnt:
iovFndriInfo:

ARRAY

GetFInfoz}

(filler3:

filler4:
fillerS:
ioACUser:

{HGetViInfo:
{HGetVInfo:
{HGetViInfo:
{ time}

{starting

date

num

and

blks

alloc

blk

bytes

to

(of

}

time}

was

flushed}

alloc

byte

size}

allocate

disk(512-byte)

{volume signature}
{drive number}
{driver refNum}
{ID of file system

size) }

at

block

a

in

}

}

handling

volume }

this

{ volume set}
{volume write count}
{volume
file count}

{volume
OF

INTEGER;

Byte;
Byte;

directory

LONGINT);

count}

{Finder

{access

rights

data}

{access

rights

for

V-402 Summary of the File Manager Extensions

info.

for

directory

volume}

only}

}

}

{last backup date
(0 if never backed
{ up) }
{sequence number of this volume in }

INTEGER;

Signed
Signed

}

{ block map}
{HGetVinfo:
next
free
file number}
{HGetVInfo:
# free alloc blks
for this
{ vol}

[1..8]

INTEGER;

bit=0}

by

{volume attrib}
{number of files in directory}
{start block of volume bitmap}
{HGetViInfo:
length of dir in blocks}

AccessParam:

ioDenyModes:

returned

{volume
index number}
{creation
date and time}
{last date and time volume

{

ioVBkUp:

number

{ in secs)}
{last modified

LONGINT) ;
LONGINT;
INTEGER;
LONGINT;
LONGINT;
INTEGER;
INTEGER;
INTEGER;
INTEGER;
INTEGER;
LONGINT;
LONGINT;

version

{information used by the Finder}
{directory ID}
{start file block
(0 if none) }
{logical length
(EOF) }
{physical length}
{start block rsrc fork}
{file logical length rsrc fork}
{file physical length rsrce fork}
{file creation date & time
(32 bits

LONGINT;
LONGINT;

ioF1MdDat:
VolumeParam:
(filler2:
ioVolIndex:
iovCrDate:
ioVLsMod:
ioVAtrb:
ioVNmF ls:

{

Finfo;

ioFlLgLen:
ioF1lPyLen:

ioF1RStBlk:

{file

0}

}

nN
—

7)

File Manager Extensions In a Shared Environment

o

=

&

i)

filler6:
ioACOwnerID:

ioACGroupID:
ioACAccess:
ObjParam:

{owner

LONGINT;
LONGINT) ;

(filler?7:

fc)
ee

ID}

{group ID}
{access rights}

INTEGER;

ioObjType:
ioObjNamePtr:
ioObjID:
ioReqCount :
ioActCount:

INTEGER;
Ptr;
LONGINT;
LONGINT;
LONGINT) ;

{function code}
{ptr to returned creator/group
{creator/group ID}
{size of buffer area}
{length of vol parms data}

(ioDstVRefNum:

INTEGER;

{destination

fillers:

INTEGER;

CopyParam:

ioNewName:
ioCopyName:

Ptr;
Ptr;

ioNewDirID:
WDParam:
(filler9:

LONGINT)

{ptr
{ptr

;

to
to

vol

name}

identifier}

destination pathname}
optional name}

{destination

directory

ID}

INTEGER;

ioWDIndex:
ioWDProcID:

INTEGER;
LONGINT;

ioWDVRefNum:

INTEGER;

fillerl0:

INTEGER;

fillerll:

END;

i)

Us)

LONGINT;
LONGINT;

LONGINT;

fillerl2:
fillerl3:
ioWDDirID:

LONGINT;
LONGINT;
LONGINT) ;

{HParamBlockRec}

Routines
FUNCTION

PBGetCatInfo
OSErr;

(paramBlock:

CInfoPBPtr;

aSync:

BOOLEAN)

Parameter Block’s new field:

om

31

FUNCTION

>
co
=
=
oe
—
ce

12
16
18
22
32
36
40

ioACUser

PBHGetVolParms
OSErr;

ioCompletion
ioResult
ioFileName
ioVRefNum
ioBuffer
ioReqCount
ioActCount

byte

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

_—_long
word
long
word
long
long
long

Summary of the File Manager Extensions V-403

Inside Macintosh
FUNCTION

—>
e
->
-

-

12
16
22
26

&co
>

3
ae

>
on
ame

PBHGetDirAccess
OSErr

(paramBlock:

44
48

ioACAccess
ioDirID

long
long

12
16
18
22
36
40
44
48

ioACGroupID

PBHSetDirAccess
: OSErr;

ioCompletion
ioResult
ioFileName
ioVRefNum
ioACOwnerlID
ioACGroupID
ioACAccess
ioDirID
PBHMapID
OSErr;

(paramBlock:

HParmBlkPtr;

async:

BOOLEAN)

HParmBlkPtr;

async:

BOOLEAN)

_long
word
long
word
long
long
long
long

(paramBlock:

HParmBlkPtr;

ioCompletion
ioResult

_long
word

26
28
32

ioObjType
ioObjNamePtr
i0ObjID

word
long
long

ioFileName
ioVRefNum

BOOLEAN)

long

12
16

18
22

async:

long

_long
word
long
word
long

40

HParmBlkPtr;

_long
word
word
word

ioCompletion
ioResult
ioFileName
ioVRefNum
ioACOwnerID

FUNCTION

~
co

ioObjNamePtr

(paramBlock:

12
16
18
22
36

FUNCTION

>
—
oa
>
=
=>
>
>

ioCompletion
ioResult
io VRefNum
ioObjType

28

FUNCTION

>
co
ae
=>
co

PBHGetLogInIinfo
OSErr;

long
word

V-404 Summary of the File Manager Extensions

async:

BOOLEAN)

'

ace

=

o

File Manager Extensions In a Shared Environment
FUNCTION

=
=
=>
>
3
on

12
16
18
22
28
26
32

FUNCTION

PBHMapName
OSErr;

(paramBlock:

(paramBlock:

12
16
18
22
24
28
32

ioCompletion _ long
ioResult
word
ioFileName
long
io VRefNum
word
ioDstVRefNum word
ioNewName
long
ioCopyName
long

>

48

ioDirID

36

FUNCTION

ae
e
>
—
>
>
cd

12
16
18
22
28
32
36
48

FUNCTION

>
a
=
>
e
>
3

12
16
18
22
24
26
48

ioNewDirID

PBHMoveRename
OSErr;

HParmBlkPtr;

async:

BOOLEAN)

long

long

(paramBlock:

ioCompletion
ioResult
ioFileName
ioVRefNum
ioNewName
ioBuffer
ioNewDirID
ioDirID
PBHOpenDeny
OSErr;

BOOLEAN)

long
word
long
word
long
word
long

>
on
>
>
>
—
~

>

async:

be

ioCompletion
ioResult
ioFileName
io VRefNum
ioObjNamePtr
ioObjType
ioObjID
PBHCopyFile
OSErr;

HParmBlkPtr;

g9
=
f
ti)
©

asyne.:..BOOLEAN)

_ long
word
long
word
long
long
long
long

(paramBlock:

ioCompletion
ioResult
ioFileName
ioVRefNum
ioRefNum
ioDenyModes
ioDirID

HParmBlkPtr;

HParmBlkPtr;

async:

BOOLEAN)

_long
word
long
word
word
__ word
long

Summary of the File Manager Extensions V-405

|

Inside Macintosh
FUNCTION

>

oa
=
>
oo
—>
=

PBHOpenRFDeny
OSErr;

12

ioCompletion

16
18
22
24
26
48

ioResult
ioFileName
ioVRefNum
ioRefNum
ioDenyModes
ioDirID

Assembly-Language
Shared
Pascal

(paramBlock:

Environment
Name

Macro

HParmBlkPtr;

_—_long

word
long
word
word
word
long

Information
Macros
Name _-

Call Number

PBGetCatInfo
_GetCatInfo
PBHGetVolParms _GetVolParms
PBHGetLogInInfo _GetLogInInfo

$09
$30
$31

PBHSetDirAccess
PBHMapID
PBHMapName
PBHCopyFile
PBHMoveRename
PBHOpenDeny
PBHOpenRFDeny

$33
$34
$35
$36
$37
$38
$39

PBHGetDirAccess _GetDirAccess

_SetDirAccess
_MapID
_MapName
_CopyFile
_MoveRename
_OpenDeny
_OpenRFDeny

$32

V-406 Summary of the File Manager Extensions

async:

BOOLEAN)

22 THE

PRINTING

MANAGER

to
tN
—

oa

=

408
408
409
410
411
414
414
415

About the Printing Manager
Calling the Printing Manager in ROM
New Low-Level Printer Controls
PrGeneral
GetRslData
—— SetRsl
___ DraftBits
NoDraftBits

416
417

Using PrGeneral
Summary of the Printing Manager

415

=.
=

ve

<
g
=
fg
ge
o)
ar
—

GetRotn

V-407

Inside Macintosh

ABOUT THE PRINTING

MANAGER

The Printing Manager has been enhanced and made easier to use through these changes: .
m Its code has been moved from a linked file into the 256K ROM.

= New low-level printer control calls have been added, in the form of new predefined
parameter constants for PrCtlCall.
a A generic procedure called PrGeneral now lets your application perform several
advanced printer configuration tasks.

CALLING THE PRINTING

MANAGER

IN ROM

All the Printing Manager routines are now accessible through the single trap _PrGlue,
available in System file version 4.1 and later. To use trap calls with all System file

versions, link your application to PRGlue, available in the MPW 2.0 file Interface.o.
Here are the Printing Manager trap calls as they appear in the Pascal interface:
PROCEDURE
PROCEDURE
PROCEDURE
FUNCTION
FUNCTION
FUNCTION
PROCEDURE
FUNCTION
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE
FUNCTION
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE
FUNCTION
FUNCTION

PrOpen;
PrClose;
PrintDefault
PrValidate

PrStlDialog
PrJobDialog
PrJobMerge
PrOpenDoc

PrCloseDoc
PrOpenPage

PrClosePage
PrPicFile

(hPrint:
(hPrint:

THPrint) ;
THPrint)

(hPrint:
THPrint;
pPrPort:
TPPrPort;
pIOBuf:
Ptr):
TPPrPort;
(pPrPort:
TPPrPort);
(pPrPort:
TPPrPort;
pPageFrame:
TPRect);

(pPrPort: TPPrPort);
(hPrint: THPrint; pPrPort:
Ptr;

pDevBuf:

Ptr;

PrError:
Integer;
PrSetError
(iErr:
Integer);
PrDrvrOpen;
PrDrvrClose;
PrCt1Call
(iWhichCtl:
Integer;
1Param3:
LongInt) ;
PrDrvrDCE:
Handle;
PrDrvrVers:

Boolean;

(hPrint: THPrint)
: Boolean;
(hPrint: THPrint)
Boolean;
(hPrintSrc, hPrintDst: THPrint);

Integer;

V-408 Calling the Printing Manager In ROM

VAR

TPPrPort;

PrStatus:

1Paraml,

pIOBuf:

TPrStatus) ;

1Param2,

The Printing Manager
You can still call Printing Manager routines with the formats given in the Printing Manager
chapter of Volume II by using one of the following interface files:

w PrintTraps.p for Pascal
= PrintTraps.h for C

NN
iw

a PrintTraps.a for assembly language

—

~~

ee
=

=
ve

2
—

Assembly-language note:

a
=
&
7
@

You can invoke each of the Printing Manager routines by

pushing a longint called a routine selector on the stack and then executing the _PrGlue
trap ($A8FD). The routine selectors are the following:
PrOpen
PrClose
PrintDefault
PrValidate

EQU
EQU
EQU
EQU

PrJobDialog
PrJobMerge
PrOpenDoc
PrCloseDoc
PrOpenPage

EQU
EQU
EQU
EQU
EQU

PrStlDialog

PrClosePage

EQU
EQU

PrError

EQU

PrSetError

EQU

PrDrvrOpen

EQU

PrDrvrClose

EQU

PrCtl1Call
PrDrvrDCE
PrDrvrVers

NEW

$C8000000
$D0000000
$20040480
$52040498
$2A040484
$32040488
$5804089C
$04000C00
$08000484
$10000808
$1800040C
$60051480
$BA000000
$C0000200
$80000000
$88000000
$A0000E00
$94000000
$9A000000

EQU

PrPicFile

or

EQU
EQU
EQU

LOW-LEVEL PRINTER CONTROLS

New values have been added for PrCtlCall parameters. The complete list is now the
following:
CONST

iPrBitsCtl
= 4;
l1ScreenBits
= $00000000;

{the
{the

Print
Print

Proc's
Proc's

ctl number}
Screen Bitmap

l1PaintBits

{the Bitmap Print
{ (sq pix) param}
{the Bitmap Print

Proc's

Paint

Proc's

Screen

{the Bitmap Print
{ (sq pix) param}

Proc's

Paint

=

$00000001;

lHiScreenBits
lHiPaintBits
iPrIoctl

=

=
=

5;

$00000002;
$00000003;

Bitmap
Bitmap

{

param}

{

param}

{the

Raw

Byte

IO

Proc's

ctl

}

}
Bitmap

}

}

number}

New Low-Level Printer Controls V-409

|

Inside Macintosh
iPrEvtCtl

=

6;

{the

1PrEvtAll

=

$0002FFFD;

1PrEvtTop

=

$0001FFFD

iPrDevCtl = 7;
1PrReset = $00010000;
1PrDocOpen = $00010000;
1PrPageEnd = $00020000;
1PrPageClose

=

$00020000;

with

{

CParams: }

{

screen}

{

window}

Proc's

Sony

printers

these
whole

{PrEvent

Proc's

CParam

for

the

top

{the PrDevCtl Proc's
{the PrDevCtl Proc's
{alias for reset}
{the PrDevCtl Proc's
{ page}
{alias for end page}

=

{the

$00050000;

use

of

the

S$O003FFFF;

=

one

for

1PrLFStd

1PrDocClose

number;

CParam

{ advance}
{the PrDevCtl

$00040000;

and

Proc's

=

1PrPageOpen

ctl

{PrEvent

1PrLineFeed

=

$00030000;

PrEvent

{

{the

PrDevCtl

{

paper

{

PageOpen }

{

DocClose}

{the

adv}

PrDevCtl
PrDevCtl

}

}
}

}

ctl number}
CParam for reset}
CParam

for

end

Proc's

CParam

for

paper

Proc's

CParam

for

std

Proc's

CParam

for

}

Proc's

CParam

for

}

}
}

}

Other values that may be shown in the interface file are used only by the Macintosh system.

PRGENERAL
The Printing Manager has been expanded to include a new procedure called PrGeneral. It
provides advanced, special-purpose features, intended to solve specific problems for those
applications that need them. You can use PrGeneral with version 2.5 and later of the
ImageWriter driver and version 4.0 and later of the LaserWriter driver. The Pascal
declaration of PrGeneral is
PROCEDURE

PrGeneral

(pData:

Ptr);

The pData parameter is a pointer to a data block. The structure of the data block is declared
as follows:
TGnlData

=

RECORD

{lst

8 bytes

{more
END;

fields

iOpCode:
iError:
1lReserved:

are

common

Integer;
Integer;
LongInt;

here,

for

all

PrGeneral

depending

on

particular

{input}
{output }
{reserved

for

calls);

future

use}

call}

The first field in the TGnlData record is a 2-byte opcode, iOpCode, which acts somewhat
like a routine selector. The currently available opcodes are these:
= GetRs|Data (get resolution data): iOpCode = 4

V-410 PrGeneral

The Printing Manager
w SetRsl (set resolution): iOpCode = 5

a DraftBits (bitmaps in draft mode): iOpCode = 6

to
ND

= NoDraftBits (no bitmaps in draft mode): iOpCode = 7

a>)

a GetRotn (get rotation): iOpCode = 8

af
=
=}
i
=.

GetRslData and SetRs! allow the application to find out what physical resolutions the
printer supports, and then specify a supported resolution. DraftBits and noDraftBits
invoke a new feature of the ImageWriter, allowing bitmaps (imaged via CopyBits) to be
printed in draft mode. GetRotn lets an application know whether landscape orientation has
been selected. These routines are described in the next sections.

<—

&

=
i)@

toe

bey

The second field in the TGnlData record is the error result, iError, returned by the print

code. This error only reflects error conditions that occur during the PrGeneral call. For
example, if you use an opcode that isn’t implemented in a particular printer driver then you
will get an OpNotImpl error. Here are the error codes:
CONST
NoErr

=

NoSuchRsl
OpNotImpl

=
=

0;

1;
2;

{no

{the
{the

error}

resolution you
driver doesn't

chose isn't available}
support this opcode}

After calling PrGeneral you should always check PrError.

If NoErr is returned, then you

can proceed. If ResNotFound is returned, then the current printer driver doesn’t support
PrGeneral and you should proceed appropriately.

[Error is followed by a four byte reserved field. The contents of the rest of the data block
depends on the opcode that the application uses.
GetRsIData
GetRs|Data (iOpCode = 4) returns a record that lets the application know what resolutions
are supported by the current printer. The application can then use SetRs!l to tell the printer
driver which one it will use. These calls introduce a good deal of complexity into your
application’s code, and should be used only when necessary.

This is the format of the input data block for the GetRs|Data call:
TRslRg

=

RECORD {used in TGetRs1Blk}
iMin:
Integer;
{0 if printer
{ resolutions}
iMax:
Integer;
{0 if printer
{ resolutions}

supports

only

discrete

}

supports

only

discrete

}

physical
physical

X
Y

END;

TRslRec

=

RECORD

iXRsl:
iYRsl:

END;

{used

in

TGetRs1Blk}

Integer;
Integer;

{a
{a

discrete,
discrete,

resolution}
resolution}

PrGeneral V-411

|

Inside Macintosh
TGetRslBlk
i1O0pCode:

=

RECORD {data block
Integer; {input;
=

for GetRslData
getRslDataOp}

call}

iError:
Integer; {output}
1Reserved: LongInt; {reserved for future use}
iRgType:
Integer; {output; version number}

XRslRg:
TRslRg;
{output;
range of X resolutions}
YRslRg:
TRslRg;
{output;
range of Y resolutions}
iRslRecCnt: Integer; {output;
how many RslRecs follow}
rgRslRec:
ARRAY[1..27]
OF TRslRec;
{output;
number filled
}
{ depends on printer type}
END;

The iRgType field is much like a version number; it determines the interpretation of the data
that follows. An iRgType value of 1 applies both to the LaserWriter and to the
Image Writer.

For variable-resolution printers like the LaserWriter, the resolution range fields XRslRg

and YRslRg express the ranges of values to which the X and Y resolutions can be set. For
discrete-resolution printers like the ImageWriter, the values in the resolution range fields

are zero.
Note:

In general, X

and Y

in these records

are the horizontal

and vertical

directions of the printer, not the document. In “landscape” orientation, X is
horizontal on the printer but vertical on the document.
After the resolution range information there is a word which gives the number of resolution
records that contain information. These records indicate the physical resolutions at which
the printer can actually print dots. Each resolution record gives an X value and a Y value.
When you call PrGeneral, use the following data block:
OpCode = 4

1 word

Error Code

1 word

Reserved

2 words

RangeType = 1

1 word

slips gi hee

2 word

Y Resolution Range:
min =0, max = 0

2 words

Resolution Record Count =0

1 word

Resolution Record #1:

2 words

X=0,Y=0

—

Resolution Record #2..27

V-412 PrGeneral

The Printing Manager
Here is the data block returned by the LaserWriter:
OpCode = 4

1 word

SS

Error Code (0 = okay)

1 word

a

Reserved

2 words

=

RangeType = 1

1 word

i

X Resolution Range:

pause

Weise

=

Y Resolution Range:

2 words

5

Resolution Record Count = 1

1 word

Resolution Record #1:

2 words

min = 72, max = 1500
min = 72, max = 1500

X = 300, Y = 300

=

=.

Notice that all the resolution range numbers are the same for this printer. There is only one
resolution record, which gives the physical X and Y resolutions of the printer (300 x 300).
Below is the data block returned by the ImageWriter.
OpCode = 4

1 word

Error Code (0 = okay)

1 word

Reserved

2 words

RangeType = 1

1 word

X Resolution Range:
min =0, max = 0

2 words

Y Resolution Range:

2 words

Resolution Record Count = 4

1 word

Resolution Record #1:
X =72,Y=72

2 words

Resolution Record #2:
X =144,
Y= 144

2 words

Resolution Record #3:
X = 80,
Y=72

2 words

Resolution Record #4:

2 words

min = 0, max = 0

X = 160, Y = 144

All the resolution range values are zero, because only discrete resolutions can be specified
for the ImageWriter. There are four resolution records giving these discrete physical
resolutions.
GetRslData always returns the same information for a particular printer type—it is not
dependent on what the user does or on printer configuration information.

PrGeneral V-413

Inside Macintosh

SetRsl
SetRsl (c(OpCode = 5) is used to specify the desired imaging resolution, after using
GetRslData to determine a workable pair of values. Below is the format of the data block:
TSetRs1Blk
iOpCode:

=RECORD {data block
Integer;
{input;

for SetRsl call}
= setRsl0Op}

iError:
1lReserved:

Integer;
LongInt;

{output}
{reserved

iXRsl1:
iYRs1l:

Integer;
Integer;

{input;
{input;

hPrint:
END;

THPrint;

{input;

for

handle

future

desired
desired

to

a

use}

valid

print

X resolution}
Y resolution}

record}

The hPrint parameter contains the handle of a print record that has previously been passed
to PrValidate. If the call executes successfully, the print record is updated with the new
resolution; the data block comes back with 0 for the error and is otherwise unchanged. If
the desired resolution is not supported, the error is set to noSuchRs] and the resolution
fields are set to the printer’s default resolution

You can undo the effect of a previous call to SetRsl by making another call that specifies an
unsupported resolution (such as 0 x 0), forcing the default resolution.
DraftBits
DraftBits (OpCode = 6) is implemented on both the ImageWriter and the LaserWriter. On
the LaserWriter it does nothing, because the LaserWriter is always in draft mode and can

always print bitmaps. Here is the format of the data block:
TDftBitsBlk
= RECORD

10pCode:
iError:
lReserved:
hPrint:

END;

Integer;
Integer;
LongInt;
THPrint;

{data block
{ calls}

for

DraftBits

and

NoDraftBits

{input; = draftBitsOp or noDraftBitsOp}
{output}
{reserved for future use}
{input; handle to a valid print record}

The hPrint parameter contains the handle of a print record that has previously been passed
to PrValidate.
This call forces draft-mode (immediate) printing, and will allow bitmaps to be printed via
CopyBits calls. The virtue of this is that you avoid spooling large masses of bitmap data
onto the disk, and you also get better performance.

V-414 PrGeneral

}

The Printing Manager
The following restrictions apply:
m This call should be made before bringing up the print dialog boxes because it affects
their appearance. On the ImageWriter, calling DraftBits disables the landscape icon in

the Style dialog, and the Best, Faster, and Draft buttons in the Job dialog box.

~

u If the printer does not support draft mode, already prints bitmaps in draft mode, or
does not print bitmaps at all, this call does nothing.

mw Only text and bitmaps can be printed.
= Everything on the page must be strictly Y-sorted; that is, no reverse paper motion
between one string or bitmap and the next. This means you can’t have two or more
objects (text or bitmaps) side by side; the top boundary of each object must be no
higher than the bottom of the preceding object.
The last restriction is important. If you violate it, you will not like the results. However, if
you want two or more bitmaps side by side, you can combine them into one before calling
CopyBits to print the result. Similarly, if you are just printing bitmaps you can rotate them

yourself to achieve landscape printing.
NoDraftBits

NoDraftBits (i{OpCode = 7) is implemented on both the ImageWriter and the LaserWriter.

On the LaserWriter it does nothing, since the LaserWriter is always in draft mode and can
always print bitmaps. The format of the data block is the same as that for the DraftBits call.
This call cancels the effect of any preceding DraftBits call. If there was no preceding
DraftBits call, or the printer does not support draft-mode printing anyway, this call does
nothing.
GetRotn
GetRotn (iOpCode = 8) is implemented on the ImageWriter and LaserWriter.
format of the data block:
block

for

Integer;

{input;

lReserved:

LongIint;

{reserved

for

{output;

Boolean

Error:

Integer;

hPrint:

THPrint;

bXtra:

SignedByte;

fLandscape:

END;

Boolean;

{output }

{input;

=

GetRotn

iOpCode:

{reserved}

Here is the

call}

getRotnOp}

handle

future

to

au
=
=.
=
ge
oS
=
fo
ge

w As in the normal draft mode, landscape format is not allowed.

TGetRotnBlk
= RECORD {data

tN
rt

use}

a valid

flag}

print

record}

The hPrint parameter contains a handle to a print record that has previously been passed to
PrValidate.
- If landscape orientation is selected in the print record, then fLandscape is true.

PrGeneral V-415

@

baw

|

Inside Macintosh

Using

PrGeneral

SetRsl and DraftBits calls may require the print code to suppress certain options in the Style
and/or Job dialog boxes, therefore they should always be called before any call to the Style
or Job dialogs. An application might use PrGeneral as follows:

= Get a new print record by calling PrintDefault, or take an existing one from a
document and call PrValidate on it.
= Call GetRslData to find out what the printer is capable of, and decide what resolution
to use. Check PrError to be sure the PrGeneral call is supported on this version of the
print code; if the error is ResNotFound, you have older print code and must print
accordingly. But if the PrError return is 0, proceed as follows:
m Call SetRsl with the print record and the desired resolution if you wish.

a Call DraftBits to invoke the printing of bitmaps in draft mode if you wish.
If you call either SetRsl or DraftBits, you should do so before the user sees either of the

printing dialog boxes.

V-416 PrGeneral

The Printing Manager

SUMMARY

OF THE

PRINTING

MANAGER
nN
nN

Constants

=!
=
ve

CONST

2

{PrtCtlCall

parameters}

iPrBitsCtl

= 4;

{the

1PaintBits

=

l1ScreenBits

=

Print

Proc's

Proc's

ctl

Proc's

Paint

$00000002;

{the Bitmap Print
{ (sq pix) param)
{the Bitmap Print

Proc's

Screen

$00000003;

{the

Bitmap

Proc's

Paint

{the
{the

Raw Byte IO Proc's
PrEvent Proc's ctl

$00000000;

$00000001;

1HiScreenBits

=

1HiPaintBits

=

iPriIoctl = 5;
iPrEvtCtl = 6;
1PrEvtAll

=

$0002FFFD;

1PrEvtTop

=

$0001FFFD

iPrDevCtl = 7;
1PrReset = $00010000;
1PrDocOpen = $00010000;
1PrPageEnd = $00020000;
1PrPageClose = $00020000;
1PrLineFeed = $00030000;
1PrLFStd

=

1PrPageOpen

SOOO03FFFF;
=

$00040000;
$00050000;

1PrDocClose

{PrGeneral iOpCode values}
GetRslData = 4;
SetRsl = 5;
DraftBits = 6;
NoDraftBits = 7;
GetRotn = 8;
{PrGeneral

error

NoErr = 0;
NoSuchRsl =
OpNot Impl

codes}

1;
2;

Bitmap

Print

{the Bitmap
{ param}

{

param}

{

(sq pix)

Print

param}

{PrEvent
Proc's
{ screen}

{PrEvent

{

Proc's

folder}

Screen

Bitmap

}

Bitmap

}

}

}

ctl number}
number}

CParam

for

the

whole

CParam

for

the

top

{the PrDevCtl Proc's
{the PrDevCtl Proc's
{alias for reset}
{the PrDevCtl Proc's

yi

number}

}

}

ctl number}
CParam for reset}
CParam

for

end

{alias for end page}
{the PrDevCtl Proc's

CParam

for

paper

{the

PrDevCtl

Proc's

CParam

for

std

{the

PrDevCtl

Proc's

CParam

for

}

Proc's

CParam

for

}

{ page}
{

advance}

{

paper

adv}

{ PageOpen }
{the PrDevCtl
{ DocClose}

}
}
}

{get resolution data}
{set resolution}
{bitmaps in draft mode}
{no bitmaps in draft mode}
{get rotation}

{no error}
{the resolution you
{the driver doesn't

chose isn't available}
support this opcode}

Summary of the Printing Manager V-417

de
&

Inside Macintosh

Data

Structures
TGnlData

bytes
are common
for all PrGeneral
calls}
Integer;
{input }
Integer;
iError:
{output }
LongIint;
1Reserved:
{reserved for future
use}
{more
fields here,
depending
on particular
call}

RECORD

=

iOpCode:

{lst

8

END;

TRslRg

=

RECORD {used in TGetRs1Blk}
iMin:
Integer;
{0 if printer only
{ resolutions}
iMax:
Integer;
{0 if printer only
{ resolutions}

supports

discrete

}

supports

discrete

}

END;

TRslRec

=

RECORD
{used in TGetRs1Blk}
iXRsl:
Integer;
{a discrete,
iYRsl:
Integer;
{a discrete,
END;

TGetRslBlk

=

RECORD

{data

i0OpCode:
iError:

block

for

Integer;
Integer;

GetRslData

X
Y

resolution}
resolution}

call}

{input; =
{output }

getRslDataOp}

l1Reserved:
iRgType:

LongInt;
Integer;

{reserved
for future use}
{output;
version number}

{output;

range

YRs1Rg:
iRslRecCnt:

TRs1lRg;
Integer;

{output;
{output;

range of
how many

XRs1Rg:

rgRslRec:

TRs1Rg;

ARRAY[1..27]

{

END;
TSetRs1Blk

physical
physical

= RECORD

{data

i0OpCode:
iError:

lReserved:

block

for

LongInt;

{reserved

for

Integer;
Integer;

{data

block

for

Integer;

iError:

Integer;
LongInt;
THPrint;

1l1Reserved:

hPrint:

DraftBits

V-418 Summary of the Printing Manager

a

use}

valid

{output }
{reserved

{input;

and

NoDraftBits

for

future

handle

record}

print

}

resolution}
resolution}

{input; = draftBitsOp
{ noDraftBitsOp}

{
END;

future

{input; handle to
{ record}
{input; desired X
{input; desired Y

iOpCode:

resolutions}

Y resolutions}
RslRecs
follow}

call}

setRslOp}

iXRsl:
iY¥Rs1:

TDftBitsBlk
= RECORD

SetRsl

{input; =
{output}

THPrint;

X

OF TRslRec;
{output; number
}
filled depends on printer type}

Integer;
Integer;

hPrint:

END;

of

to

a

or

use}

valid

}

calls}

print

}

The Printing Manager
TGetRotnBlk
= RECORD {data

block

10pCode :
iError:

lReserved:

END;

for

Integer;
Integer;

THPrint;

fLandscape:

Boolean;

call}

{input; =
{output }

LongInt;

hPrint:
bXtra:

GetRotn

{reserved

for

{output;

Boolean

{input;
{ print

SignedByte;

getRotnOp}

future

handle to
record}

{reserved}

a

use}

valid

}

flag}

~
mae

=

z

4

ie
5

Routines
PROCEDURE
PROCEDURE
PROCEDURE
FUNCTION
FUNCTION
FUNCTION
PROCEDURE
FUNCTION

S

PrOpen;
PrClose;

PrintDefault
PrValidate
PrStlDialog
PrdobDialog
PrdobMerge
PrOpenDoc

(hPrint: THPrint);
(hPrint: THPrint)
Boolean;
(hPrint: THPrint)
Boolean;
(hPrint: THPrint)
Boolean;
(hPrintSrc,
hPrintDst:
THPrint) ;
(hPrint: THPrint; pPrPort:
TPPrPort;

PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE

PrCloseDoc
PrOpenPage

Ptr):
TPPrPort;
(pPrPort:
TPPrPort) ;
(pPrPort:
TPPrPort;
pPageFrame:

PrPicFile

(hPrint:

FUNCTION
PROCEDURE
PROCEDURE
PROCEDURE
PROCEDURE

PrError:
Integer;
PrSetError
(i1Err:
Integer) ;
PrDrvrOpen;
PrDrvrClose;
PrCtlCall
(iWhichCtl:
Integer;

FUNCTION
FUNCTION
PROCEDURE

PrDrvrDCE:
Handle;
PrDrvrVers:
Integer;
PrGeneral
(pData:

PrClosePage

(pPrPort:
Ptr;

TPPrPort) ;

THPrint;

pDevBuf:

LongInt) ;

Ptr;

pPrPort:

VAR

TPRect);

TPPrPort;

PrStatus:

1Paraml,

pIOBuf:

pIOBuf:

TPrStatus) ;

1Param2,

l1Param3:

Ptr);

Summary of the Printing Manager V-419

23

THE

DEVICE

MANAGER

422
422
423

About the Device Manager
The Startup Process
Automatic Driver Installation

426
427
428
430
431
431
432

Slot Device Interrupts
New Routines
Chooser Changes
Buttons
List Definition Procedure
Page Setup
Device Package Function

425

433

Opening Slot Devices

~)

we

2
©
<
©

oS.

Summary of the Device Manager

f>
=
o>
ge
©
Le

V-421

4

Inside Macintosh

ABOUT THE DEVICE

MANAGER

New modifications have been made to the Device Manager to support slot devices.

Reader’s guide: You need the information in this chapter only if your application

uses a specific card (other than a standard video card) that plugs into a NuBus™ slot on
the Macintosh II.

This chapter covers the following subjects:
w the parts of the system startup procedure that affect slot devices
w how the Open call now handles slot devices
= how interrupts originating in slot devices are processed
m how the new Chooser works with slot devices
You’ll also need to be familiar with

m the Device Manager information in Volumes II and IV
m the Start Manager
w the Slot Manager
m the parts of the book Designing Cards and Drivers for Macintosh II and Macintosh
SE that pertain to the device your application uses.

THE STARTUP

PROCESS

The Macintosh II ROM searches for the startup device using an algorithm described in the
Start Manager chapter of this volume. It will attempt to start from a NuBus card only when

certain values are set in its parameter RAM.
Manager routines.

These values can be accessed by using Start

When the Macintosh starts up from a card in a NuBus slot, it uses startup code found in an
sResource in the configuration ROM on the card. Otherwise, the normal Macintosh startup
process occurs. Configuration ROMs and sResources are described in the Slot Manager
chapter of this volume and in the book Designing Cards and Drivers for Macintosh II and
Macintosh SE.
If parameter RAM

specifies a valid sResource ID and slot, and if that sResource has an

sBootRecord, it is used for startup. The ROM loads the slot startup code into memory and
calls its entry point to execute it. For non-Macintosh operating systems that take over the
machine, this code is either the operating system itself or a startup program. For instance,
a traditional UNIX® startup process would bring in the secondary startup program, which
prompts for a device name or filename to execute. The ROM would never receive control
again.

V-422 The Startup Process

The Device Manager
The sBootRecord code is first called early in the ROM-based startup sequence, before any
access to the internal drive. It is passed an seBlock pointed to by register AO. If a nonMacintosh operating system is being installed, the sBootRecord can pass control to it. In
this case, control never returns to the normal start sequence in the Macintosh ROM.
When the Macintosh operating system is started up, the sBootRecord is called twice. The
first time, when the value of seBootState is 0, the startup code tries to load and open at least
one driver for the card-based device and install it in the disk drive queue. It returns the
refnum of the driver. That driver becomes the initial one used to install the Macintosh
operating system. During the second call to the sBootRecord (when the value of
seBootState is 1), which happens after system patches have been installed but before
‘INIT’ resources have been executed, the sBootRec must open any remaining drivers for
devices on the card.
The sBootRecord can use the HOpen call to open the driver and install it into the unit table.
The HOpen call will either fetch the driver from the sDriver directory, or call the
sLoadDriver record if one exists. In any case, the driver’s open code must install the driver
into the drive queue. This process is discussed in more detail in the Card Firmware chapter
of the book Designing Cards and Drivers for Macintosh II and Macintosh SE.

~

io)

—)
&
=<
©
~
=
iS)
tj)

‘o)

ser

Automatic

Driver

Installation

During the startup process the system installs the default video and startup drivers, as
described in the Start Manager chapter of this volume. Immediately prior to installing the
'INIT' resources, the system searches the NuBus slots looking for other device drivers to
install. The sRsrcDir data structure in each card’s configuration ROM describes all devices
on that card. For each device there is a sRsrcList structure which contains the resource
name (sRsrcName) and the offset to a table of drivers. These structures are described in
the Slot Manager chapter of this volume.
For each sResource, the search for drivers during startup takes place in the following steps:
1. The operating system looks for an sRsrc_Flags field in the sResource list.
2. If no sRsrc_Flags field exists, or if an sRsrc_Flags field exists and the field’s

fOpenAtStart bit is set to 1, the operating system searches for a driver, as described

below in steps 3 and 4. If the value of fOpenAtStart is 0, the operating system does
not search for a driver; it goes on to the next sResource.

3. The system searches the sResource list fora driver load record (sRsrc_LoadRec)— a

routine designed to copy a driver into the Macintosh system heap. If such a routine
exists, the system copies it from the card’s ROM to the heap and executes it. The
system passes this routine a pointer in AQ to an seBlock; on exit, the routine must
return a handle in the seResult field of the same seBlock to the driver it has loaded.
the value of the seStatus field is 0, the system then installs the new driver.

If

4. If there is no driver load record, the system searches the sResource list for a driver
directory entry (sRsrc_DrvrDir). If there is such an entry and the directory contains a

The Startup Process V-423

|

Inside Macintosh

driver of the type sMacOS68000 or sMacOS68020, the system reads the driver from

the card’s ROM and installs it in the Macintosh system heap.

To install a driver, the Macintosh II ROM first loads it into the system heap and locks it if
the dNeedsLock bit in the driver flags (drvrFlags) word is set. It then installs the driver

with a DrvrInstall system call and initializes it with an Open call. If the driver returns an
error from the Open call, it is marked closed, the refNum field is cleared in the ioParameter
block, and the driver is unlocked. Note that this procedure guarantees that driver
initialization code will be executed before the system starts executing applications.

The video driver used at the beginning of system startup (the one that makes the “happy
Macintosh” appear) must be taken from a video card’s configuration ROM because the

System file is not yet accessible. If a system contains multiple video cards, the one used

first is determined by parameter RAM or, by default, by selecting the lowest slot number.

To override this initial driver, the user must install an 'INIT' 31 resource that explicitly
closes the driver from the configuration ROM and loads a new driver from a file.

The unit table data structure has been extended from 48 devices to 64 to accommodate
installing slot devices. If more than 64 entries are needed, the table automatically expands

up to a maximum of 128 entries.

When a driver serves a device that is plugged into a NuBus slot, it needs to know the slot
number, the sResource ID number and the ExtDevID number. These numbers are

discussed in the Slot Manager chapter of this volume. The Slot Manager provides values

for five new entries on the end of the Device Control Entry (DCE) data structure for each

sResource.

These new entries are

m a byte containing the slot number (dCtlSlot)
a

a byte containing the RsrcDir ID number for the sResource (dCtlSlotID)

m= a pointer for the driver to use for the device base address (dCtlDevBase)
m areserved field for future use
a

a byte containing the external device ID (dCtlExtDev)

The Device Control Entry now looks like this:
AuxDCE

=

PACKED

RECORD

dctlDriver:
Ptr;
dCctlFlags:
INTEGER;
dCtlQHdr: QHdr;
dctlPosition:
LONGINT;
dCtlStorage:

Handle;

dctlRefNum:
INTEGER;
dctlCurTicks:
LONGINT;
dctlWindow:
Ptr;
dctlDelay:
INTEGER;
dCtlEMask:

V-424 The Startup Process

INTEGER;

{ptr to ROM or handle to RAM driver}
{flags}
{driver's i/o queue}
{byte pos used by read and write }
{ calls}
{hndl to RAM drivers private
}
{

storage}

{

calls}

{driver's reference
{counter for timing
{ptr to
{number
{desk

driver's
of ticks

acessory

number}
system task

}

window if any}
btwn sysTask calls}

event

mask}

The Device Manager
dctlMenu:

INTEGER;

dactlSlot:

Byte;

actlSlotId:

{menu
ID of
{ driver}
{slot}

Byte;

{slot

dCtlDevBase:
LONGINT;
reserved:
LONGINT;

aCtlExtDev:
Byte;
fillByte:
Byte;
END;

menu

associated

with

}

ID}

{base address
of card for
{reserved;
should be 0}

{external device
{reserved}

driver}

ID}

{SlotDCE}

AuxDCEPtr

=

AuxDCEHandle

*AuxDCE;

=

*AuxDCEPtr;

All Device Control Entries are set before the driver’s Open routine is called.
Use of the base address pointer dCtIDevBase in the DCE is optional. On a card with
multiple instances of the same device, the driver can use this pointer to distinguish between
devices. Because the DCE address is passed to the driver on every call from the Device
Manager, the presence of this pointer in the DCE simplifies location of the correct device.
This pointer is the address of the base of the card’s slot space plus an optional offset
obtained from the MinorBaseOS field of the sResource. This field frees the driver writer
from the necessity of locating the hardware for simple slot devices. The system makes no
other references to it.

OPENING

SLOT DEVICES

The low-level PBOpen routine has been extended to let you open devices in NuBus slots.

A new call has been defined: OpenSlot is the equivalent of PBOpen except that it sets the
IMMED bit, which signals an extended parameter block.
FUNCTION

OpenSlot

(paramBlock:

paramBlkPtr;

aSync:

BOOLEAN)

:

OsErr;

If the slot sResource serves a single device (for example, a video device), clear all the bits

of the ioFlags field and use the following parameter block:
Parameter block
=
ce
>
—
—

12
16
18
22
27

ioCompletion
ioResult
ioNamePtr
ioRefNum
ioPermssn

pointer
word
pointer
word
byte

—
>
>
>

28
32
34
35

ioMix
ioFlags
ioSlot
iold

pointer
word
byte
byte

Opening Slot Devices V-425

i)

te

mel

\w/

o
<
oO
o
<
—
=
=
yy
ve
@
Lew

|

Inside Macintosh

In the extension fields, ioMix is a pointer reserved for use by the driver open routine. The
ioSlot parameter contains the slot number of the device being opened, in the range 9..$E; if
a built-in device is being opened, ioSlot must be 0. The iold parameter contains the
sResource ID. Slot numbers and sResources are discussed in the Slot Manager chapter of
this volume.
If the slot sResource serves more than one device (for example, a chain of disk drives), set

the fMulti bit in the ioFlags field (clearing all other flags bits to 0) and use the following
parameter block:
Parameter block
>
_
=
>

12
16
18
22
27

ioCompletion
ioResult
ioNamePtr
ioRefNum
ioPermssn

_ pointer
word
pointer
word
byte

—
=>
=

28
32
34

ioMix
ioFlags
ioSEBIkPtr

pointer
word
pointer

Here the new parameter ioSEBIkPtr is a pointer to an external parameter block (described in
the Slot Manager chapter of this volume) that is customized for the devices installed in the

slot. The pointer value is passed to the driver.

SLOT DEVICE

INTERRUPTS

Slot interrupts enter the system by way of the Macintosh II VIA2 chip, which contains an
8-bit register that has a bit for each slot. This means that there is effectively one interrupt
line per card. You can tell almost instantly which card requested the interrupt, but not
which device on the card. To locate the interrupt to a device, the Slot Manager provides the
polling procedure described below.
The Device Manager maintains an interrupt queue for each slot. The queue elements are
ordered by priority and contain pointers to polling routines. Upon receipt of a slot interrupt
the Device Manager goes through the slot’s interrupt queue, calling each polling routine,
until it gets an indication that the interrupt has been satisfied. If no such indication occurs,
a system error dialog is displayed.
The format for a slot interrupt queue element is the following:
SQLink
SQType
SQPrio
SQAddr
SQParm

EQU
EQU
EQU
EQU
EQU

0
&
6
8
12

V-426 Slot Device Interrupts

;link to next element
(pointer)
;queue type ID for validity
(word)
;priority
(low byte of word)
;interrupt service routine
(pointer)
;optional Al parameter
(long)

The Device Manager

The SQLink field points to the next queue entry; it is maintained by the system. The
SQType field identifies the structure as an element of a slot interrupt queue. It should be
set to SIQType. The SQPrio field is an unsigned byte that determines the order in which
slots are polled and routines are called. Higher value routines are called sooner. Priority
values 200-255 are reserved for Apple devices. The SQAddr field points to the interrupt

polling routine.

The SQParm field is a value which is loaded into Al before calling an interrupt service

routine. This could be a handle to the driver’s DCE, for example.

NEW

ROUTINES

i)
te
cml

The Device Manager provides two new routines to implement the interrupt queue process

just described: SIntInstall and SIntRemove. They are described below.

\w/
om
<
+
fae]

~<
—
=

=

FUNCTION

SIntInstall(sIntQElemPtr:

Trapmacro

SQElemPtr;

theSlot:

INTEGER)

:

OsErr;

_SIntInstall

On entry

DO:

slot number (word)

DO:

error code

AO: address of slot queue element

On exit

SIntInstall adds a new element (pointed to by sIntQElemPtr) to the interrupt queue for the
slot whose number is given in theSlot. As explained in the Slot Manager chapter of this

volume, slots are numbered from 9 to $E.

Assembly-language note: From assembly language, this routine has the following
calling sequence (assuming AQ points to a slot queue element):
LEA
MOVE .L

PollRoutine,Al
Al, SQAddr (A0)

;get
;set

MOVE
MOVE

AlParm,
Slot,D0

;save Al parameter
;set
slot number

MOVE

.W
.L
.W

_SIntInstall

Prio,

SQPrio(A0)

SQParm(A0)

routine
address

address

;set

priority

;do

installation

This code causes the routine at label PollRoutine to be called as a result of an interrupt from
the specified slot (9..$E). The Device Manager will poll the slot which has the highest
priority first if two or more slots request an interrupt simultaneously.

New Routines V-427

i)

ga

()
=!

Inside Macintosh
SIntRemove

FUNCTION

(sIntQElemPtr:

SQElemPtr;

Trap macro

_SIntRemove

On entry

DO:
AO:

slot number (word)
address of slot queue element

On exit

DO:

error code

INTEGER)

theSlot:

:

OsErr;

SIntRemove removes an element (pointed to by sIntQElemPtr) from the interrupt queue for

the slot whose number is given in theSlot. As explained in the Slot Manager chapter of this

volume, slots are numbered from 9 to $E.

Assembly-language note: From assembly language, this routine has the following
calling sequence (assuming AO points to a slot queue element):
LEA

_SIntRemove

MySQE1,A0

;pointer

;remove

to

it

queue

element

This routine lets you remove an interrupt handler from the system without causing a crash.
Your driver polling routine will be called with the following assembly-language code:
MOVE

JSR

.L

AlParm, Al

PollRoutine

;load

;call

Al

Parameter

polling

routine

Your polling routine should preserve the contents of all registers except Al and DO. It
should return to the Device Manager with an RTS instruction. DO should be set to zero to
indicate that the polling routine did not service the interrupt, or nonzero to indicate the
interrupt has been serviced. The polling routine should not set the processor priority below
2, and should return with the processor priority equal to 2. The Device Manager resets the
VIA2 int flag and executes an RTE to the interrrupted task when a polling routine indicates
that the interrupt is satisfied; otherwise, it calls the next lower-priority polling routine for
that slot.

If none exists, a system error results.

CHOOSER

CHANGES

Three new facilities for user-written device packages have been added to the Chooser:
u In addition to specifying and setting their names, a device package can now position
one or both buttons.
m A device package can now supply a custom list definition for the device list. The
custom list can include icons, pictures, or small icons next to the name.

V-428 Chooser Changes

The Device Manager
u Applications that do their own housekeeping can now bypass the warning message
brought up whenever a different device is chosen.
Figure 1 shows the new window displayed by the Chooser.

——————$$

mn

4

|

ee

(11

| nee

at
a

Rothe Wlonater

—_

device

list

AppleTalk L.. ImageWriter

nN

So

7

z

Vv

the

14

}
User Name:

1GOn

.

AppleTalk

<

button

1S=.

left

.

(centered)

list

igi

the

ai
3.0b13

Figure 1. The Chooser Window

As described in the Device Manager chapter of Volume IV, the Chooser can also prompt
the user for which AppleTalk network zone to communicate with. See Figure 2.

Chooser Changes V-429

E

Inside Macintosh
SSS

SSS

I>

S|

Chooser

Select a Laser Writer:
Deathtonius
Software Engineering
Classic Refriger Writer
42.2

LW++ ROMs

Zones!

AppleTalk Zones:
Harslem Land
| HNoPurgatory

| Nets-R-Us

Product Testing
Route 232

S_NGD)

Baby Writer

AppleTalk

cy

© Active
© Inactive

3.0613

Figure 2. The Chooser Displaying Zones
Buttons

A device package can choose to have 0, 1, or 2 buttons, as determined by bits 27 and 26 in
the flag field of the device ID. The two buttons are not the same. The button set by bit 27
is called the Left Button, and the button set by bit 26 the Right Button, because these are

their default positions.

The Left Button has a double border, and if it is highlighted (the title string is dark, not
gray), then a Return, Enter, or double click are equivalent to clicking the button. The Left
Button is highlighted only when one or more devices are selected in the device list. The
Right Button has a single border, never dims its title, and can be activated only by clicking
it.

Buttons can be positioned by having a resource type 'nrct' with an ID of —-4096 in the
device file. The first word of the resource is the number of rectangles in the list, in this
case two; the rest of the resource contains the rectangle definitions. The first rectangle is
the Left Button, the second is the Right Button.

Each rectangle definition is eight bytes long and contains the rectangle coordinates in the

order [top, left, bottom, right] order. The default values are [112, 206, 132, 266] for the

Left Button, and [112, 296, 132, 356] for the Right Button.
(112, 251,,132, STU, for example, would

Substituting 'nrct' values of

center a single button.

There’s an additional button-related change: in the ButtonMsg parameter, the low order
byte of the P2 parameter has a value of 1 or 2 depending on whether the Left Button or

V-430 Chooser Changes

The Device Manager

Right Button was clicked. The high order word of P2 now contains modifier bits from the
event.

List

Definition

Procedure

The Chooser uses the List Manager to produce and display the standard device list. The
programmer can now supply a list definition procedure, which could, for example, include
pictures or icons. The application should provide an 'LDEF' resource with an ID of
4096.
Also, with Chooser 3.0 and above the device may use the refCon field of the device list for
its own purposes. Remember that the list will be disposed of whenever the user changes
device types or changes the current zone.
Before the list is disposed of, the device package will be called with the terminate message.
See the List Manager section in Volume IV for the mechanics of list construction and the
list record data structure.

Page

Setup

The Chooser normally issues a warning message whenever a different printer type is
selected:
Be

the

sure

to

choose

application

Page

can

Setup

format

and

confirm

documents

the

correctly

settings

for

the

so

that

<printer>.

Since some applications handle the page resetup correctly on their own, the Chooser now
offers a way for applications to bypass the message.
FUNCTION

SetChooserAlert

(f£:BOOLEAN)

:

BOOLEAN;

If f is true, the Chooser will put up the page setup alert; if f is false it won’t.

SetChooserAlert returns the original alert state. The application should restore the original
alert state when it exits.

Assembly-language note: If the psAlert bit of the low-memory global HiliteMode is 0
then no page setup alert will be generated. Applications that set or clear this bit must be
sure not to affect any other bits in the byte and to restore the bit as they leave.
HiliteMode
psAlert
belr
bset

equ
$938
equ
6
#psAlert,HiliteMode
#psAlert, HiliteMode

Chooser Changes V-431

bo
oe)
=)
©
=<
©

met

o5
=
o>
ve
te

Inside Macintosh

Device

Package

Function

When the device package is called, the device file will be the current resource file, the
Chooser’s window will be the current grafPort, and the System Folder of the current
startup disk will be the default volume. The device package must preserve all of these.

V-432 Chooser Changes

The Device Manager

SUMMARY

OF THE

DEVICE

MANAGER

Routines
FUNCTION

OpenSlot

FUNCTION

SIntInstall(sIntQElemPtr:

FUNCTION

SIntRemove

(paramBlock:

paramBlkPtr;

(sIntQElemPtr:

SQElemPtr;

Assembly-Language

Information

Device

Data

Control

Entry

aSync:

SQElemPtr;

BOOLEAN)

theSlot:
theSlot:

: OsErr;

INTEGER
INTEGER)

)

:
:

OsErr;

OsErr;

Structure

dCtlFlags
Flags (word)
dCtlQueue
Queue flags: low-order byte is driver’s version number (word)
dCtlQHead _— Pointer to first entry in driver’s I/O queue
dClQTail
Pointer to last entry in driver’s I/O queue
dCtlPosition
Byte position used by Read and Write calls (long)
dCtlStorage
Handle to RAM driver’s private storage
dCtlRefNum_

Driver’s reference number (word)

dCtlEMask

Desk accessory event mask (word)

dCtlWindow
dCtlDelay
dCtlMenu

dCtlSlot

dCtlSlotID

dCtlDevBase

reserved

dCtlExtDev

Slot

Pointer to driver’s window
Number of ticks between periodic actions (word)
Menu ID of menu associated with driver (word)

Slot number (byte)

— Resource directory ID number for sResource (byte)
Device base address (pointer)

Longint reserved for future use (should be 0)

_ External device ID (byte)

Queue

Element

SQLink
SQType

EQU
EQU

0
4

;link to next element
(pointer)
;queue
type
ID for validity
(word)

SQAddr
SQParm

EQU
EQU

8
12

jinterrupt
service
routine
(pointer)
;optional
Al parameter
(long)

EQU

6

SQPrio

SIQType

EQU

6

jpriority

;slot

(low

interrupt

byte

of

queue

word)

element

type

Summary of the Device Manager V-433

iS)
Ww
—
©
as
er)
©
D
=|
f
ge
©ae |

Inside Macintosh

OpenSlot

Parameter

Blocks

If {Multi bit in ioFlags = 0:
>
12
ioCompletion
e
_

16
18

ioResult
ioNamePtr

26

ioPermssn

e

22

>

28

_
>

34
35

=

~

ioRefNum
ioMix

32

ioFlags

ioSlot
iold

If {Multi bit in ioFlags = 1:

ame

12

16
18
22
26

>

28

ioMix

>

34

ioSEBlkPtr

>

32

Macro
Pascal

ioCompletion

ca
—
—
~

ioResult
ioNamePtr
ioRefNum
ioPermssn

ioFlags

Names
Name

sIntInstall
sIntRemove

Macro

Name

_sIntInstall
_sIntRemove

V-434 Summary of the Device Manager

pointer
word
pointer

word
byte

pointer
word
byte
byte
pointer
word
pointer

word
byte

pointer
word
pointer

24 THE
436
436
437

438
439
44]
442
444
451
456
456
457
458

SLOT

MANAGER

About This Chapter

Slot Card Firmware
Slot Manager Routines
Data Types
Slot Parameter Block
SExec Block
Principal Slot Manager Routines
Specialized Slot Manager Routines
Advanced Slot Manager Routines
Status Results
Fatal Errors
Nonfatal Errors
Summary of the Slot Manager

V-435

Inside Macintosh

ABOUT

THIS CHAPTER

This chapter describes the Slot Manager section of the Macintosh II ROM. The Slot
Manager contains routines that let your program identify cards plugged into NuBus slots in
the Macintosh II and communicate with the firmware on each card.
Note: The Macintosh SE computer also has slots, but they work differently. For an
explanation of Macintosh SE slots, see the book Designing Cards and Drivers for
Macintosh II and Macintosh SE.
Reader’s guide: You need the information in this chapter only if you are writing
an application, driver, or operating system that must access a slot card directly.
Otherwise, the standard Macintosh Toolbox and Operating System routines normally
take care of all slot card management, making the Slot Manager transparent to most
applications.

The Slot Manager routines described in this chapter are divided into three sections:
a The section “Principal Slot Manager Routines” describes routines that you might need
if you are writing an application or a driver.

u The section “Specialized Slot Manager Routines” describes routines that you might
need if you are writing a driver.

m The section “Advanced Slot Manager Routines” describes routines that are normally
used only by the operating system. This section is included for completeness of
documentation.
Note: When accessing NuBus cards directly, it is important that you use the
standard Slot Manager routines. If you try to bypass them, your application may
conflict with other applications and probably will not work in future Apple

computers.

Before trying to use the information in this chapter, you should already be familiar with the
Device Manager. If you are writing a driver, you should also be familiar with
a the information in the book Designing Cards and Drivers for Macintosh II and
Macintosh SE
m the architecture and mode of operation of the specific card or cards your driver will
access

SLOT CARD

FIRMWARE

Most of the routines described in this chapter let you access data or code structures residing

in the firmware of all NuBus plug-in cards. These structures are described in detail in the

book Designing Cards and Drivers for Macintosh II and Macintosh SE. They have certain

V-436 Slot Card Firmware

The Slot Manager
uniform features that create a standard interface to the Slot Manager.
firmware structures are the following:

The principal card

a A format block, containing format and identification information for the card’s
firmware and an offset to its sResource directory
= An sResource directory, containing an identification number and offset for each
sResource list in the firmware
= A Board sResource list, containing information about the slot card itself
uw One or more other sResource lists, each of which contains information about a

single sResource in the card’s firmware

Don’t confuse sResources on plug-in cards with standard Macintosh resources; they are
different, although related conceptually. Every sResource has a type and a name. It may
also have an icon and driver code in firmware, and may define a region of system memory
allocated to the card itis in. Such sResources are treated like devices.

Some sResources,

however, may contain only data—for example, special fonts. You must understand the
specific nature of an sResource before trying to access it with the Slot Manager.

The physical location of a slot card’s firmware is called its declaration ROM.

The Slot

Manager maintains a table, called the Slot Resource Table, of all sResources currently
available in the system.

For full details about slot card firmware, see the book Designing Cards and Drivers for
Macintosh IT and Macintosh SE.

nN
=

co
i)
as
a
=
I

Fe

7)

SLOT MANAGER

a

ROUTINES

The Slot Manager is a section of the Macintosh II ROM containing routines that

communicate with NuBus card firmware. This section discusses them under three

headings:

a the four principal routines—those used by virtually any driver or application that needs
to manage a NuBus card directly
m the specialized routines—those that might be used by a driver
m the advanced routines—those normally used only by the Macintosh II operating
system
Assembly-language

note:

You can invoke each of the Slot Manager routines

with a macro of the same name preceded by an underscore.

These macros, however,

aren’t trap macros themselves; instead they expand to invoke the trap macro
_SlotManager. The Slot Manager then determines the routine to execute from the
routine selector, a long integer that’s passed in register DO. The routine selectors
are the following:

Slot Manager Routines V-437

Inside Macintosh
SReadByte
SReadWord
SReadLong

EQU
EQU
EQU

0
1
2

SGetCString

EQU

3

SGetBlock

EQU

5

SFindStruct

EQU

6

SReadStruct

EQU

7

SReadinfo
SReadPRAMRec

EQU
EQU

16
L?

SPutPRAMRec

EQU

18

SReadFHeader

EQU

19

SNextRsrc
SNextTypesRsrc

EQU
EQU

20
21

SRsrcinfo

EQU

22

SCkCardStatus

EQU

24

SReadDrvrName
SFindDevBase

EQU
EQU

25
ZT

InitSDeclMgr

EQU

32

SPrimaryInit
SCardChanged

EQU
EQU

33
34

SExec

EQU

35

SOffsetData
InitPRAMRecs

EQU
EQU

36
Hd

SReadPBSize
SCalcStep

EQU
EQU

38
40

InitsRsrcTable

EQU

41

SSearchSRT

EQU

42

SUpdateSRT
SCalcsPointer

EQU
EQU

43
44

SGetDriver

EQU

45

SPtrToSlot

EQU

46

SFindsInfoRecPtr
EQU
SFindsRsrcPtr
EQU

47
48

SdeleteSRTRec

49

EQU

At the time the trap macro is called, register AO must contain a pointer
to the Slot Parameter Block, described in the next section.

the routine leaves a result code in register DO.

Data

On exit,

Types

The following data types are used for communication with the Slot Manager routines:
Data type

Description

Byte

8 bits, signed or unsigned

Word

16 bits, signed or unsigned

V-438 Slot Manager Routines

The Slot Manager
Long
cString
sBlock

32 bits, signed or unsigned
One-dimensional array of bytes, the last of which has the value $00
Data structure starting with a 4-byte header that gives the total sBlock size

The bit formats of the word, long, and sBlock data types are shown in Figure 1.
Word:
15

8

7

)

Long:
31

24

23

16

#15

8

7

0

sBlock:

0

Physical Block Size

Ww
—

Data Structure

of
=a
=

=

i)
ge
@~

Figure 1. Word, Long, and sBlock Data Types

Note:

Pointers are always of type long. The value of a null pointer is $00000000.

Slot

Parameter

Block

Data transfer between the Slot Manager and card firmware takes place through the Slot
Parameter

Block, which has this structure:

TYPE

SpBlockPtr
SpBlock

=
=

“SpBlock;
PACKED
RECORD

spResult:

LONGINT;

spsPointer:

spSize:

Ptr;

LONGINT;

spOffsetData:

LONGINT;

{FUNCTION result used
{ every function}
{structure

{size

Ptr;

pointer}
field

used

by

IOFile

name

used

}

sOffsetData}

{pointer
{

}

structure}

{offset/data
{

spIOFileName:

of

by

by

to

}

sDisDrvrName}

Slot Manager Routines V-439

A

Inside Macintosh
SpsExecPBlk:

Ptr;

spStackPtr:
Ptr;
spMisc: LONGINT;
spReserved:
LONGINT;
splIOReserved:
spRefNum:

INTEGER;

INTEGER;

{pointer to sExec parameter
{ block}
{old Stack pointer}
{misc field for SDM}
{reserved for future
}
{ expansion}
{reserved field of Slot }
{ Resource Table}
{RefNum}

spCategory:
INTEGER;
spCType:
INTEGER;

{sType:Category}
{sType: Type}

spDrvrSW:
spDrvrHW:

INTEGER;
INTEGER;

{sType:DrvrSw}
{sType:DrvrHWw}

spTBMask:

SignedByte;

{type bit mask
(Bits 0..3 }
{ mask words 0..3}
{slot number}
{structure ID}
{ID of the external device}
{ID of the hardware device}
{ByteLanes from format block
{ in card ROM}
{standard flags}
{internal use only}

spSlot:
SignedByte;
spID:
SignedByte;
SpExtDev:
SignedByte;
spHWDev:
SignedByte;
spByteLanes:
SignedByte;
spFlags:
SignedByte;
spKey:
SignedByte;
END;

Assembly-language note: The Slot Parameter Block has the following
structure in assembly language:
spResult

spsPointer

spOffsetData

Structure pointer (long)
Offset/Data field (long)

splOFileName

Pointer to IOFileName (long)

spRefNum

Slot Resource Table reference number (word)

spsExecBlk
spStackPtr
spMisc
spReserved
spIOReserved

Pointer to sExec parameter block (long)
Old stack pointer (long)
Reserved for Slot Manager (long)
Reserved (long)
Reserved field of Slot Resource Table (word)

spCategory
spType
spDrvrSW
spDrvrHW
spTBMask

sResource type: Category (word)
sResource type: Type (word)
sResource type: Driver software identifier (word)
sResource type: Driver hardware identifier (word)
Aine bit eee (byte)

spld
spExtDev
spHWDev
tS ora
spFlags
spKey
spBlockSize

sResource list ID (byte)
External device identifier (byte)
Hardware device identifier (byte)
ByteLanes value from format block in card firmware (byte)
Standard flags (byte)
Reserved (byte)
Size of Slot Parameter Block

spSlot

\

Function result (long)

Slot number (byte)

V-440 Slot Manager Routines

}

}

The Slot Manager

SExec

Block

For the routine sExec, data transfer between the Slot Manager and card firmware also takes

place through the SExec Block, which has this structure:
SEBlockPtr
SEBlock

=
=

“SEBlock;
PACKED
RECORD

seSlot:
sesRsrcld:

SignedByte;
SignedByte;

{slot number}
{sResource Id}

seStatus:

INTEGER;

{status

seFlags:
seFiller0:

SignedByte;
SignedByte;

{ sExec}
{flags}
{filler--SignedByte

seFillerl:
seFiller2:

SignedByte;
SignedByte;

{filler}
{filler}

seDevice:
sePartition:
seOSType:
seReserved:
seRefNum:
seNumDevices:

SignedByte;
SignedByte;
SignedByte;
SignedByte;
SignedByte;
SignedByte;

seResult:
seIOFileName:

seBootState:
END;

LONGINT;
LONGINT;

SignedByte;

{

on

of

word

code

executed

boundary}

{result
of sLoad}
{pointer
to IOFile

to

by

}

align

name}

{which device to read from}
{the partition}
{type of OS}
{reserved field}
{RefNum of the driver}
{number of devices to load}
{state

of

StartBoot

}

code}

tn
ee

oA

<

=A

Assembly-language
assembly language:

note:

The SExec Block has the following structure in

seSlot
sesRsrcld

Slot number (byte)
sResource list ID (byte)

seFlags
seFillerO

Flags (byte)
Filler (byte)

seStatus

seFillerl
seFiller2

seResult

Status of code executed by sExec (word)
Filler (byte)
Filler (byte)

Result of sLoad (long)

selOFileName
seDevice

Pointer to IOFile name (long)
Which device to read from
(byte)

seReserved
seRefNum
seNumDevices

Reserved (byte)
RefNum of the driver (byte)
Number of devices to load (byte)

sePartition
seOSType

seBootState

Device partition (byte)
Operating system type (byte)

Status of the StartBoot code

(byte)

Slot Manager Routines V-44]

&
=
ms

ve

©
=

Inside Macintosh

The seOSType parameter has these values:
Name

Value

Description

sMacOS68000

1

Load routine will run on a Macintosh computer with

sMacOS68020

2

Load routine will run on a Macintosh computer with
MC68020 processor

MC68000 processor

Other values may be used for future Macintosh family operating systems.

Principal

Slot

Manager

Routines

The routines described in this section are available to drivers and applications that need to
perform slot management tasks beyond those automatically provided by the system. Their
principal purpose 1s to find slot devices and open their drivers.
The description of each Slot Manager routine specifies which parameters are required for
communication with the routine. A right-pointing arrow indicates that the parameter is an

input to the routine; a left-pointing arrow indicates that it is an output. Other parameters

whose values may be affected by the routine are also listed. Parameters not mentioned
remain unchanged.

Assembly-language note: All Slot Manager routines return a status result in
the low-order word of register DO after execution. A DO value of zero indicates
successful execution. O er DO values are listed under “Status Results” later in this
section. All routines report fatal errors (those that halt program execution); some may
also report nonfatal errors. The description of each routine specifies if it can return
status values indicating nonfatal errors.

FUNCTION

SRsrcInfo(spBlkPtr:

SpBlockPtr)

:

OSErrs

Required Parameters

TLILTT
TTT TT

Trap macro: _SRsrcInfo
spsPointer
splOReserved
spRefNum
spCategory
spCType
spDrvrSW
spDrvrHW
spSlot
spld
spExtDev
spHWDev

The trap macro SRsrcInfo returns an sResource list pointer (spsPointer), plus the
sResource type (category, cType, software, and hardware), driver reference number

\

V-442 Slot Manager Routines

The Slot Manager
(spRefNum), and Slot Resource Table ioReserved field (splOReserved) for the

sResource

specified by the slot number spSlot, sResource list identification number spId, and external
device identifier spExtDev. This call is most often used to return the driver reference

number.

FUNCTION

SNextsRsrc(spBlkPtr:

SpBlockPtr)

:

OSErr;

Required Parameters

TITTTTTT
ELS

Trap macro: _SNextsRsre
spSlot
splId
spExtDev
spsPointer
spRefNum
splOReserved
spCategory
spCType
spDrvrSW
spDrvrH W
spHWDev

Starting from a given slot number spSlot, sResource list identification number spId, and
external device identifier spExtDev, the trap macro SNextsRsrc returns the slot number,
sResource list identification number, sResource type (category, cType, software, and
hardware), driver reference number (spRefNum), and Slot Resource Table ioReserved

field (spIOReserved) for the next sResource. If there are no more sResources, SNextsRsrc
returns a nonfatal error status. This routine can be used to determine the set of all
sResources in a given slot card or NuBus configuration.
FUNCTION

SNextTypesRsrc(spBlkPtr:

SpBlockPtr)

:

OSErr;

Required Parameters

TITTITTTL
ITS

Trap macro: _SNextTypesRsrc

spSlot

spld
spExtDev
spTBMask
spsPointer
spRefNum
splOReserved
spCategory
spCType
spDrvrSW
spDrvrH W
spHWDev

Given an sResource type (category, cType, software, and hardware) and spTBMask, and
starting from a given slot number spSlot and sResource list identification number splId, the
trap macro SNextTypesRsrc returns the slot number spSlot, sResource list identification

Slot Manager Routines V-443

nN
hen

Se
Scos

ss)
=
is)

ge

@-—

Inside Macintosh
number spId, sResource type, driver reference number (spRefNum), and Slot Resource
Table ioReserved field (splOReserved) for the next sResource of that type, as masked. If
there are no more sResources of that type, SNextTypesRsrc returns a nonfatal error report.
The spTBMask field lets you mask off specific fields of the sResource type that you don’t
care about, by setting any of bits 0-3. Bit 3 masks off the spCategory field; bit 2 the
spCType field; bit 1 the spDrvrSW field; and bit 0 the spDrvrHW field.
This procedure behaves the same as sNextsRsrc except that it returns information only
about sResources of the specified type.
FUNCTION

SReadDrvrName(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SReadDrvrName
Required Parameters

>
a
ad

Other Parameters Affected

spSlot
splId
spResult
spSize
spsPointer

The trap macro SReadDrvrName reads the name of the sResource corresponding to the slot
number spSlot and sResource list identification number spId, prefixes a period to the value
of the cString and converts its type to Str255. It then reads the result into a Pascal string
variable declared by the calling program and pointed to by spResult. The final driver name

is compatible with the Open routine.

Specialized

Slot

Manager

Routines

The routines described in this section are used only by drivers. They find data structures in
slot card firmware.
FUNCTION

SReadByte(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SReadByte
Required Parameters

aa
ame
e

Other Parameters Affected

spsPointer
spld
spResult

spOffsetData
spByteLanes

The trap macro SReadByte returns in spResult an 8-bit value identified by spId from the
sResource list pointed to by spsPointer. This routine’s low-order byte can return nonfatal

error reports.

V-444 Slot Manager Routines

The Slot Manager
FUNCTION

SReadWord(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SReadWord
>

TL

Required Parameters

spsPointer
spId
spResult
spOffsetData
spByteLanes

Other Parameters Affected

The trap macro SReadWord returns in the low-order word of spResult a 16-bit value
identified by spId from the sResource list pointed to by spsPointer. This routine can return
nonfatal error reports.
FUNCTION

sReadLong(spBlkPtr:

SpBlockPtr)

: OSErr;

Trap macro: _SReadLong
>

TL

Required Parameters

spsPointer
splId
spResult

bors
2
SS

spOffsetData
spByteLanes
spSize

Other Parameters Affected

>

=
=
ga@
ber

The trap macro SReadLong returns in spResult a 32-bit value identified by spId from the
sResource list pointed to by spsPointer. This routine can return nonfatal error reports.
FUNCTION

SGetCString(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SGetCString
Required Parameters

axa
3
<_

Other Parameters Affected

spsPointer
spId
spResult
spOffsetData
spByteLanes
spSize
spFlags

The trap macro SGetCString copies a cString identified by spId from the sResource list
pointed to by spsPointer to a buffer pointed to by spResult. Memory for this buffer is
automatically allocated by SGetCString.

Slot Manager Routines V-445

|

Inside Macintosh
FUNCTION

SGetBlock(spBlkPtr:

SpBlockPtr)

: OSErr;

Trap macro: _SGetBlock
Required Parameters

ama
ae
-

spsPointer
splId
spResult

Other Parameters Affected

spOffsetData
spByteLanes
spSize
spFlags

The trap macro SGetBlock copies the sBlock from the sResource list pointed to by
spsPointer and identified by spId into a new block and returns a pointer to it in spResult.
€ pointer in spResult should be disposed of by using the Memory Manager routine
DisposPtr.
FUNCTION

SFindStruct

(spBlkPtr:

SpBlockPtr)

: OSErr;

Trap macro: _ sFindStruct
Required Parameters

—
o

spId |
spsPointer

Other Parameters Affected

spByteLanes

The trap macro SFindStruct returns a pointer to the data structure defined by spld in the
sResource list pointed to by spsPointer.
FUNCTION

SReadStruct

(spBl1kPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SReadStruct
Required Parameters

>
i
>

Other Parameter Affected

spsPointer
spSize
spResult
spByteLanes

The trap macro sReadStruct copies a structure of size spSize from the sResource list

sige to by spsPointer into a new block allocated by the calling program and pointed to
y spResult.

FUNCTION

SReadInfo(spBlkPtr:

SpBlockPtr)

Trap macro: _SReadInfo
Required Parameters

>
>

V-446 Slot Manager Routines

spSlot
spResult

:

OSErr;

The Slot Manager

Other Parameter Affected

spSize

The trap macro SReadInfo reads the sInfo record identified by spSlot into a new record
allocated by the calling program and pointed to by spResult. Here is the structure of the
sInfo record:
TYPE

SInfoRecPtr
SInfoRecord

=
=

“*“SInfoRecord;
PACKED
RECORD

siDirPtr:
siInitStatusA:

Ptr;
INTEGER;

SiInitStatusV:

INTEGER;

siState:
SsiCPUByteLanes:

SignedByte;
SignedByte;

SiTOpOfROM:

SignedByte;

siStatusFlags:
siTOConstant:

SignedByte;
INTEGER;

siReserved:

SignedByte;

{pointer to directory}
{initialization error}
{status

{

END;
Assembly-language
assembly language:
siDirPtr

note:

bus

Each bit set signifies a byte lane used (byte)

}

error}

;
.
Pointer to sResource directory (long)

siCPUByteLanes
siTOConst
siReserved
sInfoRecSize

}

The sInfo record has the following structure in

Fundamental error (word)

siTopOfROM
siStatusFlags

by

{reserved}

silnitStatusA

silnitStatus V
siState

returned

{ vendor init code}
{initialization state}
{0=[d0..d7],
}
{. T= [d8', aS},
2.3
{top of ROM = SFSFFFFFx,
{ where x is TopOfROM}
{bit 0--card is changed}
{timeout constant for }

_

Status returned by vendor init code (word)
Initialization state—primary, secondary (byte)
x such that Top of ROM = $FsFFFFFx (byte)
Bit 0 indicates if card has been changed (byte)

Timeout constant for bus error (word)
Reserved—amust be 0 (byte)
Size of sInfo record

The siDirPtr field of the sInfo record contains a pointer to the sResource directory in the
configuration ROM. The silnitStatusA field indicates the result of efforts to initialize the
card. A zero value indicates that the card is installed and operational. A non-zero value is
the Slot Manager error code indicating why the card could not be used.
The silnitStatusV field contains the value returned by the card's primary initialization code
(in the seStatus field of the seBlock). Negative values cause the card to fail initialization.
Zero or positive values indicate that the card is operational.
The siState field is used internally to indicate what initialization steps have occurred so far.
The siCPUByteLanes field indicate which byte lanes are used by the card.

Slot Manager Routines V-447

PN

R
S
=
=
nS
98
zs

Inside Macintosh

The siTopOfROM field gives the last nibble of the address of the actual ByteLanes value in
the fHeader record.

The siStatusFlags field gives status information about the slot. Currently only the
fCardIsChanged bit has meaning. A value of 1 indicates that the board ID of the installed
card did not match the ID saved in parameter RAM—in other words, the card has been
changed.

The siTOConstant field contains the number of retries that will be performed when a bus
error occurs while accessing the declaration ROM. It defaults to 100, but may be set to
another value with the TimeOut field in the board sResource of the card.
The siReserved field is reserved and should have a value of 0.
FUNCTION

SReadPRAMRec(spBlkPtr:

SpBlockPtr)

: OSErr;

Trap macro: SReadPRAMRec
Required Parameters

>
—

spSlot
spResult

Other Parameter Affected

spSize

The trap macro SReadPRAMRec copies the sPRAM record data for the slot identified by
spSlot to a new record allocated by the calling program and pointed to by spResult.
One sPRAM record for each slot resides in the Macintosh II parameter RAM. The sPRAM
record is initialized during startup by InittPRAMRecs, described below under “Advanced
Routines”. Here is its structure:
TYPE

SPRAMRecPtr

SPRAMRecord

=

=

“SPRAMRecord;

PACKED RECORD
boardID:

INTEGER;

{Apple-defined card
{ identification}

}

vendorUsel:

SignedByte;

{reserved

for

vendor

use}

vendorUse2:
vendorUse3:

SignedByte;
SignedByte;

{reserved
{reserved

for
for

vendor
vendor

use}
use}

vendorUse4:

SignedByte;

{reserved

for

vendor

use}

vendorUse5:

SignedByte;

{reserved

for

vendor

use}

{reserved

for

vendor

use}

vendorUse6:

SignedByte;

END;

Assembly-language
assembly language:
boardID

vendorUsel
vendorUse2

vendorUse3

note:

The sPRAM record has the following structure in

Apple-defined card indentification (word)

Reserved for vendor use (byte)
Reserved for vendor use (byte)

Reserved for vendor use (byte)

V-448 Slot Manager Routines

The Slot Manager
vendorUse4
vendorUse5

vendorUse6

Reserved for vendor use (byte)
Reserved for vendor use (byte)

Reserved for vendor use (byte)

If a card is removed from its slot, the corresponding sPRAM record is cleared at the next
system startup. If a different card is plugged back into the slot, the corresponding sPRAM
record is reinitialized. A flag is set each time an SPRAM record is initialized, to alert the
Start Manager.
FUNCTION

SPutPRAMRec(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SPutPRAMRec

Required Parameters

=>

spSlot

->

spsPointer

The trap macro SPutPRAMRec copies the logical data from the block referenced by
spsPointer into the sPRAM record for the slot identified by spSlot. This updates the
Macintosh PRAM for that slot. The sPRAM record is defined above under
SReadPRAMRec. In this record, the field boardId is an Apple-defined field and is
protected during execution of SPutPRAMRec.

t

FUNCTION

=

SReadFHeader (spBlkPtr:

SpBlockPtr)

: OSErr;

Trap macro: _SReadFHeader

Required Parameters

=

ae
oma

spSlot
spResult

Other Parameters Affected

2

spsPointer
spByteLanes
spSize
spOffsetData

The trap macro SReadFHeader copies the format block data for the slot designated by
spSlot to an FHeader record allocated by the calling program and pointed to by spResult.
Here is the structure of FHeader:
TYPE
FHeaderRecPtr
FHeaderRec

=
=

“FHeaderRec;
PACKED
RECORD

fhDIROffset:

LONGINT;

{offset

£fhROMRev:
fhFormat:

SignedByte;
SignedByte;

{revision
{format -

fhLength:
EhHCRC:

fhTstPat:
fhReserved:

fhByteLanes:

END;

LONGINT;
LONGINT;

LONGINT;
INTEGER;

SignedByte;

{length
{CRC}

to
of

directory}
ROM}

of
2}

ROM}

{test pattern}
{reserved}

{ByteLanes}

Slot Manager Routines V-449

Inside Macintosh

Assembly-language
assembly language:

note:

The FHeader record has the following structure in

fhDIROffset
fhLength

Offset to sResource directory (long)
Length
of card’s declaration ROM (long)

fhROMRev

ROM revision number (byte)

fhCR

Declaration ROM checksum (long)

fhFormat
fhTstPat

ROM format number (byte)
Test Pattern (long)

fhByteLanes
fhSize

Byte lanes used (byte)
Size of the FHeader record

fhReserved

Reserved (byte)

The fHeader record exists at the highest address of a card’s declaration ROM, and should
therefore be visible at the highest address in the card’s slot space. The Slot Manager uses
the fHeader record to verify that a card is installed in the slot, to determine its physical

connection to NuBus (which byte lanes are used), and to locate the sResource directory.

The fhDIROffset field of the fHeader record is a self-relative signed 24-bit offset to the
sResource directory. The high order byte must be 0, or a card initialization error occurs.

The fhLength field gives the size of the configuration ROM.
The fhCRC field gives the cyclic redundancy check (CRC) value of the declaration ROM.

The CRC value itself is taken as zero in the CRC calculation.

The fhRomRev field gives the revision level of this declaration ROM.
than 9 cause a card initialization error.
The fhFormat field identifies the format of the configuration ROM.
(appleFormat ) is currently recognized as valid.

Values greater

Only the value 1

The fhTstPat field is used to verify that the fhByteLanes field is correct.
The fhReserved field must be zero.
The fhByteLanes field indicates what NuBus byte lanes are used by the card. Byte lanes
are described in the “Access to Address Space” chapter of Designing Cards and Drivers for
Macintosh II and Macintosh SE.
FUNCTION

SCkCardStatus(spBlkPtr:

Trap macro: _SCkCardStatus
Required Parameter

-

Other Parameter Affected

V-450 Slot Manager Routines

spSlot
spResult

SpBlockPtr)

:

OSErr;

The Slot Manager
The trap macro SCkCardStatus checks the InitStatusA field of the sInfo record of the slot
designated by spSlot, which also reflects the value of InitStatusV. If this field contains a
nonzero value, SCkCardStatus returns a zero value. The sInfo record is described above
under SReadInfo. The sCkCardStatus routine can return nonfatal error reports.

Trap macro: _SFindDevBase
Required Parameters

—

—
<—

spSlot

spId
spResult

The trap macro SFindDevBase returns a pointer in spResult to the base of a device whose
slot number is in spSlot and whose sResource id is in spId. The base address of a device
may be in either slot or superslot space but not in both. Slot or superslot slot spaces are
discussed in the book Designing Cards and Drivers for Macintosh II and Macintosh SE.
FUNCTION

SDeleteSRTRec(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SDeleteSRTRec
Required Parameters

aa
>
>

spSlot
splId
spExtDev

nN
hee

The trap macro SDeleteSRTRec deletes from the system’s Slot Resource Table the
sResource defined by spId,spSlot, and spExtDev.
FUNCTION

SPtrToSlot

(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SPtrToSlot
Required Parameters

>
—

spsPointer
spSlot

The trap macro SPtrToSlot returns in spSlot the slot number of the card whose declaration
ROM is pointed to by spsPointer. The value of spsPointer must have the form Fsxx xxxx,
where s is a slot number.

Advanced

Slot

Manager

Routines

The routines described in this section are used only by the Macintosh II operating system.
They are described here just for completeness of documentation.
FUNCTION

InitSDeclMgr(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _InitSDeclMgr

Slot Manager Routines V-451

<2.
S
-_

=
=
m&
i)@

=y

Inside Macintosh

The trap macro InitSDeclMegr initializes the Slot Manager. The contents of the parameter
block are undefined. This procedure allocates the sInfo array and checks each slot for a
card. If a card is not present, an error is logged in the initStatusA field of the sInfoRecord
for that slot; otherwise the card’s firmware is validated, and the resulting data is placed in
the slot’s sInfoRecord. The sInfoRecord is described above under SReadInfo.
FUNCTION

SPrimaryInit

(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SPrimaryInit
Required Parameter

>

spFlags

The trap macro SPrimaryInit initializes each slot having an sPrimaryInit record. It passes
the spFlags byte to the initialization code via seFlags. Within that byte the fWarmStart bit
should be set to 1 if a warm start is being performed.
FUNCTION

SCardChanged(spBlkPtr:

SpBlockPtr)

: OSErr;

Trap macro: _SCardChanged
Required Parameters

axa
e—

spSlot
spResult

The trap macro SCardChanged returns a value of true in spResult if the card in slot spSlot
has been changed (that is, if its sPRAMRecord has been initialized); otherwise it returns
false.
FUNCTION

SExec(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SExec
Required Parameters

->
aa
>

Other parameters affected:

spsPointer
spId
spsExecPBlk

spResult

The trap macro SExec loads an sExec code block from the sResource list pointed to by
spsPointer and identified by spId to the current heap zone, checks its revision level, checks
its CRC field, and executes the code. The status is returned in seStatus. The spsExecPBlk
field is presumed to hold a pointer to an sSExecBlock (described in the Card Firmware
chapter of Designing Cards and Drivers for Macintosh II and Macintosh SE), and is passed
to the sExec block code in register AO.

V-452 Slot Manager Routines

The Slot Manager
FUNCTION

SOffsetData(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SOffsetData
Required Parameters

>
—
co
co

Other Parameters Affected

spsPointer
spld
spOffsetData
spByteLanes
spResult
spFlags

The trap macro SOffsetData returns (in spOffsetData) the contents of the offset/data field
from the sResource list identified by spId and pointed to by spsPointer. The parameter
spsPointer returns a pointer to the fields’s identification number in the sResource list.
FUNCTION

SReadPBSize(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SReadPBSize
Required Parameters

~
=>
>
—
<—

spsPointer
spld
spFlags
spSize
spByteLanes

t
=
=
=

spResult

ys

i

Other Parameter Affected

The trap macro SReadPBSize reads the physical block size of the sBlock pointed to by
spsPointer and identified by spId. It also checks to see that the upper byte is 0 if the
fckReserved flag is set. The parameter spsPointer points to the resulting logical block when

SReadPBSize is done.
FUNCTION

SCalcStep(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SCalcStep
Parameters Required

~
>
>
am

spsPointer
spByteLanes
spFlags
spResult

The trap macro SCalcStep calculates the field sizes in the block pointed to by spBlkPtr. It is
used for stepping through the card firmware one field at a time. If the fConsecBytes flag is
set it calculates the step value for consecutive bytes; otherwise it calculates it for
consecutive IDs.

Slot Manager Routines V-453

Inside Macintosh
FUNCTION

InitsRsrcTable(spBlkPtr:

SpBlockPtr)

: OSErr;

Trap macro: _InitsRsrcTable

The trap macro InitsRsrcTable initializes the Slot Resource Table. It scans each slot and
inserts the slot, type, sRsrcId, sRsrcPtr, and HWDevID values into the table for every
sResource. It sets all other fields to zero. The contents of the parameter block are
undefined.
FUNCTION

InitPRAMRecs(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _InitPRAMRecs

The trap macro InitPRAMRecs scans every slot and checks its BoardId value against the
value stored for it in its sPRAM record. If the values do not match, then the
CardIsChanged flag is set and the Board sResource list is searched for an

sPRAMInitRecord. If one is found, the sPRAMRecord for the slot is initialized with this
data; otherwise it is initialized with all zeros.
FUNCTION

SSearchSRT(spBlkPtr:

SpBlockPtr)

: OSErr;

Trap macro: _SSearchSRT

Parameters Required

~
>
~
>
ae

spSlot
splId
spExtDev
spFlags
spsPointer

The trap macro SSearchSRT searches the Slot Resource Table for the record corresponding
to the sResource in slot spSlot with list spId and external device identifier spExtDev, and
returns a pointer to it in spsPointer. If the fckForNext bit of spFlags has a value of 0, it
searches for that record; if it has a value of 1, it searches for the next record.
FUNCTION

SUpdateSRT(spBlkPtr:

SpBlockPtr)

Parameters Required

bLbbbd

Trap macro: _SUpdateSRT

Other Parameters Affected

V-454 Slot Manager Routines

spSlot
splId
spExtDev
spRefNum
spIOReserved
spsPointer
spFlags
spSize
spResult

: OSErr;

The Slot Manager
The trap macro SUpdateSRT updates the Slot Resource Table records spRefNum and
spIOReserved with information about the sResource in slot spSlot with list spId and
external device identifier spExtDev. This routine is called by IOCore whenever the driver
for a slot device is opened or closed.
FUNCTION

SCalcSPtr(spBlkPtr:

SpBlockPtr)

: OSErr;

Trap macro: _SCalcSPtr
Parameters Required

=
_
Ka

spsPointer
spOffsetData
spByteLanes

The trap macro SCalcSPtr returns a pointer to a given byte in a card’s declaration ROM,
given the pointer to a current byte and an offset (spOffsetData) in bytes.
FUNCTION

SGetDriver(spBlkPtr:

SpBlockPtr)

: OSErr;

Parameters Required

TLiid

Trap macro: _SGetDriver

Other Parameters Affected

nN
_

spSlot
spId
spExtDev
spsExecPBlk
spResult

ve
S
-

a]

=
=
r=)@

spFlags
spSize

Lene |

The trap macro SGetDriver loads the driver corresponding to the sResource designated by
the slot number spSlot and the sResource list identification number spld into a relocatable
block on the system heap and returns a handle to it in spResult (referenced by AO in
assembly language). The driver can come from either of two sources:
m First, the sResource sLoad directory is checked for a Macintosh sLoadRecord. If one
is found, then the sLoad record is loaded into RAM and executed.
u If no sLoad record exists, the sResource sDriver directory is checked for an

sDriverRecord. If one is found, then the sDriver record is loaded into RAM.

FUNCTION

SFindsInfoRecPtr(spBlkPtr:

SpBlockPtr)

:

OSErr;

Trap macro: _SFindsInfoRecPtr

Parameters Required

—

ec

spSlot

spResult

Slot Manager Routines V-455

Inside Macintosh

The trap macro SFindsInfoRecPtr returns a pointer to the sInfoRecord identified by spSlot.
The sInfoRecord is described under SReadInfo.
FUNCTION

SFindsRsrcPtr(spBlkPtr:

SpBlockPtr):

OSErr;

Trap macro: _SFindsRsrcPtr
Parameters Required

e
ae
>

Other Parameter Affected

spsPointer
spSlot
splId
spResult

The trap macro SFindsRsrcPtr returns a pointer to the sRsrc list for the sRsrc identified by
spSlot, spID, and spExtDev.

Status

Results

All Slot Manager routines return a status result in register DO upon completion. Its value is
zero if execution was successful; otherwise it is one of the values listed below.

Fatal

Errors

In the event of a serious execution error (one that halts program execution), the Slot

Manager returns one of the following status values:
Value

Name

Description

-300
—-301
-302
—303

smEmptySlot
smCRCFail
smFormatErr
smRevisionErr

No card in this slot.
CRC check failed.
The format of the card’s declaration ROM is wrong.
The revision of the card’s declaration ROM is wrong.

-307

smResrvErr

A reserved field of the declaration ROM was used.

—304
—306
—308

-309
—-312
—313
—314

-315
-316
-317
—318
-319

smNoDir
smNosInfoArray
smUnExBusErr

smBLFieldBad
sm DisposePErr

smNoBoardsRsrc
smGetPRErr

smNoBoardld
smInitStatVErr
smInitTblErr
smNoJmpTbl
smBadBoardId

V-456 Slot Manager Routines

There is no sResource directory.
The SDM was unable to allocate memory for the sInfo array.
An unexpected bus error occurred.

A valid ByteLanes field was not found.
An error occurred during execution of DisposPointer.

There is no board sResource.
An error occurred during execution of sGetPRAMRec.

There is no board Id.
The InitStatus_V field was negative after Primary Init.
An error occurred while trying to initialize the sResource Table.
Slot Manager jump table could not be created.
BoardId was wrong; reinit the PRAM record.

The Slot Manager
Nonfatal

Errors

Some (but not all) of the Slot Manager routines may also indicate nonfatal execution
problems by returning one of the status values listed below. The discussion of each routine
earlier in this chapter indicates whether or not it can return a nonfatal error.
Value

-330
-331
332
-333
-334
335
-336
337
-338
-339
341
~342
-344
345
346
-347
-350
351

Name

Description

smBadRefld
smBadsList
smReservedErr
smCodeRevErr
smCPUErr
smsPointerNil

Reference ID was not found in the given sResource list.
The IDs in the given sResource list are not in ascending order.

smNilsBlockErr

smSlotOOBErr
smSelOOBErr
smNewPErr
smCkStatusErr
smGetDrvrNamErr
smNoMoresRsrcs
smGetDrvrErr
smBadsPtrErr

smByteLanesErr

smSRTOvrFlErr
smRecNotFnd

A reserved field was not zero.

The revision of the code to be executed by sExec was wrong.

The CPU field of the code to be executed by sExec was wrong.

The sPointer is NIL. No sResource list is specified.
The physical block size (of an sBlock) was zero.
The given slot was out of bounds (or does not exist).
Selector is out of bounds.
An error occurred during execution of NewPointer.
Status of slot is bad (InitStatus_A,V).
An error occurred during execution of sGetDrvrName.
No more sResources.

An error occurred during execution of sGetDrvr.

A bad sPointer was presented to a SDM call.
Bad ByteLanes value was passed to an SDM call.
Slot Resource Table overflow.
Record not found in the Slot Resource Table.

bre
dee

<2
S—
fe
=
=

ge

@-

Slot Manager Routines V-457

Inside Macintosh

SUMMARY

OF

THE SLOT MANAGER

Constants
CONST

{ seOSType parameter
sMacoS68000
= 1
sMacOS68020
= 2

Data

Types

values
{driver
{driver

}
will
will

run
run

with
with

68000
68020

processor}
processor}

TYPE

SpBlockPtr
SpBlock

=
=

“SpBlock;
PACKED RECORD
spResult:

LONGINT;

spsPointer:
spSize:
spOffsetData:

Ptr;
LONGINT;
LONGINT;

spIOFileName:

Ptr;

SpsExecPBlk:

Ptr;

{FUNCTION

{pointer
{

spStackPtr:
spMisc:

result

used

to

sExec

LONGINT;

{reserved

spIOReserved:

INTEGER;

{ expansion}
{reserved field of
{ Resource Table}

spRefNum:
spCategory:

INTEGER;

{RefNum}

INTEGER;

spCType:
spDrvrSw:

INTEGER;
INTEGER;

{sType:
{sType:

Category}
Type}

{sType:

DrvrSw}

spSlot:

spID:
SpExtDev:
SpHWDev:
SpByteLanes:

spFlags:
spKey:
END;

V-458 Summary of the Slot Manager

INTEGER;
SignedByte;
SignedByte;

SignedByte;
SignedByte;
SignedByte;

by

}

used

parameter

{old Stack pointer}
{misc field for SDM}

spDrvrHw:
SpTBMask:

}

}
}

block}

Ptr;
LONGINT;

spReserved:

by

{ every function}
{structure pointer}
{size of structure}
{offset/data field used
{ sOffsetData}
{pointer to IOFile name
{ by sDisDrvrName}

for

future

}

Slot

{sType:
DrvrHW}
{type bit mask
(Bits

0..3

{ mask words
0..3}
{slot number}

{structure
{ID of the
{ID of the

SignedByte;

{ByteLanes

SignedByte;
SignedByte;

{ in card
{standard
{internal

ID}
external
hardware
from

}

device}
device}

format

ROM}
flags}
use only}

}

block

}

The Slot Manager
SInfoRecPtr

SInfoRecord

=

“SInfoRecord;
PACKED

RECORD

siDirPtr:

Ptr?

siInitStatusA:

INTEGER;

{pointer to }
{ directory}
{initialization
{

}

error}

siInitStatusv:

INTEGER;

siState:

SignedByte;

{status returned by
{ vendor init code}
{initialization
}

siCPUByteLanes:

SignedByte;

{0=[d0..d7],

siTopOfROM:

siStatusFlags:
siTOConstant:

SignedByte;

{

state}

{

i= (48.4215),

{

SFSSFFFFx,

{Top

ROM

}
=

«s«}

}

where

SignedByte;

{ is
{bit

INTEGER;

{ changed}
{timeout
constant
{

siReserved:

of

SignedByte;

TopOfROM. }
0 - card is

for

bus

}

x

}

}
}

error}

{reserved)

END;
SeBlockPtr
SeBlock

nN
oo

“SeBlock;
PACKED

<2)
=S

RECORD

seSlot:

SignedByte;

{slot

sesRsrcld:

SignedByte;

seStatus:

INTEGER;

{sResource
{Status
of

{
seFlags:

seFiller0:

SignedByte;

SignedByte;

by

number}

<

Id}
code

executed

sExec. }

{flags}

{filler--SignedByte to }
{ align on word boundary}
{filler}
{filler}

seFiller2:

SignedByte;
SignedByte;

seResult:

LONGINT;

{result

seIOFileName:

LONGINT;

seDevice:

SignedByte;

{pointer to IOFile name}
{which device to read }

sePartition:

SignedByte;
SignedByte;
SignedByte;
SignedByte;
SignedByte;

{the

SignedByte;

{state of
{ code. }

seFillerl:

{
seOSType:
seReserved:
seRefNum:
seNumDevices:
seBootState:

of

sLoad}

from}

partition}

{type

of

{reserved

OS}

field}

{RefNum

of

the

{number

of

devices

{

load}

driver}

StartBoot

to

}
}

END;

Summary of the Slot Manager V-459

}

3

oe

©
mag

Inside Macintosh
SPRAMRecPtr
SPRAMRecord

=
=

“SPRAMRecord;
PACKED
RECORD

boardID:

INTEGER;

{Apple-defined card
{ identification}

}

vendorUsel:

SignedByte;

{reserved

for

vendor

use}

vendorUse2:

SignedByte;

{reserved

for

vendor

use}

vendorUse3:
vendorUse4:

SignedByte;
SignedByte;

{reserved
{reserved

for
for

vendor
vendor

use}
use}

vendorUse5:

SignedByte;

{reserved

for

vendor

use}

vendorUse6:

SignedByte;

{reserved

for

vendor

use}

fhDIROffset:
fhLength:

LONGINT;
LONGINT;

{offset
{length

fhROMRev:
fhFormat:
fhTstPat:

SignedByte;
SignedByte;
LONGINT;

{revision of ROM}
{format - 2}
{test pattern}

END;
FHeaderRecPtr =
FHeaderRec
=

*“FHeaderRec;
PACKED
RECORD

£hCRC:

fhReserved:

fhByteLanes:

LONGINT;

INTEGER;

SignedByte;

{CRC}

to
of

directory}
ROM}

{reserved}

{ByteLanes}

END;

Routines
Principal

Routines

FUNCTION

SRsrcInfo

(spBlkPtr:

SpBlockPtr)

FUNCTION

SNextTypesRsrc

(spBlkPtr:

SpBlockPtr)

FUNCTION

FUNCTION

SNextsRsrc

SReadDrvrName

Specialized

(spB1kPtr:

(spB1kPtr:

: OSErr;

SpBlockPtr)

OSErr;

SReadByte

(spB1kPtr:

SpBlockPtr)

FUNCTION

SReadLong

(spB1kPtr:

SpBlockPtr)

FUNCTION

SReadWord

SGetcString

FUNCTION

SGetBlock

FUNCTION

SReadInfo

FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION

SPutPRAMRec
SReadFHeader
SCkCardStatus
SFindDevBase
SDeleteSRTRec
SPtrToSlot

FUNCTION
FUNCTION

FUNCTION

:

OSErr;

Routines

FUNCTION
FUNCTION

OSErr;

SpBlockPtr)

SFindStruct
SReadStruct

SReadPRAMRec

(spB1kPtr:

(spB1kPtr:

(spB1kPtr:

(spBlkPtr:
(spBlkPtr:
(spB1kPtr:

(spBlkPtr:

(spB1lkPtr:
(spB1kPtr:
(spB1lkPtr:
(spB1kPtr:
(spBlkPtr:

V-460 Summary of the Slot Manager

OSErr;

SpBlockPtr)

OSErr;
OSErr;

SpBlockPtr)

: OSErr;

SpBlockPtr)
SpBlockPtr)

OSErr;
OSErr;

SpBlockPtr)

SpBlockPtr)

:

OSErr;

OSErr;

SpBlockPtr)

: OSErr;

SpBlockPtr)

OSErr;

SpBlockPtr)
SpBlockPtr)
SpBlockPtr)
SpBlockPtr)

:

OSErr;
OSErr;
OSErx:
OSErr;

The Slot Manager
Advanced
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION
FUNCTION

Routines
InitSDeclMgr

(spBlkPtr:

SExec
SOffsetData
SReadPBSize
SCalcStep
InitsRsrcTable
InitPRAMRecs
SSearchSRT
SUpdateSRT
SCalcSPointer
SGetDriver
SFindSInfoRecPtr
SFindSRsrcPtr

SPrimaryInit
SCardChanged

Assembly-Language

¢:
:

OSErrs
OSErr:

(spBlkPtr:
(spBlkPtr:
(SpB1kPtr:
(spBlkPtr:
(spB1kPtr:
(SspB1kPtr:
(SpB1lkPtr:
(spBlkPtr:

SpBlockPtr)
SpBlockPtr)
SpBlockPtr)
SpBlockPtr)
SpBlockPtr)
SpBlockPtr)
SpBlockPtr)
SpBlockPtr)
SpBlockPtr)
SpBlockPtr)
SpBlockPtr)

:
:
:
:

OSErrs
O8Srr?
OSErE}
OSErr:

:

OSErr;

(spB1kPtr:

SpBlockPtr)

:

(spB1LkPtr:
(SspBlkPtr:

¢
:

:
:

OSErE;
OSErrs

OSErE;
OSErr;
OSErr;:

Information

Constants
~

;

for

SlotManager

sReadByte
sReadWord
sReadLong

EQU
EQU
EQU

0
1
2

sFindStruct
sReadStruct
sReadiInfo

EQU
EQU
EQU

6
7
16

EQU
EQU
EQU
EQU
EQU

18
19
20
21
22

Routine

selectors

sGetcString
sGetBlock

sReadPRAMRec

sPutPRAMRec
sReadFHeader
sNextRsrec
sNextTypesRsrc
sRsrciInfo

sDisposePtr

sCkCardStatus
sReadDrvrName

EQU
EQU

EQU

EQU

23

InitSDeclMgr

EQU

32

sExec
sOffsetData

EQU
EQU

sPrimaryInit
sCardChanged
InitPRAMRecs

sReadPBSize

sCalcStep

InitsRsrcTable

sSearchSRT
sUpdateSRT
sCalcsPointer

EQU
EQU

EQU

EQU

27

33
34

35
36
37

38

EQU

40

EQU
EQU
EQU

42
43
44

EQU

de
es

17

24
25

EQU

=
<
5

3
5

EQU
EQU

sFindDevBase

wn

trap

41

Summary of the Slot Manager V-461

Inside Macintosh
sGetDriver
sPtrToSlot
sFindsInfoRecPtr
sFindsRsrcPtr
sdeleteSRTRec

Slot

Parameter

spResult
spsPointer
spOffsetData
splOFileName
spsExecBlk
spStackPtr
spMisc
spReserved
splOReserved
spRefNum
spCategory
spType
spDrvrSW
spDrvrHW
spTBMask
spSlot
spld
spExtDev
spHW Dev
spByteLanes
spFlags
spKey
spBlockSize
Slot

Executive

seSlot
sesRsrclId
seStatus

seFlags

seFillerO
seFiller1l
seFiller2
seResult
selOFileName
seDevice
sePartition

seOSType

seReserved
seRefNum
seNumDevices
seBootState

EQU
EQU
EQU
EQU
EQU

Block

45
46
47
48
49

Structure

Function result (long)

Structure pointer (long)

Offset/Data field (long)
Pointer to IOFileName (lon f)
Pointer to sExec parameter block (long)
Old stack pointer (long)
Reserved

for Slot Manager (long)

Reserved (long)
Reserved field of Slot Resource Table (word)
Slot Resource Table reference number (word)
sResource type: Category (word)
sResource type: Type (word)
sResource type: Driver software identifier (word)
sResource type: Driver hardware identifier (word)

type bit mask

(byte)

Slot number (byte)

sResource list ID (byte)
External device identifier (byte)

Hardware device identifier (byte)

ByteLanes value from format block in card firmware (byte)

Standard flags (byte)
Reserved (byte)

Size of Slot Parameter Block
Block

Structure

Slot number (byte)
sResource list ID (byte)

Status of code executed by sExec (word)
Flags (byte)
Filler (byte)

Filler (byte)

Filler (byte)

Result of sLoad (long)

Pointer to IOFile name (long)

Which device to read from (byte)
Device partition (byte)
nae
system type (byte)
Reserved (byte)
RefNum of the driver (byte)

Number of devices to load (byte)

Status of the StartBoot code (byte)

V-462 Summary of the Slot Manager

The Slot Manager
SInfo

Record

Structure
Pointer to sResource directory (long)
Fundamental error (word)
Status returned by vendor init code (word)
Initialization state—primary, secon
(byte)
Each bit set signifies a byte lane used (byte)
Top of ROM = $FssFFFFx, where x is siTopOfROM (byte)
Bit 0 indicates if card has been changed (byte)
Timeout constant for bus error (word)

siDirPtr
silnitStatusA
silnitStatus V
siState
siCPUByteLanes

siTopOfROM
siStatusFlags
siTOConst
siReserved
sInfoRecSize

FHeader

Reserved—must be 0 (byte)

Size of sInfo record

Record

Structure

Offset to sResource directory (long)

fhDIROffset
fhLength
fhCR
fhROMRev
fhFormat
fhTstPat
fhReserved
fhByteLanes
fhSize

Length

of card’s declaration ROM

Declaration ROM checksum (long)
ROM revision number (byte)
ROM format number (byte)
Test Pattern (long)

(long)

Reserved (byte)

nN
de

Byte lanes used (byte)
Size of the FHeader record

NM

S
—

SPRAM

Record

boardID
vendorUsel
vendorUse2
vendorUse3
vendorUse4
vendorUse5
vendorUse6

Trap

Macro

Structure
Apple-defined card indentification (word)
Reserved for vendor use (byte)

Reserved for vendor use (byte)

Reserved for vendor use (byte)

Reserved for vendor use (byte)
Reserved for vendor use (byte)

Reserved for vendor use (byte)

Name

_SlotManager

Summary of the Slot Manager V-463

=
=
m=
ga

g

25 THE
466
466
467
468

DEFERRED

TASK

MANAGER

About This Chapter
About the Deferred Task Manager

Deferred Task Manager Routine
Summary of the Deferred Task Manager

i)

wn

0
&.
©

ba

4

baer

4

©

a

i}

bo)

=

2)

oN)

=}

9

Fe
©
le

V-465

Inside Macintosh

ABOUT

THIS CHAPTER

This chapter describes the Deferred Task Manager, which provides improved interrupt

handling by allowing lengthy tasks to be deferred.

Reader’s guide: Lengthy tasks are usually initiated by slot cards. Hence you
normally need the information in this chapter only if your program deals with slot
card interrupts.

ABOUT

THE DEFERRED

TASK MANAGER

The Deferred Task Manager provides a way to defer the execution of interrupt tasks until
interrupts have been reenabled (processor priority level 0). It maintains a deferred task
queue; instead of performing a task immediately, you can place the information describing
the task into the queue by calling the DTInstall procedure. All system interrupt handlers
check this queue just before returning. If there are tasks in the queue and interrupts are
about to be reenabled, the tasks are removed and then executed with all interrupts enabled.
While useful for all types of interrupt tasks, the Deferred Task Manager is especially handy

for slot interrupts. Interrupts from NuBus slot devices are received and decoded by the

VIA2, a second Versatile Interface Adapter (Rockwell 6522) chip on the Macintosh l. The

VIA2 generates level-2 interrupts and, due to the way the VIA chip works, interrupts must
be serviced before the processor priority level can be lowered (otherwise, a system error
will occur). During this period (which could be quite long depending on the slot device)
other level-2 interrupts such as those for sound, as well as all level-1 interrupts, are
blocked. By using the Deferred Task Manager, the processing of slot interrupts can be
deferred until all the slots are scanned; just before returning, the slot interrupt handler
dispatches to any tasks in the deferred task queue.

The deferred task queue is a standard Macintosh Operating System queue, as described in
chapter 13 of Volume II. Each entry in the deferred task queue has the following structure:
TYPE

DeferredTask

=

RECORD

qLink:
qType:
dtFlags:
dtAddr:
dtParm:

dtReserved:

QElemPtr;
INTEGER;
INTEGER;
ProcPtr;
LONGINT;
LONGINT

{next queue entry}
{queue type}
{reserved}
{pointer to task}
{optional parameter}
{reserved--should

be

0}

END;

QLink points to the next entry in the queue, and qType indicates the queue type, which

must always be ORD(dtQType).
DT Addr

contains a pointer to the task. DTParm is useful only from assembly language.

V-466 About the Deferred Task Manager

The Deferred Task Manager
Assembly-language note:

DTParm lets you pass an optional parameter to be

loaded into register Al just before the task is executed.

DEFERRED
FUNCTION

TASK MANAGER

DTInstall

(dtTaskPtr:

ROUTINES

QElemPtr)

Trap macro

_DTinstall

On entry

AO: dtTaskPtr (pointer)

On exit

DO: result code (word)

:

OSErr;

Note: To reduce overhead at interrupt time, instead of executing the _DTInstall trap
you can load the jump vector jDTInstall into an address register other than AO and
execute a JSR instruction using that register.
DTInstall adds the specified task to the deferred task queue. Your application must fill in
all fields of the task except qLink. DTInstall returns one of the result codes listed below.
noErr

vIypErr

No error

_ Invalid queue element

SC

Result codes

o

o@
ar

Lea

4

@

2.

ae

nm

om

i? 2]

<

pe)

=)
~

it =)
@
Lew

Deferred Task Manager Routines V-467

4

Inside Macintosh

SUMMARY
Data
TYPE

OF THE DEFERRED

TASK MANAGER

Types
DeferredTask

=

RECORD

qLink:
qType:
dtFlags:
dtAddr:

dtParm:
dtReserved:

QElemPtr;
INTEGER;
INTEGER;
ProcPtr;

END;

{next queue entry}
{queue type}
{reserved}
{pointer
to task}

LONGINT;
LONGINT

{optional parameter}
{reserved--should be

Routines
FUNCTION

DTInstall

(dtTaskPtr:

Assembly-Language

QElemPtr)

:

OSErr;

Information

Routines
Trap macro

On entry

On

exit

_DTInstall

AO:

DO:

result code (word)

Structure

of

dtTaskPtr (ptr)

Deferred

Task

Manager

qLink
qT ype
dtFlags
dtAddr

Pointer to next queue entry
Queue type (word)
Reserved (word)
Address of task

dtResrvd
dtQElSize

Reserved—should be 0 (long)
Size in bytes of queue element

dtParm

Queue

Optional parameter (long)

Variables
DTQueue

JDTInstall

Deferred task queue header (10 bytes)

Jump vector for DTInstall routine

V-468 Summary of the Deferred Task Manager

Entry

0}

26 THE
470
470
472

DISK

DRIVER

Changes to the Disk Driver
Using the Disk Driver
Summary of the Disk Driver

id
>)

=

1? 2]

~~

0
=<
@

Lear |

V-469

Inside Macintosh

CHANGES

TOTHE

DISK DRIVER

In earlier versions of the Disk Driver, each drive, whether electrically connected or not, is

assigned its own, hard-coded drive number—the internal and external 3.5-inch drives have

drive numbers 1 and 2, while Hard Disk 20 drives have drive numbers 3 and 4.

The new Disk Driver determines which drives are electrically connected and then
dynamically assigns drive numbers, leaving no gaps for missing drives. This translation

from drive to logical drive number means that a drive number might not correspond to the
drive’s physical, or electrical, address. For instance, on a Macintosh SE with one internal
drive and one external drive, without translation the internal drive would be given drive
number 1 and the external drive number 3 (drive number 2 belonging to the missing
internal drive).

With translation, the two connected drives are assigned logical drive

numbers 1 and 2.

Warning: Programs (such as copy-protection programs) that expect a given
physical drive to have a permanently-assigned drive number will need to be modified
in order to run under the new Disk Driver.

USING THE

DISK DRIVER

Two advanced control calls have been added to the Disk Driver and one existing call has
been extended.
csCode

= 21

csParam =

ptr (long)

This call previously worked only with the Hard Disk 20; with drive number translation, it’s
been extended to support all drives. For the drive whose drive number (remember, this
will be a /ogical drive number) is specified in ioDrvNum, this call returns a pointer to a data
structure consisting of an icon, a mask icon, and a Pascal string. This icon typically
describes the disk media. The string is used in the Get Info dialog (after the word
““Where:’’) to specify the physical drive associated with the icon. The Disk Driver leaves
this string null, letting the Finder fill in this information. (Your own driver would need to
supply this string.)

csCode

= 22

csParam

= ptr (long)

For the drive whose drive number is specified in ioDrvNum, this call returns a pointer to an

icon and a mask icon. This icon typically describes the physical drive.
csCode

= 23

csParam

= long

This call returns information about the drive’s physical location, size, and other
characteristics. The low-order byte of csParam specifies the drive type and can contain one
of the following values:

V-470 Using the Disk Driver

The Disk Driver

Value

Meaning

0

No such drive

f
3
4
5
6
7

400K drive
800K drive
Reserved
Reserved
Reserved
Hard Disk 20

1

Unspecified drive

Bits 8 through 11 of csParam specify the drive attributes, as follows:
Bit

Meaning

8
9
10

Set for external drives, clear for internal drive
Set if SCSI drive, clear if [WM
Set if drive is fixed, clear if drive can be removed

ii

Set for secondary drives, clear for primary drive

The remaining bits of csParam are reserved for future use.

~

a)

4

7ae
=)
—

=e

<
®
=

Using the Disk Driver V-471

Inside Macintosh

SUMMARY
Advanced

OF THE
Control

DISK DRIVER
Calls

csCode

csParam’

Effect

Pal
22
23

ptr (long)
ptr (long)
long

Fetches icon for media
Fetches icon for physical drive
Fetches drive information

V-472 Summary of the Disk Driver

27 THE SOUND
474
474
474
475
476
477
480
480
481
482
482
483
484
485
486
490
490
492
493
495
495
496
497
497
499
499
502

MANAGER

About This Chapter

About the Sound Manager
Overview
Synthesizers
Using the Sound Manager

Sound Manager Routines

User Routines
Sound Manager Data Structures
The SndChannel Record
The Modifier Stub
Sound Manager Commands
Basic Note Commands
Wave Table Synthesizer
Sampled Sound Synthesizer
Command Descriptions
Sound Resources
Format 1 'snd ' Resources
Example
Format 2 'snd ' Resources
Example
‘snth' Resources
MIDI Implementation
MIDI Input Modifier
Playing a Sound Manager Synthesizer
Accepting Raw MIDI Data
MIDI Output Modifier

Summary of the Sound Manager

nN

~

2)
=
=
=

=

<

—

ss)

=

V-473

~
iti=

©
“3

Inside Macintosh

ABOUT

THIS CHAPTER

This chapter describes the Sound Manager, which replaces the 64K and 128K ROM Sound

Driver. While supporting the old Sound Driver data structures, routines, and synthesizers,
the Sound Manager offers a more flexible way of doing the same things, often with new
features and options and with less programming effort.
Reader’s guide:

Most applications (other than music synthesizers) do not use

complex sound effects, and hence have no need of the Sound Manager. For
cautions about using complex sounds in ordinary applications, see the Macintosh

User Interface Guidelines chapter in this volume.

ABOUT THE SOUND

MANAGER

A major innovation of Sound Manager is the introduction of sound resources.

Sound

resources can specify just about anything—from a simple beep to a digital recording with

the quality of a compact disk. Playing a sound resource is as simple as loading the
resource and passing its handle to the SndPlay routine.

In addition, the synthesizers of the Sound Manager, utilizing the power of the new Apple

Sound Chip, use only a fraction of the processing time of the MC68020.
Overview

With the Sound Manager, sounds are created by sending commands to a synthesizer. A
synthesizer is like a device driver. The commands specify the sounds you want, and the
synthesizer takes care of playing them on a particular piece of hardware (a speaker, for
instance).

Commands are passed to a synthesizer through a special kind of queue, known as a
channel. Every channel belongs to a particular synthesizer. To produce complex sounds
like music and speech, several sounds may need to be produced at the same time; for this
reason, the wave table, MIDI, and sampled sound synthesizers can have multiple channels.
Before being passed to the synthesizer, commands may also be processed by one or more
routines, known as modifiers. Modifiers are typically used to synchronize the flow of
commands between multiple channels, or to modify a sound before it reaches the
synthesizer. To accomplish this, the Sound Manager provides modifiers with an additional
set of commands.
The path of a typical Sound Manager command is shown in Figure 1.

V-474 About the Sound Manager

The Sound Manager
ee

Tickle
. ik

—

Modified

Commands

TA
&,

ateeeem

.

s.

0? oe

sof

e

ar
Application
ey

Charmmel

‘
J
thesizex
Zero, One, ox More Modifiers mi

Sound
Manager
&

Figure 1. Sound Manager Command Path

Synthesizers
Which synthesizer you use depends on how complex a sound you want. If you just want
to play a simple melody, you can use the note synthesizer. Each note of the melody is

described by its frequency, or pitch (middle C, for instance), its amplitude (how loud), and
its duration.

With the note synthesizer, however, you can only play one note at a time; it’s not possible
to play a chord. In addition, the range of available timbres is limited.
Note: The note synthesizer is functionally equivalent to the old square-wave
synthesizer.
To produce more complex sounds, you can use the wave table synthesizer. As the
name indicates, the wave table synthesizer lets you supply a wave table that describes the
harmonic content, or timbre, of a note at any point in time. It also lets you play multiple
notes at the same time by opening several channels.
Note: Using the old four-tone synthesizer results in four channels of wave table
synthesis.
The sampled sound synthesizer lets you play digitally recorded (or computed) music
and speech. (The sampled sound synthesizer is functionally equivalent to the old free-form
synthesizer.) Rather than specifying actual notes and corresponding wave tables, you pass
a pointer to a buffer that contains samples of the sound to be played. By changing the rate
at which the samples are played, notes of different pitches and durations are produced.
Note: It’s beyond the scope of this chapter to describe how to create a wave table or
a sampled sound buffer. A good book to get started with is Computer Music,
Synthesis, Composition, and Performance by Charles Dodge and Thomas A. Jerse.
An external MIDI synthesizer can be connected to the Apple serial ports, using an
adaptor. It lets you play music created by external synthesis. The Musical Instrument

About the Sound Manager V-475

q
n
S
=
=
2
<
pa)
=SY)
7

nN

=

Inside Macintosh

Digital Interface (MIDI) is a world-wide standard for controlling external music
synthesizers.

It allows them to be controlled remotely, from a computer or another

synthesizer. In addition, many of the parameters of the typical MIDI synthesizer can be

altered and controlled in real time, giving it some of the features of a played instrument.

USING THE SOUND

MANAGER

The Sound Manager has seven routines. Many applications will need to use only a few of
these routines, since sound resources take care of much of the work. Two types of sound

resources are available:

'snth' and 'snd'.

(A detailed description of the format of the

‘snd ' resource is given later in the chapter.)

A 'snth' resource contains executable code; the code is a function whose entry point is at
the beginning of the resource. Synthesizers and modifiers are typically stored as 'snth'
resources. A synthesizer is specified to the Sound Manager by its number, which must be
the same as the resource ID of the 'snth' resource that contains it.
Note: Numbers for 'snth' resources in the range 0 through 255 are reserved for
Apple; others may be used freely. The ‘snd ' resources 1 through 4 are defined to be
the standard system beep and three variants of it. Numbers for 'snd ' resources in
the range of 0 through 8191 are reserved for Apple.
The ‘snd ' resource is both powerful and flexible.
following:

It can contain one or all of the

w a list of modifiers and synthesizers (‘snth' resources) to load
= some or all of the commands needed to produce a sound
u data tables (consisting of either wave tables or sampled sound buffers) to be used with
certain commands

By having only commands, a 'snd ' resource can describe a simple melody that can be

played on almost any channel. In this case, the channel must first be set up with a
synthesizer using the routine SndNewChannel. (It’s never necessary to open a channel for
the note synthesizer.) To dispose of the channel when you’re done with it, call
SndDisposeChannel.

Another possibility is to have the 'snd' resource contain a single digitized sound, such as
recorded music or speech. In this case, the resource also contains a few commands that
start the sound (which is contained in a data table) playing at its natural sampling rate.
Another method is to provide the synthesizer and modifiers to be used, as well as the
sounds to play. To “play” such a resource, you need only load it into memory and pass its
handle to the SndPlay routine. SndPlay will open a channel, load the specified 'snth'
resources, and pass the commands to the channel.

V-476 Using the Sound Manager

The Sound Manager
To add a modifier to a channel from your application (instead of from a 'snd ' resource),
you can call SndAddModifier. The modifier can be a 'snth' resource, or simply a routine
in memory to which you pass a pointer.
As mentioned above, commands can be placed in a'snd' resource and played using
SndPlay. An application can also send commands with the routine SndDoCommand.

If

there’s a command you want to pass immediately to the synthesizer (and any modifiers),
bypassing the commands currently in the channel, call SndDoImmediate.

SndControl is intended for passing special commands directly to a modifier or synthesizer;

currently, the only command that can be sent with SndControl is availableCmd (described
below).

SOUND

MANAGER

FUNCTION

SndPlay

BOOLEAN):

ROUTINES

(chan:

SndChannelPtr;

OSErr;

sndHdl:

Handle;

async:

SndPlay plays the 'snd ' resource specified by sndHdl. If the resource specifies a
synthesizer and any modifiers to be used, the appropriate 'snth' resources are loaded and
linked to the channel. The commands in the 'snd ' resource are then passed to the channel.
If chan is NIL and no modifiers are specified in the 'snd ' resource, SndPlay allocates a
channel defaulting to the note synthesizer. This channel is released after the commands in
the resource have been processed (in other words, after the sounds have been played).
If you specify a channel in chan, you can call SndPlay asynchronously by passing TRUE
in async. If chan is NIL, you must pass FALSE in async.
Result codes

noErr

No error

badFormat

Handle to 'snd ' resource was invalid

resProblem

Problem loading resource

badChannel
FUNCTION

SndNewChannel

init:

LONGINT;

_Invalid channel queue length

(VAR

chan:

SndChannelPtr;

userRoutine:

SndNewChannel opens a new channel.

ProcPtr)

:

synth:

OSErr;

INTEGER;

If you pass NIL for the chan parameter, the Sound

Manager opens a channel for you and returns a pointer to it.

Advanced programmers: If you’re particularly concerned with memory management, you
may want to allocate a SndChannel record yourself and pass a pointer to it in chan; for

details on doing this, see “Sound Manager Data Structures” below.

nN
~]

W
o
mS
=)
=

Sound Manager Routines V-477

fo
=}
iS)
ge
@
Law

4

Inside Macintosh

Synth indicates the synthesizer to be used; the following standard values have been defined:
CONST

noteSynth

=

sampledSynth
MIDISynthIn
MIDISynthOut

=
=
=

waveTableSynth

=

1;

{note

5;
7;
9;

{sampled sound synthesizer}
{MIDI synthesizer in}
{MIDI synthesizer out}

3;

{wave

synthesizer}

table

synthesizer}

If you pass 0 for synth, no synthesizer is linked to the channel; you’d do this only if you

intended to process commands using modifiers alone.

The init parameter is sent to the synthesizer as the second parameter of the initCmd

command; its possible values are given in the description of initCmd below. The init

parameter lets you request a channel with certain characteristics; this is only a request. To

determine whether the requested characteristics were available, you can send the
availableCmd command (described below) using the SndControl function.

If you want to supply a “‘call-back” routine, pass a pointer to it in userRoutine; if you pass

NIL, callBackCmd commands are ignored (see “User Routines” below for a discussion of
the call back routine).

Resultcodes

— noErr
resProblem

badChannel

FUNCTION

No error
Problem loading resource

_ Invalid channel queue length

SndAddModifier
(chan:
SndChannelPtr;
id:
INTEGER;
init:
LONGINT)
: OSErr;

modifier:

ProcPtr;

SndAddModifier lets you add a modifier to an open channel. Chan contains a pointer to the

channel. SndAddModifier always adds the modifier in front of the synthesizer, and in
front of any modifiers previously installed.

If you want to load a 'snth' resource and add it as a modifier, pass NIL in the modifier
parameter and pass the resource ID in id. The Sound Manager will load the resource, lock
it, and link it to the channel.
Note:

The Sound Manager saves the state of the pointer (with HGetState) and

restores it when SndDisposeChannel is called (using HSetState).

If you want to add your own procedure as a modifier (instead of using an 'snth' resource),
simply pass a pointer to it in the modifier parameter. The format of a modifier procedure is
given in “User Routines” below.
Warning:
Result codes

Having too many modifiers per channel may degrade performance.
= noErr
resProblem
badChannel

V-478 Sound Manager Routines

No error
Problem loading resource
_Invalid channel queue length

The Sound Manager
FUNCTION

SndDoCommand
(chan:
noWait:
BOOLEAN)
:

SndChannelPtr;
OSErr;

cmd:

SndCommand;

SndDoCommand inserts the given command at the end of the channel. If you specify
FALSE for the noWait parameter and the queue is full, SndDoCommand waits for room in
the queue. If you pass TRUE and the queue is full, SndDoCommand will not insert the
command, and the result code queueFull will be returned.
Result codes

FUNCTION

—noErr
queueFull
badChannel

SndDoImmediate

OSErr;

No error
No room in the queue
_Invalid channel queue length
(chan:

SndChannelPtr;

cmd:

SndCommand)

SndDoImmediate bypasses the queue and passes the given command directly to the
modifiers and synthesizer.
Note: SndDoImmediate passes the command on even if the channel is waiting in
response to a waitCmd or syncCmd command (described below).
Result codes

FUNCTION

= noErr
badChannel

SndControl

No error
_ Invalid channel queue length

(id:

INTEGER;

VAR

cmd:

SndCommand)

:

OSErr;

SndControl sends the given command directly to the modifier or synthesizer whose
resource ID is inid. The result, if any, is returned in cmd. (Currently, only the
availableCmd command is sent with SndControl; it’s described below.)
Resultcodes

FUNCTION

—_noErr
badChannel

SndDisposeChannel
;

OSErr;

No error
_Invalid channel queue length
(chan:

SndChannelPtr;

quitNow:

BOOLEAN)

SndDisposeChannel closes a channel, releasing all data structures associated with it, as

well as any 'snth' resources held by it. (Remember that if you allocated the SndChannel
record yourself, the Sound Manager will simply restore the pointer to its original state with
a call to HSetState.)

If you specify FALSE for quitNow, SndDispose channel simply places a quietCmd in the
queue; commands already in the queue are processed. If you specify TRUE for quitNow,
a flushCmd is passed, flushing all commands from the queue, and then a quietCmd is
placed in the queue.
Result codes

= noErr
badChannel

No error
Invalid channel queue length

Sound Manager Routines V-479

Q
Dy
S=
=
2.
<
&
=
>
qe@
nN

bow

|

Inside Macintosh

User

Routines

Warning: These user routines may be called at interrupt level and must preserve all
registers other than AO, Al, and DO-D2. They must not make any calls to the
Memory Manager, directly or indirectly, and can’t depend on handles to unlocked

blocks being valid. If they use application globals, they must also ensure that
register A5 contains the address of the boundary between the application globals and
the application parameters; for details, see the SetUpA5 and RestoreA5 routines.

The SndNewChannel function lets you provide a “‘call-back” routine. A special command,
callBackCmd, works like a flag; whenever this command is received by the Sound
Manager, your call-back routine is called. Your call-back routine should be of the form
PROCEDURE

MyCallBack

(chan:

SndChannelPtr;

cmd:

SndCommand) ;

The chan parameter contains a pointer to the channel; this lets you use the same call-back

procedure with multiple channels. The callBackCmd command (described below) itself is
passed in the cmd parameter; allowing you to pass information to your call-back routine.

The SndAddModifier function lets you add your own function as a modifier (without
having to create an actual 'snth' resource).
FUNCTION

MyModifier

(chan:

ModifierStubPtr)

Your modifier function should be of the form

SndChannelPtr;
:

VAR

cmd:

SndCommand;

mod:

BOOLEAN;

Each time a command reaches your modifier, your function is called. Chan contains a
pointer to the channel; this lets you use the modifier with multiple channels. Mod contains
a pointer to the modifier stub; you can use the modifier stub to store global variables used
by the modifier.
The cmd parameter contains the command. To pass the command along, simply return
FALSE (without altering the command). If you want to replace the command with another
one, place the new command in cmd and return FALSE. To prevent a command from
going on, replace it with the nullCmd command and return FALSE.
If you want to pass along an additional command, return TRUE. The Sound Manager will
call your function again, this time passing the requestNextCmd command. You can then
replace this command with a different command. You can return TRUE as many times as
you like. The requestNextCmd command indicates how many times in a row it has been
sent to your function.

SOUND

MANAGER

DATASTRUCTURES

This section describes two data structures: the channel and the modifier stub.

V-480 Sound Manager Data Structures

The Sound Manager
Reader’s guide:

The

Application programmers rarely need to access these structures.

SndChannel

Record

When you pass NIL for the chan parameter in the SndNewChannel function, the Sound

Manager allocates a SndChannel record for you. This record is a locked, nonrelocatable
block that’s released when SndDisposeChannel is called.
If you’re particularly concerned with memory allocation, you may want to allocate the

SndChannel record yourself and pass a pointer to it in the SndNewChannel call. The
structure of the SndChannel record is as follows:
TYPE

SndChannel

=

RECORD

nextChan:
firstMod:

Ptr;
Ptr;

{pointer
{pointer

callBack:

ProcPtr;

to
to

{ modifier}
{pointer to

next channel}
first
}
channel's

LONGINT;

{ call back procedure}
{free for use}

SndCommand;
INTEGER;

{used
{used

internally}
internally}

qHead:
qTail:

INTEGER;
INTEGER;

{used
{used

internally}
internally}

queue:

ARRAY

userinfo:

wait:

cmdInProg:
flags:

qLength:

Time;

INTEGER;

{used

{queue

}

internally}

length}

[0..stdQLength-1]

OF

SndCommand

END;

CallBack contains a pointer to your call back routine (specified in the userRoutine
parameter of SndNewChannel). UserInfo is free for your use.
The wait field, used internally by the Sound Manager, is of type Time; this data type is
declared as follows:
TYPE

Time

=

LONGINT;

QLength specifies the number of commands that the channel can hold; it must always be
ORD(stdQLength).

The remaining fields of the SndChannel record are used by the Sound Manager and should
not be manipulated.
When you’ve allocated the SndChannel record yourself, the Sound Manager saves the state

information from the pointer you pass, (calling HGetState). It locks the block while it’s in
use (with HLock), and then restores the state when SndDisposeChannel is called (using
HSetState).

)
I
yn
e
=;
3
<
a

Sound Manager Data Structures V-481

o
=|
f>
ge
o

Inside Macintosh

The

Modifier

Stub

Each modifier linked to a channel must have a modifier stub that describes it; the structure
of a modifier stub is as follows:
TYPE

ModifierStub

=

RECORD

nextStub:

Ptr;

{pointer

userInfo:
count:
every:
flags:
hState:

LONGINT;
Time;
Time;
SignedByte;
SignedByte

{free
{used
{used
{used
{used

code:

ProcPtr;

{pointer

to
to

next

modifier}

modifier

for modifier
internally}
internally}
internally}
internally}

to

code}

use}

END;

NextStub points to the modifier stub of the next modifier in the list; this field is maintained
by the Sound Manager and should not be modified.

modifier code itself.

Code must contain a pointer to the

UserInfo is free for your modifier to use. If the modifier is used with more than one
channel, this field could be used to maintain state information about each channel. It can be

a longint or a pointer.

A modifier could, for instance, transpose music by altering the pitch of every note that gets
passed to it. It could also create a “trill” effect by periodically altering the pitch of a note; to
do this a modifier might generate a frequencyCmd in response to a tickleCmd (these
commands are described below).

SOUND MANAGER

COMMANDS

The Sound Manager commands are as follows:
CONST

nullCmd

=

0;

initCmd
freeCmd

=
=

1;
2;

flushCmd
waitCmd
pauseCmd
resumeCmd
callBackCmd
syncCmd
empt yCmd
tickleCmd
requestNextCmd
howOftenCmd
wakeUpCmd
availablecCmd

=
=
=
=
=
=
=
=
=
=
=
=

4;
10;
11;
12;
13;
14;
15;
20;
21;
22;
23;
24;

=

41;

quietCmd

noteCmd

restCmd

=

=

V-482 Sound Manager Commands

3;

40;

The Sound Manager
freqCmd

=

phaseCmd

=

ampCmd
timbreCmd
waveTableCmd

42;

=
=
=

soundCmd
bufferCmd

rateCmd

43;
44;
60;

61;

=
=

80;
81;

=

100;

=

midiDataCmd

82;

Commands are always eight bytes in length, and are specified using the following record:
TYPE

SndCommand

=

PACKED
cmd:

RECORD
INTEGER;

paraml:

param2:

INTEGER;

LONGINT;

{command

number}

{second

parameter}

{first

parameter}

END;

If the high-order of the cmd field is set, param2 contains a pointer to some other memory
block.
Most applications only need to know about a few of the above commands. The complete
set of commands, along with the parameters they take, is described below under

“Command Descriptions”. The next three sections introduce the commands that actually
produce sound.
Basic

Note

Commands

The basic note commands are noteCmd, restCmd, freqCmd, ampCmd, and timbreCmd;

these commands are understood by all four synthesizers.
used by the note synthesizer.

They are also the only commands

With noteCmd, you specify a note by its pitch, amplitude, and duration. Pitch can be
specified in two ways. One way is to supply a value between 0 and 127; this value is then
converted into a frequency as follows. The value 60 is considered to be middle C on a
piano keyboard. Adding 1 raises the pitch by one semitone; in other words, a value of 61
represents a C sharp above middle C. Subtracting 1 lowers the pitch by one semitone; in
other words, a value of 59 represents a B below middle C. Adding or subtracting 12 raises
or lowers the pitch by one octave respectively.
Note: This method limits one to an equal-tempered scale (just like a piano keyboard)
but is perfectly acceptable for many needs.
A second way of specifying pitch is with the actual frequency of the note; this method does
not limit one to the equal-tempered scale. The frequency of middle C, as an example, is
261.6256 Hz, and concert A (A440) is 440 Hz.

When specifying pitch as a value between 0..127, the value is stored in the low-order byte
of param2; the other two bytes must be 0. When supplying an actual frequency, all three
bytes are used. The two high-order bytes represent the integer portion of the frequency and

Sound Manager Commands V-483

tet
~I

2)
=
=
=
jae
rt)
=
a

ge
©
seaw |

Inside Macintosh

the low-order byte contains the fraction (in other words, $01 = 1/256 and $FF = 255/256).

For example, middle C would be represented as $0105A0 and A440 would be $01B800.
Duration is specified in half-milliseconds.

To translate this into real terms, suppose you

want to play a piece at 120 beats per minute and each quarter note is one beat. This means
a quarter note occurs every 500 milliseconds, so the duration would be 1000 (half-

milliseconds). If you wanted 60 beats per minute, the duration would be doubled.
Amplitude is specified as a value between 0 and 255 with 255 meaning maximum
amplitude and 0 meaning silence.

NoteCmd, unlike all the other commands, needs two different values specified in param2:
the amplitude in the high-order byte and the pitch or frequency in the three low-order bytes.
To do this, you can assign the two values to temporary LONGINT fields, with the value
for the high-order byte preshifted, and then assign the sum of the fields to param2. An
example of doing this, assuming a desired amplitude of 255 (maximum amplitude) and a
pitch of 60 (middle C on a piano), is as follows:
myAmplitude,
myPitch:
LONGINT;
myAmplitude
:= $FF000000;
myPitch
:= $000105A0;
mySndCmd.param2
:= myAmplitude + myPitch;

RestCmd produces silence for a given duration.
FreqCmd, ampCmd, and timbreCmd change the pitch, amplitude, and timbre of the sound
that’s currently playing.

Wave

Table

Synthesizer

In addition to the basic sound commands, the wave table synthesizer uses waveTableCmd
and phaseCmd. WaveTableCmd specifies the wave table to be used, while phaseCmd lets
you tell where in the table to begin producing the sound.
The wave table describes the timbre, or harmonic content, of a sound at any point in time.
The table consists of a sequence of bytes spanning a single oscillation of sound. A length
of 512 bytes is recommended for optimum performance, but the synthesizer will convert
other sizes into an equivalent table of the correct frequency that’s 512 bytes long. The
samples are to be represented in offset binary format; that is, $80 is considered zero, $00
the largest negative value, and $FF the largest positive value. (This is just like the old
Sound Driver.) For example, a wave table consisting of a sine timbre would look like that
in Figure 2.

V-454 Sound Manager

Commands

The Sound Manager

0

911
Figure 2. Wave Form for a Sine Timbre

In addition to the standard method of playing out a wave table continuously, the wave table
synthesizer can be used in a “one-shot” mode. When this mode is enabled, the waveform
is output once per trigger command. Voice and other natural-sounding pulsed sounds can
be achieved by placing one period of the sound in the wave table and triggering it to play in
a nonregular fashion. One-shot mode may also be used to play a short sound (practically
speaking, a tenth of a second or less), such as a game bleep, with very little overhead.
Note: Using the old four-tone synthesizer results in four channels of wave table
synthesis. The techniques for suppressing clicks with the old four-tone synthesizer
are still supported when the old interface is used; these techniques are discouraged,
however, as they are costly in time and space. The wave table synthesizer provides
equivalent functionality with more power.

Sampled

Sound

Synthesizer

The sampled sound synthesizer plays out digitally recorded (or computed) sounds. The
sounds are passed to the synthesizer in buffers containing samples of the sound (also in
offset binary format).
The buffers may be played out at the original sampling rate (producing the same pitch), or
they can be played at higher or lower rates (producing higher or lower pitches). The rate
may be changed over time. The amplitude, as well as whether the sound is left, middle, or
right, may also be specified and changed over time. The format for these buffers is shown
in Figure 5,
Playing two or more buffers end-to-end is guaranteed to sound just as though the buffers
had been concatenated into a longer buffer as long as the buffers are longer than 256 bytes
each and are presented to the Sound Manager quickly enough. For this reason, the
techniques and restrictions for playing continuous sound with the old free-form synthesizer
no longer apply and are discouraged.
Alternatively, a single buffer of sound may be passed to the synthesizer. NoteCmd
commands can then be sent to play the buffer out at different pitches and durations. The

Sound Manager Commands V-485

i)

~]

WN
=)
=
=
2.
ne
=
oe

ge

©
=“

Inside Macintosh

pitch is changed by altering the rate used to play out the buffer. The duration is changed by
looping (playing over and over) some segment of the buffer. This segment is specified by
loop points given when the buffer is passed to the synthesizer in the 'snd ' resource. For
notes of a given duration, the loop is repeated such that the end portion will fit within the
duration. For notes of unknown duration, the loop is simply repeated until a new note or
rest is played; in the case of a rest, the end portion plays then.

Command
cmd

Descriptions

= nullCmd

paraml

= NIL

param2

= NIL

The Sound Manager simply absorbs the nullCmd. To prevent a command from going on,
replace it with nullCmd.
cmd

= initCmd

paraml

= NIL

param2 =

init

Sent by the Sound Manager to a modifier or synthesizer when it’s linked to a channel.
the application passed the init parameter when calling SndNewChannel or
SndAddModifier, this information is passed in param2.

If

The note synthesizer does not accept initialization parameters. The other three standard
synthesizers can be sent a request for certain characteristics in the low-order byte of init; the
following masks are provided:
CONST

initChanLeft

initChanRight
initChan0
initChanl
initChan2
initChan3
initSRate22k
initSRate44k
initMono
initStereo

=
=
=
=
=
=
=
=
=

$02;

$03;
$04;
$05;
$06;
$07;
$20;
$30;
$80;
$C0;

{left

stereo

channel}

{right stereo channel}
{channel 0--Wave Table only}
{channel 1--Wave Table only}
{channel 2--Wave Table only}
{channel 3--Wave Table only}
{sampling rate of 22kHz}
{sampling rate of 44kHz}
{monophonic channel}
{stereo channel}

Warning: InitCmd is only a request; to determine whether the requested
characteristics were available, you can send availableCmd (described below) using
the SndControl function.
cmd

= freeCmd

paraml

= NIL

param2

= NIL

Sent by the Sound Manager in response to a SndDisposeChannel call, freeCmd causes the
synthesizer and modifiers to stop processing commands after the current sound has
completed playing.
Note: Neither initCmd nor freeCmd will be called at interrupt level, so you’re free
to call the Memory Manager.

V-486 Sound Manager Commands

The Sound Manager
cmd

= quietCmd

paraml

= NIL

param2

= NIL

Sent by the application, quietCmd causes the synthesizer and modifiers to stop processing
commands immediately, stopping any sound in progress.
cmd

= flushCmd

paraml

= NIL

param2

= NIL

Sent by the application, flushCmd causes all commands to be flushed immediately from the
channel.
cmd

= waitCmd

paraml

= duration

param2

= NIL

Sent by either the application or a modifier, waitCmd suspends the processing of
commands for the specified duration.
cmd

= pauseCmd

paraml

= NIL

param2

= NIL

Sent by a modifier, pauseCmd suspends the processing of commands indefinitely; typically

the channel will “wake up” only in response to a tickleCmd or resumeCmd. PauseCmd is
intended for synthesizers that want to halt processing until the current command is
processed when the duration is not known in advance.
cmd

= resumeCmd

paraml

= NIL

param2

= NIL

Sent by a modifier, resumeCmd causes command processing to resume on a channel that
was paused due to a pauseCmd.
cmd

= callBackCmd

paraml

= user-defined

param2

= user-defined

Sent by an application, callBackCmd causes the call-back routine specified in the
SndNewChannel function to be executed. Param] and param2 can be used to pass
information to the call-back routine.
The callBackCmd is like a marker; when the call back routine gets called, it knows a

particular point in the command stream has been reached. A game might want, for
instance, to display something on the screen immediately after a certain sound has been
made. A callBackCmd could be placed after the particular noteCmd; the call-back routine is
alerted after the note has sounded, and is given control to perform the screen activity.

cmd

= syncCmd

paraml

= count

param2

= identifier

Sent by an application, syncCmd suspends processing of commands in this channel until
syncCmd commands with the same identifier have been received for count other channels.
Figure 3 illustrates the use of syncCmd.

nN
|
ve
ra

=
o.

Sound Manager Commands V-487

S)
=
i)
ge
7)
Lay

4

Inside Macintosh

Xwaits
K Av Y CONt nue

Charmel X

Charmel Y

Charmel Z

Cmd
Sync A,2

Cmd
Cmd

Cmd
mM
Cmd

Sync A,2

Cmd

ecvenecereooneousnss +

Cmd

cevrssesseeseeeeeed

Wanna Se: ssssiissiasisesived

ye |
KY AZ continue vvvveccenceeeed

Cmd

Cmd

2

of

Sync B,3
fessseesnf
—~
Cmd

Cmd

Cmd

re Sync B,3

Cmd

Cmd
evan -Sync B,3
Cmd

Cmd

Figure 3. Use of the SyncCmd

cmd = emptyCmd

paraml = NIL

EmptyCmd is sent only by the Sound Manager.

param2

= NIL

The synthesizers expect resumeCmd to be

followed by another command; if there are no commands to follow, the Sound Manager

sends an emptyCmd.

cmd

= tickleCmd

paraml = NIL

param2 = NIL

Sent by the Sound Manager to modifiers and synthesizers that request periodic action; the
period at which the tickleCmd is sent is specified by the howOftenCmd.
cmd

= requestNextCmd

paraml

= count

param2

= NIL

Sent by the Sound Manager in response to a modifier returning a TRUE, result (indicating
that it wants to send another command). Count is the number of times in a row that this
modifier has asked to send another command.
cmd

= howOftenCmd

paraml

= period

param2

= pointer

Sent by a modifier, howOftenCmd instructs the Sound Manager to periodically send a
tickleCmd to a modifier. Param1 contains the period, specified in half milliseconds.
Param2 contains a pointer to the modifier stub.
cmd

= wakeUpCmd

paraml

= period

param2

= pointer

Sent by a modifier, wake UpCmd requests a single tickleCmd after the number of
milliseconds specified in param1 have elapsed. Param2 contains a pointer to the modifier
stub.
Note: HowOftenCmd and wakeUpCmd are mutually exclusive; sending one will
cancel the other.

V-488 Sound Manager Commands

The Sound Manager
cmd

= availableCmd

paraml

= status

param2 =

init

Sent by an application, availableCmd can be used to determine whether the initialization
parameters requested by initCmd were available. Init specifies the same characteristics as
in the initCmd. Status returns a boolean result of TRUE if the characteristics were available
and FALSE if they weren’t.
Note: AvailableCmd can be sent only with the SndControl routine (it can’t be sent
with SndDoCommand).
cmd

= noteCmd

paraml

= duration

param2

= amplitude

Play a note with the specified frequency and amplitude for the given duration.

+ frequency
Ona

monophonic channel, this suspends the processing of commands until the note is finished.
On a polyphonic channels, subsequent commands will continue to processed.
cmd

= restCmd

paraml

= duration

param2

= NIL

Causes the channel to rest for the given duration. (This may not result in silence since the
decay of the previous note may continue to sound.) RestCmd differs from waitCmd in that
it allows a playing sound to finish (go into release and decay stages) whereas waitCmd
causes the Sound Manager to physically cut off the sound.
cmd

= frequencyCmd

paraml

= NIL

param2

= frequency

Changes the frequency of the currently playing sound. If no sound is playing, a sound of
indefinite duration is started at the given frequency and the last-requested amplitude.
Specifying a frequency of 0 results in silence; it’s equivalent to sending a waitCmd. The
frequency is specified in the low-order three bytes of the long argument (the high-order
byte must be zero).
cmd

= ampCmd

paraml

= amplitude

Changes the amplitude of the currently playing sound.

param2

= NIL

If no sound is playing, the

amplitude of the next sound, unless otherwise specified, will be set. The amplitude is

specified in param] (unlike noteCmd, where it's given in the high-order byte of param2)

cmd

= timbreCmd

paraml

= timbre

param2

= NIL

TimbreCmd is supported only by the note synthesizer. It lets you request a change in the
waveform, where () represents a sine wave and 255 represents a square wave. This is only
a request.
cmd

= waveTableCmd

_ paraml

= length

param2

= ptr

Sent by an application, waveTableCmd specifies the wave table to be used with succeeding
note commands. Param2 contains a pointer to the table and param1 specifies the length of
the table.
nN
~I
ZN
S
=
=
i=

Sound Manager Commands V-489

Se
=
>
ge
@
be

4

Inside Macintosh
cmd

= phaseCmd

PhaseCmd lets you specify which byte in the wave table to begin playing on.

emd

= soundCmd

paraml = NIL

param2

= pointer

Sent by an application, soundCmd specifies the sound to be played by succeeding note
commands. Param2 contains a pointer to the bytes describing the sound.
cmd

= bufferCmd

paraml

= NIL

param2

= pointer

Sent by an application, bufferCmd plays the buffer pointed to by param2 at the last set
frequency and amplitude. The buffer format is shown in Figure 5. The channel pauses
until the sound has played.
Note: The channel will actually be started again just before the sound has finished,
so that multiple buffers will be continuous.
cmd

= rateCmd

paraml

= NIL

param2 =

rate

Sets the rate at which succeeding buffer commands will be played. RateCmd is similar to
frequencyCmd except that it lets you specify the rate as a multiplier of the original sampling
rate; in other words, a rate of 2 is an octave higher, 0.667 a fifth lower. The rate is
specified as a fixed-point number (of type Fixed).

SOUND

RESOURCES

This section describes two standard formats of the 'snd ' resources type: format 1 and
format 2.
Note: Numbers for 'snd ' resources in the range of 0 through 8191 are reserved for
Apple.
Format

1

'snd'

Resources

Figure 4 shows the structure of a format 1 'snd' resource.

V-490 Sound Resources

format of this 'snd ' resource (word)
number of modifiers/synthesizers (word)

resource ID of first synthesizer/modifier (word)
initialization parameter (long word)

resource ID of last synthsizer/modifier (word)
initialization parameter (long word)
number of sound commands to follow (word)
first sound command (8 bytes)

last sound command

(8 bytes)

Figure 4. A Format 1 ‘snd ' Resource
The first word is the format number; in this case, it’s $0001.

The next field tells how many

synthesizers and modifiers are used by this 'snd' resource. For each synthesizer or
modifier, there follows the resource ID (of the corresponding 'snth' resource) and an
optional initialization parameter.

The synthesizers and modifiers are listed in the reverse of the order in which they are to sit
in the channel: the synthesizer first, followed by modifiers, ending with the first modifier.
(The Sound Manager runs down this list calling SndAddModifier, which places the new

modifier in front of those previously installed.)

The number of commands in the resource comes next, immediately followed by the

commands themselves. As described above in “Sound Manager Commands”, commands
consist of three fields totaling eight bytes.
The commands are followed by data tables (if any).

A command with additional data is

marked by setting the high-order bit of the command number field, with the third (long
word) argument containing the offset of the data from the start of the 'snd ' resource.

Note: The offset is calculated as 6 bytes plus the number of synthesizers/modifiers
times 6 plus the number of commands times 8. When passed to a channel by the
SndPlay routine, this offset will be converted into an actual address.

nN
|
W
i)
=
=
=.

<
al

Sound Resources V-49]

poe)
|
~~
ge
@

Inside Macintosh

Example
By providing a synthesizer and list of modifiers, and a few commands to initialize them, a
‘snd ' resource becomes an instrument. After calling SndPlay to install the instrument, the
calling program can issue a series of noteCmd commands to play a tune using this timbre.
Since there are no noteCmd commands in the resource itself, the installation does not make
any noise.
For the sampled sound synthesizer, an instrument has only a soundCmd and the
corresponding data table. The data table usually contains a single digitized note, to be
played over and over at different pitches and durations. Note: It can only play one note at
a time (one voice) per channel. In this example, a 'snd ' resource specifies the sampled
sound synthesizer and a hypothetical modifier. It plays one instrument for two notes and
two rests, and a second instrument for one note and rest. The soundCmd sets the
instrument for subsequent notes and points to the actual samples stored in the data table
portion of the resource. The calling program brings the resource into memory and calls the
Sound Manager, as follows:
ResHndl

SndPlay

:=

GetNamedResource

(NIL, ResHndl,

TRUE)

;

('snd

', 'Harpsichord')

;

Since the call does not specify a channel, the Sound Manager allocates one and destroys it
afterwards. The third argument tells the Sound Manager to play the sound
asynchronously, returning control immediately to the calling program. Because it specifies
both a synthesizer and notes, the 'snd ' resource in this example is a self-contained sound
on could be used for a sysbeep or bootbeep. The contents of this 'snd ' resource are as
ollows:
Value

Size

Meaning

l
P2
5
0
12
0
8

word
word
word
long
word
long
word

A format 1 'snd ' resource
Install two synthesizers/modifiers in the channel
Resource ID of the sampled sound synthesizer
NIL initialization parameter
Resource ID of hypothetical modifier
NIL initialization parameter
Eight sound commands (eight bytes each) to follow

(sound commands)

$8050, 0, 82
40, 400, 60

41, 400, 0

40, 400, 64

41, 400, 0

$8050,

82+3022

0,

SoundCmd (offset is 6 bytes plus 2 synthesizers/modifiers times 6

bytes plus 8 bytes times 8 commands)

NoteCmd, play for 400 half-milliseconds, a middle C note

RestCmad, rest for 0.2 seconds (while the note decays)

NoteCmd, play for 400 half-milliseconds, an E note

RestCmd, rest for 0.2 seconds (while the note decays)

SoundCmid, with offset to the second data table (the first sound is

3022 bytes long)

V-492 Sound Resources

The Sound Manager
41, 400, 0

RestCmd, rest for 0.2 seconds (while the note decays)

(first sampled sound data table)
0
3000
$56EE8BA4
2000
2200

long
long
long
long
long

60

word

3000 bytes

Pointer to the data (though it follows immediately)
Number of samples in the sound (1 byte per sample)
Sampling rate (22K samples per second)
Start of loop, for when duration is longer than samples
End of the loop (jump back to start). The remaining 800
samples are the decay portion.
BaseNote (the pitch of the sound in half steps when the
samples are played at the sampling rate)

Sound samples (with $80 the resting value, $FF the maximum

positive amplitude, and $00 the maximum negative amplitude)

(second sampled sound data table)

0
1500
$56EE8BA4
500
600

long
long
long
long
long

55

word

1500 bytes
Format

2 'snd

Pointer to the data (though it follows immediately)
Number of samples in the sound (1 byte per sample)
Sampling rate (22K samples per second)
Start of loop when duration is longer than samples
End of the loop (jump back to start). The remaining 900
samples are the decay portion.
BaseNote (the pitch of the sound in half steps when the
samples are played at the sampling rate)
Sound samples for 1500 more bytes
' Resources

A format 2 'snd ' represents either an instrument or a digitally recorded sound. After
installing it on a sound channel that uses the sampled synthesizer, an application can send
note and rest commands to the channel to play a tune. If the resource contains speech or a
sound effect, the application can play it once at its natural pitch for its natural length.
Developers of music applications are strongly encouraged to adopt the format 2 'snd '
resource as a standard. As “non-music” developers incorporate ‘snd ' resources into their
applications, they will come to depend on tools for creating and editing those sounds.
Adding to your music application the ability to write sounds out as format 2 'snd'
resources is thus highly desirable.
Format 2 'snd ' resources work only with the sampled sound synthesizer. They assume
that the sampled sound synthesizer and any relevant modifiers are already installed on a
preexisting channel (unlike format 1 resources which can let the Sound Manager take care
of allocating and releasing a channel). After setting up the channel and synthesizer, the
calling program will most likely set up an instrument, play some notes, and then install a
different instrument and play more notes. Format 2 resources hold either the instrument, a
list of notes without an instrument, or both. Format 2 resources do not disturb the setup of
the channel and synthesizer; this allows additional format 2 resources to be played. (This
saves time, prevents clicks, and keeps memory from getting fragmented.) The structure of
a format 2 resource is given in Figure 5.

Sound Resources V-493

nN
~
2)
Ss
=
=
Qa.
)
~
S
tj)
©
Lee

|

Inside Macintosh

format of this 'snd ' resource (word)
reference count (word)
number

of sound commands

to follow (word)

first sound command (8 bytes)

pointer to data (long word)
number of samples

in the sound (long word)

sampling rate (long word)
:
start of alternate sampling

loop (long word)

end of alternate sampling

loop (long word)

buffer for

BufferCmd

base note (word)

? sound samples (bytes)

?

Figure 5. A Format 2 'snd ' Resource

The 'snd ' resource for each instrument must be locked and unpurgeable so the synthesizer
can find the samples. It must be released, however, when the sound is over so that
memory does not become fragmented. Since the notes are played asynchronously of the
calling program, the caller does not know when the sound has finished. In addition, the
same resource may be queued for playing many times. For these reasons, format 2
resources have a special field in which the calling program can keep a reference count for

each 'snd ' resource that contains an instrument; when the count falls to zero, the resource

can be unlocked and made purgeable.

When a format 2 resource is used solely as an instrument description (itself not specifying
any notes), it expects the calling program to send a series of noteCmds to the channel just
after it’s installed.

V-494 Sound Resources

The Sound Manager

Example
Value

Size

2
0

word
word

1

word

Meaning
A

format 2 'snd ' resource.
Space for the reference count. Must start out 0 for the

resource to be freed. Put 256+1 here to force the calling
program to keep it in memory permanently.
One sound command to follow.

(sound command)

$8050,

0,

14

SoundCmd

(offset is 6 bytes plus 8 bytes times 1 command)

(NoteCmd commands could be placed here but would be played every time the timbre is
installed. NoteCmd commands without a soundCmd make up a tune that could be played
after another instrument has been installed.)
(sampled sound data table)
@)

long

60

word

3000
$56EE8BA4
2000
2200

long
long
long
long

3000 bytes

‘snth'

Pointer to the data (it follows immediately, not indirect)

Number of samples in the sound (1 byte per sample)
The sample rate (22K samples per second)
Start of loop when duration is longer than samples
End of the loop (jump back to start). The remaining 800
samples are the decay portion.
BaseNote (the pitch of the sound in half steps when the
samples are played at the sampling rate)

Sound samples (with $80 the resting value, $FF the maximum
positive amplitude, and $00 the maximum negative amplitude)

Resources

Sound Manager synthesizers and modifiers are both stored as resources of type 'snth’.
Low-number 'snth' resource IDs are reserved for use by Apple. High-number 'snth'
resource IDs are available for use by developers.
A modifier has the same format as a synthesizer. The main difference is a functional one.
While a synthesizer controls hardware to produce some sort of effect, a modifier resides in
the Sound Manager channel and modifies commands.
There are several cases where being able to modify a command is desirable. In the case of
MIDI a modifier is used to convert MIDI messages into Sound Manager commands. A
modifier may be written to play a chord based on a note sent down a channel.
The synthesizers currently included on the Macintosh II System Disk have the following
resource IDs:

tN
~
S
=
=
=
<
—

Sound Resources V-495

x
=

i)
ve

©

Inside Macintosh

1 = Note Synthesizer
3 = WaveTable Synthesizer
5 = Sampling Synthesizer
7 = MIDI Input Synthesizer
9 = MIDI Output Synthesizer
All 'snth' resources conform to the following Pascal call:
FUNCTION

MySynth

(chan

:

ModifierStubPtr)

SndChannelPtr;

:

VAR

comm

:

SndCommand;

mod:

Boolean;

The synthesizer passes information along the channel by altering the value of the VAR
parameter comm.
The boolean result of a synthesizer or modifier tells the Sound Manager if it should send a
RequestNextCmad. If the result is TRUE, then a RequestNextCmd is sent. In general, most
synthesizers and modifiers return FALSE.
There are three commands that every synth or modifier must handle. These are InitCmd,
FreeCmd, and NullCmd.

InitCmd is sent to a synthesizer or modifier at the time it is linked to the channel. It is never
sent at interrupt time so it is safe for the synthesizer or modifier to allocate memory.
During an interrupt your synthesizer or modifier should initialize any global data, try to take
control of the hardware and allocate any necessary memory. The modifier stub contains a
4-byte user field. If more than four bytes of storage are needed, a pointer to memory can be
stored here. It is important to note that any storage being allocated by the synthesizer or
modifier should be locked, since the memory manager cannot be called during an interrupt.
When InitCmd is passed to the synthesizer, as described above under “Command

Descriptions”, Param2 may contain a synthesizer-specific init parameter.

FreeCmd tells the synthesizer or modifier to free any data structures it may have allocated
and release control of the hardware after making sure that the hardware is quiet. FreeCmd
will never be called at interrupt time so it is safe to call the memory manager to dispose of
allocated memory. Neither the InitCmd or the FreeCmd are passed on.
The correct response to a NullCmd is simply to pass it on. You can use the NullCmd to
insure that a command is passed on by subsequent synthesizers or modifiers. The general
rule for all synthesizers and modifiers is to pass on all commands that they cannot process.

MIDI IMPLEMENTATION
This section describes in detail how the MIDI Input and Output Modifiers currently work
under the Sound Manager. It is likely that the handling of some MIDI messages will change
in future versions of the Macintosh system.

V-496 MIDI Implementation

The Sound Manager
MIDI input is accomplished through a 'snth' resource with ID=7 that converts Sound
Manager commands to MIDI commands. MIDI output is accomplished through a 'snth'
resource with ID = 9 that converts MIDI commands to Sound Manager commands.
Note: For details of the MIDI interface, refer to the MIDI 1.0 Specification,
available directly from the International MIDI Association.

MIDI

Input

Modifier

The MIDI Input Modifier is designed to allow an application using the Sound Manager to
receive information via MIDI.
When it receives an InitCmd, the Input Modifier allocates storage for internal state

information, sets up a periodic wakeup, and allows the following constants to be passed in

param2:
CONST

MidilInitChannel
MidiInitChanFilter
MidiInitRawMode

=n:
= $10;
= $100;

{MIDI Channel
to init
$0..S$F}
{set to initialize
a MIDI Channel}
{set to send raw MIDI data}

If MidilnitChanFilter is set, only information coming in on the MIDI channel specified in
MidilnitChannel will be passed along. Otherwise all MIDI input is passed along, equivalent
to MIDI omni mode.
MidilnitRawMode is set if the channel should be sent raw MIDI data. Normally the MIDI
Synthesizer interprets Sound Manager commands and sends the equivalent MIDI
commands. By setting MidiInitRawMode, raw MIDI data can be passed back to the
application.
FreeCmd disposes of all data structures allocated by the modifier during InitCmd, and
shuts down transmission of MIDI data.
TickleCmd and RequestNextCmd cause the modifier to receive MIDI input and pass it
down the channel, converting it to Sound Manager commands if MidiInitRawMode was
not set in InitCmd. This can be useful in two ways:
m when using the MIDI Input Modifier to play a Sound Manager synthesizer
= when using the MIDI Input Modifier to accept raw MIDI data
These two possibilities are discussed below.

Playing

a

Sound

Manager

Synthesizer

When playing a Sound Manager synthesizer, the MIDI Input Modifier retrieves a command
from the MIDI input buffer each time the modifier receives a TickleCmd or a
RequestNextCmd, as diagrammed in Figure 6.

nN

—I
<2

=

=
o.
£

MIDI Implementation V-497

=

oS
ge

©
=

Inside Macintosh

(\=
Channel

MIDI Input
Modifier

Synthesizer

Figure 6. Playing a Sound Manager Synthesizer
Each MIDI command is converted to a Sound Manager command according to the rules
listed below.
Channel Voice Messages:
= NoteOn events are converted to FreqCmd. Note that this is done since we cannot
determine the correct duration for a NoteCmd.

= NoteOff events are converted to FreqCmd with Param2 = 0, This will turn off any
notes playing on the channel.

u The following events are not currently processed:
Polyphonic Key Pressure/Aftertouch
Control Change
Program Change
Channel Presssure (Aftertouch)
Pitch Wheel Change
System Common Messages:
u The following messages are not currently processed:
System Exclusive
Song Position Pointer
Song Select
Tune Request
EOX “End of System Exclusive” flag
System Real Time Messages:
« Start and Continue messages are converted to ResumeCmd.
m Stop messages are converted to PauseCmd.
= System Reset will reset the MIDI input queue. It is not passed along through the
channel.
a The following messages are not currently processed:
Timing Clock
Active Sensing

V-498 MIDI Implementation

The Sound Manager

Accepting

Raw

MIDI

Data

An application can use the MIDI Input Modifier to receive raw MIDI data, as diagrammed

in Figure 7. This is useful for applications that want to handle MIDI messages in a special

way or want to take control of the translation from MIDI message to Sound Manager
commands.

Channel

MIDI Input
Modifier

|

My Modifier
|

Synthesizer

MID! Data Buffer
Figure 7. Accepting Raw MIDI Data
If the application has set MidiInitRawMode in InitCmd, then the MIDI Input Modifier will
pass raw MIDI data down the channel in Param2.

MIDI

Output

Modifier

The MIDI Output Modifier is very similar to the MIDI Input Modifier. It provides a way for
an application to make Sound Manager calls and have them be converted to MIDI
messages, as diagrammed in Figure 8. It is also possible to send MIDI messages as raw
data.

nN
~—I

Pp

=

=

a=

<
fo

—

MIDI Implementation V-499

=
i)
ge

ie

Inside Macintosh

————--—>

Channel

——_—__»

MURLARAAARAALAAARA
DRA RAT

MIDI Output
Modifier

Figure 8. MIDI Output Modifier
The Sound Manager commands that can be used with the MIDI Output Modifier are listed
below.

InitCmd

u Allocates storage for internal state information.
u Allows an InitParam to be passed in Param2, using these constants:
CONST

MidiInitChannel
MidiInitChanFilter

n;

$10;

{MIDI
{set

Channel

to

to

initialize

init
a

$0

MIDI

..

$F}

Channel}

MidilnitChannel will contain the number of the MIDI channel to be initialized.

MidilnitChanFilter must be set. Monovoice information will be sent on the MIDI channel
specified in MidiInitChannel. This is equivalent to MIDI transmit mode 4.
The MIDI velocity used is initialized to 64 by InitCmd.
FreeCmd

Disposes of all data structures allocated by the modifier during InitCmd. Shuts down
transmission of MIDI data.
NoteCmd
FreqCmd
A MIDI NoteOff message is sent for the last note played. The note is played using a fixed
velocity. The amplitude supplied in the high byte of Param2 for NoteCmd is ignored. The
low three bytes of Param2 must contain a MIDI semitone value (0 .. 127); frequency values
are not permitted. The duration supplied with NoteCmd is processed correctly.
EmptyCmd
A MIDI NoteOff message is sent for the last note played.

V-500 MIDI Implementation

The Sound Manager
QuietCmd

A MIDI AllNotesOff message is sent.
AmpCmd
The fixed velocity used in the translation of FreqCmd and NoteCmd is changed to the
supplied value. This value will be used for all subsequent MIDI messages requiring a
velocity.

MidiDataCmd

Param2 is treated as raw MIDI data and sent to the MIDI output stream.

nN
~—I

N

Sc
=
=
=

MIDI Implementation V-501

fo
i]
iy)
tj)
@

ay

Inside Macintosh

SUMMARY

OF

THE SOUND

MANAGER

Constants
CONST

{

Command

numbers

for

nullCmd
initCmd
freeCmd

1;

2;

3%
4;

flushCmd
waitCmd

pauseCmd

=

resumeCmd
callBackCmd

syncCmd
empt yCmd
tickleCmd

wakeUpCmd

=

availableCmd
noteCmd
restCmd
freqCmd

waveTableCmd
phaseCmd
soundCmd
bufferCmd
rateCmd
midiDataCmd

Synthesizer

for

1;
33
S;
V7
9;

SndNewChannel

}

{note synthesizer}
{wave table synthesizer}
{sampled sound synthesizer}
{MIDI synthesizer in}
{MIDI

synthesizer

out}

}

MidiInitChannel
MidiInitChanFilter
MidiInitRawMode

StdQLength

42;
43;
44;
60;
61;

numbers

values

length

24;
40;

81;
82;
100;

MIDISynthOut

Queue

23;

80;

noteSynth
waveTableSynth
sampledSynth
MIDISynthIn

{

15;
20's
21§
22%

41;

=

ampCmd
timbreCmd

Param2

10;
11;
12;
13%
14;

=

requestNextCmd
howOftenCmd

{

}

0»

quietCmd

{

SndDoCommand

n;
$10;
$100;

{MIDI Channel
to init
$0
.. SF}
{set to initialize
a MIDI Channel}
{set to send raw MIDI data}

}
12 8

V-502 Summary of the Sound Manager

{standard

queue

length}

The Sound Manager

Data

Types

TYPE

SndCommand

=

PACKED

RECORD

cmd:
paraml:
param2:

INTEGER;
INTEGER;
LONGINT;

{command number}
{first parameter}
{second parameter}

END;
Time

=

LONGINT;

SndChannel

=

RECORD

nextChan:

SndChannelPtr;

{pointer

to

next

firstMod:

ModifierStubPtr;

first

callBack:

ProcPtr;

{pointer to
{ modifier}
{pointer to

userinfo:

LONGINT;

{ call back procedure}
{free
for use}

qLength:

INTEGER;

{queue

wait:
emdInProg:
flags:

Time;
SndCommand;
INTEGER;

qHead:
qTail:

INTEGER;
INTEGER;

queue:

{

channel}

}

channel's

{used
{used
{used

internally}
internally}
internally}

{used
{used

internally}
internally}

ARRAY[0..stdQLength-1]

}

}

length}

OF

SndCommand

END;

ModifierStub

=

RECORD
nextStub:

ModifierStubPtr;

{pointer to
{ modifier}

next

code:

ProcPtr;

modifier

userInfo:

LONGINT;

{pointer
{ code}

count:
every:

Time;
Time;

flags:

SignedByte;

hState:

END;

{free

for

{used
{used

internally}
internally}

{used

internally}

{

SignedByte

to

use}

{used

modifier

}
}

to

}

internally}

Routines
FUNCTION

SndPlay

FUNCTION

SndNewChannel

FUNCTION

SndAddModifier

FUNCTION

SndDoCommand

(chan:
async:

SndChannelPtr;
sndHdl:
BOOLEAN)
OSErr;

Handle;

(VAR chan: SndChannelPtr;
synth:
INTEGER; init: LONGINT; userRoutine:

ProcPtr)
OSErr;
(chan:
SndChannelPtr;
modifier:
ProcPtr;
id:
INTEGER;
init:
LONGINT)
OSErr;
(chan:
SndChannelPtr;
cmd:
SndCommand;
noWait:

BOOLEAN)

OSErr;

nN
|
DN

~~
ll

=
=

2.

eS

<

Summary of the Sound Manager V-503

a
=
fe
ge
®

=

Inside Macintosh
FUNCTION

SndDoImmediate

(chan:
OSErr;

FUNCTION

SndControl

FUNCTION

SndDisposeChannel
(chan:

PROCEDURE
FUNCTION

MyCallBack
MyModifier

(id:

INTEGER;

OSErr;
;

SndChannelPtr;

VAR

cmd:

SndChannelPtr;

OSErr;

cmd:

SndCommand)

SndCommand)
quietNow:

BOOLEAN)

(chan: SndChannelPtr;
cmd: SndCommand) ;
(chan: SndChannelPtr; VAR cmd:
SndCommand; mod: ModifierStub)
BOOLEAN;

Result

Codes

Name

Value

Meaning

badChannel
badFormat

—205
—206

Invalid channel queue length
Handle to 'snd ' resource was invalid

notEnoughHardware
queueFull
resProblem

~—201
—203
—204

No more channels for the specified synthesizer
Noroomin the queue
Problem loading the resource

noHardware

—200

No hardware support for the specified synthesizer

Assembly-Language

Information

Constants
;

Command

numbers

for

SndDoCommand

nullCmd
initCmd
freeCmd

-EQU
-EQU
-EQU

0
1
2

flushCmd
waitCmd
pauseCmd
resumeCmd
callBackCmd
syncCmd
empt yCmd
tickleCmd
requestNextCmd
howOftenCmd
wakeUpCmd
availableCmd
noteCmd
restCmd
freqCmd

-EQU
-EQU)
-EQU
-EQU)
-EQU
-EQU
-EQU
-EQU)
.EQU
-EQU
-EQU)
-EQU
-EQU)
-EQU
-EQU

4
10
11
12
13
14
15
20
21
22
23
24
40
41
42

quietCmd

ampCmd

timbreCmd
waveTableCmd
phaseCmd

-EQU

-EQU

-EQU
-EQU
-EQU

3

43

44
60
61

V-504 Summary of the Sound Manager

The Sound Manager
soundCmd
bufferCmd
rateCmd
midiDataCmd

-EQU-EQU-EQU
-EQU

80
81
82
100

Synthesizer

numbers

for

noteSynth
waveTableSynth

-EQU
.EQU

1
3

j;note
j;wave

sampledSynth
MIDISynthIn

-EQU
-EQU

5
7

;sample
sound synthesizer
=;MIDI synthesizer
in

;

MIDISynthOut

Structure

of

cmdNum

Sound

9

;MIDI

synthesizer
table synthesizer
synthesizer

out

Command

Command number (word)

param]
param2
sndCSize
Structure

-EQU

SndNewChannel

First argument (word)
Second argument (long)
Size of sound command
of

Sound

Channel

commandNum
nextChan
firstMod
callBack
userInfo
wait
cmdInProg
flags
qLength
qHead

Command number (word)
Pointer to next channel
Pointer to first modifier
Pointer to channel’s call back procedure
Free for use (long)
Used internally (long)
Used internally (8 bytes)
Used internally (word)
Queue length (word)
Used internally (word)

queue

Array of sound commands

qTail

Structure
nextStub
code
userInfo
count
every
flags
hState

Used internally (word)

of

Modifier

Stub

Pointer to next modifier
Pointer to modifier code
Free for modifier to use (long)
Used internally (long)
Used internally (long)
Used internally (byte)
Used internally (byte)

S)
~“

L

=

=
=

Summary of the Sound Manager V-S05

=
=

o>
ge
©
=

te

KH

>

—

=
.

=

we
x
<
—

28
509
510
510
510

511
a12

THE

APPLETALK

fo
|
p
we
©
=

MANAGER

About This Chapter
Changes to The AppleTalk Manager
|New AppleTalk Manager Pascal Interface
Using Pascal
MPP Parameter Block
ATP Parameter Block

514
Building Data Structures
515 _— Picking a Node in the Server Range
516
Sending Packets to One’s Own Node
516
ATP Driver Changes
516
Sending an ATP Request Through a Specified Socket
517
Aborting ATP SendRequests
518
Aborting ATP GetRequests
518 | Name Binding Protocol Changes
519
Multiple Concurrent NBP Requests
519
KillNBP function
519
Variable Resources
520 New AppleTalk Protocols
522
Echo Protocol
522
AppleTalk Session Protocol
523
What ASP Does
523
What ASP Does Not Do
523.
AppleTalk Filing Protocol
524 Extended Protocol Package Driver
526
Version
526
Error Reporting
527
.XPP Driver Functions Overview
527
Using AppleTalk Name Binding Protocol
528
Opening and Closing Sessions
528
Session Maintenance
528
Commands on an Open Session
529
Getting Server Status Information
529
Attention Mechanism
530
The Attention Routine
530 Calling the .XPP Driver
530
Using XPP
530
Allocating Memory

530

Opening the .XPP Driver

533
533
533
534

Close Errors
Session Control Block
How to Access the .XPP Driver
General

531
532
532

Example
Open Errors
Closing the .XPP Driver

V-507

Inside Macintosh

536

AppleTalk Session Protocol Functions

541
541
542

AFP Implementation
Mapping AFP Commands
AFPCall Function

543

Login Command Format

536

542
545
547

549
550

551

Note on Result Codes

General Command Format
AFPWrite Command Format
AFPRead Command Format

CCB Sizes
.XPP Driver Result Codes

Summary of the AppleTalk Manager

V-508 The AppleTalk Manager

t

oo)

>

<)

The AppleTalk Manager

—o)

st

—

~*~

me

=

fo
©
=|

Te

ABOUT THIS CHAPTER
The AppleTalk Manager has been enhanced through the implementation of new protocols
and an increase in the functionality of the existing interface. This chapter describes these
enhancements beginning with a brief summary of the changes that have been made. The
remainder of the chapter provides detailed information about these changes.
Reader’s guide: The AppleTalk Manager provides services that allow Macintosh
programs to interact with clients in devices connected to an AppleTalk network. Hence
you need the information in this chapter only if your application uses AppleTalk.
The following is a brief summary of the changes that have been made to the AppleTalk
Manager interface.
= New parameter block—style Pascal calls have been added for the entire AppleTalk
Manager. These new calls give the application programmer better control of
AppleTalk operation within an application.
a At open time, the .MPP driver can be told to pick a node number in the server range.
This is a more time consuming but more thorough operation than is selecting a node
number in the workstation range, and it is required for devices acting as servers.
a Multiple concurrent NBP requests are now supported (just as multiple concurrent ATP
requests have been supported). The KilINBP command has been implemented to
abort an outstanding NBP request.
a ATP requests can now be sent through client-specified sockets, instead of having ATP
pick the socket itself.
a The ability to send packets to one’s own node is supported (although this functionality
is, in the default case, disabled).

= Two new ATP abort calls have been added: KillSendReq and KillGetReq.
KillSendReg is functionally equivalent to RelTCB, although its arguments are
different. KillGetReq is a new call for aborting outstanding GetRequests.
u Additional machine-dependent resources have been added to support, for example,
more dynamic sockets and more concurrent ATP requests.
= A new protocol called the Echo Protocol (EP) is supported.
m= A new driver, .XPP, has been added.

The .XPP driver implements the workstation

side of the AppleTalk Session Protocol (ASP) and a small portion of the AppleTalk
Filing Protocol.

To determine if your application is running on a machine that supports these enhanced
features, check the version number of the .MPP driver (at offset DCtlQueue+1 in the
Device Control Entry). A version number of 48 (NCVersion) or greater indicates the
presence of the new drivers.

About This Chapter V-509

Inside Macintosh

CHANGES

TO THE APPLETALK

MANAGER

The changes to the AppleTalk manager increase functionality and resources. Two interfaces
for the AppleTalk Manager calls are discussed: the new or preferred interface and the
alternate interface. Picking a node address in the server range, sending packets to one’s
own node, multiple concurrent NBP requests, sending ATP requests through a specified
socket and two new ATP calls are also discussed in this section.

New

AppleTalk

Manager

Pascal

Interface

In addition to the interface documented in Volume II, a new parameter block-—style interface
to the AppleTalk Manager is now available for Pascal programmers. This new interface,
referred to as the preferred interface, is available in addition to the interface described
in Volume II which is referred to as the alternate interface. All AppleTalk Manager
calls, old and new, are supported by the preferred interface.

The alternate interface has not been extended to support the new AppleTalk Manager calls.

However, the alternate interface provides the only implementation of LAPRead and

DDPRead. These are higher-level calls not directly supported through the assemblylanguage interface. Developers will wish to use the alternate interface for these calls, and
also for compatibility with previous applications. In all other cases, it is recommended that
the new preferred interface be used.

Using

Pascal

All AppleTalk Manager calls in the preferred interface are essentially equivalent to the

corresponding assembly-language calls. Their form is
FUNCTION

MPPCall

(pbPtr:

Ptr;

asyncFlag:

BOOLEAN)

: OSErr;

where pbPtr points to a device manager parameter block, and asyncFlag is TRUE if the call
is to be executed asynchronously. Three parameter block types are provided by the
preferred interface (MPP, ATP, and XPP). The MPP parameter block is shown below.
The ATP parameter block is shown in the following section, and the XPP parameter block

is shown in Figure 4 in the “Calling the .XPP Driver” section of this document. The field

names in these parameter blocks are the same as the parameter block offset names defined
in the assembly-language section (except as documented below). The caller fills in the
parameter block with the fields as specified in that section and issues the appropriate call.
The interface issues the actual device manager control call.
On asynchronous calls, the caller may pass a completion routine pointer in the parameter
block, at offset ioCompletion. This routine will be executed upon completion of the call. It
is executed at interrupt level and must not make any memory manager calls. If it uses
application globals, it must ensure that register AS is set up correctly; for details see

V-510 Changes to the AppleTalk Manager

bo
or
>

The AppleTalk Manager
SetupA5 and RestoreAS in the Operating System Utilities chapter of Volume II. If no
completion routine is desired, ioCompletion should be set to NIL.
Asynchronous calls return control to the caller with result code of noErr as soon as they are
queued to the driver. This isn’t an indication of successful completion. To determine
when the call is actually completed, if you don’t want to use a completion routine, you can
poll the ioResult field; this field is set to 1 when the call is made, and receives the actual
result code upon completion.
Refer to the AppleTalk Manager chapter in Volume II for the parameter blocks used by each
MPP and ATP call. As different MPP and ATP calls take different arguments in their
parameter block, two Pascal variant records have been defined to account for all the
different cases. These parameter blocks are shown in the sections that follow. The first
four fields (which are the same for all calls) are automatically filled in by the device

manager. The csCode and ioRefnum fields are automatically filled in by the interface,
depending on which call is being made, except in XPP where the caller must fill in the
ioRefnum. The ioVRefnum field is unused.
There are two fields that at the assembly-language level have more than one name. These
two fields have been given only one name in the preferred interface. These are entityPtr
and ntqelPtr, which are both referred to as entityPtr, and atpSocket and currBitmap, which
are both referred to as atpSocket. These are the only exceptions to the naming convention.
MPP

Parameter

MPPParamBlock

Block
=

PACKED

RECORD

qLink:
qType:
ioTrap:
ioCmdAddr:
ioCompletion:
ioResult:
ioNamePtr:

QElemPtr;
INTEGER;
INTEGER;
Ptr;
ProcPtr;
OSErr;
StringPtr;

ioVRefNum:
ioRefNum:

INTEGER;
INTEGER;

csCode:

CASE

INTEGER;

MPPParmType

LAPWriteParm:

OF

{next queue entry}
{queue type}
{routine trap}
{routine address}
{completion routine}
{result code}
{command result
(ATP
{ [long] }
{volume
{driver

reference
reference

{call command
{ SET}

code

user

bytes)

or drive
number}

}

number}

AUTOMATICALLY

}

(filler0O: INTEGER;

wdsPointer:Ptr) ;
{->Write
Data
Structure}
AttachPHParm, DetachPHParm:
(protType:Byte;
{ALAP Protocol
Type}
fillerl:Byte;
handler:Ptr);
{->protocol
handler
routine}
OpenSktParm, CloseSktParm, WriteDDPParm:
(socket :Byte;
{socket
number}
checksumFlag:Byte;
{checksum
flag}

listener:Ptr);

{->socket

listener

routine}

RegisterNameParm,
LookupNameParm, ConfirmNameParm, RemoveNameParm:
(interval:Byte;
{retry
interval}

Changes to the AppleTalk Manager V-511

|
sa
@

a

=
7
5
=|
£9
9@
ay

Inside Macintosh
count

:Byte;

CASE

MPPParmType

{retry

count}

{->names
table element
name}
{ ->entity

entityPtr:Ptr;

OF

RegisterNameParm:
(verifyFlag:Byte;

{set

filler3:Byte) ;
LookupNameParm:

if

verify

or

}

needed}

{->return buffer}
{return
}
INTEGER;

(retBuffPtr:Ptr;

ret Buff£Size:

{

maxToGet
: INTEGER;
numGotten: INTEGER)
ConfirmNameParm:

buffer

{matches

{matched

;

{

gotten}

KillNBPParm:

size}

}

number}

(newSelfFlag:Byte;
oldSelfFlag:Byte) ;

{self-send

toggle

flag}

(nKillQE1:Ptr) ;

{ptr

element

to

{previous

to

Q

get}

{->entity}

(confirmAddr:AddrBlock;
newSocket :Byte; {socket

filler4:Byte));

SetSelfSendParm:

to

self-send

state}

cancel}

END;

ATP

Parameter

Block

ATPParamBlock
=
qLink:
qType:

PACKED

ioTrap:
ioCmdAddr:
1oCompletion:
ioResult:

userData:
reqTID:
ioRefNum:
csCode:

RECORD
QElemPtr;
INTEGER;

INTEGER;
Ptr;
ProcPtr;
OSErr;

LONGINT;
INTEGER;
INTEGER;
INTEGER;

{next

bdsPointer:
CASE

Byte;
Byte;
AddrBlock;
INTEGER;
Ptr;

entry}

{completion

routine}

{result code}
{ATP user bytes
[long] }
{request transaction ID}
{driver reference number
{Call
{

atpSocket:
atpFlags:
addrBlock:
reqLength:
reqPointer:

queue

{queue type}
{routine trap}
{routine address}

command

AUTOMATICALLY

code

}

SET}

{currBitMap or socket number}
{control information}
{source/dest.
socket address}
{request/response length)
{-> request/response data}

{-> response
BDS}
Ptr;
MPPParmType
OF
SendRequestParm, NSendRequestParm:
(numOfBuffs:Byte;
{numOfBuffs}
timeOutVal:Byte;
{timeout
interval}
numOfResps: Byte;
{number
responses
actually
{ received}
retryCount
: Byte;
{number
of retries}

V-512 Changes to the AppleTalk Manager

}

The AppleTalk Manager
intBuff:

INTEGER)

;

{used
{

SendResponseParm:
(filler0O:Byte;

internally

NSendRequest }

{number

bdsSize:Byte;
transID: INTEGER)
GetRequestParm:

;

(bitMap:Byte;
fillerl:Byte) ;

responses

}
being

}

map}

{sequence

filler2:Byte);
KillSendReqParm, KillGetReqParm:
(aKillQE1:Ptr) ;
{ptr to

number}

Q

element

to

cancel}

The following table is a complete list of all the parameter block calls provided by the

preferred interface.
AppleTalk
Manager

Routine

Preferred

Interface

AttachPH

Function

PAttachPH

(thePBptr:

DetachPH

Function

BOOLEAN)
PDetachPH

WriteLAP

Function

BOOLEAN)

PWriteLAP

OSErr;

OpenSkt

Function

CloseSkt

Function

WriteDDP

Function

BOOLEAN)
POpenSkt

OSErr;
PCloseSkt
BOOLEAN)

Call
OSErr;
(thePBptr:
(thePBptr:

OSErr;
(thePBptr:

PWriteDDP
BOOLEAN)

MPPPBPtr;

async:

MPPPBPtr;

async:

MPPPBPtr;

async:

MPPPBPtr;

(thePBptr:
OSErr;

(thePBptr:
OSErr;

MPPPBPtr;

async:

PRegisterName

LookupName

Function

PLookupName

ConfirmName

Function

PConfirmName

RemoveName

Function

OpenATPSkt

Function

PRemoveName
BOOLEAN)
POpenATPSkt

CloseATPSkt

Function

PCloseATPSkt

SendRequest

Function

PSendRequest

GetRequest

Function

PGetRequest

SendResponse

Function

PSendResponse
(thePBptr:
BOOLEAN)
OSErr;

(thePBptr:

OSErr;

BOOLEAN)

OSErxr;

BOOLEAN)

OSErr;

BOOLEAN)

OSErr;

BOOLEAN)

async:

Function

BOOLEAN)

async:

MPPPBPtr;

RegisterName

MPPPBPtr;

async:

(thePBptr:

MPPPBPtr;

async:

(thePBptr:

MPPPBPtr;

async:

(thePBptr:
OSErr;
(thePBptr:

MPPPBPtr;

async:

ATPPBPtr;

async:

(thePBptr:

ATPPBPtr;

async:

(thePBptr:

ATPPBPtr;

async:

(thePBptr:

ATPPBPtr;

async:

BOOLEAN)

OSErr;

BOOLEAN)

OSErr:

BOOLEAN)

OSExx:

ATPPBPtr;

i

=

=

{ sent}
{number of BDS elements}
{transaction
ID}

{bit

AddResponseParm:
(rspNum: Byte;

of

for

ho
~"-)
>
s)
gz4

async:

Changes to the AppleTalk Manager V-513

~
—)
2

Te

om

“

Inside Macintosh

PAddResponse(thePBptr:

AddResponse

Function

ReltCB

Function

RelRspCB

Function

SetSelfSend

Function

NSendRequest

Function

KillSendReq

Function

KillGetReq

Function

KillNBP

Function

Building

Data Structures

ATPPBPtr;

async:

MPPPBPtr;

async:

: OSErr;
BOOLEAN)
BOOLEAN)
async:
ATPPBPtr;
(thePBptr:
PRelTCB
OSErr;
async:
ATPPBPtr;
(thePBptr:
PRelRspCB
BOOLEAN)
: OSErr;

PSetSelfSend
BOOLEAN)

:

(thePBptr:

OSErr;

BOOLEAN)
: OSErr;
PKillSendReq
(thePBptr:
BOOLEAN)
: OSErr;

PKillGetReq
BOOLEAN)

PKillNBP
OSErr;

:

(thePBptr:

OSErr;

(thePBptr:

async:

ATPPBPtr;

(thePBptr:

PNSendRequest

ATPPBPtr;

async:

ATPPBPtr;

async:

MPPPBPtr;

async:

BOOLEAN)

Because it is difficult for Pascal to deal with certain assembly-language structures, the
preferred interface provides a number of routines for building these structures. These
routines are summarized below. See Volume II for details of these data structures.
PROCEDURE

BuildLAPwds

(wdsPtr,dataPtr:

destHost,protoType,

Ptr;

frameLen:

INTEGER) ;

This routine builds a single-frame write data structure LAP WDS for use with the
PWriteLAP call. Given a buffer of length frameLen pointed to by dataPt,, it fills in the
WDS pointed to by wdsPtr and sets the destination node and protocol type as indicated by
destHost and protoType, respectively. The WDS indicated must contain at least two
elements.
PROCEDURE

BuildDDPwds

AddrBlock;

(wdsPtr,headerPtr,dataPtr:

DDPType

:

INTEGER;

dataLen:

Ptr;

destAddress:

INTEGER) ;

This routine builds a single-frame write data structure DDP WDS, for use with the
PWriteDDP call. Given a header buffer of at least 17 bytes pointed to by headerPtr and a
data buffer of length dataLen pointed to by dataPtr, it fills in the WDS pointed to by
wdsPtr, and sets the destination address and protocol type as indicated by destaddress and
DDPtype, respectively. The WDS indicated must contain at least 3 elements.
PROCEDURE

NBPSetEntity
Stx32Z) 5

(buffer:

Ptr;

nbpObject,nbpType,nbpZone:

This routine builds an NBP entity structure, for use with the PLookupNBP and
PConfirmName calls. Given a buffer of at least the size of the EntityName data structure
Si
pointed to by buffer, this routine sets the indicated object, type, and zone in that
uffer.

V-514 Changes to the AppleTalk Manager

to
oO
>

The AppleTalk Manager
PROCEDURE

NBPSetNTE
Socket:

(ntePtr:

Ptr;

nbpObject,nbpType,nbpZone:

INTEGER) ;

Str32;

This routine builds an NBP names table entry, for use with the PRegisterName call. Given
a names table entry of at least the size of the EntityName data structure plus nine bytes (108
bytes) pointed to by ntePtr, this routine sets the indicated object, type, zone, and socket in
that names table entry.
FUNCTION

NBPExtract

INTEGER;

VAR

(theBuffer:

abEntity:

Ptr;

numInBuf:

EntityName;

VAR

INTEGER;

address:

whichOne:

AddrBlock)

OSErr:

This routine is provided in the alternate interface, but can be used as provided for extracting
NBP entity names from a look-up response buffer.
FUNCTION

GetBridgeAddress:

INTEGER;

This routine returns the current address of a bridge in the low byte, or zero if there is none.
FUNCTION

BuildBDS

(buffPtr,bdsPtr:

Ptr;

buffSize:

INTEGER)

:

INTEGER;

This routine builds a BDS, for use with the ATP calls. Given a data buffer of length
buffSize pointed to by buffPtr, it fills in the BDS pointed to by bdsPtr. The buffer will be
broken up into pieces of maximum size (578 bytes). The user bytes in the BDS are not
modified by this routine. This routine is provided only as a convenience; generally the
caller will be able to build the BDS completely from Pascal without it.

Picking

a Node

Address

in the Server

Range

Normally upon opening, the node number picked by the AppleTalk manager will be in the
node number range ($01—$7F). It is possible to indicate that a node number in the server
range ($80-$FE) is desired. Picking a number in the server range is a more timeconsuming but more thorough process, and it’s required for server nodes because it greatly
decreases the possibility of a node number conflict.
To open AppleTalk with a server node number, an extended open call is used. An
extended open call is indicated by having the immediate bit set in the Open trap itself. In
the extended open call, the high bit (bit 31) of the extension longword field (ioMix)
indicates whether a server or workstation node number should be picked. Set this bit to 1
to request a server node number. The rest of this field should be zero, as should all other
unused fields in the queue element. A server node number can only be requested on the
first Open call to the .MPP driver.

Changes to the AppleTalk Manager V-515

s
sos
a)

=

=)
a

9
=
£9
Te@

=y

Inside Macintosh

Sending

Packets

to One’s

Own

Node

Upon opening, the ability to send a packet to one’s own node (intranode delivery) is

disabled. This feature of the AppleTalk Manager can be manipulated through the
SetSelfSend function. Once enabled, it is possible, at all levels, to send packets to entities
within one’s own node. An example of where this might be desirable is an application

sending data to a print spooler that is actually running in the background on the same node.

Enabling (or disabling) this feature affects the entire node and should be performed with
care. For instance, a desk accessory may not expect to receive names from within its own
node as a response to an NBP look-up; enabling this feature from an application could
break the desk accessory. All future programs should be written with this feature in mind.
FUNCTION

PSetSelfSend

(thePBptr:

MPPPBPtr;

async:

BOOLEAN)

:

OSErr;

Parameter Block
~
3
on

26
28
29

csCode
newSelfFlag
oldSelfFlag

word
byte
byte

Always PSetSelfSend
New SelfSend flag
Old SelfSend flag

PSetSelfSend enables or disables the intranode delivery feature of the AppleTalk Manager.
If newSelfFlag is nonzero, the feature will be enabled; otherwise it will be disabled.

previous value of the flag will be returned in oldSelfFlag.
Result Codes

ATP

noErr

The

No error

Driver Changes

Changes to the ATP driver include the ability to send an ATP request through a specific
socket rather than having ATP open a new socket, a new call to abort outstanding
SendRequest calls, and a new call to abort specific outstanding GetRequest calls.

Sending

an

ATP

Request

Through

a Specified

Socket

ATP requests can now be sent through client-specified sockets. ATP previously would
open a dynamic socket, send the request through it, and close the socket when the request
was completed. The client can now choose to send a request through an already-opened
socket; this also allows more than one request to be sent per socket. A new call,
PNSendRequest, has been added for this purpose. The function of the old SendRequest
call itself remains unchanged.

V-516 Changes to the AppleTalk Manager

to
oO
>

The AppleTalk Manager
FUNCTION

PNSendRequest

(thePBptr:

ATPBPtr;

async:

BOOLEAN)

:

OSErr;

Parameter block
~
a
=
oC

18
22,
26
28

userData
reqTID
csCode
atpSocket

longword
word
word
byte

User bytes
Transaction ID used in request
Always sendRequest
Socket to send request on

eo
>
~
>
aed
>
oa
—
o
e

29
30
34
36
40
44
45
46
47
48

atpFlags
addrBlock
reqLength =
reqPointer
bdsPointer
numOfBuffs
timeOutVal
numOf Resps
retryCount
intBuff

byte
longword
word
pointer
pointer
byte
byte
byte
byte
word

Control information
Destination socket address
Request size in bytes
Pointer to request data
Pointer to response BDS
Number of responses expected
Timeout interval
Number of responses received
Number of retries
Used internally

or current bitmap

The PNSendRequest call is functionally equivalent to the SendRequest call, however
PNSendRequest allows you to specify, in the atpSocket field, the socket through which the
request is to be sent. This socket must have been previously opened through an
OpenATPSkt request (otherwise a badATPSKt error will be returned).

Note that

PNSendRequest requires two additional bytes of memory at the end of the parameter block,
immediately following the retryCount. These bytes are for the internal use of the
AppleTalk Manager and should not be modified while the PNSendRequest call is active.
There is a machine-dependent limit as to the number of concurrent PNSendRequests that
can be active on a given socket. If this limit is exceeded, the error tooManyRegs is
returned.
One additional difference between SendRequest and PNSendRequest is that a
PNSendRequest can only be aborted by a PKillSendReq call (see below), whereas a
SendRequest can be aborted by either a RelTCB or KillSendReq call.
Result Codes

Aborting
The

ATP

noErr
reqFailed
tooManyReqs
noDataArea
reqAborted

No error
Retry count exceeded
Too many concurrent requests
Too many outstanding ATP calls
Request cancelled by user

SendRequests

RelTCB call is still supported, but only for aborting SendRequests.

PNSendRequests, a new call, PKillSendReq, has been added.

To abort

This call will abort both

SendRequests and PNSendRequests. PKillSendReq’s only argument is the queue element
pointer of the request to be aborted. The queue element pointer is passed at the offset of the
PKillSendReq queue element specified by aKillQE1.

Changes to the AppleTalk Manager V-517

—
=
=
2)=

O_

f
=
5
Te
©

Lea |

Inside Macintosh
FUNCTION

PKillSendReq

ATPPBPtr;

(thePBptr:

async:

:

BOOLEAN)

OSErr;

Parameter block
>
>

26
44

csCode
aKillQE]

word
pointer

Always PKillSendReq
Pointer to queue element

PKillSendReq is functionally equivalent to RelTCB, except that it takes different arguments
and will abort both SendRequests and PNSendRequests. To abort one of these calls, place
a pointer to the queue element of the call to abort in aKillQEI and issue the PKillSendReq
call.
Result Codes

Aborting

noErr

cbNotFound

ATP

No error

aKillQEl does not point to a SendReq
or NSendReq queue element

GetRequests

ATP GetRequests can now be aborted through the PKillGetReq call. This call looks and
works just like the PKillSendRegq call, and is used to abort a specific GetRequest call.
Previously it was necessary to close the socket to abort all GetRequest calls on the socket.
FUNCTION

PKillGetReq

(thePBptr:

ATPPBPtr;

async:

BOOLEAN)

:

OSErr;

Parameter block

>

26

>

44

csCode

word

aKillQEl

pointer

Always PKillGetReq

— Pointer to queue element

PKillGetReq will abort a specific outstanding GetRequest call (as opposed to closing the
socket, which aborts all outstanding GetRequests on that socket). The call will be
completed with a reqAborted error. To abort a GetRequest, place a pointer to the queue
element of the call to abort in aKillQEI and issue the PKillGetReg call.
Result Codes

Name

Binding

noErr
cbNotFound

Protocol

No error
aKillQEI does not point to a GetReq
queue element

Changes

Changes to the Name Binding Protocol include supporting multiple concurrent requests and
a means for aborting an active request.

V-518 Changes to the AppleTalk Manager

bn

x

>

—

The AppleTalk Manager

Multiple

Concurrent

NBP

Requests

NBP now supports multiple concurrent active requests.

FUNCTION

PKillNBP

(thePBptr:

ATPPBPtr;

csCode
aKillQEl

word
pointer

async:

BOOLEAN)

:

OSErr;

Parameter block

3
>

26
28

Always PKilINBP
Pointer to queue element

PKillNBP is used to abort an outstanding LookupName, RegisterName or ConfirmName
request. To abort one of these calls, place a pointer to the queue element of the call to abort
in a KillQEI and issue the PKilINBP call. The call will be completed with a ReqAborted
error.

Result Codes

Variable

noErr

cbNotFound

No error

aKillQEl does not point to a valid
NBP queue element

Resources

The table below lists machine-dependent resources for the different Macintosh system
configurations. The RAM-based resources are available through the AppleShare Server.
Resource
Protocol
Handlers

Macintosh

Plus

RAM-Based

Macintosh

SE

Macintosh

4

8

8

8

14*

12

12

14

ATP SendRequests

6

12

12

12

ATP Sockets

6

52,

32

126

Statically
Assigned
Sockets

Concurrent

=>
—
=
to)

maximum number of concurrent requests is machine dependent; if it is exceeded the error
tooManyRegs will be returned. Active requests can be aborted by the PKillNBP call.
function

ee.

©,

9

Specifically, a number of

LookupNames, RegisterNames and ConfirmNames can all be active concurrently. The

KilINBP

=

II

Changes to the AppleTalk Manager V-519

©
=

Inside Macintosh

Resource

Macintosh

Concurrent

Plus

RAM-Based

SE

Macintosh

Macintosh

8

16

16

32

NBP Requests

]

6

6

10

Concurrent
ASP Sessions

N/A

5

10

20

N/A

9

14

62

ATP Responses
Concurrent

II

Concurrent

ATP NSendRequests
Per Socket **

* Includes dynamic sockets
** Determined dynamically at runtime based on CPU speed.
N/A : Not Applicable

NEW APPLETALK PROTOCOLS
The following protocols have been added to the AppleTalk Manager:

m Echo Protocol
m AppleTalk Session Protocol (workstation side)
m AppleTalk Filing Protocol (small portion of the workstation side)
The AppleTalk system architecture consists of a number of protocols arranged in layers.
Each protocol in a specific layer provides services to higher-level layers (known as the
protocol’s clients) by building on the services provided by the lower-level layers. Figure 1
shows the AppleTalk Protocols and their corresponding network layers.
In Figure 1, the lines indicate the interaction between the protocols.

Notice that like the

Routing Table Maintenance Protocol, the Echo Protocol is not directly accessible to
Macintosh programs.
The details of these protocols are provided in Jnside AppleTalk.

V-520 New AppleTalk Protocols

The AppleTalk Manager

tb
oo
>
<}
—©
—
at
x
£9
=|
fo
i)@

Lee |

Gone

[Arve

Filing Protocol

]

Session Protocol

Presentation Layer

Printer Access Protocol

Zone Information
Protocol

Echo
Protocol

}

Session Layer

AppleTalk
acta
Protocol

ae Table
aintenance
aes

Name Binding
Protocol

Link Access Layer
[ronira Link Access Protocol

)
Physical Layer

a

Network

Hardware

()

Figure 1. AppleTalk Protocols and OSI Network Layers

New AppleTalk Protocols V-521

Inside Macintosh

Echo

Protocol

The Echo Protocol (EP) provides an echoing service through static socket number 4
known as the echoer socket. The echoer listens for packets received through this
socket. Any correctly formed packet sent to the echoer socket on a node will be echoed
back to its sender.
This simple protocol can be used for two important purposes:
us EP can be used by any Datagram Delivery Protocol (DDP) client to determine if a
particular node (known to have an echoer) is accessible over an internet.
= EP is useful in determining the average time it takes for a packet to travel to a remote
node and back. This is very helpful in developing client-dependent heuristics for
estimating the timeouts to be specified by clients of ATP, ASP, and other protocols.
Programs cannot access EP directly via the AppleTalk Manager. The EP implementation
exists solely to respond to EP requests sent by other nodes. EP is a DDP client residing on
statically-assigned socket 4, the echoing socket. Clients wishing to send EP requests (and
receive EP responses) should use the Datagram Delivery Protocol (DDP) to send the
appropriate packet. For more information about the EP packet format, see /nside
AppleTalk.

AppleTalk

Session

Protocol

The AppleTalk Session Protocol (ASP) provides for the setting up, maintaining and
closing down of a session. A session is a logical relationship between two network
entities,

a workstation and a server.

The workstation tells the server what to do, and

the server responds with the appropriate actions. ASP makes sure that the session dialog is
maintained in the correct sequence and that both ends of the conversation are properly
participating.
ASP will generally be used between two communicating network entities where one is
providing a service to the other (for example, a server is providing a service to a
workstation) and the service provided is state-dependent. That is, the response to a
particular request from an entity is dependent upon other previous requests from that entity.
For example, a request to read bytes from a file is dependent upon a previous request to
open that file in the first place. However, a request to return the time of day is independent
of all such previous requests.
When the service provided is state-dependent, requests must be delivered to the server in
the same order as generated by the workstation. ASP guarantees requests are delivered to
the server in the order in which they are issued, and that duplicate requests are never
delivered (another requirement of state-dependent service).

V-522 New AppleTalk Protocols

t

2)

>

<—)

The AppleTalk Manager
What

ASP

Does

ASP is an asymmetric protocol, providing one set of services to the workstation and a
different set of services to the server.
ASP workstation clients initiate (open) sessions, send requests (commands) on that

session, and close sessions down. ASP server clients receive and respond (through

command replies) to these requests.

ASP guarantees that these requests are delivered in the

same order as they are made, and without duplication. ASP is also responsible for closing

down the session if one end fails or becomes unreachable, and will inform its client (either
server or workstation) of the action.

ASP also provides various additional services, such as allowing a workstation to obtain
server status information without opening a session to a server, writing blocks of data from
the workstation to the server end of the session, and providing the ability for a server to
send an attention message to the workstation.
ASP assumes that the workstation client has a mechanism for looking up the network
address of the server with which it wants to set up a session. (Generally this is done using
the AppleTalk Name Binding Protocol.)
Both ends of the session periodically check to see that the other end of the session is still

responsive. If one end fails or becomes unreachable the other end closes the session.
ASP is a client of ATP and calls ATP for transport services.

What

ASP

Does

Not

Do

ASP does not
= ensure that consecutive commands complete in the order in which they were sent (and
delivered) to the server
= understand or interpret the syntax or the semantics of the commands sent to the server
by the workstation
w allow the server to send commands to the workstation

(The server is allowed to alert

the workstation through the server’s attention mechanism only.)

Note: The .XPP driver does implement the workstation side of the AppleTalk Filing
Protocol login command.

AppleTalk

Filing

Protocol

The AppleTalk Filing Protocol (AFP) allows a workstation on an AppleTalk network to
access files on an AFP file server. AFP specifies a remote filing system that provides user
authentication and an access control mechanism that supports volume and folder-level
access rights. For details of AFP, refer to the AFP Technical Notes.

New AppleTalk Protocols V-523

=

ae

oO,

==
£9
=
fo
Te
o)
a

Inside Macintosh

EXTENDED

PROTOCOL

PACKAGE

DRIVER

The Extended Protocol Package (XPP) driver is intended to implement several AppleTalk
communication protocols in the same package for ease of use. The .XPP driver currently

consists of two modules that operate on two levels: the low-level module implements the
workstation side of AppleTalk Session Protocol, and the high-level module implements a
small portion of the workstation side of the AppleTalk Filing Protocol.

This driver adds functionality to the AppleTalk manager by providing services additional to
those provided in the .MPP and .ATP drivers. Figure 2 shows the Macintosh AppleTalk
drivers and the protocols accessible through each driver.

V-524 Extended Protocol Package Driver

nN
io)

>

The AppleTalk Manager
(

Macintosh program

os
sce

e

St)
=

<

p=)

F

5

Fe
@
™

A small part of the
Appletalk Filing Protocol

v

AppleTalk Session Protocol

v

.XPP Driver

Name

Ad
ppleTalk Transaction

A

Protocol

Binding

Protocol

ATP Driver

|
Datagram

Delivery Protocol

(AppleTalk Link Access Protocol

)s

.MPP Driver

v
_/

Network Hardware

—_()

Figure 2. Macintosh AppleTalk Drivers

Extended Protocol Package Driver V-525

Inside Macintosh

The .XPP driver maps an AFP call from the client workstation into one or more ASP calls.
.XPP provides one client-level call for AFP.
The implementation of AFP in the .XPP driver is very limited. Most calls are a very simple

one-to-one mapping from an AFP call to an ASP command without any interpretation of
the syntax of the AFP command by the .XPP driver. Refer to the “Mapping AFP
Commands” section of this chapter for further information.
Version
The .XPP driver supports ASP Version (hex) $100, as described in /nside AppleTalk.

Error

Reporting

Errors are returned by the .XPP driver in the ioResult field of the Device Manager Control
calls.
The error conditions reported by the .XPP driver may represent the unsuccessful
completion of a routine in more than just one process involved in the interaction of the
session. System-level, .XPP driver, AppleTalk, and server errors can all turn up in the
ioResult field.
AFP calls return codes indicating the unsuccessful completion of AFP commands in the
Command Result field of the parameter block (described below).
An application using the .XPP driver should respond appropriately to error conditions
reported from the different parts of the interaction. As shown in Figure 3, the following
errors can be returned in the ioResult field:
1.

System-level errors

System errors returned by the .XPP driver indicate such conditions as the driver not

being open or a specific system call not being supported. For a complete list of result
codes returned by the Macintosh system software, refer to Volume II, Appendix A.
2. XPP errors (for example, “Session not opened”’)

The .XPP driver can also return errors resulting from its own activity (for example,
the referenced session isn’t open). The possible .XPP driver errors returned are
listed in the .XPP driver results codes section with each function that can return the
code.
3. AppleTalk Errors (returned from lower-level protocols)
-XPP may also return errors from lower-level protocols (for example, “Socket not
open’”’).

V-526 Extended Protocol Package Driver

nN

or

>

The AppleTalk Manager
Possible error conditions and codes are described in Volume II, chapter 10, “The

AppleTalk Manager.”

5. The AppleTalk Filing Protocol defines errors that are returned from the server to the
workstation client. These errors are returned in the cmdResult field of the parameter
block (error type 5 in Figure 3). This field is valid if no system-level error is returned
by the call. Note that at the ASP level, the cmdResult field is client-defined data and
may not be an error code.
ioResult Field

4 4 4
2| 3
]

Workstation
1. System Error

2. XPP Error

3. AppleTalk Error

4. ASP Server Error
5S. AFP Server Error

Figure 3. Error Reporting
.XPP

Driver

Functions

Overview

The paragraphs below describe the implementation of ASP

in the .XPP driver. For more

detailed information about ASP, refer to /nside AppleTalk, Section 11, “AppleTalk Session
Protocol (ASP)”.
Using

AppleTalk

Name

\¢°]

ae

=
~

=<

=

4. An ASP-specific error could be returned from an ASP server in response to a failed
OpenSession call. Errors of this type, returned by the server to the workstation, are
documented both in /nside AppleTalk, section 11, “AppleTalk Session Protocol”,
and in the .XPP driver results code section of this chapter.

Command
Result Field

)
=

Binding

Protocol

A server wishing to advertise its service on the AppleTalk network calls ATP to open an
ATP responding socket known as the session listening socket (SLS). The server then calls
the Name Binding Protocol (NBP) to register a name on this socket. At this point, the
server Calls the server side of ASP to pass it the address of the SLS. Then, the server

starts listening on the SLS for session opening requests coming over the network.

Extended Protocol Package Driver V-527

=
fe
ga
@
om

Inside Macintosh

Opening

and

Closing

Sessions

When a workstation wishes to access a server, the workstation must call NBP to discover

the SLS for that server. Then the workstation calls ASP to open a session with that server.

After determining the SLS (address) of the server, the workstation client issues an
OpenSession (or AFPLogin) call to open a session with that server. As a result of this call,
ASP sends a special OpenSession packet (an ATP request) to the SLS; this packet carries
the address of a workstation socket for use in the session. This socket is referred to as the
workstation session socket (WSS). Ifthe server is unable to set up the session, it returns
an error. If the request is successful, the server returns no error, and the session is
opened. The open session packet also contains a version number so that both ends can
verify that they are speaking the same version of ASP.
The AbortOS function can be used to abort an outstanding OpenSession request before it
has completed.
The workstation client closes the session by issuing a CloseSession (or AFPLogout). The
CloseSession call aborts any calls that are active on the session and closes the session. The
session can also be closed by the server or by ASP itself, such as when one end of the
session fails. The CloseAll call (which should be used with care) aborts every session that
the driver has active.
Session

Maintenance

A session will remain open until it is explicitly terminated by the ASP client at either end or
until one of the sessions ends, fails, or becomes unreachable.

Commands

on

an

Open

Session

Once a session has been opened, the workstation client can send a sequence of commands
over the session to the server end. The commands are delivered in the same order as they
are issued at the workstation end, and replies to the commands are returned to the
workstation end.
Three types of commands can be made on an open session. These commands are
UserCommand, UserWrite, and AFPCall functions described in the following paragraphs.
UserCommand calls are similar to ATP requests. The workstation client sends a command
(included in a variable size command block) to the server client requesting it to perform a
particular function and send back a variable size command reply. Examples of such
commands vary from a request to open a particular file on a file server, to reading a certain
range of bytes from a device. In the first case, a small amount of reply data is returned; in
the second case a multiple-packet reply might be generated.

V-528 Extended Protocol Package Driver

ty
Co
>

)

The AppleTalk Manager
The .XPP driver does not interpret the command block or in any way participate in
executing the command’s function. It simply conveys the command block, included in a
higher-level format, to the server end of the session, and returns the command reply to the
workstation-end client. The command reply consists of a four-byte command result and a
variable size command reply block.
UserWrite allows the workstation to convey blocks of data to the server. UserWrite is

used to transfer a variable size block of data to the server end of the session and to receive a

reply.

The AFPCall function provides a mechanism for passing an AFP command to the server
end of an open session and receiving a reply. The first byte of the AFPCall command
buffer contains the code for the AFP command that is to be passed to the server for
execution. Most AFP calls are implemented through a very simple one-to-one mapping that
takes the call and makes an ASP command out of it.
The AFPCall function can have one of four different, but very similar, formats.

Getting

Server

Status

Information

ASP provides a service to allow its workstation clients to obtain a block of service status
information from a server without the need for opening a session. The GetStatus function
returns a status block from the server identified by the indicated address. ASP does not
impose any structure on the status block. This structure is defined by the protocol above
ASP.
Attention

Mechanism

Attentions are defined in ASP as a way for the server to alert the workstation of some event
or critical piece of information. The ASP OpenSession and AFPLogin calls include a
pointer to an attention routine in their parameter blocks. This attention routine is called by
the .XPP driver when it receives an attention from the server and also when the session is
closing as described below.
In addition, upon receiving an OpenSession call or AFPLogin call, the .XPP driver sets the
first two bytes of the session control block (SCB) to zero.

When the .XPP driver receives

an attention, the first two bytes of the SCB are set to the attention bytes from the packet
(which are always nonzero).

Note: A higher-level language such as Pascal may not wish to have a low-level
attention routine called. A Pascal program can poll the attention bytes, and if they are
ever nonzero, the program will know that an attention has come in. (It would then set
the attention bytes back to zero.) Of course, two or more attentions could be received
between successive polls, and only the last one would be recorded.
The .XPP driver also calls the attention routine when the session is closed by either the
server, workstation, or ASP itself (if the ASP session times out).

attention bytes in the SCB are unchanged.

In these cases, the

Extended Protocol Package Driver V-529

4ck©

=]

==
p
=
fg
7
©
Lea

4

Inside Macintosh
The

Attention

Routine

The attention routine is called at interrupt level and must observe interrupt conventions.
Specifically, the interrupt routine can change registers AO through A3 and DO through D3
and it must not make any Memory Manager calls.
It will be called with
= DO (word) equal to the SessRefnum for that session (see OpenSession Function)

= D1 (word) equal to the attention bytes passed by the server (or zero if the session is
closing)
Return with an RTS (return from subroutine) to resume normal execution.
The next section describes the calls that can be made to the .XPP driver.

CALLING

THE .XPP DRIVER

This section describes how to use the .XPP driver and how to call the .XPP driver routines

from assembly language and Pascal.

Using

XPP

The .XPP driver implements the workstation side of ASP and provides a mechanism for
the workstation to send AppleTalk Filing Protocol (AFP) commands to the server.

Allocating

Memory

Every call to the .XPP driver requires the caller to pass in whatever memory is needed by
the driver for the call, generally at the end of the queue element. When a session is opened,

the memory required for maintenance of that session (that is, the Session Control Block) is

also passed in.

For standard Device Manager calls, a queue element of a specific size equal to IOQEISize is
allocated. When issuing many calls to XPP, it is the caller’s responsibility to allocate a
queue element that is large enough to accommodate the .XPP driver’s requirements for
executing that call, as defined below. Once allocated, that memory can’t be modified until
the call completes.

Opening

the

.XPP

Driver

To open the .XPP driver, issue a Device Manager Open call. (Refer to Volume II, chapter

6, “The Device Manager’’.) The name of the .XPP driver is 'XPP'. The original

Macintosh ROMs require that .XPP be opened only once. With new ROMs, the .XPP unit

V-530 Calling the XPP Driver

to
o
-

The AppleTalk Manager
number can always be obtained through an Open call. With old ROMs only, the .XPP unit

number must be hard coded to XPPUnitNum (40) since only one Open call can be issued
to the driver.

The .XPP driver cannot be opened unless AppleTalk is open. The application must ensure
that the .MPP and .ATP drivers are opened, as described in Volume II, pages 304-305.

The xppLoaded bit (bit 5) in the PortBUse byte in low memory indicates whether or not the
.XPP driver is open.

Example
The following is an example of the procedure an application might use to open the .XPP
driver.
;

Routine:

;

Open

;
:

Exit:

:

All

OpenXPP
the

.XPP

other

.
‘

xppUnitNum
xppTfRNum
OpenxXPP

=

error
code
XPP driver

registers
EQU
EQU

and

return
(ccr's
refNum

the

40
— (xppUnitNum+1)

BPL.S
BTST

@10
;branch
#xppLoadedBit,PortBUse ;is

MOVE

MOVEQ

BRA.S

;

XPP

;

Open

ROM

#xppTfRNum,
#0,D0

;check

;if

D1

not

call

to

and

it

open.
the

;set

just

use

noErr

call

get

we

already

the

type

open,

Open

so

XPP
XPP

driver
driver

it.

this

to

open,

correct

number
refNum

byte

if >=128K ROMs
the XPP driver

exit

an

is

ROM

jand
Make

driver

registers

not

;else

@90

driver

machine

for

errors)

;default
;default

;save

ROM85,D0

@10

refNum

preserved

A0Q-A1/D2,-(SP)

BEQ.S

driver

set)
(if no

MOVE.L
MOVE

;

Hl

DO
Dl

driver

then

as

it.

we

open

branch

driver

If

Open

refnum

using

will

driver

already?
to

make

refNum.

a

code

128K

another

Calling the XPP Driver V-531

oT
=
=
5
oe
a
g5
os
Te@

©.

—

Inside Macintosh
@10

SUB

#i0QE1Size, SP

MOVE.L

LEA

MOVE

CLR.B
_Open

SP,A0

.L

MOVE

ADD

@90

XPPName,

Al

ioPermssn

(A0)

Al,

ioFileName

TST

;AQ

param

;driver

name

;Al

(A0)

temporary

->

->

XPP

;clear

;Dl=driver

(SP) +,A0-Al1/D2

;restore

SP

;deallocate

DO

block

;error?

param

(ASP/AFP)
into

refNum

temp

block

driver

param

permissions

ioRefNum(A0),D1

#i0QE1Size,

MOVE.L

;allocate

byte

(invalid

param

name

block

block

if

error)

registers

(set

ccr's)

RTS

XPPName

DC.B4

;length

DC.B'.XPP!

;driver

of

string

name

From Pascal, XPP can be opened through the OpenXPP call, which returns the driver’s

reference number:
FUNCTION

Open

OpenXPP

(VAR

xppRefnum:

INTEGER)

:

OSErr;

Errors

Errors returned when calling the Device Manager Open routine if the function does not
execute properly include the following:
m errors returned by System
m portInUse is returned if the AppleTalk port is in use by a driver other than AppleTalk
or if AppleTalk is not open.

Closing

the

.XPP

Driver

To close the .XPP driver, call the Device Manager Close routine.
Warning: There is generally no reason to close the driver. Use this call sparingly, if
at all. This call should generally be used only by system-level applications.

V-532 Calling the XPP Driver

bo
or)
>

S

The AppleTalk Manager
Close

Errors returned when calling the Device Manager Close routine if the function does not
execute properly include the following:
m errors returned by System
m closeErr (new ROMs only) is returned if you try to close the driver and there are
sessions active through that driver. When sessions are active, closeErr is returned and
the driver remains open.
# on old ROMs the driver is closed whether or not sessions are active and no error is

returned. Results are unpredictable if sessions are still active.
Control

Block

The session control block (SCB) is a nonrelocatable block of data passed by the caller to
XPP upon session opening. XPP reserves this block for use in maintaining an open
session. The SCB size is defined by the constant schMemSize. The SCB is a locked
block, and as long as the session is open, the SCB cannot be modified in any way by the
application. There is one SCB for each open session. This block can be reused once a
CloseSess call is issued and completed for that session or when the session is indicated as
closed.
How

to Access

=
=

~*~

Errors

Session

=®

the

.XPP

Driver

This section contains information for programmers using Pascal and assembly-language
routines.
All .XPP driver routines can be executed either synchronously (meaning that the
application can’t continue until the routine is completed) or asynchronously (meaning that
the application is free to perform other tasks while the routine is executing).
XPP calls are made from Pascal in the same manner as MPP and ATP calls, with the

exception that when making XPP calls the caller must set the XPP driver’s refnum.
refnum is returned in the XPPOpen call’s parameter block.

This

A Pascal variant record has been defined for all XPP calls. This parameter block is detailed
in Figure 4. The first four fields (which are the same for all calls) are automatically filled in
by the device manager. The csCode field is automatically filled in by Pascal, depending on
which call is being made. The caller must, however, set the ioRefnum field to XPP’s
reference number, as returned in the OpenXPP call. The ioVRefnum field is unused.

Note that the parameter block is defined so as to be the maximum size used by any call.
Different calls take different size parameter blocks, each call requiring a certain minimum
size. Callers are free to abbreviate the parameter block where appropriate.

Calling the .XPP Driver V-533

$9
=
69
Tg
©
Lew

|

Inside Macintosh

General
With each routine, a list of the parameter block fields used by the call is also given. All
routines are invoked by Device Manager Control calls with the csCode field equal to the
code corresponding to the function being called. The number next to each field name
indicates the byte offset of the field from the start of the parameter block pointed to by AO;
only assembly-language programmers need to be concerned with it. An arrow next to each
parameter name indicates whether it’s an input, output, or input/output parameter:
Arrow

Meaning

Lo
c
o

Parameter is passed
Parameter is returned
Parameter is passed and returned

All Device Manager Control calls return an integer result code in the ioResult field. Each

routine description lists all the applicable result codes, along with a short description of
what the result code means. Refer to the section “XPP Driver Result Codes” for an
alphabetical list of result codes returned by the .XPP driver.

Each routine description includes a Pascal form of the call.
are of the form:
FUNCTION

XPPCall
OSErr;

(paramBlock:

Pascal calls to the .XPP Driver

XPPParmBlkPtr,async:

BOOLEAN)

XPPCall is the name of the routine.

The parameter paramBlock points to the actual I/O queue element used in the _Control call,
filled in by the caller with the parameters of the routine.
The parameter async indicates whether or not the call should be made asynchronously.
async is TRUE, the call is executed asynchronously; otherwise the call is executed
synchronously.
The routine returns a result code of type OSErr.

V-534 Calling the XPP Driver

If

no
io)

>

The AppleTalk Manager

=

®,
=)

XPPParamBlock

= PACKED

qLink:
qType:
ioTrap:
ioCmdAddr:

ioCompletion:

{next queue entry}
{queue type}
{routine trap}
{routine address}

OSErr;
LONGINT;

{result code}
{command result

ProcPtr;

ioResult:
cmdResult:

ioVRefNum:
ioRefNum:

{completion

INTEGER;
INTEGER;

csCode:

CASE

RECORD

QElemPtr;
INTEGER;
INTEGER;
Ptr;

{volume
{driver

INTEGER;

XPPPrmBlkType

ASPAbortPrm:
(abortSCBPtr:
ASPSizeBlk:
(aspMaxCmdSize:
aspQuantumSize:
numSesss:

{Call

OF

Ptr);

[word]
[word]}
[word] }

(serverAddr:

{server

address

block

[longword]}

{SCB pointer
[longword] }
{attention routine pointer

INTEGER;

{command

INTEGER;

{reply

©rbPtr:
Ptr;
CASE XPPEndPrmType
AFPLoginPrm:
(afpAddrBlock:

[long] }

[long] }

Ptr;
Ptr);
Ptr;

rbSize:

number)

{offset to session refnum
[word] }
{timeout for ATP
[byte] }
{retry count for ATP
[byte] }

AddrBlock;

cbPtr:

pointer

bytes)

INTEGER;
{for SPGetParms
INTEGER;
{for SPGetParms
INTEGER); {for SPGetParms

scbPointer:
attnRoutine:
ASPSubPrm:
(cbSize:

{command

buffer

{reply

OF

block

block

buffer

AddrBlock;

[long] }

size

[word] }

size

[word] }

pointer

pointer

[long] }

[long]}

{address block in }
{ AFPlogin
[long] }

afpSCBPtr:

Ptr;

afpAttnRoutine:

Ptr);

{ AFPlogin
[long] }
{attn routine pointer
{ in AFPlogin}

(wdSize:

INTEGER;

{write

wdPtr:

Ptr;

ASPEndPrm:

ccbStart:
max

code}

user

or drive
number)

AbortOS

(sessRefnum:
INTEGER;
aspTimeout:
Byte;
aspRetry:
Byte;
CASE XPPSubPrmType OF
ASPOpenPrm:

{Write

command

(ATP

for

XPPPrmB1lk:

END;

routine}

reference
reference

{SCB

s

=
Fy
Te
=

size(CCB)

=

ARRAY[0..295]
296;

all

other

{SCB

OF

pointer

data

{ [word] }
{write data
{ [long] }

Byte))); {CCB
{ for driver}
calls = 150}

in

size

}

}

}

pointer
memory

}
}

Figure 4. .XPP Driver Parameter Block Record

Calling the XPP Driver V-535

Inside Macintosh

AppleTalk

Session

Protocol

Functions

This section contains descriptions of the .XPP driver functions that you can call. Each

function description shows the required parameter block fields, their offsets within the

parameter block and a brief definition of the field. Possible result codes are also described.
Note

on

Result

Codes

An important distinction exists between the aspParamErr and aspSessClose result codes
that may be returned by the .XPP driver.
When the driver returns aspParamEr to a call that takes as an input a session reference
number, the session reference number does not relate to a valid open session. There could
be several reasons for this, such as the workstation or server end closed the session or the
server end of the session died.
The aspSessClosed result code indicates that even though the session reference number
relates to a valid session, that particular session is in the process of closing down (although
the session is not yet closed).
FUNCTION

ASPOpenSession
(xParamBlock:
BOOLEAN)
: OSErr;

XPPParmBlkPtr;

async:

Parameter block
—
om
i
oa
co
oa
co

26
28
30
31
32
36
40

csCode
sessRefnum
aspTimeout
aspRetry
serverAddr
scbPointer
attnRoutine

word
word
byte
byte
long word
pointer
pointer

Always ASPOpenSess
Session reference number
Retry interval in seconds
Number of retries
Server socket address
Pointer to session control block
Pointer to attention routine

ASPOpenSession initiates (opens) a session between the workstation and a server.

required parameter block is shown above. A

brief definition of the fields follows.

The

SessRefnum is a unique number identifying the open session between the workstation and
the server. The SessRefnum is returned when the function completes successfully and is
used in all calls to identify the session.
ASPTimeOut is the interval in seconds between retries of the open session request.
ASPRetry is the number of retries that will be attempted.
ServerAdadr is the network identifier or address of the socket on which the server is

listening.

SCBPointer points to a nonrelocatable block of data for the session control block (SCB)

that the .XPP driver reserves for use in maintaining an open session. The SCB size is
defined by the constant scbMemSize. The SCB is a locked block and as long as the
session is open, the SCB cannot be modified in any way by the application. There is one

V-536 Calling the XPP Driver

to
oO
>

The AppleTalk Manager
SCB for each open session. This block can be reused when a CloseSess call is issued and
completed for that session, or when the session is indicated as closed through return of
aspParamErr as the result of a call for that session.
AttnRoutine is a pointer to a routine that is invoked if an attention from the server is
received, or upon session closing. If this pointer is equal to zero, no attention routine will
be invoked.

Result codes

aspNoMoreSess
aspParamErr
aspNoServers

Driver cannot support another session
Server returned bad (positive) error code
No servers at that address, or the server did not
respond to the request
OpenSess was aborted by an AbortOS
Server cannot support the offered version number
Server Cannot open another session

reqAborted
aspBadVersNum
aspServerBusy

Note: The number of sessions that the driver is capable of supporting depends on the
machine that the driver is running on.
FUNCTION

ASPCloseSession

BOOLEAN)

:

OSErr;

(xParamBlock:

XPPParmBlkPtr;

async:

Parameter block

e

eK

26

csCode

28

sessRefnum

word

word

Always ASPCloseSession
Session reference number

ASPCloseSession closes the session identified by the sessRefnum returned in the
ASPOpenSession call. ASPCloseSession aborts any calls that are active on the session,

closes the session, and calls the attention routine, if any, with an attention code of zero
(zero is invalid as a real attention code).

Result codes

aspParamErr
aspSessClosed

FUNCTION

ASPAbortOS

OSErr;

Parameter error, indicates an invalid session reference
number
Session already in process of closing

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

Parameter block

—
i

26
28

csCode
abortSCBPointer

word
pointer

Always ASPAbortOS
Pointer to session control block

ASPAbortOS aborts a pending (not yet completed) ASPOpenSession call. The aborted
ASPOpenSession call will return a reqAborted error.
AbortSCBPointer points to the original SCB used in the the pending ASPOpenSession call.

Calling the XPP Driver V-537

—
yc
©

oh

I

~~

£5
=
o>
Ta
@

baw

4

Inside Macintosh

Result codes

FUNCTION

cbNotFound

ASPGetParms
OSErr;

SCB not found, no outstanding open session to be aborted.
Pointer did not point to an open session SCB.
(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN) :

Parameter block
e
on
eG
on

26
28
30
32

csCode
aspMaxCmdSize
aspQuantumSize
numSesss

word
word
word
word

ASPGetParms returns three ASP parameters.

Always ASPGetParms
Maximum size of command block
Maximum data size
Number of sessions
This call does not require an open session.

ASPMaxCmdSize is the maximum size of a command that can be sent to the server.
ASPQuantumSize is the maximum size of data that can be transferred to the server in a
Write request or from the server in a command reply.
NumSess is the number of concurrent sessions supported by the driver.
FUNCTION

ASPCloseAll

OSErr;

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

Parameter block
—

26

csCode

word

Always ASPCloseAll

ASPCloseAll closes every session that the driver has active, aborting all active requests and
invoking the attention routines where provided. This call should be used carefully.
ASPCloseAll can be used as a system level resource for making sure all sessions are closed

prior to closing the driver.
FUNCTION

ASPUserWrite
OSErr;

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN) :

Parameter block
on
—
“
<ce
o
a
oO
ce
-

18
26
28
30
32
34
38
40
44
46
50

cmdResult
csCode
sessRefnum
aspTimeout
cbSize
cbPtr
rbSize
rbPtr
wdSize
wdPtr
ccbStart

V-538 Calling the XPP Driver

long word
word
word
byte
word
pointer
word
pointer
word
pointer
record

ASP command result
Always UserWrite
Session reference number
Retry interval in seconds
Command block size
Command block pointer
Reply buffer size and reply size
Reply buffer pointer
Write data size
Write data pointer
Start of memory for CCB

to
o
ea

The AppleTalk Manager
ASPUserWrite transfers data on a session. ASPUserWrite is one of the two main calls that
can be used to transfer data on an ASP session. The other call that performs a similar data
transfer is ASPUserCommand described below. The ASPUserWrite command returns
data in two different places. Four bytes of data are returned in the cmdResult field and a
variable size reply buffer is also returned.
CmdResult is four bytes of data returned by the server.

SessRefnum is the session reference number returned in the ASPOpenSession call.
ASPTimeOut is the interval in seconds between retries of the call. Notice that there is no
aspRetry field (retries are infinite). The command will be retried at the prescribed interval
until completion or the session is closed.
CBSize is the size in bytes of the command data that is to be written on the session. The
size of the command block must not exceed the value of aspMaxCmdSize returned by the
ASPGetParms call. Note that this buffer is not the data to be written by the command but
only the data of the command itself.
CBPtr points to the command data.
RBSize is passed and indicates the size of the reply buffer in bytes expected by the
command. RBSize is also returned and indicates the size of the reply that was actually
returned.
RBPtr points to the reply buffer.
WDsSize is passed and indicates the size of the write data in bytes to be sent by the
command. WDSize is also returned and indicates the size of the write data that was actually
written.
WDpPointer points to the write data buffer.
CCBStart is the start of the memory to be used by the .XPP driver for the command control
block. The size of this block is equal to a maximum of 296 bytes. To determine the exact
requirement, refer to the CCB Sizes section of this document.
Result codes

FUNCTION

aspParamErr
aspSizeErr
aspSessClosed
aspBufTooSmall

ASPUserCommand

BOOLEAN)

:

OSErr;

Invalid session number, session has been closed
Command block size is bigger than MaxCmdSize
Session is closing
Reply is bigger than response buffer; the buffer will
be filled, data will be truncated
(xParamBlock:

XPPParmBlkPtr;

async:

Parameter block
—
eK
—
on
on

18
26
28
30
32

cmdResult
csCode
sessRefnum
aspTimeout
cbSize

long word
word
word
byte
word

ASP command result
Always ASPUserCommand
Session number
Retry interval in seconds
Command block size

Calling the XPP Driver V-539

‘
je
o
=

=
ry
=
f
7
©

Inside Macintosh

on

34

cbPtr

pointer

Command block pointer

on
a

40
50

rbPtr
ccbStart

pointer
record

Reply buffer pointer
Start of memory for CCB

oC

38

rbSize

word

Reply buffer and reply size

ASPUserCommand is used to send a command to the server on a session.

SessRefnum is the session reference number returned in the ASPOpenSession call.
ASPTimeOut is the interval in seconds between retries of the call. Notice that there is no
aspRetry field (retries are infinite). The command will be retried at the prescribed interval
until completion or the session is closed.
CBSize is the size in bytes of the block of data that contains the command to be sent to the
server on the session. The size of the command block must not exceed the value of
aspMaxCmdSize returned by the ASPGetParms call.
CBPointer points to the block of data containing the command that is to be sent to the
server on the session.
RBSize is passed and indicates the size of the reply buffer in bytes expected by the
command. RBSize is also returned and indicates the size of the reply that was actually
returned.
RBPtr points to the reply buffer.

CCBStart is the start of the memory to be used by the .XPP driver for the command control

block. The size of this block is equal to a maximum of 150 bytes. To determine the exact
requirement refer to the CCB Sizes section of this document.
Result codes

FUNCTION

aspParamErr
aspSizeErr
aspSessClosed
aspBufTooSmall

ASPGetStatus
OSErr;

Invalid session number, session has been closed
Command block size is bigger than MaxCmdSize
Session is closing
Reply is bigger than response buffer; the buffer will
be filled, data will be truncated.

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

Parameter block
—
—
—
o
—
o

26
30
31
32
38
40
50

csCode
aspTimeout
aspRetry
serverAddr
rbSize
rbPtr
ccbStart

word
byte
byte
long word
word
pointer
record

Always ASPGetStatus
Retry interval in seconds
Number of retries
Server socket address
Reply buffer and reply size
Reply buffer pointer
Start of memory for CCB

ASPGetStatus returns server status. This call is also used as GetServerInfo at the AFP
level. This call is unique in that it transfers data over the network without having a session
open. This call does not pass any data but requests that server status be returned.

V-540 Calling the XPP Driver

no

o
>

The AppleTalk Manager
ASPRetry is the number of retries that will be attempted.
ServerAddr is the network identifier or address of the socket on which the server is

listening.

RBSize is passed and indicates the size of the reply buffer in bytes expected by the
command. RBSize is also returned and indicates the size of the reply that was actually
returned.
RBPtr points to the reply buffer.
CCBSrart is the start of the memory to be used by the .XPP driver for the command control
block. The size of this block is equal to a maximum of 150 bytes. To determine the exact
requirement refer to the CCB Sizes section of this document.
aspBufTooSmall
aspNoServer

AFP

Reply is bigger than response buffer, or Replysize is
bigger than ReplyBuffsize
No response from server at address used in call

Implementation

The AFPCall function (called AFPCommand in Pascal) passes a command to an AFP

server. The first byte of the AFPCall command buffer (the AFP command byte) must

contain a valid AFP command code.

Note: Server information should be gotten through an ASPGetStatus call (described
above).

ASPGetStatus is equivalent to the AFPGetSrvrinfo.

GetSrvrInfo call using AFPCommand results in an error.

Mapping

AFP

Making an AFP

Commands

Most AFP calls are implemented by XPP through a very simple one-to-one mapping of an
AFP call to an ASP call without interpretation or verification of the data.
The .XPP driver maps AFP command codes to ASP commands according to the following
conventions:
AFP

Code

Command

$00

$01-$BE (1-190)
SBF (191)

$CO-$FD (192-253)
$FE (254)

$FF (255)

Comment

Invalid AFP command

Mapped to UserCommand

(with the exceptions listed

Mapped to UserCommand
never be used by Apple)

(Reserved for developers; will

below)

Mapped to UserWrite

Mapped to UserWrite

Invalid AFP command

@

mj

ay
_

ASPTimeOut is the interval in seconds between retries of the call.

Result codes

—)
i

(will never be used by Apple)

Calling the XPP Driver V-54]

s5
=|
7®
i)

baw

4

Inside Macintosh

The following AFP calls are exceptions to the above conventions:

AFP Command

Comment

(Code/Decimal)

getSrvrInfo (15)

Mapped to ASPGetStatus (Use ASPGetStatus

login (18)
loginCont (19)

Mapped to appropriate log-in dialog including
ASPOpenSession call
Mapped to appropriate log-in dialog

write (33)

Mapped to ASPUserWrite

to make this call)

logout (20)

Mapped to ASPCloseSession

The following AFP calls can pass or return more data than can fit in quantumSize bytes
(eight ATP response packets) and may be broken up by XPP into multiple ASP calls.
AFP Command
(Code/Decimal)

Comment

read (27)
write (33)

AFPCall

Can return up to the number of bytes indicated in reqCount
Can pass up to the number of bytes indicated in reqCount

Function

The AFPCall function can have one of the following command formats.
= General
a Login
u AFPWrite

uw AFPRead
General
FUNCTION

Command

Format

AFPCommand
OSErr;

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

Parameter block
oa
i
co
e
—

18
26
28
30
32

cmdResult
csCode
sessRefnum
aspTimeout
cbSize

eo
a
o
or
-

38
40
44
46
50

rbSize
rbPtr
wdSize
wdPtr
ccbStart

-

34

cbPtr

V-542 Calling the XPP Driver

long word
word
word
byte
word

AFP command result
Always AFPCall
Session reference number
Retry interval in seconds
Command buffer size

word
pointer
word
pointer
record

Reply buffer size and reply size
Reply buffer pointer
Write data size
Write data pointer
Start of memory for CCB

pointer

Command buffer

to
oa
a

The AppleTalk Manager
The general command format for the AFPCall function passes an AFP command to the

server. This format is used for all AFP calls except AFPLogin, AFPRead, and AFPWrite.
Note that from Pascal this call is referred to as AFPCommand.

CmdResult is four bytes of data returned from the server containing an indication of the
result of the AFP command.

SessRefnum is the session reference number returned in the AFPLogin call.
ASPTimeOut is the interval in seconds between retries of the call by the driver.
CBSize is the size in bytes of the block of data that contains the command to be sent to the
server on the session. The size of the command block must not exceed the value of
aspMaxCmdSize returned by the ASPGetParms call.
CBPtr points to start of the block of data (command block) containing the command that is

to be sent to the server on the session. The first byte of the command block must contain
the AFP command byte. Subsequent bytes in the command buffer contain the parameters
associated with the command as defined in the AFP document.
RBSize is passed and indicates the size of the reply buffer in bytes expected by the
command. RBSize is also returned and indicates the size of the reply that was actually
returned.
RBPtr points to the reply buffer.

WDSize is the size of data to be written to the server (only used if the command is one that
is mapped to an ASPUserWrite).

WDPrtr points to the write data buffer (only used if the command is one that is mapped to an
ASPUserWrite).

CCBStart is the start of the memory to be used by the .XPP driver for the command control
block. The size of this block is equal to a maximum of 296 bytes. To determine the exact
requirement refer to the CCB Sizes section of this document.
Result codes

aspParamErr
aspSizeErr
aspSessClosed

aspBufTooSmall
afpParmError

Invalid session number; session has been closed
Command block size is bigger than MaxCmdSize
Session is closing

Reply is bigger than response buffer or buffer will be

filled, data will be truncated

| AFP command block size is equal to zero. This error
will also be returned if the command byte in the
command block is equal to 0 or $FF (255) or
GetSrvrStatus (15).

Login

Command

Format

The AFP login command executes a series of AFP operations as defined in the AFP Draft
Proposal.

FUNCTION

For further information, refer to the AFP document.
AFPCommand
OSErr;

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN):

Calling the XPP Driver V-543

a
S
=
=
a
_

£5
=
£9
TQ©
Low

|

Inside Macintosh
Parameter block

oa
<
—
é
—
on
©
oC
oe
—

18
26
28
30
al
32
34
38
40
44
48
52
50

cmdResult
csCode
sessRefnum
aspTimeout
aspRetry
cbSize
cbPtr
rbSize
rbPtr
afpAddrBlock
afpSCBPtr
afpAttnRoutine
ccbStart

long word
word
word
byte
byte
word
pointer
word
pointer
long word
pointer
—_ pointer
record

AFP command result
Always AFPCall
Session reference number
Retry interval in seconds
Number of retries
Command buffer size
Command buffer
Reply buffer size and reply size
Reply buffer pointer
Server address block
SCB pointer
Attention routine pointer
Start of command control block

CmdResult is four bytes of data returned from the server containing an indication of the

result of the AFP command.

SessRefnum is the session reference number (returned by the AFPLogin call).
ASPTimeOut is the interval in seconds between retries of the call.

ASPRetry is the number of retries that will be attempted.
CBSize is the size in bytes of the block data that contains the command to be sent to the
server on the session. The size of the command block must not exceed the value of
aspMaxCmdSize returned by the ASPGetParms call.
CBPrtr points to the block of data (command block) containing the AFP login command that
is to be sent to the server on the session. The first byte of the command block must be the
AFP login command byte. Subsequent bytes in the command buffer contain the parameters
associated with the command.
RBSize is passed and indicates the size of the reply buffer in bytes expected by the
command. RBSize is also returned and indicates the size of the reply that was actually
returned.
RBPtr points to the reply buffer.
AFPServerAddr is the network identifier or address of the socket on which the server is

listening.

AFPSCBPointer points to a locked block of data for the session control block (SCB). The
SCB size is defined by schMemSize. The SCB is a locked block, and as long as the
session is open, the SCB cannot be modified in any way by the application. There is one
SCB for each open session.
AFPAttnRoutine is a pointer to a routine that is invoked if an attention from the server is
received. When afpAttnRoutine is equal to zero, no attention routine will be invoked.
CCBStart is the start of the memory to be used by the .XPP driver for the command control
block. The size of this block is equal to a maximum of 150 bytes. To determine the exact
requirement refer to the CCB Sizes section later in this chapter.
Note: In the parameter block, the afpSCBPointer and the afpAttnRoutine fields overlap
with the start of the CCB and are modified by the call.

V-544 Calling the XPP Driver

nN

oo)

>

—

The AppleTalk Manager
Result codes

aspSizeErr
aspBufTooSmall
aspNoServer
aspServerBusy
aspBadVersNum
aspNoMoreSess

AFPWrite

Command

Command block size is bigger than MaxCmdSize
Reply is bigger than response buffer; or buffer will
be filled, data will be truncated
Server not responding
Server cannot open another session
Server cannot support the offered ASP version
number
Driver cannot support another session.

Format

The AFPWrite and AFPRead command formats allow the calling application to make AFPlevel calls that read or write a data block that is larger than a single ASP-level call is capable
of reading or writing. The maximum number of bytes of data that can be read or written at
the ASP level is equal to quantumSize.
FUNCTION

AFPCommand

OSErr;

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

Parameter block
—
—
<—
on
o
o
e

18
26
28
30
32
34
38
40
44
46
50

cmdResult
csCode
sessRefnum
aspTimeout
cbSize
cbPtr
rbSize
rbPtr
wdSize
wdPtr
ccbStart

long word
word
word
byte
word
pointer
word
pointer
word
pointer
record

AFP command result
Always AFPCall
Session number
Retry interval in seconds
Command buffer size
Command buffer
Reply buffer size and reply size
Reply buffer pointer
(used internally)
Write data pointer (updated)
Start of memory for CCB

CmdResult is four bytes of data returned from the server containing an indication of the
result of the AFP command.
SessRefnum is the session reference number returned in the AFPLogin call.
ASPTimeOut is the interval in seconds between retries of the call.

CBSize is the size in bytes of the block data that contains the command to be sent to the
server on the session. The size of the command block must not exceed the value of
aspMaxCmdSize returned by the aspGetParms call.
CBPtr points to the block of data (see command block structure below) containing the AFP

write command that is to be sent to the server on the session. The first byte of the
Command Block must contain the AFP write command byte.

Calling the .XPP Driver V-545

Ke
©

>)

RR,

3
>
fs
=
£9
we
fo)
=

Inside Macintosh

RBSize is passed and indicates the size of the reply buffer in bytes expected by the
command. RBSize is also returned and indicates the size of the reply that was actually
returned.
RBPtr points to the reply buffer.
WDsSize is used internally.
Note: This command does not pass the write data size in the queue element but in the
command buffer. XPP will look for the size in that buffer.

WDPr is a pointer to the block of data to be written. Note that this field will be updated by
XPP as it proceeds and will always point to that section of the data which XPP is currently
writing.
CCBStart is the start of the memory to be used by the XPP driver for the command control
block. The size of this block is equal to a maximum of 296 bytes. To determine the exact
requirement refer to the CCB Sizes section later in this chapter.

Command Block Structure: The AFP write command passes several arguments to
XPP in the command buffer itself. The byte offsets are relative to the location pointed to by
cbPtr.
oo
e

eC
oC

0
1

4
8

cmdByte
startEndFlag

byte
byte

rwOffset
reqCount

long word
long word

AFP call command byte
Start/end Flag

Offset within fork to write
Requested count

CmdByte is the AFP call command byte and must contain the AFP write command code.
StartEndFlag is a one-bit flag (the high bit of the byte) indicating whether the rwOffset field

is relative to the beginning

or the end of the fork (all other bits are zero).

0 = relative to the beginning of the fork
1 = relative to the end of the fork
RW Offset is the byte offset within the fork at which the write is to begin.
ReqCount indicates the size of the data to be written and is returned as the actual size
written.
The rwOffset and reqCount fields are modified by XPP as the write proceeds and will
always indicate the current value of these fields.
The Pascal structure of the AFP command buffer follows:
AFPCommandBlock

=

PACKED

RECORD

cmdByte:
startEndFlag:
forkRefNum:
rwOffset:
reqCount:

newLineFlag:
newLineChar:
END;

V-546 Calling the XPP Driver

Byte;
Byte;
INTEGER;
LONGINT;
LONGINT;

Byte;
CHAR;

{used

by

{unused
{unused

server}

by
by

write}
write}

nN
io)

>

The AppleTalk Manager
Result codes

aspParamErr
aspSizeErr

Invalid session number
Command block size is bigger than MaxCmdSize

aspBufTooSmall

Reply is bigger than response buffer

aspSessClosed

AFPRead

Command

Session is closing

Format

The AFPWrite and AFPRead command formats allow the calling application to make AFPlevel calls that read or write a data block that is larger than a single ASP-level call is capable
of reading or writing. The maximum number of bytes of data that can be read or written at
the ASP level is equal to quantumSize.
FUNCTION

AFPCommand
OSErr;

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

Parameter block
—
ro
on
—
—
c
—
e

18
26
28
30
32
34
38
40
50

cmdResult
csCode
sessRefnum
aspTimeout
cbSize
cbPtr
rbSize
rbPtr
ccbStart

long word
word
word
byte
word
pointer
word
pointer
record

ASP command result
Always AFPCall
Session number
Retry interval in seconds
Command buffer size
Command buffer
Used internally
Reply buffer pointer (updated)
Start of memory for CCB

CmdResult is four bytes of data returned from the server containing an indication of the
result of the AFP command.
SessRefnum is the session reference number returned in the AFPLogin

call.

ASPTimeOut is the interval in seconds between retries of the call.
CBSize is the size in bytes of the block data that contains the command to be sent to the
server on the session. The size of the command block must not exceed the value of
aspMaxCmdSize returned by the GetParms call.
CBPtr points to the block of data (command block) containing the AFP read command that

is to be sent to the server on the session. The first byte of the command block must contain
the AFP read command byte. The command block structure is shown below.
RBSize

is used internally.

Note: This command does not pass the read size in the queue element but in the
command buffer. XPP will look for the size in that buffer.
RBPtr points to the reply buffer. Note that this field will be updated by XPP as it proceeds
and will always point to that section of the buffer that XPP is currently reading into.

Calling the XPP Driver V-547

=

eZ

a
S
Fe

is

Inside Macintosh

CCBStart is the start of the memory to be used by the .XPP driver for the command control
block. The size of this block is equal to a maximum of 150 bytes. To determine the exact
requirement refer to The CCB Sizes section later in this chapter.
Command Block Structure: The AFP read command passes several arguments to
XPP in the command buffer itself. The byte offsets are relative to the location pointed to by
cbPointer.
—
oO
o
e
on

0
4
8
12
13

cmdByte
rwOffset
reqCount
newLineFlag
newLineChar

byte
long word
long word
byte
byte

AFP call command byte
Offset within fork to read
Requested count
Newline Flag
Newline Character

CmdByte is the AFP call command byte and must contain the AFP read command code.
RWOffset is the byte offset within the fork at which the read is to begin.
ReqCount

indicates the size of the read data buffer and is returned as the actual size read.

The rwOffset and reqCount fields are modified by XPP as the read proceeds and will
always indicate the current value of these fields.
NewLineFlag is a one-bit flag (the high bit of the byte) indicating whether or not the read is
to terminate at a specified character (all other bits are zero).
0 = no Newline Character is specified
1 =a Newline Character is specified
NewLineChar is any character from $00 to $FF (inclusive) that, when encountered in

reading the fork, causes the read operation to terminate.

The Pascal structure of the AFPCommand follows:
AFPCommandBlock

=

PACKED

RECORD

cmdByte:
startEndFlag:

Byte;
Byte;

rwOffset:
reqCount:

LONGINT;
LONGINT;

forkRefNum:

newLineFlag:
newLineChar:

INTEGER;

{unused

{used

by

for

read}

server}

Byte;
CHAR;

END;
Result codes

aspParamErr
aspSizeErr
aspSessClosed
aspBufTooSmall

V-548 Calling the XPP Driver

Invalid session number
Command block size is bigger than MaxCmdSize
Session is closing
Reply is bigger than response buffer

tb

oo)

>

<—)

The AppleTalk Manager

CCB

Sizes

—

cS)
ar,
==

p>

The .XPP driver uses the memory provided at the end of the UserWrite, UserCommand,
and GetStatus functions parameter blocks as an internal command control block (CCB).
Using the maximum block sizes specified in the call descriptions will provide adequate
space for the call to execute successfully. However, this section is provided for developers
who wish to minimize the amount of memory taken up by the CCB in the queue element.
Specifically, this memory is used for building data structures to be used in making calls to
the ATP driver. This includes parameter blocks and buffer data structures (BDS). The
structure of the BDS is detailed in the AppleTalk Manager chapter of Volume II. The exact
size of this memory depends on the size of the response expected, and, in the case of
UserWrite, on the size of data to be written.

In the UserCommand and GetStatus cases (along with all AFP calls which map to

UserCommand), a BDS must be set up to hold the response information. The number of
entries in this BDS is equal to the size of the response buffer divided by the maximum
number of data bytes per ATP response packet (578), rounded up. As described in the
ASP chapter in /nside AppleTalk, ASP must ask for an extra response in the case where the
response buffer is an exact multiple of 578. Of course, no BDS can be larger than eight
elements. XPP also needs bytes for the queue element to call ATP with, so the minimum
size of a CCB, as a function of the response buffer size (rbSize) is
bdsSize = MIN (((rbSize DIV 578) + 1),8) * bdsEntrySz

ccbSize = ioQEISize + 4 + bdsSize

With UserWrite (and AFP calls mapping to UserWrite), XPP must create an additional
BDS and queue element to use in sending the write data to the server. Therefore the

minimum size of a UserWrite CCB, as a function of the response buffer and write data

sizes (rbSize and wdSize) is:

wrBDSSize = MIN (((wdSize DIV 578) + 1),8) * bdsEntrySz
wrCCBSize = (2 * ioQEISize) + 4 + bdsSize + wrBDSSize
Note: BDSEntrySz is equal to 12; ioQelSize is equal to 50.

Calling the XPP Driver V-549

=
ft
TQ

©

er

|

Inside Macintosh

.XPP

Driver

Result

Code

Result

Codes

Comment

Returned

aspBadVersNum

Server cannot support the offered version
number.

ASPOpenSession
AFPCall (Login)

aspBufTooSmall

Reply is bigger than response buffer.

ASPUserWrite

truncated.

ASPGetStatus

Buffer will be filled, data may be

aspNoMoreSess

Driver cannot support another session.

aspNoServers

No servers at that address.
The server did not respond to the request.

aspParamErr

Parameter error, server returned bad
(positive) error code.

Invalid Session Reference Number.

by

ASPUserCommand
AFPCall

ASPOpenSessION

AFPCall (Login)
ASPGetStatus

ASPOpenSession
AFPCall (Login)
ASPOpenSession

ASPCloseSess
ASPUserWrite
ASPUserCommand

AFPCall
aspServerBusy

Server cannot open another session.

ASPOpenSession
AFPCall (Login)

aspSessClosed

Session already in process of closing.

ASPCloseSession
ASPUserWrite
ASPUserCommand
AFPCall

aspSizeErr

Command block size is bigger than

ASPUserWrite
ASPUserCommand
AFPCall

cbNotFound

SCB not found, no outstanding
open session to be aborted. Pointer did
not point to an open session SCB.

ASPAbortOS

afpParmError

AFP Command Block size is less than or
equal to zero. Command byte in the
Command block is equal to 0 or $FF (255)

AFPCall

Open session was aborted by an
Abort Open Session.

ASPOpenSession
AFPCall (Login)

maxParamSize.

or GetSrvrStatus (15).

reqAborted

V-550 Calling the XPP Driver

z

>

The AppleTalk Manager

Ss
iS

e.
re)

—

=

oS

SUMMARY
Data

OF THE APPLETALK

=
72

MANAGER

g

Types

MPPParamBlock

qLink:

=

PACKED

qType:
ioTrap:
ioCmdAddr :

i1oCompletion:
ioResult:
ioNamePtr:

RECORD

QElemPtr;

{next

ProcPtr;

{completion

INTEGER;
INTEGER;
PEL?

OSErr?
StringPtr;

queue

entry}

{queue type}
{routine trap}
{routine address}

routine}

{result code}
{command result

{

[long] }

(ATP

user

bytes)

}

ioVRefNum:
INTEGER;
{volume reference or drive number}
ioRefNum:
INTEGER;
{driver reference number}
csCode:
INTEGER;
{call command code AUTOMATICALLY
SET}
CASE MPPParmType OF
LAPWriteParm:
(filler0O
: INTEGER;
wdsPointer:Ptr);
{->Write Data Structure}
AttachPHParm,

OpenSktParm,

DetachPHParm:

(protType:Byte;
fillerl:Byte;
handler:Ptr);

CloseSktParm,

{ALAP

Protocol

{->protocol

Type}

handler

WriteDDPParm:

routine}

(socket: Byte;
{socket number}
checksumFlag:Byte;
{checksum flag}
listener:Ptr);
{->socket
listener routine}
RegisterNameParm,
LookupNameParm, ConfirmNameParm, RemoveNameParm:
{retry interval}
(interval:Byte;
count :Byte;
{retry count}
entityPtr:Ptr;
{-—>names table element or }
{ -—>entity name}
CASE MPPParmType OF

RegisterNameParm:
(verifyFlag:Byte;

filler3:Byte) ;
LookupNameParm:
(retBuffPtr:Ptr;
retBuf£Size: INTEGER;
maxToGet

:

INTEGER;

numGotten: INTEGER) ;
ConfirmNameParm:
(confirmAddr:AddrBlock;
newSocket :Byte;
filler4:Byte));

{set
{

if

needed}

verify

}

{->return buffer}
{return buffer
}
{ size}
{matches

{matched

to

get}

gotten}

{->entity}
{socket number}

SetSelfSendParm:

Summary of the AppleTalk Manager V-551

Inside Macintosh

KillNBPParm:
END;
ATPParamBlock

qLink:

=

(newSelfFlag:Byte;

{self-send

{previous

self-send

state}

(nKillQE1:Ptr);

{ptr

element

cancel}

oldSelfFlag:Byte);

PACKED

RECORD

QElemPtr;

qType:

INTEGER;

ioTrap:

ioCmdAddr :
ioCompletion:
ioResult:

userData:
reqTID:
ioRefNum:
csCode:

atpSocket:
atpFlags:
addrBlock:
reqLength:

reqPointer:

INTEGER;

{next

{queue

queue

{routine

type}

to

toggle

Q

trap}

Ptr;
ProcPtr;
OSErr;

{routine address}
{completion routine}
{result code}

Byte;
Byte;
AddrBlock;
INTEGER;

{ SET}
{currBitMap or socket number}
{control information}
{source/dest.
socket address}
{request/response length}

LONGINT;
INTEGER;
INTEGER;
INTEGER;

PES?

{ATP user bytes
[long] }
{request transaction
ID}
{driver reference number
}
{call command code AUTOMATICALLY

{->

request/response

(numOfBuffs:Byte;
timeOutVal : Byte;

numOfResps

: Byte;

retryCount

:Byte;

{number

responses

{number

of

retries}

{number

of

responses

{number

of

BDS

{

received}

{used internally
{ NSendRequest }

SendResponseParm:
(filler0O:Byte;

{

bdsSize:Byte;

transID: INTEGER);
GetRequestParm:
(bitMap:Byte;
fillerl:Byte);
AddResponseParm:
(rspNum: Byte;

sent}

{transaction
{bit

(aKillQE1:Ptr);

=

PACKED

qType:

ioTrap:
ioCmdAddr:

ioCompletion:
ioResult:

RECORD

element

{next

INTEGER;
Pir:

{routine
{routine

trap}
address}

{result

code}

ProcPtr;
OSErr;

{queue

queue

to

cancel}

QElemPtr;

INTEGER;

type}

{completion

V-552 Summary of the AppleTalk Manager

being

map}

{ptr

Q

entry}

routine}

to

}

}

elements}

number}

{

END;

ID}

actually
for

{sequence

filler2:Byte);
KillSendReqParm, KillGetReqParm:

}

data}

{numOfBuffs}
{timeout interval}

intBuff:INTEGER);

qLink:

to

entry}

bdsPointer:
PCr;
{-> response BDS}
CASE MPPParmType OF
SendRequestParm, NSendRequestParm:

XPPParamBlock

flag}

}

}

3

>
=|
z

The AppleTalk Manager

cmdResult :

LONGINT;

{command result

ioVRefNum:

INTEGER;

{volume

ioRefNum:
csCode:

CASE

INTEGER;
INTEGER;

XPPPrmBlkType

ASPAbortPrm:
ASPSizeBlk:

XPPPrmBlk:

OF

{

(ATP user bytes)

[long] }

reference

or

drive

Pty)

:

{SCB
{

pointer

AbortOS

for

}
}

INTEGER;

{for

SPGetParms

}

aspQuantumSize:

INTEGER;

{for

SPGetParms

}

numSesss:

INTEGER);

{for

SPGetParms

}

(sessRefnum:

INTEGER;

aspTimeout:

Byte;

aspRetry:

Byte;

CASE XPPSubPrmType
ASPOpenPrm:
(serverAddr:

{

[word] }

{

[word] }

{offset to session
{ refnum
[word] }
{timeout for ATP
}

{

[byte] }

{retry count
{ [byte] }

OF

AddrBlock;

scbPointer:

Ptr;

attnRoutine:

Ptr);

ASPSubPrm:
(cbSize:

[word] }

{server

{

Per;

rbSize:

INTEGER;

rbPtr:

Ptr;

block

>

>

for

=

a8
2

}

ATP

address

}

}

}

{ [longword] }
{SCB pointer
}
{ [longword] }
{attention routine
{ pointer
[long] }

INTEGER;

ebPtr’s

}

[long]

(aspMaxCmdSize:

{

pS)

number)

{driver reference number)
{call command code}

(abortSCBPtr:

3

}

{command block
}
{ size
[word] }
{command block
}
{ pointer
[long] }

{reply buffer
{ [word] }

size

}

{reply buffer
}
{ pointer
[long] }
CASE XPPEndPrmType OF
AFPLoginPrm:
(afpAddrBlock:
AddrBlock;
{address block in }
{ AFPlogin
[long] }
afpSCBPtr:
PEx:
{SCB

pointer

{ AFPlogin

in

[long] }

afpAttnRoutine:
Ptr);
{attn routine
{ pointer}
{

ASPEndPrm:
(wdSize:
{write

in

AFPlogin}

INTEGER;
data size

[word]

Summary of the AppleTalk Manager V-553

}

Inside Macintosh
wdPtr:
{write

Ptr:
data

ccbStart:

ARRAY[0..295]

{

[long]

}

pointer

Byte) ));

OF

{CCB memory for driver}
{Write max size(CCB)
=
{ 296;
all other calls =

{

END;

AFPCommandBlock = PACKED RECORD
cmdByte:
Byte;
StartEndFlag:
Byte;
forkRefNum:
INTEGER;
{used

rwOffset:

LONGINT;

newLineFlag:

Byte;

reqCount :

LONGINT;

newLineChar:

CHAR;

by

150}

server}

{unused

by

write}

{unused

for

read}

{unused

by

write}

END;
AFPCommandBlock
cmdByte:

=

StartEndFlag:

PACKED RECORD
Byte;

Byte;

forkRefNum:
rwOffset:
reqCount:

INTEGER;
LONGINT;
LONGINT;

newLineFlag:

{used

by

server}

Byte;

newLineChar:

CHAR;

END;

AppleTalk
FUNCTION

Manager

Routines

PSetSelfSend

(thePBptr:

26
28
29

>
e

AppleTalk
FUNCTION

csCode
newSelfFlag
oldSelfFlag

Transaction

PNSendRequest

MPPPBPtr;

word
byte
byte

BOOLEAN)

:

OSErr;

:

OSErr;

Always PSetSelfSend
New SelfSend flag
Old SelfSend flag

Protocol
(thePBptr:

async:

Functions
ATPBPtr;

=>
=>
oO

18
22
26
28

userData
reqTID
csCode
atpSocket

longword
word
word
byte

o
>

29
30

atpFlags
addrBlock

byte
longword

V-554 Summary of the AppleTalk Manager

async:

BOOLEAN)

User bytes
Transaction ID used in request
Always sendRequest
Socket to send request on
or Current bitmap
Control information
Destination socket address

nN

io)

>

The AppleTalk Manager
~
>
4
>
3
on
oO
on
FUNCTION

34
36
40
44
45
46
47
48

PKillSendReq

>

26

-

FUNCTION

reqLength
= word
reqPointer
pointer
bdsPointer
pointer
numOfBuffs byte
timeOutVal
byte
numOf Resps byte
retryCount
byte
intBuff
word
(thePBptr:

csCode

44

ATPPBPtr;

word

aKillQEl

PKillGetReq

(thePBptr:

csCode
aKallQEl

word
pointer

Name

Binding

Protocol

Functions

PKillNBP

(thePBptr:

ATPPBPtr;

26
28

csCode
nKillQEl

word
pointer

>
>

AppleTalk
FUNCTION

Session

Protocol

ASPOpenSession

BOOLEAN)

:

OSErr;

Pointer to queue element

ATPPBPtr;

26
4

async:

Always PKillSendReq

pointer

>
>

FUNCTION

Dequest size in bytes
Pointer to request data
Pointer to response BDS
Number of responses expected
Timeout interval
Number of responses received
Number of retries
Used internally

async:

BOOLEAN)

:

OSErr;

Always PKillGetReq
§_ Pointer to queue element

async:

BOOLEAN)

: OSErr;

Always PKillINBP
Pointer to queue element

Functions

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

OSErr;

>
—
=
>
>
>>

26
28
30
31
32
36
40

csCode
sessRefnum
aspTimeout
aspRetry
serverAddr
scbPointer
attnRoutine

word
word
byte
byte
long word
pointer
pointer

Always ASPOpenSession
Session reference number
Retry interval in seconds
Number of retries
Server socket address
Pointer to session control block
Pointer to attention routine

Summary of the AppleTalk Manager V-555

=

e.
=,

s
&
ES
c

Inside Macintosh
FUNCTION

ASPCloseSession

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

OSErr;

=
+>

FUNCTION

26
28

csCode
sessRefnum

ASPAbortOS

Always ASPCloseSess

word
word

(xParamBlock:

Session reference number

XPPParmBlkPtr;

async:

BOOLEAN)

Lt

OSErr;

FUNCTION

26
28

csCode
abortSCBPointer

ASPGetParms

word
pointer

(xParamBlock:

Always ASPAbortOS
Pointer to session control block

XPPParmBlkPtr;

async:

BOOLEAN)

OSErr;

>

26

csCode

word

e

a2

numSesss

word

on
<—

FUNCTION

28
30

aspMaxCmdSize
aspQuantumSize

ASPCloseAll

Always ASPGetParms

word
word

(xParamBlock:

Maximum size of command block
Maximum data size
Number of sessions

XPPParmBlkPtr;

async:

BOOLEAN)

L

OSErr;

FUNCTION

26

csCode

word

ASPUserWrite

(xParamBlock:

Always ASPCloseAll
XPPParmBlkPtr;

async:

BOOLEAN)

OSErr;

-

18

>
~

26
28

=

32

=>
~

—

30
34
38

>

40

>

46

on
e

44

50

cmdResult

long word

aspTimeout

byte

csCode
sessRefnum
cbSize

word
word
word

cbPtr

pointer

rbPointer

pointer

wdPtr

pointer

rbSize

wdSize

ccbStart

word
word

record

V-556 Summary of the AppleTalk Manager

ASP command result
Always ASPUserWrite
Session reference number
Retry interval in seconds
Command block size
Command block pointer
Reply buffer size and reply size
Reply buffer pointer
Write data size
Write data pointer
Start of memory for CCB

bo
oO
>

The AppleTalk Manager
FUNCTION

ASPUserCommand

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

TLELLLi47T

OSErr;

TLTLIi1

FUNCTION

General
FUNCTION

18
26
28
30
32
34
38
40
50

cmdResult
csCode
sessRefnum
aspTimeout
cbSize
cbPtr
rbSize
rbPointer
ccbStart

long word
word
word
byte
word
pointer
word
pointer
record

(xParamBlock:

csCode

word

40

rbPointer

pointer

aspTimeout
aspRetry
serverAddr
rbSize
ccbStart

Command

ASP command result
Always ASPUserCommand
Session number
Retry interval in seconds
Command block size
Command block pointer
Reply buffer and reply size
Reply buffer pointer
Start of memory for CCB

XPPParmBlkPtr;

26

50

byte
byte
long word
word

record

async:

BOOLEAN)

Always ASPGetStatus
Retry interval in seconds
Number of retries
Server socket address
Reply buffer and reply size
Reply buffer pointer
Start of memory for CCB

Format

AFPCommand

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

OSErr;

Parameter block

om

18

cmdResult

long word

aspTimeout

byte

>
~

26
28

=)

32

cbSize

38

rbSize

aac
>

o

30

34

~

40

>

46

oO
—

44
50

@

ge

a
~

pS)

ASPGetStatus
OSErr;

30
31
32
38

co
=

csCode
sessRefnum

word
word

word

cbPtr

pointer

rbPtr

pointer

wdPtr

pointer

wdSize

ccbStart

word
word

record

AFP command result
Always AFPCall
Session reference number
Retry interval in seconds
Command buffer size
Command buffer
Reply buffer size and reply size
Reply buffer pointer
Write data size
Write data pointer
Start of memory for CCB

Summary of the AppleTalk Manager V-557

=
i)
72[s7}
Ler

|

Inside Macintosh

Login Command
FUNCTION

Format

AFPCommand

(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

18
26
28

30

31

32

cmdResult
csCode
sessRefnum

aspTimeout

aspRetry

38

cbSize
cbPtr
rbSize

44

afpAddrBlock

rs

TELLLILLL

Ltt

OSErr;

40
48
52

50

rbPtr

afpSCBPtr
afpAttnRoutine

ccbStart

AFPWrite

Command

FUNCTION

AFPCommand

long word
word
word
byte
byte
word
pointer
word
pointer
long word
pointer
pointer
record

AFP command result

Always AFPCall

Session reference number

Retry interval in seconds

Number of retries
Command buffer size
Command buffer

Reply buffer size and reply size
Reply buffer pointer
Server address block

SCB pointer
Attention routine pointer

Start of command control block

Format
(xParamBlock:

XPPParmBlkPtr;

async:

BOOLEAN)

OSErr;
on
—)
>
a>

>
~
coy
~
e
oO
e

18
26
28

cmdResult
csCode
sessRefnum

32
34
38
40
44
46
50

cbSize
cbPtr
rbSize
rbPtr
wdSize
wdPtr
ccbStart

30

LIL

Command

aspTimeout

long word

word
word

byte

word

pointer
word

pointer
word

AFP command result
Always AFPCall
Session number
Retry interval in seconds
Command buffer size
Command buffer
Reply buffer size and reply size
Reply buffer pointer
(used internally)

pointer

record

Write data pointer (updated)
Start of memory for CCB

byte
byte
long word
long word

AFP call command byte
Start/end Flag
Offset within fork to write
Requested count

Block Structure

0
1
4
8

cmdByte
startEndFlag
rwOffset
reqCount

V-558 Summary of the AppleTalk Manager

to
oo
>

5)

The AppleTalk Manager
AFPRead

Command

Format

FUNCTION

AFPCommand

(xParamBlock:

TEL LLbbiT

18
26
28

&

30

34
38
40
50

Command

>
oO
—
aad
~

XPPParmBlkPtr;

long word

cmdResult
csCode
sessRefnum

OSErr;

Always AFPCall

record

Session number
Retry interval in seconds
Command buffer size
Command buffer
Used internally
Reply buffer pointer (updated)
Start of memory for CCB

byte
long word
long word
byte
byte

AFP call command byte
Offset within fork to read
Requested count
Newline Flag
Newline Character

byte

cbSize
cbPtr
rbSize
rbPtr
ccbStart

BOOLEAN):

ASP command result

word
word

aspTimeout

async:

word

pointer
word

pointer

cmdByte
rwOffset
reqCount
newLineFlag
newLineChar

Constants
User

Bytes

aspCmdCode
aspWSSNum

EQU
EQU

aspSessID
aspOpenErr

EQU
EQU

aspVersNum
aspSSSNum

EQU
EQU

aspSeqNum
aspAttnCode

EQU
EQU

Offsets in ATP

data part

NORrRONF©

in

NN

Offsets

©.

<

Block Structure

0
4
8
12
13

gas
=
oS
=

;offset

;WSS
;ASP
;SSS

to

command

field

number in OpenSessions
version number in OpenSessions
number in OpenSessReplies

;session ID
(requests
&OpenSessReply)
;OpenSessReply error code

;sequence number
;attention bytes

aspWrBSize

EQU

0

aspWrHdrSz

EQU

ASPWrBSizet+2

;offset to write
; (WriteData)

;size

of

in
in

requests
attentions

buffer

data

size

part

Summary of the AppleTalk Manager V-559

f5
S
o>
To
e

Inside Macintosh
ASP

command

codes

aspCloseSess

EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU

aspCommand
aspGetStat

aspOpenSess

aspTickle
aspWrite

aspDataWrite

aspAttention
ASP

;close session
;user-command

4
5
6
q
8

;open session
;tickle
;write
jwritedata
(from
attention
(from

$0100

;ASP

3

;get

status

server)
server)

miscellaneous

aspVersion

MaxCmdSize
QuantumSize
XPPLoadedBit
XPPUnitNum

ASP

ul
2

errors

number

command block size
;maximum reply size

ATPLoadedBit+l
;XPP bit in PortBUse
40
junit number for XPP
(old

ROMs)

EQU
EQU
EQU

EQU

EQU
EQU
EQU
EQU
EQU
EQU

-1066
~10:67
-1068
-1069
-1070
~1071
-1L0 72
-1073
-1074
=“1075

;server cannot
support this
;buffer too small
;no more sessions on server
;no servers at that address
;parameter error
;server cannot open another
;session closed

;command

block

too

;too many clients
;no ack on attention

ASP

version

session

big

Request

codes

openSess
closeSess
userCommand
userWrite
getStatus
afpCall
getParms
abortOS
closeAll

version

ATPMaxData
;maximum
ATPMaxData*ATPMaxNum

codes

aspBadVersNum
aspBufTooSmall
aspNoMoreSess
aspNoServers
aspParamErr
aspServerBusy
aspSessClosed
aspSizeErr
aspTooMany
aspNoAck

Control

EQU
EQU
EQU
EQU
EQU

EQU
EQU
EQU
EQU
EQU

EQU
EQU
EQU
EQU

255
254
253
252
Zoi
250
249
248
247

;open session
;close session
juser command
juser write
get
status
;AFP command
(buffer
;get parameters

;abort

;close

V-560 Summary of the AppleTalk Manager

open
all

session

open

has

command

request

sessions

code)

S

oe)

>

<)

The AppleTalk Manager
ASP

area

queue element standard

structure:

arguments

passed

in the CSParam

sessRefnum
aspTimeout

EQU
EQU

$1c
$1E

;offset to session refnum
;timeout
for ATP
[byte]

serverAddr
scbPointer

attnRoutine

EQU
EQU

EQU

$20
$24

$28

;server address block
[longword]
;SCB pointer
[longword]

;attention

cbSize
cbPtr

EQU
EQU

$20
$22

;command
;command

rbPtr
wdSize
wdPtr

EQU
EQU
EQU

$28
$2C
$2E

;reply
;write
;write

aspMaxCmdSize
aspQuantumSize

EQU
EQU

EQU

Sic
$1E

$1F

;for
;for

;SCB

cmdResult

EQU

$12

;command result
; bytes) [long]

afpAddrBlock
afpSCBPtr
afpAttnRoutine

EQU
EQU
EQU

$2C
$30
$34

;address block in AFP login[long]
;SCB pointer in AFP login
[long]
jattn routine pointer in AFP login

scbMemSize

EQU

$CcO

;size

aspRetry

EQU

rbSize

EQU

ecbStart

$26

EQU

abortSCBPtr

AFPCall

$1F

command

afpLogin
afpContLogin
afpLogout
afpRead
afpWrite

$32

;retry

count

for

ATP

routine

block
block

;reply

buffer

;start

of

Te

om

Low

[byte]

[long]

size
[word]
pointer
[long]

size

[word]

buffer pointer
[long]
data size
[word]
data pointer
[long]

memory

SPGetParms
SPGetParms

pointer

of

for

memory

for

CCB

[word]
[word]

AbortOS

(ATP

for

[long]

user

SCB

codes
EQU
EQU
EQU
EQU
EQU

LB:
19;
20;
Zits
33;

Offsets for certain parameters in Read/Write calls
startEndFlag
rwOffset
reqCount
newLineFlag
newLineChar
lastWritten

EQU
EQU
EQU
EQU
EQU
EQU

$1
$4
$8
SC
$D
$0

;write only; offset relative to start or
;offset at which to start read or write
;count of bytes to read or write
;read only; newline character flag
;read only; newline character
;write only; last written
(returned)

end

Miscellaneous
afpUseWrite

EQU

$CO

;first
;

call

ASPWrite

in

range

that

maps

to

©,

sCS
a
=
f

[word]

pointer

it

an

Summary of the AppleTalk Manager V-561

|

Inside Macintosh

Preferred

Interface

Routines

AttachPH

Function

PAttachPH

DetachPH

Function

PDetachPH

WriteLAP

Function

PWriteLAP

OpenSkt

Function

POpenSkt

CloseSkt

Function

PCloseSkt

WriteDDP

Function

PWriteDDP

RegisterName

Function

PRegisterName

LookupName

Function

PLookupName

ConfirmName

Function

PConfirmName

RemoveName

Function

PRemoveName

OpenATPSkt

Function

POpenATPSkt

CloseATPSkt

Function

PCloseATPSkt

SendRequest

Function

PSendRequest

GetRequest

Function

PGetRequest

SendResponse

Function

PSendResponse

AddResponse

Function

PAddResponse

ReLTCB

Function

PRelTCB

RelRspCB

Function

PRelRspCB

SetSelfSend

Function

PSetSelfSend

NSendRequest

Function

PNSendRequest

KillSendReq

Function

PKillSendReq

KillGetReq

Function

Kil1NBP

Function

(thePBptr:
BOOLEAN)

:

MPPPBPtr;
OSErr;

BOOLEAN)

:

OSErr;

BOOLEAN)
(thePBptr:
BOOLEAN)

:

BOOLEAN)
(thePBptr:

:

(thePBptr:
(thePBptr:

(thePBptr:
BOOLEAN)

(thePBptr:
BOOLEAN)

(thePBptr:

MPPPBPtr;

async:

MPPPBPtr;

async:

OSErr;
MPPPBPtr;
: OSErr;

:

:

MPPPBPtr;

OSErr;
MPPPBPtr;
OSErr;

MPPPBPtr;
OSErr;

MPPPBPtr;

BOOLEAN)
(thePBptr:
BOOLEAN)
(thePBptr:
BOOLEAN)
(thePBptr:
BOOLEAN)
(thePBptr:
BOOLEAN)

OSErr;
MPPPBPtr;
: OSErr;
MPPPBPtr;
: OSErr;
ATPPBPtr;
: OSErr;
ATPPBPtr;
: OSErr;

BOOLEAN)
(thePBptr:
BOOLEAN)
(thePBptr:
BOOLEAN)
(thePBptr:
BOOLEAN)
(thePBptr:
BOOLEAN)

:

OSErr;
ATPPBPtr;
: OSErr;
ATPPBPtr;
: OSErr;
ATPPBPtr;
: OSErr;
ATPPBPtr;
: OSErr;

BOOLEAN)

:

BOOLEAN)
(thePBptr:
BOOLEAN)

:

PKillGetReq

BOOLEAN)
(thePBptr:

:

PKil1NBP

(thePBptr:

V-562 Summary of the AppleTalk Manager

(thePBptr:

(thePBptr:

(thePBptr:

(thePBptr:

:

ATPPBPtr;

:

BOOLEAN)

:

async:
async:
async:
async:
async:
async:
async:
async:
async:
async:
async:
async:
async:
async:

ATPPBPtr;

async:

MPPPBPtr;

async:

OSErr;

OSErr;
ATPPBPtr;
: OSErr;

BOOLEAN)

async:

ATPPBPtr;
OSErr;
ATPPBPtr;
OSErr;

MPPPBPtr;
OSErr;

async:
async:
async:
async:

i)

xz
>
—
(=)
—

The AppleTalk Manager
PROCEDURE

BuildLAPwds

destHost,

(wdsPtr,dataPtr:

PROCEDURE

BuildDDPwds

PROCEDURE

NBPSetEntity

PROCEDURE

NBPSetNTE
(ntePtr:
Socket: INTEGER) ;

FUNCTION

NBPExtract

AddrBlock;

DDPType

AddrBlock)

:

INTEGER;

(buffer:
Ptr;

(theBuffer:

VAR

:

abEntity:

OSErr;

FUNCTION

GetBridgeAddress:

FUNCTION

BuildBDS
INTEGER;

Ptr;

-_

Ptr;

dataLen:

destAddress:

INTEGER) ;

nbpObject,nbpType,nbpZone:

nbpObject,nbpType,nbpZone:
Ptr;

numInBuf:

EntityName;

VAR

INTEGER;

address:

Str32;

whichOne:

INTEGER;

(buffPtr,bdsPtr:

Ptr;

—_

as
pa)
—
val
a
—
as

INTEGER) ;

(wdsPtr,headerPtr,dataPtr:

SEXS2).;

INTEGER;

Ptr;

protoType, frameLen:

—_

@

buffSize:

INTEGER)

Summary of the AppleTalk Manager V-563

pom
as
—_

7

@

29 THE
566
567
569

VERTICAL

RETRACE

MANAGER
i)

Changes to the Vertical Retrace Manager
Vertical Retrace Manager Routines
Summary of the Vertical Retrace Manager

S

<
©
=.
°

Lew |

=

~
©-

Lear |

a

oO
@

he

=

i

ge

©
|

V-565

Inside Macintosh

CHANGES

TOTHE

VERTICAL RETRACE

MANAGER

With the advent of slots, a variety of screens are available, each with potentially different

vertical retrace periods. The Vertical Retrace Manager has been extended to provide

flexible, slot-specific video-interrupt handling on the Macintosh II. These changes are
mostly transparent to existing applications.
Several video cards can be installed on a single system.

The user can, at any time,

designate a particular slot as the primary video slot for the system. If at system startup, no
device is designated, the Start Manager selects one (see the Start Manager chapter in this
volume for details).
Instead of maintaining a single vertical retrace queue, the Vertical Retrace Manager now

maintains a separate queue for each connected video device; associated with each queue is

the rate at which the device’s vertical retrace interrupt occurs. When interrupts occur for a
particular video slot, the Vertical Retrace Manager executes any tasks in the queue for that
slot.
For compatibility with existing software, a special system-generated interrupt handles the
execution of tasks previously performed during the vertical retrace interrupt. This special
interrupt, generated 60.15 times a second (identical to the retrace rate on the Macintosh
Plus), mimics the vertical retrace interrupt and ensures that application tasks installed with
the VInstall function, as well as periodic system tasks such as updating the tick count and
checking whether the stack has expanded into the heap, are performed as usual.
You can still use the VInstall function as a way of performing recurrent tasks based on

ticks. Be aware, however, that these tasks will no longer be tied to the actual retrace rate of
the video screen.

To install a task whose execution is tied to the vertical retrace period of a particular video
device, call SlotVInstall using the VBLTask queue element; as before qT ype must be
ORD(vType). The Vertical Retrace Manager interprets the vblCount field in terms of the
rate that the specified slot generates vertical retrace interrupts. On the current Macintosh II
monitors, for instance, the interrupt occurs every 1/67th of a second; specifying a vblICount
of 10 means that the task will be executed every 10/67ths of a second. The value of
vblCount is decremented every 1/67th of a second until it reaches 0, at which point the task

is called. To remove a slot-specific task, call SlotVRemove.

The AttachVBL function is used primarily by the Start Manager and Control Panel for
designating the primary video device; only applications that shift between multiple video
cards will need to call this routine.
Slot interrupt handlers for video cards need to call the DoVBLTask function; this causes the
Vertical Retrace Manager to execute any tasks in the queue for that slot.

V-566 Vertical Retrace Manager Routines

The Vertical Retrace Manager

VERTICAL
Function

RETRACE

AttachVBL

MANAGER

(theSlot:

ROUTINES

INTEGER)

:

OSErr;
nN

=)

<

Trap macro

_Attach VBL

@

On entry

DO:

theSlot (word)

a

On exit

DO:

result code (word)

=ae
~

@is

=

m
oO
@

Attach VBL makes theSlot the primary video slot, allowing correct cursor updating.
Result codes

Function

noErr
slotNumErr

SlotVInstall

No error
Invalid slot number

(vblTaskPtr:

QElemPtr;

_SlotVInstall

On entry

AO:

vblTaskPtr (pointer)

On exit

DO:

result code (word)

DO:

theSlot:

INTEGER)

theSlot (word)

SlotV Install is identical in function to the VInstall function except that it installs the task in
the queue for the device specified by theSlot.
Result codes

Function

noErr

No error

SlotVRemove

(vblTaskPtr:

vTypErr
slotNumErr

OSExrr;

Invalid queue element
_Invalid slot number

Trap macro

_SlotVRemove

On entry

AO: vblTaskPtr (pointer)
DO:

theSlot (word)

On exit

DO:

result code (word)

QElemPtr;

me
=
=
ge
a
Lew

OSErr;

Trap macro

<

theSlot:

INTEGER)

Vertical Retrace Manager Routines V-567

|

Inside Macintosh

SlotVRemove is identical in function to the VRemove function except that it removes the
task from the queue for the slot specified by theSlot.
Result codes

Function

noErr

vTypErr
slotNumErr

DoVBLTask

No error

Invalid queue element
Invalid slot number

(theSlot:

INTEGER)

Trap macro

_DoVBLTask

On entry

DO:

theSlot (word)

On exit

DO:

result code (word)

:

OSErr;

Note: To reduce overhead at interrupt time, instead of executing the LDoVBLTask
trap you can load the jump vector jDoVBLTask into an address register and execute a
JSR instruction using that register.
DoVBLtTask causes any VBL tasks in the queue for the specified slot to be executed. If the
specified slot is the primary video slot, the position of the cursor will also be updated.
Result codes

noErr
slotNumErr

No error
Invalid slot number

V-568 Vertical Retrace Manager Routines

The

SUMMARY

OF THE VERTICAL

RETRACE

Vertical Retrace Manager

MANAGER

Routines
FUNCTION

FUNCTION
FUNCTION
FUNCTION

tw
=)

AttachVBL

SlotVInstall
SlotVRemove

DoVBLTask

Assembly-Language

(theSlot:

INTEGER)

(vblTaskPtr:
OSErr;

:

QElemPtr;

OSErr;

theSlot:

(vblTaskPtr:
QElemPtr;
theSlot:
OSErr;
(theSlot:
INTEGER)
: OSErr;

<

INTEGER)
INTEGER)

a")
asl

=.

¢)

at
~

oO
=

= |

ba)
er)
@

a)
=
i)
ge

Information

©

Routines
Trap macro

On entry

On

exit

_Attach VBL

DO: theSlot (word)

DO:

result code (word)

_SlotVInstall

AO:

DO: result code (word)

_SlotVRemove

AO: vblTaskPtr (pointer)
DO:

theSlot (word)

DO:

result code (word)

_DoVBLTask

DO:

theSlot (word)

DO:

result code (word)

DO:

vblTaskPtr (pointer)
theSlot (word)

Variables
jDoVBLTask

= Jump vector for DoVBLTask routine

Summary of the Vertical Retrace Manager V-569

30 THE
572
572

SYSTEM

ERROR

HANDLER

New Error Codes
Assembly-Language Information

oS)
S
N

iS

”

-

(a2)

=|
—

icy
+
=

i)

or

V-571

Inside Macintosh

NEW

ERROR

CODES

The following new error codes may be reported by the procedure SysError:
ID

Explanation

31
33
84

Not the requested disk
Negative ZcbFree value
A menu has been purged

Assembly-Language

Information

Constants
dsNotThel

EQU

31

33

;ZcbFree

menuPrgErr

EQU

84

;happens

negZcbFreeErr

EQU

V-572 New Error Codes

;not

the

requested

is

negative

when

a

disk

menu

is

purged

31
574
574
574
575
576
576
577
582
583

THE SCSI MANAGER
Changes to the SCSI Manager

Using the SCSI Manager
SCSI Manager Routines
Transfer Modes
Disk Partitioning
Drive Descriptor Map
Partition Map
Partitioning Guidelines
Summary of the SCSI Manager

)

—

2)

OQ

2)
—

$9
=
f>
ge
io)

Lr |

V-573

Inside Macintosh

CHANGES

TOTHE

SCSI MANAGER

On the Macintosh SE and Macintosh II, the SCSIRBlind and SCSIWBlind functions have

hardware support; this ensures that they will work reliably with most third-party SCSI

drives.

Warning: SCSI drivers that jump directly to the ROM will crash on any machine
other than a Macintosh Plus.
Three new routines support the message phases of the SCSI standard.
Several new result codes have been defined:
u If arbitration fails because the bus is busy during the SCSIGet function, the result code
scArbNBErr is returned. If the SCSI Manager is busy with another operation when
SCSIGet is called, the result code scMgrBusyErr is returned.

u If the data doesn’t come ready within the bus timeout period during the SCSIRBlind
and SCSIWBlind functions, the result code scBusTOErr is returned.

u If the bus is not in the Status phase during the SCSIComplete function, the result code
scComp!PhaseErr is returned (indicating either that filler bytes were written or bytes
were read and lost).
= If an attempted operation is out of sequence (calling SCSISelect without first calling
SCSIGet, for instance), the result code scSequenceErr is returned.

USING

THE SCSI MANAGER

Three new routines support the message phase of the SCSI standard. SCSISelAtn lets you
select a device, alerting the device that you want to send a message. SCSIMsgOut sends a
message byte to the device, and SCSIMsgIn receives a message byte from the device.

SCSI MANAGER

ROUTINES

Assembly-language note: Unlike most other Operating System routines, the
SCSI Manager routines are stack-based. You can invoke each of the SCSI routines
with a macro that has the same name as the routine preceded by an underscore.
These macros, however, aren’t trap macros themselves; instead they expand to
invoke the trap macro _SCSIDispatch. The SCSI Manager determines which routine
to execute from the routine selector, an integer that’s passed to it in a word on the
stack. The routine selectors for the new routines are as follows:

V-574 SCSI Manager Routines

The SCSI Manager
scsiSelAtn

scsiMsgin

. EQU

11

. EQU

13

-EQU

scsiMsgOut

12

If you specify a routine selector that’s not defined, the System Error Handler is called
with the system error ID dsCoreErr.

FUNCTION

SCSISelAtn

(targetID:

INTEGER)

:

OSErr;

SCSISelAtn is identical in function to SCSISelect except that it asserts the Attention line
during selection, signaling that you want to send a message to the device.
FUNCTION

SCSIMsgIin

(VAR

message:

INTEGER)

:

OSErr;

SCSIMsglIn gets a message from the device. The message is contained in the low-order
byte of the message parameter; message values are listed in the ANSI documentation for

SCSI.

SCSIMsgIn leaves the Attention line undisturbed if it’s already asserted upon entry.
FUNCTION

SCSIMsgOut

(message:

INTEGER)

:

OSErr;

SCSIMsgOut sends a message byte to the target device; message values are listed in the
ANSI documentation for SCSI.

Ue
—

7 2)

2)
2)
—

TRANSFER

MODES

The Macintosh Plus SCSI Manager implements two transfer modes:

pS)
|
mS
t=

polled and blind. The

polled mode checks the DRQ signal on the 5380 SCSI chip before each byte is transferred

(on both read and write operations). While slower than blind mode, the polled mode is
completely safe since the SCSI Manager will wait indefinitely for each byte sent to or from
the peripheral.
The blind mode does not poll the DRQ line and is therefore about 50% faster. Use of this
mode imposes certain timing constraints, however, making it unreliable for some
peripherals. Once a transfer is underway, if the peripheral’s controller cannot send (or
receive) a byte every 2 microseconds, the SCSI Manager may either read invalid data or
write data faster than the peripheral can accept it, resulting in the loss of data.
Programmers writing SCSI device drivers must be familiar with the limits of their
peripherals. If the peripheral has internal interrupts, for instance, or if it has processing
overhead at unpredictable points within a block transfer, the blind mode should not be
used.

Transfer Modes V-575

@

=y

Inside Macintosh

Note: If the peripheral has a regular pause at a specific byte number within a block,
it’s possible to use a transfer information block containing two or more data transfer
pseudoinstructions. Since the SCSI Manager will handshake the first byte at the
beginning of each data transfer operation, this can be used to synchronize with the
peripheral’s internal processing.
The Macintosh SE and Macintosh II have additional hardware support for SCSI data
transfers. For compatibility, the faster transfer routines are still called SCSIRBlind and

SCSIWBlind; these routines do, however, take advantage of the hardware handshaking

available on the new machines. Use of the hardware handshake, however, imposes other
timing constraints. If the time between any two bytes in a data transfer exceeds a certain
period—between 265 and 284 milliseconds on the Macintosh SE and approximately 16
microseconds on the Macintosh II—a CPU bus error is generated. If your peripheral

cannot meet this constraint, you should use the polled mode calls, SCSIRead and
SCSIWrite.

DISK PARTITIONING
The SCSI Manager chapter of Volume IV introduces the subject of booting from SCSI
devices. It presents two data structures needed in the first two physical blocks of the
device. The first data structure, the driver descriptor map, identifies the various device
drivers available for loading. The second structure, the device partition map, presents a
scheme for describing the allocation, or partitioning, of the blocks of a device between
multiple operating systems.
The driver descriptor map is unchanged. In order to support multiple operating systems on
a single disk, however, the device partition map has been redesigned. The old partition
map format is still supported, but developers are encouraged to adopt the new format (see
below).

Driver

Descriptor

Map

A driver descriptor map must always be located at the start of physical block 0; its format is
given in Figure 1.

V-576 Disk Partitioning

The

fs

sbSig (word)

always $4552

sbBlockSize (word)

block size of device

sbBlkCount

(long word)}

number of blocks on device

sbDevType

(word)

used

internally

sbDevID (word)

used internally

sbData (long word)

used

sbDrvrCount (word)

number of driver descriptors

ddBlock (long word)

first block of driver

ddSize (word)

driver size in blocks

ddType (word)

system type (1 for Macintosh)

f

ome
descriptor

SCSI Manager

ls

internally

Figure 1. Driver Descriptor Map
SBSig contains the signature; it’s used to verify that the block is valid (that is, the disk has

been formatted) and should always be $4552.

SBDrvrCount specifies the number of drivers that may be used for this disk; more than one
driver may be needed when multiple operating systems or processors are supported.
There must be a driver descriptor for each driver on the device (as well as a partition map
entry, as explained below). DDBlock is the address of the first physical block of the driver
code. DDSize contains the size of the driver in blocks. DDType identifies the operating
system or processor supported by the driver. The Macintosh Operating System has the
value 1; values 0 through 15 are reserved for use by Apple.
To specify a particular operating system for use at system startup, you’ll need to call the
Start Manager routine SetOSDefault using the same value in ddType (see the Start Manager
chapter in this volume).

Partition

Map

For the purposes of this discussion, a partition is simply a series of blocks that have been
allocated to a particular operating system, file system, or device driver. (Another way to
look at it is that a single physical disk is divided into a number of logical disks.) The
partition map organizes, or maps, this allocation of the physical blocks of a disk. It is
strongly recommended that all operating systems that run on the Macintosh II use and
support the partition map presented here. This will ensure the peaceful coexistence and

Disk Partitioning V-577

Inside Macintosh

operation of different operating systems on a single disk, and will enable the transfer of
files between partitions.
To support the variety of disk types and sizes that can be attached to the Macintosh II, you
should either allow for a variable number of partitions (to be determined at disk
initialization), or allocate a large number (greater than 100) of fixed partition slots.

With the exception of physical block zero, every block on a disk must be accounted for as
belonging to a partition.
The partition map contains a number of physical blocks (as mentioned above, the old

device partition map, located at physical block 1, has become logical block 0 of the partition
map). For each partition on a disk, the partition map has one block that describes the
partition. The partition map is itself a partition and contains a partition map entry
describing itself. Figure 2 gives an example of a partitioned disk.

driver descriptor map

partition map partition

partition map entry (driver)
partition map entry (A/UX)
partition map entry (partition map)

SS
partition map entry (Mac OS)

A/UX partition

S

"

Mac OS partition

<

S

other partitions

S

.

driver partition

4

Figure 2. An Example of Disk Partitioning

V-578 Disk Partitioning

The SCSI Manager
The information about a partition is contained in a partition map entry; it’s shown in

Figure 3.

byte 0

pmSig (word)

always $504D

2

pmSigPad (word)

reserved for future use

4

pmMapBIkCnt

number of blocks in map

(long word)

pmPyPartStart (long word)

first physical block of partition

pmPertBlkCnt

(long word)

number of blocks in partition

pmPartName

(32 bytes)

partition name

30

pmPartType

(32 bytes)

partition type

50

pmLgDataStart

°4

pmDataCnt

98

pmPartStatus

SC

pmLgBootStart

60

pmBootSize (long word)

size in bytes of boot code

64

pmBootLoad

(long word)

boot code load address

68

pmBootLoad2

(long word)

additional boot load information

6C

pmBootEntry

(long word)

boot code entry point

70

pmBootEntry2

(long word)

additional boot entry information

74

pmBootCksum

(long word)

boot code checksum

78

pmProcessor (16 bytes)

88

(128 bytes)

(long word)

(long word)
(long word)
(long word)

first logical block of data area
number of blocks in data area
partiton status information
first logical block of boot code

processor type

boot-specific arguments

Figure 3. Partition Map Entry
The information in the fields marked with asterisks is used and expected by the Start
Manager. The other fields may or may not be currently used; they’ve been defined to
provide a convenient and standard way of storing information specific to your driver or
operating system. To permit communication between partitions, it’s recommended that you
use these fields as described below.

Disk Partitioning V-579

oe
—

M

OQ

72)
—

7
=

te)

ga
@

=

Inside Macintosh

PMSig should always contain $504D to identify the block as containing a partition map
entry. (The old partition map format, with a signature of $5453, is still supported but is
discouraged.)

PMMapBlkCnt should contain the size in blocks of the partition map. The partition map

entry for the partition map is not necessarily the first entry in the map. The number of
blocks in the partition map is maintained in each entry, so that you can determine the size of
the partition map from any entry in the map.
PMPyPartStart should give the physical block number of the first block of the partition and

pmPartBlkCnt should contain the number of blocks in the partition.

PMPartName and pmPartType are both ASCII strings of 1 to 32 bytes in length; case is not
significant. If either name is less than 32 characters long, it must be terminated by the
NUL character (ASCII code 0). You can specify an empty name or type by setting the first
byte to the NUL character.
PMPartName is similar to the handwritten label on a floppy disk; you can use this field to
store a user-defined name (which may or may not be the same name used by the operating
system).

PMPartType should indicate the operating system or driver using the partition. Types
beginning with the string Apple_name are reserved by Apple; the following standard types
have been defined:
Type

Meaning

Apple_MFS

Apple_HFS

Flat file system (64K ROM)

Hierarchical file system (128K ROM and later)

Apple_Unix_SVR2 _— Partition for UNIX
Apple_partition_map
Partition containing partition map

Apple_Driver

Apple_PRODOS
Apple_Free
Apple_Scratch

Partition contains a device driver

Partition designated for an Apple IIGS
Partition unused and available for assignment
Partition empty and free for use

Programmers who wish to take advantage of a checksum verification performed by the
Start Manager should give a partition type of Apple_Driver and a partition name beginning
with the letters “MACTI” (for Macintosh). PMBootSize must contain the size in bytes of the
Pet ati while pmBootChecksum the checksum for that code, using the following

gorithm:

DoCksum

CkLoop

moveq.l1

moveq.l1
bra.s

+#0,D0

#0,D7
CkDecr

;initialize

move .b
add.w
rol.w

(AO0)+,D7
D7,D0
#1,D0

;get
jadd
j;and

V-580 Disk Partitioning

sum

register

;zero-extended byte
;handle 0 bytes
a byte
to checksum
rotate

The SCSI Manager
CkDecr

dbra
tst.w

bne.s
subq.w

@1

D1,CkLoop
DO

@1
#1,D0

;next byte
;convert a

;
;

into

SFFFF

checksum

of

0

With some operating systems—for instance Apple’s A/UX™ operating system—the file
system may not begin at logical block 0 of the partition. You should use pmLgDataStart to
store the logical block number of the first block containing the file system data and
pmDataCnt to specify the size in blocks of that data area.
The low-order byte of pmPartStatus (currently used only by A/UX) contains status
information about the partition, as follows:

SANKRWNK ©

Bit

Meaning
Set if a valid partition map entry

Set if partition is already allocated; clear if available
Set if partition is in use; might be cleared after a system reset
Set if partition contains valid boot information
Set if partition allows reading

Set if partition allows writing

Set if boot code is position independent
Free for your use

The high-order byte of pmPartStatus is reserved for future use.
PMLgBootStart specifies the logical block number of the first block containing boot code.
PMBootLoad specifies the memory address where the boot code is to be loaded;
pmBootLoad2 contains additional load information.
PMBootEntry specifies the memory address to which the boot code will jump after being
loaded into memory; pmBootEntry2 contains additional information about this address.
PMProcessor identifies the type of processor that will execute the boot code. It’s an ASCII
string of 1 to 16 bytes in length; case is not significant. If the type is less than 16
characters long, it must be terminated by the NUL character (ASCII code 0). You can
specify an empty processor type by setting the first byte to the NUL character. The
following processor types have been defined:
68000
68008
68010
68012
68020

Disk Partitioning V-581

eo)
—
NM

CQ
ZN

Sia

=
|
fi
ye
oO
bee

|

Inside Macintosh

Partitioning

Guidelines

Developers writing disk partitioning (or repartitioning) programs should remember the

following basic guidelines:

u Every block on a disk, with the exception of physical block 0, must belong
partition. Unused blocks are given the partition type Apple_Free.

to a

m Every partition must have a partition map entry describing it. Remember that the

partition map is itself a partition, with a partition map entry describing it. Partition
map entries can be in any particular order, and need not correspond to the order in
which the partitions they describe are located on the disk.

u Each device driver must be placed in its own partition (as opposed to being in the
partition of the operating system associated with it). This simplifies the updating of
the driver descriptor map when the driver is moved.
u Repartitioning of a disk is a two-step process where existing partitions must be

combined to form new partitions. The existing partitions to be combined must first be
marked as type Apple_Free.

As part of freeing a partition, you must set to zero the

first eight blocks (copying the contents of the partition somewhere else) to ensure that
the partition is not mistaken for an occupied partition. Once freed, the existing
partitions can be combined with adjacent free partitions to make a single, larger

partition.

= If, as a result of repartitioning, the partition map needs additional room, the other

existing partitions can be shifted towards the “end” of the disk. The partition map is
the only partition that can be extended without first destroying its contents.

V-582 Disk Partitioning

The SCSI Manager

SUMMARY

OF THE

SCSI MANAGER

Routines
FUNCTION

SCSISelAtn

FUNCTION

FUNCTION

Result

(targetID:

SCSIMsgin

INTEGER)

: OSErr;

(VAR message:
INTEGER)
: OSErr;
(message:
INTEGER)
: OSErr;

SCSIMsgOut

Codes

Name

Value

Meaning

scArbNBErr
scBusTOErr

3
9

Arbitration failed during SCSIGet; bus busy

scComp!|PhaseErr
scMgrBusyErr

10
7

SCSIComplete failed; bus not in Status phase

scSequenceErr

8

Bus timeout before data ready on SCSIRBlind and
SCSIWBlind
SCSI Manager busy with another operation when SCSIGet
was called
Attempted operation is out of sequence; e.g., calling
SCSISelect before doing SCSIGet

Assembly-Language

Information

oe)

pom

17 2)

©)

MN

Constants
;

;

Routine

(Note:

; macro
;

—

selectors

You

that

underscore.)

scsiSelAtn
scsiMsgIin

scsiMsgOut

Structure

can

has

invoke

the

-EQU
-EQU

-EQU

of Driver

same

each

name

of

as

the

the

SCSI

by

with

an

a

13

Descriptor

Map

Always $4552 (word)

sbBlkCount
sbDevType
sbDevID
sbData

Number of blocks on device (long)
Used internally (word)
Used internally (word)
Used internally (long)

sbDrvrCount

routines

preceded

11
12

sbSig

sbBlockSize

Manager

routine

Block size of device (word)

Number of driver descriptors (word)

Summary of the SCSI Manager V-583

ee)
i}
i)
ge
@o
be

|

Inside Macintosh

Driver

Descriptor

First block of driver (long)

ddBlock
ddSize
ddType

Structure

Structure

Driver size in blocks (word)

System type; 1 for Macintosh

of Partition

Map

Entry

pmSig
pmSigPad
pmMapBlkCnt
pmPyPartStart

Always $504D (or $5453 for old format) (word)
Reserved for future use (word)
Number of blocks in partition map (long)
First physical block of partition (long)
pmPartBlkCnt
Number of blocks in partition (long)
pmPartName
Partition name (1—32 bytes)
pmPartType
Partition type (1-32 bytes)
First logical block of data area (long)
pmLgDataStart
Number of blocks in data area (long)
pmDataCnt
pmPartStatus
Partition status information (long)
First logical block of boot code (long)
pmLgBootStart
Size in bytes of boot code (long)
pmBootSize
Boot code load address (long)
pmBootLoad
Additional boot load information (long)
pmBootLoad2
Boot code entry point (long)
pmBootEntry
Additional boot code entry information (long)
pmBootEntry2
pmBootCksum
Optional checksum (long)
pmProcessor
Processor type (1-16 bytes)
Additional boot-specific arguments (128 bytes)

V-584 Summary of the SCSI Manager

32 THE
588
588
588
589

591

SHUTDOWN

MANAGER

About This Chapter
About the Shutdown Manager
Using the Shutdown Manager
Shutdown Manager Routines

Summary of the Shutdown Manager

Ge

NS)
2
=

=
2.
i)

=

=

=

&
=

$9
©
=

ge

V-585

Inside Macintosh

ABOUT

THIS CHAPTER

This chapter describes the Shutdown Manager, which gives applications a chance to

perform any necessary housekeeping before the machine is rebooted or turned off. The
Shutdown Manager also provides the user with a consistent interface for restarting and

turning off the different versions of the Macintosh.

ABOUT

THE SHUTDOWN

MANAGER

With earlier versions of the System file, the Shut Down (a misnomer) menu item in the
Special menu resulted in the restarting of the machine. There was no way to turn the
machine off from software; the user needed to choose Shut Down and manually toggle the
power switch before the machine had begun to reboot.
On the Macintosh II, two options are available:

the Restart menu item results in a reboot,

while the Shut Down menu item actually turns off power to the machine.

The Macintosh SE does not have power-off capability from software. When the user
chooses Restart, the machine is rebooted.

When the user chooses Shut Down, the

Shutdown Manager blackens the screen and calls the System Error Handler with an error
code of 42. This causes an alert to be presented, telling the user it’s safe to turn off the
machine.
The Shutdown Manager is contained in the System Resource File (System file version 3.3

or later) and is compatible with all earlier versions of the Macintosh. If the Shutdown
Manager is present and the user chooses Restart, the machine is rebooted.

On all earlier

machines (with the exception of the Macintosh XL), if the user chooses Shut Down, the
Shutdown alert is presented. On the Macintosh XL, Shut Down fades the screen and turns

off the power.

USING

THE SHUTDOWN

MANAGER

The ShutDwnPower procedure turns the machine off; if the Macintosh must be turned off
manually, the Shutdown alert is presented to the user. The ShutDwnStart procedure causes
the machine to reboot.
Warning:

ShutDwnPower and ShutDwnStart are used by the Finder and other

system software; your application should have no need to call these two routines.

Both ShutDwnPower and ShutDwnStart check to see if Switcher is running; if it is, the

ExitToShell procedure is called, exiting Switcher and returning control to the Finder.
Otherwise, they perform standard system housekeeping prior to reboot or power off; this
housekeeping can be divided into two phases. In the first phase, the unit table is searched

V-586 Using the Shutdown Manager

The Shutdown Manager

for open drivers (including desk accessories). For each driver, if the dNeedGoodbye bit in

the drvrFlags field is set (see chapter 6 of Volume II for details), a Control call with csCode

equal to —1 is sent to the driver’s control routine. Then, the UnloadScrap function is
called, writing the desk scrap to the disk.

Note: While the Finder does not currently read the scrap at boot time, it may do so
in the future.
In the second phase of housekeeping, the volume-control-block queue is searched; for each
mounted volume, the UnmountVol and Eject routines are called.

The ShutDwnlInstall procedure lets you install your own shutdown procedure(s) prior to

either of these two system housekeeping phases, as well as just prior to rebooting and/or
power off. The ShutDwnRemove procedure lets you remove your shutdown procedures.

SHUTDOWN

MANAGER

ROUTINES

sdPowerOff
sdRestart
sdiInstall
sdRemove

PROCEDURE

.EQU
.EQU
.EQU
. EQU

Dm WN EF

Assembly-language note: You can invoke each of the Shutdown Manager
routines with a macro that has the same name as the routine preceded by an
underscore. These macros expand to invoke the _Shutdown trap macro. The
_Shutdown trap determines which routine to execute from a routine selector, an
integer that’s passed to it in a word on the stack. The routine selectors are as
follows:

ShutDwnPower;

.o*)
nN

ShutDwnPower performs system housekeeping, executes any shutdown procedures you
may have installed with ShutDwniInstall, and turns the machine off. (If the machine must
be turned off manually, the shutdown alert is presented.)

/N
—
=

—_

2.
©

=

~

<
omen

PROCEDURE

po)
=)
£9
itj=)

ShutDwnStart;

ShutDwnPower performs system housekeeping, executes any shutdown procedures you
may have installed with ShutDwnInstall, and reboots the machine.

Shutdown Manager Routines V-587

(

Loy |

Inside Macintosh

Assembly-language note:

ShutDwnStart results in the execution of the Reset

instruction, followed by a jump to the ROM boot code (the address is the value of the
global variable ROMBase + 10).

PROCEDURE

ShutDwnInstall

(shutDwnProc:

ProcPtr;

flags:

INTEGER) ;

ShutDwnInstall installs the shutdown procedure pointed to by shutDwnProc. The flags
parameter indicates where in the shutdown process to execute your shutdown procedure.

The following masks are provided for setting the bits of the flags parameter:
CONST

sdOnPowerOff
sdOnRestart
sdOnUnmount

sdOnDrivers

=
=
=

=

1;
2;
4;

8;

sdRestartOrPower=

{call
{call
{call

{call

ShutDwnRemove

procedure

{ drivers}
sdOnPowerOff +

{ procedure
{

PROCEDURE

procedure
procedure
procedure

restart}

(shutDwnProc:

before
before
before

before

sdOnRestart

before

power off}
restart}
unmounting}

closing

either

{call

power

}

}

off

ProcPtr) ;

ShutDwnRemove removes the shutdown procedure pointed to by shutDwnProc.
Note: If the procedure was marked for execution at a number of points in the
shutdown process (say, for instance, at unmounting, restart, and power off), it will
be removed at all points.

V-588 Shutdown Manager Routines

or

}

The Shutdown Manager

SUMMARY

OF THE SHUTDOWN

MANAGER

Constants
CONST

{

Masks

for

ShutDwnInstall

1 ;
2
4
8 ;

sdOnPowerOff
sdOnRestart
sdOnUnmount
sdOnDrivers

,
,

procedure

{call

{call

{call
{call

procedure

before

power

procedure
procedure

before
before

unmounting}
closing }

procedure

{ drivers}
sdOnPowerOff +

sdRestartOrPower

{ procedure
{

}

restart}

before

sdOnRestart;

before

off}

restart}

{call

either

}

power

off

or

}

Routines
PROCEDURE

ShutDwnPower;

PROCEDURE

ShutDwnStart;

PROCEDURE

ShutDwnInstall

PROCEDURE

ShutDwnRemove

Assembly-Language

(shutDwnProc:
(shutDwnProc:

ProcPtr;
ProcPtr);

flags:

INTEGER);

Information

Constants
; Masks

for

ShutDwnInstall

sdOnPowerOff
sdOnRestart
sdOnUnmount
sdOnDrivers

sdRestartOrPower

>

Routine

(Note:
a macro

.EQU

selectors

You can invoke each of
that has the same name

underscore.)

sdPowerOff
sdRestart
sdiInstall
sdRemove

;call procedure before power off
1
;call procedure before restart
2
;call procedure before unmounting
4
;call procedure before closing drivers
8
;call procedure
s dOnPowerOff + sdOnRestart
; before either power off or restart

.EQU
.EQU
. EQU
. EQU

the Shutdown Manager routines
as the routine preceded by an

with

a)
NS
an
=%
=
.
°
=
=
-

=Sy)

=
69
ge
@

“

Pm WNE

;
;

-EQU
.EQU
.EQU
.EQU

procedure

Summary of the Shutdown Manager V-589

Inside Macintosh

Trap

Macro

Name

_Shutdown
(Note: You can invoke each of the Shutdown Manager routines with a macro that has the
same name as the routine preceded by an underscore. Also, be aware that the _Shutdown
macro is not in ROM.)

V-590 Summary of the Shutdown Manager

33
592

592
594

THE

OPERATING

SYSTEM

UTILITIES

Changes to the Operating System Utilities

Operating System Utility Routines
Summary of the Operating System Utilities

a)
Ge
2)
n
eS

et:
=
is")
~”

V-59]

Inside Macintosh

CHANGES

TO THE OPERATING

SYSTEM

UTILITIES

When the Sound Manager is installed, the SysBeep procedure causes the alert sound setting
specified in the Control Panel to be played. The duration parameter is ignored.
Existing Macintosh applications operate in a 24-bit addressing mode. For access to slot
card devices, the Macintosh II also supports the full 32-bit addressing capability of the
MC68020. Two new routines, GettMMUMode and SwapMMUMode, let you determine,
change, and restore the addressing mode, using the following constants:
CONST

false32b
true32b

0;
1;

{24-bit
{32-bit

addressing
addressing

mode}
mode}

The Start Manager puts the system in 24-bit addressing mode by default.

The 32-bit addressing mode is provided primarily so that drivers can gain full slot-card
access.

Be aware, however, that you cannot use the Memory Manager when in this mode,

and that some Toolbox routines may not function properly.
function properly in either mode.)

(Interrupt handlers will

Warning: To be compatible with future versions of the Macintosh, you should not
depend on 24-bit addressing mode.
A new routine, StripAddress, will mask the high-order byte of an address when in 24-bit

addressing mode, but will do nothing if 32-bit mode is in effect.

OPERATING
FUNCTION

SYSTEM

GetMMUMode

UTILITY ROUTINES

(VAR mode:

INTEGER);

[Notin ROM]

GetMMUMode returns the address translation mode currently in use.
Assembly-language note: Assembly-language programmers can determine the
current address mode by testing the contents of the global variable MMU32Bit; it’s
TRUE if 32-bit mode is in effect.

V-592 Operating System Utility Routines

The Operating System Utilities
PROCEDURE

SwapMMUMode

(VAR

mode:

Trap macro

_SwapMMUMode

On entry

DO: mode (byte)

On exit

DO: mode (byte)

Byte);

SwapMMUMode sets the address translation mode to that specified by the mode parameter.
The mode in use prior to the call is returned in mode, and can be restored with another call
to SwapMMUMode.
FUNCTION

StripAddress

(theAddress:

LONGINT)

Trap macro

_StripAddress

On entry

DO: theAddress (long word)

On exit

DO: function result (long word)

:

LONGINT;

If the system is running in 24-bit addressing mode, StripAddress is identical in function to
the global variable Lo3Bytes: it returns the value of the low-order three bytes of the
address passed in theAddress. If the system is in 32-bit mode, however, StripAddress

simply passes back the address unchanged.

te
os
~
~
ie 2)

Ce
aes
=

@
i 2)

Operating System Utility Routines V-593

Inside Macintosh

SUMMARY

OF THE OPERATING SYSTEM

UTILITIES

Constants
CONST

{

Addressing
false32b

=

true32b

modes
0;

=

}

{24-bit

1;

addressing

{32-bit

addressing

mode}

mode}

Routines
PROCEDURE
PROCEDURE
FUNCTION

GetMMUMode
SwapMMUMode
StripAddress

Assembly-Language

(VAR mode:
Byte);
(VAR mode:
Byte);
(theAddress:
LONGINT)

:

LONGINT;

Information

Routines
Trap macro

On entry

On

exit

_SwapMMUMode

D0: mode (byte)

DO: mode (byte)

_StripAddress

DO: the Address (long)

D0:

function result (long)

Constants
;

Addressing

false32b

true32b

modes

.EQU

-EQU

0

1

;24-bit

;32-bit

addressing

addressing

Variables
MMU32Bit

Current address mode (byte)

V-594 Summary of the Operating System Utilities

mode

mode

io)
en

=

i)

te

=.
=

ge

~~

2
=

34 THE FLOATING-POINT ARITHMETIC
TRANSCENDENTAL
FUNCTIONS
PACKAGES

AND

>

ox}
me

7

=aa

@®

=.
or)

The Floating-Point Arithmetic and Transcendental Functions packages have been extended
to take advantage of the MC68881 coprocessor. Using the routines in these packages
(described fully in the Apple Numerics Manual) will ensure compatibility on all past and
future versions of the Macintosh; in addition, when the 68881 is present, floating-point
performance will be improved, on average, by a factor of 7 or 8 over the Macintosh Plus.
While taking advantage of the speed of the 68881, the precision of the routines in both
packages has been preserved.
Warning:

—s

Certain highly-specialized applications will want to access the 68881

directly; be aware, however, that doing this virtually ensures that your application

will not function on other, past and perhaps future, versions of the Macintosh.
Moreover, the transcendental functions provided by the 68881 are actually less
precise than the corresponding functions in the Transcendental Functions package.

To promote long word alignment of operands, the 68881 stores its extended type in a 96bit format, putting 16 bits of filler between the 16-bit sign/exponent and the 64-bit
significand. These 16 filler bits make the mixing of SANE calls and direct access of the
68881 a tricky business.

V-595

APPENDIX

A:

RESULT

CODES

This appendix lists all the new result codes returned by the Macintosh system software.
They’re ordered by value, for convenience when debugging; the names you should actually
use in your program are also listed.
The result codes are grouped roughly according to the lowest level at which the error may
occur. This doesn’t mean that only routines at that level may cause those errors; higherlevel software may yield the same result codes. For example, an Operating System Utility
routine that calls the Memory Manager may return one of the Memory Manager result
codes. Where a different or more specific meaning is appropriate in a different context, that

meaning is also listed.
Value

Name

Meaning

SCSI Manager Errors
2
3
4
5
6

scCommErr
scArbNBErr
scBadparmsErr
scPhaseErr
scCompareErr

7

scMgrBusyErr

8

scSequenceErr

9

scBusTOErr

10

scComp|PhaseErr

Communications error (operations timeout)

Arbitration failed during SCSIGet; bus busy

Bad parameter or TIB opcode
SCSI bus not in correct phase for attempted operation
SCSI Manager busy with another operation when
SCSIGet was called
SCSI Manager busy with another operation when
SCSIGet was called
Attempted operation is out of sequence; e.g., calling
SCSISelect before doing SCSIGet
Bus timeout before data ready on SCSIRBlind and
SCSIWBlind
SCSIComplete failed; bus not in Status phase

System Error Handler Errors
31
33
84

dsNotThe1
negZcbFreeErr
menuPrgErr

Not the requested disk
ZcbFree is negative
Happens when a menu is purged

Sound Manager Errors
—200

—201
—203

—204
—205
—206

noHardware

notEnoughHardware
queueFull
resProblem
badChannel
badFormat

No hardware support for the specified synthesizer
No more channels for the specified synthesizer
No room in the queue
Problem loading resource
Invalid channel queue length
Handle to 'snd ' resource was invalid

Slot Manager Errors (fatal)

—300

smEmptySlot

No card in this slot

Appendix A: Result

Codes V-597

>

‘)
a)

©
=

=°
©

2)

Inside Macintosh

-301
—302
—303
—304
—305
—306

smCRCFail
smFormatErr
smRevisionErr
smNoDir
smLWTstBad

CRC check failed
The format of the declaration ROM is wrong
The revision of the declaration ROM is wrong

—307
—308
—309
—310
—311
—312
—313
—314
—315
—316
—317

smResrvErr
smUnExBusErr
smBLFieldBad
smFHBlockRdErr

A cone

smNoBoardsRsrc
smGetPRErr
smNoBoardlId
smInitStatVErr
smInitTblErr

—318
-319

smNoJmpTbl
smBadBoardID

smNosInfoArray

smFHBIkDispErr
smDisposePErr

There is no directory

The long word test failed
The SDM was unable to allocate memory for the sInfo
arra

field of the declaration ROM was used (fatal)

An unexpected Bus Error occurred

A valid ByteLanes field was not found
The F—Header block could not be read
The F—Header block could not be disposed of
An error occured during execution of _DisposPointer
There is no board sResource
An error occured during execution of _sGetPRAMRec
There is no board ID
The InitStatus_V field was negative after Primary Init
An error occured while trying to initialize the Slot
Resource Table
Slot Manager jump table could not be created
Board ID was wrong; reinit the PRAM record

Slot Manager Errors (non-fatal)

—330
—331
—332
—333

smBadReflId
smBadsList
smReservedErr
smCodeRevErr

—334

smCPUErr

—335
—336
—337
—338
—339
—341
—342
—344
—345
—346
—347
—349
—350
—351

smsPointerNil
smNilsBlockErr

smSlotOOBErr
smSelOOBErr

smNewPErr
smCkStatusErr
smGetDrvrNamErr
smNoMoresRsrcs
smGetDrvrErr
smBadsPtrErr

smByteLanesErr
smNoGoodOpens
smSRTOvrFlErr
smRecNotFnd

Reference ID was not found in the given list
The IDs in the given sList are not in ascending order
A reserved field was not zero
The revision of the code to be executed by sExec was
wrong
The CPU field of the code to be executed by sExec was
wrong
The sPointer is nil: no list is specified
The physical block size (of an sBlock) was zero
The given slot was out of bounds (or does not exist)

Selector is out of bounds
An error occured during execution of _NewPointer

Status of slot is bad (InitStatus_A,V)
An error occured during execution of _sGetDrvrName

No more sResources

An error occured during execution of _sGetDrvr

A bad sPointer was presented to a SDM call
Bad ByteLanes value was passed to an SDM call
No opens were successful in the loop
Slot Resource Table overflow
Record not found in the Slot Resource Table

Device Manager Error

—360

slotNumErr

Invalid slot number

AppleTalk Manager Errors
—1066
—1067

aspBadVersNum
aspBufTooSmall

V-598 Appendix A:

Server cannot support this ASP version
Buffer too small

Result Codes

Result Codes

-1068

aspNoMoreSess

No more sessions on server

-1070

aspParamErr

Parameter error

—1069

-1071
-1072
-1073
-1074
-1075

aspNoServers

aspServerBusy
aspSessClosed
aspSizeErr

aspTooMany
aspNoAck

No servers at that address

Server cannot open another session
Session closed
Command block too big

Too many clients
No ACK on attention request

>

Returned by the Printing Manager when used with a LaserWriter

=

-4101
—4100
—4099

Printer not found, or closed
Connection just closed
Write request too big

=
g

—4097
—4096

Bad connection reference number
No free Connect Control Blocks available

—4098

Request already active

Returned by SysEnvirons call
-5500

envNotPresent

—5501

envBadVers

—5502

envVersTooBig

SysEnvirons trap not present (System file earlier than

version 4.1); glue returns values for all fields except

systemVersion
A nonpositive version number was passed—no
information is returned
Requested version of SysEnvirons call was not available

Appendix A: Result Codes V-599

=

APPENDIX B: ROUTINES
OR PURGE MEMORY

THAT

MAY

MOVE

This appendix lists all the new routines that may move or purge blocks in the heap. As
described in chapter 1 of Volume II, calling these routines may cause problems if a handle

has been dereferenced. None of these routines may be called from within an interrupt,
such as in a completion routine or a VBL task.
Warning: Many more routines may disturb memory than did previously. In
particular, the following generic classes of routines may move or purge memory:
= most new color QuickDraw routines
m all new Printing Manager routines
w all new TextEdit routines.
The specific routines you must be careful with are listed below.
Name

Name

Name

ActivatePalette
ADBRelnit
AddComp

DisposCTable
DisposePalette
DisposeRgn

FillRoundRect
FindWord
Fix2SmallFract

AllocCrsr
BackColor

DisposPixMap
DisposPixPat

Font2Script
FontScript

AddSearch
BackPat

DisposGDevice
DrawChar

BackPixPat
Char2Pixel
CharWidth
ClipRect
CloseCPort
ClosePicture

DrawJust
DrawPicture
DrawString
DrawText
EraseArc
EraseOval

CloseRgn
CMY2RGB
Color2Index
CopyBits

EraseRect
EraseRgn
EraseRoundRect
FillArc

CopyPalette
CopyRgn
CTab2Palette
DelComp
DelIMCEntries
DelSearch
DiffRgn
DispMCInfo

FillCOval
FillCPoly
FillCRect
FillCRgn
FillCRoundRect
FillOval
FillPoly
FillRect

ClosePoly
ClosePort

Copy Mask

ErasePalette
ErasePoly

FillCArc

FMS wapFont
ForeColor

FrameArc
FrameOval
FramePoly
FrameRect
FrameRgn
FrameRoundRect

GetAuxCdl
GetCCursor

GetClcon
GetColor
GetCTable
GetFontInfo

GetGrayRgn

GetMCInfo
GetNewCWindow
GetNewPalette
GetPixPat
GetStylHandle
GetStylScrap
GetSubTable
HiliteText

Appendix B: Routines That May Move or Purge Memory V-601

>

=|
e
5
=
ao
”

Inside Macintosh
Name

Name

Name

DisposCIcon
HSV2RGB
InitCPort
InitGDevice
InitGraf
InitPalettes
InitPort
InitPRAMRecs
InitProcMenu
InitSDeclMgr
InitsRsrcTable
InsetRgn
IntlScript
InvertArc
InvertOval
InvertPoly
InvertRect
InvertRgn
InvertRoundRect
KeyScript
KillPicture
KillPoly
Line

FillRgn
PaintPoly

SetDeskCPat

LineTo

MakelTable
MapRgn
MeasureJust
MeasureText
NewCDialog
NewCWindow
NewGDevice
NewPalette
NewPixMap
NewPixPat
NewPort
NewRgn
OpenCPicture
OpenCPort
OpenPicture
OpenPix Map
OpenPoly
OpenPort
OpenPort
OpenRgn
PaintArc
PaintOval

PaintRect

PaintRgn

PaintRoundRect
Palette2CTab
PenNormal
PenPat
PenPixPat
Pixel2Char
PlotCIcon
PMBackColor

PMForeColor

PopUpMenuSelect
PrClose
PrCloseDoc

PrClosePage
PrCtCall
PrDrvrClose
PrDrvrDCE

PrDrvrOpen

PrDrvrVers
PrError
PrGeneral
PrintDefault

PrJobDialog
PrJobMerge
PrOpen
PrOpenDoc
PrOpenPage
PrPicFile
PrSetError

PrStlDialog

PrValidate
RealColor
RGB2CMY
RGB2HSL
RGB2HSV
RGBBackColor
RGBForeColor
RGetResource
ScrollRect

SectRgn

SetCCursor
SetCPixel
SetCtlColor

HSL2RGB

SetEmptyRgn
SetMCEntries
SetMCInfo

SetRectRgn
SetStylHandle
SetWinColor
sExec
sGetBlock

sGetcString

sGetDriver
ShutDwnInstall
ShutDwnRemove
SmallFract2Fix

SndAddModifier

SndDisposeChannel
SndNewChannel

sPrimaryInit

StdArc
StdBits
StdComment
StdLine

StdOval
StdPoly

StdPutPic
StdRect

StdRgn

StdRRect
StdText
StdTxMeas

StringWidth

TEGetHeight
TEGetOffset
TEGetPoint

TEGetStyle
TEReplaceStyle
TESetStyle
TEStylInsert
TEStylNew
TESty1Paste
TextWidth
Transliterate

UnionRgn
XorRgn

V-602 Appendix B : Routines That May Move or Purge Memory

APPENDIX

C:

SYSTEM

TRAPS

This appendix lists the trap macros for the new Toolbox and Operating System routines and their
corresponding trap word values in hexadecimal. The trap macros are listed twice: first by name,
then by value. The “Name” column gives the trap macro name (without its initial underscore
character). In those cases where the name of the equivalent Pascal call is different, the Pascal
name appears indented under the main entry. The routines in Macintosh packages are listed
under the macros they invoke after pushing a routine selector onto the stack; the routine selector
follows the Pascal routine name in parentheses.

Warning:

Traps that aren’t currently used by the system are reserved for future use.

Name

ActivatePalette
ADBOp
ADBRelInit
AddComp
AddSearch
AllocCursor
AnimateEntry
AnimatePalette
AttachVBL
BackPixPat
CalcCMask
CharExtra
CloseCPort
Color2Index
CopyBits
CopyMask
CopyPixMap
CopyPixPat
CountADBs

CTab2Palette

DelComp
DelMCEntries
DelSearch
DispMCInfo
DisposCCursor
DisposCIcon
DisposCTable
DisposePalette
DisposGDevice
DisposPixMap
DisposPixPat
DoVBLTask
DTInstall
FillCArc
FillCOval
FillCPoly
FillCRect
FillCRgn

Trap word
AA94
A07C
A07B
AA3B
AA3A
AA1D
AA99
AAIA
A071
AAOB
AA4F
AA23
A87D
AA33
A8EC
A817
AAO5
AA09
A077

Trap

Name
FillCRoundRect
GetADBInfo
GetAuxCtl
GetAuxWin
GetBackColor
GetCCursor
GetClIcon
GetCPixel
GetCTable

GetCTSeed

GetC Variant
GetCWMgrPort

GetDefaultStartup
GetDeviceList

GetEntryColor
GetEntry Usage
GetForeColor
GetGDevice

GetIndADB
GetItemCmd

GetMainDevice
GetMaxDevice

GetMCEntry
GetMClInfo

GetNewCWindow
GetNewPalette
GetNextDevice
GetOSDefault
GetPalette
GetPixPat
GetSubTable
GetVideoDefault
GetW Variant
HiliteColor
Index2Color

InitCport

AA12

InitGDevice
InitPalettes

word

AA10
A079
AA44
AA42
AAIA
AAIB
AAIE
AA17
AA18
AA28
A809
AA48
A07D
AA29
AA9B
AA9D
AAI19
AA32
A078
A84E
AA2A
AA27
AA64
AA61
AA46
AA92
AA2B
A084
AA96
AAOC
AA37
A080
A80A
AA22
AA34
AAOI
AA2E
AA90

Appendix C: System Traps V-603

o

ic)
a—)

©
=

=f

oO
©
a

Inside Macintosh

Trap word

Name
InitProcMenu
Internal Wait
SetTimeout
GetTimeout
InvertColor

(0)
(1)

KeyTrans

MakelITable
MakeRGBPat
MenuChoice

NewCDialog

NewCWindow
NewGDevice
NewPalette

NewPixMap
NewPixPat

OpColor

OpenCport

OpenPicture

Pack12
Fix2SmallFract
SmallFract2Fix
CMY2RGB
RGB2CMY
HSL2RGB
RGB2HSL
HSV2RGB
RGB2HSV

smGetScript
smSetScript
smCharByte
smCharType

smPixel2Char
smChar2Pixel
smTranslit
smFindWord
smHiliteText
smDrawJust
smMeasureJust

SCSIDispatch

SCSISelAtn

SCSIMsgIn

SCSIMsgOut
SeedCFill
SetADBInfo
SetCCursor
SetClientID
SetCPixel
SetCPortPix
SetCtlColor

(10)
(12)
(14)
(16)
(18)
(20)
(22)
(24)
(26)
(28)
(30)
(32)
(11)
(12)
(13)

AAAO
AAOA
AAIF
AA98
AA97
A80B
A8FD
AA3D

PopUpMenuSelect
PrGlue

ProtectEntry
QDError
RealColor

ReserveEntry

RestoreEntries
RGBBackColor
RGBForeColor
RGetResource
SaveEntries

(0)
(2)
(4)
(6)
(8)

AA36
AA3E
AA4A
AAI5
AA14
A80C
AA49
A8B5

V-604 Appendix C: System Traps

SetEntryColor
SetEntryUsage
SetGDevice
SetItemCmd
SetMCEntries
SetMCInfo
SetOSDefault
SetPalette
SetStdCProcs

SetVideoDefault
SetWinColor

Shutdown

ShutDwnPower

ShutDwnStart

ShutDwninstall
ShutDwnRemove

SIntInstall
SIntRemove
SlotManager
sReadByte
sRead Word
sReadLong
sGetcString

word

A815

AASO
AO7A
AAIC
AA3C
AA16
AA43
AO7E
AA47

SetDeskCPat
SetDeviceAttribute
SetEntries

Palette2CTab
PenPixPat
PlotCIcon
PmBackColor
PmForeColor

smGetEnvirons

AA35
A9C3
AA39
AAOD
AA66
AA4B
AA45
AA2F
AAQI
AA03
AAO7
AA21
AAOO
A8F3
A82E

smSetEnvirons

SetDefaultStartup

GetColor

ScriptUtil
smFontScript
smIntlScript
smK ybdScript
smFont2Script

A808
A0O7F

Trap

Name

(1)
(2)
(3)

(4)

(0)
(1)
(2)
(3)

AA3F
AA9IC
AAQE
AA31
A84F
AA65
AA62
A083
AA9S5
AA4E
A081
AA41
A895

A075
A076
A0Q6E

System Traps

Name
sGetBlock
sFindStruct
sReadStruct
sReadInfo
sReadPRAMRec
sPutPRAMRec

Trap word

sFindsRsrcPtr
sdeleteSRTRec
SlotVInstall
SlotVRemove
SndAddModifier
SndControl

(20)

SndDoCommand

A803

(22)

SndNewChannel

A807

(19)

sNextTypesRsrc

(21)

sRsrcInfo

sDisposePtr
sCkCardStatus
sReadDrvrName
sFindDevBase
InitSDeclIMgr
sPrimaryInit
sCardChanged
sExec
sOffsetData
InitPRAMRecs
sReadPBSize
sCalcStep
InitsRsrcTable
sSearchSRT

sUpdateSRT
sCalcsPointer
sGetDriver
sPtrToSlot

sFindsInfoRecPtr

Trap word
A055

A05D
AQ6E
sReadByte
sReadWord
sReadLong

sGetcString
sGetBlock
sFindStruct
sReadStruct
sReadInfo
sReadPRAMRec
sPutPRAMRec
sReadFHeader
sNextRsrc
sNextTypesRsrc
sRsrcInfo

Trap word

(5)
(6)
(7)
(16)
(17)
(18)

sReadFHeader
sNextRsrc

Name
(48)
(49)

SndDisposeChannel

SndDoImmediate

(23)
(24)
(25)
(27)
(32)
(33)
(34)
(35)
(36)
(37)
(38)
(40)
(41)

SndPlay
StripAddress
SwapMMUMode
SysEnvirons
TEDispatch
TEStylePaste
TESetStyle
TEReplaceStyle
TEGetStyle
GetStyleHandle
SetStyleHandle
GetStyleScrap
TEStyleInsert

(43)
(44)
(45)
(46)

TEGetHeight
TEGetOffset
TestDeviceAttribute
TEStyleNew

Name

Trap word

(42)

TEGetPoint

(47)

(0)
(1)
(2)
(3)
(4)
(5)
(6)
Wa,

AO6F
A070
A802
A806

A801

i

A804

5

A805
A055
A05D
A090
A83D

(8)

(9)

A83C
AA2C
A83E

Name

StripAddress

sDisposePtr

(23)

(2)

sPrimaryInit

(33)

SwapMMUMode
SlotManager
(0)
(1)
(3)
(5)
(6)
(7)
(16)
(17)
(18)
(19)
(20)
(21)
(22)

sCkCardStatus
sReadDrvrName
sFindDevBase
InitSDeclMgr
sCardChanged
sExec
sOffsetData
InitPRAMRecs
sReadPBSize
sCalcStep
InitsRsrcTable
sSearchSRT
sUpdateSRT
sCalcsPointer
sGetDriver

(24)
(25)
(27)
(32)
(34)
(35)
(36)
(37)
(38)
(40)
(41)
(42)
(43)
(44)
(45)

Appendix C: System Traps V-605

i

eo
se

Inside Macintosh
Trap word
sPtrToSlot
sFindsInfoRecPtr
sFindsRsrcPtr
sdeleteSRTRec
AO6F
A070
A071
A072
A075
A076
A077
A078
A079
AO7A
A07B
A07C
A07D
AO7E
AO7F
SetTimeout

GetTimeout

A080
A081
A082
A083
A084
A090
A801
A802
A803
A804
A805
A806
A807
A808
A809
A80A
A80B
A80C
A815
SCSISelAtn

SCSIMsgIn

SCSIMsgOut
A817
A82E
Fix2SmallFract
SmallFract2Fix
CMY2RGB
RGB2CMY
HSL2RGB

Trap

Name

(46)
(47)
(48)
(49)

SlotVInstall
SlotV Remove
AttachVBL
DoVBLTask

DTInstall

SIntRemove
CountADBs
GetIndADB
GetADBInfo
SetADBInfo
ADBRelnit
ADBOp
GetDefaultStartup

SetDefaultStartup

Internal Wait

(0)
(1)

GetVideoDefault
SetVideoDefault
SIntInstall
SetOS Default
GetOSDefault

SysEnvirons

SndDisposeChannel
SndAddModifier
SndDoCommand
SndDoImmediate

SndPlay

SndControl
SndNewChannel
InitProcMenu
GetC Variant
GetWVariant

PopUpMenuSelect
RGetResource

SCSIDispatch
(11)
(12)
(13)
CopyMask

Pack12

(1)
(2)
(3)
(4)
(5)

V-606 Appendix C: System Traps

word

RGB2HSL
HSV2RGB
RGB2HSV
GetColor
A83C
A83D
TEStylePaste
TESetStyle

TEReplaceStyle
TEGetStyle
GetStyleHandle
SetStyleHandle

GetStyleScrap
TEStyleInsert
TEGetPoint
TEGetHeight
A83E
A84E
A84F
A87D
A895
ShutDwnPower
ShutDwnStart
ShutDwniInstall
ShutDwnRemove
A8B5
smFontScript
smIntlScript
smKybdScript
smFont2Script
smGetEnvirons
smSetEnvirons
smGetScript
smSetScript
smCharByte
smCharType
smPixel2Char
smChar2Pixel
smTranslit
smFindWord
smHiliteText
smDrawJust
smMeasureJust
A8EC
A8F3
A8FD
A9C3
AAOO
AAO1
AA0O3

Name

(6)

(7)
(8)
(9)

TEGetOffset

TEDispatch

(0)
(1)

(2)
(3)
(4)

(5)
(6)
(7)

(8)
(9)

TEStyleNew
GetltemCmd
SetItemCmd
CloseCPort
Shutdown

(1)
(2)
(3)
(4)

ScriptUtil

(0)
(2)
(4)
(6)
(8)
(10)
(12)
(14)
(16)
(18)

(20)

(22)
(24)
(26)
(28)
(30)
(32)

CopyBits
OpenPicture
PrGlue
KeyTrans

OpenCport

InitCport
NewPixMap

System Traps
Trap
AA04
AAO05
AA06
AAO7
AAO08
AA09
AAOA
AAOB
AAO0C
AAOD
AAOE
AAOF
AA10
AAI1
AA12
AAI3
AA14
AA15
AAI6
AAI7
AA18
AAI9
AAIA
AAIB
AAIC
AAI1D
AAIE
AAIF
AA21
AA22
AA23
AA?24
AA25
AA26
AA27
AA29
AA28
AA2A
AA2B
AA2C

word

Name

Trap

DisposPixMap

AA37
AA39
AA3A
AA3B
AA3C
AA3D
AA3E
AA3F
AA40
AA41
AA42
AA43
AA44
AA45
AA46
AA47
AA48
AA49
AA4A
AA4B
AA4C
AA4D
AA4E
AA4F
AASO
AA60
AA61
AA62
AA63
AA64
AA65
AA66
AA90
AAQ1
AA92
AA93
AA94
AA95
AA96
AA97
AA98
AA99
AA9A
AA9B
AA9C
AA9D
AAQE
AA9F
AAAO

CopyPixMap
SetCPortPix
NewPixPat

DisposPixPat
CopyPixPat

PenPixPat
BackPixPat
GetPixPat
MakeRGBPat
FillCRect
FillCOval

FillCRoundRect
FillCArc
FillCRgn
FillCPoly
RGBForeColor
RGBBackColor
SetCPixel
GetCPixel
GetCTable

GetForeColor

GetBackColor
GetCCursor
SetCCursor
AllocCursor
GetClcon
PlotCIcon

OpColor

HiliteColor
CharExtra

DisposCTable

DisposClIcon
DisposCCursor

GetMaxDevice
GetDeviceList
GetCTSeed
GetMainDevice
GetNextDevice
TestDeviceA ttribute
SetDeviceAttribute
InitGDevice
NewGDevice

DisposGDevice

AA36

SetGDevice
GetG Device
Color2Index
Index2Color
InvertColor
RealColor

word

Name
GetSubTable
MakelI Table
AddSearch

AddComp
SetClientID
ProtectEntry
ReserveEntry
SetEntries

QDError
SetWinColor
GetAuxWin
SetCtlColor

GetAuxCtl
NewCWindow

GetNewCWindow
SetDeskCPat

GetCWMegrPort
SaveEntries
RestoreEntries

NewCDialog

DelSearch

DelComp

SetStdCProcs
CalcCMask
SeedCFill
DelMCEntries
GetMCInfo

SetMCInfo
DispMCInfo

GetMCEntry

SetMCEntries

MenuChoice

InitPalettes
NewPalette
GetNewPalette

DisposePalette

ActivatePalette
SetPalette
GetPalette
PmForeColor
PmBackColor

AnimateEntry

AnimatePalette

GetEntryColor

SetEntryColor
GetEntry Usage
SetEntryUsage

CTab2Palette
Palette2CTab

Appendix C: System Traps V-607

oa
—)
a~)
©
=

ce

o
©

2)

APPENDIX

D:

GLOBAL

VARIABLES

This appendix gives an alphabetical list of all system global variables described in this
volume, along with their locations in memory.
Name
AtMenuBottom
AuxWinHead
CPUFlag

DeviceList
DTQueue

HiliteMode
HiliteRGB
JADBProc
JDTInstall
JVBLTask
KbdLast

KbdType

MainDevice

MBarHeight

MenuClnfo
MenuDisable
MMU32Bit

QDColors

Location

$A0C
$CDO
$12F
$8A8

$D92
$938

$DA0
06B8

$D9C
$D28
$218
$21E
$8A4

$BAA

$DS0

$B54
$CB2

$8B0

TheGDevice
TimeDBRA

$28E
$D32
$2A6
$CC8
$D00

TimeSCCDB

$D02

TimeSCSIDB

$DA6

TopMenultem

$A0A

ROM85

SynListHandle
SysZone

Contents
Flag for menu scrolling (word)
Auxiliary window list header (long)
Microprocessor in use (word)
Handle to the first element in the device list
Deferred task queue header (10 bytes)

Set if highlighting is on
Default highlight color for the system
Pointer to ADBRelInit preprocessing/
postprocessing routine
Jump vector for DTInstall routine
Jump vector for DoVBLTask routine
ADB

address of the keyboard last used (byte)

Keyboard type of the keyboard last used (byte)
Handle to the current main device
Height of menu bar (word)
Header for menu color information table
Menu ID and item for selected disabled item
Current address mode (byte)
Default QuickDraw colors
Version number of ROM (word)

Handle to synthetic font list
Address of system heap zone
Handle to current active device (long)
Number of times the DBRA instruction can be
executed per millisecond (word)
Number of times the SCC can be accessed per
millisecond (word)
Number of times the SCSI can be accessed per
millisecond (word)
Pixel value of top of scrollable menu

Appendix D: Global Variables V-609

GLOSSARY
ADB device table: A

Apple DeskTop Bus.

structure in the system heap that lists all devices connected to the

auxiliary control record: A Control Manager data structure containing the information
needed for drawing controls in color.
auxiliary window record: A Window Manager data structure that stores the color
information needed for each color window.
background activity:
another application.

A program or process that runs while the user is engaged with

break table: A list of templates that determine the general rules for making word
divisions in a particular script.
Any of the four bytes that make up the NuBus data width.

NuBus slot cards

may use any or all of the byte lanes to communicate with each other or with the

Macintosh II.
cdev:

A resource file containing device information, used by the Control Panel.

cGrafPort:

The drawing environment in Color QuickDraw, including elements such as a

pixel map, pixel patterns, transfer modes, and arithmetic drawing modes.

channel: A queue that’s used by an application to send commands to the Sound
Manager.
chunky: A pixel image in which all of a pixel’s bits are stored consecutively in memory,
all of a row’s pixels are stored consecutively, and rowBytes indicates the offset from one
row to the next.
Color Look-Up

Table (CLUT):

A data structure that maps color indices, specified

Color

Table (CLUT)

device:

using QuickDraw, into actual color values. Color Look-Up Tables are internal to certain
types of video cards.
Look-Up

ro)
t<
bow

board sResource list: A standard Apple sResource list that must be present in every
NuBus slot card that communicates with the Macintosh II.

byte lane:

Q°

1? 2)
i? 2)

This kind of video device contains hardware

that converts an arbitrary pixel value stored in the frame buffer to some actual RGB video
value, which is changeable.

Color Manager: The part of the Toolbox that supplies color-selection support for Color
QuickDraw on the Macintosh II.

Glossary V-611

4

Inside Macintosh

Color QuickDraw:
the Macintosh II.

The part of the Toolbox that performs color graphics operations on

color table: A set of colors is grouped into a QuickDraw data structure called a color
table. Applications can pass a handle to this color table in order to use color entries.
color table animation: Color table animation involves changing the index entries in the
video device’s color table to achieve a change in color, as opposed to changing the pixel
values themselves. All pixel values corresponding to the altered index entries suddenly
appear on the display device in the new color.
complement: The numerical amount that must be added to a number to give the least
number containing one more digit.
declaration ROM:

A ROM

ona NuBus slot card that contains information about the

card and may also contain code or other data.

deny modes: File access modes that include both the access rights of that path and denial
of access to others.
device address: A value in the range $00—$0F assigned to each device connected to the
Apple DeskTop Bus.
device handler ID:
DeskTop Bus.

A value that identifies the kind of device connected to the Apple

DeviceList: A linked list containing the gDevice records for a system. One handle to a
gDevice record is allocated and initialized for each video card found by the system.
direct device: A video device that has a direct correlation between the value placed in the
video card and the color you see on the screen.

dithering: A technique for mixing existing colors together to create the illusion of a third
color that may be unavailable on a particular device.

drag delay: A length of time that allows a user to drag diagonally across a main menu,
moving from a submenu title into the submenu itself without the submenu disappearing.
Echo Protocol: An echoing service provided on static socket number 4 (the echoer
socket) by which any correctly-formed packet will be echoed back to its sender.
fixed device: A video device that converts a pixel value to some actual RGB video
value, but the hardware colors can’t be changed.
font script: The script used by the font currently designated by thePort; hence the
system that determines in what form text characters are displayed to the user.
format block: A structure in a declaration ROM that provides a standard entry point for
other structures in the ROM.

V-612 Glossary

Glossary
gDevice: A QuickDraw data structure that allows an application to access a given device.
A gDevice is a logical device, which the software treats the same whether it is a video card,
a display device, or an offscreen pixel map.
graphics device:

A video card, a printer, a display device, or an offscreen pixel map.

Any of these device types may be used with Color QuickDraw.

GrayRgn: The global variable that in the multiple-screen desktop describes and defines
the desktop, the area on which windows can be dragged.
hierarchical menu:

A menu that includes, among its various menu choices, the ability

to display a submenu. In most cases the submenu appears to the right of the menu item
used to select it, and is marked with a filled triangle indicator.
invalidation:

When a color table is modified, its inverse table must be rebuilt, and the

screen should be redrawn to take advantage of this new information. Rather than being

reconstructed when the color table is changed, the inverse table is marked invalid, and is
automatically rebuilt when next accessed.
inverse table: A special Color Manager data structure arranged in such a manner that,
given an arbitrary RGB color, the pixel value can be very rapidly looked up.

justification gap: The number of pixels that must be added to a line of text to make it
exactly fill a given measure.

Also called slop.

key script: The system that determines the keyboard layout and input method for the
user interface. It may be different from the font script, which determines how text is
displayed.
line-height table: A TextEdit data structure that holds vertical spacing information for
an edit record’s text.
localization: The process of adapting an application to different languages, including
converting its user interface to a different script.
luminance: The intensity of light. Two colors with different luminances will be
displayed at different intensities.
main screen: Ona system with multiple display devices, the screen with the menu bar is
called the main screen.
menu entry: An entry in a menu color table that defines color values for the menu’s title,
bar, and items.
MIDI synthesizer: This synthesizer interfaces with external synthesizers via a Musical
Instrument Data Interface (MIDI) adaptor connected to the serial ports.
modifier: A program that interprets and processes Sound Manager commands as they
pass through a channel.

Glossary V-613

Inside Macintosh

note synthesizer:

Functionally equivalent to the old square-wave synthesizer, the note

null-style record:

A TextEdit data structure used to store the style information for a null

sysntesizer lets you generate simple melodies and informative sounds such as error
warnings.

selection.
palette:

needs.

A collection of colors provided and used by your application according

Palette Manager:

to your

The part of the Toolbox that establishes and monitors the color

environment of the Macintosh II. It gives preference to the color needs of the front
window, making the assumption that the front window is of greatest interest to the user.

pixel: A dot on a display screen. Pixel is short for picture element.
pixel map:

Color QuickDraw’s extended data structure, containing the dimensions and

content of a pixel image, plus information on the image’s storage format, depth, resolution,

and color usage.

pixel pattern: The pattern structure used by Color QuickDraw, one of three types: oldstyle pattern, full color pixel pattern, or RGB pattern.
pixel value:

The bits in a pixel, taken together, form a number known as the pixel value.

Color QuickDraw represents each pixel on the screen using one, two, four, or eight bits in
memory.

pop-up menu: A menu not located in the menu bar, which appears when the user
presses the mouse button in a particular place.
range locking: Locking a range of bytes in a file so that other users can’t read from or
write to that range, but allowing the rest of the file to be accessed.
raw key codes: Hardware-produced key codes on the Macintosh II and Apple Extended
Keyboard, which are translated into virtual key codes by the 'KMAP' resource.
RGB

space:

How Color QuickDraw represents colors. Each color has a red, a green,

and a blue component, hence the name RGB.

RGB value: Color QuickDraw represents color using the RGBColor record type, which
specifies the red, green, and blue components of the color. The RGBColor record is used
by an application to specify the colors it needs. The translation from the RGB value to the
pixel value is performed at the time the color is drawn.
routine selector: A value pushed on the stack to select a particular routine from a group
of routines called by a single trap macro.
sampled sound synthesizer: Functionally equivalent to the old free-form synthesizer,
the sample sound synthesizer lets you play pre-recorded sounds or sounds generated by
your application.

V-614 Glossary

Glossary

script: A writing system, such as Cyrillic or Arabic. This book is printed in Roman

script.

script interface system:
of a particular script.
server;

Special software that supports the display and manipulation

A node that manages access to a peripheral device.

service request enable:

A bit set by a device connected to the Apple DeskTop Bus to

tell the system that it needs servicing.

session: A session consists of a series of transactions between two sockets,
characterized by the orderly sequencing of requests and responses.
slop:

See justification

OQ

gap.

Sc

slot exec parameter block: A data structure that provides communication with the Slot
Manager routines sMacBoot and sPrimaryInit.
slot parameter block: A data structure that provides communication with all Slot
Manager routines except sMacBoot and sPrimaryInit.
slot resource:

A software structure in the declaration ROM

sResource:

See slot

sResource directory:
sResource lists.
sResource list:

of a slot card.

resource.

The structure in a declaration ROM that provides access to its

A list of offsets to sResources.

startup screen: When the system is started up, one of the display devices is selected as
the startup screen, the screen on which the “happy Macintosh” icon appears.
style record:

A TextEdit data structure that specifies the styles for the edit record’s text.

style scrap: A new TextEdit scrap type, ‘styl’, is used for storing style information in
the desk scrap along with the old "TEXT" scrap.
style table: A TextEdit data structure that contains one entry for each distinct style used
in an edit record’s text.
submenu delay: The length of time before a submenu appears as a user drags through a
hierarchical main menu; it prevents rapid flashing of submenus.

synthesizer:

A program which, like a device driver, interprets Sound Manager

commands and produces sound.

text styles: TextEdit records used for communicating style information between the
application program and the TextEdit routines.

Glossary V-615

7)
M

=
=
<<

Inside Macintosh

TheGDevice: When drawing is being performed on a device, a handle to that device is
stored as a global variable TheGDevice.
type coercion: Many compilers feature type coercion (also known as typecasting),
which allows a data structure of one type to be converted to another type. In many cases,
this conversion is simply a relaxation of type-checking in the compiler, allowing the

substitution of a differently-typed but equivalent data structure.

virtual key codes:
codes.

The key codes that appear in keyboard events. See also raw key

wave table synthesizer: Similar to the old four-tone synthesizer, the wave table
synthesizer produces complex sounds and multipart music.
word-selection break table: A break table that is used to find word boundaries for
word selection, spelling checking, and so on.

word-wrapping break table:
screen wrapping of text.
workstation:

A break table that is used to find word boundaries for

A node through which a user can access a server or other nodes.

V-616 Glossary

INDEX
A
access modes V-376
‘actb' resource V-278
ActivatePalette procedure V-162
ADBDataBlock V-369
ADB device table V-367
ADBOp function V-368
ADBRelnit procedure V-367
ADBSetInfoBlock V-370
'ADBS' resource V-371
AddComp procedure V-147
AddResMenu procedure V-243
AddResponse function V-513
AddSearch procedure V-147
AFPCommand function V-542
AFP command mapping V-541
AFP login command format V-543
AFP read command format V-547
AFP write command format V-545
alert color table V-278
Alert function V-284
AllocCursor procedure V-75
'ALRT' resource V-278
AnimateEntry procedure V-164
AnimatePalette procedure V-164
animating colors V-156
AppendMenu procedure V-243
Apple Desktop Bus V-361
routines V-367
Apple Extended Keyboard V-190, V-192

AppleShare V-380

AppleTalk Filing Protocol (AFP) V-523
AppleTalk Manager V-507
AppleTalk Session Protocol (ASP) V-522
AppleTalk system configurations V-519
arithmetic drawing modes V-59
ASPAbortOS function V-537
ASPCloseAll function V-538
ASPCloseSession function V-537
ASPGetParms function V-538
ASPGetStatus function V-540
ASPOpenSession function V-536
ASPUserCommand function V-539

ASPUserWrite function V-538
assembly language V-3
AtMenuBottom global variable V-249
ATPParamBlock packed record V-512
AttachPH function V-513
AttachVBL function V-567
AuxCtlHead global variable V-216
AuxCulRec record V-217
AuxDCE packed record V-424
AuxWinHead global variable V-200
AuxWinList V-200
AuxWinRec record V-201

B
BackPixPat procedure V-74

"BNDL' cdev resource V-327
board sResource list V-437

break table V-309
BuildBDS function V-515
BuildDDPwds procedure V-514
BuildLAPwds procedure V-514

Cc
CalcCMask procedure V-72
CautionAlert function

CCrsr record V-62
‘ectb' resource

V-284

V-221

'CDEF' V-221
cdev function V-329
‘cdev' resource V-327, V-329
cdevs V-324
CGrafPort record V-49
Char2Pixel function V-308

CharByte function V-306
CharExtra procedure V-77
CharType function V-306
Chooser, changes to V-428
chunky pixel image V-54
‘cicn' resource V-65, V-78, V-80
CIcon record V-64

Index V-617

Inside Macintosh
ClearMenuBar procedure V-247

D

CloseCPort procedure V-68
CloseSkt function V-513
CLUT devices V-134
‘clut' resource V-78, V-81
CMY2RGB procedure V-175

'dctb' resource V-278

CloseATPSkt function

V-513

CMY color model V-43, V-171
Color2Index function V-141

color V-14
ColorInfo record V-159
Color Look-Up Table (CLUT) V-46, V-134
Color Manager V-133
routines V-141
colormenus V-227
color model conversion routines V-174
Color Picker Package V-171
routines V-174
Color QuickDraw V-39
routines V-66
ColorSpec record V-49, V-136
color table V-46
color table animation V-153
ColorTable record V-48, V-135
command mapping, AFP V-541
compatibility guidelines V-1
CompProc procedure V-147
ConfirmName function V-513
control color table V-218
control definition function V-220
Control key V-21
Control Manager V-215
routines V-221
Control Panel V-323

CopyBits procedure V-70

CopyMask procedure V-71
CopyPixMap procedure V-70

CopyPixPat procedure V-73

CouldAlert procedure V-285
CouldDialog procedure V-284
CountADBs function V-369
courteous colors V-154
CProcRec record V-146
CPUFlag variable V-348
CQDProcs record V-91
‘crsr' resource V-63, V-78
cSpecArray V-49, V-136
CTab2Palette procedure V-165
CulCTab record V-218
CWindowRecord V-199

V-618 Index

declaration ROM V-437
Deferred Task Manager V-465

routine V-467

DeferredTask record V-466
DefOSRec record V-355

DefStartRec V-353
DefVideoRec V-354
DelComp procedure V-147

DeleteMenu procedure V-244

DelMCEntries procedure V-238
DelMenultem procedure V-244
DelSearch procedure V-147
DetachPH function V-513

Device Address V-366

device handler ID V-365
device table, ADB V-367
DeviceList V-118
Device Manager V-421
routines V-427
dialog color table V-278
dialog item list V-279
Dialog Manager V-277

routines V-283

direct devices V-134
DisableItem procedure V-246
Disk Driver V-469
DispMCInfo procedure V-239
DisposCCursor procedure V-75
DisposCIcon procedure V-76
DisposCTable procedure V-78
DisposePalette procedure V-162

DisposGDevice function V-123
DisposPixMap procedure V-70
DisposPixPat procedure V-73

dithering V-57
'‘DITL' cdev resource V-327
'‘DITL' resource V-278
‘DLOG' resource V-278
DoVBLTask function V-568
drag delay V-24
DragGrayRgn function V-209
DrawJust procedure V-310
DrawMenuBar procedure V-244
DTinstall function V-467

Index

E

G

echoer V-522
echoer socket V-522
Echo Protocol (EP) V-522
Enableltem procedure V-246
error codes (new) V-572
Escape key V-21
explicit colors V-156

GDevice record V-119
General cdev V-325
GetADBInfo function V-369
GetAppFont function V-315
GetAuxCu function V-222
GetAux Win function V-207
GetBackColor procedure V-68
GetBridgeAddress function V-515
GetCCursor function V-75
GetClIcon function V-76
GetColor function V-174
GetCPixel procedure V-69
GetCTable function V-77
GetCTSeed function V-143
GetCVariant function V-222
GetCWMgrPort procedure V-205, V-210
GetDefaultStartup procedure V-353
GetDefFontSize function V-315
GetDeviceList function V-124

Extended Protocol Package (XPP)
driver V-524

F

‘fctb' resource V-183, V-184
FHeaderRec packed record V-449
file access modes V-376
File Manager, V-extensions V-10
File Manager extensions V-375
FillCArc procedure V-69
FillCOval procedure V-69
FillCPoly procedure V-69
FillCRect procedure V-69
FillCRgn procedure V-69
FillCRoundRect procedure V-69
FindWindow procedure V-208
FindWord procedure V-309
Fix2SmallFract function V-175
fixed devices V-134
FlashMenuBar procedure V-246
Floating-Point Arithmetic and Transcendental
Functions Packages V-595
Flush command V-363, V-364
'FOND' resource V-181, V-185
Font2Script function V-315
Font Manager V-179
routines V-180
'FONT' resource V-181
font script V-298
FontScript function V-314
format block V-437
fractional pen positioning V-84
FreeAlert procedure V-285
FreeDialog procedure V-285
'FREF' cdev resource V-327
function keys V-22

GetEntryColor procedure V-164
GetEntry Usage procedure V-165
GetEnvirons function V-313
GetForeColor procedure V-68
GetGDevice function V-123
GetGrayRgn function V-208
GetIndADB function V-369
GetItemCmd procedure V-240
GetltemIcon procedure V-246
GetItemMark procedure V-246
GetlItemStyle procedure V-247
GetMainDevice function V-124
GetMaxDevice function V-125
GetMBarHeight function V-315

GetMCEntry function V-239

GetMCInfo function V-239
GetMenu function V-243
GetMHandle function V-246
GetMMUMode function V-592
GetNewCWindow function V-207
GetNewDialog function V-284
GetNewMBar function V-247
GetNewPalette function V-162
GetNextDevice function V-124
GetOSDefault procedure V-355
GetPalette function V-163
GetPixPat function V-73
GetRequest function V-513
GetScript function V-312
GetStylHandle function V-268

Index V-619

Inside Macintosh
GetStylScrap function V-268
GetSubTable procedure V-142
GetSysFont function V-315
GetSysJust function V-315
GetTimeout procedure V-356
GetVideoDefault procedure V-354
GetW Variant function V-208
global variables V-607
GrafVars record V-67
graphics devices V-117, V-118
routines V-122
GrayRgn global variable V-121
GrayRgn variable V-205
GrowWindow function V-209

H
heap zones V-3
hierarchical menu V-226
HiliteColor procedure V-77
HiliteMenu procedure V-245
HiliteMode global variable V-61
HiliteRGB global variable V-62
HiliteText procedure V-310
HLS color model V-43, V-171
HParamBlockRec record V-390
HSL2RGB procedure V-175
HSV2RGB procedure V-175
HSV color model V-43, V-171

‘ICN#' cdev resource V-327
‘ictb' resource V-278
Index2Color procedure V-141
‘INIT’ 31 resource V-352
InitCPort procedure V-67
InitGDevice procedure V-123
InitMenus procedure V-242
InitPalettes procedure V-161
InitPRAMRecs function V-454
InitProcMenu procedure V-238
InitSDeclMegr function V-451
InitsRsrcTable function V-454
InitWindows procedure V-208
InsertMenu procedure V-244
InsertResMenu procedure V-243
InsNewltem procedure V-243

V-620 Index

Intemational Utilities Package
sorting routines V-291
interrupt tasks V-466
‘'INTL' O resource

V-9, V-287

V-288

'INTL' 1 resource V-288
‘INTL’ 2 resource V-288
IntlScript function V-314
inverse table

V-137

InvertColor procedure V-141
ioACAccess record V-388
ioACUser record V-390
ioDenyModes record V-389
ioObjType record V-388
ITab record V-139
‘jtlO' resource V-288
‘itll’ resource V-288
‘it12' resource V-288
‘jtlb' resource V-288
‘jtlc' resource V-288

J
JADBProc variable V-367
jDoVBLTask V-568
jDTInstall V-467
justification gap V-305

K
KbdLast variable V-367
KbdType variable V-367
'KCHR' resource V-190
Keyboard cdev V-325
keyboard event message V-193
keyboards V-190
key script V-298
KeyScript procedure V-314
KeyTrans function V-195
KillGetReq function V-514
KillINBP function V-514
KillSendReq function V-514
'KMAP' resource V-190

L
LHElement V-263
LHTable V-263
Listen command V-363, V-364

Index
localization V-8, V-294
login command format, AFP V-543
LookupName function V-513

M
‘mach’ cdev resource V-327, V-328
Macintosh Plus Keyboard V-190, V-191
Macintosh II Keyboard V-190, V-191
MainDevice global variable V-124
main screen V-121
MakelTable procedure V-142
MakeRGBPat procedure V-73
MatchRec record V-72
MBarHeight global variable V-253
‘MBDF' resources V-250
MCEntry V-231
MCTable V-232
‘mctb' resource V-234
'"MDEF' resources V-248
MeasureJust procedure V-311
memory, routines that may move or purge
V-601
menu bar definition procedure V-250
menu bar defproc messages V-251
menu bar entry V-233
MenuChoice function V-240
MenuClInfo global variable V-242
menu color information table V-231
MenuCRsrc V-234
menu definition procedure V-248
MenuDisable global variable V-249
menu features V-24
menu highlighting V-235
Menulnfo V-230
menu item entry V-234
MenuKey function V-245
MenuList V-228
Menu Manager V-225
routines V-238
MenuSelect function V-244
menu title entry V-233

MIDI (Musical Instrument Digital Interface)

V-475, V-496
MIDI synthesizer V-475
MMU32Bit global variable V-592
Modifier Flag structure V-194
ModifierStub record V-482
Monitors cdey V-325
Mouse cdev V-325

MoveWindow procedure V-209
MPPParamBlock packed record V-511, V-551
multibit fonts V-83
multiple screens V-121
Musical Instrument Digital Interface (MIDI)
V-475, V-496
MyCallBack procedure V-480
MyModifier function V-480

N
NBPExtract function

V-515

NBPSetEntity procedure V-514
NBPSetNTE procedure

V-515

NewCDialog function V-283

NewCWindow function V-207
NewGDevice function V-122
NewPalette function V-161

NewPixMap function V-70

NewPixPat function V-72
"NFNT' resource V-181, V-183
NoteAlert function V-284

note synthesizer V-475

‘nrct' cdev resource V-327
‘nrct' resource V-329

NSendRequest function V-514
NullSTRec V-264

O
offscreen bitmap V-125
offscreen devices V-125
OpColor procedure V-77
OpenATPSkt function V-513
OpenCPort procedure V-67
OpenPicture function V-96
OpenSkt function V-513
OpenSlot function V-425
Operating System Utilities V-591
routines V-592

P
Pack12 trap macro V-174
PaintOne procedure V-208
Palette2CTab procedure V-166
palette V-152
palette customization V-158

Index V-621

Inside Macintosh
Palette Manager V-151
routines V-161
palette prioritization V-157
Palette record V-159
palette resource example V-160
partition map entry V-579
PBGetCatInfo function V-391
PBHCopyFile function V-396
PBHGetDirAccess function V-394
PBHGetLogiInInfo function V-393
PBHGetVolParms function V-392
PBHMapID function V-395
PBHMapName function V-395
PBHMoveRename function V-397
PBHOpenDeny function V-398
PBHOpenRFDeny function V-398
PBHSetDirAccess function V-394
PenPixPat procedure V-74
picComments V-94
PICT file V-85
sample V-95
PICT opcodes V-96
expanded format V-103
picture compatibility V-92
Picture record V-86
picture spooling V-87
sample programs V-88, V-89
picture structures V-92
Pixel2Char function V-307
pixel V-42
pixel pattem V-55
pixel value V-42
PixMap record V-52
PixPat record V-55

PKillGetReq function V-518

PKilINBP function V-519
PKillSendReq function V-518
PlotCIcon procedure V-76
‘pltt' resource V-152

PmBackColor procedure V-163

PmForeColor procedure V-163
PNSendRequest function V-517
pop-up menu V-25
PopUpMenuSelect function V-241
‘ppat' resource V-78, V-79
PrCloseDoc procedure V-408
PrClosePage procedure V-408
PrClose procedure V-408
PrCtlCall procedure V-408

PrDrvrClose procedure V-408
PrDrvrDCE function V-408

V-622 Index

PrDrvrOpen procedure V-408
PrDrvrVers function V-408
PrError function V-408
PrGeneral procedure V-410
PrGlue trap V-408, V-409
primary ordering V-291
PrintDefault procedure V-408
Printing Manager V-407
PrJobDialog function V-408
PrJobMerge procedure V-408

PrOpenDoc function V-408

PrOpenPage procedure V-408
PrOpen procedure V-408
ProtectEntry procedure V-143
PrPicFile procedure V-408
PrSetError procedure V-408
PrSuDialog function V-408
PrValidate function V-408
PSetSelfSend function V-516

Q
QDError function V-145

R
raw key codes V-190
RealColor function V-141
read command format, AFP V-547
register Q V-365
register 3 V-365
RegisterName function V-513
RelRspCB function V-514
RelTCB function V-513
RemoveName function V-513
ReqListRec record V-144
ReserveEntry procedure V-143
Resource Manager V-29
resource types V-30
Restart command V-586
RestoreEntries procedure V-144
result codes V-597
RGB2CMY procedure V-175
RGB2HSL procedure V-175
RGB2HSV procedure V-175
RGBBackColor procedure V-68
RGBColor record V-48, V-136
RGBForeColor procedure V-68
RGB space V-42

Index
RGB value V-48
RGetResource function V-30
ROM resources V-30, V-32

S
sampled sound synthesizer V-475
SaveEntries procedure V-144
sBootRecord V-422
SCalcSPtr function V-455
SCalcStep function V-453
SCardChanged function V-452
SCkCardStatus function V-450
screen configuration V-127
script V-294
Script Interface System V-295
Script Manager V-9, V-293
features V-303
routines V-306
ScriptUtil macro V-306
‘scrn' resource V-127
ScrpSTElement V-266
ScrpSTTable array V-266
SCSIDispatch trap macro V-574
SCSI Manager V-573
routines V-574
SCSIMsgIn function V-575
SCSIMsgOut function V-575
SCSIRBlind function V-574, V-576
SCSISelAtn function V-575
SCSIWBlind function V-574, V-576
SDeleteSRTRec function V-451
SearchProc function V-146
SEBlock packed record V-441
secondary ordering V-291
SeedCFill procedure V-71
SendRequest function V-513
SendReset command V-363, V-364
SendResponse function V-513
server V-522
Service Request Enable V-366
session V-522
SetADBInfo function V-370
SetCCursor procedure V-75
SetChooserAlert function V-431
SetClientID procedure V-147
SetCPixel procedure V-70
SetCulColor procedure V-222
SetDefaultStartup procedure V-354
SetDeskCPat procedure V-210

SetDeviceAttribute procedure V-124
SetEntries procedure V-143
SetEntryColor procedure V-165
SetEntryUsage procedure V-165
SetEnvirons function V-314
SetFractEnable routine V-180
SetGDevice procedure V-123
SetItemCmd procedure V-240
SetItemIcon procedure V-246
SetItemMark procedure V-246
SetMCEntries procedure V-239
SetMCInfo procedure V-239
SetOSDefault procedure V-355
SetPalette procedure V-162
SetPortPix procedure V-76
SetScript function V-313
SetSelfSend function V-514
SetStdCProcs procedure V-77
SetStylHandle procedure V-268
SetSysJust procedure V-316
SetTimeout procedure V-356
SetVideoDefault procedure V-355
SetWinColor procedure V-207
SExec Block V-441
SExec function V-452
SFindDevBase function V-451
SFindsInfoRecPtr function V-455
SFindsRsrcPtr function V-456
SFindStruct function V-446
SGetBlock function V-446
SGetCString function V-445
SGetDriver function V-455
Shut Down command V-586
Shutdown Manager V-585
routines V-587
Shutdown trap macro V-587
ShutDwniInstall procedure V-588
ShutDwnPower procedure V-587
ShutDwnRemove procedure V-588
ShutDwnStart procedure V-587
SInfoRecord packed record V-447
SInunstall function V-427
SIntRemove function V-427
slot interrupts V-426
Slot Manager V-435
routines V-437
Slot Parameter Block V-439
Slot Resource Table V-437
SlotVInstall function V-567

SlotVRemove function V-567

SmallFract2Fix function V-175

Index V-623

Inside Macintosh
SndAddModifier function V-478
SndChannel record V-477, V-481

SUpdateSRT function V-454
SwapMMUMode procedure V-593

SndControl function

synthesizers V-475
synthetic font V-182
SysBeep procedure V-592
SysEnvirons function V-5
SysEnvRec record V-6
SysError procedure V-572
system environment record V-6
System Error Handler V-571
System file resources V-34
system traps V-603

SndCommand packed record V-483
V-479

SndDisposeChannel function V-479
SndDoCommand function V-479
SndDoImmediate function V-479
SndNewChannel function V-477

SndPlay function V-477
‘snd ‘resource V-476, V-490
SNextsRsrc function

V-443

SNextTypesRsrc function V-443
‘snth' resource

V-476, V-495

SOffsetData function V-453
sound V-19
Sound cdevy V-325
Sound Manager V-473
commands

T

V-482, V-486

routines V-477
SpBlock packed record V-439
SPRAMRecord packed record V-448
SPrimaryInit function V-452
SProcRec record

V-146

SPtrToSlot function V-451
SPutPRAMRec function V-449
SReadByte function V-444
SReadDrvrName function

V-444

SReadFHeader function V-449
SReadInfo function

V-446

SReadLong function V-445
SReadPBSize function

V-453

SReadPRAMRec function V-448
SReadStruct function V-446
SReadWord function V-445
sResource V-437
sResource directory V-437
sResource list V-437
SRsrcInfo function V-442
SSearchSRT function V-454
Start Manager V-347
routines

V-352

Startup V-349
Startup device cdev V-325
Startup process V-422
Startup screen V-121
STElement record

V-262

StopAlert function V-284
StripAddress function V-593
StScrpRec V-265
StyleRun V-261
submenu delay V-24

V-624 Index

SynListHandle global variable V-182

Talk command V-363, V-364
TDftBitsBlk record V-414
TEDispatch V-267
TEGetHeight function V-269
TEGetOffset function V-268
TEGetPoint function V-269
TEGetStyle procedure V-269
TEReplaceStyle procedure V-270
TESetStyle procedure V-269
TestDeviceAttribute function V-124
testing V-28
TEStyleRec V-261
TEStyleTable V-262
TEStylInsert procedure V-268
TEStylNew function V-268
TEStylPaste procedure V-269
text drawing V-81
TextEdit V-259
routines V-267
text mask mode V-83
TextStyle V-265
TGetRotmBlk record V-415
TGetRsIBIk record V-412
TGnlData record V-410
theGDevice V-118
TheMenu global variable V-244
TimeDBRA variable V-352
TimeSCCDB variable V-352
TimeSCSIDB variable V-352
tolerant colors V-155
Toolbox Event Manager V-189
TopMenultem global variable V-249
Transcendental Functions Packages V-595
transfer mode

V-57

Index
Transliterate function V-311
trap macros V-603
TRslRec record V-411
TRslRg record V-411
TSetRsIBIk record V-414
type coercion V-66, V-200

U
universal defprocs V-206
user interface guidelines V-13

V
version 2 pictures V-84
Vertical Retrace Manager V-565
routines V-567
virtual key codes V-190

routines

V-206

WMerCPort V-205
word-description break tables V-309
word-selection break tables V-309
workstation V-522
write command format, AFP V-545
WriteDDP function V-513
WriteLAP function V-513

X, Y
XPP command control block V-549
XPP error reporting V-526
XPP (Extended Protocol Package) driver

V-524, V-527, V-530

access V-533
example V-531
result codes V-550
XPP open session commands

V-528

XPPParamBlock packed record V-535

W
wave table synthesizer V-475
‘wctb' resource

window defproc V-205
Window Manager V-197

V-201, V-204

WinCTab record V-202
window color table

V-203

Zz
Zoom Window

procedure

V-210

Index V-625

This book was written, edited, and composed on a desktop publishing system using

Apple® Macintosh™ computers and Microsoft® Word. Proof and final pages were

produced on the Apple LaserWriter® Plus printer. POSTSCRIPT™, the LaserWriter pagedescription language, was developed by Adobe Systems Incorporated. Color art was
created on a Macintosh II computer and an AppleColor™ high-resolution RGB monitor
using Modern Artist™ software by Computer Friends, Inc. Final color prints were
produced by ColorSet™ from ImageSet™ Corporation.

The text is set in Times® and display type in Helvetica® boldface. Program listings are set
in Apple Courier, a monospaced font.

Inside Macintosh
Welcome to the world of programming for the Macintosh®. No other personal computer has been as
enthusiastically received by the programming community, as the large—and growing—body of Macintosh
software attests. Inside Macintosh provides the guidelines and technical information that you’ll need to
develop Macintosh programs, but many other resources can help speed and simplify your software
development efforts.

Development

Languages

You won’t have to look far to find a development language that suits your specific requirements. A

growing family of Macintosh languages will serve your development needs whether your expertise is in

Pascal, C, Assembler, FORTH, FORTRAN, COBOL, BASIC, Lisp, Modula-2, or one of many others.

And the information in Jnside Macintosh can be applied to any of the Macintosh languages.

The

Certified

Developer

Program

If your primary business is developing software products for commercial markets, we strongly suggest that

you investigate the Apple Certified Developer Program. This program helps developers produce and bring
Macintosh products to market by providing them with support programs, services, and information.
Among them are

¢ Technical Support: Apple’s Developer Technical Support Group offers fast answers by way of
AppleLink® or MCI electronic mail.
¢ Macintosh

Technical Notes: This is a bimonthly package of supplemental technical information.

¢ AppleLink: Through this electronic service, you can get answers to your technical questions and
current information on Apple and third-party products and programs.

¢ Certified Developer Mailings: These monthly mailings keep you informed about Apple’s
products, development tools, and technical and company directions.

¢ The Information Exchange: This information, available in printed and HyperCard® stack form,
lists company-sponsored programs and services available to you and your company.

¢ Outside Apple: This monthly newsletter informs you of developer-oriented Apple groups, programs,
and events.
You must meet certain criteria to get Certified Developer status. You can get an information package and

application by writing to

Developer

Programs

Apple Computer, Inc.
20525 Mariani Avenue, M/S 51-W
Cupertino, CA 95014

APDA

The Apple Programmer’s and Developer’s Association, APDA™, provides technical documentation and
products for all programmers and developers who work on Apple equipment. It provides material that is
unavailable elsewhere (including preliminary documentation of new Apple products). APDA also sells
compilers and other tools from both Apple and third-party sources. For information on joining, write to

APDA
290 SW 43rd Street

Renton, WA

98055

(206) 251-6548

Technical

Notes

Published bimonthly by Developer Technical Support, these notes answer frequently asked questions

through examples and sample code and provide updates, additions, and corrections to the Inside Macintosh
books. They are available through the Certified Developer Program, APDA, and major electronic
information services.

U

=
Apple’ Inside Macintosh
The Official

Publication from

> 62.55 FT

USA

Volume V

Apple Computer, Inc.
Inside Macintosh, Volume V, is a companion to the first four volumes of Inside Macintosh. It

describes the new programming tools available for the Macintosh® II and Macintosh SE computers.

Written by the people at Apple Computer, /nside Macintosh is the definitive source of information
for programmers writing application programs for any of the computers in the Apple Macintosh
family. It includes the following:
* Guidelines for designing a user interface that conforms to the Macintosh standard.

* Descriptions of more than 1,200 ROM- and disk-based routines.

* A description of the Macintosh hardware.

Inside Macintosh is your guide to creating software for the Macintosh. It describes the Pascal

interfaces to the routines and, wherever applicable, gives special information for programming in

assembly language. (If you're using a high-level language other than Pascal, your development
system documentation should tell you how to apply the information in /nside Macintosh.) A typical
chapter describes a related set of routines, such as the Window Manager, and provides key concepts
and background information, hints on which routines you need to learn about and how they fit into

your program, and a detailed description of each routine.

Inside Macintosh consists of six volumes. This volume, Volume \, contains descriptions of hundreds

of changes and additions to the programming tools available on the Macintosh II and SE, including:
* Technical information on using color in your programs.
* Details on how application programs access slot devices.
* Information on the Apple Desktop Bus,’ which provides support for multiple input devices.
+ An overview of the new foreign-language script capabilities.

* Details of enhanced sound generation capabilities.

* Compatibility guidelines to help you write programs that run on several Macintosh computers.

Volume I contains important introductory material and describes the QuickDraw graphics package
and important Managers such as the Resource, Font, and Menu Managers. Volume II complements

Volume I in describing the Managers that perform such basic routines as file and device I/O,

memory management, and interrupt handling. Volume II discusses your program's interface with

the Macintosh Finder?" describes the Macintosh 128K and 512K computers, and provides summaries
of all the Managers and other software described in volumes I through II. Volume IV discusses the
changes introduced by the Macintosh 512K Enhanced and Macintosh Plus computers, including the
Hierarchical File System and the SCSI uate Inside Macintosh X-Ref is an index to Inside Macintosh

and other Macintosh technical boo

About the cover: This design represents a new look for the origina. I | | ll ill il | | | |
Volume V, and the other books in the Apple Technical Library. The contents have not been changed.
Printed in U.S.A.
Apple Computer, Inc.
20525 Mariani Avenue
Cupertino,CA 95014
(408) 996-1010
TLX 171-576

Addison-Wesley Publishing Company, Inc.

9

"780201°177190

ISBN

O-201-177159-6

