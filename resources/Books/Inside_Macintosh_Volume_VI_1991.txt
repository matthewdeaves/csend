er

~~

e

sypemens site

Macintosh, Volumes

{through V, with

information about
system software
version 7.0

ini

eet

i

~—

el

a

—

ee

ee

reer

~~ aoe

-

.

~-

—_—

Inside Macintosh, Volume VI
by Apple Computer, Inc.

—

_

=r

—e

Tg

—_

~"y

LOS=

~~

'

tees

—<_

4>

Name

‘

Icon

=

Arabic

i+!

=F]

Canada

=
*

Cyrillic
*

1

Cyrillic transliterated
Denmark

S|

Sim

Faeroe Islands

=

=

Germany

aE

x

Hebrew

&

&

Japanese Katakana

o

o

Japanese Romaji

£

*

Korean

—

sa

Netherlands, period decimal separator (previously (Ht.))

—

==

Netherlands, comma decimal separator

@

Sd

Roman (U.S.)

=

EI

Spain

|+
+

Swiss Italian

Turkey

a

Turkish, U.S. modified

AR

fi &i

Swiss German

United Kingdom (previously GE)

i

li

#

Gf B

+e

t+

Swiss French

United States

Color Plate I.

Examples of keyboard icons

=

icons

[siz

ie

niaie

=.

a

Color

CloseView

<())

=

Sound

|
Keyboard

Map

a

.

v

ail) See

|i

Color Plate II. A colorized window

PF

Border Style =

f

—
a

Color Plate IV.

Design for black-and-white
monitors first

PF OF
ae ae

x

Hy
3

OP

ANAS

SSS

PFS Ss

Color Plate V. Don’t mimic color effects
in black-and-white designs

Color Plate VI. Use light colors
for large areas

Color Plate IX. A consistent light source
(enlarged for detail)

Color Plate VII. Don’t use bright
colors for large areas

Color Plate X. Inconsistent light sources
(enlarged for detail)

ICN#

ics#

icl4

icl8

Color Plate XI.

ics8

Mask

a

Mask

An icon family

Color Plate XII. Consistently designed

Color Plate XIII. Inconsistently designed

small icons (enlarged for detail)

small icons (enlarged for detail)

GEGRREDTEE

Color Plate XIV. Icons with a black outline
(enlarged for detail)

Color Plate XV. Icons without a black
outline (enlarged for detail)

Color Plate XVI. Apple icon colors (as marked)

Before anti-aliasing

Correctly anti-aliased

+
Color Plate XVII. Correct anti-aliasing (enlarged for detail)

Before anti-aliasing

Color Plate XX.

Incorrectly anti-aliased

Inconsistent use of icon elements (enlarged for detail)

Document

Stationery

6)

&

7

Query document

bs

=

bo

Ly

Oo)

D

nL

bo

a

KIRK

)

LD

Edition

ope,
nh
Extension

af

sil ge

po fe

nS

fe
a

GC]
Control Panels
folder

Color

IS) ERS is

Color Plate XXI. Default system icon families

ga

Portable

(2

fel

7B

ws

ie]

lacsii

a

User Setup

Color Plate XXII. Examples of control panel icons

eg |

File Sharing

Source

Mask

Dest

Result

Color Plate XXIII. Copying with a pixel map as a mask

Color Plate XXIV.

Colorizing

8 bits

Color Plate XXV.

Default color tables

Inside Macintosh.
Volume VI

A
vv

Addison-Wesley

Publishing

Company

Reading, Massachusetts
Menlo Park, California
New York
Don Mills, Ontario
Wokingham, England
Amsterdam
Bonn
Sydney
Singapore
Tokyo
Madrid
Paris
Seoul
Milan
MexicoCity
Taipei
San Juan

@
APPLE COMPUTER, INC.
This manual is copyrighted by Apple or by Apple’s suppliers, with all rights reserved. Under
the copyright laws, this manual may not be copied, in whole or in part, without the written
consent of Apple Computer, Inc. This exception does not allow copies to be made for others,
whether or not sold, but all of the material purchased may be sold, given, or lent to another
person. Under the law, copying includes translating into another language.
The Apple logo
is a registered trademark of Apple Computer, Inc. Use of the “keyboard”
Apple logo (Option-Shift-K) for commercial purposes without the prior written consent of
Aes may constitute trademark infringement and unfair competition in violation of federal
and state laws.
© Apple Computer, Inc., 1991
20525 Mariani Avenue
Cupertino, CA 95014-6299
(408) 996-1010
og

the Apple logo, APDA, AppleLink, AppleShare, AppleTalk, Apple IIGs,

X, EtherTalk,
HyperCard, HyperTalk, ImageWriter, LaserWriter, TvealTalk. Macintosh,
MPW, MultiFinder, SANE, and TokenTalk are registered trademarks

of Apple Computer, Inc.
Apple Desktop
TrueType, and

Bus, Balloon Help, Finder, KanjiTalk, Moof, QuickDraw, ResEdit,
Zhong-Wen Talk are trademarks of Apple Computer, Inc.

Helvetica and Times are registered trademarks of Linotype Company.
ITC Zapf Dingbats is a registered trademark of International Typeface Corporation.
MacPaint is a registered trademark of Claris Corporation.
NuBus is a trademark of Texas Instruments.

PostScript is a registered trademark, and Illustrator is a trademark, of Adobe Systems
Incorporated.
Sony is a registered trademark of Sony Corporation.
UNIX is a registered trademark of UNIX System Laboratories, Inc.
Simultaneously published in the United States and Canada.
ISBN 0-201-57755-0 (book)
ISBN 0-201-57776-3 (boxed edition)
34567 8 9-MU-96959493
Third printing, January 1993

Inside Macintosh

Volume VI

LIMITED

WARRANTY

ON MEDIA

AND REPLACEMENT

ALL IMPLIED WARRANTIES ON THIS MANUAL, INCLUDING IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE, ARE LIMITED IN DURATION TO NINETY (90) DAYS FROM THE
DATE OF THE ORIGINAL RETAIL PURCHASE OF THIS PRODUCT.
Even though Apple has reviewed this manual, APPLE MAKES NO WARRANTY OR
REPRESENTATION, EITHER EXPRESS OR IMPLIED, WITH RESPECT TO THIS
MANUAL, ITS QUALITY, ACCURACY, MERCHANTABILITY, OR FITNESS FOR
A PARTICULAR PURPOSE. AS A RESULT, THIS MANUAL IS SOLD “AS IS,”
AND YOU, THE PURCHASER, ARE ASSUMING THE ENTIRE RISK AS TO ITS
QUALITY AND ACCURACY.
IN NO

EVENT

INCIDENTAL,

WILL

OR

APPLE

BE

LIABLE

CONSEQUENTIAL

FOR

DAMAGES

DIRECT,

INDIRECT,

RESULTING

FROM

SPECIAL,
ANY

DEFECT

OR INACCURACY

IN THIS MANUAL,

even if advised of the possibility of such damages.

THE WARRANTY
IN LIEU OF ALL

AND REMEDIES SET FORTH ABOVE ARE EXCLUSIVE AND
OTHERS, ORAL OR WRITTEN, EXPRESS OR IMPLIED. No Apple

dealer, agent, or employee is authorized to make any modification, extension, or addition to this

warranty.

Some states do not allow the exclusion or limitation of implied warranties or liability for incidental or
consequential damages, so the above limitation or exclusion may not apply to you. This warranty
gives you specific legal rights, and you may also have other rights which vary from state to state.

~
~
=~
—

—

co)
os

~

=
2)

Contents

Chaplero
XX1X

ABBWNRK

et

—

NNNYNNN

WOADAMNN&

WW

BWW

bo RO ROO

KR

WO PO Rho

ee Se

ee
ee
1
!
!

SS

ee
1
'
1

!

!

Sk

1

Ne
'
1
'

ODTOODANAMNHKWNONADAH W

P-3
P-8
P-16

I- 325 4

Figures,

Tables,

1430
‘

pages
A

and

Listings

Preface

About /nside Macintosh
An Overview of the Chapters in Volume VI
A Road Map to Volume VI
1 Introduction to the System Software Version
About This Chapter
About the System Software Version 7.0 Environment
The Cooperative Multitasking Environment
Interapplication Communication
Sharing Data Among Applications
Sending Events Between Applications
Exchanging Message Blocks Between Programs
Remote Data Access
Enhanced User Interface
Sound
TrueType Fonts
Graphics
File Management
Memory Management
Temporary Memory
24-Bit and 32-Bit Addressing
Process Management
Timing Services
Compatibility
Worldwide Development
Communication Over a Network
Hardware Interfaces
Overview of Chapters in This Volume
2 User Interface Guidelines
About This Chapter
User Interface Design Principles
Worldwide Software Development
Cultural Values
Resources
Language Differences
Text Display and Text Editing
Default Alignment of Interface Elements
Keyboards
Fonts
User Documentation
Terminology
The Version 7.0 Environment
User Feedback
Background Notification

7.0 Environment

About This Chapter
About Compatibility
Using Memory Wisely
Using Assembly Language
Accessing Hardware
Using Low-Memory Global Variables
Determining Whether a Trap Is Available
Running in System Software Version 7.0
Allowing Multiple Applications
Supporting Required Apple Events
Removing Font Size Restrictions
Operating With Virtual Memory
Enabling Menus During a Modal Dialog
Coexisting With the System Menus
Creating Movable Modal Dialog Boxes
Creating Pop-Up Menus
Manipulating Dialog Item Lists
Counting Items in a Dialog Item List
Appending Items to a Dialog Item List
Shortening a Dialog Item List

vi

Contents

WN

NYNYNYNYNYYNYY

SWDNADNANHWHLHWNONMNMRK

YN

909 U9'099 Gd Hd G99 Got

NY

TDOODANHLHWWNNMRF

DOW

Gs KINO 'ROWD WD BIND RO RDS BO ee ee

NYNYNYYNYYNYYNYYYNYYYYY

DAADHA

pe

9

Color Design for Version 7.0
General Color Design Guidelines
The Icon Family
Black-and-White Icons
Small Icons
Color Icons
Consistent Use of Icons
Customized Icons
Windows
Window Positions
The Zoom Box and Window Behavior
Dialog Boxes
Modal Dialog Box Behaviors
Movable Modal Dialog Boxes
Keyboard Navigation in Dialog Boxes
Button Labels
Dialog Box Layout
Dialog Box Messages
Standard File Dialog Boxes
Save Changes Dialog Box
Menus
File Menu
Edit Menu
Font Menu
Help Menu
Keyboard Equivalents
Pop-Up Menus
Standard Pop-Up Menus
Type-In Pop-Up Menus
More User Interface Information

He wah GB YO GO tp UO YD M9
NOOCCANNWWN—$ObONIYNUAAUwY

Inside Macintosh, Volume VI

la

el

NO

Oe

WWWWW

1

WW

WWW

YW

3 Compatibility Guidelines

©)
=
=
—

Contents

—
—_

©
—

—

nn

WW
WW
WWWW

HHL
HS1 HHH
HHH
HEH
HH
HHH
HRHRAHLHH
ft
'
'
'
'
!
!
I
1
-§
K.
'
bod
8
Ae.
eh.
ig
S

BBS

Tt
KT
Kee
BRHLRBBEBWWWWWNMNNMNMWNMWNNNN—
— HWW
OND
DTDoOUMM”nAHHRWNK

in

manana
Ree

heE

WW

®

WW

tk

HELL
UARAAAE

FF

8

WWW

OR

BWW
DEAD

OB.

ke

WWW

PDO
WH WW
DBDOOD

ho

UR

WWW

Oe

PY PY PY
OAR

ke

WW

PY

wR

WD

OR

WW

PM PD te
OOS

77

Localizing Macintosh Programs
General Guidelines
Localizing With the Toolbox
Running Macintosh Programs Under A/UX
How the A/UX Toolbox Works
Using the A/UX Toolbox
A/UX Compatibility Guidelines
About the Gestalt Manager
Using the Gestalt Manager
Determining Features of the Operating Environment
Determining Whether Gestalt Is Available
Interpreting Gestalt Responses
Interpreting Responses to Environmental Selectors
Interpreting Responses to Informational Selectors
Adding Gestalt Selectors
Modifying Gestalt Selectors
Specifying Gestalt Selector Functions
Gestalt Manager Routines
Getting Information About the Operating Environment
Adding Selector Codes
Modifying Selector Codes
Summary of the Gestalt Manager
Summary of the Window Manager
Summary of the Control Manager
Summary of the Dialog Manager
4 The Edition Manager
About This Chapter
About the Edition Manager
Publishers, Subscribers, and Editions
Using the Edition Manager
Receiving Apple Events From the Edition Manager
Creating the Section Record and Alias Record
Saving a Document Containing Sections
Opening and Closing a Document Containing Sections
Reading and Writing a Section
Formats in an Edition
Opening an Edition
Format Marks
Reading and Writing Edition Data
Closing an Edition
Creating a Publisher
Creating the Edition Container
Opening an Edition Container to Write Data
Creating a Subscriber
Opening an Edition Container to Read Data
Choosing Which Edition Format to Read
Using Publisher and Subscriber Options
Publishing a New Edition While Saving or Manually
Subscribing to an Edition Automatically or Manually
Canceling Sections Within Documents
Locating a Publisher Through a Subscriber
Contents

Vil

HHL

vill

DODNANMNNN
OONK
OMOANRWNNDTOTADMAMA W
WHR

DAA

A

AAA

AAA

AAA

!

—

AAA

AIAN

—

PAH

HADAHLHAAADAHAHLAHLAA
it
ct

a

DHLa

HSHte

ABH
ine
on
i
ke

aS

HEH

RRAKRA

OCO W
$$ TDOWOONDADNENNNOWMr>IW

Inside Macintosh, Volume VI

Renaming a Document Containing Sections
Displaying Publisher and Subscriber Borders
Text Borders
Spreadsheet Borders
Object-Oriented Graphics Borders
Bitmapped Graphics Borders
Duplicating Publishers and Subscribers
Modifying a Subscriber
Relocating an Edition
Customizing Dialog Boxes
Subscribing to Non-Edition Files
Getting the Current Edition Opener
Setting an Edition Opener
Calling an Edition Opener Procedure
Opening and Closing Editions
Listing Files That Can Be Subscribed To
Reading From and Writing to Files
Calling a Format I/O Procedure
Edition Manager Routines
Initializing the Edition Manager
Creating and Registering a Section
Creating and Deleting an Edition Container
Setting and Locating a Format Mark
Reading in Edition Data
Writing out Edition Data
Closing an Edition After Reading or Writing
Displaying Dialog Boxes
Locating a Publisher and Edition From a Subscriber
Edition Container Formats
Reading and Writing Non-Edition Files
Summary of the Edition Manager
5 The Event Manager
About This Chapter
About the Event Manager
Introduction to Events
Low-Level Events
Operating-System Events
High-Level Events
Event Processing
The Event Loop
Event Masks
Switching Contexts
Specifying Memory Requirements and Scheduling Options
The Structure of a 'SIZE' Resource
Creating a 'SIZE' Resource
Using the Event Manager
Receiving Low-Level Events
Responding to Operating-System Events
Receiving High-Level Events
Identifying High-Level Event Senders and Receivers
Sending High-Level Events

Contents

2)

Contents

o
=}

~s
@

~

lV

OWOoOond

WN

AAA

WWD
NYY
PY
tw

AAA

DPD DADADADRDAD

AAD

DADARDADA

DAD

'

t

1

'

'

'

'

DADADDADADRDADADDADDNDD

'
1
1
'
I
NDNDDNDNDANODO
UYADDAAUUAMNUWAAARALEEREOHWHOHWHHHNYDNN—H|
'
1
1
1
1
1
SGUIDRhBONUARHOHIUIADENHNSHDIANDDOSDAANUCERODADUMAW

IW

AAA

~2)

N
=

71
71
74
-75

Requesting Return Receipts
Responding to Events From Other Applications
Searching for a Specific High-Level Event
Event Manager Routines
Receiving Events
Sending Events
Receiving a Specific High-Level Event
Converting Process Serial Numbers and Port Names
Summary of the Event Manager
6 The Apple Event Manager
About This Chapter
About the Apple Event Manager
Introduction to Apple Events
Types of Apple Events
Components of Apple Events
Data Structures Within Apple Events
Responding to Apple Events
Requesting Services Through Apple Events
Using the Apple Event Manager
Accepting an Apple Event
Installing Entries Into the Apple Event Dispatch Tables
Handling the Required Apple Events
Required Apple Events
Handling the Open Application Event
Handling the Open Documents Event
Handling the Print Documents Event
Handling the Quit Application Event
Handling Apple Events Sent by the Edition Manager
Handling the Create Publisher Event
Getting Data out of an Apple Event
Getting Data out of a Parameter
Getting Data out of an Attribute
Getting Data out of a Descriptor List
Writing Apple Event Handlers
Replying to an Apple Event
Disposing of Apple Event Data Structures
Interacting With the User
Creating an Apple Event
Adding Parameters to an Apple Event
Specifying a Target Address
Sending an Apple Event
Dealing With Timeouts
Writing an Idle Function
Writing a Reply Filter Function
Writing and Installing Coercion Handlers
The Application Died Event
Apple Event Manager Routines
Creating and Managing the Apple Event Dispatch Tables
Dispatching Apple Events
Getting Parameters and Attributes From Apple Events
Counting the Items in Descriptor Lists

Contents

ix

ADDADADARPADADADSY
OODOmMmWDnDNDmDDmDono~
OWOdONYAINRWNOW
Wr

Inside Macintosh, Volume VI

-96
6-98
6-99
6-100

6-101

nd

a

Mana

ad

d

BB

SE ed Sd a

Bd

ed a

dd

id tes

bo bb to wh th

ta

a

dd

ad ead ed

ie do 1 I ie maga

ad

ed

A hE

SAUDWONNYKOOINNDMHBPWNHNODABHWNADAHNOAA
HAW

6-103
6-105

x

Getting Items From Descriptor Lists
Getting Data and Keyword-Specified Descriptor Records From AE Records
Requesting User Interaction
Requesting More Time to Respond to Apple Events
Suspending and Resuming Apple Event Handling
Creating Apple Events
Creating and Duplicating Descriptor Records
Creating Descriptor Lists and AE Records
Adding Items to Descriptor Lists
Adding Data and Keyword-Specified Descriptor Records to AE Records
Adding Parameters and Attributes to Apple Events
Sending Apple Events
Getting the Sizes and Descriptor Types of Descriptor Records
Deleting Descriptor Records
Deallocating Memory for Descriptor Records
Coercing Descriptor Types

Creating and Managing the Coercion Handler Tables

Creating and Managing the Special Handler Tables
Summary of the Apple Event Manager

7 The Program-to-Program Communications Toolbox
About This Chapter
About the PPC Toolbox
Ports, Sessions, and Message Blocks
Setting Up Authenticated Sessions
Using the PPC Toolbox
PPC Toolbox Calling Conventions
Specifying Port Names and Location
Names
Opening a Port
Browsing for Ports Using the Program Linking Dialog Box
Obtaining a List of Available Ports
Preparing for a Session
Initiating a PPC Session
Receiving Session Requests
Accepting or Rejecting Session Requests
Exchanging Data During a PPC Session
Reading Data From an Application
Sending Data to an Application
Ending a Session and Closing a Port
Invalidating Users
PPC Toolbox Routines
The PPC Toolbox Parameter Block and Completion Routine
Initializing the PPC Toolbox
Using the Program Linking Dialog Box
Obtaining a List of Ports
Opening and Closing a Port
Starting and Ending a Session
Receiving, Accepting, and Rejecting a Session
Reading and Writing Data
Locating a Default User and Invalidating a User
Summary of the PPC Toolbox

Contents

~

=
—

Contents

—
oo

7.
—

—_
_

CW C
WWODOWDWDDDADDDDADDDADABDWDHOHWOW
WWW
WOW
BRWWWNR
REE eRe
HHH
pp
DNNDNNDMNMNAMAMNnnnb
KE RP OOOOOMIDANWNAW
COONAN BBRNNHWARBWHAO
SWMNWONDNDHNNMR
NK

BS SG Ng a Wa thst ty sea GO'GO'GO' ge Go O'goign Go

7

8 The Data Access Manager
About This Chapter
About the Data Access Manager
The High-Level Interface
Sending a Query Through the High-Level Interface

Retrieving Data Through the High-Level Interface

The Low-Level Interface
Sending a Query Through the Low-Level Interface
Retrieving Data Through the Low-Level Interface
Comparison of the High-Level and Low-Level Interfaces
Using the Data Access Manager
Executing Routines Asynchronously
General Guidelines for the User Interface
Keep the User in Control
Provide Feedback to the User
Using the High-Level Interface
Writing a Status Routine for High-Level Functions
Using the Low-Level Interface
Getting Information About Sessions in Progress
Processing Query Results
Getting Query Results
Converting Query Results to Text
Creating a Query Document
User Interface Guidelines for Query Documents
Contents of a Query Document
Query Records and Query Resources

Query Records
Query Resources
Writing a Query Definition Function
Data Access Manager Routines
Asynchronous Execution of Routines
Initializing the Data Access Manager
High-Level Interface
Handling Query Documents
Handling Query Results
Low-Level Interface
Controlling the Session
Sending and Executing Queries
Retrieving Results
Installing and Removing Result Handlers
Summary of the Data Access Manager

\0O \O
\O
OWOOwOo
rE
Trrri
Nee
W
NW
L
ODN
OD

9

The

Finder

Interface

About This Chapter

About the Finder Interface
Finder-Related Resources

Creators, File Types, and the Signature Resource
Icon Resources
File Reference Resources
The Bundle Resource
The Size Resource

Contents

xi

9

9

0

0

0

OO

10

0

AnntawbpAR EL
=ordnR-CHORUN

is

10 NO NO SO

NO

SO NO

oo
POBPOOPGeooo

bBRwbwwwHwWNYONNHNNNWD OMNPh

HW O
NOTODHWNOODADA

Inside Macintosh,

Volume VI

Messages When the Finder Can’t Find Your Application
Version Resources
How and When the Finder Launches Your Application
Finder-Related Changes to the User Interface
Stationery Pads
Edition Icons
Customized Icons
Aliases
Resolving Alias Files
Desk Accessories
Fonts, Sounds, and Other Movable Resources

Balloon Help for Icons
Finder Information in the Volume Catalog
The System Folder and Its Related Directories
Folder Organization
Finding Directories
The Desktop Database
History of the Desktop Database

Using the Desktop Database

Desktop Manager Routines
Locating and Opening the Desktop Database
Reading the Desktop Database
Adding to the Desktop Database
Deleting Entries From the Desktop Database
Manipulating the Desktop Database Itself
Summary of the Finder Interface
1 0

Control

Panels

10-3
10-3
10-4
10-5
10-6
10-7
10-8
10-8
10-10
10-12
10-12
10-13
10-13
10-13
10-13
10-14
10-14
10-14
10-28
10-29

About This Chapter

Xl

Contents

About Control Panels

Writing Control Panel Files

About the Monitors Control Panel

Designing an Extension for the Monitors Control Panel
The ‘card’ Resource
The 'mntr' Resource
The Monitor Function

Messages to the Monitor Function

The
The
The
The
The
The

'RECT' Resource
'DITL' Resource
'ICON' and ‘cicn' Resources
'vers' Resources
'STR#' Resource
'gama' Resources

The 'FREF', 'BNDL', Icon Family, and Signature Resources
The 'INIT' Resource

A Sample of an Extension to the Monitors Control Panel
Including Another Control Panel Definition in a Monitors Extension File
Summary of the Extension File for the Monitors Control Panel

=}
—_

Contents

11 The Help Manager
About This Chapter
About the Help Manager
Help Balloon Display
Default Help Balloons for Menus, Windows, and Icons
Using the Help Manager
Providing Text or Pictures for Help Balloons
Defining the Help Balloon Content
Using Clear, Concise Phrases
Using Active Constructions
Using Parallel Structure
Using Consistent Terminology
Defining the Help Balloon Position
Specifying the Format for Help Balloon Content
Specifying Options in Help Resources
Providing Help Balloons for Menus
Providing Help Balloons for Items in Dialog Boxes and Alert Boxes
Providing Help Balloons for Window Content
Help Balloons in Static Windows
Help Balloons in Dynamic Windows
Overriding Help Balloons for Application Icons
Overriding Other Default Help Balloons
Adding Your Own Menu Items to the Help Menu
Writing Your Own Balloon Definition Function
Help Manager Routines
Determining Whether Help Is Enabled
Determining Whether a Help Balloon Is Showing
Displaying and Removing Help Balloons
Displaying a Help Balloon
Using Your Own Menu Definition Procedure
Removing a Help Balloon
Using Your Own Tip Function
Adding Items to the Help Menu
Getting and Setting the Font Name and Size
Getting and Setting Information for Help Resources
Getting the Dimensions of a Help Balloon
Getting the Content of a Help Balloon
Summary of the Help Manager
12 The Font Manager
About This Chapter
About the Font Manager
Font Terminology
Font Measurements
Font Scaling
How the Font Manager Renders TrueType Fonts
Using the Font Manager
Adding Font Sizes and Names to the Menu
Storing a Font Name in a Document
Using TrueType Fonts in Preference to Bitmapped Fonts
Preserving the Glyph’s Shape

Contents

xili

-

=

‘<)

_—

—
—
7)

4

Inside Macintosh,

Volume VI

12-18
12-18
12-19
12-21
12-22

Font Manager Routines
Choosing TrueType Fonts Over Bitmapped Fonts
Scaling Fonts
Erasing the Font Manager’s Memory Caches
Summary of the Font Manager

13-3
13-3
13-3
13-6
13-7
13-7
13-10
13-10
13-11
13-12
13-12
13-13
13-14
13-15
13-15
13-16
13-16
13-16
13-18
13-18
13-18
13-19
13-20
13-21
13-24

13 The Resource Manager
About This Chapter
Resources
Resource Types
Resource [Ds
Definition Procedures
Font Families and Scripts
Resources in the System File
System Icons
Document and Application Icons
Folder Icons
System Folder Icons
Desktop Icons
Standard File Package Icons
User Information Resources
Packages
Function Key Resources
Using the Resource Manager
Using Partial Resources
Creating and Opening Resource Files
Storing Fonts in a Resource Fork
Resource Manager Routines
Creating Resource Files
Opening Resource Files
Reading and Writing Partial Resources
Summary of the Resource Manager
1 4

Worldwide

About This Chapter

Software

About Worldwide Software

Overview

The Graphic Representation of Languages
Localized Versions of the Macintosh System Software
Multiple Script Systems and Multiple Languages on the Macintosh Computer
Identifying Scripts, Languages, and Regions
About the Script Management System
About the Script Manager
Local and Global Variables
Style Runs and Higher-Level Text Organization
Tokens
Date Conversion
Geographic Information
Number Conversion
About the International Utilities Package
About the International and Keyboard Resources
About the Macintosh Script Systems

xiv

Contents

Contents

L 2
~
—
~

—

i)
—_
—

—_:

<2]

14-16
14-19
14-19
14-20
14-21
14-2]
14-23
14-25
14-25
14-26
14-26
14-27
14-27
14-27
14-27
14-28
14-28
14-28
14-28
14-29
14-29
14-30
14-30
14-31
14-32
14-32
14-33
14-33
14-33
14-34
14-34
14-35
14-35
14-35
14-36
14-36
14-36
14-37
14-37
14-37
14-39
14-39
14-40
14-40
14-4]
14-43
14-43
14-44
14-45
14-45
14-45
14-46

The Script Management System and Related Worldwide Components
Worldwide Control Panels and Desk Accessory
Installing and Removing Script Systems, Keyboards, and Fonts
Using the Keyboard Menu
Selecting Keyboard Layouts
Distinguishing Scripts
Keyboards
Fonts
Localization
Sorting
Primary or Secondary Order
Expansion
Contraction
Ignorable Characters
Exceptional Words
Formats
Date and Time
Currency and Measurement
Calendars
Numbers
An Introduction to Scripts
Character Representation
Text Direction
Contextual Forms
Diacritical Marks
Uppercase and Lowercase Characters
Character Reordering
Word Demarcation
Alignment and Justification of Text
Representing Scripts on the Macintosh
Character Set Encoding
Character Input
Composition Rules
Text Manipulation
Text Rendering
Using the Script Manager
Determining the Features of the Script Manager
Initializing the Script Manager
Creating Simple Script Systems
Calling the Script Manager
Overview of the Script Manager Routines
Checking and Modifying Global and Local Variables
Accepting Implicit Script Codes
Verbs for GetScript and SetScript
Verbs for GetEnvirons and SetEnvirons
Checking and Setting System Variables
Setting the Active Keyboard Script
Obtaining Script Information
Obtaining Character Information
Manipulating Text
Drawing and Editing Text
Formatting Text

Contents

XV

Inside Macintosh,

Volume VI

14-47
14-47
14-47
14-48
14-48
14-48
14-48
14-48
14-49
14-49
14-49
14-49
14-50
14-50
14-5]
14-55
14-58
14-59
14-60
14-61
14-62
14-64
14-65
14-68
14-71
14-72
14-72
14-73
14-73
14-74
14-74
14-75
14-75
14-76
14-77
14-78
14-79
14-80
14-81
14-82
14-85
14-86
14-87
14-90
14-9]
14-92
14-95
14-96
14-98
14-98
14-99
14-100
14-100
14-10]

Modifying Text
Substituting Text
Truncating Text
Lexically Interpreting Different Scripts
Date and Time Utilities
Converting Worldwide Dates and Times
Converting Long Dates
Modifying and Verifying Date and Time Records
Reading and Storing Locations
Number Utilities
Converting to and From Canonical
Number Formats
Working With Formatted Numbers
Script Manager Routines
Localizing Word Selection and Line Break Tables
Defining Word Boundaries and Line Breaks
Determining Word Selection: An Example
Optimized Word Break Tables
Truncating Text
Substituting Text
Substituting and Truncating Text
Converting Case and Stripping Diacritical Marks
Handling Justified Text
Providing for Spacing Between Multiple Style Runs
Justifying Text on the Roman Script System
Using the International Utilities Package Routines
Overview of the International Utilities Package Routines
Comparing Strings
Modifying the Standard String Comparison
Facilitating Interscript Sorting Order
Accessing the International Resources
Localizing Dates, Times, and Metric Information
International Utilities Package Routines
Script and Language Codes
Manipulating the ‘itl2' and 'itl4' Resources
Specifying Resource Handles Explicitly
Determining Interscript Sorting Order
Using the International and Keyboard Resources
Enhancements to International Resources
The ‘itlc' Resource
The 'itlm' Resource
The ‘itlb' Resource
The ‘itl0' Resource
The ‘itll’ Resource
The ‘itl2' Resource
The ‘itl2' Resource Header
The 'itl4' Resource
Keyboard Types and Modifier Bits
The 'KCHR' Resource
The 'kcs#', 'kcs4', and 'kcs8' Resources
The 'KSWP' Resource
The ‘itlk' Resource
Key Caps and the 'KCAP' Resource
Dead-Key Feedback
The 'KCAP' Resource

xvi

Contents

(
4
-_

=
—

Contents

—

_
7)

—
os

-~

i? 2)

14-102
14-102
14-102
14-103
14-104
14-104
14-104
14-105
14-107
14-107
14-107
14-108
14-109
14-109
14-109
14-110
14-110
14-11]
14-133
14-138

15-3
15-3

Localizing to Other Languages and Regions
Using Resources
Text and Dialog Translation Tips
Adapting Text Operations
Using Fonts
Avoiding Special Character Codes as Delimiters
Using the Standard Roman Character Set
Adapting Keyboard Equivalents
Modifying the Representation of Dates, Times, and
Writing Software for Other Scripts
Working With Fonts
Working With Character Codes
Working With Text Direction
Synchronizing Keyboards and Fonts
Handling Numbers
Identifying Keywords and Tokens
Possible Printing Problems
Summary of the Script Manager
Summary of the International Utilities Package
Summary of the International Resources

Numbers

15 TextEdit

About This Chapter
About TextEdit
Mixed-Directional Text
Highlighting
Mouse-Down Regions
Dual Carets
Caret Movement Across Direction Boundaries
Font and Keyboard Synchronization
Double-Byte Characters
Vertical Movement of the Caret
Arrow Key Actions for Selected Text
Caret Position at Line Ends
Word Selection and Line Breaks
Accurate Line Measurement
TextEdit and TrueType Fonts
Using TextEdit
Determining the Version of TextEdit
Customizing TextEdit’s Features
Measuring the Width of Components of a Line
Defining Word Boundaries
Controlling Outline Highlighting, Text Buffering, and Inline Input
Setting Left Alignment for Right-to-Left Directional Scripts
Using WordRedraw for Line Calculations
Using the lineStarts Array to Determine Line Length
Using TextEdit’s Default Click Procedure
TextEdit Routines
Outline Highlighting, Text Buffering, and Inline Input
Outline Highlighting
Text Buffering
Inline Input
Contents

xvil

Inside Macintosh,

Volume

VI

15-25
15-26
15-26
15-28
15-29
15-29
15-31]
15-3]
15-32
15-34
15-36
15-36
15-37
15-40

Customizing TextEdit
Replacing the End-of-Line Routine
Replacing the Measuring Routines
Replacing the Drawing Routine
Replacing the Hit Test Routine
Replacing the Word Breaking Routine
Backspacing to the Beginning of a Style
Determining the Position of an Ambiguous Offset
Toggling a Style
Determining Styles Across a Selection
Setting Styles in TextEdit’s Scrap Record
Determining the Number of Styles
TextEdit Data Structures
Summary of TextEdit

16-3
6-3
16-6

16 Graphics Overview
About This Chapter
About Macintosh Graphics
The Components of Macintosh Graphics

16-6
16-8
16-9
16-9
16-10
16-11
16-12
16-13
16-15
16-16
16-16
16-18
16-18
16-19
16-20

The Interface
The Video Card and Screen
The Major Data Structures
The RGB Color Record
Color Collections
The Pixel Map Record
Port Characteristics: The Color GrafPort Record
Device Characteristics: The Graphics Device Record
Graphics Initialization
The Graphics Path
How Indexed Pixels Work
How Direct Pixels Work
Determining the QuickDraw Version
What Else to Read
Summary of Graphics Data Types

7-3
7-3
7-4
7-4
17-6
17-10
17-11
17-12
17-12
17-16
17-16
17-17
17-17
17-18

17 Color QuickDraw
About This Chapter
About Color QuickDraw
Direct Pixels
Pixel Map Record Extensions
Direct Pixel Values
Writing Compatible Graphics Applications
Using Color QuickDraw
Manipulating Pixel Map Images
Copying With Masks
Colorizing
Transfer Modes
Dithering
Resizing Images
Luminance Mapping

XVili

Contents

16-6

QuickDraw

Contents

17-18
17-19
17-19
17-19
17-20
17-20
17-21
17-21
17-21
17-24
17-25
17-25
17-25
17-25
17-26
17-26
17-27
17-28
17-28
17-29

Image Resolution
Displaying Variable-Resolution Pixel Maps and Pictures
Exporting Pixel Map Records
Converting a Bitmap to a Region
Determining Whether Drawing Is Complete
Extensions to the Version 2 Picture Format
Font Name
Line Justification
Direct Pixel Images
Sample Extended Version 2 Picture
Color QuickDraw Routines
Creating an Extended Version 2 Picture
Creating Regions From Bitmaps
Copying Pixel Map Images
Determining Whether QuickDraw Has Finished Drawing
Reporting Data Structure Changes
Obtaining Intermediate Colors
Interpreting New QDError Result Codes
Using a Custom Color Search Function
Summary of Color QuickDraw
18 The Picture Utilities Package
About This Chapter
About the Picture Utilities Package
Using the Picture Utilities Package
Getting Color Information
Collecting Information From Multiple Pixel Maps or Pictures
Storing Information: The Picture Information Record
Picture Utilities Package Routines
Collecting Information From a Single Image
Collecting Information From Multiple Images
Creating Custom Color-Sampling Methods
Summary of the Picture Utilities Package
19 The Color Picker Package
About This Chapter
About the Color Picker Package
Color Models
The RGB Model
The CMYK Model
The HLS and HSV Models
Color Models in the Dialog Box
Using the Color Picker Package
Presenting the Color Picker Dialog Box
Using Conversion Facilities
Color Picker Package Routines
Displaying the Color Picker Dialog Box
Converting Between Color Models
Converting Between SmallFract and Fixed Values
Summary of the Color Picker Package
Contents

XIX

~
~
—
~
—

‘<

—
~
=
is

4

WY WV
WNWNNMWNNN
SeeeeeP
SPSS
WW
OMWMAAAYDMALH

Inside Macintosh,

Volume

VI

20 The Palette Manager
About This Chapter
About the Palette Manager
Palettes
Color Usage Categories
Changing the Color Environment
Restoring the Color Environment
Using the Palette Manager
Working With Color Usage Categories
Courteous Colors
Tolerant Colors
Animated Colors
Displaying Animated Colors on Direct Devices
Explicit Colors
Inhibited Colors
Combined Usage Categories
Creating Palettes
Assigning Colors to a Palette
Creating a Palette in a Resource File
Assigning a Default Palette to an Application
Linking a Color Table to a Palette
Associating One Palette With Many Ports
Palette Manager Routines
Initializing the Palette Manager
Initializing and Allocating Palettes
Interacting With the Window Manager
Drawing With Color Palettes
Animating Color Tables
Manipulating Palettes and Color Tables
Manipulating Palette Entries
Summary of the Palette Manager
21
The Graphics Devices Manager
About This Chapter
About the Graphics Devices Manager
Offscreen Graphics
Using the Graphics Devices Manager
Offscreen Graphics World Flags
Example of Offscreen Graphics Code
Advanced Features of the Graphics Devices Manager
The Graphics Device Record
The 'scrn' Resource
Setting a Device’s Pixel Depth
Graphics Devices Manager Routines
High-Level Routines
Creating a Graphics World
Working With a Graphics World’s Pixel Map
Updating the Graphics World
Setting and Retrieving the Graphics World
Disposing of a Graphics World
Low-Level Routines
Supporting the Offscreen Graphics World

XX

Contents

—,
=
~
_
<7]
~
=
~

Contents

—_

2

MMMM
bd Yo

Managing the Graphics Device Record
Summary of the Graphics Devices Manager
22 The Sound Manager
About This Chapter
About the Sound Manager
Introduction to Sound
Sound Synthesizers
The Square-Wave Synthesizer
The Wave-Table Synthesizer
The Sampled Sound Synthesizer
Sound Commands
Sound Channels
Multiple Channels of Sound
Sound Compression and Expansion
Continuous Play From Disk
Sound Recording
Sound Storage Formats
Sound Resources
The Format | 'snd ' Resource
The Format 2 'snd ' Resource
Sound Files
Chunk Organization and Data Types
The Form Chunk
The Format Version Chunk
The Common Chunk
The Sound Data Chunk
Reading and Writing Sound Files
Using the Sound Manager
Playing 'snd ' Resources
Allocating Sound Channels
Initializing Sound Channels
Releasing Sound Channels
Determining Features of Synthesizers
Playing Frequencies
Playing Sampled Sounds
Installing Voices Into Channels
Manipulating a Sound That Is Playing
Flushing Sound Channels
Pausing and Restarting Sound Channels
Synchronizing Sound Channels
Managing the CPU Load
Producing an Alert Sound
Compressing and Expanding Sounds
Playing Sampled Sounds From Files
Playing an 'snd ' Resource From Disk
Playing a File From Disk
Playing Selections
Recording Sounds Through the Sound Input Dialog Box
Recording Sounds Directly From a Device
Defining a Sound Input Completion Routine
Defining an Interrupt Routine
Getting and Setting Sound Input Device Information
Contents

xxi

d

Inside Macintosh, Volume VI

Go GW be

NY WY
MMNMNMNMNM

G2 G2 G2 G2 Ye G

WW
OOMmAMNFL

22-68
22-69
22-69
22-70
22-71
22-72
22-74
22-76
22-77
22-79
22-79
22-81
22-82
22-82
22-87
22-88
22-90
22-91
22-92
22-94
22-94
22-94
22-98
22-99
22-101
22-102
22-103

Obtaining Information About Sound Features
Obtaining Information About Available Sound Features
Obtaining Version Information
Obtaining Information About a Single Sound Channel
Obtaining Information About All Sound Channels
Using Double Buffers
Setting Up Double Buffers
Writing a Doubleback Procedure
Specifying Callback Routines
Sound Manager Routines
Playing Sound Resources
Allocating and Releasing Sound Channels
Linking Synthesizers to Sound Channels
Sending Commands to a Sound Channel
Obtaining Information
Playing From Disk
Managing Double Buffers
Compressing and Expanding Audio Data
Recording Sounds
Manipulating Sound Input Devices
Opening and Closing Sound Input Devices
Recording Sounds Directly From Sound Input Devices
Manipulating Device Settings
Constructing Sound Resource and File Headers
Registering Sound Input Devices
Converting Between Milliseconds and Bytes
Summary of the Sound Manager
23 The Time Manager
About This Chapter
About the Time Manager
Time Manager Versions
The Original Time Manager
The Revised Time Manager
The Extended Time Manager
Other Time-Related Facilities
The TickCount Function
The Delay Function
The Vertical Retrace Manager
Using the Time Manager
Installing and Activating Task Records
Using Application Global Variables in Tasks
Performing Periodic Tasks
Computing Elapsed Time
Time Manager Routines
Summary of the Time Manager
24
The Notification Manager
About This Chapter
About the Notification Manager
Using the Notification Manager
Creating a Notification Request
Contents

a

a!

~»
a

Contents

_—
—_

=

©
—

—

mn
n

Defining a Response Procedure
Installing a Notification Request
Removing a Notification Request
Notification Manager Routines
Summary of the Notification Manager

tN
MN ty
MANMNNYY
AN
A
t WN Den
1
4
& & WW
= \O On

25 The File Manager

25-10
25-10
25-11
25-11
25-12
25-12
25-15
25-17
25-20
25-25
25-26
25-28
25-29
25-29
25-30
25-31
25-31
25-34
25-34
25-34
25-35
25-37
25-37
25-40
25-42
25-43
25-44
25-45
25-47
25-48
25-50
25-52
25-54

About This Chapter
About the File Manager
Identifying Files, Directories, and Volumes
File System Specifications
The Evolution of File Specification Strategies
Limitations on MFS Disks
A Simpler Safe-Save Strategy
New Special-Purpose Features
A Quick, Thorough Catalog Search
File IDs
Shared Environments
Remote Mounting
Privilege Information in Foreign File Systems
Using the File Manager
Using FSSpec Records
Updating Files
Searching a Volume
Tracking Files With File IDs
Mounting Volumes Programmatically
Manipulating Privilege Information in Foreign File Systems
High-Level File Manager Routines
Routines That Use FSSpec Records
Making FSSpec Records
Exchanging the Data in Two Files
Functions Modified to Accept FSSpec Records
Opening a Data Fork
Managing HFS
Functions New With HFS
MEFS Functions Modified to Accommodate Directory IDs
Low-Level File Manager Routines
Reading Volume Information
Searching a Catalog
Creating FSSpec Records
Swapping Data Between Two Files
Creating and Using File IDs
Functions for Manipulating File IDs
Functions Changed to Accommodate File IDs
Mounting Volumes
Accessing Privilege Information in Foreign File Systems
Opening Data Forks
Summary of the File Manager

Contents

XXL

Inside Macintosh, Volume VI

1

~~]

aa

)

NH NYY
MMM
WY WL
ANMNNMNMNMNMNN
SAYA
!
'
y ed ad ad eS eS
—
Ww
Nn NNNMN
KK CODmDMDDHAVAHA

26-3.
26-3
26-4
26-5
26-9
26-10
26-11
26-20
26-20
26-20
26-22
26-25

27-20
27-21
28-3
28-4
28-6
28-7
28-9
28-9
28-10
28-11
28-12
28-12
28-13
28-14
28-15
28-16
28-16
28-16
xxiv

26 The Standard File Package

About This Chapter
About the Standard File Package
Using the Standard File Package
Presenting the Default Interface
Customizing Your Interface
Customized Dialog Boxes
Callback Routines
Compatibility With Earlier Procedures
Standard File Package Routines
Saving Files
Opening Files
Summary of the Standard File Package
27 The Alias Manager
About This Chapter
About the Alias Manager
About Alias Records
Search Strategies for Resolving Alias Records
Fast Search
Exhaustive Search
Using the Alias Manager
Creating Alias Records
Resolving Alias Records
ResolveAlias
MatchAlias
Maintaining Alias Records
Getting Information About Alias Records
Customizing Alias Records
Alias Manager Routines
Creating and Updating Alias Records
Resolving and Reading Alias Records
Filtering Possible Targets
Summary of the Alias Manager

28

Memory

Management

About This Chapter
About Memory Management
Dividing Memory Among Multiple Applications
Extending an Application’s Available Memory
Extending the Operating System’s Available Memory
Controlling the System Memory Settings
About the Memory Manager
Using Master Pointers
Using Window and Control Definition Functions
Manipulating 24-Bit and 32-Bit Memory Addresses
Using the Memory Manager
Setting and Restoring the A5 Register
Manipulating AS Without MPW
Memory Manager Routines
Setting and Restoring the A5 World
Manipulating Memory Addresses
Contents

(

o
—

Contents

OOOIUANAW

NOONE

Nr NG? NNO

tN
ONNNMNNNNN

YD

ND: ND

28-17
28-18
28-19
28-20
28-21
28-21
28-21
28-23
28-23
28-24
28-25
28-25
28-25
28-26
28-26
28-26
28-26
28-28
28-29
28-30
28-30
28-31
28-31
28-32
28-33
28-33
28-33
28-36
28-36
28-37
28-37
28-37
28-37
28-38
28-38
28-39
28-40
28-41

About Virtual Memory
Using Virtual Memory
Holding and Releasing Memory
Locking and Unlocking Memory
Obtaining Information About Virtual Memory
Information About the System Memory Configuration
Information About Page Mapping
Deferring User Interrupt Handling
Debugger Support Under Virtual Memory
Bus Error Vectors
Special Nonmaskable Interrupt Needs
Supervisor Mode
The Debugging State
Keyboard Input
Page States
Virtual Memory Routines
Holding and Releasing Pages
Locking and Unlocking Pages
Obtaining Page-Mapping Information
Deferring User Interrupt Handling
Determining Which Debugger Functions Are Present
Determining Whether Paging Is Safe
Locking and Unlocking Memory With Caching Enabled
Entering and Exiting the Debugging State
Obtaining Keyboard Input
Determining Page State
About Temporary Memory
Using Temporary Memory
Allocating Temporary Memory
Locking Temporary Memory
Unlocking Temporary Memory
Releasing Temporary Memory
Determining Features of Temporary Memory
Temporary Memory Routines
Requesting Temporary Memory
Locking and Unlocking Temporary Memory
Freeing Temporary Memory
Summary of Memory Management
29 Process Management
About This Chapter
About Process Management
How the Process Manager Creates Processes
How the Process Manager Schedules Processes
How Your Application Specifies Scheduling Options
Using the Process Manager
Opening or Printing Files Based on Finder Information
Getting Information About Other Processes
Launching Other Applications
Specifying Launch Options
Controlling Launched Applications
Launching Desk Accessories
Contents

XXV

—

_

@
—
~
~~
~—D

4

Inside Macintosh,

29-16
29-17
29-20
29-24

Volume

VI

Process Manager Routines
Getting Process Information
Launching Applications and Desk Accessories
Summary of Process Manager Routines
30 The Slot Manager
About This Chapter
About the Slot Manager
Card Initialization
Using the Slot Manager
Enabling and Disabling NuBus Cards
Enabling and Disabling SResource Data Structures
Searching for Disabled SResource Data Structures
Restoring Deleted SResource Data Structures
Slot Manager Routines
The Slot Manager Parameter Block
Determining the Version of the Slot Manager
Getting Information About SResource Data Structures
Enabling, Disabling, or Restoring SResource Data Structures
Summary of the Slot Manager
31
The Power Manager
About This Chapter
About the Power Manager
The Idle State
The Sleep State
The Sleep Queue
Sleep Requests
Sleep Demands
Wakeup Demands
Sleep-Request Revocations
Using the Power Manager
Determining Whether the Power Manager Is Present
Enabling or Disabling the Idle State
Setting, Disabling, and Reading the Wakeup Timer
Placing a Routine in the Sleep Queue
Responding When the Sleep Queue Calls Your Routine
Switching Serial Power On and Off
Power Manager Routines
Controlling the Idle State
Controlling and Reading the Wakeup Timer
Controlling the Sleep Queue
Controlling Serial Power
Reading the Status of the Internal Modem
Reading the Status of the Battery and of the Battery Charger
Summary of the Power Manager

32 The AppleTalk Manager

About This Chapter
About the AppleTalk Manager
Changes to the AppleTalk Manager
Contents

‘2
oo
ow?

Contents

=

_

©

~

me

i? 2)

AppleTalk Protocols
AppleTalk Device Drivers, AppleTalk Connection Files, and the LAP Manager
Using the AppleTalk Manager
Determining Whether AppleTalk Phase 2 Drivers Are Present
Deciding Which AppleTalk Protocol to Use
The .MPP Driver
Getting Information About the .MPP Driver
A New NBP Wildcard Character
The LAP Manager
The AppleTalk Transition Queue
Adding and Removing AppleTalk Transition Queue Entries
Sending Messages to the AppleTalk Transition Queue
How the AppleTalk Manager Calls Your AppleTalk Transition Queue Entry
Defining Your Own AppleTalk Transition
The LAP Manager 802.2 Protocol
Attaching and Detaching 802.2 Protocol Handlers
The .ATP Driver
Canceling All Calls to the ATPGetRequest Function
Setting the Timeout Value for the ATP Release Timer
The .XPP Driver
Using the .XPP Driver to Obtain Information About Zones
Obtaining Zone Information
AppleTalk Data Stream Protocol (ADSP)
Using ADSP
The ADSP Connection Control Block
The .DSP Parameter Block
Opening and Maintaining an ADSP Connection
Creating and Using a Connection Listener
Writing a User Routine for Connection Events
-DSP Driver Routines
Establishing and Terminating an ADSP Connection
Establishing and Terminating an ADSP Connection Listener
Maintaining an ADSP Connection
The .ENET Driver
Providing Your Own Ethernet Driver
Changing the Ethernet Hardware Address
Opening the .ENET Driver
Using a Write-Data Structure to Transmit Ethernet Data
Using the Default Ethernet Protocol Handler to Read Data
Using Your Own Ethernet Protocol Handler to Read Data
How the .ENET Driver Calls Your Protocol Handler
How Your Protocol Handler Calls the .ENET Driver
-ENET Driver Routines
Attaching and Detaching an Ethernet Protocol Handler
Writing and Reading Ethernet Packets
Adding and Removing Ethernet Multicast Addresses
Summary of the AppleTalk Manager
A

Result

Codes

B

Routines

and

Their

Memory

Behavior

Contents

xxvii

€

System

Traps

¥

0

Inside Macintosh, Volume VI

ca

Global

Variables

E-1

E

The

Standard

GL-1

Glossary

IN-]

Index

xxviii

Contents

Roman

Character

Set

9) 4
geAc
on |
o
“Y
ABrj
—e

—

Figures,

Tables,

and

Listings

—_

—

—

&

2)

Color Plates
Color plates are immediately preceding the title page.
Color Plate I.
Examples of keyboard icons
Color Plate II.
A colorized window
Color Plate III.
A colorized movable modal dialog box
Color Plate IV.
Design for black-and-white monitors first
Color Plate V.
Don’t mimic color effects in black-and-white designs
Color Plate VI.
Use light colors for large areas
Color Plate VII.
Don’t use bright colors for large areas
Color Plate VIII.
Use bright colors for details
Color Plate IX.
A consistent light source
Color Plate X.
Inconsistent light sources
Color Plate XI.
An icon family
Color Plate XII.
Consistently designed small icons
Color Plate XIII.
Inconsistently designed small icons
Color Plate XIV.
Icons with a black outline
Color Plate XV.
Icons without a black outline
Color Plate XVI.
Apple icon colors
Color Plate XVII.
Correct anti-aliasing
Color Plate XVII. —_ Incorrect anti-aliasing
Color Plate XIX.
Consistent use of icon elements
Color Plate XX.
Color Plate X XI.

Color Plate XXII.
Color Plate XXIII.
Color Plate XXIV.
Color Plate XXV.
P-17

|-5
|-7
1-9
1-9
1-10
1-11
1-13.
1-14
1-17
1-22
1-25

&
—
_

—_s

~”D
a

cme
—

—

ge

~”

Inconsistent use of icon elements

Default system icon families
Examples of control panel icons
| Copying with a pixel map as a mask
Colorizing
Default color tables

Preface
Figure P-1. | A road map to Volume VI
1 Introduction to the System Software Version 7.0 Environment
Figure 1-1. —_ Features of the system software version 7.0 environment
Figure 1-2.
The managers constituting the interapplication
communications architecture
Figure 1-3.
Using interapplication communication
Figure 1-4.
Applications using interapplication communication
Figure 1-5. — A publisher, an edition, and a subscriber
Figure 1-6.
Sharing dynamic data with other applications
Figure 1-7.
Sending events to other applications
Figure 1-8.
Requesting data from a remote database
Figure 1-9.
Comparison of TrueType and bitmapped fonts
Figure 1-10.
Using multiple scripts in a single document
Figure 1-11.
Overview of chapters in Volume VI

TLS

Inside Macintosh, Volume VI

'

NNMNYNYNYYNYNNYNYHYNYNYYYHYYYYNYYYYYYYY

1

'

i

1

!

1

adi

dies pa

cd

cals sadly auabe aa

We

Nn We ©

MW

Wn

1
3
ie
ee A
a
NNNNMNNR
ee
AN
RF OONDN NY

fk

1

'

MNMNNN

1

WWW

i]

WY

SWANN

HPHBWWNK

ODOM

1

WDAYNAMHNK§

i

!

!

1

1

i]

SE eee
WWWWWWWWWWWNNNNNNNNNNHK

OWOMNMNOON~

PO
DO
BOW
'
'
'

2

XXX

User

Interface

Guidelines

Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure

2-1.
2-2.
2-3.
2-4.
2-5.
2-6.
2-7.
2-8.
2-9.
2-10.
2-11.
2-12.
2-13.
2-14.
2-15.
2-16.
2-17.
2-18.
2-19.
2-20.
2-21.
2-22.
2-23.
2-24.
2-25,
2-26.
2-27.
2-28.
2-29.
2-30.
2-31.

Dual carets in mixed-directional text
Multidirectional text correctly highlighted
Reversing the alignment of dialog box items
The Keyboard menu
The boundaries of a font
A progress indicator
The Application menu with a notification symbol
An icon family
A well-designed icon and its selected version
A poorly designed icon and its selected version
Default system icons in black and white
Examples of control panel icons
A movable modal dialog box
A Finder movable modal dialog box
A selected scrolling list
A dialog box with OK and Cancel buttons
A dialog box with OK instead of a Cancel button
A progress indicator that uses a Stop button
A confirmation alert box
The recommended spacing of buttons and text in a dialog box
A well-written dialog box message
The new standard file dialog box for opening files
The save changes dialog box
A sample Edit menu
A sample hierarchical menu with Edition Manager commands
A sample pull-down Size menu and font size dialog box
The Help menu
The appearance of a version 7.0 pop-up menu
An open version 7.0 pop-up menu
A type-in pop-up menu
A type-in pop-up menu with user’s choice added

Table
Table
Table
Table
Table
Table

2-1.
2-2.
2-3.
2-4.
2-5.
2-6.

Examples of keyboard icons
Pattern substitutions for colors in keyboard icons
Translation chart for user documentation
Apple reserved keyboard equivalents for all systems
Additional reserved keyboard equivalents for worldwide systems
Other common keyboard equivalents

3 Compatibility Guidelines
Figure 3-1.
The size menu for a bitmapped font
Figure 3-2.
The size menu for an outline font
Figure 3-3.
A pop-up menu in its inactive and active states
Figure 3-4,
A pop-up control that is right-aligned
Figure 3-5.
An initial dialog box and a list of items to append
Figure 3-6.
The dialog box after items are overlaid
Figure 3-7.
The dialog box after items are appended to the right
Figure 3-8.
The dialog box after items are appended to the bottom
Figure 3-9.
The dialog box after items are appended relative to Item 2
Figure 3-10.
Interactions among an application, the A/UX Toolbox, and
ROM code
Figures, Tables, and Listings

Figures, Tables, and Listings

Table 3-1.

Listing 3-1
Listing 3-2

Listing 3-3

Listing : -4.

COANYDYNIAANNOCTOADANMN

Oo

a
ee
Se
!
Ne
WD
N Ww Wo
BMONWOMO CO

aN

Mee

COONAN

HAH
HAHHHHH
MannbpRHAL

WWWWNY

HSE

HAHAH

PEEP
SAHA
=

WwW
oo

PEP&

Listing 3-5
Listing 3- 6

System
Status of User Interface Toolbox and Macintosh Operating
x
Toolbo
libraries in the A/UX
Determining whether a trap is available
Determining whether Gestalt is available
Using Gestalt to determine the Time Manager version
Interpreting a bit field response
Installing a selector function into the system heap
Defining a new Gestalt function

4 The Edition Manager
The default edition icon
Figure 4-1.
A publisher, an edition, and a subscriber
Figure 4-2.
The
publisher dialog box
Figure 4-3.
The
subscriber dialog box
Figure 4-4,
A
document
and its corresponding editions
Figure 4-5,
Publisher
and
subscriber borders
Figure 4-6.
Edition Manager commands in the Edit menu
Figure 4-7.
Edition Manager commands under the Publishing menu command
Figure 4-8.
A document with a publisher and subscriber and its resource fork
Figure 4-9.
Figure 4-10.
The new publisher alert box
Figure 4-11.
A sample publisher dialog box
Figure 4-12.
A sample subscriber dialog box
Figure 4-13.
The publisher options dialog box with update mode set to On Save
Figure 4-14.
The publisher options dialog box with update mode set to Manually
Figure 4-15.
The subscriber options dialog box with update mode
set to Automatically
Figure 4-16.
The subscriber options dialog box with update mode
set to Manually
Figure 4-17.
Edit menu with Show/Hide Borders menu command
Figure 4-18.
Publisher borders
Figure 4-19.
Subscriber borders
Figure 4-20.
A publisher with contents removed
Figure 4-21.
A publisher border within a spreadsheet document
Figure 4-22.
A publisher border with resize handles
Figure 4-23.
A publisher and subscriber with clipped graphics
Figure 4-24.
Creating multiple publishers alert box
Figure 4-25.
Saving multiple publishers alert box
Figure 4-26.
Subscribing directly to a 'PICT' file
Listing 4-1.
Listing 4-2.
Listing 4-3.

Listing 4-4.

Listing 4-5.
Listing 4-6.
Listing 4-7.
Listing 4-8.
Listing 4-9,

Accepting Section Read events and verifying if a
section is registered
Saving a document containing sections
Opening a document containing sections
Creating a publisher
Writing data to an edition
Creating a subscriber
Reading in edition data
Responding to action codes
Using your own edition opener function

Figures, Tables, and Listings

Inside Macintosh,

D

Volume VI

The Event Manager

Figure 5-1.
Figure 5-2,
Figure 5-3.

Events In a single application environment
Events in a multi-application environment
Events in system software version 7.0

Listing 5-1.

A simple event loop
Processing events
A template for a 'SIZE' resource
The Rez input for a sample 'SIZE' resource
Posting a high-level event by application signature
Using the PPCBrowser function to post a hi gh-level event
Accepting a high-level event

Listing 5-2.
Listing 5-3.
Listing 5-4.

Listing 5-5.
Listing 5-6.
Listing 5-7,

6

The Apple Event Manager

Figure
Figure
Figure
Figure

6-1.
6-2.
6-3.
6-4.

Figure 6-9.

An Open Documents event
Major components of an Open Documents event
A descriptor record with event class data
A keyword-specified descriptor record for the event class attribute
of an Open Documents event
A descriptor list for a list of aliases
Data structures within an Open Documents event
Accepting and processing an Open Documents event
The Apple Event Manager calling the handler for an
Open Documents event
Responding to an Open Documents event

Table 6-1.

Coercion handling provided by the Apple Event Manager

Listing 6-1.
Listing 6-2.

A DoEvent procedure
A DoHighLevelEvent procedure for handling Apple events and
other high-level events
Inserting entries for required Apple events into an application’s
Apple event dispatch table
Inserting entries for Apple events sent by the Edition Manager into
an application’s Apple event dispatch table
A handler for the Open Application event
A handler for the Open Documents event
A handler for the Print Documents event
A handler for the Quit Application event
A handler for the Create Publisher event
Extracting items from a descriptor list
A function that checks for a keyMissedKeywordAttr attribute
Adding the keyErrorString parameter to the reply Apple event
Adding parameters to the reply Apple event
Using the AEInteractWithUser function
Creating a target address
Specifying a target address in an Apple event
Sending an Apple event
An idle function

Figure 6-5,

Figure 6-6.

Figure 6-7.
Figure 6-8.

Listing 6-3.
Listing 6-4.

6-58
6-58
6-61
6-66

XXXII

Listing 6-5.
Listing 6-6.
Listing 6-7.
Listing 6-8.
Listing 6-9.
Listing 6-10.
Listing 6-11.
Listing 6-12.
Listing 6-13.
Listing 6-14.
Listing 6-15.
Listing 6-16.
Listing 6-17.
Listing 6-18.

Figures, Tables, and Listings

Figures, Tables, and Listings
ey

=
&
D

7 The Program-to-Program Communications Toolbox
Figure 7-1.
A PPC Toolbox session between two applications
Figure 7-2.
The Sharing Setup icon
Figure 7-3.
The Sharing Setup control panel
Figure 7-4.
The session termination alert box
Figure 7-5.
The users and groups dialog box
Figure 7-6.
The user termination alert box
Figure 7-7.
The guest dialog box
Figure 7-8.
The PPC Toolbox authentication process
Figure 7-9.
Database and spreadsheet applications using the PPC Toolbox
Figure 7-10.
Two Macintosh applications and their corresponding ports
Figure 7-11.
The PPC Toolbox and a dictionary service application
Figure 7-12.
The program linking dialog box
Figure 7-13.
The program linking dialog box without a zone list
Figure 7-14.
The user identity dialog box
Figure 7-15.
The incorrect password dialog box
Figure 7-16.
The invalid user name dialog box
Figure 7-17.
Transmitting message blocks
Figure 7-18.
The PPC Toolbox parameter blocks
7-1.
7-2.
7-3.
7-4.
7-5.
7-6.
7-7.
7-8.
7-9.
7-10.
7-11.
7-12.
7-13.
7-14.
7-15.

=

7
w

CZz

=e

=
ge

w

Listing 7-18.
Listing 7-19.
Listing 7-20.
8 The Data
Figure 8-1.
Figure 8-2.
Figure 8-3.
Figure 8-4.
Figure 8-5.
Figure 8-6.
Figure 8-7.

Access Manager
A connection with a database
Using high-level Data Access Manager routines
Using low-level Data Access Manager routines
A flowchart of a session using the high-level interface
A flowchart of a session using the low-level interface
A query document dialog box
Function of a query document

=
WW

Bae Hit Be
Mia Mie Mia Mi

WwWwWWWwWNMmNMNMNNMNN-—

Wwwrwwonwn

2p

Se Bite Bis Mite Bias tae Mi

Coonan
—Oo~1O

Listing 7-16.
Listing 7-17.

Initializing the PPC Toolbox using the PPCInit function
Opening a PPC port
Using a port filter function
Browsing through dictionary service ports
Using the IPCListPorts function to obtain a list of ports
Using the StartSecureSession function to establish a session
Initiating a session using the PPCStart function
Using the PPCInform function to enable a port to receive sessions
Completion routine for a PPCInform function
Accepting a session request using the PPCAccept function
Completion routine for a PPCAccept function
Rejecting a session request using the PPCReject function
Completion routine for a PPCReject function
Using the PPCRead function to read data during a session
Polling the ioResult field to determine if a PPCRead function
has completed
Using the PPCWrite function to write data during a session
Polling the ioResult field to determine if a PPCWrite function
has completed
Ending a PPC session using the PPCEnd function
Closing a PPC port using the PPCClose function
Using the DeleteUserldentity function to invalidate a user identity

mee

2 Go
--

Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing

ae

bet)

~~~
WW Wo WW
NUN

sanYY)
i
i
i
i
fe Be ie a
WWINNNReee—
i
eo
tee
Fw
OF
MPNankOO~
IM — OW
C NSYAVAAN

ve
&

Figures, Tables, and Listings

XXXII

Inside Macintosh,

Table 8-1.

Data types defined by the Data Access Manager

Listing 8-1
Listing 8-2
Listing 8-3.
Listing 8-4.
Listing 8-5
Listing 8-6

Using the high-level interface
A sample status routine
Sending a query fragment
Using the low-level interface
A result handler

3

tad: pas

OO

eee

\O

0

Ons

©

‘9

WN

©

NK

No RoR

OW OO

ol oR ok \ok<e)

9

OOO

Volume VI

The

A query definition function

Finder

Interface

Figure 9-10.
Figure 9-11.
Figure 9-12.

Default large black-and-white icons
An application icon and its mask
The ResEdit view of an icon and its mask
Examples of document icons
Linking 'ICN#' and 'FREF' resources in a 'BNDL' resource
The default application-unavailable alert box
The application-unavailable alert box specifying an
application’s name
The application-unavailable alert box with a customized message
The application-unavailable alert box for 'TEXT' and
‘PICT’ documents
The version data in the information window
Default and customized help balloons for application icons
The System Folder and related folders

Listing 9-1.
Listing 9-2.
Listing 9-3.
Listing 9-4.
Listing 9-5.

'ICN#' resources for an application and its documents
Using file reference resources
Using a bundle resource
Using the ResolveAliasFile function to open a file
Creating a help balloon resource for an application icon

Figure
Figure
Figure
Figure
Figure
Figure

9-1.
9-2.
9-3.
9-4.
9-5.
9-6,

Figure 9-7.
Figure 9-8.
Figure 9-9,

10

Control

Panels

Figure 10-1.
Figure 10-2.
Figure 10-3.

The Monitors control panel
An Options dialog box for a Monitors control panel
An Options dialog box with superuser controls

Listing 10-1.
Listing 10-2.

Sample of an extension to the Monitors control panel
Resources for a file that extends the Monitors control panel

11 The Help Manager
Figure 11-1.
The Help menu for the Finder
Figure 11-2.
A help balloon drawn with the standard balloon definition function
Figure 11-3.
The tip and hot rectangle for a help balloon
Figure 1 1-4.
Standard balloon positions and their variation codes
Figure 11-5.
Alternate positions of a help balloon
Figure 11-6.
Default help balloons for the window frame
Figure 11-7.
Default help balloons for the Apple and Help menus
Figure 11-8.
Default help balloons for application and document icons
Figure 11-9.
Help balloons for different states of the Cut command
Figure 11-10. Help balloons for a changing menu item
Figure 11-1]. A help balloon in a modal dialog box
Figure 11-12. Static and dynamic windows
XXXIV

Figures, Tables, and Listings

Figures, Tables, and Listings
eet
|
—e

we-—

-_—

a|
(@*)
wn

11-46
11-47
11-58
11-61

Figure
Figure
Figure
Figure

11-13.
11-14.
11-15.
11-16.

A tool palette with a help balloon
A help balloon for a dialog box with a title
Default and customized help balloons for an application icon
The Help menu with two appended menu items

11-23
11-27
11-29
11-31
11-38
11-46
11-48

Listing
Listing
Listing
Listing
Listing
Listing
Listing

11-1.
11 -2
11-3.
11-4.
11-5.
11-6.
11-7.

11-55
11-58
11-60
11-62

Listing
Listing
Listing
Listing

11-8.
11-9.
| 1-10.
11-11.

A partial menu help resource
The missing items component in a menu help resource
Corresponding ‘'hmnu' and 'STR#' resources
Using HMCompareltem for a changing menu item
A dialog item list and its help resource
Corresponding 'hwin' and 'hrct' resources for a tool palette
Specifying help for titled and untitled windows with an
‘hwin’ resource
Using HMShowBalloon to display help balloons
Creating a help balloon resource for an application icon
Overriding default help balloons
A sample menu help resource for items in the Help menu

12-5
12-6
12-7
12-8
12-9
12-9
12-9
12-10
12-11
12-12
12-12
12-13
12-14
12-15
12-17

12 The Font Manager
Figure 12-1.
The standard Roman character set
Figure 12-2.
Terms for font measurements
Figure 12-3.
The ascent line and maximum y-value
Figure 12-4.
A comparison of scaled TrueType and bitmapped fonts
Figure 12-5.
A glyph stretched horizontally
Figure 12-6.
A glyph stretched vertically
Figure 12-7.
A glyph condensed horizontally
Figure 12-8.
The effect of an off-curve point on two Bézier curves
Figure 12-9.
An outline with points on and off the curve
Figure 12-10. A curve with consecutive off-curve points
Figure 12-11. An outline glyph
Figure 12-12. An unmodified outline glyph at a small point size
Figure 12-13. An instructed outline glyph
Figure 12-14. A sample Size menu and font size dialog box
Figure 12-15. The difference between a scaled glyph and a preserved glyph

12-16

Listing 12-1.

13-4
13-6

1 3 The Resource Manager
Table 13-1. | Resource types available for your application’s use
Table 13-2.
Resource types reserved for the Operating System’s use

13-17

Listing 13-1.

14-9
14-16
14-17
14-18
14-19
14-21
14-22
14-24

14 Worldwide Software Overview
Figure 14-1.
The script, language, and region hierarchy
Figure 14-2.
Types of script systems
Figure 14-3.
The components of the Macintosh Script Management System
Figure 14-4. | Worldwide control panels and desk accessory
Figure 14-5.
Default icons for keyboards, fonts, and scripts
Figure 14-6.
The Keyboard menu
Figure 14-7.
Distinguishing scripts with resource ID ranges for script codes 0-32
Figure 14-8. | Keyboard translation

-

_2

as

ae

—
—
ad

9°)

7 2)

7

&

—
L
_—:
2)
_
—_e
—

ae!
79

~”M

Checking a font family ID against the font name

Using partial resource calls

Figures, Tables, and Listings

= xxxv

Inside Macintosh,

Volume VI

14-29
14-30
14-3]
14-31
14-3]
14-32
14-32
14-33
14-36
14-38
14-38
14-52
14-53
14-54
14-54
14-57
14-69
14-70
14-93
14-96
14-99
14-99
14-100
14-101

Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure

14-108

Figure 14-33.

14-4]
14-42
14-44
14-55
14-56
14-56

Table
Table
Table
Table
Table
Table

14-1.
14-2.
14-3.
14-4.
14-5.
14-6.

14-58
14-66
14-80
14-84
14-95
14-95
14-97
14-98
14-98

Table
Table
Table
Table
Table
Table
Table
Table
Table

14-7.
14-8.
14-9.
14-10.
14-11.
14-12.
14-13.
14-14.
14-15.

GetScript and SetScript verbs
Verbs for GetEnvirons and SetEnvirons
Verbs for the KeyScript procedure
U.S. word selection algorithm
Occurrence of word breaks in various character sequences
Significance of the state numbers in the Roman word selection
algorithm
U.S. word select transition table for forward processing
Proportions of slop value to be distributed
The international and keyboard resources
Script, language, and region codes
The keyboard types
The keyboard modifier bits
Changes in handling 'KCHR' (0) key combinations
Changes in 'KCHR' dead-key completers
Keyboard color icon types and standard icon equivalents

14-59
14-61
14-66
14-83
14-88
14-101
14-105

Listing
Listing
Listing
Listing
Listing
Listing
Listing

14-1
14-2
14-3
14-4.
14-5
14-6
14-7

Obtaining optimized word break tables
Substituting and truncating text
Distributing slop value among style runs
Multiscript mapping and sorting
International date and time information
Physical layout of keyboards
Making keyboard equivalents work with multiple scripts

XXXVI

Figures, Tables, and Listings

14-9.
14-10.
14-11.
14-12.
14-13.
14-14.
14-15.
14-16.
14-17.
14-18.
14-19.
14-20.
14-21.
14-22.
14-23.
14-24.
14-25.
14-26.
14-27.
14-28.
14-29.
14-30.
14-31.
14-32.

Scripts
Alphabetic, syllabic, and ideographic representations of characters
Three text directions
Contextual forms in cursive English
Stand-alone and contextual forms in Arabic
A ligature in Roman text
Ligatures in Arabic text
Character reordering in Devanagari script (for the word hindi)
Backing-store and display order
Calling the Script Manager routines implemented by a script system
Calling the Script Manager routines
Forward operation of the state machine for word selection
NFindWord header and class tables
NFindWord state table
Format of NFindWord action code
Roman word selection state transitions
Justification in Roman text
The effects of the Roman justification routines
The ‘itl2' resource header
Inside the 'KCHR' resource
Format of entries in the 'KSWP' resource
The 'itlk' resource entries
Key Caps display of dead keys with Option key pressed
Key Caps display of completer keys after circumflex dead key
has been pressed
Extracting blocks of Roman text

Figures, Tables, and Listings
—

mas

geAS
=

_—

15

Textkait
15-1.
15-2.
15-3.
15-4.
15-5.
15-6.
15-7.
15-8.
15-9.
15-10.
15-11.
15-12.
15-13.
15-14.
15-15.
15-16.
15-17.
15-18.
15-19.
15-20.

@
2)

-

|SS
<E
o”

15-9
15-9
15-10
15-11
15-12
15-15
15-16
15-16
15-32
15-33
15-33
15-33
15-38

Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure

A right-to-left primary line direction
The display order
The backing-store order
Different levels of runs in a line of text
Discontinuous highlighting display
Highlighting mixed-directional text
Mouse-down region specifics
Dual carets in mixed-directional text
Pasting styled text
Dual carets at a direction boundary
Caret movement across a direction boundary
Font and keyboard script synchronization
The caret position at line end
Word breaks for word selection
A line break with multiple scripts installed
A character offset at a line break
An initial selection before TESetStyle is called
The result of calling TESetStyle to toggle with a bold style
The result of calling TESetStyle to toggle with an italic style
The TextEdit data structures

15-20

Table 15-1.

Constants for the just parameter of TESetJust

15-34

Listing 15-1.

15-35

Listing 15-2.

Marking the Style menu items so they correspond to the
current selection
Determining the font, face, size, and color of the current selection

16-4
16-7
16-15
16-17
16-18

16 Graphics Overview
Figure 16-1.
Macintosh graphics chapters
Figure 16-2.
QuickDraw and the graphics managers
Figure 16-3.
Initializing Macintosh graphics
Figure 16-4.
The indexed pixel path
Figure 16-5.
The direct pixel path

—

—_

-

oe
—
\

oa
2)
a3
ge72]
—_
_—

—~

17 Color QuickDraw
A 32-bit direct pixel
Figure 17-1.
Figure 17-2.
A 16-bit direct pixel
Figure 17-3.
Converting a 16-bit direct pixel to a 32-bit direct pixel
Figure 17-4.
Converting a 48-bit RGB color to a 32-bit direct pixel
Figure 17-5.
Converting a 48-bit RGB color to a 16-bit direct pixel
Figure 17-6.
Converting a 48-bit RGB color to an 8-bit indexed pixel
Figure 17-7.
Converting a 32-bit pixel to a 48-bit RGB color
Figure 17-8.
Converting a 16-bit pixel to a 48-bit RGB color
Figure 17-9.
Converting an 8-bit indexed pixel to a 48-bit RGB color
Figure 17-10. Copying pixel maps with CopyBits
Figure 17-11. Copying pixel maps with CopyMask
Figure 17-12. Copying pixel maps with CopyDeepMask
Table
Table
Table
Table

17-1.
17-2.
17-3.
17-4.

The default color tables for gray-scale devices
The default color tables for color devices
The new version 2 picture opcodes
Version 2 picture example
Figures, Tables, and Listings

XXXVvil

;

Inside Macintosh,

Volume VI

19 The Color Picker Package
Figure 19-1.
The Color Picker dialog box
Figure 19-2.
The RGB color cube
Figure 19-3.
Getting to pink
Figure 19-4.
Cyan, magenta, and yellow on the color cube
Figure 19-5.
|The HLS/HSV color cone
20 The Palette Manager
Figure 20-1.
A courteous palette
Listing 20-1.
Listing 20-2.

A palette (‘pltt') resource
A multi-use palette

21 The Graphics Devices Manager
Listing 21-1.
Sample offscreen graphics world
22 The Sound Manager
Figure 22-1.
The position of the Sound Manager
Figure 22-2.
Bypassing the command queue

Figure 22-3.

XXXVIILL

Figure
Figure
Figure
Figure
Figure
Figure
Figure
Figure

22-4.
22-5.
22-6.
22-7.
22-8.
22-9.
22-10.
22-11.

Table
Table
Table
Table
Table
Table
Table

22-1.
22-2.
22-3.
22-4.
22-5.
22-6.
22-7.

Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing

22-1.
22-2.
22-3.
22-4.
22-5.
22-6.
22-7.
22-8.
22-9.
22-10.
22-11.
22-12.
22-13.

Mixing multiple channels of sampled sound

A graph of a wave table
The Sound control panel
The sound recording dialog box
The structure of 'snd ' resources
The location of the data offset bit
The general structure of a chunk
Interleaving stereo sample points
A sample AIFF-C file

| Audio compression and expansion options
AIFF and AIFF-C capabilities
| MIDI values
| Sample rates
| Sound input device information selectors
| Sound commands
| The sound header format used by SetupSndHeader
A format | 'snd ' resource

A restructured format | 'snd ' resource
A format | 'snd ' resource containing sampled sound data
A resource specification
Resource specification for the Simple Beep
A format 2 'snd ' resource
Playing an 'snd ' resource with SndPlay
Using low-level Sound Manager routines
Creating a sound channel
Using the availableCmd command
Using the versionCmd command
Using the freqDurationCmd command
An ‘snd ' resource containing compressed sound data

Figures, Tables, and Listings

Figures, Tables, and Listings
Le 3

ie
tic
~
—

22-51
22-56
22-57
22-58
22-61
22-64
22-64
22-71

22-72

22-74
22-77
22-78
22-79

Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing

22-14.
22-15.
22-16.
22-17.
22-18.
22-19.
22-20.
22-21.
22-22.
22-23.
22-24.
22-25.
22-26.

Halving the frequency of a sampled sound

N
m

Compressing audio data

kd

Playing an 'snd ' resource from disk
Recording through the sound input dialog box

~
—
~

—
fe)
Nn
-

Recording directly from a sound input device

ee

Determining the name of a sound input device
Determining some sound input device settings

a

i<
ee
i 2
~—
—

Determining whether a sound channel is paused

—

ge

Determining the number of allocated sound channels
Setting up double buffers
Defining a doubleback procedure
Issuing a callback command
Defining a callback procedure

23-7

23 The Time Manager
Figure 23-1.
Original and revised Time Managers (drifting, unpredictable
frequency)
The extended Time Manager (drift-free, fixed frequency)
Figure 23-2.

23-11
23-13

Listing 23-1.
Listing 23-2.

23-13
23-14
23-15

Listing 23-3.
Listing 23-4.
Listing 23-5

24-4
24-5

24 The Notification Manager
Figure 24-1.
A notification in the Application menu
Figure 24-2.
A sample alert box

24-8

Listing 24-1.

25-6
25-8
25-23

25 The File Manager
Figure 25-1.
Identifying a file in MFS
Figure 25-2.
Identifying a file in HFS
Figure 25-3.
The effect of ioSearchBits on interpretation of ioSearchInfo|]
and ioSearchInfo2

25-16
25-18
25-18
25-21
25-21

Table
Table
Table
Table
Table

25-1.
25-2.
25-3.
25-4.
25-5.

25-14
25-15
25-19
25-24

Listing
Listing
Listing
Listing

25-1.
25-2.
25-3.
25-4

23-6

2|
@

2)

Installing and activating a Time Manager task

Passing the address of the application’s A5 world to a
Time Manager task
Defining a Time Manager task that can manipulate global variables
Defining a periodic Time Manager task
Computing elapsed time

Setting up a notification record

How FSMakeFSSpec interprets file specifications
The effect of FSpExchangeFiles on a catalog entry
The effect of FSpExchangeFiles on a file control block
Fields in ioSearchInfol and ioSearchInfo2 used for a file
Fields in ioSearchInfol and ioSearchInfo2 used for a directory
Testing for PBCatSearch
Opening a document using the FSSpec record
Updating a file with FSpExchangeFiles
Searching a volume with PBCatSearch

Figures, Tables, and Listings

= Xxxix

Inside Macintosh,

Volume VI

26 The Standard File Package
Figure 26-1.
The default Open dialog box
Figure 26-2.
The default Save dialog box
Figure 26-3.
The New Folder dialog box
Figure 26-4.
The name conflict dialog box
Listing
Listing
Listing
Listing
Listing

26-1.
26-2.
26-3.
26-4.
26-5.

Opening a document
The definition of the default Open dialog box
The definition of the default Save dialog box
The item list for the default Open dialog box
The item list for the default Save dialog box

to

27 The Alias Manager
Figure 27-1.
Resolving a relative path
28 Memory
Figure 28-1.
Figure 28-2.
Figure 28-3.
Figure 28-4.
Figure 28-5.
Figure 28-6.

Management
The memory organization in a single-application environment
The organization of the application partition
The memory organization in a multiple application environment
Using temporary memory
The Memory control panel
A master pointer structure in the 24-bit Memory Manager

Listing
Listing
Listing
Listing

Passing A5 to a notification response procedure

2 9

28-1.
28-2.
28-3.
28-4.

Process

Listing 29-1,
Listing 29-2.

Setting up and restoring A5

Translating logical to physical addresses
Determining whether temporary memory routines are available
Management
Searching for a specific process
Launching an application

30 The Slot Manager
Table 30-1.
Slot Manager search routines
Table 30-2.
How the Slot Manager determines the base address used by
an sResource data structure
Listing 30-1.
Listing 30-2.

Disabling and enabling sResource data structures
Searching for sResource data structures

31-5
31-9
31-10

31
The Power Manager
Figure 31-1.
Relationship of an application to the Power Manager
Figure 31-2.
How the sleep queue handles a sleep request
Figure 31-3.
How the sleep queue handles a sleep demand

31-8

Table 31-1.

Response of network services to sleep requests and demands

31-15
31-17

Listing 31-1.

Adding an entry to the sleep queue
A sleep queue routine

xl

Figures, Tables, and Listings

Listing 31-2.

Figures, Tables, and Listings
ery
_
go

=~

32-6
32-9
32-10
32-26
32-82

32 The AppleTalk Manager
Figure 32-1.
AppleTalk protocols
AppleTalk device drivers
Figure 32-2.
Figure 32-3.
AppleTalk application interfaces
Figure 32-4.
AppleTalk Ethernet packet formats
Figure 32-5.
An Ethernet write-data structure

32-27
32-33
32-34
32-48
32-54
32-57
32-80
32-82
32-84

Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing
Listing

A-l

32-1.
32-2.
32-3.
32-4.
32-5.
32-6.
32-7.
32-8.
32-9.

Codes

B

and Their Memory Behavior
Routines that may move or purge memory
Routines that do not move or purge memory but may not be called
at interrupt time
Routines that may be called at interrupt time

Routines

Table B-3.

System

D

Global Variables

E

The

C-1.
C-2.
C-3.
C-4.

Table D-1.

Table E-1.
Table E-2.

+S)

a
—

3")

<<

Sh21
—
—*
—
=

ge

~N

Result codes

C

Table
Table
Table
Table

bj

Calling a LAP Manager L802.2 routine from assembly language
Using the GetZoneList function
Using the GetMyZone function
Using ADSP to establish and use a connection
Using ADSP to establish and use a connection listener
An ADSP user routine
Finding an EtherTalk card and opening the .ENET driver
Sending a data packet over Ethernet
Using the default Ethernet protocol handler to read data

A
Result
Table A-1.

Table B-1.
Table B-2.

i¢°)

<

Traps
System traps by trap name
System traps by trap word
System traps that take selectors
Routines selected from system traps

Global variables

Standard

Roman

Character

The standard Roman

Set

character set

Unencoded PostScript characters

Figures, Tables, and Listings

xli

Inside Macintosh,

xlii

Volume VI

Figures, Tables, and Listings

OYAMHIMN
WOO
OOOO

HW

PREFACE

10
10
10
10
ll
11
11
12
12
12
12
13
13
13
13
13
14
14
14
14
15
15
15
15
15
16

About Inside Macintosh
The Development Environment
The System Software Environment
The Format of a Typical Chapter
The Conventions Used in This Volume
Other Documentation
An Overview of the Chapters in Volume VI
Introduction to the System Software Version 7.0 Environment
User Interface Guidelines
Compatibility Guidelines
The Edition Manager
The Event Manager
The Apple Event Manager
The Program-to-Program Communications Toolbox
The Data Access Manager
The Finder Interface
Control Panels
The Help Manager
The Font Manager
The Resource Manager
Worldwide Software Overview
TextEdit
Graphics Overview
Color QuickDraw
The Picture Utilities Package
The Color Picker Package
The Palette Manager
The Graphics Devices Manager
The Sound Manager
The Time Manager
The Notification Manager
The File Manager
The Standard File Package
The Alias Manager
Memory Management
Process Management
The Slot Manager
The Power Manager
The AppleTalk Manager
A Road Map to Volume VI

Preface

ABOUT

INSIDE

MACINTOSH

Inside Macintosh is a six-volume set of books that describes how to write an application for

the Apple® Macintosh® family of computers. /nside Macintosh is the definitive guide and

reference for anyone writing software for the Macintosh computer. The first two volumes
describe the routines in the Macintosh User Interface Toolbox and the Macintosh Operating
System. The third volume is a summary of the Pascal interfaces for all routines described in
Volumes I and II. The fourth and fifth volumes describe features and routines introduced
with the Macintosh Plus, Macintosh SE, and Macintosh II computers. Volume VI describes

the managers and features available in system software version 7.0.

Volume I contains the original user interface guidelines for Macintosh applications and an
introduction to memory management and assembly language. It also describes QuickDraw™,
the Resource Manager, the Event Manager, the Font Manager, the Window Manager, the
Menu Manager, the Dialog Manager, TextEdit, and other routines relating to the user interface
that you can use in your application.
Volume II describes the Macintosh Operating System, including the routines that perform

file I/O, device I/O, memory management, and interrupt handling. It covers the File Manager,

the Device Manager, the Printing Manager, the AppleTalk® Manager, and various drivers
and utilities.
Volume III describes the Finder™ interface, provides an overview of the hardware of the
Macintosh 128K and Macintosh 512K computers, and contains summaries of the Pascal
interfaces for all routines described in Volumes I and II.

Volume IV describes routines introduced with the Macintosh Plus and Macintosh 512K
enhanced computers. It introduces the Hierarchical File System, the SCSI Manager, the
Time Manager, and the List Manager. The volume also describes changes to various
managers and drivers and presents an overview of the Macintosh Plus hardware.
Volume V describes routines introduced with the Macintosh SE and Macintosh II computers.
It describes Color QuickDraw, the Palette Manager, the Script Manager, the Sound Manager,

the Slot Manager, the Apple Desktop Bus™, and changes made to various managers to support

color. The volume also includes additional user interface guidelines and compatibility guidelines. It explains how to add color to menus, windows, and dialog boxes. It also discusses
hierarchical, scrolling, and pop-up menus.
This volume, Volume VI, describes the system software version 7.0 environment, new
managers available with version 7.0, new routines and data structures, new user interface
guidelines, and how to take advantage of the version 7.0 environment.
Inside Macintosh, Volume VI, is also available in an on-line edition. The on-line edition
provides a navigational model that lets you browse through information and it provides a
search capability to quickly locate routines, data structures, and other text.

The /nside Macintosh X-Ref provides a comprehensive, integrated index for Volumes I
through VI of Inside Macintosh, as well as Programmer’s Introduction to the Macintosh
Family; Technical Introduction to the Macintosh Family; Designing Cards and Drivers for
the Macintosh Family, second edition; and Guide to the Macintosh Family Hardware, second
edition. All these books are available from Addison-Wesley.
About Inside Macintosh

P-3

Inside Macintosh,

The

Volume VI

Development

Environment

The User Interface Toolbox and Macintosh Operating System routines are available using
Pascal, C, or assembly-language interfaces. How you access these routines depends on the
development environment you are using. This volume shows all routines in their Pascal
interface using the Macintosh Programmer’s Workshop (MPW®). All sample code listings
are shown in MPW Pascal, with a few examples shown in assembly language.
The MPW development environment includes these books: Macintosh Programmer's
Workshop Development Environment, Volume 1; Macintosh Programmer’s Workshop
Development Environment, Volume 2; MPW Pascal: Macintosh Programmer’s Workshop
Pascal; MPW C: Macintosh Programmer’s Workshop C; and MPW Assembler: Macintosh
Programmer’s Workshop Assembler. These books are available from APDA® (Apple
Programmers and Developers Association).
The code listings and other code in this volume were developed using MPW 3.0. They show
methods of using various routines and illustrate techniques for accomplishing particular tasks.
All code listings have been compiled and, in many cases, tested. However, Apple does not
intend that you use these code samples in your application.
If you are programming in assembly language, pay attention to the assembly-language notes
and trap macro notes. These notes provide information about saving and restoring registers,
details of what each register must contain on entry to Operating System routines, what the
routines return in the registers, and other information you might find helpful.
If you are programming in Pascal or C only, you can skip over the assembly-language
information.
This volume occasionally uses SurfWriter, WipeOut, store data, display data, send and
receive, make memo, and spell quick as names of sample programs for illustrative purposes;
these are not actual products of Apple Computer, Inc.
APDA offers worldwide access to a broad range of programming products, resources, and
information for anyone developing on Apple platforms. You’!| find the most current versions
of Apple and third-party development tools, debuggers, compilers, languages, and technical
references for all Apple platforms. To establish an APDA account, obtain additional ordering
information, or find out about site licensing and developer training programs, contact
APDA
Apple Computer, Inc.
20525 Mariani Avenue, M/S 33-G
Cupertino, CA 95014-6299
Telephone:
Fax:
Telex:

800-282-2732 (United States)
800-637-0029 (Canada)
408-562-3910 (elsewhere in the world)
408-562-3971
171-576

If you provide commercial products and services, call 408-974-4897 for information on the
developer support programs available from Apple.

P-4

About Inside Macintosh

Preface

For information on registering signatures, file types, Apple events, and other technical
information, contact
Macintosh Developer Technical Support
Apple Computer, Inc.
20525 Mariani Ave,, M/S 75-3T
Cupertino, CA 95014-6299

The

System

Software

Environment

Inside Macintosh Volume VI focuses on system software version 7.0; however, many of
the chapters in this volume contain information that is also relevant to system software
version 6.0 and later. See the Compatibility Guidelines chapter for information on
developing applications that can run in both system software version 6.0 and system
software version 7.0.
If the Gestalt function is available, you should use it instead of the SysEnvirons and Environs
routines. You can use the Gestalt function to determine whether all the features your application requires are present on a particular Macintosh computer. You should not rely on the
ROM version, since later system software versions can override routines in ROM. See the
Compatibility Guidelines chapter for details on how to use the Gestalt function.

The

Format

of a Typical

Chapter

Almost all chapters in Volume VI have a standard structure. For example, the Edition
Manager chapter contains these sections:
a “About This Chapter” This section describes the information you can find in the chapter
and includes references to related chapters.
w “About the Edition Manager” This section provides an overview of the features provided
by the Edition Manager.
a Additional sections describe concepts related to the Edition Manager.
a “Using the Edition Manager” This section describes the tasks you can accomplish using
the routines provided by the Edition Manager. It describes how to use the most common
routines, gives related user interface information, provides code samples, and supplies
additional information.
a “Edition Manager Routines” This section lists Edition Manager routines in
version 7.0, with routine declarations and descriptions of every parameter for
each routine.
a “Summary of the Edition Manager” This section provides the Edition Manager’s Pascal

interface for version 7.0 constants, data structures, routines, and result codes, as well as

relevant assembly-language information.

About Inside Macintosh

P-5

Inside Macintosh,

The

Volume VI

Conventions

Used

in This

Volume

This volume uses elements such as assembly-language notes, trap macro notes, note boxes,
and warning boxes to set off important information. Trap macro notes and assemblylanguage notes are useful only if you are programming in assembly language.
All routines (with a few exceptions) have both a Pascal and assembly-language form. The

summary at the end of each chapter first lists the constants, data structures, and routines
provided with the MPW Pascal interface files, and then lists equivalent assembly-language
information for data structures and routines for use with the MPW Assembler interface files.
The constants for the MPW Assembler interface files are the same as their Pascal equivalents,
so the constant names are shown only in the Pascal section of the summary. (The constants,
data structure names, and routine names in the MPW C interface files are also the same as
their Pascal equivalents.)
When appropriate, the declaration for a procedure or function includes relevant assemblylanguage information in the form of a trap macro note that immediately follows the declaration.
The trap macro that corresponds to a Pascal interface routine begins with an underscore
character (_) followed by the Pascal routine name. Trap macro notes appear in this form:

Trap macro

For register-based routines, this shows the trap macro
name and describes the parameters that must be in the
registers on entry to the routine and describes the values
returned in the registers.
For stack-based routines, this shows the name of the trap
macro if it is different from the Pascal interface name.

Assembly-language notes appear in this form:

Assembly-language note: This gives information of interest only if you
are programming in assembly language.
If you are programming in Pascal or C only, you can skip over the information in trap macro
notes and assembly-language notes.
Important information is often called out in a note box:

Note:

Text set off in this way presents reminders or notes related to the topic.

Information that you need to pay special attention to is shown in a warning box:
A

Warning: Warnings like this alert you to situations in which you could damage
software or lose data. a

Words that appear in boldface are key terms or concepts and are defined in the Glossary
P-6

About Inside Macintosh

Preface

All code listings use the Courier font (chis is Courier) to indicate code from a sample
program that can be compiled. The summary listings and set-off code in text also use Courier
for the actual data structure names, field names, constant names, and routine names that
match the names used in the MPW Pascal interface files.

Many Toolbox and Operating System routines accept a pointer to a parameter block as
a parameter. For these routines, the routine description includes a list of the fields in the
parameter block that are used by the routine.
A typical parameter block description looks like this:
Parameter block
[in/out]

[offset]

[field name]

[size]

[description]

=

0

input]

long

This is an input parameter

<—

+

ouput!

word

This is an output parameter

o

6

inAndOut

long

This is an input/output parameter

>

10

reqCount

long

Requested number of files to send

>

14

buffer

long

Pointer to data buffer

—

18

accCount

long

Actual number of files sent

The arrow in the first column indicates whether the field is an input parameter, output
parameter, or both. You must supply values for all input parameters and input/output
parameters. The routine returns values in output parameters and input/output parameters.
The second column indicates the offset and is useful only if you are programming in
assembly language or debugging your code. The offset value is the offset in bytes from
the beginning of the parameter block for each field within the structure.
The third column shows the field name as defined in the MPW Pascal interfaces, and the
fourth column shows the size of that field. The size is given in bytes or indicated as word or
long (for long word). Long indicates a field that occupies 4 bytes; word indicates a field
that occupies522 bytes. The size is provided for your information and is more useful if you
are programming in assembly language. The final column provides a short description
of the field.

Other

Documentation

For specific hardware information about the Macintosh family, see Guide to the Macintosh
Family Hardware, second edition, and Designing Cards and Drivers for the Macintosh
Family, second edition; for additional software information, see previous volumes of /nside
Macintosh. Also see Macintosh Worldwide Development: Guide to System Software for a
complete description of all components of the worldwide system software. See Human
Interface Guidelines: The Apple Desktop Interface for a complete description of the Apple
human interface.

About Inside Macintosh

P-7

Inside Macintosh,

AN

Volume V1

OVERVIEW

OF THE

CHAPTERS

IN VOLUME

VI

The following sections describe the content of each chapter in this volume and tell where to
find additional information in previous volumes. Figure P-1 (at the end of the Preface) lists

the chapters in Volume VI and shows which other volumes cover those topics.

Introduction to the System

Software Version

7.0 Environment

The first chapter in this volume provides an overview of the features of system software

version 7.0. It describes the operating environment for applications that run in version 7.0.

User

Interface

Guidelines

The User Interface Guidelines chapter in Volume VI reviews the user interface design principles and gives new guidelines for system software version 7.0. The chapter discusses
windows, dialog boxes and movable modal dialog boxes, additions to the standard menus,
terminology, and user feedback. It also gives guidelines for developing worldwide software
and for designing color icons and windows.
The Finder Interface chapter in this volume provides related information on the user interface
presented by the Finder. Individual chapters address specific issues related to the user
interface features provided by a particular manager.
The User Interface Guidelines chapter in Volume I describes the various components of a
Macintosh application and discusses the use of menus, windows, dialog boxes, scroll bars
and other controls.
The User Interface Guidelines chapter in Volume IV discusses use of the arrow keys,
reserved keyboard equivalents, window zooming, and the standard close box.
The User Interface Guidelines chapter in Volume V briefly discusses the use of color in your
application. The chapter describes features of the standard and extended keyboards, and
discusses using sound, hierarchical menus, and scrolling menus in your application.
For more information on the Apple human interface, see the Human Interface Guidelines:
The Apple Desktop Interface.

Compatibility

Guidelines

The Compatibility Guidelines chapter describes issues relating to compatibility for various
managers in system software version 7.0. It also includes details on pop-up menus, movable
modal dialog boxes, new routines for manipulating dialog items in a dialog box, and
discusses menu access when an application displays a modal dialog box.
The chapter also shows you how to call Gestalt, the new function for determining various
attributes, versions, and features of the system software.

P-8

An Overview of the Chapters in Volume VI

Preface

The chapter gives guidelines you should follow to help ensure that your application is compatible across the Macintosh family of computers. It also provides information on how
to make your application compatible with A/UX® (Apple’s version of the UNIX® operating
system) and presents a brief overview of how to write software that can be easily localized
for use in other regions.

The

Edition

Manager

The Edition Manager chapter describes how you can let users publish and subscribe data
among many documents. The Edition Manager is part of the interapplication communications
(IAC) architecture in version 7.0. See the Edition Manager chapter for sample code that
shows how to add publish and subscribe capabilities to your application.

The

Event

Manager

The Event Manager chapter in Volume VI includes information on all events, including
suspend and resume events. The chapter incorporates information from Programmer’s Guide
to MultiFinder and replaces the information found there. The Event Manager chapter in this
volume also describes how to send and receive high-level events.
For specific information on keyboard events, the modifier flags field of the event record,
reading the keyboard and keypad, and responding to mouse events or disk-inserted events,
see the Toolbox Event Manager chapter in Volume I.
You also may want to read about the Operating System Event Manager, described in
Volume II. The Operating System Event Manager handles low-level, hardware-related
events. The Operating System Event Manager chapter also describes how your application
can post its own events in the event queue. You usually use the Event Manager to send
and retrieve events. For information on the PPostEvent function, see the Operating System
Event Manager chapter in Volume IV.
For information on standard keyboards, an addition to the modifier flags field in the event
record, and the KeyTrans function, see the Toolbox Event Manager chapter in Volume V.

The

Apple

Event

Manager

The Apple Event Manager chapter describes Apple events and how your application can
receive and process the required set of Apple events. It also describes how to create and
send Apple events.

The

Program-to-Program

Communications

Toolbox

The Program-to-Program Communications (PPC) Toolbox chapter describes how your application can exchange message blocks with other applications. The PPC Toolbox provides
low-level control of communication and is generally more suitable for code that is not eventbased or desk accessories or applications that are closely integrated.

An Overview of the Chapters in Volume VI

P-9

Inside Macintosh,

The

Data

Volume

Access

V1

Manager

The Data Access Manager chapter describes how your application can communicate with a
database application or other data source running on a remote computer. The chapter
describes how your application can use high-level or low-level routines to initiate communication with a remote data server, send commands or data to the server, and, after the server
executes the commands, retrieve any requested data from the server.

The

Finder

Interface

The Finder Interface chapter in this volume describes how to create bundles, file references,
and icons, including small icons and color icons. Code listings show how to set up the
resources the Finder needs to start up your application and display your application’s icons
on the desktop.
The chapter also describes changes to the Finder interface—for example, the new aliases and
stationery documents. It shows how to find special folders, such as the Preferences folder
and Temporary Items folder. In addition, the chapter describes how fonts and sounds are

visible on the desktop and how the user installs fonts and sounds by moving their icons to the

System Folder icon.

The Finder Interface chapter describes the Desktop Manager, a new manager that lets your
application add or remove information from the desktop database.
The Finder Interface chapter in this volume replaces the Finder Interface chapters in
Volumes III and IV.

Control

Panels

The Control Panels chapter in this volume describes the new behavior of control panels in
system software version 7.0. If you develop video cards, you can also use the information
in the chapter to create an Options dialog box for the Monitors control panel.
The Control Panel chapter in Volume V describes how to write a control panel. Read the
information in the Control Panels chapter in this volume for additional information on writing
a control panel in system software version 7.0. Control panels written for earlier versions of
system software are compatible with version 7.0.

The

Help

Manager

The Help Manager chapter discusses how you can provide help balloons that supply your
users with information that describes the actions, behaviors, or properties of elements of
your application. The chapter explains how to create help balloons for menus, windows,
icons, controls, and other elements of the user interface of your application.

P-10

An Overview of the Chapters in Volume VI

Preface

The

Font

Manager

The Font Manager chapter in Volume VI describes how your application can take advantage

of TrueType™ fonts.

The Font Manager chapter in Volume I describes how the Font Manager works with
QuickDraw to draw characters. It discusses font numbers, character styles, font size,
scaling factors, the ascent line, the base line, the descent line, and leading. The chapter
also describes the format of a bitmapped font.
The Font Manager chapter in Volume IV discusses bitmapped fonts (of resource type 'FONT'
or 'NFNT") and font families (of resource type 'FOND'). It describes a few data structures,
like the font family record.
The Font Manager chapter in Volume V includes information on fractional character widths,
the font search algorithm (how the Font Manager looks for a particular font), and how to
specify colors for a font.

The

Resource

Manager

The Resource Manager chapter in Volume VI lists the standard resource types in version 7.0.
The chapter also describes routines that you can use to read or write part of a resource.
The Resource Manager chapter in Volume I describes how you can store menus, fonts,
icons, and other data as resources. It gives definitions and descriptions of resource files,
resource forks, and data forks. It describes how to create and open resource files, how to
read resources from a resource file, and how to add, remove, update, and write resources
to a resource file.
The Resource Manager chapter in Volume IV describes a few routines that search only the
current resource file (these routines have the numeral

| in their routine name). It also

describes two advanced functions, RsrcMapEntry and OpenRFPerm.

The Resource Manager chapter in Volume V describes the RGetResource function and lists
resource types, ROM resources, and resources in the System file.

Worldwide

Software

Overview

The Worldwide Software Overview chapter provides an introduction to scripts and script
systems. It can help you design your application so that it is compatible with Macintosh
computers throughout the world.
See the Worldwide Software Overview chapter for an introduction to worldwide issues, and
see the User Interface Guidelines chapter for guidelines about developing your application for
use around the world. See the International Utilities Package chapter in Volume I for
information on displaying numbers, currency, time, and dates in the correct format for
various countries around the world. Macintosh Worldwide Development: Guide to System
Software (available from APDA) replaces the Script Manager chapter in Volume V and
provides a more complete description of all components of the worldwide system software.

An Overview of the Chapters in Volume VI

P-1]

Inside Macintosh,

Volume

VI

TextEdit
The TextEdit chapter in this volume describes how TextEdit provides support for working
with different script systems. It describes how you can use TextEdit to let the user edit and
display text in multiple scripts and styles when a non-Roman script system is in use. TextEdit
automatically handles text that uses more than one script, style, or direction.
The TextEdit chapter in Volume I introduces TextEdit and explains how your application
can use TextEdit routines for basic text formatting and editing.
The TextEdit chapter in Volume IV describes how TextEdit supports automatic scrolling
of text.
The TextEdit chapter in Volume V explains how TextEdit lets you vary text attributes such as
size, style, and font. It also describes the style record that stores the style information.

Graphics

Overview

The Graphics Overview chapter provides an introduction to graphics on the Macintosh
computer. The system software provides a rich set of routines that support quick drawing
of objects such as circles, rectangles, and text. The Graphics Overview chapter introduces
many of the concepts and data structures explained in greater detail in the chapters on Color
QuickDraw, the Picture Utilities Package, the Color Picker Package, the Palette Manager,
and the Graphics Devices Manager.

Color

QuickDraw

The Color QuickDraw chapter in Volume VI describes how version 7.0 supports both
indexed and direct specification of color. It also describes changes to the pixel map record
and the PICT2 file format, and it describes a routine that lets you convert a bitmap record into
a region. The information in the Color QuickDraw chapter in this volume supplements the
QuickDraw chapter in Volume I and the Color QuickDraw chapter in Volume V.
The QuickDraw chapter in Volume I introduces the basic concepts of QuickDraw, including
descriptions of the mathematical foundation of QuickDraw and the graphics environment that
QuickDraw provides. It also describes QuickDraw routines.
The Color QuickDraw chapter in Volume V describes how Color QuickDraw provides
support for drawing objects using a large number of different colors.

The

Picture

Utilities

Package

The Picture Utilities Package chapter describes routines you can use to examine the contents
of pictures and pixel maps.

P-12

An Overview of the Chapters in Volume VI

Preface

The

Color

Picker

Package

The Color Picker Package chapter in this volume describes how to present users with a
standard user interface for selecting a color. This chapter replaces the Color Picker Package
chapter in Volume V.

The

Palette

Manager

The Palette Manager chapter in this volume describes palettes, the default color tables, and
how to create and use a palette to control the color environment. This chapter replaces the
Palette Manager chapter in Volume V.

The

Graphics

Devices

Manager

The Graphics Devices Manager chapter describes how you can prepare offscreen graphics
and move them quickly into view. It also provides useful information if you are developing
a graphics-intensive application. This chapter replaces the Graphics Devices chapter in
Volume V.

The

Sound

Manager

The Sound Manager chapter in this volume completely replaces any previous information in
Inside Macintosh regarding the Sound Manager. The Sound Manager chapter in Volume VI
is the complete reference and guide for the use of sound. It provides an introduction to sound
and describes sound synthesizers, sound channels, sound commands, sound resources, and
sound files.
The chapter also describes how your application can use the Sound Manager to create and
play sounds, mix and synchronize multiple channels of sound, expand and compress sound
data, and play sounds continuously from disk.
See the Sound Manager chapter in this volume if you want to use any kind of sound in your
application, even if you only want to use the SysBeep procedure.

The

Time

Manager

The Time Manager chapter in this volume describes the original Time Manager, the revised
Time Manager (available in system software version 6.0.3 and later), and the extended Time
Manager (available in system software version 7.0). It completely replaces the Time Manager
chapter in Volume IV.
The chapter describes how to schedule a routine for later execution, how to schedule a routine
to execute at periodic intervals, and how to compute elapsed time. It also describes other
time-related services, such as those provided by the TickCount and Delay functions, and the
Vertical Retrace Manager.

An Overview of the Chapters in Volume VI

P-]3

Inside Macintosh,

The

Volume

Notification

VI

Manager

The Notification Manager chapter describes how to notify users of significant occurrences
relating to your application when your application is running in the background. Device
drivers, VBL tasks, Time Manager tasks, completion routines, startup code, desk accessories, and applications can use the Notification Manager.
The Notification Manager chapter in this volume replaces the information in Appendix D of
the Programmer’s Guide to MultiFinder.

The

File

Manager

The File Manager chapter in this volume describes how to create a file specification to identify
a file, folder, or volume. It also describes how you can use the File Manager to search for
and quickly find files.
The File Manager chapter in Volume IV describes the file system, including the Macintosh
File System (MFS) and Hierarchical File System (HFS). The chapter provides descriptions
of File Manager data structures and routines.
The chapter on File Manager Extensions in a Shared Environment in Volume V presents
routines that allow your application to more easily execute in a shared environment.

The

Standard

File Package

The Standard File Package chapter in this volume describes the StandardGetFile and
StandardPutFile procedures available in version 7.0. You can use these two procedures
to present the standard user interface when a user opens or saves a file. The chapter also
describes the two new procedures CustomGetFile and CustomPutFile, which let your
application exercise more control over the user interface when opening and saving files.
The Standard File Package chapter in Volume I describes the original procedures that
present the standard user interface for opening and saving files in earlier system software.

The Standard File Package chapter in Volume IV describes modifications to the original
procedures for use with the Hierarchical File System.

The

Alias

Manager

The Alias Manager chapter describes how to create and resolve alias records—a new data
structure that describes a file, folder, or volume.
You can use alias records instead of conventional file specifications to store file or directory
information. If you create an alias record, your application can use the Alias Manager to
locate the file or directory when needed—even if the user has renamed it, copied it, restored
it from backup, or moved it. The chapter describes the routines you can use to manage the
information in alias records.

P-14

An Overview of the Chapters in Volume VI

Preface

Memory

Management

The Memory Management chapter in Volume VI describes 32-bit addressing, virtual memory,
and routines that let your application use available temporary memory. The chapter replaces the
discussion of temporary memory in Chapter 3 of the Programmer’s Guide to MultiFinder.
The Memory Manager chapter in Volume II describes the system heap zone and application
heap zone, how to allocate memory blocks, and how to avoid memory fragmentation. It also
discusses dereferencing a handle, lists general-purpose data types, shows the organization of
memory, and gives an overview of the stack and the heap. The routine descriptions discuss
how to set the heap zone size, create handles and pointers, allocate relocatable and
nonrelocatable blocks, and how to free memory in the heap.
The Memory Manager chapter in Volume IV describes improvements to Memory Manager
routines that are largely transparent to your application. It also describes routines that let your
application set or clear flags that the Memory Manager associates with each relocatable block.

Process

Management

The Process Management chapter describes how the Process Manager schedules applications for execution and manages access to shared resources. It describes routines that let
your application get information about any or all running applications. The chapter replaces
the discussion of launching applications found in the Programmer's Guide to MultiFinder.

The

Slot

Manager

The Slot Manager chapter in this volume describes how version 7.0 supports 32-bit
addressing of NuBus™ cards. The Slot Manager chapter in Volume V gives an overview
of the firmware of a slot card, explains the slot parameter block, and describes Slot
Manager routines.

The

Power

Manager

The Power Manager chapter describes a manager used only with the Macintosh Portable in
system software version 6.0.4 and later. This information is useful only if you are writing a
device driver or application that might be affected when power for the various subsystems of
the Macintosh Portable is shut off.

The

AppleTalk

Manager

The AppleTalk Manager chapter in this volume describes how version 7.0 supports various
link access protocols (for example, the LocalTalk® Link Access Protocol and the EtherTalk®
Link Access Protocol) that can be used for AppleTalk communication. It describes the
AppleTalk Data Stream Protocol (ADSP), a new protocol your application can use to
exchange information between two equal entities.

An Overview of the Chapters in Volume VI

P-15

~~
pr}

=)
oO
fe)

Inside Macintosh,

Volume

VI

The chapter explains how you can request that your program receive notification each time
another routine opens or closes the .MPP driver or whenever another routine is about to
close the .MPP driver.
The chapter also discusses how the LAP Manager lets your application control communication over non-LocalTalk networks, such as Ethernet. In addition, it provides information

you can use to write your own protocol handler for Ethernet or 802.3.

The AppleTalk Manager chapters in Volumes II, IV, and V provide additional information on
the device drivers and protocols associated with AppleTalk.

A ROAD

MAP

TO VOLUME

VI

Figure P-1 shows each chapter in this volume. If you need to read related chapters in earlier
volumes of Inside Macintosh for additional information, those other volumes are also shown.
For each chapter, the volumes are shown in the order in which you should read them; the
volumes shown are the only ones you need to read for information on that topic.

P-16

A Road Map to Volume VI

Preface

Volume VI Chapter

Volume Priority

Introduction to the System Software
Version 7.0 Environment

|]

MM
——

User Interface Guidelines

Compatibility Guidelines
Edition Manager
Event Manager

|| 1

||IV||V|/VI

Mi

§|/VI

Color Picker Package || yj
Palette Manager

ao
IE

ly

Data Access Manager

uv

Finder Interface

u

Control Panels

v jw

IV

Vv

|

=

Graphics Devices Manager

—||\y

7-

—

6

||

Sound Manager

—
||

Time Manager

a

Notification Manager =

VI
{ined
—

||yy

File Manager | |Iv|/v
Standard File Package

Help Manager

|/VI

MATA,

Alias Manager
——>

|!

ae

Resource Manager |}!

———

IV||

ViVi

ee

||IV|| V||VI

vl

——

Memory Management

ufiv|vi
:

Process Management

o

Slot Manager

Vi

Power Manager
a4

=|

z]re|

TextEdit

[vl

<<

Picture Utilities Package

i||VI

Program-to-Program

Worldwide Software Overview

—

ii

—
_|/VI

Font Manager

aa

ee

ee

Apple Event Manager
eet
Communications Toolbox

Volume Priority

:

—>

Vij}

Volume VI Chapter

Graphics Overview

AppleTalk Manager

Figure P-1. A road map to Volume VI

A Road Map to Volume VI

P-17

Inside Macintosh,

P-18

Volume VI

INTRODUCTION TO THE SYSTEM
SOFTWARE VERSION 7.0 ENVIRONMENT
About This Chapter
About the System Software Version 7.0 Environment
The Cooperative Multitasking Environment
Interapplication Communication
Sharing Data Among Applications
Sending Events Between Applications
Exchanging Message Blocks Between Programs
Remote Data Access
Enhanced User Interface
Sound
TrueType Fonts
Graphics
File Management
Memory Management
Temporary Memory
24-Bit and 32-Bit Addressing
Process Management
Timing Services
Compatibility
Worldwide Development
Communication Over a Network
Hardware Interfaces
Overview of Chapters in This Volume

ne
—

i)
—

ise |

i}
Qu
fo)
CQ

&.
=)
i}

[-]

Inside Macintosh,

1-2

Volume VI

Introduction to the System Software Version 7.0 Environment

ABOUT

THIS

CHAPTER

This chapter describes the operating environment for applications that run in system software
version 7.0. It also provides general information about the features available to you when you
design an application to run in the system software version 7.0 environment.
Read this chapter for an overview of how your application can use the Macintosh®
User Interface Toolbox and Macintosh Operating System routines in system software
version 7.0 to
m share data with other applications using the Edition Manager

—

= communicate with other applications using the Event Manager, Apple® Event Manager,
or the Program-to-Program Communications (PPC) Toolbox
m access data from other sources, including remote databases, using the Data Access
Manager

or |

)
2.
—
CO

=.
i)
i}

m play sounds using the Sound Manager
= keep track of specific files using the Alias Manager
= perform quick searches for specific files using the File Manager
m provide on-line assistance for users with the Help Manager

a draw TrueType™ fonts using the Font Manager
= use direct devices for graphics applications using Color QuickDraw™
= function in worldwide markets using the Script Manager, International Utilities
Package, and TextEdit

This chapter discusses the features and managers new to version 7.0. In addition, see
the Preface, where “A Road Map to Volume VI” shows each manager discussed in this
volume and illustrates a pathway through related information in previous volumes of
Inside Macintosh.
Although Volume VI focuses on system software version 7.0, many of its chapters contain
information that is also relevant to system software version 6.0 and later. See the

Compatibility Guidelines chapter in this volume for information on developing applications
that can run in both system software version 6.0 and system software version 7.0.

About This Chapter

—

~-

1-3

Inside Macintosh,

Volume VI

ABOUT THE SYSTEM SOFTWARE
VERSION 7.0 ENVIRONMENT
System software version 7.0 extends the environment of the Macintosh computer by
providing even greater support for cooperation between applications. The user interface
continues to build on solid design principles and provides additional benefits; for example,
in version 7.0 users can more directly manipulate icons on the desktop and users can

customize the Apple menu. The Finder™, the Macintosh Operating System, and the User
Interface Toolbox provide and maintain this environment.

The Finder is the system application that lets users organize and manage applications, documents, folders, and disks on the desktop. Users can choose commands from the Finder menu
bar or use the mouse to perform various tasks. Because the Finder presents the standard
interface that the user becomes familiar with, you need to make sure that your application
performs in an expected manner in the Finder environment.
Macintosh users also expect certain standard behavior from Macintosh applications; for
example, all applications should provide File and Edit menus. Macintosh applications that
follow the user interface guidelines provide consistency and let users determine what action
to take to perform a particular task.
In earlier Macintosh computers a user ran one application at a time. Today’s Macintosh
model recognizes that a user often wants to run many applications at once. System software
version 7.0 provides this cooperative environment.
In system software versions 5.0 and 6.0, the MultiFinder® option provided a cooperative
multitasking environment. In system software version 7.0, the features of MultiFinder are
integrated into the Macintosh Operating System.
The Macintosh Operating System lets the user have several applications open at the same time
and lets the user switch between them. The Operating System also gives the user constant
access to the Finder. This lets a user move among open documents and applications without
having to save or quit the previous document or application. This environment also allows
applications to run in the background. For example, the Finder can copy files while the user
is working on another task in the foreground.
The cooperative environment of the Macintosh allows multiple applications to share the CPU
and other resources. You need to understand how this environment can affect your application.
The next section, “The Cooperative Multitasking Environment,” explains this in more detail.
An important aspect of system software version 7.0 is interapplication communication
(IAC), a new collection of features that help applications work together.
Copy and paste is a simple way in which Macintosh applications work together by sharing
data. In system software version 7.0, applications can provide automated copy and paste
features (that is, your application can automatically update the data that the user pastes into a
document when the original source of information changes). Applications can extend this
concept by using high-level events to request that other applications perform a particular task
or return requested information. Applications and drivers that require close integration with
each other can also extend this concept by reading and writing low-level message blocks.
1-4

About the System Software Version 7.0 Environment

Introduction to the System Software Version 7.0 Environment

Apple Computer, Inc. has defined a protocol for high-level events called the Apple Event
Interprocess Messaging Protocol. High-level events that adhere to this protocol are called
Apple events. You can help ensure effective communication with other applications by using
this protocol.
Macintosh applications in system software version 7.0 can respond to incoming high-level
events from other applications as well as events generated by the user, and they can also send
high-level events to other applications. Better cooperation and communication between
applications help users to get the most out of any one application or to use the best features
from many applications—in effect, combining the features of many applications to achieve
the desired result.
By including the features provided by IAC in your application, you give the users of your
application even greater power, ease of use, and flexibility in accomplishing their tasks.

=
=

=

ee
gx}

Figure 1-1 highlights the general areas for which system software version 7.0 provides
routines. The next sections describe these topics in greater detail.

i)
jor
—

Q

=F

=ij

Sound=>|

Sharing dynamic data
s

Communicating between
applications

4

£.

a
ft
Sharing files across a network
Accessing remote databases

Interapplication
communication

(IAC)

Playing sound continuously from disk
Compressing & expanding sound data i

Recording sound
Graphics mm

¢= Networking

A

Keeping track of

specific files
to

Xr

oe

fonts

management

\

a

Color windows & icons

¢= Worldwide

Supporting multiple scripts

Formatting dates & numbers

interface

Movable modal dialog boxes

Z

Cooperative mm} Cooperating with other

multitasking

\

24-bit & 32-bit addressing

Temporary memory

Drawing fonts in
any size

____User ®) Balloon Help

Localizing applications

Virtual memory

Examining picture

information
=

TrueType=|

!
|= File

EAAAZ Sorting strings

i
Supporting direct devices Se

environment

= alee

ae

ner

applications

| Performing tasks in the

Beehoreune

Version 7.0

environment

Figure 1-1. Features of the system software version 7.0 environment
About the System Software Version 7.0 Environment

1-5

Inside Macintosh,

The

Volume VI

Cooperative

Multitasking

Environment

The cooperative multitasking environment is a standard part of system software version 7.0.
The Macintosh Operating System and the Finder work together to provide this environment.
MultiFinder is now transparent to the user; the user always has the capability to run more than
one application at a time. Because the user may choose to run other applications in addition to
your application, your application needs to be capable of existing in a shared environment.
The Operating System schedules the processing of all applications and desk accessories.
When a user opens a document or application, the Operating System loads the application
code into memory and schedules the application to run. The application runs at the next
available opportunity. The next available opportunity usually means when the current process
or application gives up the CPU. In most cases, the application runs immediately (or appears
to the user to run immediately).
Once an application is executing, the CPU is available only to that application. The application can only be interrupted by hardware interrupts, and these are transparent to the
application. However, to allow the user to interact with your application and others, you
must periodically relinquish the CPU using the WaitNextEvent or EventAvail function.
Using these event routines in your application lets the user interact with your application
and also with other applications.
Although the user can have a number of open documents and applications, only one
application is the active application. The active application is the application currently
interacting with the user; its icon appears in the right side of the menu bar. The active
application displays its menu bar and is responsible for highlighting the controls of its
frontmost window.
When your application is the active application and the user switches to another application
(by clicking in the window of a document belonging to another application, for example), the
Operating System sends your application a suspend event. When your application receives a
suspend event, it should prepare to suspend processing, allowing the user to switch to the
other application. For example, in response to a suspend event, your application should
remove the highlighting from the controls of its frontmost window and take any other
necessary actions. The suspension actually occurs the next time your application calls
WaitNextEvent or EventAvail.
Your application also needs to be able to resume processing when the user chooses to work

with your application again. Your application receives a resume event when the user switches
back to your application. In response to a resume event, your application should update the
contents of its windows and highlight the controls of its frontmost window.
The Operating System preserves the environment of your application when it is suspended
and restores that environment before sending it a resume event. Your application does
not need to preserve or restore the operating environment in response to suspend or

resume events.

When you perform user testing of your application, you might want to observe people using
other applications as well as your application, to make sure that your application works well
in a cooperative environment.
See the Compatibility Guidelines and the Event Manager chapters in this volume for specific
information on how your application can handle suspend and resume events and how your
application can take advantage of the cooperative multitasking environment.
1-6

About the System Software Version 7.0 Environment

Introduction to the System Software Version 7.0 Environment

Interapplication

Communication

The interapplication communications architecture provides support for
m automated copy and paste between applications
m sending and receiving events between applications
m reading and writing blocks of data between applications

Macintosh OS & Toolbox

uoT}ONpoAyUy

|

The Edition Manager, Apple Event Manager, Event Manager, and PPC Toolbox provide
these features, and Figure 1-2 shows their relationships.

if:

WT Ecition Manager |
:

L>

:

7

Apple Event Manager|

arr

Event Manager

ea

|
Se

PPC Toolbox

|

Figure 1-2. The managers constituting the interapplication communications architecture
The IAC architecture is built on communication and cooperation between applications. Apple
has defined important standards to help ensure that communication between applications is
effective. Using the Clipboard, applications can share static data by allowing the user to copy
and paste data between documents. Using the Edition Manager, applications can support
dynamic data sharing and allow users to perform automatic copy and paste between documents. Applications that support dynamic data sharing allow users to copy data from one
document to another and receive automatic updating of the information when the data in the
original document changes. The verbs publish and subscribe describe this form of dynamic
data sharing.
You can let users publish and subscribe among many documents by using the Edition
Manager and implementing the Create Publisher and Subscribe To menu commands. This
is a form of high-level communication between applications; actually, the communication
is indirect, as the Edition Manager provides the interface that allows applications to share
dynamic data.
Your application can publish and subscribe with applications and documents on a local disk
or across a network. In general, anything that you allow the user to copy or paste you should
also allow the user to publish or subscribe to. See “Sharing Data Among Applications” later
in this chapter for more information on using the publish and subscribe features in your
application.
About the System Software Version 7.0 Environment

1-7

Inside Macintosh, Volume VI

Using the Apple Event Manager, applications can send Apple events to each other to request
services or information. These types of events are often the result of a user request, or they
can be specific events that your application sends to another application. Apple events provide
a standard way in which your application can communicate with many other applications.
Other high-level events are for applications that choose to use a protocol other than the Apple
Event Interprocess Messaging Protocol (AEIMP). Applications can use the Event Manager to
send high-level events that follow their own protocol.
The Program-to-Program Communications (PPC) Toolbox is a set of low-level routines that

allow applications to communicate on the local computer or over a network. Using the PPC
Toolbox, applications can exchange blocks of data with each other by reading and writing
low-level message blocks. The PPC Toolbox provides a method of communication between
applications that is more useful for applications that are closely integrated, specifically
designed to work together, or dependent on each other for information. The PPC Toolbox
is typically more useful for code that is not event-based.

Your application can use the PPCBrowser function to allow the user to choose another application to which to send high-level events or low-level message blocks. The PPCBrowser
function provides a standard user interface for choosing an application to communicate with,
much like the Standard File Package provides a standard user interface for opening a file.
All these forms of interapplication communication are based on the premise that applications
cooperate with each other. Both the application sending the high-level event or low-level
message block and the application receiving it must agree on the protocol of communication.
Figure 1-3 shows that your application can use the Edition Manager to publish and subscribe
data. Your application can use the Apple Event Manager to send and process Apple events
and the Event Manager to send and receive high-level events. Your application can use the
PPC Toolbox to read and write low-level message blocks. Your application can use any of
these methods to communicate with other applications located on the same computer or across
a network.
As Figure 1-3 shows, managers in the IAC architecture can use the services of other
managers. For example, the Apple Event Manager uses the communication services
of the Event Manager. The Event Manager in turn uses the PPC Toolbox on behalf
of applications.

Figure 1-4 shows how two different applications can use the Edition Manager to publish and
subscribe, and how they can use the routines provided by the Apple Event Manager, the
Event Manager, or the PPC Toolbox to communicate with each other.

The next sections describe the three parts of the IAC architecture: the Edition Manager, the
Apple Event Manager and Event Manager, and the PPC Toolbox.

1-8

About the System Software Version 7.0 Environment

Introduction to the System Software Version 7.0 Environment

4?
Edition

Apple

events

4f

High-level
events

4

s

Low-level
message
blocks

| Edition Manager|
a

Né@

| Apple Event Manager

yEvent Manager

|

I

|

—
—

im

as
—

°

=
=

PPC Toolbox

i)
-

—e

S—

Lad

/

Figure 1-3. Using interapplication communication

Apple
~ | | events

ae
=af

ner

ef

EL

| Edition Manager|

B

message
blocks

Apple Event Manager

| oo tl
zl, 4
aaa]

|

: Low-level

Event Manager

TT

PPC Toolbox

Figure 1-4. Applications using interapplication communication

About the System Software Version 7.0 Environment

1-9

Inside Macintosh,

Sharing

Volume VI

Data Among

Applications

The Edition Manager lets applications share dynamic data at the user’s request. (The Clipboard
lets applications share static data.) You build publish and subscribe capabilities into your
application in much the same way that you build copy and paste into your application.
Using the Edition Manager, you can let a user publish data by selecting a portion of text,
graphics, or other data within a document and choosing Create Publisher from the Edit
menu. When the user performs this action, your application saves the selected information
in a separate file. The information that is stored in a separate file is referred to as an edition.
You can also let a user subscribe to data in an edition by choosing Subscribe To from the
Edit menu; when the user chooses an edition, your application includes the information
from the edition in the current document. The information in an edition can be shared by
many documents.
A publisher is a portion of a document that is made available to other documents through an
edition. A subscriber is a portion of a document that receives the information from an edition.
Figure 1-5 shows a document containing a publisher, a file containing an edition, and a
document containing a subscriber. The bottom fish in the Fishes of the World document is a

publisher. The information from this publisher is made available to other documents through
the Illustration edition. The Aquarium poster document contains a subscriber that gets its
information from the Illustration edition. Note that when a user selects a publisher or

subscriber within a document, your application should display a border surrounding the
publisher or subscriber.

In general, when a user modifies the contents of a publisher and saves the document, your
application should write the new data to the edition. The Edition Manager then informs all
open applications with documents that subscribe to the edition that the edition contains
updated information. These applications can then automatically update the subscribers in

se

i——-~

-

paar a

er ,
‘

)

|

ex
Illustration

|
E X PERIE

Fishes of the

World

|

3

Au;

The Aquarium
The sigh akjdh
ajdn | The sich aigdh
Cvxjs dkjx_ IN jhche
vijs Gikjpd. IN jhche
ashdjn hxcgjhc zjxc.
ashdin hacgjhe zjxc.
Thanks
to jvh znacjk | Thanks
to jvh znacjk
xgychz zhoc, Hit zxc
xcjenz zh.
apie Ze zgcigz zi
zyNe He Tgexz 7
xhajndink dtuw Cj
xhajndink Caw

G abyex sais.

G atycx zigers.

Aquarium poster

Figure 1-5. A publisher, an edition, and a subscriber

1-10

NCE

About the System Software Version 7.0 Environment

The sich aigch
ajdh
Cyxjs dip. IN j
ashgjh hxcgjhc zjxc.
Thanks
to jvh znx
xqjychz zhge. Hit
ape Te zigczzi
aha of

G ahicx ziqais.

Introduction to the System Software Version 7.0 Environment

the documents. For example, in Figure 1-5, if the user changes the color of the fish in the
Fishes of the World document and then saves the document, the change can be automatically
made in the Illustration edition and the Aquarium poster document.
Figure 1-6 shows how a user might create a poster by using information from other documents. For example, the user could subscribe to separate editions containing an illustration
created by a graphics designer, text created by a writer, and a headline created by an editor.

iN

be

224
Illustration
EXPERIENCE
The Aquarium tee

—
—

_
_
ona

y)

"

=
Title text

Text for poster

E

X

P

E

R

| E

N

The Aquarium

The sich akjdh axih
The sidh akjdh
cvs digxt IN fnchc
cCvajs dkjxt IN jhchc
ashagh hucgjhe zjxc
ashdjh hxcgjhe zjxc.
Thanks to jh znxcjk | Thanks to jvh znacjk
xejchz zhgc. Hif zxc
rqychz zh
Zhe zc Zicckjz ZI
zh zie zkjckz zt
xhajndjnk diturw dj
xhajhdjhk ojtuw
G alicx zwais.
G anicx zkjais

—

C

u
-_~
=

E

-

—

2)
—
_s
~
=

The sich aiddh ajdh
Cvxjs dkjxt IN|
ashdjh hxcgine zZyxc.
| Thanks to jvh znx
xcjen2z zhge. Hif
apc zc zigckjz zi
xhajhdink d#
G ahjcx zkjais.

—

—

Aquarium poster

Figure 1-6. Sharing dynamic data with other applications
Your application should save the new information in the edition whenever the user edits the
publisher and saves the document that contains the publisher—unless the user has indicated
that the information should be saved in the edition on request only. Saving new information
in an edition replaces the previous contents of the edition.
When the information in an edition changes, the Edition Manager informs your application.
Your application should then update any subscribers with the new information from the
edition (unless the user has indicated that updates should be incorporated on request only).
For example, a user might open a word-processing document called My Stocks that accesses
information from an edition called Stock Report. The Stock Report edition might be updated
twice a day by an on-line database. As the information in the edition changes, the My Stocks
document can receive automatic updates with the latest information.
You can implement publish and subscribe capabilities in your application by using the
routines provided by the Edition Manager and supporting the required set of Apple events.
See the Edition Manager chapter for sample code that shows how to add these features to
your application.

About the System Software Version 7.0 Environment

1-11

Inside Macintosh,

Sending

Volume VI

Events

Between

Applications

The Macintosh Operating System provides routines that allow your application to send and
receive events using the Apple Event Manager and Event Manager. The Event Manager
provides a general method for communication between applications. The Apple Event
Manager provides a standard method of communication between applications using the
Apple Event Interprocess Messaging Protocol. (The PPC Toolbox can be used to read
and write low-level message blocks and is more useful for applications that are closely
integrated or perform coordinated tasks.)
Using the Apple Event Manager or Event Manager, applications can send events to other
applications to request services or information. You can send these events between applications on the same computer or between applications located on different computers on a
network. The Apple Event Manager uses the services of the Event Manager to send and
receive Apple events. The Event Manager uses the communication services of the PPC
Toolbox on behalf of your application to send and receive events.
For high-level events and Apple events, the applications involved must agree on what
they can ask each other and on the action that should be taken in each situation. Both the
application sending the event and the application receiving the event must agree on the
protocol of communication.
Your application should support at least the required set of Apple events sent by the Operating
System. If you plan to implement publish and subscribe capabilities, your application should
also support the Apple events sent by the Edition Manager. You can also implement other
common Apple events or design your own customized Apple events. In addition, sets of
Apple events exist for many specific categories of applications (for example, word processors
or spreadsheets).

If your application acts on an Apple event, it should perform the standard action requested by
that event. This helps ensure that other applications (and eventually users) can send an event
to a particular type of application and expect the other application to understand and act on the
event in a standard way.
In most cases, you should use Apple events to communicate with other applications.
However, if necessary, you can implement your own protocol for high-level events.
Figure 1-7 shows how two applications might use high-level events. For example, a
user might need to update the telephone numbers of everyone in the marketing department.
To accomplish this, the user might use a word-processing application to send a highlevel event with the new telephone numbers across a network to a directory application
running on a Macintosh computer at the company’s headquarters. When the telephone
directory application receives the high-level event, it updates its directory with the new
telephone numbers.

See the Event Manager chapter in this volume for information on how to send and receive
high-level events. See the Apple Event Manager chapter for information on the Apple Event
Interprocess Messaging Protocol.

1-12

About the System Software Version 7.0 Environment

Introduction to the System Software Version 7.0 Environment

Update phone
numbers for
marketing

Phone numbers: | 089-555-1910
019-555-0987
089-555-0987
019-555-4563
089-555-4563
019-555-2169
089-655-2169
019-555-0190
089-555-0190
019-555-1092
069-555-1092
089-555-3830
089-555-0298

<=
iy
alia

Highlevel
events

Phone numbers:
019-555-0987
019-555-4563
019-555-2169
019-555-0190
019-555-1092

|

Pr

Event Manager

PPC Toolbox
\

L

Directory

High-

level
events

|

|

|

|

Event Manager

PPC Toolbox
n

=

|

om
5
=

|

S
i)

|

Figure 1-7. Sending events to other applications

Exchanging

Message

Blocks

Between

Programs

Using the Event Manager or Apple Event Manager to send events should meet the needs of
most applications for program-to-program communication. However, for low-level control or
to get services not provided by the Event Manager or Apple Event Manager, you can use the
PPC Toolbox. The PPC Toolbox lets you send larger amounts of data to other applications
located on the same computer or across a network. The PPC Toolbox can also be used by
pieces of code that are not event-driven. The PPC Toolbox is usually called by the Operating
System; device drivers, desk accessories, or other code modules can also use it.
Using the PPC Toolbox to send data between programs requires that both your program and
the program you’re communicating with are open at the same time. To initiate communication, one program opens a port and requests a session with another program. The target
program must also open a port and accept the request. Once a session is established, the two
programs can read and write low-level message blocks.
See the Program-to-Program Communications Toolbox chapter in this volume for information on reading and writing low-level message blocks between programs.
About the System Software Version 7.0 Environment

1-13

Inside Macintosh,

Remote

Volume VI

Data

Access

Using the Data Access Manager, your application can communicate with databases or other
data sources running on a Macintosh computer or on a remote host computer. For example,
your application can use high-level routines to open a document containing commands to be

sent to a remote data server; initiate communication with the remote data server; send the
commands to the server; and (after the server executes the commands) retrieve the requested

data from the server. You can also use the Data Access Manager to send data to a remote
database or other data source.

If your application knows how to create commands for a remote data server, then your application can use low-level routines to send these commands and data directly to the data server.

o=s

=

@

a

Figure 1-8 shows how a user in San Francisco might use a spreadsheet application to request
data from a company database in New York. The spreadsheet application can use the Data
Access Manager to request the data from the database. The database application in New York
sends back the requested data, and the spreadsheet application can use this data to generate a
graph of the information.

<[t2[47[89]78]56]"**

mk

San cain
i

Graph monthly sales
data for:

®New
[

York

cancet

|

OS.F.

ODallas
|

OK

|

‘

~

Monthly Sales,
New York

Y

B

$30M

$20M
$10M
FY 1988

Figure 1-8. Requesting data from a remote database
See the Data Access Manager chapter for information on sending and retrieving information
from a remote database or other data source.

1-14

About the System Software Version 7.0 Environment

Introduction to the System Software Version 7.0 Environment

Enhanced

User

Interface

The user interface for system software version 7.0 contains noticeable improvements, such as
support for movable modal dialog boxes, and several new features. The Apple menu can now
contain applications, documents, folders, or other Finder objects. You can supply small icons
that the Finder displays in the Apple menu for your application and documents created by
your application. Names of open applications now appear in the Application menu, a new
menu to the right of all other menus. The Finder displays the small icon for your application
in the right side of the menu bar whenever your application is active.
The structure of the System Folder has changed, including the addition of new folders that
reside inside the System Folder. You can now store preference files in the Preferences folder
and temporary files in the Temporary Items folder.
The Control Panels folder, which is inside the System Folder, replaces the Control Panel desk
accessory. Control panels now appear as individual documents in the Control Panels folder.
The user can open the Control Panels folder from the Finder or the Apple menu. In addition, if
you develop video cards, you can create an Options dialog box that is used with the Monitors
control panel.
In version 7.0, fonts, desk accessories, keyboards, international resource collections, and

sounds are represented as icons on the desktop. The user installs fonts and sounds by
dragging their icons to the System Folder icon. The user can store desk accessories in the
Apple Menu Items folder within the System Folder or anywhere in the volume. You can
now distribute fonts and desk accessories as movable resource files with separate icons.
The Finder now lets you create one or more icons for a single document or other desktop
object; one of the icons represents the real object, and the others are aliases that point to
the object. Aliases can give convenient access to documents that are nested within many
folders or that reside on a file server.

The Finder can display help balloons with descriptive text when the user moves the cursor to
certain elements of the Finder user interface while help is activated. In addition, if you use
standard windows in your application, the Help Manager automatically displays help balloons
for standard elements of the window, like the title bar and close box. You can use the features
of the Help Manager to display help balloons for other elements of the user interface of your
application. For example, you can create help balloons for menus, dialog boxes, and controls
used by your application.
See the Control Panels, Finder Interface, Help Manager, and User Interface Guidelines
chapters in this volume for information on these user interface features.

About the System Software Version 7.0 Environment

1-15

—
—
—

col
-_
—
~
=

3

==
0
=.
=
-

ll

Lod

—

Inside Macintosh,

Volume VI

Sound
Your application can create and play sounds, mix and synchronize multiple channels of sound,

expand and compress sound data, record sound, and play sounds continuously from disk
using the Sound Manager.

The Sound Manager provides a rich set of routines for producing sounds, from playing a single
sound to playing a set of digitally recorded sounds. You can also compress sound data for
efficient storage of sound data on disk, and expand compressed sound data in real time.
See the Sound Manager chapter in this volume for complete information on using sound in
your application.

TrueType

Fonts

System software version 7.0 provides support for TrueType fonts. The Font Manager uses
equations (instead of bitmaps) to define the appearance of glyphs in TrueType fonts. After
using the equation to define a specific glyph in a particular font, the Font Manager translates
the outline to a bitmap for display on the screen.
The advantage of TrueType fonts is that a single TrueType font can be used to generate
glyphs at any size. The TrueType font includes instructions that fine-tune the image of the

font at different sizes. TrueType fonts are also resolution independent; the same TrueType
font can generate glyphs on a 72 dpi device or a 300 dpi device.

Your application can immediately take advantage of TrueType fonts if they are supported by
the user’s system software. However, the Font Manager still supports bitmapped fonts, and
gives preference to bitmapped fonts over TrueType fonts if both are available for a specific
typeface at a particular size.
To offer full support for TrueType fonts, your application can provide a menu command
(such as Size or Other) to let the user choose any size of a TrueType font. Your application
can also request that the Font Manager always choose TrueType fonts over bitmapped fonts.
Figure 1-9 shows an example of on-screen glyphs generated using a TrueType font and a
bitmapped font. The left side of the figure shows glyphs in a TrueType font that is rendered
at 12, 16, 19, 24, 31, 37, and 45 points. The right side of the figure shows glyphs in a
bitmapped font scaled at the same sizes.
See the Font Manager chapter for an introduction to TrueType fonts and for information on
using TrueType fonts in your application.

Graphics
The Macintosh User Interface Toolbox provides a rich set of routines that support graphics.
Using the Toolbox routines, your application can provide fast and high-quality graphics and
visual display to the user.

1-16

About the System Software Version 7.0 Environment

Introduction to the System Software Version 7.0 Environment

TrueType font scaled on screen
from 12 points to 45 points

abe

Bitmapped font scaled on screen
from 12 points to 45 points

abe

abe

abe

abc

abc

abc

abe

abc

abc

abc

abc

abc

—
—

—

~

iw
i
;
~
nd
lm!
—_
—
—_

abc

ic)

os
—e

Figure 1-9. Comparison of TrueType and bitmapped fonts
You can use the routines provided by QuickDraw to draw text, straight lines, ovals,
rectangles, or any variety of shapes. QuickDraw lets you define multiple drawing environments (ports)—each with its own coordinate system, location on the screen, and other

characteristics. QuickDraw also performs automatic clipping of drawing environments—
preventing another application from drawing in the drawing environment used by your
application. QuickDraw manages all drawing to the screen and provides a flexible set of
routines your application can use to perform most graphics operations.
Color QuickDraw provides support for gray-scale and color devices. In addition, users can
connect multiple monitors of different sizes, depths, and color capabilities. Color QuickDraw
automatically draws to the appropriate screen and takes advantage of the special
characteristics of that device.
Color QuickDraw in version 7.0 supports both indexed and direct devices. Indexed devices
typically have a color look-up table with 256 entries, meaning that up to 256 different colors
can be displayed at once on the screen. The user’s video card and monitor determine the
number of bits per pixel and the number of colors that can be displayed on the screen. For
indexed devices, Color QuickDraw supports 1, 2, 4, or 8 bits of information per pixel.
Direct devices do not use a color look-up table; instead, the video card contains enough RAM
to directly store color information for each pixel. This allows direct devices to display up to
16 million colors. For direct devices, Color QuickDraw supports 32 bits of information per
pixel (although only 24 are actually used). See the Graphics Overview chapter in this volume
for a comparison of indexed and direct devices.

About the System Software Version 7.0 Environment

1-17

Inside Macintosh, Volume VI

Using the Palette Manager, you can create palettes for your application. A palette is a
convenient way to group collections of colors. You can also use palettes if your application
makes special uses of color—for example, if your application needs color table animation.
See the Palette Manager chapter in this volume for information on the default color tables
supplied with version 7.0 and for information on how to set up and maintain palettes.
You can use the Color Picker Package to offer users a standard dialog box for choosing a
color. The user can choose any color from the entire range the available device can display.
See the Color Picker Package chapter in this volume for information on how to display the
Color Picker dialog box and for a description of the various color models used by the Color
Picker Package.
You can examine the contents of pictures and pixel maps using the Picture Utilities Package.
See the Picture Utilities Package chapter in this volume for more information.
You can use offscreen graphics to prepare images in a graphics environment you create and
then move the images quickly into view. The Graphics Devices Manager lets your application
get information about particular graphics devices and provides routines your application can
use if it needs exacting control of the graphics environment.
For an introduction to graphics on the Macintosh computer, see the Graphics Overview
chapter in this volume. If you’re developing a graphics-intensive application, see the Color
QuickDraw, Palette Manager, and Graphics Devices Manager chapters in this volume for
information on routines that provide advanced graphics features.
System software version 7.0 also provides support for color icons. See the Finder Interface
chapter in this volume for information on how you can create color icons for your application
and the documents it creates.

File

Management

Your application can easily locate the files it needs by using alias records. An alias record is a
data structure that identifies a file, folder, or volume. Whenever your application needs to
store the location of a file or directory that it might need later, you can record the location and
other identifying information in an alias record. The next time your application needs the file
or directory, you can use the alias record to locate it, even if the user has renamed it, copied
it, restored it from backup, or moved it. You can also use alias records to identify objects on
other volumes, including AppleShare® volumes. The Alias Manager provides routines for
managing the information in alias records.
Note that the Finder creates alias objects that are visible to the user, while your application
usually creates alias records when it needs to store identifying information about a file or
directory that it uses internally.
You can also quickly search a disk for particular files using File Manager routines. You can
search for one or more files that match certain criteria that your application specifies. For
example, your application can search for all files that have a modification date later than
June 15, 1991, and the File Manager returns to your application a list of all files that match
this specification.
In version 7.0, individuals can share files with other users. A user can make all files within

one or more of the folders on a local disk available over a network. This increases the chance
that documents created by your application are used in a shared environment.
1-18

About the System Software Version 7.0 Environment

Introduction to the System Software Version 7.0 Environment

The File Manager provides a new standard format for identifying files. You can use this
standard format in File Manager routines, and other managers also accept files specified
in the new format.
The user interface for opening and saving a file is enhanced in version 7.0. The Standard File
Package provides two new procedures, StandardGetFile and StandardPutFile, that your
application can use to display the standard user interface for choosing a file. To customize the
user interface for choosing a file, you can use the new CustomGetFile and CustomPutFile
procedures.
See the File Manager chapter in this volume for information on identifying and locating files
on a volume, see the Standard File Package chapter for information on letting the user choose

a file, and see the Alias Manager chapter for information on using alias records.

—

=
S

=<

Memory

~
—_

Management

~

UU

=

=!

==
0
=2
—

The Macintosh Operating System manages the loading of applications, desk accessories, and
other code into and out of memory. Applications must share the amount of memory available.
Without virtual memory, if an application needs a greater amount of memory than is currently
free for application use in the user’s system, the user must free up some memory. With
virtual memory, the Operating System can store elsewhere the contents of memory in use
by other applications in order to make room for the active application.
Virtual memory extends the available memory beyond the limits of physical RAM by using
part of the available secondary storage (such as a hard disk) to hold portions of programs and
data not currently in use. When an application needs portions of memory stored on disk, the
Operating System brings those portions back into physical memory by swapping them with
other unused portions of memory.
The operation of virtual memory is mostly transparent to your application. The user sets
options in the Memory control panel to control various features of virtual memory. The
user chooses whether virtual memory is turned on and, if so, how much virtual memory
is available. The main benefit of virtual memory is that it allows users to run more applications at once and work with larger amounts of data.
See the Memory Management chapter in this volume for further information on using
virtual memory.

Temporary

Memory

Your application can allocate temporary memory if it needs additional memory for short-term
purposes. Your application is not always guaranteed the desired amount of memory, so it
should work correctly even if it does not get the requested memory. For example, you might
allocate a small buffer in your application heap to copy data, and request additional temporary
memory. If the temporary memory is available, your application can use it to copy large
amounts of data more quickly. If the temporary memory is not available, your application
should still be able to perform the copy, although it might take a little longer. As soon as your
application finishes using the temporary memory, you should release it so that the memory
can be made available to other applications.
See the Memory Management chapter for further information on using temporary memory.
About the System Software Version 7.0 Environment

1-19

—_
~~
—

_

Inside Macintosh, Volume V1

24-Bit

and

32-Bit

Addressing

For Macintosh computers that support 32-bit addressing, the Memory Manager in version 7.0
uses all 32 bits of a memory address when the 32-bit addressing setting in the Memory
control panel is on. Earlier versions of system software use 24-bit addressing, in which only
the first 24 bits of a memory address are significant, and the upper 8 bits are ignored. For
compatibility, all machines that support 32-bit addressing also support 24-bit addressing.
Macintosh computers that support 32-bit addressing can run with either 32-bit addressing or
24-bit addressing, but not both at the same time. The user chooses 32-bit addressing or 24-bit
addressing by changing the setting in the Memory control panel and restarting the computer.
Applications that use the upper 8 bits of a memory address do not work correctly in 32-bit
addressing mode. Applications that strip the upper 8 bits of a memory address or rely on the
structure of the Memory Manager heap also do not work correctly in 32-bit addressing mode.
Therefore, your application should not directly manipulate the bits ina memory address. If
your application can operate correctly in 32-bit addressing mode, you can indicate this to the
Operating System by setting a flag in your application’s 'SIZE' resource. See the Event
Manager chapter for a discussion of the 'SIZE' resource.
If you use your own customized window definition functions or customized control
definition functions, see the Memory Management chapter for guidelines on avoiding
memory address violations. The Memory Management chapter also provides further
guidelines on how to write an application that works with 32-bit addressing.

Process

Management

System software version 7.0 provides support for process management. Your application can
get information about any currently running process, including your own. For example, for a
specified process, you can find the application’s name, type and signature; the number of
bytes in the process partition, the number of free bytes in the application heap, the application
that launched the process, and other information. Your application can also launch other
applications and desk accessories.
When a user opens a desk accessory in version 7.0, the Operating System launches the desk
accessory in its own partition. When a desk accessory is open, the Finder puts the name of
the desk accessory in the list of open applications in the Application menu, and also gives the
active desk accessory its own About command in the Apple menu that includes the name of
the desk accessory. This makes the user interface for desk accessories more consistent with
the user interface of small applications.
You can achieve greater control over other applications using the Process Manager routines.
You can bring an application to the front, get information about other applications, and launch
other applications without terminating your own application. Your application can also
receive notification if any application that it has launched terminates.
System software version 7.0 provides greater support for launching applications and documents at startup. All desktop objects in the Startup Items folder are automatically opened at
startup. All background applications in the Extensions folder are launched early in the startup
sequence before the Finder is started. Background applications generally perform a specific
task and are invisible to the user. The Startup Items folder and Extensions folder are located
inside the System Folder.
1-20

About the System Software Version 7.0 Environment

Introduction to the System Software Version 7.0 Environment

See the Process Management chapter in this volume for information on launching other
applications and getting information on currently running processes.

Timing

Services

You can schedule routines to execute at a later time using the Time Manager. The Time
Manager provides a hardware-independent method of performing time-related tasks.
You can schedule routines to run periodically or after a specified delay. Time delays can be
specified in milliseconds or microseconds in version 7.0. You can achieve a maximum
resolution of 20 microseconds. This gives you greater accuracy in coordinating sound,
multimedia, and other events that require precise timing.

—
—

See the Time Manager chapter in this volume for information on how to schedule a routine
for later execution and how to compute elapsed time.

=

oe

“3

i)
Qu.

c

ec)
-

5

Compatibility

a

~

You can determine what features are available on a Macintosh computer using the Gestalt
function. The Gestalt function provides information about various attributes, versions, and
features of particular software and hardware available on the currently running system.
The Compatibility Guidelines chapter in this volume discusses guidelines you should follow
to ensure that your application is compatible with previous versions of Macintosh system
software as well as with new releases of Macintosh system software.
These guidelines can help you develop your application so that it is compatible across the
Macintosh family of computers. The guidelines also provide information on how to make
your application compatible with A/UX® and how to design your application so that it can
be easily localized for use in other regions.

Worldwide

Development

As you develop applications for worldwide markets, you need to consider differences in
scripts, languages, and regions. The Macintosh system software presents one of the most
flexible architectures for developing applications that can support more than one script.
A script, such as Roman, Kanji, or Arabic, is a writing system for a human language such as
English, Japanese or Arabic. Scripts have different characteristics; for example, they can
differ in the direction in which their characters and lines run and in the number of characters
in their character sets. The way in which you need to input, display, render, and edit text may
change depending on the script in use.
A script system is a collection of software facilities that provides for basic differences between
writing systems. Script systems include character sets, fonts, keyboards, and routines for text

collation and word breaks. Examples of script systems are Roman, Japanese, Arabic, Hebrew,

Thai, Devanagari, and Korean. A script system can also be localized for a particular language,
region, or country. For example, the Roman script system has been localized for French,
British, Italian, and U.S. users (among others). The system software of all Macintosh
About the System Software Version 7.0 Environment

1-2]

Inside Macintosh,

Volume VI

computers includes the Roman script system. If another script system is required, it is also
customized for the particular language or region. You can use the Script Management System
to help you display text in the correct format for various scripts.
Worldwide system software consists of the Macintosh Script Management System (that is,
the Script Manager and one or more Macintosh script systems) and related components
(including the International Utilities Package, the international resources, and keyboard
resources).

Measurement systems often differ from country to country, as do currency, sorting order,

word boundaries, and the formatting of dates and times. The International Utilities Package

handles formats for the presentation of numbers, currency, time, and dates in countries
around the world. The international resources and several of the keyboard resources also
contain region-specific or language-specific information, such as date and time formats.

TextEdit also provides support for working with different script systems. You can use
TextEdit to let the user edit and display text in multiple scripts and styles when a non-Roman
script system is in use. TextEdit automatically handles text with more than one script, style,
and direction. For example, TextEdit supports mixing English text (a left-to-right directional
script) with Arabic text (a right-to-left directional script) in the same line.

You should use resources to store text for menus, dialog boxes, and other parts of the user
interface of your application. This lets a translator localize your application for a particular
language, region, or country without requiring modification of your code. In addition, by
using routines provided by the Macintosh Script Management System, you can write your
application so that it works independently of the particular script in use.
Figure 1-10 shows a document created by an application that uses the Macintosh Script
Management System to support more than one script system.
—~=__]_HSSS===S=_

le

wSsHi_jaeeseBaeeS_|==pE

ifs

The Macintosh (U#sS)

provides several

el

writing systems (334226 CoS abs),

Figure 1-10.

Using multiple scripts in a single document

See the Worldwide Software Overview chapter for an introduction to designing your application for worldwide markets, and see the User Interface Guidelines chapter for suidelines
related to developing your application for use around the world. See the TextEdit chapter for
information on using TextEdit when a non-Roman script system is in use. Macintosh
Worldwide Dev elopment: Guide to System Software (available from APDA®) provides a
complete description of all components of the worldwide system software, including routines
in the Script Manager.

1-22

About the System Software Version 7.0 Environment

Introduction to the System Software Version 7.0 Environment

Communication

Over

a Network

The Macintosh Operating System provides many routines to support applications communicating and sharing data across a network. You can send events between applications located
on different computers using the Event Manager or Apple Event Manager, and read and write
low-level message blocks using the PPC Toolbox. You can send and retrieve information
from a remote database or other data sources using the Data Access Manager. You can share
data and files between applications on different computers using file sharing, the Edition
Manager, and the Alias Manager.
In addition, you can use the network and communication services provided by the AppleTalk®
Manager or Communications Toolbox. The AppleTalk Manager provides routines your
application can use to send and receive information over an AppleTalk network.
The AppleTalk Manager in version 7.0 supports various link access protocols (for example,
the LocalTalk® Link Access Protocol and the EtherTalk® Link Access Protocol) that can be
used for AppleTalk communication. Your application can also use a new protocol, the
AppleTalk Data Stream Protocol (ADSP), to exchange information between two equal

entities. Either end of an ADSP connection can send data at any time. You can use ADSP
to establish two-way communication between computers—for example, for use in office
conferencing. See the AppleTalk Manager chapter for information on the device drivers and
protocols associated with AppleTalk.
The Communications Toolbox provides your application with a standard interface for various
communication services (such as data connections, file transfer, and terminal emulation) that

are often used with a modem, other serial connections, or over an AppleTalk network. See
Macintosh Communications Toolbox Reference Guide (available from APDA) for additional
information on the routines provided by the Communications Toolbox.

Hardware

Interfaces

The Macintosh family of computers supports many different types of hardware, including
mouse devices, keyboards, display devices, hard disks, floppy disks, CD-ROM discs, and
other devices. These devices are supported through various hardware interfaces, including

SCSI (Small Computer System Interface), ADB (Apple Desktop Bus™), and SCC (Serial

Communications Chip). In addition, a number of different devices can be supported through

the expansion interfaces (the NuBus™ and processor-direct slots).

You can design expansion cards and drivers for the NuBus and processor-direct slots. For
specific hardware information for the Macintosh family, see the Guide to the Macintosh
Family Hardware, second edition. For information on writing a driver for the Macintosh
family, see Designing Cards and Drivers for the Macintosh Family, second edition, and for
system software information, see /Jnside Macintosh, Volumes I-VI.

Volume VI (this volume) contains information on the new Power Manager and additional

information on the Slot Manager. The Power Manager is a new manager used with the
Macintosh Portable. The Slot Manager in version 7.0 supports 32-bit addressing of NuBus
cards. See the Power Manager chapter and Slot Manager chapter in this volume for specific
information on these managers.

About the System Software Version 7.0 Environment

1-23

—

—

~

—

Lee

|

o

2.
=)

Q
a
5"

~

Inside Macintosh,

Volume VI

OVERVIEW

OF

CHAPTERS

IN THIS

VOLUME

The User Interface Guidelines chapter and Compatibility Guidelines chapter provide
important information about designing your application to take advantage of the
Macintosh user interface and to ensure compatibility across the Macintosh family
of computers.
The rest of the chapters in this volume show how to use the new features of version 7.0
in your application. Each chapter gives detailed descriptions of each manager, including
routines, parameters, and data structures.
Figure 1-11 shows where you can find a detailed description of how to use each feature
of the system software version 7.0 environment.

1-24

Overview of Chapters in This Volume

Introduction to the System Software Version 7.0 Environment

Introduction

Version 7.0 ||| | Compatibility
Environment||| | Guidelines

User Interf

User

Pas

Chapter 1

Finder

Control

Chapter 9

Chapter 9)

Interface

uIdelInes
Chapter2
,
=i
Help
Manager

Panels

|

f

y
Resource
Manager

Font
Manager

Chapter 11

|

Chapter3 }/

Worldwide
,
Worldwide
TextEdit

Chapter 12 }) | Chapter 13

Software

Chapter 15

Overview

ical

Chapter 1

—_—

—

=
S

=
2.
fo
e)

S.
5

=

Picture
Utilities

Graphics
Devices

Chapter 19

Chapter y)

Manager

Package

Chapter 18

File
Manager

Color
Picker

Alias
Manager

Standard
File

Chapter 25 ]))| Package || Chapter 27
Chapter 26

Sirocsss

Management
Chapter 28

Time

Manager
Chapter 23

Managemen
Chapter 29
Notification

Manager
}] | Chapter 22

Access
Manager

Manager
| Chapter 20

Chapter 8

Slot
Manager

AppleTalk
Manager

Power
Manager

Chapter 30 }/) | Chapter 31 }/) | Chapter 32

Interapplication

Communications (IAC)
-

Edition

Manager

Event

Chapter 4 | Manager | Apple Event
—A,

)

Chapter 5

Manager

¥

Chapter 6

)

4 Program-to-

Program
Communication
Toolbox
Chapter 7

L.

=

Sound

Data

Palette

Color

Graphics

QuickDraw
Overview
Chapter 16 /// | Chapter 17}

Manager
Chapter 24

Figure 1-11. Overview of chapters in Volume VI

Overview of Chapters in This Volume

1-25

~~) ~~) tO t YNt
t ~~) t ~
LW! >) NN © COOMONDAMNHL LS LW t ye

BW
COTO ANNA

WD

USER

~)

~

ONAN

~~) i)

~

30
30
3]
32
32
32
33
34
34
36
36
36
af

INTERFACE

GUIDELINES

About This Chapter
User Interface Design Principles
Worldwide Software Development
Cultural Values
Resources
Language Differences
Text Display and Text Editing
Default Alignment of Interface Elements
Keyboards
Fonts
User Documentation
Terminology
The Version 7.0 Environment
User Feedback
Background Notification
Color Design for Version 7.0
General Color Design Guidelines
The Icon Family
Black-and-White Icons
Small Icons
Color Icons
Consistent Use of Icons
Customized Icons
Windows
Window Positions
The Zoom Box and Window Behavior
Dialog Boxes
Modal Dialog Box Behaviors
Movable Modal Dialog Boxes
Keyboard Navigation in Dialog Boxes
Button Labels
Dialog Box Layout
Dialog Box Messages
Standard File Dialog Boxes
Save Changes Dialog Box
Menus
File Menu
Edit Menu
Font Menu
Help Menu
Keyboard Equivalents
Pop-Up Menus
Standard Pop-Up Menus
Type-In Pop-Up Menus
More User Interface Information

N

c
~N

@

a

—
-_
ed

nee

‘7

-_=

=

ps]
i)
@

2-1

Inside Macintosh,

Volume VI

User Interface Guidelines

ABOUT

THIS

CHAPTER

This chapter provides recommendations about how to adapt your application’s interface to the
Apple® Desktop Interface provided with system software version 7.0. It describes new user
interface guidelines and clarifies existing guidelines. It also introduces several user interface
topics that you need to consider when you design or redesign an application. Throughout the
chapter are references to places where you can find more information about technical
implementation issues.
Your application should maintain the spirit of the Apple Desktop Interface and remain consistent with the guidelines presented earlier in /nside Macintosh, Human Interface Notes, and
Human Interface Guidelines: The Apple Desktop Interface—which present a complete
description of the Apple Desktop Interface.

USER

INTERFACE

DESIGN

PRINCIPLES

nN

This section describes the fundamental principles of the Apple Desktop Interface. It’s a brief
reminder of the basic premises that you should consider when you design your application

for the Macintosh® computer.

a Metaphors from the real world. Concrete, simple metaphors provide people with
a set of expectations to apply to computer environments. Whenever appropriate, audio
and visual effects can support the metaphors.
s Direct manipulation. Each user action has a perceptible response and the Operating
System provides feedback to verify the effect of the action. For example, icons move
when users drag them. In the Macintosh interface, people don’t have to trust that
abstract commands entered in a text-based interface do what they promise. This means
that when users choose the Bold command, a word changes immediately to boldface—
in comparison to other operating systems in which users type in commands and wait to
see the results when the document is printed.
= See-and-point (not remember-and-type). Users rely on recognition, not recall,
so entities are visible when possible. People don’t have to remember anything the
computer already knows, such as which commands are available.
= Consistency. Effective applications are internally consistent and consistent with
other applications.
a WYSIWYG (what you see is what you get). There is no significant difference
between what users see on the screen and what eventually is printed.
= User control. Users, not the computer or the application, initiate and control all actions.
a Feedback and dialog. Users get feedback about all interactions with the computer,
and it is immediate feedback when possible. This communication should be brief,
direct, and expressed in the users’ vocabulary rather than the programmer’s.
User Interface Design Principles

2-3

fea:
ez
io)
“
—

—=
©
a

rha)
@

Inside Macintosh,

Volume

VI

us Forgiveness. As users explore the interface, their actions should generally be reversible so that people explore and learn by doing. Users should be able to identify in
advance any actions that aren’t reversible.
= Perceived stability. Users feel comfortable in a computer environment that remains
understandable and familiar rather than one that changes randomly.
= Aesthetic integrity. Visually confusing or unattractive displays detract from the
effectiveness of human-computer interactions. Therefore different things, like folders
and documents, should look different on the screen. Also, users should be able to
control the superficial appearance of their computer workplaces to display their own
style and individuality. Messes are only acceptable if users make them. Applications
aren't allowed this freedom.
For further explanation of these design principles, see Human Interface Guidelines: The
Apple Desktop Interface.

WORLDWIDE

SOFTWARE

DEVELOPMENT

Macintosh worldwide system software is designed to address the complex problems you'll
encounter when you design your applications to be compatible with regional, linguistic, and
script differences around the globe. Worldwide system software consists of the Macintosh
Script Management System (which is one or more script systems and the Script Manager)
and related components that include the International Utilities Package, the international
resources, and keyboard resources.
The Macintosh computer has always presented one of the most flexible architectures for
developing worldwide software. Because of the enhanced support for script systems in
version 7.0, it’s easier for users to add one or more non-Roman script systems to their
Macintosh computers. With version 7.0, software can be localized with greater ease. Now
it’s even more advantageous for you to create applications that can be used worldwide.
It’s much easier to design software with worldwide support from the beginning of your
development process. This may mean that you create your application so that it is easy to
localize, or that you adapt it for use in a specific area. Localizing software involves translating an application’s menus, dialog boxes, alert boxes, and content areas into a language
or regional dialect.
You can also make your application Script Manager—-compatible. The Script Manager
routines and the International Utilities Package handle text issues for all script systems.
If your application is not text-oriented but does simple text processing, using TextEdit
provides adequate support.
If your application does moderate text processing, such as that accomplished by a simple
word processor, you probably want to incorporate Script Manager capabilities. If it does
intensive text processing, such as page layout, you can build in support beyond the Script
Manager routines to handle text for a specific script system.
The following sections outline the major issues you need to consider when you develop software for local or worldwide use. For a complete description of the issues and a discussion of

technical implementation, see the TextEdit and Worldwide Software Overview chapters later in

2-4

Worldwide Software Development

User Interface Guidelines

this volume. These chapters discuss the routines that assist you in developing your application
for worldwide use. See Macintosh Worldwide Development: Guide to System Software for a
complete discussion of developing worldwide software. This book is available from APDA®.

Cultural

Values

Whenever you design a user interface, consider that differences exist in the use of color,
graphics, calendars, text, and the representation of time in various regions around the world.
It’s important that you be able to localize your user interface elements with ease. As an
example, consider how different cultures assign different meanings to colors. The color
white represents purity in one culture and death in another. Therefore you may want to
localize elements of the user interface, such as the colors of text or graphics, in versions of
your application designed for different regions.
Graphics have the potential to enhance your application, but they can also be offensive. In
addition to colors, many cultures assign varying values and characteristics to living creatures,
plants, and inanimate objects. In the United States the owl is a symbol of wisdom and knowledge, whereas in Central America the owl represents witchcraft and black magic. Some
cultures forbid the depiction of uncovered bodies and body parts, while other cultures
enhance marketing materials with pictures of scantily clad people. It’s a good idea to avoid
the use of seasons, holidays, or calendar events in software that you expect to distribute
worldwide. Also avoid using graphics that represent holidays or seasons, such as Christmas
trees, pumpkins, or snow—or be sure that the symbols can be localized. You can influence
your audience in simple but profound ways by carefully selecting elements of your application’s interface. Make sure that visible interface elements can be localized for other regions
around the world.
Different calendars are used to mark time around the world. The United States and most of
Europe observe time according to the Gregorian calendar. The traditional Arabic calendar,
the Jewish calendar, and the Chinese calendar are lunar rather than solar. Often time is marked
one way for business and government purposes while religious events are dated according to
a different calendar. Therefore your application should be flexible in handling dates, and you
may want to provide the user with a way to change the representation of time. Use the
International Utilities Package to handle numbers, dates, and sorting.

Resources
It’s essential to store region-dependent information in resources so that text the user sees can
be translated (during localization) without modifying your application’s code. When you
create resources, consider text size, location, and direction. Remember that text size varies in
different languages. Also, depending on the script system, the direction of text may change.
Most Middle Eastern languages read from right to left instead of left to right, the direction of
Roman script. Text location within a window should be easy to change.
Use the Macintosh Script Management System to handle these situations. See the Worldwide
Software Overview, Compatibility Guidelines, and Resource Manager chapters in this
volume for more information on using resources to store data the user sees. Also consult
Macintosh Worldwide Development: Guide to System Software for more information.

Worldwide Software Development

2-5

i)

io~
@
“

pamed

_—

@
mt
ec)
m
Q
@

Inside Macintosh,

Language

Volume

V1

Differences

Languages differ in grammar, structure, meaning, and nuance. Translating languages is a
delicate task and often can cause confusion, so be wary of using colloquial phrases or
nonstandard usage and syntax. Choose your words carefully for command names in menus
and for messages in dialog boxes, alert boxes, and help balloons. When translated, text can
become up to 50 percent larger than U.S. English text, so you can’t rely on string length.
Text needs room to grow up, down, and sideways.
Potential grammar problems may arise with error messages and the so-called user programming structure of languages like HyperTalk®. The word order of messages may be completely
different in translation, thus rendering a message nonsense when translated. Simple concatenation of strings generally doesn’t work when an application is translated. For example, word
order in German usually places the verb at the end of a sentence. Suppose a German developer built an application that concatenated two strings to create an error message. When
localized for the United States, the application might produce a sentence like “The file with
the long name move.” Instead of concatenating strings, use the ReplaceText function, which
correctly assists with the syntactic ordering of elements. See the Worldwide Software
Overview chapter for information on technical implementation.

Text Display and Text Editing
System software version 7.0 allows users to display different scripts at the same time. A
script is a writing system for a human language. Scripts may differ in the direction in which
their characters and lines run, the size of the character set used to represent the script, and
context dependence. Whenever a user installs a non-Roman script system, at least two scripts
are available, the Roman script that is present on all Macintosh computers and the non-Roman
script. If you use the TextEdit and Dialog Manager routines, you can correctly handle most
text in different scripts. For moderate text processing, the routines provided by the Script
Manager can assist you in implementing these guidelines. The TextEdit and Worldwide
Software Overview chapters in this volume discuss all of these issues thoroughly.
No matter what level of worldwide support you provide, it’s important to avoid two common
assumptions. Characters aren’t necessarily | byte; they can be 2 bytes. You also shouldn’t
assume that text is always left-aligned and read from left to right.
Remember that the meaning of a character code depends on the font, and character codes may
be | or 2 bytes long. The cursor should move between characters, not bytes, and the Delete
key should erase characters, not bytes. Inserted characters should appear between other
characters, not between bytes of a 2-byte character. Also be aware of the impact of 2-byte
characters on data transmission.
Use the language-specific routines in the Macintosh Script Management System for breaking
and wrapping words and for string comparison and sorting. Consider word boundaries and
their impact on word wrapping, selection, search, and cut and paste.
Some scripts include multiple sets of numerals. For example, international business in Japan
and the Middle East requires the use of Western digits as well as the digits from a Japanese
script or an Arabic script. Applications that handle numbers should accept all the numerals in
each set as valid. Use the International Utilities Package to handle numbers.

2-6

Worldwide Software Development

User Interface Guidelines

You need to provide metric and English measurements. Use numeric routines for international
number formatting and interpretation.
Your application should appropriately position the cursor when the user clicks in text. The
cursor, or caret, should appear where the next character will appear when typed. If this is
ambiguous because of multidirectional text, use dual carets, as shown in Figure 2-1. For a
detailed discussion of using dual carets, see the TextEdit chapter in this volume.
Roman keyboard icon
File

Edit

Avant Garde

Font

Style

we

(sa)!

Format

New York

Garamond

Palatino

Times

ify

=

oy
Secondary caret

Primary caret
N

(=

Figure 2-1. Dual carets in mixed-directional text

MN

io)

ar}

—
=}
a

Highlighting should apply to a contiguous set of characters in memory, even though the
glyphs may not appear contiguous on the screen. In other words, you should highlight

@

ape

characters in phonetic order (the order in which the user speaks, reads, or writes) rather

than the order in which characters appear on screen. However, the arrow keys should move
the cursor in the direction that the arrow points, regardless of text direction. This guideline
applies across script boundaries when the user displays multiple scripts. In Figure 2-2 the
multidirectional text appears correctly highlighted for editing; the words are highlighted in the
order that the user reads, from right to left. The translation of the mixed-directional Hebrew
and English sentence is in the window labeled “unidirectional highlighting.” The corresponding English words, flowing from left to right, are highlighted for editing.
2S

multidirectional highlighting

py}

iy

California ntn1 Cupertino (RMEaeEeeApple Computerfite 34 manana

wa

Dy

20]

unidirectional highlighting

The management of Apple Computerfiiee cee

eam Cupertino in the state of California.

AE

iy
re

Figure 2-2. Multidirectional text correctly highlighted
Note: If your application uses TextEdit routines, most worldwide text issues are
handled for you. If your application needs more sophisticated text handling, you
should also consult the Worldwide Software Overview chapter in this volume.
Worldwide Software Development

2-7

7)

@

Inside Macintosh,

Volume V1

Applications that work with tokens (abstractions that have multiple representations) or use
characters that vary from script system to script system should work correctly in all scripts.
For example, a token that represents the concept of “less than or equal to” might have two
representations on a U.S. system, the 2-byte sequence <= or the |-byte character <. If you
use the IntITokenize function to handle these details, your application doesn’t have to be
aware of the character codes.

Default Alignment

of Interface

Elements

When dialog boxes are localized for use with worldwide versions of system software, the text
in the dialog box may become longer or shorter. Also, the alignment of controls in the dialog
box may vary with localization. Arabic and Hebrew are written right to left, so the alignment
of items in an Arabic or a Hebrew dialog box is generally right to left, just as dialog box items
in English or Russian are generally left to right. The low-memory global variable TESysJust
controls the alignment of interface elements.
When TESysJust is —1, the Control Manager reverses the alignment of check boxes and radio
buttons, the Menu Manager reverses the alignment of menu items to be ordered and aligned
on the right, and TextEdit aligns text by default on the right. Create your application so that it
supports both left alignment and right alignment of controls and adjust the alignment as
appropriate. Provide a way for the user to change the default line direction of text. Use the
SetSysJust procedure to set the value of the global variable TESysJust.
When the alignment of items is reversed, it’s important that the elements appear symmetrical.
Therefore when you create dialog box items, try to make sure that their display rectangles are
the same size. Figure 2-3 shows a typical dialog box and the same dialog box with the alignment of its elements reversed. You can see why it’s important to create display rectangles of
the same size.

Keyboards
As stated previously, in version 7.0 users can install multiple script systems. If the Operating
System or an application determines that all conditions are met, it enables the script system,
making it available to users. A script system can contain more than one keyboard layout that
maps character codes to keys on a physical keyboard, and it can support more than one
attached physical keyboard. All keyboards do not have the same set or number of keys and
users may have more than one keyboard attached to their computer. See the Worldwide
Software Overview chapter in this volume for information on installing and enabling script
systems and keyboard resources.
Version 7.0 adds a new Keyboard menu when more than one script system is present or a
localizable resource flag is set. This menu simplifies the user’s access to scripts and keyboards. The icon for the Keyboard menu appears between the icons for the Help menu and
the Application menu. A keyboard icon appears next to each keyboard name, and the icon
of the active keyboard appears in the menu bar. As Figure 2-4 shows, the Keyboard menu
displays a list of installed keyboard layouts for each enabled script system.

2-8

Worldwide Software Development

User Interface Guidelines

‘(Co Check It Out

oO Extremely Long Radio Button

‘(CCheck It In

©) Long Radio Button

OLB. Short

‘(Check It Over

[cancel] [

' Check It Out
Check

ok

|

Extremely Long Radio Button

It In]

_ Long Radio Button ©

Check It Over(]

_1.B. Short ©.
[ Cancel |

[

OK

]

i)

S
2)
oc)
ar

Figure 2-3. Reversing the alignment of dialog box items

—

=

©

sont

a)

The Keyboard menu groups the keyboard layouts by script system, which are separated by
dotted or gray lines. In Figure 2-4, there are two Roman keyboard layouts (Spanish and
United States); a single Hebrew keyboard layout; and two Japanese keyboard layouts. Only
one keyboard layout and one physical keyboard are active at a time; the active condition is
indicated by a checkmark in the menu.

| &@

Jrtl

fe

BR

Keyboard icon for active
|
keyboard script

a + Ie

ANY+ Ib
About
AARNE

NORE RRR ETRE

Keyboards...
EERE OEE eee ERE

E Ee EE HESS EE ESEEESEE EER EE EER EE ES

Renee Reena EEN EERE eRe nE RTE nEe HEE EM HE HEHE EEE HE EEE EE EEE EES

Keyboard layout for

active script (Hebrew)

ae

nay

E— Espanol
@
Figure 2-4. The

a)
fe

/

Script

boundary

us

Keyboard

menu

Worldwide Software Development

2-9

Inside Macintosh,

Volume VI

Users can change keyboard layouts by using this menu or by using a keyboard equivalent,
Command-Space bar, to cycle through the keyboard layouts. Don’t use the keyboard
equivalents Command-Space bar and Command-modifier key—Space bar in your application,
since they are reserved for use by the Script Manager. See “Keyboard Equivalents” later in
this chapter for a complete listing of reserved keyboard equivalents.
Table 2-1 shows some new black-and-white versions of keyboard icons for localized versions of Macintosh system software. They are shown in color on Color Plate I, "Examples
of Keyboard Icons,” at the beginning of this volume. A keyboard icon represents a localized
keyboard layout. If you develop key-boards or keyboard resources, you must provide
customized icons like these. You create a 16-by-16 pixel icon in 1-bit, 4-bit, and 8-bit color.
If you use the same colors for the 4-bit and the 8-bit color icons, you only need to provide
one 4-bit icon. This scheme takes up less space in the System file.
To represent your keyboard layout for version 7.0, replace the black-and-white symbol you
previously used to represent a localized keyboard layout with an icon similar to those shown
in Table 2-1 and Color Plate I.
If you are designing a new keyboard icon, use a solid symbol to represent a keyboard layout
for a region that is larger or smaller than a country or province. For example, a diamond
represents the Roman Script System, which is used in the United States, Central America,
and most of Europe. Use the flag of a country or province if the keyboard layout is only used
in that area. For example, the Union Jack represents the keyboard layout localized for use in
| Examples of keyboard icons
Name

PBR ee
SOO

Netherlands, comma

Arabic

decimal separator

Canada
ani

Cyrillic
Cyrillic transliterated
Denmark
Baeroe Islands

Germany

oo

Hebrew

Roman

(U.S.)

Spain
Swiss

French

Swiss German

Swiss Italian
Turkey

Japanese Romaji

rs

Turkish U.S. modified

Japanese Katakana

zs

United Kingdom

Korean

Netherlands, period decimal
separator (previously (HL)

2-10

Name

oHe

Ee

Icon

2-1.

+) +

Table

Worldwide Software Development

(previously (GB)
United States

User Interface Guidelines

the United Kingdom. Be sure to use the colors that appear on the nation’s flag. You can also
add a visual indicator to the flag to show some modification. Use a superscript diamond to
indicate a QWERTY transliteration, which is a mapping of sounds from a language to
the Roman keyboard layout. Use a subscript comma or period to indicate which decimal
separator is used. See Table 2-1 for examples of icons with these symbols.
When you design the black-and-white version of a flag icon, use black and a 50 percent
gray pattern. These choices provide the best contrast and legibility. To avoid confusion
between flags of similar design, use the pattern substitutions for colors shown in Table 2-2.
See Table 2-1 to see flags that use the correct pattern substitutions.
Table

2-2.

Pattern substitutions for colors in keyboard icons

Pattern

3

“A

Color

Black

Black or blue

50 percent gray

Red

25 percent gray

Light blue

Diagonal stripes

Green

White

White or yellow

i)

&
eZ

@

Lew

—

=

on

@

=~

When the user changes the keyboard layout, you should synchronize the font to that keyboard
layout. You can use the FontScript function to periodically poll the Operating System to find
out if the user has changed the keyboard layout. Choosing a font should set the keyboard
layout to the script of that font. For example, if a user chooses a Japanese font such as
Osaka, your application should change the keyboard script to Japanese. When a user clicks in
text, your application should set the keyboard layout to correspond to the font of that text.
For a well-designed application, the keyboard icon in the menu bar should always indicate
the status of the font script. The TextEdit chapter in this volume provides an example of automatically synchronizing the font and the keyboard layout.
See the Worldwide Software Overview chapter in this volume for more information on the
Keyboard menu.

Fonts
When you write software that supports non-Roman scripts, don’t make assumptions about
font sizes; let the user choose them. For example, system or application fonts may be preset
to 12 or 18 points and a font with a resource ID of 0 is not always set to Chicago. Pay attention to the use of system and application fonts when the user cannot choose the font. If you
must assign font sizes, use the Script Manager to find appropriate fonts and sizes. Use the
proper font names as defined by worldwide system software. Whenever possible, display
font names in the proper script and font in your Font menu.

Worldwide Software Development

2-11

x)
La)

|

Inside Macintosh, Volume VI

Diacritical marks may extend beyond the ascent line. Some fonts, such as Japanese fonts,
contain glyphs that extend to the boundaries of the enclosing rectangle of the font, or to both
minimum-y and maximum-y lines. You should leave room for space between lines of text
and between the top and bottom lines of any enclosing rectangle. See the Font Manager
chapter in this volume for more information. Figure 2-5 shows some glyphs that demonstrate
the boundaries you need to allow for lines of text.
Maximum y-value

Ascent line

Base line

Descent line

Minimum y-value

Figure 2-5. The boundaries of a font

USER

DOCUMENTATION

Documentation for users is an essential part of the user interface that you provide. It should
be as well considered and developed as your application’s user interface. Consider the
audience that you address with your product and tailor the documentation to its needs. It’s
often useful to provide alternate types of documentation for the differing types of users who
make up your audience. Beginners have different needs than expert users.
People have distinct learning styles. Some users learn by seeing, some learn by doing, some
learn by hearing, and some learn through a combination of these styles. It’s best to provide for
the broadest possible range of learning styles. For example, including a written tutorial, a
written reference manual, an on-line tutorial with visual and auditory feedback, and an on-line

help system should meet the needs of nearly everyone who wants to learn to use your product.
As an example of an on-line help system, you can look at Balloon Help™ in the Finder™ in
version 7.0. For information on including your help system in the Help menu or implementing
Balloon Help for you application, see the Help Manager chapter in this volume.
Develop task-oriented documentation that teaches users how to accomplish the tasks that you
designed your application to perform. Avoid system-oriented documentation that describes
everything that your application can do rather than teaching practical skills.
2-12

User Documentation

User Interface Guidelines

It’s important to use standard terminology and nontechnical language in user documentation.
Don’t pass on technical jargon to users and expect them to understand or like it. When you
must use technical terms, be sure to define them at first occurrence, and include a glossary if
your document has many specialized terms. Be consistent in your use of terminology. Make
sure that messages and terms that users see on the screen match what appears in the
documentation.
Apple Computer, Inc., publishes the Apple Publications Style Guide, which codifies the way
in which Apple documentation uses language. It’s a guide to writing about the Apple Desktop
Interface. You can obtain this publication through APDA.
It’s very important to translate all user documentation, including tutorials, on-line help, and
books, when you localize your software product. Making your documentation available in a
user’s native language greatly enhances the usability and marketability of your product.

TERMINOLOGY
i)

Use regular language in your applications as well as your documentation. Don’t use technical
jargon or computer science terminology. The majority of users aren’t programmers. It’s
especially important not to use programming terms in menus, dialog boxes, or user books.
In particular, don’t use file type names to refer to Finder documents that users see. Call
documents by the terms that appear in the Kind column in Finder windows. Use the terms in
Table 2-3 in place of the four-letter type names.
Table

2-3.

Translation chart for user documentation

Previously
used term

Suggested
terminology

Examples

cdev

control panel

Mouse control panel

RDEV

Chooser extension

LaserWriter® Chooser extension,
AppleShare® Chooser extension

INIT

system extension
(not startup document)

File Sharing Extension

adev

network extension

EtherTalk® network extension

ddev

database extension

Data Access Language (DAL)
database extension

DA

desk accessory

Calculator desk accessory

FKEY

function key

36 -Shift-3 screen-dump utility

standard file dialog box

directory dialog box

SFGetFile dialog box

MultiFinder® icon

active-application icon

TeachText application icon
Terminology

2-13

&

<2)

@
"

—

=
oo
@
“t
=
pt)
oO

@

Inside Macintosh,

Volume

VI

In version 7.0 a cooperative multitasking operating environment is always available to users.
Therefore it’s no longer appropriate to use the term Mu/tiFinder to distinguish this environment from the Finder environment. When you update or revise written material that relates to
version 7.0, replace the term MultiFinder with the term Finder.

THE

VERSION

7.0

ENVIRONMENT

This section briefly describes the general user interface recommendations that affect your
application when it runs in the version 7.0 environment. The changes to system software
and the operating environment are described in the Introduction to the System Software
Version 7.0 Environment chapter and in the Compatibility Guidelines chapter in
this volume.
In previous versions of system software, a cooperative multitasking environment was available to users with MultiFinder. Users could turn on MultiFinder so that they could open
multiple applications at one time; however, most people didn’t use MultiFinder regularly.
In version 7.0 the cooperative multitasking environment is standard. Now all users can open
as many applications and desk accessories as their computer’s memory can support. The
Macintosh computer manages applications in much the same way that each application
handles its own windows.
As in previous versions of system software, only one application can be active at a time. The
frontmost application, the one interacting with the user, is the active application. Its small icon
represents the Application menu in the menu bar and appears next to the application’s name in
the Application menu. Your application should update the controls in the frontmost window
whenever the user switches to your application. If you previously didn’t update your application to be compatible with MultiFinder, you now need to modify your application’s event loop
to accommodate a cooperative environment. For more information on the operating environment in version 7.0, see the Compatibility Guidelines chapter.

User

Feedback

When your application is the active application, you need to provide feedback to the user to
indicate what’s happening. A user learns to predict how long certain operations last. In the
version 7.0 environment, multitasking, virtual memory, and network connectivity cause task
length to become more variable. A user won’t always be able to predict the length of time per
task. Therefore it becomes more essential to display feedback about what is taking place. If
you don’t, the user may think that the Operating System stopped running and may attempt to
correct a perceived error condition, perhaps by manually restarting the machine. At least use
the spinning beach ball or animated watch cursor to indicate an operation in process. If you
can approximately determine the amount of time a task will last, it’s even better to use a
progress indicator so that a user knows that the Operating System is still running and that an
operation is occurring. Figure 2-6 shows an example of a progress indicator.

2-14

The Version 7.0 Environment

User Interface Guidelines

Inserting the file “Really long document”
into “Wombat data”...

Figure 2-6. A progress

Background

indicator

Notification

When your application runs in the background, you may need to get the user’s attention to
respond to a task completion or a request for input. The Notification Manager provides
several ways for your application to alert the user. When a background task is running and
you need to notify the user, use the Notification Manager to alternate an icon in the menu bar
with the icon for the Application menu or Apple menu as appropriate. In general, you should
display an icon that corresponds to your application or system extension, so that the user gets
a visual clue about which application is requesting attention. In addition, you should display a
diamond-shaped mark next to your application’s name in the Application menu. You can also
play a sound. Figure 2-7 shows an example of a notification symbol.

Le)

(os
~”

o&

Hide

My

“

OR

——

~
@
san.

App

rhi]

Hide Others
Shows RE

Notification symbol
Active application symbol

@

Finder

+ (¢ Sample
“<a My App

Figure 2-7. The Application menu with a notification symbol
Nothing more should happen until the user chooses to activate your application, at which time
you can display a modal dialog box. Your dialog box or message must inform the user about
what needs attention, why attention is needed, and what to do. For example, a dialog box

might say “Transmission of the file My Phone List to 415-555-1212 could not be completed
because the phone line went dead,” and it might present the user with two buttons, Try Again
and Cancel.
A background application should not take control from the user by placing an alert box on
the screen when the user hasn’t activated the application. If an immediate response is crucial
and the user doesn’t respond to the notification request, your application needs to handle the
situation gracefully.
See the Notification Manager chapter in this volume for information about implementing
these techniques.

The Version 7.0 Environment

2-15

Inside Macintosh,

COLOR

Volume VI

DESIGN

FOR

VERSION

7.0

The appearance of system software version 7.0 is enhanced by using the color capabilities of
the Macintosh. The use of color makes the interface more visually pleasing. The color also
distinguishes the active window from other windows and enhances user controls on the
window frame. It’s important to recognize that color in the interface is applied to help users
focus their attention on their work and not to draw attention to the interface itself. This section
describes the use of color in the Macintosh interface and provides recommendations about
how you can add color to your icons and applications. Color Plate II, “A Colorized Window,”
shown at the beginning of this volume, demonstrates the new appearance of colorized
windows in version 7.0.
Note: The figures that demonstrate the guidelines in this section appear on the color
plates found at the beginning of this volume. The printed colors may vary slightly
from the colors that you see on your screen.
The windows and dialog boxes in version 7.0 are designed for aesthetic consistency across all
monitors from black-and-white displays to 8-bit color displays. For display on color monitors,
color and shades of gray have been added to the frames of windows and to user controls. The
window background remains white on all systems and the window contents remain black and
white. For an example see Color Plate III, “A Colorized Movable Modal Dialog Box,” which

shows a colored frame, but black radio buttons and text. This updated design takes advantage
of the color capabilities of the Macintosh but maintains the consistency of the Macintosh
interface. On color screens, the racing stripes in the title bar and the scroll bars are gray. The
user controls, close box, size box, zoom box, and scroll box are colored to make them more

apparent. The borders of inactive windows are gray and recede into the background so that the
active window’s black frame emphasizes its position in front of the other windows.
For version 7.0 the standard window definition functions have been changed to display color
windows and dialog boxes. Some control definition functions have been updated to display
in color the window’s scroll bars, scroll arrows, scroll box, close box, size box, and zoom

box. If you use the standard window definition functions and standard control definition
functions, your application’s windows will match the appearance of version 7.0 system
windows. If you create your own windows, be compatible with version 7.0 by using the
standard window color table and the guidelines described in this section. Be aware that users
can change the colors of windows and dialog boxes by using the Colors control panel. If you
use the default window color table, you can be sure that the colors you use are consistent
with any color that the user has access to with the Colors control panel. You can use the
Palette Manager to associate a color palette with a window definition. See the Palette Manager
chapter in this volume for more information.

General

Color

Design

Guidelines

Always design for black and white first and then colorize that design. This method ensures that
your design looks good on all Macintosh computers. One example of why this is important is
the text selection mechanism. On a color monitor you might be tempted to change the color
of text to indicate its selection; however, this technique wouldn’t translate to a black-and-white
monitor. In addition, a significant percentage of the population (up to 10 percent of the male

2-16

Color Design for Version 7.0

User Interface Guidelines

population) has color deficiencies and wouldn’t recognize the use of color to indicate selection. Therefore, you should never use color as the only means of communicating important
information. Color should always be used redundantly. Color Plate IV, “Design for Blackand-White Monitors First,” shows the correct process of designing for black-and-white
monitors and then adding color to those designs. It demonstrates the consistency of the
appearance of the icons and how the aesthetic integrity is maintained across the designs.
Keep black-and-white designs two-dimensional. It’s important to maintain the visual consistency of the Macintosh interface across applications and computer systems. Don’t cause
unnecessary visual clutter by trying to mimic color effects, such as shadows, in black-andwhite designs. Color Plate V, “Don’t Mimic Color Effects in Black-and-White Designs,”
shows icons that were designed in color first and then adapted to a black-and-white design. It
demonstrates the difficulty of trying to mimic color effects. This color plate shows how using
only black pixels and white pixels limits your ability to re-create the appearance of color
icons.
Note: This guideline doesn’t apply to keyboard icons discussed earlier in the
“Worldwide Software Development” section. In that section, specific patterns
represent colors for black-and-white versions of the keyboard icons.
Maintain a close visual relationship between a black-and-white design and its colorized version.
Users should be able to easily recognize standard interface elements and icons across all monitor types. Users can have several monitors connected to a computer and several computers on
which they use your applications. Your application should look consistent when a user changes
the bit-depth of a monitor or when the user moves your icon or window from a color monitor
to a monochrome monitor.
Use as few colors as possible in your designs. The fewer colors you use, the less flashing
occurs when the screen’s color table updates during screen redrawing. Using fewer colors
also results in less visual clutter on the screen. If you use a graphics application to do design
work, make sure that the colors you use are available in the default color tables. For more
information about color palettes and color tables, see the Palette Manager chapter later in
this volume.
Use light or subtle colors for large areas. Also use subtle colors to avoid visual clutter on the
screen. To extend the range of light or subtle colors available, you can create colors that are
lighter than those in the default color tables by using a 50 percent pattern of the color and
white. Color Plate VI, “Use Light Colors for Large Areas,” shows some icons that appropriately use colors. Color Plate VII, “Don’t Use Bright Colors for Large Areas,” shows how
too many bright colors can be visually distracting.
Use bright colors sparingly and only in small areas. Bright colors attract the eye and can
distract the user from the information that you’re trying to convey. Bright colors can be
effective in the contents of a window, such as in a chart. However, if bright colors appear all
over the screen, it becomes difficult for the user to focus attention. You can use bright colors
for small details. An example of this technique is the version 7.0 hardware icons (such as the
hard disk icon) that use red and green pixels to represent the Apple logo. For an example of
this guideline, see Color Plate VIII, “Use Bright Colors for Details.”
For display on color screens in version 7.0 use true gray wherever you previously used a
50 percent gray pattern. Use true gray in menus for the dotted separator lines between groups
of items and for dimmed menu items.
Color Design for Version 7.0

2-17

Inside Macintosh,

Volume VI

Use a consistent light source. On the Macintosh screen the light source always comes from
the upper-left corner of the screen. Therefore windows and other elements have drop
shadows on the lower-right side. Use the light source consistently, so that shading is consistent throughout the interface. Color Plate IX, “A Consistent Light Source,” at the beginning
of this volume, shows three desktop objects that have drop shadows consistent with a light
source at the upper-left corner of the screen. Color Plate X, “Inconsistent Light Sources,”
shows three desktop objects that have different light sources and inconsistent drop shadows.

The

Icon

Family

In previous versions of system software, you provided a black-and-white 32-by-32 pixel
icon for your application that was automatically reduced to 16-by-16 pixels when necessary.
In system software version 7.0, you can provide multiple versions of an icon in black and
white and in color. You can provide a family of icons that includes a 32-by-32 pixel and a
16-by-16 pixel icon, in 1-bit color (black and white), 4-bit color, and 8-bit color. The

32-by-32 pixel icons appear on the desktop and, if the user chooses by Icon from the View
menu, these icons also appear in Finder windows. The 16-by-16 pixel icons appear in the
menu as the Application menu’s title when your application is active. They also appear next
to your application’s name in the Application menu and in Finder windows when the user
chooses by Small Icon from the View menu. The user can also set the icon size to 16-by16 pixels or 32-by-32 pixels in other views. For localized keyboards and keyboard layouts,
you provide a 16-by-16 pixel icon only, in 1-bit, 4-bit, and 8-bit color. Figure 2-8, shown on
this page in black and white, and Color Plate XI, “An Icon Family,” show a family of icons
for version 7.0.

ICN#

ics#

icl4

icl8

Figure 2-8. An

ics8

Mask

Mask

icon family

See the Finder Interface chapter in this volume for information about which icons you need to

provide and how to create a bundle resource for your application.

The monitor displays the highest-quality icon that its screen allows. That is, if you provide an
8-bit color icon, a 4-bit color icon, and a black-and-white icon, the user sees the 8-bit color

icon on the monitor that supports 8-bit color. If you provide an 8-bit icon but not a 4-bit icon,
the black-and-white icon is displayed on the 4-bit monitor. If you provide a 4-bit icon but not
an 8-bit icon, then the 4-bit icon is displayed on both 4-bit and 8-bit monitors. If you don’t

provide a color icon, then the Finder displays the black-and-white version of the 32-by-32 pixel

icon on all types of monitors.

Black-and-White

Icons

As stated previously, you should begin by designing a black-and-white icon. In general,
you should use an outline of one black pixel to create the icon border. Use a minimal
2-18

Color Design

for Version 7.0

User Interface Guidelines

number of black pixels in the icon so that the icon’s appearance is noticeably different when
selected. Figure 2-9 shows an example of a well-designed icon that changes significantly
during selection.

ca
Figure 2-9. A well-designed icon and its selected version
If you use too much black or 50 percent gray in your icon, the icon doesn’t appear significantly different when the pixels are reversed for selection. Figure 2-10 shows an example
of an icon with too much black and 50 percent gray.

Nw

Figure 2-10. A poorly designed icon and its selected version

=

eZ)

@-

—

Small

i)
me
@

Icons

In version 7.0 you can provide a 16-by-16 pixel icon that you scale to size rather than relying
on the Operating System to algorithmically reduce your 32-by-32 pixel icon. If you do not
provide a small icon, the Finder reduces the larger icon based on an algorithmic formula that
makes the icon look rough and creates less pleasing visual results.
You should provide a small version of your 32-by-32 pixel icon that you scale. Preserve
as many graphical elements of the icon as possible. In essence you provide the same icon
in asmaller scale. You can fine-tune the small icon by adding and removing pixels. Don’t
eliminate significant elements, or the smaller version of the icon may look different from the
larger version. See Color Plate XII, “Consistently Designed Small Icons,” which shows
icons that a designer carefully scaled and tuned to preserve key elements of the icons’
designs. Also see Color Plate XIII, “Inconsistently Designed Small Icons,” to see small
icons that don’t match their corresponding 32-by-32 pixel versions. If you have difficulty
distinguishing the consistency or inconsistency, it’s a good idea to consult with a graphic
designer to design or review your icons.

Color

Icons

Version 7.0 ships with full-color icons that appear on color monitors. Your application can
also provide color icons.
Don’t design a color icon that’s substantially different from your black-and-white icon. When
you add color to an icon, it’s best to leave the one-pixel black outline and fill the icon in with
color. Coloring or graying the icon’s outline makes the icon appear less distinct on the desktop. Remember that the user can change the background color of the desktop as well as its

Color Design for Version 7.0

2-19

=pe)
©

©

Inside Macintosh,

Volume VI

pattern, so your icon may not be displayed against the background on which you designed it.

If you use ResEdit™ 2.1 to create your icons, it provides a way to look at your icon against

different backgrounds to see whether your design is effective in various environments such
as black-and-white displays or color displays of different bit depths. Color Plate XIV, “Icons
With a Black Outline,” and Color Plate XV, “Icons Without a Black Outline,” demonstrate

the importance of the black outline of an icon.

Color Plate XVI, “Apple Icon Colors,” identifies the 34 colors used for icon design in
version 7.0 in a palette with the standard 256 colors. If you use ResEdit 2.1 to design and
create your icons, the Finder icon family editor provides easy access to these colors. Choose
Apple Icon Colors from the Color menu. This command sets the palette in the editor (which
is similar to the palette in most graphics applications) to contain the 34 colors used for Finder
icons. See ResEdit Reference for information on using ResEdit 2.1.
If the default color table colors aren’t available, the system software gracefully degrades to
black and white, starting with comparable 8-bit colors, then using 4-bit colors if possible,
and finally displaying the element in black and white if no other choice exists. The system
software won’t substitute colors that aren’t visually close to colors that you assigned. If you
choose colors other than the 34 marked in Color Plate XVI, use them for detail and not for
essential parts of your windows or icons. The selection mechanism for color icons lowers
the brightness of colors to indicate selection. This means that the colors appear darker when
selected. On a color monitor, a black-and-white icon turns gray when selected. On a monochrome monitor, a black-and-white icon uses reverse video to show selection. In order for
selected items to appear distinct from unselected ones, use light colors for large areas.
One technique for enhancing the appearance of your icons is to smooth angular or curved
lines by coloring pixels on jagged edges. Designers refer to this technique as anti-aliasing.
Change the pixel color where you can see a visual break in the outline of a black-and-white
icon. Color Plate XVII, “Correct Anti-Aliasing,” shows an icon in its normal state and then
with anti-aliasing that changes the pixels on the outline of the icon. Color Plate XVIII,
“Incorrect Anti-Aliasing,” shows a different icon in its normal state and then with antialiasing that replaces internal pixels to improve the appearance of the icon. You can find these
figures on the color plates at the beginning of this volume.
The Finder uses only one mask for each size in the icon family, so make sure that all your
icons have the same outline shape. Don’t add pixels or shadows to the outline shape of
color icons. The Finder uses the icon mask for alignment and transformation effects, so
make sure that the mask and all your icons are appropriate for each other.

Consistent

Use

of Icons

Use icons consistently throughout your designs. For example, if you reuse icon elements when
you modify the generic document icon to represent your own application’s files, make sure that
they match. For example, the Macintosh computer inside the System Folder icon is the same
as the Macintosh that appears as the Finder icon and as part of the Installer icon. The file server

2-20

Color Design for Version 7.0

User Interface Guidelines

icon contains the same gray document icon and the same purple folder icon that appear on
the desktop. Color Plate XIX, “Consistent Use of Icon Elements,” and Color Plate XX,
“Inconsistent Use of Icon Elements,” at the beginning of this volume, demonstrate this guideline. Don’t invent new icons to represent known entities such as folders and documents.

Customized

Icons

You can provide the following customized icons if you support the associated features. You can
customize these icons to represent your application, just as you can customize document icons.
= Document icon. This icon represents a document created with your application. You
can customize this icon so that it relates to your application icon by adding graphics to it.
Be sure to maintain the outline of the document. See the Finder Interface chapter in this
volume for more information about displaying customized icons.
a Stationery icon. This icon represents a stationery pad that the user creates from a
document. You can customize the stationery icon for each document icon by adding
graphic elements to the stationery document page. See the Finder Interface chapter in
this volume for more information about stationery.
= Query document icon. This icon represents a file that contains information that the
Data Access Manager uses to transmit a query to a database. You can customize this
icon by adding graphics to the document page. Be sure to maintain the outline of the
icon and the volume symbol that represents the database. See the Data Access Manager
chapter in this volume for more information on using the Data Access Manager.
= Edition icon. This icon represents an edition file that is created when a user chooses
Create Publisher from the Edit menu. You can customize this icon by putting a different
graphic inside the rectangle. Maintain the horizontal orientation and the double-dotted
line of the icon that identify it as an edition icon. See the Edition Manager chapter in
this volume for more information on implementing the Edition Manager.
= Extension icon. This icon represents a system extension. You can customize
this icon by adding a graphic to the puzzle piece. You can display the puzzle piece in
a horizontal or vertical orientation with the protruding part facing any direction. See
the Finder Interface chapter in this volume for more information on displaying
customized icons.
If you support these features but don’t provide customized icons, the Finder displays default
icons for these objects, depicted here in Figure 2-11 and in Color Plate XXI, “Default System
Icon Families,” at the beginning of this volume. See the Finder Interface chapter in this volume
for information on how to use the bundle resource to associate these icons with your application.

nL]

a LJ

a Lb

Document

Stationery

Query
document

Figure 2-11.

i

ao

Chat

Edition

Extension

Default system icons in black and white
Color Design for Version 7.0

2-21

Inside Macintosh,

Volume

VI

If you develop control panels, you must provide an icon family for each control panel. The
control panel icon is a square panel with an indicator on it to identify it. The indicator also
appears on the Control Panels folder. You can add a graphic to the square to customize the

icon. You can display the icon in either a horizontal or vertical orientation. Figure 2-12 shows
some examples of control panel icons in both orientations. The examples are shown in color
in Color Plate XXII, “Examples of Control Panel Icons,” at the beginning of this volume.

a
s&

slS

Control Panels
folder

Color

Figure 2-12.

a&é

Portable

wl

User Setup

File Sharing
Monitor

Examples of control panel icons

WINDOWS
This section provides information about window placement and behavior. It also presents
general guidelines about windows and related dialog boxes and alert boxes.

Window

Positions

To determine where to place a window, consider what kind of window your application is
opening, what other windows are open and where, and the relationship between the content
of a window and other windows or dialog boxes. Respect the user’s control of the window
and maintain the user’s preferred size, state, and location for the window.
When your application opens a new document window, center it on the desktop. Open each
additional window below and to the right of its predecessor. Before closing a window, check
to see if the user has changed its size, state, or position. Save window positions, then reopen
windows in the size, state, and location in which the user left them.
Before reopening a window, check to make sure that the size and state are reasonable for the

user’s current monitor or monitors, which may not be the same as the monitor on which the
document was last open. For example, if a user is working on a word-processing document
on a full-page display and then takes the document home and uses another computer to finish
working, the second computer may have a 13-inch monitor. Then your application should
open the document in a window sized appropriately for the smaller monitor and not
necessarily in the saved size.
If the user hasn’t changed a window’s position, place windows in a position appropriate to
the monitor type. If a user opens, moves, and closes a document window without making
any changes, save the new window position but don’t modify the date stamp.
When you open several windows on multiple screens, place the windows on the screen where
the user is working. If a user drags a window from a Macintosh II monitor to a portrait
2-22

Windows

User Interface Guidelines

display monitor, open subsequent windows on the portrait display monitor. The default
position of a window must always be contained on a single screen.
Open dialog boxes and alert boxes on the screen where the user is working. For example, if a
user has two monitors with a text document on the second monitor, open a find-and-replace
dialog box on the screen where the related text document appears, not necessarily on the
monitor where the menu bar is.

The

Zoom

Box

and

Window

Behavior

A click in the zoom box toggles a window between two states, the user state and the standard
state. The user state, as its name implies, is set by the user. In Human Interface Guidelines:
The Apple Desktop Interface, a window’s standard state definition is described as generally
the full screen, or close to it, with the size and location that are best suited to working on
the document.
But Macintosh monitors now come in all shapes, sizes, and configurations, so applications
should never simply assume that the standard state should be as large as the screen. Frequently
the monitor is larger, sometimes much larger, than the most useful size for a window. Screen
real estate is valuable, so use screen-sized windows only when they make sense.

nN
|
2)

@
7

For example, a document for a word processor has a well-defined most-useful width (the
width of a page) and a variable most-useful height (depending on the number of pages).
Therefore the width of the standard state should be the width of a page or the width of the
screen, whichever is smaller, and the height of the standard state should be the height of
the document or the height of the screen, whichever is smaller.

-_

—

<)
=_

e
=>

an
x)
@

Cl

When a user clicks the zoom box to change a window from the user state to the standard
state, first determine the appropriate size of the standard state. If this size would fit completely on the screen without moving the upper-left corner of the window, keep this corner
anchored. Otherwise, move the window to an appropriate default location.
Zooming behavior in multiscreen environments should not violate any of the guidelines
described in this chapter, but it does introduce a single additional rule. The standard state
should be on the monitor containing the largest portion of the window, not necessarily on
the monitor with the menu bar. This means the standard state for a single window may be
on different monitors at different times if the user moves the window around. In any case,
the standard state for any window must always be fully contained on a single screen.

DIALOG

BOXES

This section presents revised guidelines for design and layout of effective dialog boxes.
The guidelines rely on the principles of feedback and dialog, forgiveness, and consistency
as described in Human Interface Guidelines: The Apple Desktop Interface. These guidelines supersede previous guidelines about dialog boxes published in prior versions of
Inside Macintosh.

Dialog Boxes

4

=
—

2-23

Inside Macintosh, Volume VI

Modal

Dialog

Box

Behaviors

In version 7.0 the Dialog Manager has been updated to provide additional support for feedback
mechanisms and menu bar access. When you display a modal dialog box, the Dialog Manager
disables the Application menu, the About Balloon Help command in the Help menu, and the
About Keyboards command in the Keyboard menu. It then checks to see if you are handling
menus during a modal dialog box. These conditions are explained in detail in the Compatibility
Guidelines chapter in this volume.
If the Dialog Manager determines that you are not handling your own menus, it disables the
rest of the menu bar except for the Help menu. The Dialog Manager then determines whether
the dialog box contains an active editable text box and if you have the standard keyboard
equivalents for the Cut, Copy, and Paste commands. If both of these conditions are met, then
the Dialog Manager enables the Edit menu and those commands in the Edit menu.
If the Dialog Manager detects that you are handling menus in your application, it only disables
the Application menu. You must provide access to the Help and Edit menus. To support the
Cut, Copy, and Paste commands you need to convert the Clipboard before and after you
display a modal dialog box. You can also provide menu bar access in your application by
enabling menus and commands in those menus that make sense in the context of the current
task. See the Compatibility Guidelines chapter in this volume for information on enabling
menus when you display a modal dialog box.

Movable

Modal

Dialog

Boxes

Version 7.0 introduces a new window class, the movable modal dialog box. The user sometimes needs to see document contents that a modal dialog box obscures. To allow the user to
move a dialog box in this case, you can use a movable modal dialog box rather than a modal
dialog box. The movable modal dialog box has a title bar as part of its standard window so
that the user can move the dialog box by dragging the title bar.
The design of the movable modal dialog box combines the standard modal window with a
title bar with racing stripes, but no close box or zoom box. This design gives the user visual
feedback that the dialog box is modal, and must be responded to before completing any other
action in the active application, but the user can move it. Figure 2-13 shows a movable modal
dialog box with attribute options that affect an area a user would want to see, such as the text
that a border would surround.
Line Style

Figure 2-13. A movable modal dialog box

2-24

Dialog Boxes

User Interface Guidelines

To create a movable modal dialog box, use the window definition ID of the movable modal
dialog box in the standard resource type 'WDEF'. As with all movable windows, be sure to
save the position of the movable modal dialog box window for the next time it’s used. See
“Creating Movable Modal Dialog Boxes” in the Compatibility Guidelines chapter in this
volume for details on creating movable modal dialog boxes.
Movable modal dialog boxes should respond like modal dialog boxes in most ways. When
you display a movable modal dialog box, however, there are some additional behaviors you
need to support. You must make certain that the dialog box is modal within your application.
That is, the user should not be able to switch to another of your application’s windows while
the dialog box is active. Allow your application to run in the background when you display a
movable modal dialog box. For example, system software version 7.0 uses movable modal
dialog boxes to show that an application is busy with a time-consuming operation, yet a user
can still switch the application to the background. Figure 2-14 shows a movable modal dialog
box displayed by the Finder when it is copying files.

Copy
Items remaining to be copied:
Writing:

5

Picture 1

Figure 2-14. A Finder movable modal dialog box
You need to provide access to the menu bar when you display a movable modal dialog box.
Provide access to the Help menu, the Edit menu, the Keyboard menu when appropriate, and
any context-appropriate commands. Also enable the Application menu so the user can switch
to another application.
It’s important to consider whether you can use a modeless dialog box instead of a movable
modal dialog box—to preserve the user’s ability to perform any task in any order. See the
Compatibility Guidelines chapter in this volume for information on implementing movable
modal dialog boxes.

Keyboard

Navigation

in Dialog

Boxes

In previous versions of system software you could select an item in the scrolling list in the
standard file dialog box for opening files by using the keyboard. The ability to select an item
from a set of items by typing the beginning character or characters of its name is called type
selection. The user can also use the arrow keys to move the selection by one item in the
direction of the arrow. Type selection has been extended to work in other lists, such as the
list of files in a Finder window and the list of available devices in the Chooser.
Some dialog boxes have several elements, such as text boxes and scrolling lists, that can
accept input from the keyboard. It’s necessary to visually indicate which element is currently
accepting input from the keyboard in order to let users know which of the possible elements
is active. Each element has its own distinct indicator. As in the past, a text box displays a
blinking insertion point or selected text range to indicate that it is accepting keyboard input.

Dialog Boxes

2-25

Inside Macintosh,

Volume VI

When a scrolling list is the active element in a dialog box, its visual indicator is a rectangular
border of two black pixels, which is separated from the list by one pixel of white space.
Figure 2-15 shows the AppleTalk® Zones list in the Chooser as an active scrolling list area.
SSeS

Chooser

e

AppleShare

AppleTalk ImageWr...

ImageWriter

LaserWriter

AppleTalk
Bear

Zones:

Boulevard

Cougar Court
Elephant

Avenue

Penguin Place
Stork Street

ice
ae
ombat
Way

Zebra Zone

Figure 2-15.

coe

.

appleralk

@ Active

© Inactive

70

A selected scrolling list

When a user activates a scrolling list, using the following QuickDraw™ routines outlines the
scrolling list in the standard way:
PenSize(2,2);
InsetRect

(scrollRect,-3,-3);

FrameRect

(scrollRect);

Since all typing goes to the active window, there should be only one active area and only one
indicator at any time. If a dialog box has only one element that can accept keyboard input (and
that element is a scrolling list), it’s not necessary to outline a scrolling list. In the standard file
dialog box the user can use type selection to identify the desired file in the list of files, but,
since there’s no other list or text box, the selected list doesn’t have a border.
In a dialog box the user can move the active area to any interface element that accepts keyboard
input, such as a text box, by clicking the desired element or by pressing the Tab key to cycle
through the available elements.

Button

Labels

Whenever possible, label a button with a verb that describes the action that it performs. Use
book-title capitalization for button labels. In general, this means that you capitalize one-word
titles and, in multiple-word titles, capitalize words of four or more letters. Usually you don’t
capitalize words like in, an, or and. The specific rules for this type of capitalization appear in
detail in the Apple Publications Style Guide.
Provide a Cancel button whenever you can, and always map Command-period and the
Esc (Escape) key to the Cancel button. Map the Return key and the Enter key to the default
button, which is usually the button with the safest result or the most likely response. Don’t
2-26

Dialog Boxes

User Interface Guidelines

display a default border around any button if you use the Return key in editable text boxes.
Having two behaviors for one key confuses users and makes the interface less predictable.
In all dialog boxes, any buttons that are activated by key sequences must invert to give visual
feedback that indicates which item has been chosen. A good rule of thumb is to invert the
button for 8 ticks of the clock, which is long enough to be visible, but short enough that it’s not
annoying. All alert boxes and modal dialog boxes that use the ModalDialog procedure exhibit
this behavior. If you implement your own dialog boxes or alert boxes, be sure to include this
behavior. See the Compatibility Guidelines chapter in this volume for more information on the
ModalDialog procedure.
A user typically reads the text in a dialog box until it becomes familiar and then relies on
visual cues, such as button names or positions, to respond. Names such as Save, Quit, or
Erase Disk allow users to identify and click the correct button quickly. These words are often
more clear and precise than words like OK, Yes, and No. If the action can’t be condensed
into a word or two, OK and Cancel or Yes and No may serve the purpose. If you use these
generic words, be sure to phrase the wording in the dialog box so that the action the button
initiates is clear. Figure 2-16 shows a dialog box with appropriate OK and Cancel buttons.
)
Cat Detector™

Pinpoint a purr at:

options

=

Cat licence price (£):

=

e

-

© 40 yards

@ 60 yards
(© 80 yards

&

15] [ft

o
S

| Cancel

Figure 2-16. A dialog box with OK and Cancel buttons
Use Cancel for the button that closes the alert or dialog box and returns the computer to the state
it was in before the alert or dialog box appeared. Cancel means “dismiss this operation, with no
side effects.” It does not mean “I’ve read this dialog box” or “stop what you’re doing regardless.”
When it is impossible to return to the state that existed before an operation began, don’t use the
word Cancel. You can use OK or Stop, which are useful in different situations. Use OK for
the name of a button that closes the alert or dialog box and accepts any changes made while the
dialog box was displayed. Figure 2-17 shows a dialog box that illustrates this guideline.

That Format
This Format

Yet Another Format

Formats

“

lle

Custom

Remove

Modify

Figure 2-17. A dialog box with OK instead of a Cancel button
Dialog Boxes

2-27

Inside Macintosh,

Volume

VI

This dialog box uses OK because clicking the button maintains any changes that were made
subsequent to the display of the dialog box. If the button were named Cancel, clicking it
should remove any formats created, removed, or changed since the dialog box appeared, and
it should return the computer to the state it was in before the dialog box appeared.
Use Stop for a button that halts an operation midstream while accepting the possible side
effects. Stop may leave the results of a partially complete task intact, whereas Cancel always
returns the computer to its previous state. It’s appropriate to change the button name in the
middle of the operation from Cancel to Stop if you can determine when it’s no longer possible
to cancel. Figure 2-18 shows a dialog box that illustrates this guideline.
Inserting the file “Really long document”
into “Wombat data”...

Figure 2-18. A progress indicator that uses a Stop button
The dialog box in Figure 2-18 uses Stop because clicking the button maintains the text that is
already inserted while preventing completion of the insert operation.
In an alert box that requires confirmation, use a word that describes the result of accepting the
message in the dialog box. For example, if a dialog box says “Revert to the last saved version
of this document,” label the button Revert rather than OK. Figure 2-19 shows a dialog box
with appropriately labeled buttons.

Revert to the last saved
of “The Big Red Book”?

Figure 2-19.

version

A confirmation alert box

If there is a most likely action, use a default button. This button usually completes the action
that the user initiated to bring up the dialog box. The default button is outlined with an
additional border of three black pixels, separated by a border of one white pixel, and its
action is performed when the user clicks the button or presses the Return or Enter key.
Don’t use a default button if the most likely action is dangerous—for example, if it causes a
loss of user data. When there is no default button, pressing Return or Enter has no effect: the
user must explicitly click a button. This guideline protects users from accidentally damaging
their work by pressing Return or Enter out of habit. You can consider using a safe default
button, such as Cancel.
A modal dialog box usually cuts the user off from the task. That is, he or she can’t see
the area of the document that changes when choices are made in the dialog box until
dismissing the dialog box. Once the area becomes visible by dismissing the dialog box, the
2-28

Dialog Boxes

User Interface Guidelines

user sees whether the changes are the desired ones. If the changes aren’t appropriate, then
the user has to repeat the entire operation. To provide better feedback to the user, you need to
provide a way for the user to see what the changes will be. Therefore, any selection made in a
modal dialog box should immediately update the document contents, or you should provide a
sample area in the dialog box that reflects the changes that the user’s choices will make. In
the case of immediate document updating, the OK button means “accept this change” and the
Cancel button means “undo all changes done by this dialog box.”
Some applications use an Apply button to approximate this behavior. This method confuses
the meaning of OK and Cancel and is not recommended. If you must implement modal dialog
boxes with an Apply button, you need to include a Cancel button and a Revert button in the
dialog box. Otherwise the Cancel button becomes confusing to the user. When there is an
Apply button, the Cancel button undoes the results of the Apply operation and dismisses the
dialog box. The OK button dismisses the dialog box. The Revert button returns the document
to the state it was in before the dialog box was displayed. The user must always be able to
undo any actions caused by the dialog box.

Dialog

Box

Layout

)

In most simple dialog boxes, such as alert boxes, you should place buttons in functional and
consistent locations, both within your application and across all applications that you develop.
Place the action button in the lower-right corner with the Cancel button to its left. Figure 2-20
shows the recommended location for buttons and text. The default button can be any button;

|

its assignment is secondary to the consistent placement of buttons. This rule keeps the action
button and the Cancel button consistently placed. Otherwise, the buttons would keep changing
location depending on the default choice for the dialog box.

weer

7

~

'

ied

[~~ “This is where the text goes.
ig

use

wording

that

makes

typical user.
nm
LGN cae ge

A=1 3 white pixels
B = 23 white pixels

Be sure td

sense

=

to the

|
———
|| Aft

(cr

‘A!

|

At

Figure 2-20. The recommended spacing of buttons and text in a dialog box

Use a consistent amount of white space between the border of the dialog box and its elements.
This creates a balanced appearance in the dialog box. Otherwise the user might perceive a
lopsidedness or other visual imbalance in your dialog box.
The Western reader’s eye tends to move from the upper-left area of the dialog box to the
lower-right area. Put the initial impression that you want to convey in the upper-left area
(like the alert icon that appears in alert boxes), and place the buttons that a user clicks in the
lower-right area. Following this guideline makes it easier for users to identify what’s
important in a dialog box.

Dialog Boxes

2-29

eS
—N
oO
~

ail

~

—

©
a §
©
O
o

Inside Macintosh, Volume VI

When dialog boxes are localized for worldwide versions of system software, the text in the
dialog box may become longer or shorter. The alignment of the items in the dialog box may
vary with localization. Arabic and Hebrew are written right to left, so alignment of the items
in an Arabic or Hebrew dialog box should be right to left. The Control Manager, Menu
Manager, and TextEdit routines handle the alignment of dialog box components. For more
information, see the chapters that describe those managers in this volume and previous
volumes. Be sure to create dialog items of the same size, so that they align properly when a
user has a script that reads from right to left. This guideline is discussed earlier in the
“Worldwide Software Development” section of this chapter.

Dialog

Box

Messages

Write messages in dialog boxes and alert boxes that make sense to the user. Use simple,
nontechnical language and don’t provide system-oriented information that the user can’t
respond to. When possible, give the user information that helps explain how to correct the
problem. Figure 2-21 shows an example of a well-written dialog box message that replaces
the message users used to see, “The application is busy or missing.”

(

The application that created the document
“Progress” could not be found. Do you
want to open the document using the
application “TeachText”?

Figure 2-21.

A well-written dialog box message

Use the name of the document or application in a dialog box when the text refers to it. For
example, a dialog box that appears when a user chooses Shut Down after working on the
company’s annual report using the TeachText application should say “Save changes to the
TeachText document “Annual Report” before quitting?” rather than simply “Save changes
before quitting?” This kind of labeling helps users who are working with several documents
or applications at once to make decisions about each one individually.

Standard

File Dialog

Boxes

The version 7.0 standard file dialog boxes present some new information to the user. They
show a file’s position in relation to the disk it’s stored on. Instead of showing the root level
of a hard disk as the highest level of the directory structure, the desktop now appears as the
top level of the Hierarchical File System. The Drive button has been replaced with the Desktop
button. A user can view and select disk drives from the standard file dialog box and can see
other desktop entities such as the Trash folder. The dialog box that appears when the user
chooses Save As includes a New Folder button that allows the user to create a folder in which
to store the document. The pop-up menu in this dialog box now includes the downwardpointing triangle for additional visual feedback.

2-30

Dialog Boxes

User Interface Guidelines

If you interact with the file system directly and use a dialog box similar to the standard file
dialog boxes, you should replicate the organization and appearance of the standard file dialog
boxes. Figure 2-22 shows an example of the new standard file dialog box for opening files.
For more information, see the Standard File Package chapter in this volume.
| Ge Desktop w|
—

Loma

= Pinky

Prieta

<= Loma Prieta
ate

Lieet

a

— Independence
> 2il
©

User

Interface

O surfwriter

Hasktop

Guidelines

|

|

ie)

T trash

—

[[

Figure 2-22. The new standard file dialog box for opening files
'S)

Save

Changes

Dialog

Box

=
2)
©
*

This section describes the new standard dialog box for saving all changes to a document
before a user quits an application. The design presented in Volume IV of Inside Macintosh
created some situations in which users, especially inexperienced users, could experience a
loss of data. The new design addresses those concerns and standardizes the appearance of the
dialog box so that users can quickly identify potentially dangerous actions.
Place the standard warning icon in the upper-left corner of the dialog box. This icon indicates
to users that they need to carefully consider the dialog box message before clicking the default
button or the Return key. The warning icon should always be in the same, predictable location
so that users easily recognize it as a warning and respect its meaning.
Previously the buttons in the save changes dialog box were labeled Yes, No, and Cancel. The
save changes dialog box changes the names of the buttons to correlate to the action users
perform by pressing the button. The buttons should now read Save, Don’t Save, and Cancel.
Using these verbs reinforces the identity of each possible action to the user so that the experience is more intuitive. In other words, the Don’t Save label provides much more context for
the user than the word No does.
The new design provides a safeguard for the user by standardizing the location of buttons in
a safe configuration. In order to prevent accidental clicks of the wrong button, you should
always keep safe buttons apart from buttons that could cause data loss. Place the Save button
in the lower-right corner with the Cancel button to its left. Place the Don’t Save button on
the left and left-aligned with the message text. This way, the user must explicitly move the
pointer and click the button that could cause irretrievable loss of data. Figure 2-23 shows an
example of a standard save changes dialog box.

Dialog Boxes

2-31

Lael

=}
©
-

=

p9
°
©

Inside Macintosh,

Volume

VI

Save changes to the TeachText
document

“Special

Memo”

before

quitting?

(Cancer) (save ]
A button that
causes data loss

i

=

Zz

Buttons that are “safe”
for data

Figure 2-23. The save changes dialog box
Include the name of your application and the name of the document in the dialog box message,
as shown in Figure 2-23. When a user shuts down the computer, several save changes dialog
boxes may appear if there are several open documents on the desktop. This addition of information to the standard message helps the user by identifying to which application and
document the message refers.

MENUS
This section describes changes to applications’ menu style and contents in system software
version 7.0. Applications can include several standard menu items that relate to new features
of system software version 7.0. This section also presents the reserved list of keyboard
equivalents for menu commands.

File

Menu

Applications that support high-level database access, as described in the Data Access Manager
chapter later in this volume, need to include the Open Query command in the File menu. This
command opens a query document that establishes communication with a target database.

Edit

Menu

If your application implements the capabilities of the Edition Manager, include its commands
in the Edit menu, separated from the standard commands by a gray line. The commands are
w Create Publisher...
mw Subscribe To...
w Publisher/Subscriber Options... (context-sensitive toggle command)
a Show/Hide Borders (optional context-sensitive toggle command)
Stop All Editions (optional command)
2-32

Menus

User Interface Guidelines

Figure 2-24 shows a sample Edit menu that includes the required commands.
Undo

#2

Cut
Copy
Paste
Select

All

3H
#C
3U
3A

Create

Publisher...

Subscribe To...
Publisher Options...
Show

Figure 2-24.

Clipboard

A sample Edit menu

If you find that you need all of the available space in the Edit menu for your application’s
commands, another way to accommodate the Edition Manager commands is by implementing
a hierarchical menu. Include a Publishing command in the Edit menu as the title of the sub-

oe

menu. Use the standard indicator for a hierarchical menu, as shown in Figure 2-25, which

7

no other alternative.

o

also shows the submenu with the Edition Manager commands. Because hierarchical menus
increase the complexity of your application, it’s best to only use this approach when you have

S
a
Undo

82

Cut

SH

Select All

A

Copy
Paste

Publishing
Show

#&C
BU

14

Clipboard)

Create Publisher...
Subscribe

To...

Publisher

Options...

Figure 2-25. A sample hierarchical menu with Edition Manager commands
The user interface issues, as well as the technical implementation information related to
the Edition Manager capabilities, are described in the Edition Manager chapter later in
this volume.

Font

a
=I

Menu

System software version 7.0 includes TrueType™ fonts. If you decide to incorporate basic
support for TrueType fonts into your application, remove the 127-point size limit for bitmapped
fonts. Provide support for all font sizes in your application. Continue to outline font sizes in the
menu for those sizes that appear in the user’s System file. Use plain type for font sizes that
aren’t in the System file. If a TrueType font is present, outline all sizes of that font that you
display in the menu. Provide a way for users to choose whatever font size they desire. When
the user chooses a font size, place a checkmark next to the active font size.
Menus

2-33

Inside Macintosh,

Volume

VI

One method that you can use to support TrueType fonts is to add an Other command to the end
of the Size menu (or the end of the Font menu, if that’s where your application allows users to
choose font sizes). When the user chooses Other, display a dialog box that allows the user
to choose any available font size. You can include a text box in which users can type the font
size they want. If the user enters a font size that’s not currently on the menu, add it to the list
of choices. If the user is adding a TrueType font size, outline the size when you add it to the
menu. If the user is working with a bitmapped font, show the new size in plain type. Provide
a real-time display area to update the font size as the user changes it. Figure 2-26 displays a
sample pull-down Size menu and font size dialog box. See the Font Manager chapter in this
volume for more information on TrueType fonts.

size

A

Font Size:

9

10
12
18

Tl

.
AC quick

brown fox

vag

516)
Larger

[Cancel _|

Smaller

(x)

r
Figure 2-26.

Help

A sample pull-down Size menu and font size dialog box

Menu

System software version 7.0 includes on-line help for system software. The user can access
Apple’s Balloon Help from the Help menu. If you provide help information for your application, move the help commands that you provide to the Help menu. It’s a good idea to
include the name of your application next to your help command so that the user can easily
distinguish the type of help to choose. For example, you might include a command called
TeachText Help in the Help menu. Figure 2-27 shows the Help menu.

About

Balloon

Show

Balloons

Figure 2-27.

The

Help...

Help

menu

You can also use the Help Manager to implement Balloon Help for your application. See the
Help Manager chapter for more information and implementation details.

Keyboard

Equivalents

In the past, several keyboard equivalents were reserved by Apple for common commands.
Table 2-4 and Table 2-5 show the standard Macintosh keyboard equivalents.
2-34

Menus

User Interface Guidelines

Table

2-4.

Apple reserved keyboard equivalents for all systems

Menu

Keys

Command

Menu

Keys

Command

File

a6.-N

New

Edit

36 -Z,

Undo

File
File
File
File

a -W
a6 -S
36 -P
36-Q

File

d-O

Open...

Edit

Close
Save
Print...
Quit

Edit
Edit
Edit

a6 -X
a6 -C
a6-V
a6-A

Cut

Copy
Paste
Select All

Table 2-5 shows several keyboard equivalents that are reserved for use with worldwide
versions of system software, localized keyboards, and keyboard layouts. These keyboard
equivalents have actions that don’t correspond directly to menu commands, so there is no
menu column with command names in Table 2-5.
Table

2-5.

Additional reserved keyboard equivalents for worldwide systems

Keys

Action

#—Space bar
#—Option—Space bar

Rotate through enabled script systems
Rotate through keyboard layouts within a script

d—modifier key-Space bar

N

&

a
=

Apple reserved

=

See the section on keyboard equivalents in the Worldwide Software Overview chapter in this
volume for more discussion of handling keyboard equivalents in other script systems.
These key combinations are reserved across all applications. Even if your application doesn’t
support one of these menu commands, it shouldn’t use these keyboard equivalents for
another function. This guideline is for the user’s benefit. Reserving these key combinations
provides guaranteed, predictable behavior across all applications.
Creating a situation where Command-O means open 99 percent of the time and ostracize
| percent of the time would do two things. First, users wouldn’t consider using Command-O
for the latter function because it is used by all other applications to mean open. Second,
changing the meaning of Command-O in your application would weaken the user’s perception of the consistency of the interface.
Some applications use other common keyboard equivalents, as shown in Table 2-6.
These keyboard equivalents are secondary to the standard keyboard equivalents listed in
Table 2-4 and Table 2-5. If your product doesn’t support one of these functions, then use
these equivalents as you wish.
Table

2-6.

Other common keyboard equivalents

Menu

Keys

Command

Menu

Keys

Command

File
File
Style

36 -F
a -G
a6-T

Find
Find Again
Plain Text

Style
Style
Style

36-B
a6 -]
36-U

Bold
Italic
Underline
Menus

2-35

©
La)

Inside Macintosh,

Volume

VI

You shouldn’t assign keyboard equivalents for infrequently used menu commands. Doing so
only burdens your users and constrains your application. Only add keyboard equivalents for
the commands your users employ most frequently.

Pop-Up

Menus

In previous versions of system software, pop-up menus did not look sufficiently different
from other Macintosh interface elements. The |-pixel drop shadow that differentiated pop-up
menus from editable text boxes wasn’t a strong visual cue that indicated a menu existed. This
section presents the new standard appearance for pop-up menus that includes additional
graphical feedback. It also describes how the new appearance enables some uses that were
previously impossible.

Standard

Pop-Up

Menus

The new standard pop-up menu adds a downward-pointing triangle identical to the triangle
used to indicate that a menu is too long to fit on the screen and must scroll. All pop-up menus
should add this triangle. Figure 2-28 shows a simple pop-up menu in the new style.
<>Loma

Prieta

+

Figure 2-28. The appearance of a version 7.0 pop-up menu
When the user presses the mouse button while the pointer is over the pop-up menu or its label
text, the triangle disappears. When the mouse button is released, the triangle reappears.
Figure 2-29 shows this behavior.

Baud:|

Figure 2-29.

1200 ¥
3

300
600

Baud: “1200
2400

4800
9600

An open version 7.0 pop-up menu

See the Compatibility Guidelines chapter in this volume for information on implementing the
standard pop-up menu in your application.

Type-In

Pop-Up

Menus

Sometimes it is useful to display a list of choices but still allow the user to type in a choice
that the application didn’t know in advance. Keep in mind that users should be able to see
and point; they should never have to remember and type. The type-in option should be an
additional choice when appropriate, not a requirement. If the user types in an item that is
already in the menu, place a checkmark next to the menu item. The menu always highlights
the item that corresponds to the value in the text box. Your application also needs to highlight
the value in the text box. This behavior prevents a quick click in the menu from accidentally
2-36

Menus

User Interface Guidelines

wiping out the previous value. It also reinforces the idea that choosing a different value in
the menu changes the value in the text box. You don’t need to invert the menu’s label in
this situation. The new standard pop-up menu lends itself readily to this use, as shown in
Figure 2-30.

Size: [9 Ix]

Figure 2-30.

Size:

A type-in pop-up menu

If the value typed into the text box does not match any of the items in the pop-up menu,
the menu should add the type-in value as the first item and separate it from the rest of the
standard values by a gray line, as shown in Figure 2-31. This appearance makes a clean
distinction between common items that are always available and the typed-in value, which
is only temporary.

i)

&
NH

Size: [13 Ix]

@
“

Size:

—

~—s<

c
©

9)
10
12
14
18
at}

ss
OQ
@

Figure 2-31. A type-in pop-up menu with user’s choice added
See the Compatibility Guidelines chapter in this volume for more information about using the
new standard pop-up menu in your application.

MORE

USER

INTERFACE

INFORMATION

This chapter has presented the basic ideas you need to consider for supporting the new
interface features of version 7.0. You'll find more interface information about using the
new managers in the chapters that describe them. You can also get additional information
from the following sources:
w Human Interface Guidelines: The Apple Desktop Interface. Reading, Mass.: AddisonWesley, 1987.
w Apple Publications Style Guide. Apple Computer, Inc., 1990.
w

ResEdit Reference. Reading, Mass.: Addison-Wesley,

1991.

More User Interface Information

2-37

Inside Macintosh,

Volume

VI

a Apple Direct. This is a technical journal that presents various articles and a monthly
column on human interface design.
mw The AppleLink Developer Technical Services bulletin board. This bulletin board
maintains a Human Interface Discussion folder that presents Human Interface Notes
and provides answers for questions submitted by developers.

2-38

More User Interface Information

Go
NW
— OOnnrNAADDN
WN

COMPATIBILITY

GUIDELINES

About This Chapter
About Compatibility
Using Memory Wisely
Using Assembly Language
Accessing Hardware
Using Low-Memory Global Variables
Determining Whether a Trap Is Available
Running in System Software Version 7.0
Allowing Multiple Applications
Supporting Required Apple Events
Removing Font Size Restrictions
Operating With Virtual Memory
Enabling Menus During a Modal Dialog
Coexisting With the System Menus
Creating Movable Modal Dialog Boxes
Creating Pop-Up Menus
Manipulating Dialog Item Lists
Counting Items in a Dialog Item List
Appending Items to a Dialog Item List
Shortening a Dialog Item List
Localizing Macintosh Programs
General Guidelines
Localizing With the ‘Toolbox
Running Macintosh Programs Under A/UX
How the A/UX Toolbox Works
Using the A/UX Toolbox
A/UX Compatibility Guidelines
About the Gestalt Manager
Using the Gestalt Manager
Determining Features of the Operating Environment
Determining Whether Gestalt Is Available
Interpreting Gestalt Responses
Interpreting Responses to Environmental Selectors
Interpreting Responses to Informational Selectors
Adding Gestalt Selectors
Modifying Gestalt Selectors
Specifying Gestalt Selector Functions
Gestalt Manager Routines
Getting Information About the Operating Environment
Adding Selector Codes
Modifying Selector Codes
Summary of the Gestalt Manager
Summary of the Window Manager
Summary of the Control Manager
Summary of the Dialog Manager

os)

©
=|
~

i)
~

SS.

=F

=
te

@

=I

Q.

ot
=

@

a

3-1

Inside Macintosh,

3-2

Volume VI

Compatibility Guidelines

ABOUT

THIS

CHAPTER

This chapter describes how you can write applications that have the greatest chance of operating on any Macintosh® computer, regardless of its hardware components or available system
software, managers, and device drivers. It also addresses how you can take advantage of
features that are new to system software version 7.0 in ways that are least likely to cause
problems for users who are not running version 7.0. In a word, this chapter provides as much
advice as possible to help you achieve maximum compatibility for your applications on all
Macintosh computers, including those running version 7.0.
System software version 7.0 provides the most important test of software compatibility since
the introduction of the Macintosh I, and you must understand how you may need to revise
your current applications so that they operate correctly with this new system software.
Fortunately, if you have followed the guidelines given in previous volumes of /nside
Macintosh, your applications stand a very good chance of working correctly in version 7.0
without any modification whatsoever. However, version 7.0 introduces many new features
and capabilities that you may wish to use in your applications. This chapter provides a
number of additional guidelines to help you take advantage of those features while retaining
compatibility with previous system software.
This chapter discusses several aspects of writing software that is compatible with all
Macintosh computers:

Fs)
OQ

°
=
S
rR

what can cause compatibility problems and how in general to avoid those problems

how to update your application to take maximum advantage of new features of system
software version 7.0

=A

c.
=
‘S

how to write software that can be easily modified for use in other regions

?)

how to write applications that execute under A/UX®, Apple Computer, Inc.’s version of

the UNIX® operating system

=A
2
Cc.
=

c

i? 2)

how to determine what software and hardware features are available on a particular
machine
The discussion of revising applications to take advantage of the new capabilities of system
software version 7.0 also includes details about several new features of the Dialog and Menu
Managers, including
the new pop-up menu control definition
m the system menus
=m movable modal dialog boxes
= new Dialog Manager routines to count and manipulate items in dialog boxes

About This Chapter

3-3

Inside Macintosh,

Volume VI

This chapter also describes the Gestalt Manager, a set of three new Operating System functions that provide applications with a simple and efficient method for determining what
software and hardware features are available on a given machine. You need to use the Gestalt
Manager if your application takes advantage of particular hardware components (such as a

floating-point unit) or software modules (such as Color QuickDraw™) that are not available

on all Macintosh computers. Your software can also use the Gestalt Manager to inform the
Operating System (and hence other applications) that it is present in the current environment.
The Gestalt Manager is available in system software versions 6.0.4 and later. Your development system may supply code that allows you to call Gestalt on earlier system software
versions; check the documentation provided with your development system to see if this is
possible. Of course, because you cannot use Gestalt to determine if the Gestalt Manager

itself is present, you must do that in some other way; one such method is illustrated in
“Determining Whether Gestalt Is Available” later in this chapter.

You need to read this chapter if you are interested in writing applications that execute on as
many Macintosh computers as possible or under alternate operating systems such as A/UX.
In particular, if you wish to enhance an existing product so that it supports new features of
system software version 7.0 but also executes correctly in earlier versions of system software, or if you wish to write a new product that executes only in version 7.0, you should
look at “Running in System Software Version 7.0” later in this chapter. Read the sections on
the Gestalt Manager later in this chapter if you need to take advantage of specific software or
hardware features that may not be present on all versions of the Macintosh, or if you wish to
inform other applications of the presence of your application in the operating environment.
If you want your applications to run in system software versions earlier than 6.0.4 (where the
Gestalt function is not available), you should be familiar with the Environs procedure,
discussed in the Operating System Utilities chapters of Volumes II and IV, and the
SysEnvirons function, discussed in the Compatibility Guidelines chapter of Volume V. Both
Environs and SysEnvirons perform the kind of function that Gestalt performs—they allow you
to determine what features are available on a specific machine. For reasons outlined later,
however, you should not use either of these routines if the Gestalt function is available.
Unfortunately, no single chapter can provide all the information you need to achieve the
greatest possible compatibility for your applications. Most of the subsequent chapters in this
volume (and indeed all previous volumes of /nside Macintosh) contain numerous warnings

and guidelines that you should heed if you wish to increase the likelihood that your applications will execute correctly on all members of the Macintosh family and under alternate
operating systems such as A/UX. The Memory Management chapter in this volume, for
example, contains a fuller account of 32-bit clean programming than is given here and is
essential reading for all developers.
The Worldwide Software Overview chapter in this volume gives complete details on the
Script Manager, which can help you write applications that are compatible worldwide.
Similarly, the guidelines given in this chapter on writing A/UX-compatible Macintosh
programs summarize and complement, but do not replace, the discussion in the separate
publication A/UX Toolbox: Macintosh ROM Interface. So the complete story on Macintosh
software compatibility does not end with this chapter, but it does begin here.

3-4

About This Chapter

Compatibility Guidelines

ABOUT

COMPATIBILITY

Compatibility is the ability of a program to execute properly in different operating environments. Compatibility is important if you want to write software that runs, with little or no
modification, on all members of the Macintosh family and in all system software versions.
If you want to take advantage of particular software or hardware features that may not be
present on all Macintosh computers, you need to know how to determine when those features
are available.
To appreciate why compatibility is a real concern, imagine that from all the Macintosh computers currently in operation in the world, you were to choose two at random. You would
quite likely find a number of differences in the hardware and software configurations of those
two machines. You might find different CPUs, different memory management units (MMUs),
different amounts of RAM, different shapes and sizes of monitors, and so forth. You are
also likely to find different versions of system software, different ROM versions, different
AppleTalk® drivers, different versions of managers, different printer interfaces, and so forth.
Ideally, you want your product to run on both of those machines, regardless of the many
significant differences between them. If you succeed in writing your application so that it does
operate on both of those machines, you have succeeded in writing compatible software.
Fortunately, it is possible to write software that is compatible across the entire Macintosh line
of computers. This section provides a number of guidelines that you should follow if you
want your applications to run on the greatest number of Macintosh computers. Some of these
guidelines are quite general and apply to all programs; some apply only if you are
programming in assembly language.

oe)
-Q
°
=
‘)
—

—

One key to achieving compatibility is not to depend on things that may change. /nside
Macintosh contains numerous warnings about which information is likely to change. As
the Operating System and User Interface Toolbox evolve to accommodate the needs of
developers and users, many of their elements will vary. Whenever possible, Apple strives
to add features without altering existing interfaces. In general, you can assume that Operating
System and Toolbox routines are less likely to change than data structures. Therefore, you
should never directly manipulate data structures that are internal to a manager or system
software routine, even if their structure is documented. Instead, you should manipulate those
structures only indirectly, by calling Operating System and Toolbox routines that achieve the
desired effect. In particular, you should never alter any portion of a data structure marked as
unused or reserved.
Another key to writing compatible code is to code defensively. Do not assume that users
perform actions in a particular order, and do not assume that function and procedure calls
always succeed. You should always test the return values of routines for errors, as illustrated
in most of the code samples presented in this volume.

About Compatibility

3-5

S.

S,

~

oo
Q

=h
a
©.

="

@

i? 7)

Inside Macintosh,

Using

Volume VI

Memory

Wisely

A major cause of compatibility problems, especially in connection with applications running
in the A/UX operating system, is misuse of the Memory Manager. Here are some important
points to keep in mind:
= Do not set or clear bits in master pointers directly. Use Memory Manager traps (for
example, HLock) instead.
m Always check the handle or pointer returned by a routine to make certain that it is not
NIL. A NIL handle may indicate that a memory allocation failed or that a requested
resource could not be found.
m Always check that a handle marked as purgeable has not been purged before using that
handle. You can check for a purged handle like this:
IF

myHandle®

<>

NIL

THEN

{handle

not

purged}

m Do not create your own handles; instead, use the Memory Manager function
NewHandle.
a Never make assumptions about the contents of Memory Manager data structures.
If you have followed all these guidelines, it is likely that your application is 32-bit clean; that
is, it operates correctly in an environment where all 32 bits of handles and pointers are used
to store memory addresses. When running with 32-bit addressing in system software
version 7.0 and A/UX, your applications must be 32-bit clean or they may not operate
correctly. See the Memory Management chapter in this volume for more information about
these issues.

Using

Assembly

Language

In general, your software should not include 68000 instructions that require the processor
to be in supervisor mode; these include instructions that modify the contents of the Status
Register (SR). Do not modify the SR as a means of changing the Condition Code Register

(CCR) half of the SR; instead, use an instruction that addresses the CCR directly. Do not use

the User Stack Pointer or turn interrupts on and off.

If you wish to handle your own exceptions (thereby relying on the position of data in
the exception’s local stack frame), be aware that exception stack frames vary within the
68000 family.
In particular, don’t use the TRAP instruction. Also, the Macintosh SE and Macintosh II
hardware does not support the TAS instruction, which uses a special read-modify-write
memory cycle.
Some Macintosh computers use memory protection and may prevent code from writing to
addresses within code segments. Also, the 68020 and 68030 cache code as it is encountered.
You should allocate data blocks on the stack or in heap blocks separate from the code, and
your code should not modify itself.

3-6

About Compatibility

Compatibility Guidelines

Accessing

Hardware

You should never address hardware directly; whenever possible, use the routines provided
by the various device drivers and managers to send data to the available hardware. The
addresses of memory-mapped hardware (like the VIA1, VIA2, SCC, and so forth) are
always subject to change, as is the hardware itself. More important, direct access to such
hardware is not possible in every operating environment. In multi-user systems like A/UX,
for instance, the operating system manipulates all hardware; applications simply cannot write
directly to hardware addresses.
You should also avoid writing directly to the screen. Use QuickDraw routines whenever
possible to draw on the screen. If you absolutely must write directly to the screen, do not
assume that the screen is a fixed size or that it is in a fixed location. The location, size, and bit
depth of the screen differ in various machines. On machines without Color QuickDraw, you
can use the QuickDraw global variables screenBits.bounds to determine the size of the main

screen, screenBits.baseAddr to determine the start of the main screen, and screenBits.rowBytes
to determine the offset between rows. On machines with Color QuickDraw, the device list

(described in the Graphics Devices chapter in this volume) tells the location, size, and bit depth

of each screen; screenBits contains the location and size of the main device; and the global

variable GrayRgn contains a region describing the shape and size of the desktop.

Variables

a

Don’t rely on low-memory global variables. Many of these variables have been previously
documented in /nside Macintosh, but many have not. In particular, you must avoid undocumented low-memory global variables because they are most likely to change. But you should
try to avoid even well-known global variables because they may not be available in all environments or in the future. In general, you can avoid using low-memory global variables by
using available routines that return the same information. (For example, the TickCount
function returns the same value that is contained in the low-memory global variable Ticks.)

Determining

Whether

a Trap

Is Available

One important way that the Operating System and Toolbox have changed through successive
versions of the ROM and system software is by the addition of numerous new traps. For
example, the Time Manager released with system software version 7.0 includes a new trap,
InsXTime, that provides certain improvements over the existing trap, InsTime. By using
InsXTime instead of InsTime, your application can ensure that the periodic actions it requests
execute at a fixed frequency that does not drift over time. Before using a trap that is not
available on all machines, however, you need to determine whether it is available; if you call
InsXTime on a machine that does not implement it, your program will crash.
There are several ways your application can check the availability of a particular trap. First,
you can call the Gestalt function that is discussed later in this chapter to see if the appropriate
version of the corresponding driver or manager is available. For example, the trap InsX Time
is included in the extended Time Manager but not in earlier versions of the Time Manager. So
you could use Gestalt to determine which version of the Time Manager is available in the
current operating environment. If Gestalt reports that the extended Time Manager is present,
you can safely call InsXTime to queue your request.

About Compatibility

3-7

OQ

S
=
Ss
=

=.

S.
=:
S
~~

x

Global

x

Low-Memory

souljepimn

Using

Inside Macintosh,

Volume VI

There are several cases, however, in which you cannot use Gestalt to determine whether

a specific trap is implemented. You cannot, for instance, use Gestalt to determine whether the
Gestalt trap itself is available. In addition, the trap whose existence you wish to test might not

be included in any manager or, if it is, there might not be a Gestalt selector code for that

manager. The WaitNextEvent trap is a good example of this: there is no way, using Gestalt,
to determine whether WaitNextEvent is available.
A second way to determine the availability of a particular Operating System or Toolbox trap is
by testing directly for the existence of the trap, using the technique illustrated in Listing 3-1.
You should use this method to test whether Gestalt is available before calling Gestalt. You
should also use it to test for the existence of traps not included in managers or drivers about
which Gestalt can report. This listing illustrates how to test the availability of WaitNextEvent.
Listing 3-1. Determining whether a trap is available
FUNCTION

NumToolboxTraps:

Integer;

BEGIN

IF

NGetTrapAddress(_InitGraf,
ToolTrap)
=
NGetTrapAddress ($AA6E,
ToolTrap)
NumToolboxTraps
:= $200

THEN

ELSE

NumToolboxTraps

:=

$400;

END;
FUNCTION GetTrapType
(theTrap:
CONST
TrapMask
= $0800;
BEGIN
IF BAND(theTrap,TrapMask)
>
GetTrapType
:= ToolTrap
ELSE
GetTrapType
:= OSTrap;
END;

FUNCTION

TrapAvailable

(theTrap:

Integer)

0

:

TrapType;

THEN

Integer)

:

Boolean;

VAR
tType:
TrapType;
BEGIN
tType
:= GetTrapType(theTrap) ;
IF tType
= ToolTrap THEN
BEGIN
theTrap
:= BAND(theTrap,
S$O7FF);
IF theTrap
>= NumToolboxTraps
THEN

theTrap

:=

_Unimplemented;

END;

TrapAvailable
:= NGetTrapAddress(theTrap,
NGet TrapAddress (_Unimplemented,

tType)
<>
ToolTrap) ;

END;

FUNCTION

WNEAvailable:

Boolean;

CONST

_WaitNextEvent

=

S$A860;

{trap

number

of

WaitNextEvent}

BEGIN

WNEAvailable

:=

TrapAvailable(_WaitNextEvent) ;

END;

3-8

About Compatibility

Compatibility Guidelines

The NumToolboxTraps function relies on the fact that the InitGraf trap (trap number $A86E)
is always implemented. If the trap dispatch table is large enough (that is, has more than $200
entries), then $AA6E always points to either Unimplemented or something else, but never to
InitGraf. As a result, you can check the size of the trap dispatch table by checking to see if the

address of trap $A86E is the same as $AAGE.

After receiving the information about the size of the dispatch table, the TrapAvailable function
first checks to see if the trap to be tested has a trap number greater than the total number of
traps available on the machine. If so, it sets the theTrap variable to Unimplemented before
testing it against the Unimplemented trap.
Note: The technique presented in Listing 3-1 for determining whether a particular
trap is available differs from techniques formerly supported by Apple. The previous
method determined the size of the trap dispatch table by checking the machine type.
This type of check should not be used for any purposes other than simply displaying
the information, as explained in “Using the Gestalt Manager” later in this chapter.

RUNNING

IN SYSTEM

SOFTWARE

VERSION

7.0

The guidelines given in the previous sections apply to all Macintosh applications, regardless
of the version of system software available. If you heed those guidelines, you are likely to
produce applications that run reasonably well in all environments, including system software
version 7.0. Those guidelines define a minimal level of conformance necessary for your
applications to run in version 7.0. Applications that conform to the programming interfaces
documented in /nside Macintosh and violate none of the guidelines presented earlier in this
chapter are called 7.0-compatible because they run in version 7.0 without problems.
An application can be 7.0-compatible, however, without taking advantage of the many new
features available in system software version 7.0 and without exhibiting an awareness that
other applications may be present and may wish to use processor time that would otherwise
go unused. Among applications that do take advantage of new features, there are at least two
levels of involvement with version 7.0.
An application is 7.0-friendly if it takes advantage of some of the special features of
version 7.0 when executing in that environment, but is still able to perform all its principal
functions when executing in version 6.0. An application is 7.0-dependent if it requires the
existence of features that are available only in version 7.0; it might not even run in version
6.0. Even if 7.0-dependent applications do execute in version 6.0, they are virtually
guaranteed to offer far fewer features there than in version 7.0.
The situation is similar to deciding whether your applications should use Color QuickDraw.
If you revise existing black-and-white drawing programs to incorporate color, your applications operate either with or without Color QuickDraw. If you introduce new applications that
require Color QuickDraw, they simply won’t run on machines that don’t support color.

Running in System Software Version 7.0

3-9

o)
(

)

4

—

=

a

—

_

po)

=

meme

a
pas
—_

a

~s

al

a

wa

-~
—

=e

ll

—_—

i)

—

nee

~
@

2)

Inside Macintosh,

Volume VI

The rest of this section gives guidelines on what you can do to existing applications to make
them 7.0-friendly and not simply 7.0-compatible. The following pages describe in overview
how to
m be aware that the user may have launched multiple applications
m support the required set of required Apple® events

m remove font size restrictions to support outline fonts
m

make sure that your application operates correctly with virtual memory

Each of these items is discussed more completely elsewhere in this volume. For example, to
learn what you need to do to support outline fonts in your application, see the Font Manager
chapter. For information about cooperating with other open applications, see the Event
Manager chapter and the Process Management chapter.
This section also discusses features of system software version 7.0 that simplify the creation
and manipulation of several new or existing user-interface elements. These new capabilities
allow you to
m get user menu selections while a modal dialog box is displayed
m coexist with system menus
m create movable modal dialog boxes
m create pop-up menus
= count and manipulate items in dialog boxes
Most of these features are not available on system software versions earlier than 7.0. The
routines that allow you to count the number of items in a dialog item list and add or remove
items from a dialog box have previously been available as part of the Communications
Toolbox. You can determine whether those routines are available by using the Gestalt function to test for the Dialog Manager extensions. You can use the gestaltPopupAttr selector
with Gestalt to determine if the new pop-up control definition function is available.
Note: The four Dialog Manager procedures CouldDialog, CouldAlert, FreeDialog,
and FreeAlert are no longer supported.

Allowing

Multiple Applications

System software version 7.0 continues the development of the Macintosh Operating System
into a multitasking environment in which multiple applications can be active and must share
the available system resources. The facilities provided with earlier versions of system
software by the optional MultiFinder® package are now an integral part of system software
version 7.0. This means that your application must display a certain awareness that other
applications might be open at the same time and competing with it for processing time,
memory, control of communications ports, and so forth.

Although most operating systems regulate the sharing of available resources by having the
system parcel them out, the Macintosh Operating System relies on the willingness of fore3-10

Running in System Software Version 7.0

Compatibility Guidelines

ground and background applications to share those resources among themselves. For example,
you can indicate your application’s memory requirements by specifying a minimum memory
partition size (below which that application does not execute) and a preferred partition size (at
which the application executes best). The Operating System itself has very little control over
the partition size allotted to your application, other than by limiting that size to the available
memory. Similarly, the Operating System has very little control over which applications
receive processing time because the user ultimately decides when to bring a background application into the foreground. If your application holds onto the microprocessor for too long
while being switched into the background, other applications may appear sluggish and
unresponsive.
The lesson to be learned from all this is that in system software version 7.0 your application
must be a good neighbor. You cannot expect the Operating System to force responsible
behavior on your application; rather, you must ensure that your application can happily
coexist with other open applications by following these guidelines:
Include a'SIZE' resource (with resource ID —1) that specifies reasonable minimum and

preferred memory partition sizes; if you occasionally need larger amounts of memory,
use the temporary memory routines described in the Memory Management chapter in
this volume.

a Modify your main event loop to process suspend and resume events; this reduces the
time it takes to switch your application into the foreground or background.
For a more complete discussion of using WaitNextEvent and processing suspend and resume
events, see the Event Manager chapter in this volume. That chapter also includes a description
of the multitasking environment that is standard in system software version 7.0.

WoD

¢

m Use the WaitNextEvent function instead of the GetNextEvent function in your main
event loop to obtain events from the Toolbox Event Manager; this allows other
applications to use processor time your application doesn’t need and allows your
application to perform operations while it is in the background.

4
&

=
—

—_

ed

ume

—r
—

a

<

ad

mw

ao

= 4

=)

ue

.
©

—

Supporting

Required

Apple

—r
~
oO
i? 2)

Events

—

Possibly the most significant new feature in system software version 7.0 is interapplication
communication (IAC), which will play an increasingly important role in future versions of
the Macintosh Operating System. One central part of IAC is the addition of high-level events
to those events that the Event Manager receives and conveys to applications. High-level
events allow applications to communicate with one another by putting events in each other’s
event queues.
Apple Computer, Inc. has defined a protocol for high-level events called the Apple Event
Interprocess Messaging Protocol. High-level events that adhere to this protocol are called
Apple events. Some Apple events must be supported by an application that supports any
Apple events; these are known as required Apple events. With a minimal amount of work,
you can modify your main event loop so it supports the required Apple events. In doing so,
you increase the level of compatibility of your application and ease the transition to the day
when applications will expect other applications to support Apple events.
For information on how to support the required Apple events, see the Apple Event Manager
chapter in this volume.
Running in System Software Version 7.0

3-11

Inside Macintosh,

Removing

Volume VI

Font Size

Restrictions

System software version 7.0 introduces outline fonts, known as TrueType™ fonts. An
outline font can be printed or displayed at any point size without the jagged appearance of
some bitmapped fonts. A 7.0-friendly application should allow its users to take advantage of
this improvement. Minimally, this means that users should be able to ask for any point size
up to 32,768. Many applications now let users specify font sizes up to 127 points, but you
should remove even this limitation when running in version 7.0. In addition, your application
should allow users to increase or decrease the font size by | point.
You can use the IsOutline routine, documented in the Font Manager chapter in this volume, to
see if a particular font is an outline font. If it is, you might wish to indicate that fact in your
font size menu. For example, suppose that your Size menu for a particular bitmapped font
looks like the one in Figure 3-1.

® Point
10
Y12
14
18
24
Other...

Figure 3-1. The size menu for a bitmapped font
To provide a visual indication that the selected font is an outline font that looks good at any
size, you might change the menu to look like the one in Figure 3-2. One way to do this is
by outlining all listed sizes, as well as the Other item.

© Point
10

v12

14

18
a4

Owner

aa

Figure 3-2. The size menu for an outline font
The User Interface Guidelines chapter in this volume contains additional suggestions on
incorporating outline fonts into your application.

3-12

Running in System Software Version 7.0

Compatibility Guidelines

Operating

With

Virtual

Memory

System software version 7.0 supports virtual memory, a memory management scheme that
extends the logical address space of the machine by using part of the available secondary
storage (usually, a hard disk) to store parts of memory that are not currently in use. When
virtual memory is present, the perceived amount of RAM can extend up to 14 megabytes on
systems with 24-bit ROMs and up to 4 gigabytes on systems with 32-bit clean ROMs.
Because the Operating System has more addressable memory, your applications can ask for
and receive larger blocks of memory than they would if virtual memory were not available.
Virtual memory is available only on machines equipped with a memory management unit
(MMU). Currently, these machines include 68030-based machines (where the MMU is built
into the CPU) as well as 68020-based machines that contain the 68851 Paged Memory
Management Unit. You can use the Gestalt function to determine whether virtual memory is
installed. If it is, you may need to exercise caution to ensure that the normally invisible
operation of virtual memory does not adversely affect the execution of your application.
Applications that might need to be concerned with virtual memory include those that have
critical timing requirements, execute code at interrupt time, or perform debugging operations.
Note: The vast majority of applications do not need to know whether virtual
memory is installed.
One type of application that might need to know if virtual memory is operating is a multimedia application that manages very large images or incorporates many sounds into its
presentations. Imagine that such an application wants to display a large number of intricate
color images in rapid succession, and that some of those images are as large as a megabyte
each. If virtual memory is operating, it 1s very likely that parts of those images are on disk
when they need to be displayed. This means that in the middle of drawing a picture, the
system has to stop long enough to read those parts of the picture off the disk. The result is
that a noticeable delay may occur, which may be unacceptable.

Menus

During

a Modal

=

"S
m

=.

S:
=

<

~

wt i

=e
&=
@®

wn

Dialog

The Dialog Manager in system software version 7.0 has been modified to make it easier for
your application to allow access to the menu bar during a modal dialog. Sometimes it is
useful (or even necessary) for users to be able to make menu selections while your
application is displaying a modal dialog box. For example, a user might want to turn on
Balloon Help during a modal dialog. Similarly, if the modal dialog box contains several
editable text fields, the user might find it simpler to copy text from one text field and paste
it into another.

Running in System Software Version 7.0

2

Q.

In a case like this, you can use routines that lock the appropriate data into RAM so that
displaying the image requires no disk access. These routines are fully documented in the
Memory Management chapter later in this volume. Other software that may need to know
about those routines includes drivers, interrupt code, and debugging applications.

Enabling

o)

3-13

Inside Macintosh,

Volume VI

In previous system software versions, user access to menus in the menu bar was prohibited
during a modal dialog unless your application specifically allowed it. Moreover, keyboard
equivalents of the standard Edit menu commands did not operate correctly in a modal dialog
box unless your application provided a filter procedure to replace the standard filter procedure.
In system software version 7.0, the user can access selected menus in the menu bar during a
modal dialog. When your application displays a modal dialog window (of type dBoxProc),
these actions occur:
1. All menu items in the Help menu are disabled, except the Show Balloons (or Hide
Balloons) command, which is enabled.

2. All menu items in the Application menu are disabled.
3. If the Keyboard menu appears in the menu bar (that is, if there is more than one script
system installed in the system or if the smfShowlcon bit is set in the Script Manager
flags long word), that menu is enabled, but the About Keyboards command is disabled.
In addition, if your application then calls the ModalDialog procedure, several other
actions occur:

4. All your application’s menus are disabled.
5. If the modal dialog box contains a visible and active editable text field and if the menu
bar contains a menu having commands with the standard keyboard equivalents

Command-X, Command-C, and Command-V, then those three commands are enabled.

The user can then use either the menu commands or their keyboard equivalents to cut,
copy, and paste text. (The menu item having keyboard equivalent Command-X must be
one of the first five menu items.)

When the user dismisses the dialog box, all menus are restored to the state they were in prior
to the appearance of the dialog box.
There are some cases in which actions 4 and 5 do not occur when you call ModalDialog.
The enabling and disabling described in steps 4 and 5 does not occur if any of these
conditions happen:
m Your application does not have an Apple menu.
m Your application has an Apple menu, but the menu is disabled when the dialog box
is displayed.
m Your application has an Apple menu, but the first item in that menu is disabled when
the dialog box is displayed.
Note: If your application already handles access to the menu bar during a modal
dialog and you do not want the automatic menu enabling and disabling provided by
system software version 7.0 to occur, you should ensure that one or more of those

conditions is true when you display a modal dialog box.

3-14

Running in System Software Version 7.0

Compatibility Guidelines

Coexisting

With the System

Menus

In system software version 7.0, the menu bar may contain as many as four system menus,
which are menus that provide access to system features such as application switching,
Balloon Help, and keyboard scripts. The four system menus are the Apple menu, the
Application menu, the Help menu, and the Keyboard menu. All four of these menus have
icons as titles. The Apple menu icon is located in its usual location at the left side of the
menu bar, but the three other menu icons are positioned at the right side of the menu bar.
The system menu icons are drawn automatically in the menu bar of any application that
supports an Apple menu and that uses the default system menu bar definition procedure
(that is, resource of type 'MBDF' having ID 0). The Application menu icon is always
drawn. The Help menu icon is drawn if space is available, and the Keyboard menu icon
is drawn if space is available and if more than one script system is available in the system.
Both the Help menu icon and the Keyboard menu icon disappear from the menu bar if your
application installs a menu whose title has a right side that extends into the space occupied
by one or both of those icons. This allows your application to reclaim any space in the
menu bar that would have been occupied by one or both of those two menu icons, if
necessary. However, the Application menu icon is always displayed in the menu bar. If
your application installs a menu whose title is long enough to overlap space occupied by
the Application menu icon, the overlapping portion of that title is placed behind the
Application menu icon.
The system menus are installed into your application’s menu list, so you should not make
any assumptions about the last item (or items) in your menu list. Your application receives
notice of mouse-down events in the menu bar, even when those events concern system
menus. You can still call MenuSelect in response to a mouse-down event in the menu bar,

however, because MenuSelect returns either 0 in the high word when the Apple, Application,
or Keyboard menu is selected, or the HelpMgrID constant when the Help menu is selected.

Fe)
OQ
S
=}
a=)
f
=

g,

=
t
oP

=

Creating

Movable

Modal

Dialog

3
2)
=

Boxes

is")
~”

The Window Manager in system software version 7.0 allows you to create a new type of
window, called a movable modal dialog box, by specifying the following constant as the
window definition ID when you call NewWindow:
CONST

movableDBoxProc

=

§&%

{movable

modal

dialog

box}

The User Interface Guidelines chapter in this volume contains illustrations of movable modal
dialog boxes and recommendations for their use. Note carefully that it is your application’s
responsibility to ensure that any movable modal dialog boxes you create display the behavior
described there. In particular, you must provide the code that prevents the user from bringing
another window in your application forward while a movable modal dialog box is displayed.
Note: The term movable modal dialog box is likely to cause confusion because
windows you create with the movableDBoxProc window definition ID cannot, in
general, be manipulated like other (nonmovable) modal dialog boxes. For example,
you should not call the ModalDialog procedure when the frontmost window is a
movable modal dialog box.
Running in System Software Version 7.0

3-15

Inside Macintosh,

Creating

Volume VI

Pop-Up

Menus

The Control Manager in system software version 7.0 makes it much easier for you to create
pop-up menus. Pop-up menus provide the user with a simple way to select from among a list
of choices without having to move up to the menu bar. They are particularly useful in a dialog
box that requires the user to specify a number of settings or values. Figure 3-3 shows a popup menu in both its inactive and active states.
Inactive state

Active state

Baud Rate: | 300 EA

u

|

fhe

Pop-up title

,

F

600

Pop-up box

1200

2400
4800
9600

Figure 3-3. A pop-up menu in its inactive and active states
Prior to system software version 7.0 (or on earlier systems running without the
Communications Toolbox installed), the easiest way to create pop-up menus was to create the
pop-up title as a staticText item in a dialog item list and the pop-up box as a user item. Your
application then needed to draw a box around that user item, draw the drop shadow, and
insert text into the box. Then you could call the PopUpMenuSelect function to draw the popup menu and track the cursor within the menu, making sure to invert the pop-up title while
the menu is active (to duplicate the behavior of menu titles in the menu bar).
The Control Manager in system software version 7.0 allows you to create a pop-up menu as
a new type of control by using the following constant when you call NewControl:
CONST

popupMenuCDEFProc

=

1008;

{pop-up

menu}

If you specify popupMenuCDEFProc (plus any appropriate variation code) as the procID
parameter in NewControl (or specify it as the procID of a control that you open with
GetNewControl), the Control Manager creates a pop-up menu control, which includes
the pop-up title and the pop-up box with a one-pixel drop shadow. The appearance of the
pop-up title and the values in the menu are controlled by other parameters passed to
NewControl (or stored in a resource), as described later in this chapter.

In system software version 7.0, the control definition function specified by the constant
popupMenuCDEFProc also draws the downward-pointing triangle in the pop-up menu. Note
that the triangle is not drawn automatically in earlier system software versions.
To create a pop-up menu, call NewControl and specify popupMenuCDEFProc (plus any
appropriate variation code) as the procID parameter.
3-16

Running in System Software Version 7.0

Compatibility Guidelines

FUNCTION

NewControl

(theWindow:
WindowPtr;
boundsRect:
title:
Str255;
visible:
Boolean;
min:

Integer;

refCon:

max:

LongInt)

Integer;
:

Rect;
value:

procID:

Integer;

Integer;

ControlHandle;

The value, min, and max parameters behave differently with pop-up menus than with other
controls created with NewControl. You can specify constants listed below to control the
appearance and location of text in the control. If NewControl returns successfully (that is, if
the returned ControlHandle is not NIL), the control minimum and maximum values contain

information about the new pop-up menu, as described later in this section. In addition,
NewControl may modify the boundsRect parameter to reflect the actual width of the pop-up
menu box that is created.
When you call NewControl, the value parameter specifies the manner in which the title of the
pop-up menu is to be aligned and drawn. The value parameter should be some combination
of the following constants:
CONST

popupTitleLeftJust

=

$0000;

{left

alignment}

popupTitleCenterJust

=

$0001;

{center

popupTitleRightJust

=

SOOFF;

{right

popupTitleBold
popupTitleitalic
popupTitleUnderline
popupTitleOutline
popupTitleShadow

=
=
=
=
=

$0100;
$0200;
$0400;
$0800;
$1000;

{bold text}
{italic
text}
{underlined
tex}
{outlined
text}
{shadow
text}

popupTitleCondense

=

$2000;

{condensed

popupTitleExtend

=

$4000;

{extended

text}

popupTitleNoStyle

=

$8000;

{unstyled

text}

alignment}
alignment}

wn

OQ
S

=~
"o

text}

su

_
Leaded

3.
=

<<

?)

Figure 3-4 illustrates the appearance of the pop-up control if you pass the popupTitleRightJust
constant. Note that the position of the pop-up box and the pop-up title are reversed from their
default (left-aligned) positions.

300,
600
1200
2400
4800
9600

Baud Rate:

Figure 3-4. A pop-up control that is right-aligned
You can also pass a sum of constants in the value parameter to draw the pop-up title with
more than one of these characteristics. If NewControl completes successfully, the value
parameter contains the current minimum value of the menu. Your application can then use
the value of the control to determine the currently selected item.
Running in System Software Version 7.0

3-17

=hale
=

©.
=

9°)
2)

Inside Macintosh, Volume VI

The min parameter specifies the resource ID of the menu in the pop-up control when the
control is being created. After the control has been created, the pop-up menu control
definition sets the minimum value of the control to 1.
The max parameter specifies the width of the pop-up title area when the control is being
created. After the control has been created, the pop-up menu control definition sets the
maximum value of the control to the number of items in the pop-up menu.
The procID parameter should contain the value popupMenuCDEFProc plus any desired
variation code. Currently recognized variation codes are defined by constants:
CONST

popupFixedWidth

=

$0001;

{use

fixed-width

control}

popupUseAddResMenu
popupUseWFont

=
=

$0004;
$0008;

{use
{use

resource
for
window
font}

menu}

Constant

Description

popupFixedWidth

Uses a constant control width. If your application specifies this
value, the pop-up menu control definition function does not
resize the control horizontally to fit long menu items. The width
of the pop-up box is set to the width of the control, minus the
width of the pop-up title your application specifies when it
creates the control. If the contents of the pop-up box do not fit
into the space provided, the text is truncated to fit and ellipses
(...) are appended to its end. If you do not specify this variation
code, the contents of the pop-up box are guaranteed to fit
because the pop-up menu control definition function resizes
the control horizontally (up to the size of the control’s bounding
rectangle).

popupUseAddResMenu

Gets menu items from a resource. If your application specifies
this value, the pop-up menu control definition function
interprets the refCon parameter passed to NewControl as a
value of type ResType that specifies the resource type to load
into the menu (using the AddResMenu procedure).

popupUseW Font

Uses the font of the specified window. If your application
specifies this value, the pop-up menu control definition
function draws the pop-up menu title using the font and size
of the grafPort that owns the control. In addition, the pop-up
menu, when active, is to use the font and size of that grafPort
instead of the standard system font.

The refCon parameter is a long integer that is available for your application’s use. However,
if you specify popupUseAddResMenu as a variation code, the value in the refCon parameter
is typecast to the type ResType and is used by AddResMenu to add items to the pop-up
menu. For example, if the value in the refCon parameter is LongInt('FONT'’), the pop-up
menu control definition function appends a list of the fonts installed in the system to the menu

3-18

Running in System Software Version 7.0

Compatibility Guidelines

associated with the pop-up menu control. After the control has been created, your application
can use the control handle’s refCon field for whatever use it requires. You can determine
which menu item is currently selected by calling GetCtl Value.
Whenever the pop-up control is redrawn, the control definition function calls the CaleMenuSize
procedure. This procedure recalculates the size of the menu associated with the control (to
allow for the addition or deletion of items in the menu). The control definition function may
also update the width of the pop-up menu control to the sum of the width of the pop-up title,
the width of the longest item in the menu, the width of the downward arrow, and a small
amount of white space. As previously described, your application can override this behavior
by using the variation code popupFixedWidth.
You can obtain the menu handle and the menu ID of the menu associated with the pop-up
control by dereferencing the contrlData field of the control record. The contrlData field is a
handle to a block of private information. For pop-up menu controls, this field is a handle to
a popupPrivateData structure:
TYPE

popupPrivateData

=

RECORD
mHandle:

MenuHandle;

{handle

mID:

Integer;

{menu

mPrivate:

ARRAY[0..0]

OF

SignedByte

to

menu}

ID}

{reserved}

END;

Ue

The mHandle field contains a handle to the menu. The mID field is the ID of the menu. The
mPrivate field is reserved.

>
—
ne
—_

4

—

as
~

_

a
_

Manipulating

Dialog

Item

~

ie
—

Lists

—_

A

The Dialog Manager in system software version 7.0 includes several new routines that
make it easier for you to manipulate dialog item lists. You can count the number of items
in a dialog list by using the CountDITL function. You can add items to an item list by using
the AppendDITL procedure and remove items from the end of an item list by calling the
ShortenDITL procedure.
These Dialog Manager extensions are available in system software version 7.0 and also on
any earlier system that has the Communications Toolbox installed. Before calling these
routines, you should make sure that they are available by calling the Gestalt function with
the gestaltDITLExtAttr selector.

Counting

Items

in a Dialog

Item

List

You can call the CountDITL function to count the items in a dialog item list.
FUNCTION

CountDITL

(theDialog:

DialogPtr)

:

Integer;

CountDITL returns the number of items in the dialog item list associated with the dialog box
pointed to by the parameter theDialog.

Running in System Software Version 7.0

3-19

Pp)

=—T

(=n)

—

a7)
—

Try
_
—_

is)
2)

Inside Macintosh,

Appending

Volume VI

Items to a Dialog

Item

List

You can call the AppendDITL procedure to append items to the end of a dialog item list.
PROCEDURE

AppendDITL

(theDialog:

DialogPtr;

theDITL:

Handle;

method:

DITLMethod) ;

The parameter theDialog specifies the dialog box to whose item list you want to append
items. The parameter theDITT. is a handle to the item list you want to append to that dialog
box’s existing item list. The method parameter specifies the manner in which you want the
new item list to be appended. The available methods are defined by constants of type
DITLMethod:
Integer;

appendDITLBottom

=
=

|

overlayDITL
appendDITLRight

1;

{overlay
existing
{append at right}
{append

©

=

I

CONST

DITLMethod

ho

TYPE

at

items}

bottom}

Consider the initial dialog box and list of items to be appended that are illustrated in
Figure 3-5.

(0,0)

(0,0)

Initial dialog box

Items to be appended

Figure 3-5. An initial dialog box and a list of items to append
If the method parameter is overlayDITL, the items to be appended are superimposed on any
existing items in the dialog box. Figure 3-6 shows the result of overlaying new dialog items.

(0,0)
[item 3]

[Item 1 |

[Item4]

[Item2]

Figure 3-6. The dialog box after items are overlaid

3-20

Running in System Software Version 7.0

Compatibility Guidelines

The positions of the new items are determined by the coordinate system of the initial
dialog box.
If the method parameter is appendDITLRight, the new items are appended to the right of the
dialog box, as illustrated in Figure 3-7.

(0,0)

Figure 3-7. The dialog box after items are appended to the right
The positions of the new items are offset by the upper-right coordinate of the port rectangle
of theDialog. AppendDITL automatically expands the dialog box to accommodate the new
dialog items. If you know that your application will need to restore a dialog box to the size
it was before you called AppendDITL, you should save the original size before calling
AppendDITL.
If the method parameter is appendDITLBottom, the new items are appended to the bottom of
the dialog box, as illustrated in Figure 3-8.

(ao
~
al

—
_
_
—

bx_—
—_
x.
—_
te
=
=
=
—_
4

(0,0)

te

OQ
=~=
ie
lan)
2.
re—
=
_
_

°+P

Figure 3-8. The dialog box after items are appended to the bottom
The positions of the new items are offset by the lower-left coordinate of the original dialog
box. AppendDITL automatically expands the dialog box to accommodate the new dialog
items. If you know that your application will need to restore a dialog box to the size it was
before you called AppendDITL, you should save the original size before calling AppendDITL.

Running in System Software Version 7.0

3-2]

4

Inside Macintosh,

Volume VI

You can append a list of dialog items relative to existing items in the dialog box by passing a
negative number in the method parameter. The absolute value of this number is interpreted as
the item in the dialog box relative to which the new items are to be positioned. For example,
if the method parameter is —2, the items to be appended are offset from the upper-left corner
of item number 2, as illustrated in Figure 3-9.

(0,0)

Figure 3-9, The dialog box after items are appended relative to Item 2
Because Item 3 was appended relative to the top-left corner of Item 2, it appears on top
of Item 2.
Because AppendDITL modifies the contents of the parameter theDITL, your application must
get rid of the dialog item list after calling AppendDITL. Here is a typical calling sequence:
myNewItems

:=

GetResource('DITL',

AppendDITL(myDialog,
ReleaseResource

Shortening

myNewlItems,

(myNewltems)

myID);

appendDITLBottom);

;

a Dialog Item List

You can call the ShortenDITL procedure to remove items from the end of a dialog item list.
PROCEDURE

ShortenDITL

(theDialog:

DialogPtr;

numberItems:

Integer);

The parameter theDialog specifies the dialog box from whose item list you want to remove
items. The numberltems parameter specifies how many items to remove from the end of
the item list. Note that ShortenDITL does not automatically resize the dialog box.

LOCALIZING

MACINTOSH

PROGRAMS

Localization is the process of adapting an application to a specific language, culture, and
region. By planning ahead and making localization relatively painless, you’ll ensure that your
product is ready for international markets in the future. This section provides a brief overview
of what you need to do to make it easy to localize your application. For the complete account
of writing software that is compatible with Macintosh computers throughout the world, you
should read the TextEdit chapter and the Worldwide Software Overview later in this volume.
You should also consult the “Worldwide Software Development” section in the User
Interface Guidelines chapter of this volume.
3-22

Localizing Macintosh Programs

Compatibility Guidelines

General

Guidelines

The key to easy localization is to store region-dependent information used by your application
as resources (rather than within the application’s code). Text seen by the user can then be
translated without modifying the code. In addition, storing such information in resources
means that your application can be adapted for a different area of the world simply by substituting the appropriate resources. Make sure that at least the following kinds of information are
stored in resources:
m all text, including special characters and delimiters
m= menus and keyboard equivalents for menu commands (if available)
w

character, word, phrase, and text translation tables

m address formats, including zip codes and telephone numbers
When you create resources for your applications, remember the following key points:

translated text is often 50 percent larger than the U.S. English text

4 some system fonts contain characters that extend to both the ascent and descent lines
= potential grammatical problems may arise from error messages, “natural” programming
language structures, and so forth
m text location within a window should be easy to change

Localizing

With

the

duioy

¢

diacritical marks, widely used outside the United States, may extend up to the
ascent line

£9

=F

cE
=

<
op)

e

O

O

m text needs room to grow (up, down, and sideways)

=i
o

os
=
©”

Toolbox

In addition to these general guidelines, you need to be aware of a host of other localization
issues, such as differences in script systems and measurement systems. The User Interface
Toolbox in system software version 7.0 contains updated versions of several packages and
managers that you can use to facilitate localization of your applications—TextEdit, the
International Utilities Package, and the Script Manager.
Perhaps the most important localization tool is the Script Manager, which contains routines
that allow your application to function correctly with non-Roman scripts (writing systems).
The Script Manager furnishes a standard interface that allows installation of different script
systems, maintains global data structures, supports switching keyboards between different
scripts, and provides a central dispatcher that gives your application access to script systems.
It also contains utilities for text processing and parsing, which are useful for applications that
do a lot of text manipulation. The Script Manager provides easy ways to translate your application into another writing system and to coordinate with the International Utilities Package.
The International Utilities Package provides routines for dealing with sorting, currency,
measurement systems, and date and time formatting. These tend to vary in some degree from
Localizing Macintosh Programs

3-23

Inside Macintosh,

Volume

VI

script to script, language to language, and region to region, and your application should take
advantage of the Macintosh Operating System’s ability to present this information in the
correct format based on the current script. It is important that you use the routines in this
package rather than the Operating System Utility routines such as UprString (documented in
Volume II); the Operating System Utility routines do not handle diacritical marks and
(because they are used by the File Manager) cannot be localized for different countries.
TextEdit provides routines that handle basic text formatting and editing capabilities, such as
inserting new text or scrolling text within a window. The versions of TextEdit included in
system software versions 6.0.4 and later contain new features that allow them to work with
different scripts. For example, TextEdit takes advantage of the Script Manager’s handling
of double-byte characters to display scripts (such as Kanji) with improved accuracy and
consistency.
For more information about the enhanced versions of TextEdit, see the TextEdit chapter in

this volume. For complete information on both the International Utilities Package and the
Script Manager, see the Worldwide Software Overview chapter.

RUNNING

MACINTOSH

PROGRAMS

UNDER

A/UX

A/UX is Apple’s version of the UNIX operating system, which provides a multitasking
and multi-user environment in which users can run applications. One of the most distinctive
features of A/UX in comparison with other implementations of the UNIX operating system
is its ability to run conforming Macintosh applications. Within limits described later in this
section, applications developed for the Macintosh Operating System using the standard
Macintosh User Interface Toolbox routines will execute under A/UX.
The ability to run Macintosh applications under A/UX is provided by enhancements to the
A/UX kernel and by a library of functions known as the A/UX Toolbox. The A/UX
Toolbox is a library of routines that enables a program running under A/UX to call
Macintosh Toolbox routines and native Macintosh Operating System routines. The A/UX
Toolbox provides a bridge between the Macintosh and A/UX environments, giving you
two kinds of code compatibility:
m Youcan execute Macintosh binary code (applications compiled in the Macintosh
environment) under A/UX, within the current limitations of the A/UX Toolbox.

m You can write common source code that can be separately built (that is, compiled and
linked) into executable code for both environments.
The A/UX Toolbox operates transparently to the user and to applications. This means that
(subject once again to qualifications detailed later) your applications developed for the
Macintosh Operating System should execute under the A/UX operating system.
This section briefly explains how the A/UX Toolbox works and then provides details on
writing Macintosh applications that execute under the A/UX operating system. A/UX
provides such a high level of compatibility with Macintosh applications that your existing
application may very well run under A/UX with no changes whatsoever. In general, if
your application conforms to the interfaces documented in /nside Macintosh, is MultiFinderaware, does not rely on low-memory global variables, and heeds the various guidelines
presented in “About Compatibility” earlier in this chapter, it should operate under A/UX.
3-24

Running Macintosh Programs Under A/UX

Compatibility Guidelines

How

the

A/UX

Toolbox

Works

The primary function of the A/UX Toolbox is to make available to programs running under
A/UX the standard Macintosh support code described in /nside Macintosh. Most of the
support code consists of routines built into the Macintosh ROM.
The ROM routines fall into two categories, User Interface Toolbox routines and Macintosh
Operating System routines. The A/UX Toolbox uses one of two strategies for supporting a
call to a Macintosh ROM routine, depending on whether the call is to the User Interface
Toolbox or to the native Macintosh Operating System.
When an A/UX Toolbox application calls one of the Macintosh User Interface Toolbox
routines, the A/UX Toolbox intercepts the call and, if necessary, translates the parameters
into a form usable by the ROM. After the A/UX Toolbox performs the translation, it
invokes the ROM code that would be used in the native Macintosh environment.

dwiod

Figure 3-10 illustrates how the two elements of the A/UX Toolbox library interact with the
application and the ROM code.

¢

When an A/UX Toolbox application calls one of the Macintosh Operating System routines,
the A/UX Toolbox diverts the call to a substitute routine in its own library. The A/UX
Toolbox Operating System routines call the standard A/UX libraries to perform the A/UX
equivalents of the Macintosh Operating System functions. The Macintosh Operating System
ROM code is never used under A/UX. Note that some of the built-in User Interface Toolbox
routines generate calls to the Macintosh Operating System routines; these calls are also
intercepted by the A/UX Toolbox and diverted to routines in its own library.

pS)

Application running
under A/UX

-

es
—

oe

—
—

mee

nm

e

<A

oP)

JJ

Standard
A/UX

libraries

Macintosh
eel

OS

subset

Macintosh ROM
Macintosh
OS

Figure 3-10.

iT

~
Ty
—

Qu
@

—
me

=}

is?)

if 2)

‘

Macintosh

|

Interface

.

:

User

Toolbox

| A/UX Toolbox

ROM interface

routines

{I

Macintosh
'
:

User
Interface
Toolbox

Interactions among an application, the A/UX Toolbox, and ROM code

Running Macintosh Programs Under A/UX

3-25

Inside Macintosh,

Volume VI

Using the A/UX Toolbox
The primary limitation on Macintosh applications running under A/UX is that the A/UX
Toolbox does not currently support all managers and drivers. Table 3-1 summarizes the status
of various ROM libraries in A/UX Release 2.0. Note that “Full” support for a manager or
driver means that the version of that manager released with system software 6.0.5 is available.
In particular, there is currently no support under A/UX for any of the new features introduced
in system software version 7.0.
Table

3-1.

ROM

library

Status of User Interface Toolbox and Macintosh Operating System libraries in
the A/UX Toolbox

Alias Manager

Apple Desktop Bus™

AppleTalk Manager
Binary-Decimal Conversion Package
Color Manager
Color Picker Package
Color QuickDraw
Control Manager
Data Access Manager
Deferred Task Manager
Desk Manager
Device Manager
Dialog Manager
Disk Driver
Disk Initialization Package
Edition Manager
Event Manager, Operating System
Event Manager, Toolbox
File Manager
Floating-Point Arithmetic and
Transcendental Functions Packages
Font Manager
Gestalt Manager
Help Manager
International Utilities Package
List Manager
Memory Manager
Menu Manager
Notification Manager
Package Manager
Palette Manager
Power Manager
PPC Toolbox
Printing Manager
QuickDraw
Resource Manager

Scrap Manager
Script Manager
SCSI Manager

3-26

Implementation
None
None
Full
Full
Full
Full
Full
Full
None
None
Full
Full
Full
Full
Full
None
Partial
Full*
Full
Full*
Full
Full
None
Full
Full
Full
Full
Full
Full
Full
None
None
Full
Full
Full
Full
Full
None

Running Macintosh Programs Under A/UX

Compatibility Guidelines

Table

3-1.

ROM

library

Status of User Interface Toolbox and Macintosh Operating System libraries in
the A/UX Toolbox (Continued)
Implementation

Segment Loader
Serial Driver
Shutdown Manager
Slot Manager
Sound Manager
Standard File Package
Startup Manager
System Error Handler
TextEdit
Time Manager
Utilities, Operating System
Utilities, Toolbox
Vertical Retrace Manager
Window Manager

Partial
Full
Full*
Full
Full
Full
Full
Full*
Full
Full*
Partial
Full
Partial
Full

dwoa

¢

Note: When A/UX implements a particular manager or driver, the version of that
manager or driver may not be the same as the version available in the Macintosh
Operating System. This means that, whenever possible, you should use Gestalt to
check for the existence of the particular features your application needs. In managers
or drivers marked with an asterisk (*), all routines are implemented under A/UX,
but the behavior is not identical to that in the Macintosh Operating System. See the
publication A/UX Toolbox: Macintosh ROM Interface for complete details on the
implementation of these managers and drivers.

=~

—

—
_

—

me

as

_

<A

A/UX

Compatibility

Guidelines

~
“4

&

a.

The A/UX Toolbox has been designed to allow as many Macintosh applications as possible
to execute under the A/UX operating system. Because of profound differences between the
two environments, however, it is possible that some applications may not execute correctly
under A/UX. By following these guidelines, you can help ensure that your Macintosh
applications run under A/UX.
a Make certain that your application is MultiFinder-friendly. MultiFinder is a standard part

of A/UX, just as it is in system software version 7.0 (where the Finder™ and the

Process Manager provide the cooperative multitasking environment). Your application

should include a 'SIZE' resource and call the WaitNextEvent function in its main event

loop. Note that the version of MultiFinder included with A/UX Release 2.0 is
functionally equivalent to the version of MultiFinder released with system software
version 6.0.5, but it has been customized for use under A/UX.

a Always use the available managers and drivers to manipulate hardware devices. In the
Macintosh Operating System, individual processes and the various libraries can have
much more control over the system than under A/UX, where the kernel manages all
interaction between processes and the underlying hardware. In particular, do not attempt
to read data from or write data to any of the memory-mapped hardware available on a
Macintosh computer.
Running Macintosh Programs Under A/UX

3-27

@

—

=e

~
@

if 2)

Inside Macintosh,

Volume V1

m Avoid relying on the low-memory global variables. Not all of them are available
under A/UX.
=» Make certain that your application is 32-bit clean (that is, it operates in an environment where all 32 bits of a handle or pointer are significant in determining memory
addresses).

m Use the Gestalt Manager to determine which versions of managers and drivers are
present in the current operating environment before relying on features that are not
common to all released versions. Generally, the versions of managers available under
A/UX Release 2.0 are the same as those versions included in Macintosh system
software version 6.0.5.
Finally, your application should conform to the programming interfaces described in /nside
Macintosh and should follow the basic compatibility guidelines presented in “About
Compatibility” earlier in this chapter. For further details on running Macintosh applications
under A/UX, see A/UX Toolbox: Macintosh ROM Interface.

ABOUT

THE

GESTALT

MANAGER

The Macintosh family of computers includes many models of computers, and it is likely to
grow in the future. Macintosh software runs on a number of different processors, some of
which are accompanied by floating-point coprocessors or memory management units. In
addition, the installed versions of the system software, drivers, and QuickDraw routines may
vary from machine to machine. To ensure that your applications are maximally compatible
with existing and future versions of the Macintosh, you should keep references to specific
software and hardware features to a minimum.
In general, applications should communicate with the system software and hardware through
the available managers and device drivers. If, however, it is necessary or useful for your
applications to take advantage of software or hardware components that may not be present
on all Macintosh computers, then you need some method of determining whether those
components are available. The Gestalt Manager serves this need by allowing you to get
information about the operating environment in a simple and efficient manner.
System software version 7.0 introduces several new managers and makes significant changes
to many existing managers. To take advantage of new version 7.0 features, and to run on as
many machines as possible, it is more important than ever before that your application determine the software and hardware components available in a particular operating environment.
To help you develop software for the entire line of Macintosh computers, system software
version 7.0 includes the Gestalt Manager. This manager includes the Gestalt function, which
is a replacement for both the Environs procedure and the SysEnvirons function. The Gestalt
function gives your application the ability to determine information about a large number of
machine-dependent features. You can use the Gestalt function to find the following sorts of
information about the hardware configuration and operating environment of the machine your
application is executing on:
m the type of machine
m the version of the System file currently running
3-28

About the Gestalt Manager

Compatibility Guidelines

m the type of CPU
m the type of keyboard attached to the machine
m the type of floating-point processing unit (FPU), if any
m the type of MMU, if any
m the size of available RAM
w the amount of available virtual memory
m

the versions of various drivers and managers

m the features of various drivers and managers
w the version of QuickDraw currently present
m whether the A/UX operating system is running or not

Although the Gestalt function can provide your application with most of the basic information
it needs about particular software or hardware features, you may still need to call other routines
to determine more specific features. For example, if you need to determine the resolution of
the main Macintosh screen, you can use the ‘Toolbox Utility procedure ScreenRes. (See the
Toolbox Utilities chapter of Inside Macintosh, Volume I, for a description of this procedure.)
The Gestalt function replaces both the Environs procedure and the current implementation
of the SysEnvirons function as the standard means of determining specific aspects of the
operating environment. The Gestalt function is simpler to use and provides more information
than either of those routines. Applications that use SysEnvirons still execute correctly in
system software version 7.0 (the SysEnvirons function calls the Gestalt function).

About the Gestalt Manager

3-29

-Q
=)

=
-_
a=]

oS)

=H

=H

=
ta

o~

x
x

Associated with the Gestalt function are two other functions—one that allows an application
to register new features with Gestalt and another that allows an application to change the
function used by Gestalt to retrieve a particular piece of information. These two functions
make it easy for your application to announce its presence to other applications, in case they
wish to alter their actions in view of the presence of your application. For example, a macro
utility that intercepts sequences of keyboard presses and translates them into other sequences
can register itself with Gestalt at system initialization time; afterward, other applications can
call Gestalt to determine if that utility is present. In this way, Gestalt can act as a central
clearinghouse for information on the available hardware and software features of the
operating environment, including any third-party applications that register themselves with
Gestalt. Gestalt therefore provides a further means of cooperation and awareness among
applications executing in the version 7.0 environment.

o®)

souljopin

How your application uses the resulting information depends on what your application needs
to accomplish. For example, in a case where critical hardware features are not available, your
application might display an alert box to notify the user that the required hardware is missing
and then terminate. Or if your application has determined that Color QuickDraw is available,
it could execute alternate code to take advantage of the expanded capabilities of that software.

Inside Macintosh, Volume VI

Use of the Environs procedure is no longer recommended because it encourages you to think
in terms of ROM versions, not in term of features that may be available. The Gestalt Manager
can also provide information such as ROM version and size, but you should not write applications that infer the presence of particular software or hardware features on the basis of that
information. When you need to know whether a particular feature is present, you should
request information about it directly, using the appropriate Gestalt selector.
Although you can still call the SysEnvirons function, the Gestalt Manager is simpler and
more efficient, and is the recommended way to get information about the operating environment. SysEnvirons returns a system environment record containing nine different pieces of
information. Gestalt returns only the information requested by use of a specific selector code
parameter. In most cases, your application really needs only a part of what is contained in the
system environment record. With Gestalt, your application can request only the information
it needs.

USING

THE

GESTALT

MANAGER

The Gestalt Manager includes three functions—Gestalt, NewGestalt, and ReplaceGestalt.
You can use the Gestalt function to obtain information about software or hardware components available on the current machine. You can use NewGestalt to register new software
modules (such as drivers and patches) with the Operating System. Use ReplaceGestalt to
replace the function associated with a particular selector code by some other function.
Note:

Most applications do not need to use either NewGestalt or ReplaceGestalt.

Determining

Features

of the Operating

Environment

When your application needs information about a specific software or hardware feature that
can be provided by the Gestalt function, your application can pass Gestalt a selector code
(or selector) as one of the parameters. The selector code is simply an indication of what
information your application currently needs. There are two types of selector codes—
predefined selector codes that are always recognized by Gestalt, and application-defined
selector codes that applications may register with Gestalt by calling the NewGestalt function.
If Gestalt can determine the requested information, it returns that information in its second
parameter, known as the response parameter. If Gestalt cannot obtain the desired information, it returns a result code indicating the cause of the error; in that case, the value of the
response parameter is undefined. You should a/ways check the result code returned by
Gestalt to make sure that the response parameter contains meaningful information.
Note: When passed one of the predefined selector codes, Gestalt does not move
or purge memory and therefore may be called at any time, even at interrupt time.
However, selector functions associated with application-defined selector codes may
move or purge memory, and applications can alter Gestalt’s predefined selector
functions. As a result, it is safest to assume that Gestalt might always move or purge
memory. The NewGestalt function may move memory and should not be called at
interrupt time.

3-30

Using the Gestalt Manager

Compatibility Guidelines

There are two types of predefined selector codes: codes that return information that your
application can use to guide its actions (known as environmental selectors), and codes
that provide information only and should never be used as an indication of some feature’s
existence (known as informational selectors).
It is particularly important that you understand the difference between environmental and

informational selectors. The response returned by Gestalt when it is passed an informational

selector is for your (or the user’s) edification only and should never be used by your application
as a means of determining whether some specific software or hardware feature is available.
For example, you can use Gestalt to test for the version of the ROM installed on a particular
machine, but you should never use this information to guide any of your application’s actions.
Routines you expect to be in ROM may actually be in RAM; hence, you cannot determine that
some routine usually found in ROM is not present simply by looking at the ROM version. Also,
routines contained in ROM may have been patched by the system at startup time, in which case
the system might not have the features that you think it has on the basis of the reported ROM
version. Similar remarks apply to other informational selectors such as ROM size, machine
type, and System file version.
You can use the following environmental selectors to determine information about the
operating environment.
CONST
gestaltAddressingModeAttr
gestaltAliasMgrAttr

=
=

'addr';
'alis';

{addressing mode attributes}
{Alias Mgr attributes}

~

gestaltAppleEventsAttr

=

'evnt';

{Apple

2

gestaltAppleTalkVersion

=

‘atlk';

{AppleTalk

gestaltAUXVersion

=

'a/ux';

{A/UX

gestaltConnMgrAttr
gestaltCRMAttr

=
=

'‘conn';
'crm
';

{Connection Mgr attributes}
{Comm Resource Mgr attrs}

=
=

gestaltCTBVersion
gestaltDBAccessMgrAttr

=
=

'ctbv';
'dbac';

{Comm
{Data

on
=i

gestaltDITLExtAttr

=

'ditl';

{Dialog

gestaltEasyAccessAttr
gestaltEditionMgrAttr

=
=

'easy';
'edtn';

{Easy Access
{Edition Mgr

gestaltExtToolboxTable

=

'xttt';

{Ext

gestaltFindFolderAttr

=

'fold';

{FindFolder

gestaltFontMgrAttr

=

'font';

{Font

Mgr

gestalt FPUType

=

'fpu

{FPU

type}

gestaltFSAttr
gestaltFXfrMgrAttr

=
=

'fs
';
'fxfr';

{file-system attributes}
{File Transfer Mgr attrs}

gestaltHardwareAttr

=

'hdwr';

{hardware

gestaltHelpMgrAttr
gestaltKeyboardType
gestaltLogicalPageSize

=
=
=

'help';
'kbd
';
'pgsz';

{Help Mgr attributes}
{keyboard
type}
{logical
page size}

gestaltLogicalRAMSize
gestaltLowMemorySize
gestaltMiscAttr

=
=
=

'lram';
'lmem';
'misc';

{logical
RAM size}
{low-memory
area size}
{miscellaneous
attributes}

gestaltMMUType
gestaltNotificationMgrAttr

=
=

'mmu
';
'nmgr';

{MMU type}
{Notification

gestaltNuBusConnectors
gestaltOSAttr
gestaltOSTable

=
=
=

'sltc';
'os
'‘';
'ostt';

{NuBus
connector
bitmap}
{0O/S attributes}
{0O/S trap table base}

';

events

attributes}

version}

version

if

5

present}

©

Toolbox version}
Access
Mgr attrs}
Mgr

Toolbox

extensions}

a

attributes}
attributes}
trap

table

=
&
base}

attributes}
attributes}

attributes}

Mgr

attrs}

Using the Gestalt Manager

3-3]

Inside Macintosh, Volume VI

gestaltParityAttr

=

'prty';

{parity

gestaltPhysicalRAMSize

=

'ram

{physical

gestaltPopupAttr

=

'pop!';

{pop-up

gestalt PowerMgrAttr

=

'powr';

{Power

gestaltPPCToolboxAttr

=

'ppc

{PPC

gestalt ProcessorType
gestaltQuickdrawVersion

=
=

'proc';
'qd
‘';

{processor
{QuickDraw

gestaltResourceMgrAttr

=

'rsrc';

{Resource

gestaltScriptCount

=

'scr#';

{#

gestaltScriptMgrVersion
gestaltSerialAttr

=
=

'scri';
'ser
';

{Script
{serial

Mgr version}
hardware attributes}

gestaltSoundAttr

=

'snd

{sound

attributes}

gestaltStandardFileAttr

=

'stdf';

{Standard

gestaltStdNBPAttr

=

'nlup';

{StandardNBP

gestaltTermMgrAttr
gestaltTextEditVersion

=
=

'term';
'te
'‘';

{Terminal
{TextEdit

';

';

';

attributes}

RAM
CDEF

Mgr

attributes}

Toolbox

of

attributes}
type}
version}

Mgr

active

attributes}

script

File

systems}

attributes}

attributes}

Mgr attributes}
version}

gestaltTimeMgrVersion

=

'tmgr';

{Time

gestaltToolboxTable
gestaltVersion

=
=

'tbtt';
'vers';

{Toolbox
{Gestalt

trap table
version}

gestaltVMAttr

=

'vm

{virtual

memory

'‘';

Mgr

size}
attributes}

version}
base}

attributes}

The following informational selectors are provided for informational purposes only. You can
display the information returned when using these selectors, but you should never use this
information as an indication of what software features or hardware may be available.
CONST

gestaltMachinelIcon

=

'micn';

{machine

ICON/cicn

gestaltMachineType

=

'mach';

{machine

type}

gestaltROMSize
gestaltROMVersion

=
=

'rom
';
'romv';

{ROM
{ROM

gestaltSystemVersion

=

'sysv';

{System

res

ID}

size}
version}

file

version}

“Interpreting Gestalt Responses” later in this chapter explains the exact meaning of each of
these selectors and of the values returned by Gestalt in each case.

Determining

Whether

Gestalt

Is Available

Because the Gestalt Manager currently exists only in system software versions 6.0.4 and later
(and in ROM on the Macintosh IIci, the Macintosh Portable, and later machines), you should

make certain that it is actually available before attempting to call it. You can do this by using
the TrapAvailable function defined previously in “Determining Whether a Trap Is Available.”
Listing 3-2 uses that function to determine whether the Gestalt Manager is available.
Listing 3-2. Determining whether Gestalt is available
FUNCTION

GestaltAvailable:

Boolean;

CONST

_Gestalt

=

SAI1AD;

BEGIN

GestaltAvailable

:=

TrapAvailable(_Gestalt) ;

END;

3-32

Using the Gestalt Manager

Compatibility Guidelines

Note: If you are using the MPW® development system version 3.2 or later, then
you do not need to perform this check because that version provides glue routines that
allow you to call Gestalt even if it is not in ROM or in the System file. However, if
you are programming in assembly language, this glue is not provided (and you still
need to check that Gestalt is available before calling it).
If you need to know at several different places in your application whether Gestalt is
available, it may be more efficient to define a global Boolean variable that you can test
before calling Gestalt. Listing 3-3 illustrates how to do this. Once again, this code
uses the TrapAvailable function defined earlier.
Listing 3-3. Using Gestalt to determine the Time Manager version
VAR

gHasGestalt:
gHasGestalt

IF

:=

gHasGestalt
myErr
IF

:=

myErr

Boolean;

DoError

if

Gestalt

is

implemented}

TrapAvailable(_Gestalt);

THEN

Gestalt
<>

{true

BEGIN
(gestaltTimeMgrVersion,

noErr
(myErr)

myFeature);

THEN

we

;

END;

OQ

This sample code returns (in the myFeature parameter) the version of the Time Manager
available on the current machine. Before using that information, however, you should test
the result code to make sure that Gestalt was able to determine the requested information.

S
=
a)Ss

=.

g.
=

<<

2

Interpreting

Gestalt

=
ry
&=:

Responses

When your application calls Gestalt to get information about the operating environment, the
meaning of the value that Gestalt returns in the response parameter depends on the selector code
with which it was called. For example, if you call Gestalt using the gestaltTimeMegrVersion
selector, it returns a version code in the low-order byte of the response parameter. In this case,
a returned value of 3 indicates that the extended Time Manager is available.
In almost all cases, the last few characters in the selector’s symbolic name form a suffix that
indicates what type of value you can expect Gestalt to return in the response parameter. For
example, if the final characters in a Gestalt selector are Size, then Gestalt returns a size in the
response parameter. The following list shows the meaningful suffixes.
Suffix

Meaning

Attr

The returned value is a range of 32 bits, the meaning of which must be
determined by comparison with a list of constants. Note that bit 0 is the
least significant bit of the long word.

Using the Gestalt Manager

3-33

is")

i 2)

Inside Macintosh,

Volume VI

Suffix

Meaning

Count

The returned value is a number indicating how many of the indicated type
of item exist.

Size

The returned value is a size. Sizes reported by Gestalt are usually in bytes.

Table

The returned value is the base address of a table.

Type

The returned value is an index describing a particular type of feature.

Version

The returned value is a version number. Implied decimal points may
separate digits of the returned value. For example, a value of $0605
returned in response to the gestaltSystemVersion selector indicates that
system software version 6.0.5 is present.

Selectors that have the suffix Attr deserve special attention; they cause Gestalt to return a bit
field that your application must interpret in order to determine whether a desired feature is
present. For example, the gestaltOSAttr selector requests information about a number of
Operating System features. To determine whether a particular Operating System feature is
available, you need to read the appropriate bit in the response parameter, as Listing 3-4
illustrates,
Listing 3-4. Interpreting a bit field response
VAR

IF

myBit:
myFeature:

Integer;
LongiInt;

myErr:

Integer;

ghasGestalt
myErr
IF

:=

myErr

THEN

BEGIN

Gestalt(gestaltOSAttr,
<>

noErr

myFeature) ;

THEN

DoError (myErr)
ELSE BEGIN
myBit
IF

:=

BitTst

gestaltTempMemSupport;
(@myFeature,

31-myBit)

WriteLn('temporary

=

TRUE

THEN

memory

support

available')

memory

support

not

ELSE

WriteLn('temporary

available');

END;

END;

This code uses the Toolbox utility function BitTst to determine whether the appropriate bit in
Gestalt’s response is set to 1. Notice that because bit numbering with BitTst is the opposite of
the usual MC680x0 numbering scheme used by Gestalt, the bit to be tested must be subtracted
from 31. Also, the first parameter to BitTst is a pointer to a byte; hence the use of the @
operator. Your development system may have other ways of testing the appropriate bit. For
example, if you are using MPW, you could write the test like this:
oo

F-

3-34

BTst

(myFeature,

myBit)

=

TRUE

Using the Gestalt Manager

THEN

Compatibility Guidelines

Interpreting

Responses

to

Environmental

Selectors

Gestalt returns one of the following responses when passed a predefined environmental
selector.

Selector

Meaning

gestaltAddressingModeAttr

Returns information about the current addressing mode.
CONST

gestalt32BitAddressing

=

0;

gestalt32BitSysZone
gestalt32BitCapable

=
=

ly
2y

The gestalt32BitAddressing attribute indicates that the machine
started up with 32-bit addressing. The gestalt32BitSysZone
attribute indicates that the system heap has 32-bit clean block
headers (regardless of the type of addressing the machine
started up in). See the Memory Management chapter for more
information about 32-bit addressing.
gestaltAliasMgrAttr

Returns information about the Alias Manager.
CONST

gestaltAppleEventsAttr

gestaltAliasMgrPresent

=

03

te

Returns information about Apple events.

o
ad

CONST

gestaltAppleTalk Version

gestaltAppleEventsPresent

=

~

0;

~

a=)

Returns the version number of the AppleTalk driver currently
installed. In particular, it returns the version number of the
.MPP driver. The version number is placed into the loworder byte of the result, so you should ignore the three
high-order bytes of the result. If an AppleTalk driver is
not currently open, the response parameter is 0. The driver
does not open until the user requests a network service (for
example, by running the Chooser).
Returns the version of A/UX if it is currently executing.
The result is placed into the lower word of the response
parameter. If A/UX is not executing, Gestalt returns
gestaltUnknownErr.

gestaltConnMegrAttr

Returns information about the Connection Manager.
gestaltConnMgrPresent
gestaltConnMgrCMSearchFix

=
=

ft

CONST

©

gestaltAUXVersion

-

‘

’

The gestaltConnMgrCMSearchFix bit flag indicates whether a
fix is present that allows the CMAddSearch routine to work
over the mAttn channel.

Using the Gestalt Manager

3-35

ry

=F

g,
=
=
op
S=.
O

=
a
~”

Inside Macintosh,

Volume VI

Selector

Meaning

gestaltCRMAttr

Returns information about the Communications Resource
Manager.
CONST

gestaltCRMPresent

=

gestaltCTB Version

Returns the version number of the Communications Toolbox.

gestaltDBAccessMgrAttr

Returns information about the Data Access Manager.
CONST

gestaltDITLExtAttr

gestaltDBAccessMgrPresent

=

0;

Returns information about the Dialog Manager.
CONST

gestaltDITLExt

Present

=

0;

If this flag bit is TRUE, then the Dialog Manager extensions are
available. See “Manipulating Dialog Item Lists” earlier in this
chapter for details about the Dialog Manager extensions
included in system software version 7.0.
gestaltEasy AccessAttr

Returns information about the status of Easy Access.
CONST

gestaltEditionMegrAttr

gestaltEasyAccessOff

=

gestaltEasyAccessOn

=

03
1;

gestaltEasyAccessSticky

=

D3

gestaltEasyAccessLocked

=

tf

Returns information about the Edition Manager.
CONST

gestaltEditionMgrPresent

=

0;

gestaltExtToolboxTable

Returns the base address of the extended Toolbox trap table.

gestaltFindFolderAttr

Returns information about the FindFolder function.
CONST

CONST

gestaltFPUType

0;

gestaltOutlineFonts

=

0;

Returns a value that indicates the type of floating-point
coprocessor currently installed, if any.
CONST

gestaltNoFPU
gestalt68881
gestalt68882

gestaltFS Attr

=

Returns information about the Font Manager.

iT

gestaltFontMegrAttr

gestaltFindFolderPresent

Os
Ly
24

Returns information about the file system.
CONST

gestaltFullExtFSDispatching
gestaltHasFSSpecCalls

=
=

0;
ls

The bit gestaltFullExtFS Dispatch indicates that all the routines
selected through the _HFSDispatch macro are avialable to
external file systems.
3-36

Using the Gestalt Manager

Compatibility Guidelines

Selector

Meaning

gestaltFXfrMegrAttr

Returns information about the File Transfer Manager.
CONST

gestaltHasVIA1l
gestaltHasVIA2
gestaltHasASC

=
=
=

0;
1;
33

gestaltHasSCC
gestaltHasSCSI

=
=

A?
7;

Returns information about the Help Manager.
CONST

gestaltHelpMgrPresent

=

0;

=

ISOADBKbd

gestaltADBKbdII

=

gestaltADBISOKbdII

=

¢

gestaltExt

lwod

—

|a
—*
~
—
—e
—

—

se

a

.

<
~~
Wd
~

’

7

=

gestaltPrtblISOKbd
gestaltStdISOADBKbd

oe

=

gestaltPrtblADBKbd

se

=

gestaltStdADBKbd

WD

——

gestaltExtADBKbd

o™e

=

gestaltMacPlusKbd

.

=

gestaltMacAndPad

OP

gestaltMacKbd

“YH

CONST

FE

Returns a value that indicates the type of keyboard that is
currently attached to the system.

~e

gestaltKeyboardType

0;

Returns information about the hardware configuration of
the machine.
CONST

gestaltHelpMgrAttr

=

KH HF WO
KF oOot

gestaltHardwareAttr

gestaltFXfrMgrPresent

.
‘

—

me

2.

If the Apple Desktop Bus is in use, there may be multiple
keyboards or other ADB devices attached to the machine.
Gestalt returns the type of the keyboard on which the last
keystroke occurred.

co

—
se

—
i¢°]
72)
—

gestaltLogicalPageSize

Returns the logical page size. This value is an unknown on
68000-based machines because such machines do not have
logical pages. On those machines, Gestalt returns an error.

gestaltLogicalRAMSize

Returns the amount of logical memory available. This value
is the same as that returned by gestaltPhysicalRAMSize
when virtual memory is not installed. On some machines,
however, this value might be less than the value returned by
gestaltPhysicalRAMSize because some RAM may be used
by the video display and the Operating System.

gestaltLowMemorySize

Returns the size (in bytes) of the low-memory area. The lowmemory area is used for vectors, global variables, and
dispatch tables.

Using the Gestalt Manager

3-37

Inside Macintosh, Volume VI

Selector

Meaning

gestaltMiscAttr

Returns information about miscellaneous pieces of the
Operating System or hardware configuration.
CONST

=

(0's

gestaltSquareMenuBar

=i

23

gestaltNoMMU
gestaltAMU
gestalt68851
gestalt68030MMU

gestaltNotificationMegrAttr

=

-

‘

.

,

.

,

Returns information about the Notification Manager.
CONST

gestaltNuBusConnectors

i}

CONST

©

Returns a value that indicates the type of MMU currently
installed, if any.
WN
Fe

gestalIMMUType

gestaltScrollingThrottle

gestaltNotificationPresent

=

0;

Returns information about the NuBus™ slot connector locations. The value returned is a bitmap. For example, the value
returned on a Macintosh II would have bits 9 through E set,
indicating that 6 NuBus slots are present (having locations
9 through E).

gestaltLaunchControl

FP

uu

gestaltTempMemTracked

=

gestaltIPCSupport

—

gestaltSysDebuggerSupport

It

gestaltTempMemSupport
gestaltRealTempMemory

™.

gestaltLaunchFullFileSpec

Wout

gestaltLaunchCanReturn

PWN

gestaltSysZoneGrowable

I

CONST

OC

Returns general information about the Operating System,
such as whether temporary memory handles are real handles.
The low-order bits of the response parameter are interpreted
as bit flags. A flag is set to 1 to indicate that the corresponding feature is available. Currently, the following bits are
significant:

OADM

gestaltOS Attr

See the Memory Management chapter in this volume for a full
explanation of the temporary memory features, and see the
Process Management chapter for a full explanation of the
launch control features.
gestaltOSTable

Returns the base address of the Operating System trap table.

gestaltParityAttr

Returns information about the parity-checking abilities of
the machine.
CONST

gestaltHasParityCapability
gestaltParityEnabled

0;
=

Te

Note that parity is not considered to be enabled unless all
installed memory is parity RAM.
3-38

Using the Gestalt Manager

Compatibility Guidelines

Selector

Meaning

gestaltPhysicalRAMSize

Returns the number of bytes of physical RAM currently
installed.

gestaltPopupAttr

Returns information about the pop-up control definition.
CONST

gestaltPopupPresent

=

0;

If the gestaltPopupPresent bit is set, the version 7.0 pop-up
control definition procedure is present. See “Creating Pop-Up
Menus” earlier in this chapter for details about creating pop-

up menus.

gestaltPowerMerAttr

Returns information about the Power Manager, if present.
CONST

gestaltPPCToolboxAttr

=
=

OF
1;

gestaltPMgrScCc

=

2

gestalt

=

3s

PMgrSound

Returns information about the capabilities of the PPC
Toolbox.
CONST

gestaltProcessorT
ype

gestaltPMgrExists
gestaltPMgrCPUIdle

gestaltPPCToolboxPresent

=

0;

o)

Returns a value that indicates the type of processor that is
currently running.

4

=)
=
—
—

—_

CONST

gestaltQuickdraw Version

gestalt68000
gestalt68010

=
=

1;
2;

gestalt68020

=

3;

gestalt68030

=

4;

>

—_

g.
re

a

lon
wd

Returns a 2-byte value indicating the version of QuickDraw
currently present. The high-order byte of that number represents the major revision number, and the low-order byte
represents the minor revision number. For example, the
Macintosh IIci contains QuickDraw version 2.01 in ROM;
on that machine, Gestalt returns the value $0201.
CONST

gestaltOriginalQD
gestaltOriginalQD1l

=
=

$000;
$001;

gestalt8BitQD
gestalt32BitQD
gestalt32BitQD11

=
=
=

$100;
$200;
$210:

gestalt32BitQD12
gestalt32BitQD13

=
=

$220:
$2303

Values having a major revision number of 1 or 2 indicate that
Color QuickDraw is available, in either the 8-bit or 32-bit

version. These results do not, however, indicate whether a
color monitor is attached to the system. You need to use highlevel QuickDraw routines to obtain that information.

Using the Gestalt Manager

3-39

=
=P
Qu.
oO
vam
—
a
o

—_.

~

Inside Macintosh,

Volume VI

Selector

Meaning

gestaltResourceMgrAttr

Returns information about the capabilities of the Resource
Manager.
CONST

gestaltPartialRsrcs

=

0;

gestaltScriptCount

Returns the number of script systems currently active.

gestaltScriptMegrVersion

Returns the version number of the Script Manager.

gestaltSerialAttr

Returns information about the serial hardware of the machine

(such as whether or not the GPla line is connected and can be

used for external clocking).
CONST

=
=

0;
1;

gestaltGPIaToDCDb

=

2;

Returns information about the sound capabilities of the

machine.

gestaltStereoCapability
gestaltStereoMixing

=
i

gestaltSoundIOMgrPresent

gestaltBuiltInSoundInput
gestaltHasSoundInputDevice

WE ©

.
‘
‘
.
U

-

CONST

.
,

uO

gestaltSoundAttr

gestaltGPIaToDCDa
gestaltGPIaToRTxCa

.
,

If the bit gestaltStereoCapability is TRUE, the available
hardware can play stereo sounds. The bit gestaltStereoMixing
indicates that the sound hardware of the machine mixes both
left and right channels of stereo sound into a single audio signal
for the internal speaker. The gestaltSoundlOM¢grPresent bit
indicates that the new sound input routines are available, and
the gestaltBuiltInSoundInput bit indicates that a built-in sound
input device is available. The gestaltHasSoundInputDevice bit
indicates that some sound input device is available.
gestaltStandardFileAttr

Returns information about the Standard File Package.
CONST

gestaltStandardFile58

=

0;

If this flag bit is set to 1, you can call the four new
procedures StandardPutFile, StandardGetFile,
CustomPutFile, and CustomGetFile. (The name of
the constant reflects the enabling of selectors 5—8 on
the trap macro that handles the Standard File Package.)
gestaltStdNBPAttr

Returns information about the call StandardNBP (NameBinding Protocol).
CONST

gestaltTermMerAttr

=

0;

Returns information about the Terminal Manager.
CONST

3-40

gestaltStdNBPPresent

Using the Gestalt Manager

gestaltTermMgrPresent

=

0;

Compatibility Guidelines

Selector

Meaning

gestaltTextEditVersion

Returns a value that indicates which version of TextEdit is
present.
CONST

gestaltTEl

=

1

gestaltTE2
gestaltTE3

=
=

2
3;

gestaltTE4
gestaltTE5

=
=

4
5

See the TextEdit chapter in this volume for further information on the capabilities of the enhanced versions of
TextEdit.
gestaltTimeMerVersion

Returns a value that indicates the version of the Time

Manager that is present.
CONST

gestaltStandardTimeMgr

=

1;

gestaltRevisedTimeMgr

=

2;

gestaltExtendedTimeMgr

=

3;

See the Time Manager chapter in this volume for a complete
explanation of the capabilities of each of these three versions.
gestaltToolboxTable

Returns the base address of the Toolbox trap table.

gestalt Version

Returns the version of Gestalt. The current version is 1,

oe)
~
=
—
.

—

corresponding to a returned value of $0001.

gestaltVMAttr

=
&

ot

te

)

Returns information about virtual memory.

te
—
—r)
ta

CONST

a

gestaltVMPresent

=

—_

0;

—

Responses

to Informational

Selectors

—

@
”

Gestalt returns the following responses when passed a predefined informational selector.
A

Warning: Never infer the existence of certain hardware or software features
from the responses that Gestalt returns to your application when you pass it
these selectors.

a

Selector

Meaning

gestaltMachinelcon

Returns an icon family resource ID for the current type of
Macintosh.

gestaltMachineType

Returns one of the following values, indicating the type of
machine on which the application is currently running.
CONST

gestaltClassic
gestaltMacxL

=
=

Ls
2}

{Macintosh
{Macintosh

4

~
ry
~
@
—
rT)
—
_—

Interpreting

4

~
—

128K}
XL}

gestaltMac512KE

=

34

{Macintosh

512KE}

gestaltMacPlus

=

4;

{Macintosh

Plus}

Using the Gestalt Manager

3-4]

Inside Macintosh, Volume VI

Selector

Meaning

gestaltMachineType (continued)
gestaltMacSE

e

Ss

{Macintosh

SE}

gestaltMacII
gestaltMacIIx

=
=

63
7;

{Macintosh
{Macintosh

II}
IIx}

gestaltMacIIcx

=

68:

{Macintosh

IIcx}

gestaltMacSE030

=

Qy

{Macintosh

SE/30}

gestaltPortable

=

10;

{Macintosh

Portable}

gestaltMacIIci

=

121%

{Macintosh

IIci}

gestaltMacII£x

=

13%

{Macintosh

IIfx}

gestaltMacClassic
gestaltMacIIsi

=
=

17;
18;

{Macintosh
{Macintosh

Classic}
IIsi}

gestaltMacLC

=

19s

{Macintosh

LC}

To obtain a string containing the machine’s name, you can pass the
returned value to GetIndString as an index into the resource of
type 'STR#' in the System file having resource ID defined by the
constant kMachineNameStrID.
CONST

gestaltROMSize
gestaltROMVersion
gestaltSystemVersion

Adding

kMachineNameStrID

=

-16395;

Returns the size of the installed ROM. The value is returned in
a word.
~ Returns the version number of the installed ROM.
Returns the version number of the currently active System file.
This number is represented as two byte-long numbers. For
example, if your application is running in version 6.0.4, then
Gestalt returns the value $0604. You should ignore the high-order
word of the returned value.

Gestalt Selectors

You can add a new selector code to those already understood by Gestalt by calling the
NewGestalt function. The NewGestalt function requires two parameters. The first parameter
is the new selector to be registered. The second parameter is the address of a selector
function. Gestalt executes the selector function when it needs to determine what value to
pass back when it is called after the new selector code.
The selector code is a four-character sequence of type OSType. For example, Carl’s ObjectOriented Linker might register itself using the selector code 'COOL'. If you have registered
a creator string with Apple, you are strongly encouraged to use that sequence as your
selector code.
Note: Apple reserves for its own use all four-character sequences consisting solely
of lowercase letters and nonalphabetic ASCII characters.
The selector function whose address you specify when registering a new Gestalt selector
code can be any function that resides in the system heap and whose calling syntax conforms
3-42

Using the Gestalt Manager

Compatibility Guidelines

to that defined in “Specifying Gestalt Selector Functions” later in this chapter. Listing 3-5
illustrates how to install a simple function into the system heap and pass its address to
NewGestalt.
Listing 3-5. Installing a selector function into the system heap
PROGRAM

NewGestaltSample;

USES
Memtypes,

OSIntf,

TooliIntf,

{standard

includes}

PasLibintf,

{for

standard

GestaltEqu,

{for

Gestalt}

Traps;

{for

trap

I/O,

etc.}

numbers}

CONST
mySelector

=

"COOL":

{Gestalt

function

selector}

gstFuncRsrcType
gstFuncRsrcID

=

'GDEF';

{Gestalt

function

resource

type}

=

228%

{Gestalt

function

resource

ID}

gestaltErr:
gstFuncHandle:

OSErr;
Handle;

{error returned
by
{handle
to Gestalt

oldGestaltFunc:

ProcPtr;

{pointer

VAR

to

old

Gestalt}
function}

function}

BEGIN
{first

make

IF

TrapAvailable(_Gestalt)

NOT

sure

that

Gestalt

is

available}

THEN

BEGIN

ye

WriteLn('Gestalt

END;

{load

IEexit (1)

Gestalt

function

gstFuncHandle

IF

:=

=

BEGIN

(1)

it

from

{detach

implemented.');

resource

NIL

WriteLn('Could
IEexit

not

into

system

CO

Ss

=

heap}

GetResource(gstFuncRsrcType,

gstFuncHandle

END;

is

=

gstFuncRsrcID);

=

THEN

not

S

load

Gestalt

function

Q

resource.');

=
=

the

resource

map

so

it

stays

=

i? 2)

around}

DetachResource(gstFuncHandle) ;
{add the new selector;
first assume
gestaltErr
:= NewGestalt(mySelector,
IF

gestaltErr

<>

noErr

that
it doesn't
already
exist}
ProcPtr(gstFuncHandle”%));

THEN

BEGIN

WriteLn('Could

{try

to

gestaltErr
ProcPtr
IF

not

replace

add

as

existing

a

new

selector.');

selector}

:= ReplaceGestalt (mySelector,
(gstFuncHandle*),
oldGestaltFunc) ;

gestaltErr

<>

noErr

THEN

not

replace

BEGIN

WriteLn('Could
TEexit

selector

either.');

(1);

END;
END;

WriteLn('Selector

installed.');

DisposHandle(gstFuncHandle) ;
END.

Using the Gestalt Manager

= 3-43

Inside Macintosh,

Volume VI

You can ensure that the new Gestalt selector function is installed into the system heap by
defining it as a resource (in this case, of type 'GDEF') whose resource attributes are
resSysHeap and resLocked (in other words, lock the resource into the system heap). The
following linking instructions illustrate one way to accomplish this:
Link

GestaltFunc.p.o
-o

-rn

-ra

=resSysHead,resLocked

-rt

GDEF=128

NewGestaltSample

If you are not using MPW, you can set the resource attributes by using ResEdit.
Listing 3-6 shows the actual function definition, contained in the file GestaltFunc.p.

Listing 3-6. Defining a new Gestalt function
UNIT

GestaltFunc;

INTERFACE
USES
GestaltEqu;

{for

Gestalt}

CONST

myResult
FUNCTION

=

$87654321;

gestaltCool

(Gestalt

(gestaltSelector:
VAR

function

response}

OSType;

gestaltResponse:

LongInt)

:

OSErr;

IMPLEMENTATION
FUNCTION

gestaltCool;

BEGIN
gestaltResponse
:= myResult;
gestaltCool
:= noErr;

{return
{return

response}
no error}

END;
END.

Because the new selector function resides in the system heap, Gestalt recognizes and
responds to the new selector until the machines restarts, even if your application terminates
before that time. As a result, you might want your selector function to determine whether
your application is still running before returning a value to Gestalt. If your application has
terminated, the selector function should return an error.
Note that if you try to register a selector that has already been registered with Gestalt, an
error results.

Modifying

Gestalt

Selectors

You can use the ReplaceGestalt function to modify the function that Gestalt executes when
passed a particular selector code. As with the function whose address is passed to NewGestalt,
the new function must reside in the system heap and have a calling syntax that conforms to
that defined in the following section, “Specifying Gestalt Selector Functions.” Listing 3-5
illustrates how to replace a Gestalt selector function.

3-44

Using the Gestalt Manager

Compatibility Guidelines

To allow the new function to call the function previously associated with the selector in
question, the ReplaceGestalt function returns the address of the previous function.
If you attempt to redefine a selector that is not yet defined, an error is returned; in that case,
the address of the previous function is undefined. Accordingly, you should always test the
result code of ReplaceGestalt before calling Gestalt with the selector in question.
Note: If you modify the function associated with a predefined Gestalt selector, do
not use any bits in the response parameter that are not documented in this chapter.
Apple reserves all undocumented bits in the response parameter returned by predefined Gestalt selectors.

Specifying

Gestalt Selector

Functions

When you call the NewGestalt and ReplaceGestalt functions, you need to supply the address
of a selector function that is called when some application passes the specified new or
replacement selector to Gestalt. This selector function should have the following syntax and
must reside in the system heap.
FUNCTION

mySelectorFunction

(selector:

OSType;

VAR

response:

LongInt)

€

OSEYY};

When you pass the new or replacement selector to Gestalt, Gestalt calls the specified selector
function to determine the information that Gestalt should pass back to the calling software.
Your function should place the result into the long integer pointed to by the response
parameter and should return the result code that Gestalt will return. This function should be
as simple as possible and cannot use global variables in the A5 world unless A5 is set up
explicitly and then restored upon exit. (See the Memory Management chapter in this volume
for an explanation of setting up and restoring the A5 world.)
Your selector function can, if necessary, call Gestalt and pass it other selector codes. Note
that the response variable parameter is the address into which your function should place the
information requested. You cannot depend on that address containing useful information
when your selector function is called.

GESTALT

MANAGER

ROUTINES

This section describes the three functions in the Gestalt Manager—Gestalt, NewGestalt, and
ReplaceGestalt. They allow you, respectively, to determine what hardware and software
features are present in the operating environment, to add new selectors to those understood
by the Gestalt function, and to replace the functions associated with known selectors.

Gestalt Manager Routines

3-45

2)

S
~

SS

ry

=F

3
=
<
©

=
Q.
©
&

="

~N

Inside Macintosh,

Getting

Volume VI

Information

About the Operating

Environment

Use the Gestalt function to obtain information about the operating environment. The information you need is indicated by the selector parameter, which Gestalt must already recognize.
FUNCTION

Gestalt

(selector:

Trap macro
On entry
On exit

OSType;

VAR

response:

LongInt)

:

OSErr;

_Gestalt
DO: selector code
AO: response
DO: result code

Upon successful completion of the function, the response parameter contains the information
requested. Note that Gestalt returns the response from all function selectors in a long integer,
occupying 4 bytes. In some cases, not all 4 bytes are needed to hold the returned information,
in which case Gestalt places the information in the low-order bytes of the response parameter.
Note: Although the response parameter is declared as a variable parameter, you
cannot use it to pass information to Gestalt or to a Gestalt selector function. Gestalt
interprets the response parameter as an address into which it is to place the result
returned by the selector function specified by the selector parameter. Gestalt ignores
any information already located at that address.
Result codes
noErr
gestaltUnknownErr
gestaltUndefSelectorErr

Adding Selector

0
—5550
-—5551

No error
Could not obtain the response
Undefined selector

Codes

Use the NewGestalt function to add selector codes to those already recognized by Gestalt.
FUNCTION

NewGestalt

(selector:

OSType;

selectorFunction:

OSErr';

Trap macro
On entry
On exit

3-46

_NewGestalt
AO: address of new selector function
DO: selector code
DO: result code

Gestalt Manager Routines

ProcPtr)

Compatibility Guidelines

NewGestalt takes as parameters the selector to be registered and the function that Gestalt calls
when it receives this selector. The interface for the selectorFunction function is defined in
“Specifying Gestalt Selector Functions” earlier in this chapter.
Result codes

noErr
memFullErr
gestaltDupSelectorErr
gestaltLocationErr

Modifying

Selector

0
—108
-—5552
—5553

No error
Ran out of memory
Selector already exists
Function not in system heap

Codes

The ReplaceGestalt function allows an application to replace the function that is currently
associated with a selector.
FUNCTION

ReplaceGestalt

(selector:
VAR

Trap macro
On entry
On exit

OSType;

selectorFunction:

oldGestaltFunction:

ProcPtr)

:

ProcPtr;
OSErr;

_ReplaceGestalt
AO: address of new selector function

tw

=
a
—
~

DO: selector code
AO: address of old selector function
DO: result code

os

—
_
as
me
_
eee

s

—s
—
—
a
te

The interface for the selectorFunction function is defined in “Specifying Gestalt Selector
Functions” earlier in this chapter. The new function must reside in the system heap and may
want to call the function previously associated with the named selector. It may do so by using
the address returned in the parameter oldGestaltFunction. If ReplaceGestalt returns an error
of any type, then the value of oldGestaltFunction is undefined.
Result codes

noErr
gestaltUndefSelectorErr
gestaltLocationErr

0
-—5551
—5553

No error
Undefined selector
Function not in system heap

Gestalt Manager Routines

3-47

oO
wd

a
—
wee
~a

©—

—s
—
—

o
+ 2)

4

Inside Macintosh,

SUMMARY

Volume VI

OF

THE

GESTALT

MANAGER

Constants
CONST

{environmental

selector

codes}

gestaltAddressingModeAttr
gestaltAliasMgrAttr

‘'addr'

{addressing

‘alis ¢‘

{Alias

Mgr

gestaltAppleEventsAttr
gestaltAppleTalkVersion

‘evnt'; ‘

{Apple

events

‘atlk'; ,

gestaltAUXVersion
gestaltConnMgrAttr
gestaltCRMAttr

ha /ux' ;,

{AppleTalk version}
{A/UX version if present}

“conn >’

{Connection

“erm.

{Comm

Resource

Mgr

gestaltCTBVersion

'SEby* 3’

{Comm

Toolbox

version}

gestaltDBAccessMgrAttr

"dbac* >’

{Data

Access

gestaltDITLExtAttr

'ditl'; ’

{Dialog

gestaltEasyAccessAttr

‘easy'; ‘

{Easy

gestaltEditionMgrAttr

‘edtn'; ‘

{Edition

gestaltExtToolboxTable

"“SCECE, 3‘

{Ext

gestaltFindFolderAttr

“foida" 3‘

gestaltFontMgrAttr
gestaltFPUType

"font';‘

{FindFolder attributes}
{Font Mgr attributes}

gestaltFSAttr
gestalt FXfrMgrAttr

'fs

.
‘

'

attributes}

Mgr

attributes}

Mgr

Mgr

attrs}

attrs}

extensions}

Access

attributes}

Mgr

attributes}

Toolbox

{FPU

attributes}

trap

table

base}

type}

{file-system

attributes}

{File

gestaltHardwareAttr

“ExEx* :‘
‘hdwr'; ‘

{hardware

attributes}

gestaltHelpMgrAttr

‘help'; ‘

{Help

attributes}

gestaltKeyboardType

"kbd

{keyboard

gestaltLogicalPageSize
gestaltLogicalRAMSize

"pgsz'; ‘
‘lram'; ‘

{logical

page

{logical

RAM

gestaltLowMemorySize
gestaltMiscAttr
gestaltMMUType

‘lmem' ;‘

{low-memory

gestaltNotificationMgrAttr
gestaltNuBusConnectors

‘'nmgr'; ‘

{miscellaneous attributes}
{MMU type}
{Notification Mgr attrs}

‘slte'; ’

{NuBus

gestaltOSAttr
gestaltOSTable

gestaltParityAttr
gestalt PhysicalRAMSize
gestalt PopupAttr
gestaltPowerMgrAttr
gestaltPPCToolboxAttr

'; ’

'misc'; ’
‘mmu

'

‘ostt'
'prty!
‘ram

Mgr

'

'

Mgr

size}
size}

area

connector

attributes}

{O/S

trap

table

size}

bitmap}
base}

attributes}

{physical

RAM

{popup

CDEF

{Power

Mgr

{PPC

attrs}

type}

{O/S

{parity

"pop!'
‘powr '
"ppc

Transfer

size}

attributes}

attributes}

Toolbox

attributes}

gestalt ProcessorType
gestaltQuickdrawVersion
gestaltResourceMgrAttr

"proc'; ‘

{processor
{QuickDraw

"FsSrc?s ‘

{Resource

gestaltScriptCount
gestaltScriptMgrVersion

"sert#! >‘
'scri'; ‘

gestaltSerialAttr
gestaltStandardFileAttr

‘ser
'; ‘
‘snd
*; ‘
*stdf'; ‘

{# of active script systems}
{Script Mgr version}
{serial hardware attributes}

gestaltStdNBPAttr

‘nilun* ;‘

gestaltSoundAttr

3-48

*

mode

attributes}

Summary of the Gestalt Manager

type}
version}
Mgr

attributes}

{sound attributes}
{Standard
File attributes}

{StandardNBP

attributes}

Compatibility Guidelines

gestaltTermMgrAttr

=

'term';

{Terminal

Mgr

gestaltTextEditVersion

=

'te

{TextEdit

version}

gestaltTimeMgrVersion

=

'tmgr';

{Time

gestaltToolboxTable

=

'tbhtt';

{Toolbox

trap

gestaltVersion

=

'vers';

{Gestalt

version}

gestaltVMAttr

=

'vm

{virtual

memory

{informational

selector

'‘';

';

Mgr

attributes}

version}

table

attributes}

codes}

gestaltMachineIcon

=

'micn';

{machine

gestaltMachineType
gestaltROMSize

=
=

'mach';
'rom ';

{machine type}
{ROM size}

gestaltROMVersion
gestaltSystemVersion

=

'romv';
'sysv';

{ROM version}
{System
file version}

{gestaltAddressingModeAttr

gestalt32BitAddressing
gestalt32BitSysZone
gestalt32BitCapable
{gestaltAliasMgrAttr

base}

=
#
=

response

0;
dy
Ze

=

res

ID}

values}

{TRUE if booted in
{32-bit compatible
{machine is 32-bit

response

gestaltAliasMgrPresent

ICON/cicn

32-bit mode}
system zone}
capable}

values}

0;

{TRUE

if

Alias

Mgr

is

present}
Ce

{gestaltAppleEventsAttr

response

values}

gestaltAppleEventsPresent

=

{TRUE

{gestaltConnMgrAttr

0;

response

gestaltConnMgrPresent
gestaltConnMgrCMSearchFix
{gestaltCRMAttr

response

gestaltCRMPresent

=

events

if

Apple

Q¥
1;

{TRUE
{TRUE

if
if

Connection Mgr present}
CMAddSearch fix present}

wee

_

ht
~
=)
mA
tase
—
oa
+
—
—T

values}
{TRUE

if

Comm

response

values}

gestaltDBAccessMgrPresent

=

{TRUE

0;

{gestaltDITLExtAttr

response

gestaltDITLExtPresent

=

{gestaltEasyAccessAttr

response

0;

Resource

Mgr

2)

present}

if

Data

Access

Mgr

present}

if

Dialog

Mgr

extensions

present}

values}

gestaltEasyAccessOff

=

0;

{Easy

Access

present

gestaltEasyAccessOn
gestaltEasyAccessSticky

=
=

1;
2;

{Easy
{Easy

Access
Access

on}
sticky}

gestaltEasyAccessLocked

=

3;

{Easy

Access

locked}

response

values}

=

0;

~
wd
~
&
bate
=)
2.
>
pans
pare
4
ig?)

values}
{TRUE

—_

<

—

{gestaltDBAccessMgrAttr

{gestaltEditionMgrAttr

present}

values}

=
=

Ox

gestaltEditionMgrPresent

CC 2
~
—)

{TRUE

if

Edition

Mgr

but

off}

present}

Summary of the Gestalt Manager

3-49

Inside Macintosh, Volume VI

{gestaltFindFolderAttr

response

gestaltFindFolderPresent

=

{gestaltFontMgrAttr

response

gestaltOutlineFonts

=

0;

values}

{TRUE

FindFolder

if

outline

present}

values}

0;

{TRUE

fonts

{gestaltFPUType

response

gestaltNoFPU
gestalt68881

=
=.

O;
Ls

{no FPU present}
{Motorola
68881 present}

gestalt68882

=

2s

{Motorola

{gestaltFSAttr

response

68882

present}

values}
=
=

0;
1;

{TRUE
{TRUE

{gestaltFxXfrMgrAttr

response

values}

gestaltFxXfrMgrPresent

=

{TRUE

{gestaltHardwareAttr
gestaltHasVIA1l
= 0;

present}

values}

gestaltFullExtFSDispatching
gestaltHasFSSpecCalls

0;

response

if
if

if

new HFSDispatch present}
FSSpec
calls present}

File

Transfer

Mgr

gestaltHasVIA2
gestaltHasASC

=
=

1;
3%

{has
{has

a VIA2}
an ASC}

gestaltHasSCC

=

4;

{has

an

gestaltHasSCSI

=

7;

{has

SCST}

{gestaltHelpMgrAttr

response

values}

gestaltHelpMgrPresent

=

0;

{true

SCC}

if

Help

Mgr

present}

{gestaltKeyboardType

response

values}

gestaltMacKbd

=

l;

{Macintosh

keyboard}

gestaltMacAndPad

=

2;

{Macintosh

keyboard

gestaltMacPlusKbd
gestaltExtADBKbd
gestaltStdADBKbd

=
=
=

3%
a
5

{Macintosh Plus keyboard}
{Extended ADB keyboard}
{Standard ADB keyboard}

gestalt PrtblADBKbd
gestaltPrtblISOKbd

=
=

6:
7

{Portable
{Portable

gestaltStdISOADBKbd

=

8;

{ISO

Std

ADB

keyboard}

gestaltExtISOADBKbd

=

9;

{ISO

Ext

ADB

keyboard}

gestaltADBKbdII
gestaltADBISOKbdII

=
=

10
lls

{ADB
{ISO

Keyboard
ITI}
ADB Keyboard

{gestaltMMUType

response

present}

values}
{has a VIA1}

{gestaltMiscAttr
response values}
gestaltScrollingThrottle
= 0;
{TRUE
gestaltSquareMenuBar
= 2;
{TRUE

3-50

if

if
if

Std
ISO

ADB
ADB

and

keypad}

keyboard}
keyboard}

II}

scrolling
throttle
on}
menu bar is square}

values}

gestaltNoMMU

=

Os

{no

MMU

gestaltAMU

=

l;

{Mac

II

Summary of the Gestalt Manager

present}
addr

management

unit}

Compatibility Guidelines

{|

gestalt68851
gestalt68030MMU

2°

{Motorola

68851

PMMU}

3;

{Motorola

68030

built-in

{gestaltNotificationMgrAttr
gestaltNotificationPresent

{gestaltOSAttr

response

response
=

0;

values}

{Notification

Mgr

=:
=

Oe
Ls

{system heap can
{can return
from

gestaltLaunchFullFileSpec

=

2;

{LaunchApplication

gestaltLaunchControl

=

3;

{Process

4;

{temp
{temp

gestaltTempMemSupport

memory

support

present }

memory

handles

are

i
a

°F
3

{temp memory
{IPC support

gestaltSysDebuggerSupport

=

8;

{system

gestaltParityEnabled

gestaltPopupPresent

=

real}

handles
tracked}
is present}

debugger

support}

values}

=

response

available}

available}

gestaltTempMemTracked
gestaltIPCSupport

response

is
is

—

gestaltHasParityCapability

grow}
launch}

Manager

gestaltRealTempMemory

{gestaltPopupAttr

present}

values}

gestaltSysZoneGrowable
gestaltLaunchCanReturn

{gestaltParityAttr

MMU}

0;

{machine

1;

{parity

can
RAM

check
is

parity}

installed}
os)

values}

0;

{pop-up

CDEF

is

lan
oo=

present}

\

4

_—

—_

{gestaltPowerMgrAttr

response

values}

—_

gestaltPMgrExists
gestaltPMgrCPUIdle

=
=

Q%
1;

{Power Manager
{CPU can idle}

gestaltPMgrSCc

=

2%

{can

stop

SCC

clock}

gestalt

=

33

{can

turn

off

sound

PPC

Toolbox

PMgrSound

is

{gestaltPPCToolboxAttr

response

values}

=

0;

{TRUE

response

values}
{68000

processor}

if

gestalt68010

=

2;

{68010

processor}

gestalt68020
gestalt68030

=
=

3;
4;

{68020
{68030

processor}
processor}

{gestaltQuickdrawVersion

response

present}

—

<

gestaltPPCToolboxPresent

{gestaltProcessorType
gestalt68000
= 1;

fle
ed
=$9
case
—_
~
A
—
re
~
G2
=~&
mato

power}

a!

—

@

ped
bare
—
ote
i
a

present}

values}

gestaltOriginalQD
gestaltOriginalQD1
gestalt8BitQOD
gestalt32BitQOD
gestalt32BitQD11

=
=
=
=
=

$000;
$001;
$100;
$200;
$210;

{original
QuickDraw}
{original
QuickDraw
in System
{8-bit Color QuickDraw}
{32-Bit Color QuickDraw}
{32-Bit
Color QuickDraw vers.

gestalt32BitQD12

=

$220;

{32-Bit

Color

QuickDraw

vers.

1.2}

gestalt32BitQD13

=

$230;

{32-Bit

Color

QuickDraw

vers.

1.3}

Summary of the Gestalt Manager

7.0}

1.1}

3-5]

Inside Macintosh,

Volume VI

{gestaltResourceMgrAttr
response values}
gestaltPartialRsrcs
= 0;
{partial

{gestaltSoundAttr

0?

response

{GPI
{GPI

connected
connected

to
to

DCD on port A}
RTxC on port A}

{GPI

connected

to

DCD

=
=

0;
1;

{gestaltStdNBPAttr

response
=

{gestaltTermMgrAttr

=

;
;
;

3-52

{TRUE

routines

if

StandardNBP

{TRUE

if

Terminal

present}

Mgr

gestaltTE2

=

2;

{with

scripts

on

Mac

=
=

3;
4;

{with 6.0.4
scripts
{in 6.0.5
and 7.0}

on

other

gestaltTE5

=

5;

{TextWidthHook

6.0.4

available

IIci}

in

machines}
TextEdit}

{gestaltTimeMgrVersion
gestaltStandardTimeMor

response
= 1;

values}
{standard

gestaltRevisedTimeMgr
gestaltExtendedTimeMgr

=
=

{revised Time Manager}
{extended Time Manager}

{gestaltVMAttr

response
=

present}

response
values}
MacIIci
ROM}

gestaltTE3
gestaltTE4

gestaltVMPresent

B}

available}

values}

0;

{gestaltTextEditVersion
gestaltTEl
= 1;
{in

port

values}

0;

response

gestaltTermMgrPresent

on

{stereo capability present}
{stereo mixing on internal speaker}
{sound input routines available}
{built-in input device available}
{sound input device available}

{gestaltStandardFileAttr
response values}
gestaltStandardFile58
= 0;
{new Std File

gestaltStdNBPPresent

exist}

values}

tod

gestaltStereoCapability
gestaltStereoMixing
gestaltSoundIOMgrPresent
gestaltBuiltInSoundInput
gestaltHasSoundInputDevice

functions

values}

Oe Ww

gestaltGPIaToDCDb

=
eo

response

NO

{gestaltSerialAttr
gestaltGPIaToDCDa
gestaltGPIaToRTxCa

resource

2;
3;

Time

Manager}

values}

0;

{virtual

memory

present}

{gestaltMachineType

response

gestaltClassic
gestaltMacxL

— se
= 2s

{Macintosh
{Macintosh

128K}
XL}

gestaltMac512KE
gestaltMacPlus

=.
=

Be
4;

{Macintosh
{Macintosh

512K enhanced}
Plus}

gestaltMacSE
gestaltMacII

=

§;
6;

{Macintosh
{Macintosh

SE}
ITI}

gestaltMacIIx

=

“Ps

{Macintosh

IIx}

Summary of the Gestalt Manager

values}

Compatibility Guidelines

gestaltMacIIcx
gestaltMacSE030

=
=

8;
9;

{Macintosh
{Macintosh

IIcx}
SE/30}

gestaltPortable
gestaltMacIIci

=
=

10;
ii;

{Macintosh
{Macintosh

Portable}
IIci}

gestaltMacIIf£x

=

23%

{Macintosh

IIfx}

gestaltMacClassic

=

Tis

{Macintosh

Classic}

gestaltMacIIsi

=

18;

{Macintosh

IIsi}

gestaltMacLC

+

Le

{Macintosh

LC}

kMachineNameStrID

=

-16395;

{'STR#'
{

resource

contains

machine

that

}

names}

Routines
FUNCTION

Gestalt

(selector:
OSErr;

OSType;

VAR

response:

LongInt)

FUNCTION

NewGestalt

(selector:

OSType;

selectorFunction:

ProcPtr)

OSErr;
FUNCTION

ReplaceGestalt

(selector:
VAR

G2
2

OSType;

selectorFunction:

oldGestaltFunction:

ProcPtr)

:

ProcPtr;
OSErr;

i
pb)

_~

mee
—

J
—
—
eee
ae

<

nt

Application-Defined

Routines

q@)
con
~
—?

e
a

@

—

FUNCTION

mySelectorFunction

Result

Codes

noErr
gestaltUnknownErr
gestaltUndefSelectorErr
gestaltDupSelectorErr
gestaltLocationErr

Q
—5550
-5551
—5552
—5553

(selector:
OSErr;

OSType;

VAR

response:

ae
_

LongInt)

_

ig")
wn

Noerror
Could not obtain the response
Undefined selector
— Selector already exists
Function not in system heap

Summary of the Gestalt Manager

3-53

Inside Macintosh,

SUMMARY

Volume VI

OF

THE

WINDOW

MANAGER

Constants
CONST

{window

definition

ID}

movableDBoxProc

SUMMARY

=

OF

THE

menu

control

5;

{movable

CONTROL

modal

dialog

box}

MANAGER

Constants
CONST

{pop-up

definition}

popupMenuCDEFProc

{pop-up

menu

=

title

1008;

{pop-up

characteristics}

popupTitleLeftJust

=

popupTitleCenterJust

{left
{center

alignment}
alignment}

=

SOOFF;

{right

alignment}

popupTitleBold

=

$0100;

{bold

text}

popupTitleItalic

=

$0200;

{italic

popupTitleUnderline
popupTitleOutline

=
=

$0400;
$0800;

{underlined
text}
{outlined
text}

popupTit1]leShadow

=

$1000;

{shadow

popupTit

=

$2000;

{condensed

popupTitleExtend

=

$4000;

{extended

text}

popupTitleNoStyle

os

$8000;

{unstyled

text}

{pop-up

TYPE

$0000;
$0001;

popupTitleRightJust

leCondense

menu

variation

text}

text}
text}

codes}

popupFixedwidth

Data

menu}

$0001;

{use

fixed-width

control}

popupUseAddResMenu

=

$0004;

{use

resource

menu}

popupUseWFont

=

$0008;

{use

window

for

font}

Type
popupPrivateData

=

RECORD

mHandle:
mID:

MenuHandle;
Integer;

mPrivate:

ARRAY[0..0]

{handle
to
{menu
ID}
OF

SignedByte

END;

3-54

Summary of the Control Manager

{reserved}

menu}

Compatibility Guidelines

SUMMARY

OF

THE

DIALOG

MANAGER

Constants
CONST

{DITLMethod

constants}

overlayDITL

=

Of

{overlay

appendDITLRight

=

i;

{append

at

right}

appendDITLBottom

=

2

{append

at

bottom}

Data

Type

TYPE

DITLMethod

=

existing

items}

Integer;

Routines
ae)
FUNCTION

PROCEDURE

CountDITL

AppendDITL

(theDialog:

DialogPtr)

:

(theDialog:

DialogPtr;

theDITL:

method:
PROCEDURE

ShortenDITL

Integer;

S
=]

Handle;

+
e,

DITLMethod) ;

(theDialog:

DialogPtr;

g.

numberItems:

Integer);

=

‘<

=e
a

©
=

©

i? 4]

Summary of the Dialog Manager

3-55

THE

EDITION

MANAGER

About This Chapter
About the Edition Manager
Publishers, Subscribers, and Editions
Using the Edition Manager
Receiving Apple Events From the Edition Manager
Creating the Section Record and Alias Record
Saving a Document Containing Sections
Opening and Closing a Document Containing Sections
Reading and Writing a Section
Formats in an Edition
Opening an Edition
Format Marks
Reading and Writing Edition Data
Closing an Edition
Creating a Publisher
Creating the Edition Container
Opening an Edition Container to Write Data
Creating a Subscriber
Opening an Edition Container to Read Data
Choosing Which Edition Format to Read
Using Publisher and Subscriber Options
Publishing a New Edition While Saving or Manually
Subscribing to an Edition Automatically or Manually
Canceling Sections Within Documents
Locating a Publisher Through a Subscriber
Renaming a Document Containing Sections
Displaying Publisher and Subscriber Borders
Text Borders
Spreadsheet Borders
Object-Oriented Graphics Borders
Bitmapped Graphics Borders
Duplicating Publishers and Subscribers
Modifying a Subscriber
Relocating an Edition
Customizing Dialog Boxes
Subscribing to Non-Edition Files
Getting the Current Edition Opener
Setting an Edition Opener
Calling an Edition Opener Procedure
Opening and Closing Editions
Listing Files That Can Be Subscribed To
Reading From and Writing to Files
Calling a Format I/O Procedure
Edition Manager Routines
Initializing the Edition Manager
Creating and Registering a Section
Creating and Deleting an Edition Container
Setting and Locating a Format Mark
Reading in Edition Data

rs
—

=
=
°
)5
~

—

)

=|is)
i7)

er |

Inside Macintosh,

69
70
71
76
78
78
81

Volume VI

Writing out Edition Data
Closing an Edition After Reading or Writing
Displaying Dialog Boxes
Locating a Publisher and Edition From a Subscriber
Edition Container Formats
Reading and Writing Non-Edition Files
Summary of the Edition Manager

The Edition Manager

ABOUT

THIS

CHAPTER

This chapter describes how you can use the Edition Manager to allow your users to share and
automatically update data from numerous documents and applications.
The Edition Manager is available only in system software version 7.0. It can be used by
many different applications located on a single disk or throughout a network of Macintosh®
computers. To test for the existence of the Edition Manager, use the Gestalt function,
described in the Compatibility Guidelines chapter of this volume.
Read the information in this chapter if you want your application’s documents to share and
automatically update data, or if you want to share and automatically update data with documents created by other applications that support the Edition Manager.
For example, a user might want to capture sales figures and totals from within a spreadsheet
and then include this information in a word-processing document that summarizes sales for
a given month. The Edition Manager establishes a connection between these two documents.
When a user modifies the spreadsheet, the information in the word-processing document
can be automatically updated to contain the latest changes. To accomplish this, both the
spreadsheet application and the word-processing application must support the features of
the Edition Manager.
To use this chapter, you should be familiar with sending and receiving high-level events,
described in the Events Manager chapter of this volume. Your application must also support
Apple® events to receive Apple events from the Edition Manager. See the Apple Event
Manager chapter in this volume for detailed information.

ABOUT

THE

EDITION

MANAGER

&
co)

oS
=
5
2
f

The Edition Manager provides you with the ability to

—

= capture data within a document and integrate it into another document

=
ge

a modify information in a document and automatically update any document that shares
its data

‘a

Law |

a share information between applications on the same computer or across a network of
Macintosh computers
Building the capabilities of the Edition Manager into your program is similar to building cutand-paste features into your program. Text, graphics, spreadsheet cells, database reports—
any data that you can select, you can make accessible to other applications that support the
Edition Manager.

About the Edition Manager

4-3

Inside Macintosh, Volume VI

This chapter first defines the main elements of the Edition Manager and then discusses how to
save, open, read, and write a document that shares data. In addition, this chapter describes
how to
a make data accessible to other applications
m

integrate data into numerous documents

m set update options
= implement borders
mw modify shared data
m customize dialog boxes
This chapter also describes an advanced feature that allows applications to share data directly
from a file.

PUBLISHERS,

SUBSCRIBERS,

AND

EDITIONS

A section is a portion of a document that shares its contents with other documents. The
Edition Manager supports two types of sections: publishers and subscribers. A publisher is
a section within a document that makes its data available to other documents or applications.
A subscriber is a section within a document that obtains its data from other documents or
applications.
Your application writes a copy of the data in each publisher to a separate file called an
edition container. The actual data that is written to the edition container is referred to
as the edition. Your application obtains the data for each subscriber by reading data
from the edition container. Note that throughout this chapter, the term edition refers to
the edition container and the data it contains.
You publish data when you want to make it available to other documents and applications.

When data is published, it is stored in an edition container. You subscribe to data that a

publisher makes available by reading an edition from its container.

Note: Section and edition container are programmatic terms. You should not use
them in your application or your documentation. Use publishers, subscribers, and
editions. You should also refrain from using other terms such as publication or
subscription to describe the dynamic sharing of information provided by the Edition
Manager. Use the terms publish and subscribe to describe the Edition Manager
features.
Each edition has an icon that is visible from the Finder. Figure 4-1 shows the default
edition icon.
SE,

POPPE
L OIL E EO

==
et PEELE
PEE EPPS

sample

Figure 4-1. The default edition icon
4-4

Publishers, Subscribers, and Editions

The Edition Manager

The name that the user specifies for the edition is located beneath the edition icon. To create
customized edition icons, see the Finder Interface chapter in this volume for detailed
information. Figure 4-2 illustrates a document containing a single publisher, its corresponding edition, and a subscriber to the edition in another document.

$1394.67
$3875.78
$9356.87
$5690.78

Publisher-{
.

ee

January

December
$5677.67
$2837.34
$3695.80
$5465.98

Totals
$2349.75
$3984.67

February
$1938.99

Totals
$3251.45

$2457.89
$3255.09

SH25.646

$989088

$5655.88
$6586.45

$5468.00
$7861.23
$5433.71

$1324.67
$2313.78
$4312.87
$3590.00

$4567.67
$2345.34
$3425.80
$5465.98

$7689.75
$3425.67
$5463.90
$7865.90

$2313.56
$4312.87
$3590.67

TO: Nick
FROM; Laura Palmer

$5463,90
$7489.14

ae:

Meeerrertetens
oreeeee

November

+

ay LE

Sales data

Here are the sales figures that you requested
January
$1332.46
$2313.56

February
$1938.99
$2457 89

Totals

$3251.45
$3425 66

a

— Subscriber

These Sgures reflect the increases over a two
month penod which were alfected by
the increase cost of
Operating expenses for that period
Adustments to these figures will be evaluated
shortly

Figure 4-2. A publisher, an edition, and a subscriber
Note that the publisher and subscriber borders illustrated in Figure 4-2 may appear slightly
different from the borders you see on screen. Figure 4-6 shows a screen-captured image of
the publisher and subscriber borders that appear on screen.
Data always flows in one direction, from publisher to edition to subscriber. Documents that
contain publishers and subscribers do not have to be open at the same time to share data.
Whenever the user saves a document that contains a publisher, the edition changes to reflect
the current data from the publisher. All subscribers update their contents from the edition.
Any number of subscribers can subscribe to a single edition.
To create a publisher within a document, a user selects an area of the document to share and
chooses Create Publisher from the Edit menu (illustrated later in this chapter). Figure 4-3
shows the dialog box that your application should display when the user chooses Create
Publisher.

a
&

Preview
of

3

|) Editions |
i

a

© sales data

S.
st
S
5
ra
=
pet)
ge

= Loma Prieta

—

ta

i sales report

Desktop

2

Fe
Name

of new

|Grand piano

edition:

|

{ Pubtisn }}

Figure 4-3. The publisher dialog box

Publishers, Subscribers, and Editions

4-5

Inside Macintosh,

Volume V1

Your application provides a thumbnail sketch of the edition data that the Edition Manager |
displays in the preview area of the publisher dialog box. Your preview of the edition in this
dialog box should provide a visual cue about the type of information that the user has selected
to publish.
A preview area also appears in the subscriber dialog box (see Figure 4-4). Your preview for
an edition in this dialog box should provide a visual cue about the type of information the
edition contains. For example, it should allow users to distinguish between text information
and spreadsheet arrays.
The publisher dialog box uses the extended interface of the standard file dialog box that
accompanies system software version 7.0. The user navigates through the contents of the
disk using the mouse or keyboard.
A user can modify a publisher within a document just like any other portion of a document.
As a default, each time a user saves a document containing a publisher, your application
should automatically write the publisher’s data to the edition. You also need to provide the
user with the choice of sending new publisher data to an edition manually (that is, only at the
user’s specific request). You can provide these options by using the publisher options dialog
box described later in “Using Publisher and Subscriber Options.”
For example, one user may choose to automatically update an edition each time a document is
saved. This update mode is useful for a user who creates a publisher within a spreadsheet
application that records stock information. Each time the user updates the stock information
and saves the spreadsheet, a new edition automatically becomes available to subscribers.
Another user may choose to update an edition only upon request. This update mode might be
useful for a user who creates a publisher within a word-processing application for a quarterly
sales report. The user incrementally updates the sales report throughout the entire quarter, but
does not want this information to be available to subscribers until the end of the quarter. Only
at the end of each quarter does the user specifically request to update the edition and make it
available to any subscribers.
To create a subscriber within a document, the user places the insertion point and chooses
Subscribe To from the Edit menu. Figure 4-4 shows the dialog box that your application
should display when the user chooses Subscribe To.
Preview
sp

Dae

a s

7,

|< Editions ~|

=

(3 Grand piano
© sales data

Loma Prieta
:

Desktop

£3 sales report

ik

Cancel
ra

Figure 4-4. The subscriber dialog box

4-6

Publishers, Subscribers, and Editions

Subscribe

The Edition Manager

The subscriber dialog box also uses the extended interface of the standard file dialog box
introduced with system software version 7.0. Initially, the dialog box should highlight the
name of the last edition published or subscribed to. This allows a user to create a publisher
and immediately subscribe to its edition.
A subscriber receives its data from a single edition. By default, your application should
automatically update a document containing a subscriber whenever a new edition is available.
You also need to provide the user with the choice of receiving the latest edition manually (that
is, only when the user specifically requests it). You can provide these options by using the
subscriber options dialog box described later in “Using Publisher and Subscriber Options.”
For example, one user may choose to automatically receive new editions as they become
available. This update mode is useful for a user who subscribes to information from an
edition that consists of daily sales figures. This user automatically acquires each version
of the sales information as it becomes available.
Another user may choose to receive a new edition only upon request. This update mode is
useful for a user who creates a subscriber to an edition that consists of graphics data (such
as a company logo). The user may require only periodic versions of the logo and not need
frequent updates. In this case, your application should only update the subscriber with a

new edition when the user specifically requests it.

A user can select, cut, copy, or paste an entire subscriber. Although the contents of the subscriber as a whole can be modified, a user cannot edit portions of a subscriber. For example,
a user can underline or italicize the entire subscriber text, but cannot delete a sentence or rotate
a single graphical object. This restriction protects the user from losing changes to a subscriber
when a new edition arrives. Remember that, as a default, new editions should automatically

update a subscriber. Any changes that a user made to the subscriber text would have to be
reapplied when the new edition arrives. See “Modifying a Subscriber” later in this chapter for
further information.
A single document can contain any number or combination of publishers and subscribers.
Figure 4-5 shows an example of a document that contains two publishers and one subscriber
(and their corresponding editions). Remember that data always flows in one direction, from
publisher to edition to subscriber. The “Concert flyer” document contains a publisher that is
subscribed to by the “Benefit concert” document. The “Concert flyer” document also
subscribes to a portion of the “Pianos & palm trees” document. In addition, the “Concert
flyer” document as a whole is subscribed to by the “Sample flyer” document.
You should distinguish each selected publisher and subscriber within a document with a
border. Display a publisher border as 3 pixels wide with 50 percent gray lines, and display
a subscriber border as 3 pixels wide with 75 percent gray lines. A rectangle of one white
pixel should separate the data from the border itself. Borders should be drawn outside the

Publishers, Subscribers, and Editions

S
tj

S.
=
°
5
<4
—

=
==
i=i)

Lew}

4-7

Inside Macintosh,

Volume VI

Mw)

in

Subscriber

of

v

the

Title

being held by the City Ars

Foundation. All proceeds
will be donated to the children’s
art museum and the city center

‘

=

arts council

me

\

M

Benefit concert

cic
in
the

park

5

“37
re
/

2

as

«iz

3

At

Graphic

Pianos & palm trees

GLB PM beginning March 21.
The series wil continue through

Here is a sample

Aprit 25

—— —-

flyer.

J

‘

Concert

flyer

.

Publisher

The concerts will be held in the outdoor ataumn
shat located across from the Academy of Sciences
in Golden Gate Park in San Francisco.

i

2ark
}
is a series of benefit concerts

252.

c

'

M

M.,

>

an

Flyer

——

s ns

wit

the ;

me

C

Subscriber

Sample flyer

Figure 4-5. A document and its corresponding editions
contents of publishers and subscribers so that data is not obscured. See Figure 4-6 for an
illustration of the borders as they appear on screen. See “Displaying Publisher and Subscriber
Borders” later in this chapter for detailed information on how to implement borders for
specific applications.
Figure 4-6 shows a document containing a publisher and a document containing a subscriber,
with borders displayed for each.
Borders for publishers and subscribers should behave like the borders of 'PICT' graphics
within a word-processing document. Your application should display a border whenever the

4-8

Publishers, Subscribers, and Editions

The Edition Manager

Tm
[|

Publisher border

= [=>

=jH.£

Subscriber border =z
4?

Apple SCSI cable terminators are hardware

a

devices that attach to a SCSI cable. There

islcel

must be no more than two terminators in a
SCSI chain.
:
:

Figure 4-6. Publisher and subscriber borders
user clicks within the content area of a publisher or a subscriber. Your application should
hide the border whenever the user clicks outside the content area. See “Displaying Publisher
and Subscriber Borders” later in this chapter for detailed information on how to implement
borders for specific applications.
You also need to support the standard Edition Manager menu commands in the Edit menu.
These menu items include
=

Create Publisher...

a

Subscribe To...

a
ie)
Send
lo!
—
=

o

i)
a

—

=
=
a
~

ge

is)
ar)

Publisher/Subscriber Options...
mw Show/Hide Borders (optional)
Stop All Editions (optional)

Publishers, Subscribers, and Editions

4-9

Inside Macintosh,

Volume VI

Use a dotted line to separate the Edition Manager menu commands from the standard
Edit menu commands Cut, Copy, and Paste. Figure 4-7 shows the standard Edition
Manager menu commands.

Undo

2

Cut
Copy
Paste
Clear
Select All

36H
#C
#U
A

Create Publisher...
Subscribe To...
Subscriber
Show

Options...

Clipboard

Figure 4-7, Edition Manager commands in the Edit menu
The Publisher Options menu command should toggle with Subscriber Options when a user
selects either a publisher or a subscriber within a document. In addition, you may support a
Show Borders menu command that toggles with Hide Borders to display or hide all publishers
and subscriber borders within documents. You may also support a Stop All Editions menu
command to provide a method for temporarily suspending all update activity in a document.
When the user chooses this command, you should place a checkmark next to it. You should
also stop all publishers from sending data to editions and all subscribers from receiving new
editions. When the user chooses this command again, remove the checkmark and update any
subscribers that are set up to receive new editions automatically.
If you find that you need all of the available space in the Edit menu for your application’s
commands, you may create a hierarchical menu for the Edition Manager menu commands. If
you choose to implement this structure, you should allow users to access the Edition Manager
menu commands through a Publishing menu command in the Edit menu. Because this menu
structure is not as accessible to users, you should implement it only if you have no other
alternative.
Figure 4-8 shows the Edition Manager menu commands in a hierarchical menu structure.

Undo

#82

Cut
Copy
Paste
Select

All

#H
#C
#U
aA

Publishing

4

Show

Clipboard)

/

Create Publisher...
Subscribe To...
Publisher Options...

Figure 4-8. Edition Manager commands under the Publishing menu command
4-10

Publishers, Subscribers, and Editions

The Edition Manager

For each publisher or subscriber within an open document, you must have a section record and
an alias record. The section record contains a time stamp that records the version of the data
that resides in the section. The section record also identifies the section as either a publisher or
subscriber, and it establishes a unique identity for each publisher or subscriber. The section
record does not contain the data within the section. The alias record is a reference to the edition
container from the document that contains the corresponding publisher or subscriber section.
There are special options associated with publishers and subscribers within documents. Your
application can use the publisher and subscriber options dialog boxes provided by the Edition
Manager to make these choices available to the user. For example, a user can select Open
Publisher within the subscriber options dialog box to access the document containing the
publisher. Your application can also allow a user to cancel subscribers or publishers within
documents, specify when to update an edition from a publisher, or specify when to update a
subscriber with a new edition. These options are described later in this chapter.

USING

THE

EDITION

MANAGER

This section describes how your application can
receive Apple events from the Edition Manager
m set up asection record and alias record for open documents containing sections
m save a document that contains sections
m open a document that contains sections
w read and write sections

rs

m create a publisher within a document, create its edition container, and write data to it

ty

2.
=

= create a subscriber within a document and read its data from an edition

is
=
=
ro
gea)
—

To begin, you must determine whether the Edition Manager is available on your system
by using the Gestalt function. The Gestalt selector is gestaltEditionMgrAttr (‘edtn’). If the
response parameter returns | in the bit defined by the gestaltEditionMgrPresent constant
(bit 0), the Edition Manager is present.

Ler |

If the Edition Manager is present, load it into memory using the InitEditionPack function.
This function determines whether your machine has enough space in the system heap for
the Edition Manager to operate.
err

:=

InitEditionPack;

If the InitEditionPack function returns noErr, you have enough space to load the package. If
you do not have enough space, the application can either terminate itself or continue with the
Edition Manager functionality disabled.

Using the Edition Manager

4-11

Inside Macintosh,

Receiving

Volume

VI

Events

Apple

From

the Edition

Manager

Applications that use the Edition Manager must support Apple events. This requires that your
application support the required Open Documents event and Apple events sent by the Edition
Manager. See the Apple Event Manager chapter in this volume for information on Apple events.
Apple events sent by the Edition Manager arrive as high-level events. The EventRecord data
type defines the event record.
TYPE

EventRecord

=

RECORD
what:

Integer;

{kHighLevelEvent }

message:

Longint;

{'sect'}

when:
where:

LongInt;
Point;

{*read’,
{

modifiers:

‘writ',

“cerecl';

}

“gerL* }

Integer

END;

The Edition Manager can send the following Apple events:
=

Section Read events ('sect' 'read’)

w

Section Write events ('sect' 'writ')

mw Section Cancel events (‘sect' 'cncl’)

= Section Scroll events ('sect' 'scrl')
Each time your application creates a publisher or a subscriber, the Edition Manager registers

its section. When an edition is updated, the Edition Manager scans its list to locate registered

subscribers. For each registered subscriber that is set up to receive updated editions automatically, your application receives a Section Read event.

If the Edition Manager discovers that an edition file is missing while registering a publisher, it
creates a new edition file and sends the publisher a Section Write event.
When you receive a Section Cancel event, you need to cancel the specified section. Note that
the current Edition Manager does not send you Section Cancel events, but you do need to
provide a handler for future expansion.
If the user selects a subscriber within a document and then selects Open Publisher in the
subscriber options dialog box, the publishing application receives the Open Documents event
and opens the document containing the publisher. The publishing application also receives a
Section Scroll event. Scroll to the location of the publisher, display this section on the user’s
screen, and turn on its border.
See “Opening and Closing a Document Containing Sections” later in this chapter for detailed
information on registering and unregistering a section and writing data to an edition. See
“Using Publisher and Subscriber Options” later in this chapter for information on publisher
and subscriber options.

4-12

Using the Edition Manager

The Edition Manager

After receiving an Apple event sent by the Edition Manager, use the Apple Event Manager to
extract the section handle. In addition, you must also call the IsRegisteredSection function
to determine whether the section is registered. It is possible (due to a race condition) to receive
an event for a section that you recently disposed of or unregistered. One way to ensure that an
event corresponds to a valid section is to call the IsRegisteredSection function after you receive
an event. The Apple Event Manager chapter in this volume provides detailed information on
Apple Event Manager routines.
err

:=

IsRegisteredSection

(sectionH) ;

Listing 4-1 illustrates how to use the Apple Event Manager and install an event handler to
handle Section Read events. You can write similar code for Section Write events, Section
Scroll events, and Section Cancel events.

Listing 4-1. Accepting Section Read events and verifying if a section is registered
{The following
goes
in your
initialization
code. }
MyErr
:= AEInstallEventHandler(sectionEventMsgClass

sectionReadMsgID

{'sect'},

{'read'},

@MyHandleSectionReadEvent,

{

event

routine

the

is

{This

the

Apple

Manager

Event

when

calls

0,

a

FALSE) ;

}

Read

Section

arrives.}

FUNCTION

MyHandleSectionReadEvent

(theAppleEvent,
reply:
AppleEvent;
refCon:
LongInt)
: OSErr;

VAR
getErr:

OSErr;

sectionH:

SectionHandle;

BEGIN

buffer. }
out of Apple event message
section handle
sectionH)
:= GetSectionHandleFromEvent (theAppleEvent,
getErr
{Get

noErr

=

getErr

IF

BEGIN

ic

END ELSE

a.
=

THEN

=

S
S

{Do nothing if section is not registered. }
= noErr
IF IsRegisteredSection(sectionH)
THEN

=

;

MyHandleSectionReadEvent

BEGIN
MyHandleSectionReadEvent

:=

:=

DoSectionRead(sectionH)

aS

;

%

getErr;

END;

END;

{MyHandleSectionReadEvent }

should read
routine
{The following
{ display. }
DoSectionRead(subscriber:
FUNCTION

in

subscriber

SectionHandle)

data
:

and

update

its

}

OSErr;

BEGIN

{Your
END;

code

here. }

{DoSectionRead}
(Continued)

Using the Edition Manager

4-13

Inside Macintosh,

Volume VI

Listing 4-1. Accepting Section Read events and verifying if a section
is registered (Continued)
{This

is

FUNCTION

part

of

your

Apple

event-handling

GetSectionHandleFromEvent

code. }

(theAppleEvent:

sectionH:

AppleEvent;

SectionHandle)

VAR

:

OSErr;

VAR

ignoreType:

DescType;

ignoreSize:

Size;

BEGIN

{Parse

section

handle

out

of

message

GetSectionHandleFromEvent
:= AEGetParamPtr(
theAppleEvent,

END;

buffer. }
{event

to

parse}

keyDirectObject,

{Look

for

direct

typeSectionH,

{Want

a

ignoreType,

{Ignore

@sectionH,

{Put

SizeOf(sectionH),

{size of storage
{ SectionHandle}

ignoreSize)

{Ignore

;

object.}

SectionHandle

type.}

type

get.}

it

could

SectionHandle

storage

here. }
for

it

}

used.}

{GetSectionHandleFromEvent }

Creating the Section

Record

and Alias Record

Your application is responsible for creating a section record and an alias record for each
publisher and subscriber section within an open document.
The section record identifies each section as a publisher or subscriber and provides identification for each section. The section record does not contain the data within the section; it
describes the attributes of the section. Your application must provide its own method for
associating the data within a section with its section record. Your application is also responsible for saving the data in the section.
The alias field of the section record contains a handle to its alias record. The alias record is
a reference to the edition container from the document which contains the publisher or subscriber section. You should be familiar with the Alias Manager’s conventions for creating
alias records and identifying files, folders, and volumes to locate files that have been moved,
copied, or restored from backup.

When a user saves a document, your application should store all section records and alias

records in the resource fork. Corresponding section records and alias records should have
the same resource ID. This allows compatibility for future changes.
Figure 4-9 shows a document containing a publisher and subscriber, and the corresponding
section records and alias records.
The SectionRecord data type defines the section record. A section record contains information
to identify the data contained within a section as a publisher or a subscriber, a time stamp to
record the last modification of the section, and unique identification for each section.

4-14

Using the Edition Manager

The Edition Manager

Adding
Cabie Terminators

A Cable Terminator
acts as a damper in
Terminators
keep signals from bouncing off one end
your SCS! Cable System.

of the line and rippling back, interfering
with the new messages.
-

Subscriber—

SCSI cables and terminators
Devices connected to the SCS! port on the back

Publisher.
Resource fork
Section record

Section record
version:
kind:

mode:
mdDate:

sectionID:

refCon:
alias:

version:
kind:
mode:
mdDate:
sectionlD:
refCon:
alias:

“Alias record:—-> [2205

subPart:
nextSection:
controlBlock:
refNum:

= Aliasrecord:—->

(35)
Terminator

subPart:
nextSection:
controlBlock:
refNum:

Figure 4-9. A document with a publisher and subscriber and its resource fork
TYPE

SectionRecord

RECORD

=

version:
kind:
mode:
mdDate:

SignedByte;
SectionType;

sectionID:

Updat eMode;
TimeStamp;
LongInt;

refCon:
alias:

Longint;
AliasHandle;

{always

1

in

ol
i
=o_o
—:
_
—:
=
~
—
_

7.0}

{publisher or subscriber}
{automatic or manual}
{last change in document}
{application-specific,

}

{ unique per document}
{application-specific}
{handle

to

alias

bane!
ne
_
—_
=
as
a
wT

ts)
o

~

record}

{The following fields are private and are set up by the }
{ RegisterSection function described later within this }
{ chapter.
Do not modify the private fields. }
{private}

subPart:
nextSection:

LongIint;
SectionHandle;

controlBlock:

Handle;

{ linked list}
{may be used for

refNum:

EditionRefNum

{ only}
{private}

{private,

do

not

use

as

a

}

comparison

}

END;

Using the Edition Manager

4-15

?

Inside Macintosh,

Field

Volume VI

descriptions

version

Indicates the version of the section record, currently $01.

kind

Defines the section type as either publisher or subscriber with the stPublisher or
stSubscriber constant.

mode

Indicates if editions are updated automatically or manually.

mdDate

Indicates which version (modification date) of the section’s contents is con-

sectionID

tained within the publisher or subscriber. The mdDate is set to 0 when you
create a new subscriber section, and is set to the current time when you create a
new publisher. Be sure to update this field each time publisher data is modified.
The section’s modification date is compared to the edition’s modification date to
determine whether the section and the edition contain the same data. The section
modification date is displayed in the publisher and subscriber options dialog
boxes. See “Closing an Edition” later in this chapter for detailed information.
— Provides a unique number for each section within a document. A simple way to
implement this is to create a counter for each document that is saved to disk
with the document. The counter should start at 1. The section ID is currently
used as a tie breaker in the GoToPublisher function when there are multiple
publishers to the same edition in a single document. The section ID should not
be 0 or —1. See “Duplicating Publishers and Subscribers” later in this chapter
for information on multiple publishers.

refCon

Available for application-specific use.

alias

Contains a handle to the alias record for a particular section within a document.

Whenever the user creates a publisher or subscriber, call the NewSection function to create
the section record and the alias record.
err

:=

NewSection

(container,
initialMode,

sectionDocument,

kind,

sectionID,

sectionH);

The NewSection function creates a new section record (either publisher or subscriber),
indicates whether editions are updated automatically or manually, sets the modification date,
and creates an alias record from the document containing the section to the edition container.
The sectionDocument parameter can be NIL if your current document has never been saved.
Use the AssociateSection function to update the alias record of a registered section when the
user names or renames a document by choosing Save As from the File menu. If you are
creating a subscriber with the initialMode parameter set to receive new editions automatically,
your application receives a Section Read event each time a new edition becomes available for
this subscriber.
If an error is encountered, the sectionH parameter is set to NIL. If not, sectionH contains the
handle to the allocated section record.

4-16

Using the Edition Manager

The Edition Manager

Set the initialMode parameter to the update mode for each subscriber and publisher created.
You can specify the update mode using these constants:
CONST

sumAutomatic

=

sumManual

=

pumOnSave

=

pumManual

=

OQ;

{subscriber

new

}

Zs

{ editions
automatically}
{subscriber
receives
new

}

0;

{ editions
{publisher

manually}
sends new

}

1;

{ editions
{publisher

on save}
does not

send

{
{

receives

new editions
request}

until

}

user

}

See “Using Publisher and Subscriber Options” later in this chapter for detailed information on
update modes for publishers and subscribers.

Saving

a Document

Containing

Sections

When saving a document that contains sections, you should write out each section record
as a resource of type 'sect' and write out each alias record as a resource of type ‘alis' with
the same ID as the section record. See the Resource Manager chapters in Volume I and this
volume for detailed information on resources.
If a user closes a document that contains newly created publishers without attempting to save
its contents, you should display an alert box similar to the one shown in Figure 4-10.

This document contains new Publishers.
must save this document to keep them.

You

+
=

Save changes to the TeachText document
“untitled” before closing?

[

Cancel

)

Save

a.

s,

iS
|
=
$9
=
ge@

}

—

ss |

Figure 4-10. The new publisher alert box
If you keep the section records and alias records for each publisher and subscriber as
resources, you can use the ChangedResource or WriteResource function. If you detach
the section records and alias records from each section, you need to clone the handles and
use the AddResource function. See the Resource Manager chapter in Volume V for detailed
information on the ChangedResource, WriteResource, and AddResource functions.
Use the PBExchangeFiles function to ensure that each time you save a document that contains
sections, the file ID remains the same. Saving a file typically involves creating a new file
(with a temporary name), writing data to it, closing it, and then deleting the original file that
you are replacing. You rename the temporary file with the original filename, which leads to a
new file ID. The PBExchangeFiles function swaps the contents of the two files (even if they
Using the Edition Manager

4-17

Inside Macintosh,

Volume VI

are open) by getting both catalog entries and swapping the allocation pointers. If the files are
open, the file control block (FCB) is updated so that the reference numbers still access the
same contents (under a new name). See the File Manager chapter in this volume for detailed
information on the PBExchangeFiles function.
Listing 4-2 illustrates how to save a file that contains sections. As described earlier, you
should write out the eligible section records and alias records as resources to allow for
future compatibility. There are several different techniques for saving or adding resources;
this listing illustrates one technique. The section handles are still valid after using the
AddResource function because this listing illustrates just saving, not closing, the file.
Before you write out sections, you need to see if any publisher sections share the same
control block. Publishers that share the same control block share the same edition.

If a user creates an identical copy of a file by choosing Save As from the File menu and
does not make any changes to this new file, you simply use the AssociateSection function
to indicate to the Edition Manager which document a section is located in.

Listing 4-2. Saving a document containing sections
PROCEDURE

SaveDocument

(thisDocument:

MyDocumentInfoPtr;

numberOfSections:

Integer);

VAR

aSectionH:

SectionHandle;

copiedSectionH:

Handle;

copiedAliasH:

Handle;

resID:

Integer;

thisone:

Integer;

BEGIN

{Write contents of publishers that
{ The GetSectionAliasPair function
{

resID

to

a

section.

{ returns
TRUE
FOR thisone
:=

The

need to
returns

be written during
a handle and }

CheckForDataChanged

if the data
in the section
1 TO numberOfSections
DO

function

has

save.

}

changed. }

BEGIN

aSectionH

:=

IF

GetSectionAliasPair(thisDocument,

thisone,

(aSectionH**.kind = stPublisher)
&
(aSectionH**.mode = pumOnSave)
&
(CheckForDataChanged(aSectionH) )
THEN DoWriteEdition(aSectionH,
thisDocument) ;
END;

resID);

{for}

{Set the curResFile
to be the resource
fork
UseResFile(thisDocument*.resForkRefNum) ;

of

{Write

document. }

FOR

all

section

thisone

:=

1

TO

{Given

an

index,

{

your

and

records

to

numberOfSections

alias

DO

the

thisDocument.}

BEGIN

from

aSectionH

4-18

:=

get

the

next

section

internal

list

of

sections

handle

for

GetSectionAliasPair(thisDocument,

Using the Edition Manager

and

this

resID

}

file.}
thisone,

resID);

}

The Edition Manager

{Check

for

duplication

of

CheckForDupes

(thisDocument,

{Save

record

section

to

control

block

values. }

numberOfSections) ;

disk. }

copiedSectionH
:= Handle(aSectionH) ;
HandToHand (copiedSectionH) ;
AddResource(copiedSectionH,

{Save

alias

record

copiedAliasH
HandToHand

:=

to

{Write

rest

resID,

'');

disk.}

Handle(aSectionH**.alias) ;

(copiedAliasH);

AddResource(copiedSectionH,
END;
{for}

END;

rSectionType,

of

document

to

rAliasType,

resID,

'');

disk.}

{SaveDocument }

Opening

and Closing

a Document

Containing

Sections

When opening a document that contains sections, your application should use the GetResource
function to get the section record and the alias record for each publisher and subscriber. Set the
alias field of the section record to be the handle to the alias. See the Resource Manager chapter
in Volume I for detailed information on the GetResource function.

You also need to register each section using the RegisterSection function. The RegisterSection
function informs the Edition Manager that a section exists.
err

:=

RegisterSection

(sectionDocument,

sectionH,

aliasWasUpdated) ;

The RegisterSection function adds the section record to the Edition Manager’s list of registered sections. This function assumes that the alias field of each section record is a handle
to the alias record. The alias record is a reference to the edition container from the section’s
document. If the RegisterSection function successfully locates the edition container for a
particular section, the section is registered through a shared control block. The control block
is a private field in the section record.

—
i
lm!
ee

7}
cue

Comal
-_~
=
—

-_

a
—_
©aa
—_
aa
ve
—

——
—

If the RegisterSection function cannot find the edition container for a particular subscriber,
RegisterSection returns the containerNotFoundWrn result code. If the RegisterSection
function cannot find the edition container for a particular publisher, RegisterSection creates
an empty edition container for the publisher in the last place the edition was located. The
Edition Manager sends your application a Section Write event for that section.
When a user attempts to open a document that contains multiple publishers to the same
edition, you should warn the user by displaying an alert box (see “Duplicating Publishers
and Subscribers” later in this chapter).
When a user opens a document that contains a subscriber (with an update mode set to
automatic), receives a new edition, and then closes the document without making any
changes to the file, you should update the document and simply allow the user to close
it. You do not need to prompt the user to save changes to the file.
Using the Edition Manager

4-19

@
a |

Inside Macintosh,

Volume VI

When closing a document that contains sections, you must unregister each section (using
the UnRegisterSection function) and dispose of each corresponding section record and
alias record.
err

:=

UnRegisterSection

(sectionH);

The UnRegisterSection function removes the section record from the list of registered
sections and unlinks itself from the shared control block.
Listing 4-3 illustrates how to open an existing file that contains sections. As described earlier,
you should retrieve the section and alias resources, connect the pair through the alias field
of the section record, and register the section with the Edition Manager. There are many
different techniques for retrieving resources; this listing shows one technique. If an alias was
out of date and was updated by the Alias Manager during the resolve, the Edition Manager
sets the aliasWasUpdated parameter of the RegisterSection function to TRUE. This means
that you should save the document. Additionally, your application must maintain its own list
of registered sections for each open document that contains sections.
Listing 4-3. Opening a document containing sections
PROCEDURE

OpenExistingDocument

(thisDocument:

MyDocumentInfoPtr) ;

VAR

sectionH:

SectionHandle;

aliasH:

AliasHandle;

aliasWasUpdated:

Boolean;

registerErr:

OSErr;

resID:

Integer;

thisone:
numberOfSections:

Integer;
Integer;

aName:

Str255;

BEGIN

{Set the curResFile
to be the resource
fork
UseResFile(thisDocument*.resForkRefNum) ;

{Find

out

the

number

numberOfSections

:=

of

section

of

thisDocument.}

resources. }

Count1lResources(rSectionType) ;

Coen til een fillets till ones tila tit ene

{In determining the number of section/alias resource pairs to
get,
this code only loops for as many sections it finds.
}
It is unusual to have more section resources than alias }

4-20)

resources.

Your

appropriately.
resource
pairs

the

section. }

code

may

You now
to get.

want

have
Loop

Using the Edition Manager

to

check

this

and

handle

it

}

}

a count
of the number
of section/alias
}
to get them,
connect
them,
and register
}

The Edition Manager

FOR

thisone

1

TO

numberOfSections

DO

BEGIN

sectionH

:=

SectionHandle(GetlIndResource(rSectionType,
thisone));

{If sectionH
{ Be sure to
{Get

{

the

is NIL,
something
check
for this.}

resource

alias

with

the

ID

of

same

the

could

section

resource

GetResInfo(Handle(sectionH),

:=

and

resID,

section

and

alias

sectionH**.alias

:=

aliasH;

{Register

the

registerErr

);
but

function

{Add

this

{

AddSectionAliasPair

section/alias

may

is

}

aName);

convenient. }

is

resID));

wrong

}

convenient. }

return

alias

has
to

this

to

your

internal

is

a

routine

to

make
when

of

save.

if

a

this.

section

}

Continue

looping

bookkeeping.

}

accomplish

sectionH,

note

you

error

error.

pair

changed,

know

an

fatal

MyAddSectionAliasPair(thisDocument,
the

the

RegisterSection(thisDocument*.fileSpec,
sectionH,
aliasWasUpdated);

not registered.
This is not a
register remaining sections. }

important

get

}

section. }
:=

RegisterSection

{

file.

together. }

{
{

{If

the

to

rSectionType,

it

{The

The

this

is NIL,
then there could be something
file. Be sure to check for this.}

DetachResource (Handle(aliasH)
{Detaching is not necessary,

is
to

use

with

AliasHandle(GetiResource(rAliasType,

{If aliasH
{ with the

{Connect

wrong

ID. }

DetachResource (Handle(sectionH) );
{Detaching is not necessary,
but it
aliasH

be

}

ps

this.}

ics

resID);
It

is

(>)
ooed
me
“_
wee
—
=~
_
od

}

AliasHasChanged

is

a

<
—
as
=
~
_
a
=

}

{ routine that will do this.}
IF aliasWasUpdated THEN AliasHasChanged(sectionH) ;
END;
END;

oO

-_

{for}
{OpenExistingDocument }

Reading

and

Writing

a Section

Your application writes publisher data to an edition. New publisher data replaces the previous
contents of the edition, making the previous edition information irretrievable. Your application reads data from an edition for each subscriber within a document.

Using the Edition Manager

4-2]

-

Inside Macintosh, Volume VI

The following sections describe how to
= use different formats to write to or read from an edition
= open an edition to initiate writing or reading
m set a format mark
m write to or read from an edition
a close an edition after successfully writing or reading data

Formats

in an

Edition

You can write data to an edition in several different formats. These formats are the same as

Clipboard formats. Clipboard formats are indicated by a four-character tag.

Typically, when a user copies data, you identify the Clipboard formats and then write the data
to scrap. With the Edition Manager, when a user decides to publish data, you identify the
Clipboard formats and then write the data to an edition. You can write multiple formats of the
same data.
For an edition, you should write your preferred formats first. In general, to write data to an
edition, your application should use either 'TEXT' format or 'PICT" format. This allows
your application to share data with most other applications. To subscribe to an edition, your
application should be able to read both 'TEXT' and 'PICT' files. In addition, your application can write any other private formats that you want to support.
Clipboard formats are described in the Scrap Manager chapter in Volume I.
A few special formats are defined as constants.
CONST

kPublisherDocAliasFormat

=

"alis"';

{alias

{
kPreviewFormat
kFormatListFormat

=

record

edition

to

'prvw';

{'PICT'

'fmts';

{lists
all
{ formats}

from

the

}

publisher}

thumbnail

sketch}

available

}

The kPublisherDocAliasFormat (‘alis') format is written by the Edition Manager. It is an alias

record from the edition to the publisher’s document. Appended to the end of the alias is the
section ID of the publisher, which the Edition Manager uses to distinguish between multiple
publishers to a single edition. You should discourage users from making multiple copies of
the same publisher. See “Duplicating Publishers and Subscribers” later in this chapter for
detailed information.

The kPreviewFormat (‘prvw') format should be written by any application that publishes
large amounts of data that may be slow to draw a preview. This format holds a preview of
the edition data that is displayed in the preview area of the subscriber dialog box. This format

4-22

Using the Edition Manager

The Edition Manager

is actually a 'PICT' file that is generated by the publishing application and displays well in a
rectangle of 120 by 120 pixels. You can also use this 'PICT' file to display subscriber data
within a document (to save space).
To draw a preview in the 'prvw' format, the Edition Manager calls DrawPicture with a 120
by 120 rectangle. To draw a preview in the 'PICT' format, the Edition Manager examines the
picture’s bounding rectangle and calls DrawPicture with a rectangle that scales the picture
proportionally and centers it in a 120 by 120 area.
The kFormatListFormat (‘fmts') format is a virtual format that is read but never written. It is
a list of all the formats and their lengths. Applications can use this format in place of the
EditionHasFormat function (described in “Choosing Which Edition Format to Read” later in
this chapter), which provides a procedural interface to determine which formats are available.
If your application can read two or more of the available formats, use 'fmts' to determine the
priority of these formats for a particular edition. The order of 'fmts' reflects the order in
which the formats were written.
The FormatsA vailable data type defines a record for the 'fmts' format.
TYPE

FormatsAvailable

=

ARRAY[0..0]

OF

RECORD
theType:
theLength:

FormatType;
Longint

{format
{length

{

type
for an edition}
of edition
format
}

type}

END;

For example, an edition container may have a format type 'TEXT' of length 100, and
a format type 'styl' of length 32. A subscriber to this edition can open it and then read
the format type 'fmts' to list all available formats. In this example, it returns 16 bytes:
'TEXT' $00000064 'styl' $00000020.

Opening

ae
ies
ao

an Edition

—
—:
—
—
~
_
-_~

For a publisher, use the OpenNewEdition function to initiate the writing of data to an edition.

—

ra
—

ev)

err

:=

OpenNewEdition

(publisherSectionH,

_
~

fdCreator,

publisherSectionDocument,

x
tf)

0)

refNum) ;

—

The publisherSectionH parameter is the publisher section that you are writing to the edition.
The fdCreator parameter is the Finder™ creator type of the new edition icon.
The publisherSectionDocument parameter is the document that contains the publisher. This
parameter is used to create an alias from the edition to the publisher’s document. If you pass
NIL for publisherSectionDocument, an alias is not made in the edition file. The refNum

parameter returns the reference number for the edition.

For a subscriber, use the OpenEdition function to initiate the reading of data from an edition.
err

:=

OpenEdition

(subscriberSectionH,

refNum) ;

Using the Edition Manager

4-23

;

Inside Macintosh,

Volume VI

The subscriberSectionH parameter is a handle to the section record for a given section. The
refNum parameter returns the reference number for the edition.
The user may rename or move the edition in the Finder. Before writing to or reading data
from an edition, the Edition Manager verifies the name of the edition. This process is
referred to as synching or synchronization. Synching ensures that the Edition Manager's
existing edition names correspond to the Finder’s existing edition names by updating the
control block.

Format

Marks

Each format has its own mark. The mark indicates the next position of a read or write operation. Initially, a mark automatically defaults to 0. After reading or writing data, the format
mark is set past the last position written to or read from. The mark is similar to the File
Manager’s current read or write position marker for a data fork. Any time that an edition is
open (after calling the OpenEdition or the OpenNewEdition function), any of the marks for
each format can be queried or set.
To set the current mark for a section format to a new location, use the SetEditionFormatMark
function.
err

:=

SetEditionFormatMark

(whichEdition,

whichFormat,

setMarkTo);

To find where a current mark is for a format in an edition file, use the GetEditionFormatMark
function.
err

:=

GetEditionFormatMark

(whichEdition,

whichFormat,

currentMark) ;

Reading

and Writing

Edition

Data

With the Edition Manager, you can read or write data a few bytes at a time instead of putting
data into one block as the Scrap Manager does. This model is similar to the data fork of a
Macintosh file. You can read sequentially by setting the mark to 0 and repeatedly calling read,
or you can jump to a specific offset by setting the mark there. The Edition Manager also adds
the capability to stream multiple formats by keeping a separate mark for each format. This
allows you to write a few bytes of one format and then write a few bytes of another format,
and so forth.
Once you have opened the edition container for a particular publisher, you can begin writing
data to the edition. Use the WriteEdition function to write publisher data to an edition.
err

:=

WriteEdition

(whichEdition,

whichFormat,

buffPtr,

buffLen);

The WriteEdition function writes the specified format (beginning at the current mark for that
format type) from the buffer pointed to by the buffPtr parameter up to buffLen bytes.
After you open the edition container for a subscriber and determine which formats to read,
use the ReadEdition function to read edition data.
4-24

Using the Edition Manager

The Edition Manager

err

:=

ReadEdition

(whichEdition,

whichFormat,

buffPtr,

buffLen);

The ReadEdition function reads the data with the specified format (whichFormat) from the
edition into the buffer. The ReadEdition function begins reading at the current mark for that
format and continues to read up to buffLen bytes. The actual number of bytes read is returned
in the buffLen parameter. Once the buffLen parameter returns a value smaller than the value
you have specified, there is no additional data to read, and the ReadEdition function returns a
noErr result code.

Closing an Edition
When you are done writing to or reading data from an edition, call the CloseEdition function.
err

:=

CloseEdition

(whichEdition,

successful) ;

Each time a user edits a publisher within a document, you must update the modification date
in the section record (even if the data is not yet written). When the update mode is set to

Manually, the user can compare the modification dates for a publisher and its edition in the
publisher options dialog box. One modification date indicates when the publisher last wrote
data to the edition, and the other modification date indicates when the publisher section was
last edited.
If the successful parameter for a publisher is TRUE, the CloseEdition function makes the
newly written data available to subscribers and sets the modification date in the mdDate field
of the edition to correspond to the modification date of the publisher’s section record. If the
two dates differ, the Edition Manager sends a Section Read event to all current subscribers.
If the successful parameter for a subscriber is TRUE, the CloseEdition function sets the
modification date of the subscriber’s section record to correspond to the modification date of
the edition.
If you cannot successfully read from or write data to an edition, set the successful parameter

to FALSE. For a publisher, data is not written to the edition, but it should still be saved with
the document that contains the section. When the document is next saved, data can then be

written to the edition. See “Closing an Edition After Reading or Writing” later in this chapter
for additional information on the CloseEdition function.

>
eo)
2.

=
5

<—
g

2
go©

er

Creating

a

Publisher

You need to support a Create Publisher menu command in the Edit menu. When a user selects
a portion of a document and chooses Create Publisher from this menu, you should display the
publisher dialog box on the user’s screen. The Create Publisher menu command should
remain dimmed until the user selects a portion of a document.
Use the NewPublisherDialog function to display the publisher dialog box on the user’s
screen. This function is similar to the CustomPutFile procedure described in the Standard
File Package chapter in this volume.
err

:=

NewPublisherDialog

(reply);

Using the Edition Manager

4-25

Inside Macintosh, Volume VI

The dialog box contains space for a preview (a thumbnail sketch) of the edition and a
space for the user to type in the name of the edition in which to write the publisher data.
Figure 4-11 illustrates a sample publisher dialog box.
|<) Editions w|

Preview

<

WA

Loma Prieta

Lieet

[>

© sales data
{3 sales report

|

Desktop

pS

1

—_

Name

of new

edition:

|Simple graphiq

|

Figure 4-11. A sample publisher dialog box
The NewPublisherDialog function displays the preview (provided by your application), a text
box with the default name of the edition (provided by your application), and handles all user
input until the user clicks Publish or Cancel.
You pass a new publisher reply record as a parameter to the NewPublisherDialog function.
TYPE

NewPublisherReply
RECORD
canceled:

=

replacing:

usePart:

preview:

previewFormat:

container:

Boolean;

{user

Boolean;

{always

FormatType;

{ 'TEXT',
or
‘snd'
{type of preview}

Boolean;
Handle;

canceled

dialog

box}

{user chose existing }
{ filename for an edition}
{handle

EditionContainerSpec

FALSE

to

in

'prvw',

version

{edition

'PICT',

7.0}

data}

}

chosen}

END;

You fill in the usePart, preview, previewFormat, and container fields of the new publisher
reply record.
Always set the usePart field to FALSE. The preview field contains either NIL or the data to
display in the preview. The previewFormat field should contain 'PICT', 'TEXT'’, or 'prvw'.
Set the container field to be the default name and folder for the edition. The default name
should reflect the data contained in the publisher. For example, if a user publishes a bar chart

of sales information entitled “sales data,” then the default name for the edition could also

be “‘sales data.” Otherwise, you should use the document name followed by a hyphen (-)
and a number to establish uniqueness. For example, your default name could be “January
Totals - 3.”
If the document has not been saved, the default name should be “untitled edition <>” where
nis anumber to establish uniqueness. The default folder should be the same as the edition for
the last publisher created in the same document. If this is the first publisher in the document,
the default folder should be the same folder that the document is in.
4-26

Using the Edition Manager

The Edition Manager

The canceled field of the new publisher reply record indicates whether the user canceled from
the dialog box. The replacing field indicates that the user chose to replace an existing edition
= If aE
ne returns FALSE, call the CreateEditionContainerFile function to create an
edition file.
The container field is of data type EditionContainerSpec.
TYPE

EditionContainerSpec

=

RECORD

theFile:

FSSpec;

theFileScript:
thePart:

ScriptCode;
Longint;

thePartName:

Str3il¢

thePartScript:

ScriptCode

{file containing
edition
{ data}
{script
code of filename}
{which part of file,
}
{ always
kPartsNotUsed}

{not
{not

used
used

in
in

version
version

}

7.0}

7.0}

END;

The field theFile is of type FSSpec. See the File Manager chapter in this volume for further
information on file system specification records.
You identify the edition using a volume reference number, directory ID, and filename. When
specifying an edition, follow the standard conventions described in the File Manager chapter
of this volume.
After filling in the fields of the new publisher reply record, pass it as a parameter to the
NewPublisherDialog function, which displays the publisher dialog box.
err

:=

NewPublisherDialog

(reply);

After displaying the publisher dialog box, use the CreateEditionContainerFile function to create
the edition container, and then use NewSection function to create the section record and the

alias record. See “Creating the Section Record and Alias Record”

detailed information.

earlier in this chapter for

In response to the user selecting the Create Publisher menu item, this code illustrates how
your application might set up the preview for the edition, set the default name for the edition
container, and call an application-defined function (DoNewPublisher function) to display the
publisher dialog box on the user’s screen. An application might call the DoNewPublisher
function as a result of the user making a menu selection to create a publisher or in response to
handling the Create Publisher event. See the Apple Event Manager chapter in this volume for
an example handler that handles the Create Publisher event.
VAR

thisDocument:

promptForDialog:
preview:
previewFormat:
defaultLocation:

MyDocumentInfoPtr;

Boolean;
Handle;
FormatType;
EditionContainerSpec;

BEGIN

{Get a preview
to show the user.
The MyGetPreviewForSelection
{ function
returns
a handle
to the preview. }
preview
:= MyGetPreviewForSelection(thisDocument) ;
previewFormat
:=
'TEXT';

Using the Edition Manager

}

4-27

des
—
\*J

lan!
—
rs
loom
be ©

°

~
—

a

—
as
~

_
as
~
_—

go

oO
_

.

Inside Macintosh,

Volume VI

defaultLocation

:=

MyGetDefaultEditionSpec(thisDocument) ;

:= TRUE;
promptForDialog
:= DoNewPublisher(thisDocument,
myErr

previewFormat,

promptForDialog,

.
preview,

defaultLocation) ;

END;

Creating

the Edition

Container

Use the CreateEditionContainerFile function to create an edition container to hold the

publisher data.
err

:=

CreateEditionContainerFile

(editionFile,
fdCreator,
editionFileNameScript) ;

This function creates an edition container. The edition container is empty (that is, it does not
contain any formats) at this time.
To create a customized icon for the edition container, put the creator signature of your application with the icon in your application’s bundle. See the Finder Interface chapter in this
volume for additional information. Depending on the contents of the edition, the file type will
be 'edtp' (for graphics), ‘edtt' (for text), or 'edts' (for sound).

After creating the edition container, use the NewSection function to create the section record
and alias record for the section.
Listing 4-4 illustrates how to create a publisher. The DoNewPublisher function shown in the
listing is a function provided by an application. Note that an application might call the
DoNewPublisher function as a result of the user making a menu selection to create a publisher
or in response to handling the Create Publisher event. See the Apple Event Manager chapter in
this volume for an example handler that handles the Create Publisher event.
The parameters to the DoNewPublisher function include a pointer to information about the
document, a Boolean value that indicates if the function should display the new publisher
dialog box, the preview for the edition, the preview format, and an edition container.
The function displays the publisher dialog box if requested, letting the user accept or
change the name of the edition and the location where the edition should reside. Use the
CreateEditionContainerFile function to create the edition with the given name and location.
Use the NewSection function to create a new section for the publisher.
After the section is created, you must write out the edition data. Be sure to add the newly
created section to your list of sections for this document. There are several different
techniques for creating publishers and unique IDs; this listing displays one technique.
Listing 4-4. Creating a publisher
FUNCTION

DoNewPublisher(thisDocument:
MyDocumentInfoPtr;
promptForDialog:
Boolean;
preview:
previewFormat:
FormatType;
editionSpec:
EditionContainerSpec)

VAR

getLastErr,
createErr,

4-28

dialogErr:
sectionErr:

OSErr;
OSErr;

Using the Edition Manager

Handle;
:

OSErr;

The Edition Manager

resID:

Integer;

thisSectionH:
reply:

SectionHandle;
NewPublisherReply;

BEGIN

{Set up info
for new publisher
reply.replacing
:= FALSE;
reply.usePart
:= FALSE;

reply.preview

:=

reply.container

:=

:=

promptForDialog

:=

previewFormat;

editionSpec;
THEN

BEGIN

dialogErr

record}

preview;

reply.previewFormat
IF

reply

{user
{Display

interaction

dialog

NewPublisherDialog(reply) ;

box

and

is

allowed}

let

user

select. }

{Dispose of preview data handle.}
DisposHandle(reply.preview) ;

{There's usually no error returned here, but if there is,
}
{ then it makes no sense to continue with this operation. }
IF dialogErr <> noErr THEN MyErrHandler (dialogErr) ;
{Do nothing if user canceled. }
IF

reply.canceled

THEN

BEGIN

DoNewPublisher
:= userCanceledErr;
EXIT (DoNewPublisher) ;
END;
END;

{If

IF

user

NOT

wants

to

replace

reply.replacing

BEGIN
createErr

an

THEN

existing

file,

don't

create

one.}

:=

CreateEditionContainerFile(reply.container.theFile,
kAppSignature,

{If

IF

the

create

createErr

<>

failed,
noErr

BEGIN

DoNewPublisher
EXIT

:=

then

THEN

reply.container.theFileScript) ;

this

operation

can't

be

completed}

cos
=
~
cont
—
—
mal
_s
~
=
=
~

errAEPermissionDenied;

(DoNewPublisher) ;

END;
END;

{Advance

counter

to

make

a

new

{ document.
It is not required
{ resources. }
thisDocument*.nextSectionID
:=

unique
that

sectionID

you

equate

for

this

section

2
—
as
~
_
se
as
~

}
IDs

thisDocument*.nextSectionID

with
+

tf°)

}

‘c

dl

1;

{Create a publisher
section. }
sectionErr
:= NewSection(reply.container,
thisDocument*.fileSpecPtr,

stPublisher,

IF

(sectionErr
(sectionErr

<>
<>

pumOnSave,

noErr)
& (sectionErr <> multiplePublisherWrn)
notThePublisherWrn)
THEN

{If a new section
could
{ operation. }
MyErrHandler (sectionErr)
resID

:=

thisDocument*.nextSectionID,

thisSectionH) ;

not

be

created,

don't

continue

with

&
this

}

;

thisDocument’®.nextSectionID;

(Continued)

Using the Edition Manager

4-29

;

Inside Macintosh, Volume VI

Listing 4-4. Creating a publisher (Continued)
{Add this
section/alias
pair
{ The AddSectionAliasPair
is

to my internal
bookkeeping.
}
a routine
to accomplish
this.}

{Write out
first
edition. }
DoWriteEdition(thisSectionH,

thisDocument) ;

AddSectionAliasPair(thisDocument,

thisSectionH,

{Remember
that
the section and alias
records
when the user
saves
the
{ saved as resources
{Set

the

function

DoNewPublisher
END;

:=

result

resID);

need to be
document. }

}

appropriately}

MyGetLastError;

{DoNewPublisher}

Opening

an Edition Container to Write Data

Several routines are required to write (publish) data from a publisher to an edition container.
Before writing data to an edition, you must use the OpenNewEdition function. This function
should be used only for a publisher within a document. Use this function to initiate the
writing of data to an edition.
err

:=

OpenNewEdition

(publisherSectionH,

fdCreator,

publisherSectionDocument,

refNum) ;

A user may try to save a document containing a publisher that is unable to write its data to an
edition—because another publisher (that shares the same edition) is writing, another subscriber
(that shares the same edition) is reading, or a publisher located on another computer is registered to the section. In such a case, you may decide to refrain from writing to the edition so
that the user does not have to wait. You should also refrain from displaying an error to the
user. The contents of the publisher are saved to disk with the document. The next time that the
user saves, you can write the publisher data to the edition. You should discourage users from
making multiple copies of the same publisher and pasting them in the same or other documents
by displaying an alert box (see “Duplicating Publishers and Subscribers” later in this chapter).
If a user clicks Send Edition Now within the publisher options dialog box (to write publisher

data to an edition manually), and the publisher is unable to write its data to its edition (for any

of the reasons outlined above), you should display an error message.

After you are finished writing data to an edition, use the CloseEdition function to close
the edition.
Listing 4-5 illustrates how to write data to an edition. As described earlier, you must open the
edition, write each format using the WriteEdition function, and close the edition using the
CloseEdition function. This listing shows how to write text only. If the edition is written
successfully, subscribers receive Section Read events.
Listing 4-5. Writing data to an edition
PROCEDURE

DoWriteEdition(thePublisher:

VAR
eRefNum:
openErr:

4-30

EditionRefNum;
OSErr;

Using the Edition Manager

SectionHandle) ;

The Edition Manager

writeErr:
closeErr:

OSErr;
OSErr;

thisDocument:

MyDocumentInfoPtr;

textHandle:

Handle;

BEGIN

{Find out which document
this
section belongs
to.
{ The FindDocument
function accomplishes
this. }
thisDocument
:= FindDocument (thePublisher) ;

{Open

edition

openErr

:=

IF

openErr

{If

the

for

}

writing. }

OpenNewEdition(thePublisher,
kAppSignature,
thisDocument’.fileSpecPtr,
eRefNum) ;
<> noErr THEN

open

failed,

then

{ so don't
continue with
MyErrHandler (openErr) ;

you

this

can't

write,

operation. }

}

{Get the text data to write.
The GetTextInSection
}
{ function
accomplishes
this. }
textHandle
:= GetTextInSection(thePublisher,
thisDocument) ;

{Write

HLock

out

text

(textHandle)

writeErr

:=

data.}
;

WriteEdition(eRefNum,

HUnLock (textHandle) ;
IF writeErr
<> noErr

'TEXT',

textHandle”%,

GetHandleSize(textHandle));
THEN

BEGIN

{There were problems
writing;
simply
close
the edition.
}
= FALSE,
the edition data <> section data.
{ When successful
{ Note:
this
isn't
fatal or bad;
it just means
that
the
}
{ data wasn't
written
and no Section
Read events will
be }
{ generated. }
closeErr
:= CloseEdition(eRefNum,
FALSE);
END

}

ELSE

pas

BEGIN

{The write was successful;
now close
the edition.
}
{ When
successful
= TRUE,
the edition data
= section
data.
}
{ This edition
is now available
to any subscibers.
}
{ Section Read events will be sent
to current
subscribers. }
closeErr
:= CloseEdition(eRefNum,
TRUE);

|

—e

—_-

ee

=~
~

~

a

—
iS
—

=

as
_

END;

END;

1°)

@

{DoWriteEdition}

Creating

iw

Qa.

“|

a Subscriber

You need to create a Subscribe To menu command in the Edit menu. When a user chooses

Subscribe To from this menu, your application should display the subscriber dialog box on

the user’s screen.

Use the NewSubscriberDialog function to display the subscriber dialog box on the user’s
screen. This function is similar to the CustomGetFile procedure described in the Standard
File Package chapter in this volume.
To create a subscriber, you must get information from the user, such as the name of the

edition being subscribed to. The dialog box displays a listing of all available editions and
Using the Edition Manager

4-3]

Inside Macintosh,

Volume VI

allows the user to see a preview (thumbnail sketch) of the edition selected. Figure 4-12

shows a sample subscriber dialog box.
Preview

|&j Editions w|

= Loma Prieta

£3 Simple graphic
©

sales data

{3 sales report

Desktop

ry

( Subscribe ]

Figure 4-12. A sample subscriber dialog box
The subscriber dialog box allows the user to choose an edition to subscribe to. The
NewSubscriberDialog function handles all user interaction until a user clicks Subscribe
or Cancel. When a user selects an edition container, the Edition Manager accesses the
preview for the edition container (if it is available) and displays it.
You pass a new subscriber reply record as a parameter to the NewSubscriberDialog function.
TYPE

NewSubscriberReply

=

RECORD

canceled:
formatsMask:

Boolean;
SignedByte;

{user canceled
dialog
{formats
required}

container:

EditionContainerSpec

{edition

box}
selected}

END;

The canceled field returns a Boolean value of TRUE if the user clicked Cancel. To indicate

which edition format types (text, graphics, or sound) your application can read, you set the

A;

{Can subscribe
to
{ 'TEXT',
and
}
{

'snd

'.

'PICT',

}

w

1;

i

ksndFormatMask

=

NO)

kPICTformatMask
kKTEXT£formatMask

Ss

CONST

i

formatsMask field to one or more of these constants:

To support a combination of formats, add the constants together. For example, a formatsMask
of 3 displays both graphics and text edition format types in the subscriber dialog box.
The container field is of data type EditionContainerSpec. You must initialize the container
field with the default edition volume reference number, directory ID, filename, and part. To
do so, use the GetLastEditionContainerUsed function to obtain the name of the last edition
displayed in the dialog box.
err

:=

GetLastEditionContainerUsed

(container) ;

This function returns the last edition container for which a new subscriber was created

using the NewSection function. If there is no last edition, or if the edition was deleted,

4-32

Using the Edition Manager

The Edition Manager

GetLastEditionContainerUsed still returns the correct volume reference number and
directory ID to use, but leaves the filename blank and returns the fnfErr result code.

The container field is of data type EditionContainerSpec.
TYPE

EditionContainerSpec

=

RECORD

theFile:

FSSpec;

{file

theFileScript:

ScriptCode;

{ data}
{script

containing

thePart:

Longint;

{which

thePartName:

Str31;

{ always
kPartsNotUsed}
{not
used
in version
7.0}

thePartScript:

ScriptCode

{not

code
part

used

of
of

in

edition

}

filename}
file,

version

}

7.0}

END;

The field theFile is of type FSSpec. See the File Manager chapter in this volume for further
information on file system specification records.
After filling in the fields of the new subscriber reply record, pass it as a parameter to the
NewSubscriberDialog function, which displays the subscriber dialog box.
err

:=

NewSubscriberDialog

(reply);

After displaying the subscriber dialog box, call the NewSection function to create the section
record and the alias record. See “Creating the Section Record and Alias Record” earlier in this
chapter for detailed information.
If the subscriber is set up to receive new editions automatically (not manually), the Edition
Manager sends your application a Section Read event. Whenever your application receives a
Section Read event, it should read the contents of the edition into the subscriber.
Listing 4-6 illustrates how to create a subscriber. As described earlier, you must set up and
display the subscriber dialog box to allow the user to subscribe to all available editions. After
your application creates a subscriber, your application receives a Section Read event to read in
the data being subscribed to. Be sure to add the newly created section to your list of sections
for this file. There are many different techniques for creating subscribers and unique IDs; this
listing displays one technique.
Listing 4-6. Creating a subscriber
PROCEDURE

DoNewSubscriber

(thisDocument:

MyDocumentiInfoPtr) ;

VAR

getLastErr:
dialogErr:
sectionErr:

OSErr;
OSErr;
OSErr;

resID:

Integer;

thisSectionH:
reply:

SectionHandle;
NewSubscriberReply;
(Continued)

Using the Edition Manager

4-33

+
ce
a.
=
=
=
2—
oo
=
g
re
©
ar

Inside Macintosh,

Volume VI

Listing 4-6. Creating a subscriber (Continued)
BEGIN

{Put default
edition name into reply
record.}
getLastErr
:= GetLastEditionContainerUsed(reply.container) ;

{Can subscribe to
reply.formatsMask
{Display

dialog

pictures or text.}
:= kPICTformatsMask

box

and

let

user

+

kTEXTformatsMask;

select.}

dialogErr
:= NewSubscriberDialog(reply) ;
{There's usually no error returned here, but if there is,
{ then it makes no sense to continue with this operation.
{ Pass control
to MyErrHandler. }
IF dialogErr
<> noErr THEN MyErrHandler
{Do

IF

nothing

if

user

reply.canceled

{Advance

counter

{

document.

It

{

resources. }

to

;

canceled. }

THEN

is

(dialogErr)

EXIT (DoNewSubscriber) ;

make

not

a

new

necessary

thisDocument*.nextSectionID

:=

unique
to

sectionID

equate

for

section

this

IDs

created,
control

don't
continue with
to MyErrHandler.}

}

with

}

thisDocument*.nextSectionID

+

{Create a subscriber section. }
sectionErr
:= NewSection(reply.container,
thisDocument®.fileSpecPtr,
stSubscriber,
thisDocument*.nextSectionID,
sumAutomatic,
thisSectionH) ;
IF sectionErr <> noErr THEN
{Same reasoning as above.
If a new section could not be
{
{

}
}

this

operation.

Pass

1;

}

}

MyErrHandler(sectionErr) ;
resID

:=

{Add

this

thisDocument*.nextSectionID;
section/alias

pair

to

your

internal

bookkeeping.

}

{ AddSectionAliasPair is a routine to accomplish this. }
AddSectionAliasPair(thisDocument,
thisSectionH,
resID);
{Remember
that you will
receive a Section
{ in the edition
that you just subscribed
{

mode

is

set

{Remember
that
{ as resources
END;

4-34

to

Read event
to because

to read
}
the initial

sumAutomatic. }

the section and alias
records
need
when
the user saves
the document.}

{DoNewSubscriber}

Using the Edition Manager

to

be

saved

}

}

The Edition Manager

Opening

an Edition Container to Read

Data

Before reading data from an edition, you must use the OpenEdition function. Your application should only use this function for a subscriber. Use this function to initiate the reading of
data from an edition.
err

:=

OpenEdition

(subscriberSectionH,

refNum);

As a precaution, you should retain the old data until the user can no longer undo. This allows
you to undo changes if the user requests it.
Your application can supply a procedure such as DoReadEdition to read in data from the
edition to a subscriber. When your application opens a document containing a subscriber
that is set up to receive new editions automatically, the Edition Manager sends you a Section
Read event if the edition has been updated. The Section Read event supplies the handle to
the section that requires updating. Listing 4-7 provides an example of reading data from
an edition.

Choosing

Which

Edition Format to Read

After your application opens the edition container for a subscriber, it can look in the edition
for formats that it understands. To accomplish this, use the EditionHasFormat function.
err

:=

EditionHasFormat

(whichEdition,

whichFormat,

formatSize) ;

The EditionHasFormat function returns the noTypeErr result code if a requested format
is not available. If the requested format is available, this function returns the noErr result
code, and the formatSize parameter contains the size of the data in the specified format or
kFormatLengthUnknown (1), which signifies that the size is unknown.
4+

After your application opens the edition container and determines which formats it wants to
read, call the ReadEdition function to read in the edition data. See “Reading and Writing
Edition Data” earlier in this chapter for detailed information.
After you have completed writing the edition data into the subscriber section, call the
CloseEdition function to close the edition. See “Closing an Edition” earlier in this chapter
for detailed information.

a.
st
°
5
i
=
=|

=
tjo)

‘ic

Lew

Listing 4-7 illustrates how to read data from an edition. As described earlier, you must open
the edition, determine which formats to read, use the ReadEdition function to read in data,

and then use the CloseEdition function to close the edition. This listing shows how to read
only text.

Using the Edition Manager

ea)

4-35

|

Inside Macintosh, Volume VI

Listing 4-7. Reading in edition data
PROCEDURE

DoReadEdition(theSubscriber:

SectionHandle) ;

VAR

eRefNum:

EditionRefNum;

openErr:

OSErr;

readErr:
closeErr:
thisDocument:

OSErr;
OSErr:
MyDocumentInfoPtr;

textHandle:

Handle;

formatLen:

Size;

BEGIN

{Find

out

{

FindDocument

The

which

thisDocument

document

:=

this

function

section

FindDocument

openErr

{If

the

{

don't

so

<>

open

noErr

to.

}

this.}

(theSubscriber)

{Open the edition for reading. }
openErr
:= OpenEdition(theSubscriber,
IF

belongs

accomplishes

;

eRefNum) ;

THEN

failed,

then

continue

with

most

this

likely

you

can't

read,

}

operation. }

MyErrHandler(openErr) ;
{Look

for

'TEXT'

format.}

IF EditionHasFormat
BEGIN

(eRefNum,

'TEXT',

formatLen)

=

noErr

THEN

{Get the handle of location to read to.
}
{ The GetTextInSection function accomplishes this. }
textHandle
:= GetTextInSection(theSubscriber,
thisDocument) ;
SetHandleSize(textHandle,
formatLen) ;
HLock

(textHandle)

readErr

:=

;

ReadEdition(eRefNum,

'TEXT',

textHandle”,

formatLen) ;
HUnLock

(textHandle)

IF readErr
BEGIN

=

noErr

;
THEN

{The read was successful;
now close the edition.
}
the section data = edition
{ When successful = TRUE,
closeErr
:= CloseEdition(eRefNum,
TRUE);
EXIT

data. }

(DoReadEdition) ;

END;
END;

{'TEXT'

format

wasn't

found

or

read

error;

just

{ the edition.
FALSE
tells
the Edition Manager
{ did not get the latest
edition. }
closeErr
:= CloseEdition(eRefNum,
FALSE);
END;

4-36

{DoReadEdition}

Using the Edition Manager

close
that

}

your

application

}

The Edition Manager

Using

Publisher and Subscriber Options

There are special options associated with publishers and subscribers within documents. Your
application can use the publisher and subscriber options dialog boxes provided by the Edition
Manager to make these choices available to the user. You should make these dialog boxes
available to the user by creating a menu command in the Edit menu that toggles between
Publisher Options (when the user has selected a publisher within a document) and Subscriber
Options (when a user has selected a subscriber within a document).

When a user chooses these menu commands, you need to display the corresponding publisher
or subscriber options dialog box. Use the SectionOptionsDialog function to display the appropriate dialog box on the user’s screen.
err

:=

SectionOptionsDialog

(reply);

Each dialog box contains information regarding the section and its edition. Figure 4-13
shows the publisher options dialog box with the update mode set to On Save.

Publisher to:

| <3 Simple graphic Bd!

-Send Editions:
@ On Save

© Manually
Latest Edition:

{ Cancel Publisher
{ Send Edition Now
Tuesday , October

|

|

17, 1989 5:04:00 PM

Figure 4-13. The publisher options dialog box with update mode set to On Save

x

Figure 4-14 shows the publisher options dialog box with the update mode set to Manually.

S
st.
°
5
4
&
=iss]

Publisher
«Send

to:

| £3 Simple

graphic

—

v|

ga

Editions:

© On Save

@® Manually
Latest Edition:
Last Change:

cs)
co

|

( Send Edition Now
Monday, June 18, 1990 4:21:39 PM
Monday, June 18, 1990 4:21:39 PM

Cancel

&

Publisher

|
| Cancel

Figure 4-14. The publisher options dialog box with update mode set to Manually
As a shortcut for the user, you should display the publisher options dialog box when the user
double-clicks on a publisher section within a document.

Using the Edition Manager

4-37

Inside Macintosh,

Volume VI

Figure 4-15 shows the subscriber options dialog box with the update mode set to
Automatically.

Subscriber to: |

Simple graphic v]

aes Se
@ Automatically

{ Cancel Subscriber |

© Manually

Latest Edition:

{ GetEditionNow

Tuesday, October

|

[ OpenPublisher

|

17, 1989 5:04:00 PM

[ Cancel

|

(

OK

Figure 4-15. The subscriber options dialog box with update mode set to Automatically
Figure 4-16 shows the subscriber options dialog box with the update mode set to Manually.
Subscriber to: | £2 Simple graphic wv]
Maal

adie ;

[ Cancel Subscriber |

© Automatically

@ Manually
Latest Edition:

Last Received:

{ GetEditionNow |

Monday, June 18, 1990 4:17:33 PM

Monday, June 18, 1990 4:17:33 PM

[

OpenPublisher

|

Cancel

Figure 4-16. The subscriber options dialog box with update mode set to Manually
As a shortcut for the user, you should display the subscriber options dialog box when the
user double-clicks on a subscriber section within a document.
You pass a section options reply record as a parameter to the SectionOptionsDialog function.
TYPE

SectionOptionsReply

=

RECORD

canceled:

Boolean;

{user

changed:

Boolean;

{changed

section

sectionH:

SectionHandle;

{handle

to

ResType

{ section
record}
{action codes}

action:

canceled

the

dialog

box}

record}

specified

}

END;

Set the sectionH parameter to the handle to the section record for the section the user selected.
Upon return of the SectionOptionsDialog function, the canceled and changed fields are set. If
the canceled parameter is set to TRUE, the user canceled the dialog box. Otherwise, this
parameter is FALSE. If the changed parameter is TRUE, the section record is changed. For
example, the user may have changed the update mode.
4-38

Using the Edition Manager

The Edition Manager

The action parameter contains the code for one of five user actions. All action codes dismiss
the publisher and subscriber options dialog boxes when complete.
m action code is 'read' for user selection of the Get Edition Now button
m action code is 'writ' for user selection of the Send Edition Now button
m action code is 'goto' for user selection of the Open Publisher button
m action code is 'cncl' for user selection of the Cancel Publisher or Cancel Subscriber button
m

actioncodeis'

'($20202020) for user selection of the OK button

Listing 4-8 shows an example of how your application can respond to the action codes
received from the section options reply record. There are several different techniques that
your application can use to accomplish this—this listing shows one technique.
Listing 4-8. Responding to action codes
PROCEDURE

DoOptionsDialog(theSection:

SectionHandle) ;

VAR

reply:

SectionOptionReply;

theEditionInfo:
action:

EditionInfoRecord;
ResType;

sodErr:

OSErr;

geiErr:

OSErr;

gpiErr:

OSErr;

BEGIN

reply.sectionH
sodErr

:=

{Determine
IF

:=

theSection;

b

SectionOptionsDialog(reply) ;
what

the

user

did

and

reply.canceled
THEN
{The user changed his/her

handle

=

=

appropriately. }

mind;

simply

changed;

make

routine

to

accomplish

to

do

=
5

return. }

<

f
=|
65
ge
a
=

EXIT (DoOptionsDialog) ;
IF

reply.changed
THEN
{The section
record

has

{

is

SectionHasChanged

SectionHasChanged

(theSection)

{If

you

customize,

action

:=

reply.action;

IF

(action

BEGIN

{User

=

a

you

'read')

THEN

selected

Get

may

Edition

of

this.

}

this. }

;

want

{Get

note

the

Now

action

some

post-processing

now.}

code. }

button. }

DoReadEdition(theSection) ;
EXIT (DoOptionsDialog) ;
END;

(Continued)

Using the Edition Manager

4-39

Inside Macintosh, Volume VI

Listing 4-8. Responding to action codes (Continued)
IF

(action

BEGIN

=

{User

'writ')

THEN

selected

Send

Edition

Now

button. }

DoWriteEdition(theSection) ;
EXIT

(DoOptionsDialog) ;

END;

IF
(action
= 'goto')
BEGIN
{User selected
geiErr

:=

THEN
Open

{There's

usually

no

{

is,

don't

IF

there

geiErr

gpsErr
{Same

then

<>

:=

Publisher

button. }

GetEditionInfo(theSection,

noErr

error

returned

continue

THEN

theEditionInfo);
here,

with

but

this

if

}

operation. }

MyErrHandler(geiErr) ;

GotoPublisherSection(theEditionInfo.container) ;

comment

{ if there's
IF gpsErr
<>

as

above.

an error. }
noErr THEN

Pass

control

to

MyErrHandler

}

MyErrHandler(gpsErr) ;

EXIT (DoOptionsDialog) ;
END;

IF

(action

BEGIN

{Call

{

=

{User
the

section

‘'cncl')

THEN

selected

Cancel

Publisher

UnRegisterSection

record

and

the

function

alias

or

Cancel
and

Subscriber

dispose

of

the

button. }
}

record. }

EXIT (DoOptionsDialog) ;
END;

END;

{DoOptionsDialog}

The following sections describe the features of the publisher and subscriber options
dialog boxes.

Publishing

a New

Edition While Saving or Manually

By default, your application should write publisher data to an edition each time the user
saves the document and the contents of the publisher differ from the latest edition. In the
publisher options dialog box, the user can choose to write new data to an edition each time
the document is saved (by clicking On Save) or only when the user specifically requests it
(by clicking Manually).
When the update mode is set to manual, a user must click the Send Edition Now button
within the publisher options dialog box to write publisher data to an edition. When a user
clicks Send Edition Now, the section options reply record contains the action code ‘writ’.
Write out the new edition beginning with the OpenNewEdition function. Writing to an edition
manually is useful when a user tends to save a document numerous times while revising it.

4-40

Using the Edition Manager

The Edition Manager

Each time the user saves the document, check the update mode of the publisher section. If the
publisher section sends its data to an edition on save, check to see whether the publisher data
has changed since it was last written out to the edition. If so, write out the new edition.
In addition, you may also support a Stop All Editions menu command to provide a method
for temporarily suspending all update activity. See “Publishers, Subscribers, and Editions”
earlier in this chapter for additional information.

Subscribing to an Edition Automatically or Manually
By default, your application should subscribe to an edition each time new edition data becomes
available. In the subscriber options dialog box, the user can choose to read new data from an
edition as the data is available (by clicking Automatically) or only when the user specifically
requests it (by clicking Manually).
When the update mode is set to manual, the user must click the Get Edition Now button
within the subscriber options dialog box to receive new editions. When a user clicks this
button, the section options reply record contains the action code ‘read’. Read in the new
edition beginning with the OpenEdition function. See “Opening an Edition Container to
Read Data” earlier in this chapter for detailed information.
When the update mode is set to automatic, your application receives a Section Read event
each time a new edition becomes available. In response, you should read the new edition
data beginning with the OpenNewEdition function.
Your application does not receive Section Read events for subscribers that receive new
editions manually.
You may also support a Stop All Editions menu command to provide a method for
temporarily suspending all update activity. See “Publishers, Subscribers, and Editions”
earlier in this chapter for additional information.

Canceling

Sections

Within

oe

G2)

Documents

=

The option of canceling publishers and subscribers is available to the user through the Cancel
Publisher and Cancel Subscriber buttons in the corresponding options dialog boxes. When

the user wants to cancel the publisher or cancel the subscriber within a document, the action

code of the section options reply record is 'cncl’. See “Relocating an Edition” later in this
chapter for additional information on canceling a section.

os

2

—

~
=

a
ne

ge
c

—

When a user cancels a section (either a publisher or subscriber) and then saves the document,
or when a user closes an untitled document (which contains newly created sections) without
saving, you must unregister each corresponding section record and alias record using the
UnRegisterSection function. In addition, you should also delete the section record and alias
record using the DisposHandle procedure. See the Memory Manager chapter in Volume I for
additional information on the DisposHandle procedure.

Using the Edition Manager

os
pae
~
-_~

4-4]

Inside Macintosh,

Volume VI

When a user cancels a publisher section and then saves the document, or when a user closes
an untitled document (which contains newly created publishers) without saving, you must
also delete any corresponding edition containers (in addition to deleting section records and
alias records).

Do not delete an edition container file, section record, or alias record until the user saves the

document—the user may decide to undo changes before saving the document.

To locate the appropriate edition container to be deleted (before you use the UnRegisterSection
function), use the GetEditionInfo function.
err

:=

GetEditionInfo

(sectionH,

editionInfo);

The editionInfo parameter is a record of data type EditionInfoRecord.
TYPE

EditionInfoRecord

=

RECORD

crDate:

TimeStamp;

{date

edition

{

created}

was

mdDate:

TimeStamp;

{date

of

fdCreator:

OSType;

{file

creator}

last

fdType:

OSType;

{file

type}

container:

EditionContainerSpec

container

}

change}

{the

edition}

END;

The GetEditionInfo function returns the edition container as part of the edition information.
The crDate field contains the creation date of the edition. The mdDate field contains the modification date of the edition.

The fdType and the fdCreator fields are the type and creator of the edition file. The container
field includes a volume reference number, directory ID, filename, script, and part number for
the edition.
To remove the edition container, use the DeleteEditionContainerFile function.
err

:=

DeleteEditionContainerFile

Locating

a Publisher Through

(editionFile) ;

a Subscriber

The user can locate a publisher from a subscriber within a document by clicking the Open
Publisher button in the subscriber options dialog box. As a shortcut, Apple suggests that you
also allow the user to locate a publisher when the user selects a subscriber within a document
and presses Option—double-click.

4-42

Using the Edition Manager

The Edition Manager

When the action code of the SectionOptionsReply record is 'goto', use the
GoToPublisherSection function.
err

:=

GoToPublisherSection

(container);

The GoToPublisherSection function locates the correct document by resolving the alias in the
edition, and it launches the document’s application if necessary (the Edition Manager sends an
Open Documents event). The Edition Manager then sends the publishing application a Section
Scroll event. If the document containing the requested publisher is located on the same computer as its subscriber, the document opens and scrolls to the location of the publisher. If the
document containing the requested publisher is located on a shared volume (using file sharing),
the document opens and scrolls to the location of the publisher only if the user has privileges
to open the document from the Finder.
You need to provide the GoToPublisherSection function with the edition container. To
accomplish this, use the GetEditionInfo function. See the previous section, “Canceling
Sections Within Documents,” for information on the GetEditionInfo function.

Renaming

a Document

Containing

Sections

If a user renames a document that contains sections by choosing Save As from the File menu,
or if a user pastes a portion of a document that contains a section into another document, use
the AssociateSection function.
Use the AssociateSection function to update the alias record of a registered section.
err

:=

AssociateSection

(sectionH,

newSectionDocument) ;

The AssociateSection function internally calls the UpdateAlias function. It is also possible to
update the alias record using the Alias Manager (see the Alias Manager chapter in this volume
for additional information).

Displaying

Publisher and Subscriber

aS
=

So.

et.©

Borders

=

Each publisher and subscriber within a document should have a border that appears when a
user selects the contents of these sections. You should display a publisher border as 3 pixels
wide with 50 percent gray lines and a subscriber border as 3 pixels wide with 75 percent gray
lines. Separate the contents of the section from the border itself with one pixel of white space.
To create your borders, you should use patterns—not colors. Depending on the user’s
monitor type, colors may not be distinguishable.

Using the Edition Manager

4-43

4
—
$9
=
ey
7
@

“

Inside Macintosh,

Volume VI

In general, borders for publishers and subscribers should behave like the borders of ‘PICT’
graphics within a word-processing document. A border should appear when the user clicks
within the content area of a publisher or a subscriber and disappear when the user clicks
outside the content area of a section. You can also make all publisher and subscriber borders
appear or disappear by implementing an optional Show/Hide Borders menu command.
Figure 4-17 displays the Edition Manager Show/Hide Borders menu command in the
Edit menu.

Undo

2

Cut
Copy
Paste
Select All

36H
36C
sU
#A

Create Publisher...
Subscribe To...
Subscriber

Options...

Show Borders
Show

Clipboard

Figure 4-17. Edit menu with Show/Hide Borders menu command
Depending on your application, you may choose to include resize handles or similar components in your borders. See “Object-Oriented Graphics Borders” later in this chapter for an
example of resize handles.
Whenever a user selects a portion of a publisher or inserts a cursor into the publisher, you
should display the border as 50 percent gray. A user can copy the contents of a publisher or
subscriber without copying the section itself by selecting the data, copying, and then pasting
the data in a new location. A user can cut and paste a selection that contains an entire publisher
or subscriber, but you should discourage users from making multiple copies of a publisher.
See “Duplicating Publishers and Subscribers” later in this chapter for detailed information.
When the user modifies a publisher, your application should grow or shrink its border to
accommodate the new dimension of the section.
You should display only one publisher border within a document at a time. If a cursor is
inserted within a publisher that is contained within a larger publisher, you should display
only the smaller, internal publisher border. If it is absolutely necessary to display all section
borders within a document at the same time, you can create a Show/Hide Borders menu item.
You do not need to provide support for publishers contained within other publishers. If
you do not, you should dim the Create Publisher menu command (to indicate that it is not
selectable) when a user attempts to create a publisher within an existing publisher.

4-44

Using the Edition Manager

The Edition Manager

Figure 4-18 shows the recommended border behavior for publishers when borders are

shown, when a user selects the contents of a section, and when a user selects data within

a document that includes a publisher section.

=>

borders displayed =e

SESL
GANGS. ADLAGEINALD
ES oocnenenmeng Ln
Devices connected to the SCS] port on the back = @ |HEE

of the main unit must have the proper nurnber
fof terminators for the devices to work correctly

and to prevent damage to the SCSI chip inside

your computer. —

=_ |=

contents

highlighted

=

Deyices connected to the SCSI port on the back
of the main unit must have the proper number
of ter pauperis for ue os ices: toDela: cor tees

ro
co)
-%
=

S
=

=

)
=
)
ge
e)
“

Figure

4-18.

Publisher

borders

Figure 4-19 shows the recommended border behavior for subscribers when borders are
shown: when a user selects the contents of a section, and when a user selects data within
a document that includes a subscriber section.

Using the Edition Manager

4-45

Inside Macintosh,

Volume VI

LI

borders displayed

Apple SCSI cable terminators
2
are hardware devices that attach
to a SCSI cable. There must be no

more than two terminators ina
SCSI chain.

a

GLE
==

§

a
H

iS
ei La)

contents highlighted =H

Apple SCS] cable terminators

'

aly

are hardware devices that attach |

to a SCSI cable. There must be no |
more than two terminators ina
|
SCSI chain.

=(_]=>= subscriber highlighted =
Apple SCSI cable terminators
are hardware devices that attach

§

to a SCSI cable. There must be no
more than two terminators in a
SCSI

chain.

Figure 4-19.

Subscriber

borders

If a user tries to select only a portion of a subscriber, you should highlight the entire contents
of the subscriber. A user cannot edit the data contained within a subscriber. See “Modifying a
Subscriber” later in this chapter for detailed information.
If a user cancels a section using the publisher or subscriber options dialog box, your application should leave the contents of the section within the document, but you should be sure to
remove the borders from this data, as it is no longer considered a section.
Generally, the appearance and function of publisher and subscriber borders should be the
same across different applications. See the following sections entitled “Text Borders,”
“Spreadsheet Borders,” “Object-Oriented Graphics Borders,” and “Bitmapped Graphics
Borders” for descriptions of specialized features for publisher and subscriber borders in word
processing, spreadsheet, or graphics applications.

4-46

Using the Edition Manager

The Edition Manager

Text

Borders

In word-processing documents, a publisher may contain other publishers. However, one
publisher should not overlap another publisher. You should display only one publisher
border at a time. If an insertion point is placed within a publisher that is encompassed by
another larger publisher, you should display only the smaller internal publisher border.
In exceptional cases, it may be necessary to display more than one publisher or subscriber
border at a time. For example, a publisher may consist of a paragraph that includes a marker
for a footnote. The data contained within the footnote should also be considered part of the
publisher. When a user selects the paragraph, you should simultaneously display a border
around the footnote.
The border of a publisher that contains text should be located between characters within the
text. The insertion point, when placed on such a boundary, should gravitate toward the
publisher. That is, a click in front (to the left) of a publisher border should place the cursor
inside the publisher, so that subsequent typing goes inside the publisher. Clicking at the end
(to the right) of a publisher border should also place the cursor inside the publisher.
Whenever two separate borders are adjacent to one another (side by side), the boundary click
should go in between them. This is also true for a border that is next to other nontextual
aspects of a document, such as 'PICT' graphics or page breaks.
When a user removes information from a publisher that contains text data, the border should
become smaller to accommodate the new text. When a user adds information to the publisher,
the border should grow to show the enlarged area of the publisher. The insertion point should
remain within the publisher.
If a user highlights the entire contents of a publisher and then chooses Cut from the Edit
menu, you should not delete the publisher border within the document. The user may intend
to delete the existing publisher data and replace it with new data, or the user may want to
move the entire publisher and its data to a new location. Figure 4-20 shows this state.

4+.
Ceeaet

~

~
—

The first quarter summary of our regional sales shows the
effectiveness of our new training program. It is clear that
we need to capture
Figure 4-20.

the remaining

=s
a
~
~

=
a

sales potential.

—

=
=
1
GQ
@
“

A publisher with contents removed

You should leave the cursor inside the smal! publisher border for further typing. If the user
inserts the cursor in a new location (instead of typing data inside the existing border), you
need to remove the empty publisher border from the document to allow the user to move the
publisher. This effectively deletes the publisher from the document. If the user pastes the
publisher that is currently held in the Clipboard, you should recreate its border. If the user
cuts or copies other data from the document before pasting the publisher from the Clipboard,
the publisher should be removed from the Clipboard.

Using the Edition Manager

4-47

Inside Macintosh,

Volume VI

Spreadsheet

Borders

Borders around spreadsheet data or other data in arrays should look and behave very much
like text borders. Figure 4-21 shows a typical border within a spreadsheet document.

A
ene

an

2°)

4

§ Widgets

es

3 | Sprockets |
5

en

B
January.

c

D

E

re 14830

16494

Renna Lvecsnscesnsnnennel vamaexssaeniniaaae amcawaranunasnes

Figure 4-21. A publisher border within a spreadsheet document
Note that the border goes below the column headers (A, B, C, D) and to the right of the row
labels (1, 2, 3, 4)—it should not overlap these cell boundaries. The border at the bottom and

the border on the right side can be placed within the adjacent cells (outside of the cells that
constitute the publisher).
In contrast to word-processing applications, borders in spreadsheet documents (or other
documents with array data) can overlap. That is, a user can select a row of cells to be a
publisher and an overlapping column of those cells to be another publisher. You should
never display more than one publisher border at a time. When a user selects a spreadsheet
cell that is part of more than one publisher, you should display only the border of the
publisher that was last edited. (This can be accomplished by comparing the modification
dates of the publishers.)

If it is absolutely necessary to display all section borders within a document at the same
time, you can create a Show/Hide Borders command in the Edit menu to toggle all borders
on and off.

When data is added to or deleted from a publisher that consists of a spreadsheet cell or other
array, its border should grow or shrink to accommodate the addition or deletion of data. A
publisher should behave like a named range in a spreadsheet. For example, if a user cuts a
row within a publisher that consists of a named range in a spreadsheet, you should shrink the
publisher data and its border correspondingly.
When a user cuts a publisher and its entire contents within a spreadsheet document, the entire
section should be held in the Clipboard. Do not leave an empty publisher border in a spreadsheet (as recommended for text borders). If a user attempts to paste a copy of an existing
publisher, you should warn the user by displaying an alert box (see “Duplicating Publishers

and Subscribers” later in this chapter).

4-48

Using the Edition Manager

The Edition Manager

Object-Oriented

Graphics

Borders

In an object-oriented drawing application, the publisher border should fit just around the
selected objects.
You can provide resize handles that appear with all drawing objects to allow the user to resize
the border of a publisher. Figure 4-22 shows a publisher border with resize handles.

=>

Sample Graphics

=e
4?

ab
my
Figure 4-22.

A publisher border with resize handles

A user can create freeform graphics within drawing applications that cause publisher borders
to seemingly float over the area the user publishes. The border acts like a clipping rectangle—
anything within the border becomes the publisher. Figure 4-23 shows a publisher that
contains clipped graphics and its subscriber in another application.

A user can create publishers and subscribers that overlap each other. Thus, borders may
overlap and it may no longer be possible to turn on a particular border when the user clicks

within a publisher. Drawing applications should provide a menu command, Show Borders,
that toggles to Hide Borders. This command should allow users to turn all publisher and
subscriber borders on or off.

Using the Edition Manager

aN
=

—_
=

(gs
=

=<
—

“2

=

i]

7
ic)
“

4-49

Inside Macintosh,

Volume VI

=" |=

Graphics Publisher

:

2=HEz

af

ia

wake]
==

Graphics Subscriber =H

<?

Figure 4-23. A publisher and subscriber with clipped graphics

Bitmapped

Graphics

Borders

Creating a border around bitmapped graphics in applications is similar to doing so in objectoriented drawing applications. The border appears around the selected area. The user can
create overlapping publishers and subscribers in bitmapped graphics applications. You need
to provide a Show/Hide Borders command to allow users to turn all borders on and off.

Duplicating

Publishers

and

Subscribers

Whenever a user clicks a publisher or subscriber border, you should change the contents of
the section to a selected state. You should discourage users from making multiple copies of a
publisher and pasting them in the same or other documents, because the contents of the
edition would be difficult or impossible to predict. Multiple copies of the same publisher also
contain the same control block value. See “Creating and Registering a Section” later in this
chapter for detailed information on control blocks.

4-50

Using the Edition Manager

The Edition Manager

When a user attempts to create a copy of a publisher that already exists, you should display
an alert box such as the one shown in Figure 4-24.

There

is another

Publisher

Edition “January

open

Sales.”

to the

If there is more than one Publisher to an
Edition, the Edition’s contents aren’t
predictable.

(“0K _)

Figure 4-24.

Creating multiple publishers alert box

When a user attempts to save a document that contains multiple copies of the same publisher,
display an alert box such as the one shown in Figure 4-25.

“Year end

report”

contains

two

Publishers to the Edition “January Sales.”
If there

is more

than

one

Publisher

Edition, the Edition’s contents aren’t

to an

predictable.

__0K|
Figure 4-25.

to ignore your

Saving multiple publishers alert box

al

your

application

3

If a user decides to ignore your alert box, your application should still save the document, but
you should continue to display this error message every time the user saves this document.

pon
—
~~

—_:

A user can modify the contents of any duplicate publisher, but the contents of the edition will
be whichever publisher was the last to write.
When a user chooses to copy and paste or duplicate a section, use the HandToHand function
(described in the Operating System Utilities chapter in Volume ID) to duplicate the section
record and alias record. Put the alias field of the cloned section record with the handle to the
cloned alias record and generate a unique section identification number for it. When exporting
your Clipboard to the scrap, you should also place the section data, section record, and alias
record in the scrap.
Use the RegisterSection function (described earlier in “Opening and Closing a Document
Containing Sections”) to register the cloned section’s section record.
A user can select the contents of a publisher without selecting the border and copy just the
data to a new location. In this case, the user has simply copied data (and not the publisher).
Do not create a border for this data in the new location.

Using the Edition Manager

4-5]

—

—
on!
~
~e
a

4

—

as
~
—
_
ay
—

ti

i)
—

;

Inside Macintosh, Volume VI

Modifying

a Subscriber

When the user selects data or clicks in the data area of a subscriber, you should highlight the
entire contents of the subscriber using reverse video. You can allow users to globally adorn
subscribers. For example, a user might select a subscriber within a document and change
all text from plain to bold. However, you should discourage users from modifying the
individual elements contained within a subscriber—for example, by editing a sentence or
rotating an individual graphical object.
Remember that each time a new edition arrives for a subscriber, any modifications that the
user has introduced are overwritten. Global adornment of a subscriber is much easier for
your application to regenerate.
If you do allow a user to edit a subscriber section, provide an enable/disable editing option
within the subscriber options dialog box using the SectionOptionsExpDialog function,

described later in “Customizing Dialog Boxes.” When you allow a user to edit a subscriber,
you should change the subscriber from a selected state to editable data.

In addition to global adornment, your application may also need to support partial selection
of subscribers to enable spell checking and search operations.
Because a user can modify a publisher just like any other portion of a document, its subscriber may change in size as well as content. For example, a user may modify a publisher
by adding two additional columns to a spreadsheet.

Relocating

an Edition

In the Finder, users cannot move an edition across volumes. To relocate an edition, the user

must first select its publisher and cancel the section (remember to remove the border). The user

needs to republish and then select a new volume location for the edition. As a convenience for
the user, you should retain the selection of all the publisher data after the user cancels the
section to make it easy to republish the section.

Customizing

Dialog

Boxes

The expandable dialog box functions allow you to add items to the bottom of the dialog boxes,
apply alternate mapping of events to item hits, apply alternate meanings to the item hits, and
choose the location of the dialog boxes. See the Dialog Manager chapter in Volume I and the
Standard File Package chapters in Volumes I and VI for additional information.
The expandable versions of these dialog boxes require five additional parameters. Use the
NewPublisherExpDialog function to expand the publisher dialog box.
err

:=

NewPublisherExpDialog

(reply,
dlgHook,

4-52

Using the Edition Manager

where,

expansionDITLresID,

filterProc,

yourDataPtr);

The Edition Manager

Use the NewSubscriberExpDialog function to expand the subscriber dialog box.
err

:=

NewSubscriberExpDialog

(reply,
dligHook,

where,

expansionDITLresID,

filterProc,

yourDataPtr) ;

Use the SectionOptionsExpDialog function to expand the publisher options and the
subscriber options dialog boxes.
err

:=

SectionOptionsExpDialog

(reply,
where,
expansionDITLresID,
GlgHook,
filterProc,
yourDataPtr) ;

The reply parameter is a pointer to a NewPublisherReply, NewSubscriberReply, or
SectionOptionsReply record, respectively.
You can automatically center the dialog box by passing (—1, —1) in the where parameter.
The expansionDITLresID parameter should be 0 or a valid dialog item list (‘DITL') resource
ID. This integer is the ID of a dialog item list whose items are appended to the end of the
standard dialog item list. The dialog items keep their relative positions, but they are moved as
a group to the bottom of the dialog box. See the Dialog Manager chapter in Volume I for
additional information on dialog item lists.
The filterProc parameter should be a valid, expandable modal filter procedure pointer or NIL.
This procedure is called by the ModalDialog function. The filterProc function enables you to
map real events (such as a mouse-down event) to an item hit (such as clicking the Cancel

button). For instance, you may want to map a keyboard equivalent to an item hit. See the
Dialog Manager chapter in Volume I for information on the ModalDialog function.
The dlgHook parameter should be a valid, expandable dialog hook procedure pointer or NIL.
This procedure is called after each call to the ModalDialog filter function. The dlgHook parameter takes the appropriate action, such as filling in a check box. The itemOffset parameter to
the procedure is the number of items in the dialog item list before the expansion dialog items.
You need to subtract the item offset from the item hit to get the relative item number in the
expansion dialog item list. The return value from the dlgHook parameter is the absolute
item number.

os
=
a

=.
==
—

$9
=
$
7
io)
ar

When the Edition Manager displays subsidiary dialog boxes in front of another dialog box on
the user’s screen, your dlgHook and filterProc parameters should check the refCon field in
the WindowRecord data type (from the window field in the DialogRecord) to determine which
window is currently in the foreground. The main dialog box for the NewPublisherExpDialog
and the NewSubscriberExpDialog functions contains the following constant:
CONST

sfMainDialogRefCon

=

“erat

{new

{

new

publisher

and

subscriber}

Using the Edition Manager

4-53

}

Inside Macintosh, Volume VI

The main dialog box for the SectionOptionsExpDialog function contains the following constant:
CONST

=

emOptionsDialogRefCon

{options

'optn';

dialog}

See “Summary of the Edition Manager” later in this chapter for additional constants.
The yourDataPtr parameter is reserved for your use. It is passed back to your hook and
modal filter procedure. This parameter does not have to be of type Ptr—it can be any 32-bit
quantity that you want. In Pascal, you can pass in register A6 for yourDataPtr, and make
digHook and filterProc local functions without the last parameter. The stack frame is set up
properly for these functions to access their parent local variables. See the Standard File
Package chapter in this volume for detailed information.
For the NewPublisherExpDialog and NewSubscriberExpDialog functions, all the pseudo-

items for the Standard File Package—such as sfHookFirstCall(—1), sfHookNullEvent(100),
sfHookRebuildList(101), and sfHookLastCall(—2)—can be used, as well as
emHookRedrawPreview( 150).

For the SectionOptionsExpDialog function, the only valid pseudo-items are sfHookFirstCall(—1),

sfHookNullEvent(100), sfHookLastCall(—2), emHookRedrawPreview(150),
emHookCancelSection( 160), emHookGoToPublisher( 161), emHookGetEditionNow(162),
emHookSendEditionNow(162), emHookManualUpdateMode(163), and

emHookAutoUpdateMode(164). See the Standard File Package chapter in this volume for
information on pseudo-items.

SUBSCRIBING

TO

NON-EDITION

FILES

Using the Edition Manager, a subscriber can read data directly from another document, such
as an entire 'PICT' file, instead of subscribing to an edition. This feature is for advanced
applications that can set up bottleneck procedures for reading. Figure 4-26 shows a document
that is subscribing directly to a 'PICT' file.
For each application, the Edition Manager keeps a pointer to a bottleneck function. The
Edition Manager never opens or closes an edition container directly. Instead, the Edition
Manager calls the current edition opener. The InitEditionPack function (described later
in “Initializing the Edition Manager”) sets up the current system opener function.
To override the standard opener function, create an opener function that contains the
following parameters.
FUNCTION

MyOpener

(selector:
VAR

4-54

PB:

EditionOpenerVerb;
EditionOpenerParamBlock)

Subscribing to Non-Edition Files

:

OSErr;

The Edition Manager

JJ
us

hi

+

J;

\
¥

in

w,

the

aN

IN

park

Subscriber

i

ny

(

sein vn over) Vieconetny evering

Pianos & palm trees

at 8 PM beginning
March 21

The concerts will be held in the outdoor atrium
shell located across from the Academy of Sciences
in Golden Gate Park in San Francisco.
The series wll continue
through
April 25.

Figure 4-26.

Subscribing directly to a 'PICT' file

Your opener needs to know which formats the file contains and how the data is supposed to
be read or written.
The opener can allocate a handle or pointer to contain information such as file reference
numbers. This value is passed as ioRefNum to the I/O procedures.
The eoOpen and eoOpenNew edition opener verbs (described later in “Calling an Edition
Opener Procedure”’) return a pointer to a function to do the actual reading and writing.
The following sections describe
= how to get the current edition opener procedure
a

= how to set your own edition opener procedure

Se
i
==.
=
<4
ey
=
ey
re

= how to call an edition opener procedure
m the edition opener parameters

Getting the Current

_—

Edition

a)

Opener

When you want to get the current edition opener procedure, use the GetEditionOpenerProc
function.
err

:=

GetEditionOpenerProc

(opener) ;

The opener parameter returns the pointer to the current edition opener procedure. A different
current opener is kept for each application. One application’s opener is never called by
another application.

Subscribing to Non-Edition Files

4-55

Inside Macintosh,

Volume VI

Setting an Edition Opener
You can provide your own edition opener procedure. To do so, use the SetEditionOpenerProc
function.
err

:=

SetEditionOpenerProc

(@MyOpener) ;

The @MyOpener parameter is a pointer to the edition opener procedure that you are providing. If you set the current opener to be a routine in your own code, be sure to call the
GetEditionOpenerProc function first so that you can save the previous opener. If your opener
is passed a selector that it does not understand, use the previous opener provided by the Edition
Manager to handle it. See the next section for a list of selectors.

Calling an Edition

Opener

Procedure

You use the CallEditionOpenerProc function to call an edition opener procedure. Since
the Edition Manager is a package that may move, a real pointer cannot be safely returned
for the standard opener and I/O procedures. The system opener and the I/O routines are
returned as a value that is not a valid address to a procedure. The CallEditionOpenerProc
and CallFormatIOProc functions check for these values and call the system procedures.
You should never assume that a value for a system procedure is a fixed constant.
err

:=

CallEditionOpenerProc

(selector,

PB,

routine);

Set the selector parameter to one of the edition opener verbs. The edition opener verbs include
m eoCanSubscribe
mw eoOpen
mw eoClose
m eoOpenNew
mw eoCloseNew

The PB parameter of the CallEditionOpenerProc function is an edition opener parameter block.
TYPE

EditionOpenerParamBlock

=

RECORD

info:
sectionH:

EditionInfoRecord;

{edition

SectionHandle;

{ be subscribed
{publisher
or
}
{

4-56

container

subscriber

to

to}

}

document:

FSSpecPtr;

{ requesting
open}
{document
passed}

fdCreator:
ioRefNum:

OSType;
Longint;

{Finder
creator
type}
{reference
number}

Subscribing to Non-Edition Files

}

The Edition Manager

ioProc:

FormatIOProcPtr;

{routine
{

success:

formatsMask:

to

read

or

writing

Boolean;

{reading

SignedByte

{ was successful}
{formats
required
{

}

formats}

}
to

}

subscribe}

END;

The routine parameter of the CallEditionOpenerProc function is a pointer to an edition opener
procedure.
The following list shows which fields of the edition opener parameter block are used by the
edition opener verbs.
Opener

Field

Description

Called

—

info

oe

formatsMask

—

Return value

Edition container to subscribe to.
Formats required to subscribe.
A noErr code indicates that an edition
container can be subscribed to. A
noTypeErr code indicates that an edition
container cannot be subscribed to.

NewSubscriberDialog
function for a
subscriber

>

info
sectionH

Edition container to open for reading.
Subscriber section requesting
open or NIL.
Reference number for use by I/O

OpenEdition and
GetStandardFormats
functions for a
subscriber

verb

eoCanSubscribe

eoOpen

ard

<_

ioRefNum

—

ioProc

I/O routine to call to read formats.

—

Return value

A noErr code or appropriate error code.

>

info

—

sectionH

Edition container to be closed for
reading.
Subscriber section requesting close

a}

ioRefNum

—-

ioProc

—

success

by

routine. Not the same as EditionRefNum.

eoClose

Return value

eoOpenNew

=

info

one

sectionH

—

document

—>

fdCreator

—

ioRefNum

eae
—

ioProc
Return value

or NIL.
Value returned by eoOpen.

CloseEdition and
GetStandardFormats
functions for a

subscriber

Value returned by eoOpen.
Success value passed to the
CloseEdition function.
A noErr code or appropriate error code.
Edition container to open for writing.
Publisher section requesting
open or NIL.
Document pointer passed into the
OpenNewEdition function.
The fdCreator passed into the
OpenNewEdition function.
Reference number for use by I/O
routine. Not the same as
EditionRefNum.
I/O routine to call to write formats.
A noErr code or appropriate error code.

=
S
=

=
<

=
72
i:
OpenNewEdition
function for a
publisher

Subscribing to Non-Edition Files

4-57

Inside Macintosh,

Volume VI

Opener
verb
eoCloseNew

by

Field

Description

Called

=>

info

=

sectionH

Edition container to be closed after
writing.
Publisher section requesting close

CloseEdition function
for a publisher

>

ioRefNum

>

success

>

or NIL.
Value returned by eoOpenNew.

ioProc

<

Value returned by eoOpenNew.
Success value passed to the

CloseEdition function.

Return value

A noErr code or appropriate error code.

The sample code in Listing 4-9 demonstrates how to install your own edition opener function.
Listing 4-9. Using your own edition opener function
VAR

gOriginalOpener:
{Install
{

and

your

then

PROCEDURE

EditionOpenerProcPtr;

edition

set

the

opener

opener

to

by

{global

variable}

off

current

opener

your

opener.}

saving

point

to

}

InstallMyOpener;

BEGIN

FailOSErr
FailOSErr
END;

a

(gOriginalOpener) ) ;
(@MyEditionOpener) ) ;

{InstallMyOpener}

{This
{

(GetEditionOpenerProc
(SetEditionOpenerProc

opener

calls

selector

verb

FUNCTION

the
it

original

does

MyEditionOpener

not

edition

opener

if

it

(selector:
VAR

PB

PB:

EditionOpenerParamBlock)

DO

BEGIN
CASE

selector

OF

eoCanSubscribe:
MyEditionOpener
eoOpen:

MyCanSubscribe
(PB) ;

MyEditionOpener

MyEditionOpen
(PB) ;

eoClose:

MyEditionOpener

MyEditionClose
(PB) ;

OTHERWISE

MyEditionOpener

:=

(selector,
END;
END;

END;

4-58

passed

}

EditionOpenerVerb;

BEGIN
WITH

is

understand. }

CallEditionOpenerProc
PB,

{case}

{with}

{MyEditionOpener}

Subscribing to Non-Edition Files

gOriginalOpener) ;

:

OSErr;

The Edition Manager

{This
{
{
{

function

returns

noErr
if it can subscribe
to the request
}
by the Edition Manager
to build
the list of }
files
in NewSubscriberDialog.
Notice
that
it calls
the original
}
it does not understand.}
for files
opener
file.

It

FUNCTION
BEGIN

is

called

MyCanSubscribe

{Check
file
type
to
{ edition. }
IF PB.info.fdType
=
THEN

(VAR
see

if

{for

MyCanSubscribe

{Otherwise,
let the
ELSE MyCanSubscribe

PB:
it

EditionOpenerParamBlock)
is

a

file

you

can

emulate

OSErr;
as

an

}

example}'PICT'
:=

noErr

saved off edition opener decide.}
:= CallEditionOpenerProc(eoCanSubscribe,
PB,

END;

:

gOriginalOpener);

{MyCanSubscribe}

Opening

and Closing

Editions

Each time the Edition Manager opens or closes an edition container, it calls the current edition
opener procedure and passes it an opener verb and a parameter block.
Your opener must be careful when closing documents since a document may already have
been opened by another application. Be sure to use the Open/Deny modes whenever possible.
Do not close a document if it was already open when your application opened it.

Listing Files That Can

Be Subscribed

To

The NewSubscriberDialog function calls the eoCanSubscribe opener verb to build the list of
files that can be subscribed to. The preview in the subscriber dialog box is generated by
calling the GetStandardFormats function (described in “Edition Container Formats” later in
this chapter), which calls the format I/O verbs eoOpen, ioHasFormat, ioRead, and then
eoClose. See “Calling a Format I/O Procedure” later in this chapter for detailed information
on format I/O verbs.

aes

ea)

a

mae
oe
nd
—
—

—<
—
ie)
—

=~

Reading

From

=
tj)

and Writing to Files

‘<)
es )

The I/O procedure is a routine that actually reads and writes the data. It too has an interface of
a selector and a parameter block.
To override the standard reading and writing functions, create an I/O function. Note that you
also need to provide your own opener function to call your I/O function. See “Calling an
Edition Opener Procedure” earlier in this chapter.
FUNCTION

MyIO

(selector:

FormatIOVerb;

VAR

PB:

FormatIOParamBlock)

OSErr;

Subscribing to Non-Edition Files

4-59

Inside Macintosh,

Volume VI

Calling a Format

I/O Procedure

To indicate to the Edition Manager which format I/O procedure to use, use the
CallFormatIlOProc function.
err

:=

CallFormatIOProc

(selector,

PB,

routine);

Set the selector parameter to one of the format I/O verbs. The format I/O verbs include
mw ioHasFormat
m ioReadFormat
= ioNewFormat
w

ioWriteFormat

The PB parameter of the CallFormatIOProc function contains a format I/O parameter block.
TYPE

FormatIOParamBlock

=

RECORD

ioRefNum:

Longint;

{reference

format:

FormatType;

{edition

number}

formatIndex:

Longint;

{opener-specific

offset:

LongInt;

{ of
formats}
{offset
into

format}

buffPtr:

Ptxs

{data

here}

buffLen:

LongiInt

{length

format

starts

of

type}
enumeration

}

data}

END;

The routine parameter of the CallFormatIOProc function is a pointer to a format I/O procedure.
The following list shows which fields of FormatlOParamBlock are used by the format
I/O verbs.
Opener
verb
ioHasFormat

ioReadFormat

4-60

Parameter

Description

Called

>

ioRefNum

>
-

format
formatIndex

EditionHasFormat,
GetStandardFormats,
and ReadEdition
functions

-

buffLen

co

Return value

I/O reference number returned
by opener.
Check for this format.
An optional enumeration of the
supplied format.
If found, return the length size or —1
if size is unknown.
A noErr or noTypeErr code.

>

ioRefNum

>
>
>

format
formatIndex
offset

I/O reference number returned by
opener.
Get this format.
Value returned by ioHasFormat.
Read format beginning from this offset.

ReadEdition and
GetStandardFormats
functions

Subscribing to Non-Edition Files

by

The Edition Manager
Opener
verb

ioNewFormat

ioWriteFormat

Parameter

Description

=
o

buffPtr
buffLen

€

Return value

Put data beginning here.
Specify buffer length to read, and return
actual amount received.
A noErr code, or appropriate error code.

—

ioRefNum

-

format
formatIndex

co

Return value

=

ioRefNum

_
>
>
>
o
<-

format
formatIndex
offset
buffPtr
buffLen
Return value

Called

by

I/O reference number returned by
opener.
Create this format.
An optional enumeration of the
supplied format.
A noErr code, or appropriate error code.

SetEditionFormatMark
and WriteEdition
functions

I/O reference number returned by
opener.
Get this format.
Value returned by ioNewFormat.
Write format beginning from this offset.
Get data beginning here.
Specify buffer length to write.
A noErr code or appropriate error code.

WriteEdition function

The marks for each format are kept by the Edition Manager. The format I/O procedure only
needs to be able to read or write, beginning at any offset. If you know that your application
always reads an entire format sequentially, you can ignore the offset.

EDITION

MANAGER

ROUTINES
<
=}
=
=
=.

This section describes the routines for

initializing the Edition Manager

a

=~

<
S
=}
=
ge
C
—

creating and registering a section
creating and deleting an edition container

™

setting and locating a format mark
reading in edition data
writing out edition data
closing an edition after reading or writing
displaying dialog boxes
locating a publisher and edition from a subscriber
reading edition container formats
reading and writing non-edition files
Edition Manager Routines

4-6]

Inside Macintosh,

Volume VI

Result codes appear at the end of each function where applicable. In addition to the specific
result codes listed, you may receive errors generated by the Alias Manager, File Manager,
and Memory Manager.

Initializing the Edition

Manager

You use the InitEditionPack function to initialize the Edition Manager. Note that you should
only call this function once. Before calling this function, be sure to determine whether the
Edition Manager is available on your system by using the Gestalt function. The Gestalt
selector is gestaltEditionMgrAttr (‘edtn’).
FUNCTION

InitEditionPack

:

OSErr;

The InitEditionPack function returns an error if the package could not be loaded into the
system heap and properly initialized. In addition, you may also receive resource errors.
Result codes
noErr

0

memFullErr

Creating

and

—108

No error

Could not load package

Registering a Section

You use the NewSection function to create a new section (either publisher or subscriber) and
alias record (which is a reference to the edition container from the document containing the
publisher or subscriber section). The NewSection function allocates two handles in the

current zone: one handle for the section record and another handle for the alias record. Note
that you are responsible for unregistering handles created by the Edition Manager.
FUNCTION

NewSection

(container:

EditionContainerSpec;

FSSpecPtr;

kind:

Longint;

SectionType;

initialMode:

SectionHandle)

:

sectionDocument:

sectionID:

UpdateMode;

VAR

sectionH:

OSErr;

The container parameter specifies the edition you want to publish or subscribe to. The
sectionDocument parameter contains the volume reference number, directory ID, and
filename of the document that contains a section. The sectionDocument parameter can
be NIL if your current document has never been saved. If so, when the user finally
saves the document, remember to call the AssociateSection function on each section
to update its alias record.
The kind parameter designates the type of section (publisher or subscriber) being created.
A section ID is a unique number for a section within a document. The sectionID parameter
initializes the sectionID field within the new section record. Do not use 0 or -1 for an ID
number; these numbers are reserved. If your application copies a section, you need to specify
a unique number for the copied section.

4-62

Edition Manager Routines

The Edition Manager

The initialMode parameter contains the update mode for the section. For publishers this is
either the pumOnSave or pumManual constant, and for subscribers it is either sumAutomatic
or sumManual. A subscriber created with sumAutomatic mode automatically receives a
Section Read event. To prevent this initial Section Read event, you should set the initialMode

parameter to sumManual and then, when NewSection returns, set the mode field of the

section record to sumAutomatic.

If the NewSection function fails, the sectionH parameter is set to NIL. If the function is
successful, sectionH contains the handle to the allocated section record.
Your application receives the multiplePublisherWrn result code if there is another registered
publisher to the same edition. Your application receives the notThePublisherWrn result code
if another publisher (to the same edition) was the last section to write to the edition. The

multiplePublisherWrn result code takes priority over the notThePublisherWrn result code.
In addition, you may also receive memory and file opening errors.
Result codes

noErr
editionMegrInitErr
badSectionErr
badSubPartErr
multiplePublisherWm
notThePublisherWrn

0
—450
—451
—454
—460
—463

No error
Manager not initialized
Not a valid section type
Bad edition container spec
Already is a publisher
Not the publisher

The NewSection function registers a section similar to the way that the RegisterSection
function informs the Edition Manager about a section (except that the NewSection function
does not resolve an alias to find the edition container).
FUNCTION

RegisterSection

(sectionDocument:
SectionHandle;

FSSpec;
VAR

sectionH:

aliasWasUpdated:

iE

Boolean)

OSErr;

=

a

—e

The sectionDocument parameter contains the volume reference number, directory ID, and
filename of the document that contains a section. The sectionH parameter is a handle to the
section record for a given section.
The aliasWasUpdated parameter returns TRUE if the alias for the edition container subscribed
to was out of date and was updated. This may occur if the edition file was moved to a new
location or was renamed.
The RegisterSection function adds the section record to the Edition Manager’s list of
registered sections and tries to allocate a control block. After calling the RegisterSection
function, the controlBlock field of the section record is either NIL or a valid control block.
For a subscriber, the control block is NIL if the RegisterSection function could not locate
the edition container being subscribed to. The RegisterSection function then returns either
the containerNotFoundWrn or the userCanceledErr result code. For a publisher, if the
RegisterSection function could not locate its corresponding edition container, the Edition

Edition Manager Routines

4-63

=.

=
—

<<
—

po)

=|
£9
ge
=

Inside Macintosh,

Volume

VI

Manager creates an edition container in the last place the edition was located and creates a
control block for it. If the RegisterSection function could not locate a publisher’s corresponding edition container or its volume, the control block is NIL. You should never
re-register a section that is already registered.
Note that you can compare control blocks for individual sections. If two sections contain the
same control block value, these sections publish or subscribe to the same edition (unless the
control block is NIL). The Edition Manager keeps track of how many sections are referencing
a control block to know when it can be deallocated. The control block maintains a count of
how many sections are referencing it. Each time you use the UnRegisterSection function, the
control block subtracts one from the number of sections. When the number of sections
reaches (), the control block is deallocated.
Your application receives the multiplePublisherWrn result code if there is another registered
publisher to the same edition. Your application receives the notThePublisherWrn result code
if another publisher (to the same edition) was the last section to write to the edition. The

multiplePublisherWrn result code takes priority over the notThePublisherWrn result code.
In addition, you may also receive memory and file opening errors.
Result codes

noErr
userCanceledErr
editionMerInitErr
badSectionErr
multiplePublisherWrn
containerNotFoundWrn
notThePublisherWrn

0)
—128
—450
—45 1
—460
—46]
—463

No error
User chose Cancel from a mount server dialog box
Manager not initialized
Not valid section type
Already is a publisher
Alias was not resolved
Not the publisher

When a section needs to be disposed of because the document containing the section is closing,
or the user has canceled the section, you need to call the UnRegisterSection function before
disposing of the section.
FUNCTION

UnRegisterSection

(sectionH:

SectionHandle)

:

OSErr;

The sectionH parameter is a handle to the section record for a given section.
The UnRegisterSection function removes the section from the Edition Manager’s list of
registered sections. You can then dispose of the section record and alias record with standard
Memory and Resource Manager calls. Once unregistered, a section does not receive any
events and cannot read or write any data. Depending on your Clipboard strategy, you may
want to unregister sections that have been cut into the Clipboard.
Result codes

noErr
fBsyErr
editionMegrInitErr
notRegisteredSectionErr

4-64

0
—47
—45()
—452

Edition Manager Routines

No error
Section doing I/O
Manager not initialized
Not registered

The Edition Manager

Using the IsRegisteredSection function, your application must verify that each event received
is for a registered section. This is necessary because your application may have just called
UnRegisterSection while the event was already being held in the event queue.
FUNCTION

IsRegisteredSection

(sectionH:

SectionHandle)

:

OSErr;

The sectionH parameter is a handle to the section record for a given section. The
IsRegisteredSection function does not return a Boolean—a noErr result code indicates
that a section is registered.
Result codes
noErr
notRegisteredSectionErr

0
-—452

No error
Not registered

If a user saves a document that contains sections under another name (using Save As) or
pastes a portion of a document that contains a section into another document, use the
AssociateSection function to update the section’s alias record.
FUNCTION

AssociateSection

(sectionH:

SectionHandle;

FSSpecPtr)

:

newSectionDocument:

OSErr;

The sectionH parameter is a handle to the section record for a given section. The
newSectionDocument parameter contains the volume reference number, directory ID,
and filename of the new document. The AssociateSection function calls UpdateAlias
on the section’s alias record.
In addition, you may also receive update alias errors.
Result code
noErr

Creating and

0)

Deleting

rs

No error

ie

S
=
S
=

an Edition Container

<2
al

=to)
io

Each time a user creates a new publisher section within a document to an edition that does
not already exist, you use the CreateEditionContainerFile function to create an empty
edition container.
FUNCTION

CreateEditionContainerFile

Ler

(editionFile:
FSSpec;
fdCreator:
OSType;
editionFileNameScript:
OSErr;

ScriptCode)

The editionFile parameter contains the volume reference number, directory ID, and filename
for the edition container being created. The fdCreator parameter contains the creator type for
the edition.

Edition Manager Routines

4-65

|

Inside Macintosh,

Volume

VI

The editionFileNameScript parameter is the script of the filename. It is returned in the

theFileScript field of the edition container specification record. (The new publisher reply
record includes a container field for an edition container specification record.)
The CreateEditionContainerFile function creates an empty edition container file (it does not
contain any formats). This function creates a file type ‘edtu'. As soon as you write data to the
edition, the type is updated (to 'edtp' for graphics, ‘edtt' for text, or 'edts' for sound). If both
text and pict are written, the type that was written first determines the file type. If your application has a bundle, you should designate an icon for the appropriate edition types that you
can write.
In addition, you may also receive file creating errors.
Result codes
noErr
editionMegrInitErr

0
—450

No error
Manager not initialized

If a user cancels a publisher section within a document or closes a document containing a
newly created publisher without saving, you need to remove the edition container.
To locate the appropriate edition container to be deleted, use the GetEditionInfo function.

You use the UnRegisterSection function (only after using the GetEditionInfo function) to

unregister the section record and alias record of the publisher being canceled. See “Locating
a Publisher and Edition From a Subscriber” later in this chapter for detailed information on
the GetEditionInfo function. See “Creating and Registering a Section” earlier in this chapter
for detailed information on the UnRegisterSection function.
To remove the edition container, use the DeleteEditionContainerFile function.
FUNCTION

DeleteEditionContainerFile

(editionFile:

FSSpec)

:

OSErr;

If the user cancels a publisher, do not call the DeleteEditionContainerFile function until
the user saves the document. This allows the user to undo changes and revert to the last
saved version of the document.
The DeleteEditionContainerFile function only deletes the edition container if there is no
registered publisher. You need to unregister a publisher before you can delete its corresponding edition container.
The editionFile parameter contains the volume reference number, directory ID, and filename
for the edition container being deleted.
You should use the DeleteEditionContainerFile function even if there are subscribers to the
edition. When a subscriber section tries to read in data, it receives an error.

In addition, you may also receive file deleting errors.
Result codes
noErr
editionMerInitErr
4-66

0
—450

Edition Manager Routines

No error
Manager not initialized

The Edition Manager

Setting and

Locating

a Format

Mark

Use the SetEditionFormatMark function to set the current mark for a section format. The mark
indicates the next position of a read or write operation. Initially, a mark defaults to 0. After
reading or writing data, the format mark is set past the last position written to or read from.
FUNCTION

SetEditionFormatMark

(whichEdition:
FormatType;

EditionRefNum;
setMarkTo:

whichFormat:

LongInt)

:

OSErr;

The whichEdition parameter is the reference number for the edition. The whichFormat parameter indicates the format type for the edition, and the setMarkTo parameter is the offset for the
next read or write for this format.
Result codes

noErr
rfNumErr
noTypeErr
editionMerInitErr

0
—5]
—102
-450

No error
Bad edition reference number
Unknown format (subscriber only)
Manager not initialized

Use the GetEditionFormatMark function to locate the current marker for a particular format.
FUNCTION

GetEditionFormatMark

(whichEdition:
FormatType;

EditionRefNum;
VAR

currentMark:

whichFormat:
LongInt)

OSErr;

The whichEdition parameter is the reference number for the edition. The whichFormat parameter indicates the format type for the edition, and the currentMark parameter is the mark for
the format.

If the edition does not support the format specified in the whichFormat parameter, you receive
a noTypeErr result code.
Result codes

noErr
rfNumErr

noTypeErr
editionMerInitErr

Reading

in Edition

—51

0)

—102
—450

No error
Bad edition reference number

OpenEdition

=

Ler |

Data

EditionRefNum)

:

SectionHandle;

S.
S
°
5is
2
geic)

Unknown format
Manager not initialized

(subscriberSectionH:

ie

po

To initiate the reading of data from an edition (for a subscriber), use the OpenEdition function.
FUNCTION

b

VAR

refNum:

OSErr;

The subscriberSectionH parameter is a handle to the section record for a given section. The
refNum parameter returns the reference number for the edition.
Edition Manager Routines

4-67

Inside Macintosh,

Volume

VI

Multiple subscribers can each call the OpenEdition function simultaneously (each call returns

a different reference number) and read data from a single edition. If a publisher (located on a

different machine) is writing to an edition when you use the OpenEdition function, you
receive an flLckedErr result code.
In addition, you may also receive memory, file opening, and file reading errors.
Result codes

noErr
flLckedErr
permErr
editionMegrInitErr

0
—45
—54
—450

No error
Publisher writing to an edition
Not a subscriber
Manager not initialized

Use the EditionHasFormat function to learn in which formats the edition data is available.
FUNCTION

EditionHasFormat

(whichEdition:
FormatType;

EditionRefNum;
VAR

formatSize:

whichFormat:
Size)

:

OSErr;

The whichEdition parameter is the reference number for the edition. The whichFormat parameter indicates the format type that you are requesting. For the whichFormat parameter, you
should decide which formats to read in the same way that you do when using paste from the
Scrap Manager. You can also get a list of all the available formats and their respective lengths
by reading the kFormatListFormat (‘fmts') format. The formatSize parameter specifies the
format length.
If the requested format is available, this function returns noErr, and the formatSize parameter
returns the size of the data in the specified format or kFormatLengthUnknown (—1), which

signifies that the size is unknown. You should therefore continue to read the format until

there is no more data.

Be aware that the EditionHasFormat function may return kFormatLengthUnknown for the
length of the format.
Result codes
noErr
rfNumErr

noTypeErr
editionMerInitErr

—51

0

—102
—450

No error
Bad edition reference number

Format not available
Manager not initialized

Use the ReadEdition function to read data from an edition. This function reads from the

current mark for the specified format.
FUNCTION

ReadEdition

(whichEdition:
FormatType;

EditionRefNum;
buffPtr:

UNIV

whichFormat:

Ptr;

VAR

buffLen:

Size)

OSErr;

The whichEdition parameter is the reference number for the edition. The whichFormat
parameter indicates the format type that you want to read.

4-68

Edition Manager Routines

The Edition Manager

The buffPtr parameter is a pointer to the buffer into which you want to read the data. The
buffLen parameter is the number of bytes that you want to read into the buffer. The buffLen
parameter is also a return value that returns the total number of bytes read into the buffer. If
the buffLen parameter returns a value smaller than the value you have specified, there is no
additional data to read, and the ReadEdition function returns a noErr result code. If you use

the ec i
result code.

function after all data is read in, the ReadEdition function returns an eofErr

You can read data from an edition while a publisher on the same machine is writing data
to the same edition. The data that you are reading is the old edition (not the data that the
publisher is writing). If the publisher finishes writing data before you are through reading
the old edition data, the ReadEdition function returns an abortErr result code. If the
ReadEdition function returns an abortErr result code, you should stop trying to read data
and use the CloseEdition function with the successful parameter set to FALSE.
In addition, you may also receive file reading errors.
Result codes
noErr
abortErr
eofErr
rfNumErr

0)
—27
—39
—5]

noTypeErr
editionMerInitErr

—102
—450

Writing out Edition

Data

No error
Publisher has written a new edition
No more data of that format
Bad edition reference number

Format not available
Manager not initialized

To initiate the writing of data from a publisher to its edition container, use the OpenNewEdition
function.
Bay

FUNCTION

OpenNewEdition

(publisherSectionH:

SectionHandle;

fdCreator:

OSType;

publisherSectionDocument:

FSSpecPtr;

refNum:

EditionRefNum)

:

&

VAR

OSErr;

S.
St
S
5

<4
—

£5
=pt)
oe@

The publisherSectionH parameter is the publisher section that is writing to the edition. The
fdCreator parameter is the Finder creator type of the new edition icon.

Lar |

The publisherSectionDocument parameter is the document that contains the publisher. This
parameter is used to create an alias from the edition to the publisher’s document. If you pass
NIL for publisherSectionDocument, an alias is not made in the edition file.
The refNum parameter returns the reference number for the edition. This parameter is
necessary for subsequent calls to WriteEdition, SetEditionFormatMark, and CloseEdition to
specify which publisher is writing its data to an edition. If the edition cannot be opened for
writing because there is another publisher writing to it, or because the file system does not
allow writing, an error is returned and refNum is set to NIL.
The OpenNewEdition function returns an flLckdErr result code if there is a subscriber on
another machine reading data from the same edition. The OpenNewEdition function returns a
permErr result code if there is a registered publisher to that edition on another machine.
Edition Manager Routines

4-69

Inside Macintosh, Volume VI

The Edition Manager allows two registered publishers that are located on the same machine to
write to the same edition. Note that multiple publishers cannot write to the same edition
simultaneously—only one publisher can write to an edition at a given time.
In addition, you may also receive file creating, file opening, file reading, resolve alias, and
memory errors.
Result codes

noErr
flLckdErr
permErr
wrPermErr
editionMgrInitErr

0
—45
—54
-61
450

No error
Edition in use by another section
Registered publisher on another machine
Not a publisher
Manager not initialized

Use the WriteEdition function to write data to an edition. This function begins writing at the
current mark for the specified format.
FUNCTION

WriteEdition

(whichEdition:

FormatType;

EditionRefNum;

buffPtr:

UNIV

whichFormat:

Ptr;

buffLen:

Size)

:

OSErr;

The whichEdition parameter is the reference number for the edition. The whichFormat
parameter indicates the format type that you want to write.
The buffPtr parameter is a pointer to the buffer that you are writing into the edition. The
buffLen parameter is the number of bytes that you want to write. If the data cannot be entirely
written to the edition, the WriteEdition function returns an error.
In addition, you may also receive file writing and memory errors.
Result codes

noErr
rfNumErr

—51

editionMerInitErr

0

—450

No error
Bad edition reference number

Manager not initialized

Closing an Edition After Reading

or Writing

After finishing reading from or writing to an edition, use the CloseEdition function to close
the edition.
FUNCTION

CloseEdition

(whichEdition:
:

EditionRefNum;

successful:

Boolean)

OSErr’:

The whichEdition parameter is the reference number for the edition. The successful parameter
indicates whether your application was successful in reading or writing data to the edition.
When a subscriber successfully finishes reading data from the edition, the CloseEdition
function takes the modification date of the edition file that you have read and puts it in the
mdDate field of the subscriber’s section record. This indicates that the data contained in the
edition and the subscriber section within the document are the same.
4-70

Edition Manager Routines

The Edition Manager

When a subscriber is unsuccessful in reading data from an edition (because there is not

enough memory, or you didn’t find a format that you can read), set the successful parameter
to FALSE. The CloseEdition function then closes the edition, but does not set the mdDate
field. This implies that the subscriber is not updated with the latest edition.
When a publisher successfully finishes writing data to an edition, the CloseEdition function
makes the data that the publisher has written to the edition available to any subscribers and
sets the corresponding edition file’s modification date (ioFIMdDat) to the mdDate field of the
publisher’s section record. The Edition Manager then sends a Section Read event to all
current subscribers set to automatic update mode. At this point, the file type of the edition file
is set based on the first known format that the publisher wrote.
When a publisher is unsuccessful in writing data to an edition, the CloseEdition function
discards what the publisher has written to the edition. The data contained in the edition prior
to writing remains unchanged, and Section Read events are not sent to subscribers.
In addition, you may also receive file closing errors.
Result codes
noErr
rfNumErr

editionMegrInitErr

Displaying

Dialog

—5]

0)

—450)

No error
Bad edition reference number

Manager not initialized

Boxes

Use the GetLastEditionContainerUsed function to get the default edition to display. This
function allows a user to easily subscribe to the data recently published.
FUNCTION

GetLastEditionContainerUsed

(VAR container:
EditionContainerSpec)

:

OSErr;

.

yj

If the GetLastEditionContainer function locates the last edition for which a section was created,
the container parameter contains its volume reference number, directory ID, filename, and part,
and returns a noErr result code. (The last edition created is associated with the last time that

your application or another application located on the same machine used the NewSection
function.) If the last edition used is missing, the GetLastEditionContainerUsed function returns
an fnfErr result code, but still returns the correct volume reference number and directory ID
that you should use for the NewSubscriberDialog function.
Pass the information from the GetLastEditionContainerUsed function to the

NewSubscriberDialog function.
Result codes
noErr

fnfErr

editionMerInitErr

()

—43

—450

No error

Edition container not found

Manager not initialized

Edition Manager Routines

4-7]

S,
=
S
5

—<
—

ee)

5
ga(s:)
i)

or |

Inside Macintosh,

Volume

VI

The Edition Manager supports three dialog boxes: publisher, subscriber, and options dialog
boxes. Your application can display simple dialog boxes that appear centered on the user’s
screen, or you can customize your dialog boxes.
Unlike the Standard File routines, the NewPublisherDialog and the NewSubscriberDialog
functions allow you to specify the initial volume reference number and directory ID so
that there can be one default location for editions for all applications.
Use the NewSubscriberDialog function to display the subscriber dialog box on the
user’s screen.
FUNCTION

NewSubscriberDialog

(VAR

reply:

NewSubscriberReply)

:

OSErr;

The reply parameter contains the new subscriber reply record.
TYPE

NewSubscriberReply

=

RECORD

canceled:

Boolean;

{user canceled
{ dialog
box}

}

formatsMask:

SignedByte;

{formats

required}

container:

EditionContainerSpec

{edition

selected}

END;

The NewSubscriberDialog function (which is based on the CustomGetFile procedure
described in the Standard File Package chapter in this volume) switches to the volume reference number and directory ID and selects the filename of the edition container that you
passed in. Use the GetLastEditionContainerUsed function to set the edition container to the

last edition that was either published or subscribed to. This allows the user to publish and
then easily subscribe.

The formatsMask field indicates which edition format type (text, graphics, and sound) to
display within the subscriber dialog box. You can set the formatsMask field to the following

constants: kTEXTformatMask (1), kPICTformatMask (2), or ksndFormatMask (4). To

support a combination of formats, add the constants together. For example, a formatsMask
of 3 displays both graphics and text edition format types in the subscriber dialog box.
Note that if an edition does not contain either 'PICT', 'TEXT', or 'snd ' data, it will not be

seen by the NewSubscriberDialog function (unless you install an opener that adds it using
eoCanSubscribe).

If the NewSubscriberDialog function returns with the canceled field set to TRUE, the user
canceled the dialog box. Otherwise, this field is FALSE and the container field holds the
edition container for the new subscriber.
Result codes

noErr
editionMerInitErr
badSubPartErr

4-72

0)
—450
—454

Edition Manager Routines

No error
Package not initialized
Bad edition container spec

The Edition Manager

Use the NewPublisherDialog function to display the publisher dialog box on the user’s screen.
FUNCTION

NewPublisherDialog

(VAR

reply:

NewPublisherReply)

:

OSErr;

The reply parameter contains a new publisher reply record.
TYPE

NewPublisherReply

=

RECORD

canceled:

Boolean;

{user

replacing:

Boolean;

{user chose existing }
{ filename for an edition}

canceled

usePart:

Boolean;

{always

false

preview:

Handle;

{handle

to

previewFormat:
container:

FormatType;
EditionContainerSpec

{

'TEXT',

{type of
{edition

dialog

in

'prvw',
or

'snd'

box}

version

7.0}

'PICT',

}

data}

preview}
chosen}

END;

The NewPublisherDialog function (which is based on the CustomPutFile procedure described
in the Standard File Package chapter) switches to the volume reference number and directory
ID and sets the text edit field to the filename of the edition container that you passed in. Set the
fileName field of the file system specification record to be the default name of the edition file.
(The new publisher reply record includes a container field for an edition container specification
record, and the edition container specification record includes a field [theFile] for a file system
specification record.) See “Creating a Publisher” earlier in this chapter for information on the
default file specification.
The usePart field must be set to FALSE before calling the NewPublisherDialog function.
Set the preview field to be a handle to 'prvw', ‘PICT’, 'TEXT", or 'snd ' data. Set the
previewFormat field to indicate which type of data the handle references.

rN

Upon return of the NewPublisherDialog function, the canceled and replacing fields are set. If
the canceled field is set to TRUE, the user canceled the dialog box. If the replacing field is
TRUE, the user chose an existing filename from the list of available editions and confirmed
this replacement. If the replacing field is TRUE, do not call the CreateEditionContainerFile
function, which creates a new edition container. The container field contains the volume
reference number, directory ID, and filename for the edition that the user selected.
You should deallocate the handle referenced by the preview field to free up memory.
Result codes

noErr
editionMgrInitErr
badSubPartErr

0
—450
—454

No error
Package not initialized
Bad edition container spec

Edition Manager Routines

4-73

=

&
=
°
5
ra
2
=|
i)
gea)
—

ew

|

Inside Macintosh, Volume VI

Use the SectionOptionsDialog function to display the publisher options and subscriber
options dialog boxes on the user’s screen.
SectionOptionsDialog

FUNCTION

(VAR

reply:

SectionOptionsReply)

:

OSErr;

The reply parameter contains a section options reply record.
TYPE

SectionOptionsReply

=

RECORD

canceled:

Boolean;

{user

changed:

Boolean;

{changed

canceled

sectionH:

SectionHandle;

{handle to the specified
{ section record}

action:

ResType

{action

the

dialog
section

box}
record}

}

codes}

END;

Set the sectionH parameter to the handle to the section record for the section the user selected.
Upon return of the SectionOptionsDialog function, the canceled and changed fields are set. If
the canceled parameter is set to TRUE, the user canceled the dialog box. Otherwise, this

parameter is FALSE. If the changed parameter is TRUE, the user changed the section record.
For example, the update mode may have changed.

The action field contains the code for one of five user actions.
m action code is 'read' for user selection of the Get Edition Now button
m action code is 'writ' for user selection of the Send Edition Now button
m action code is 'goto' for user selection of the Open Publisher button
m

action code is 'cncl' for user selection of the Cancel Publisher or Cancel Subscriber
button

m actioncodeis'

'($20202020) for user selection of the OK button

Note that you may receive memory errors.
The NewSubscriberExpDialog, NewPublisherExpDialog, and SectionOptionsExpDialog
functions are the same as the simple dialog functions but have five additional parameters.
These additional parameters allow you to add items to the bottom of the dialog boxes,
apply alternate mapping of events to item hits, apply alternate meanings to the item hits,
and choose the location of the dialog boxes.
FUNCTION

NewSubscriberExpDialog

(VAR

reply:

Point;

NewSubscriberReply;

expansionDITLresID:

where:

Integer;

GlgHook:
ExpDlgHookProcPtr;
filterProc:
ExpModalFilterProcPtr;
yourDataPtr:
UNIV
Ptr)
: OSErr;

4-74

Edition Manager Routines

The Edition Manager

FUNCTION

NewPublisherExpDialog

(VAR

reply:

Point;

NewPublisherReply;

dlgHook:

ExpDlgHookProcPtr;

ExpModalFilterProcPtr;
Pir)
: OSErr;

FUNCTION

SectionOptionsExpDialog

(VAR

where:
Integer;

expansionDITLresID:

reply:

Point;

filterProc:

yourDataPtr:

SectionOptionsReply;

expansionDITLresID:

UNIV

where:

Integer;

AlgHook:
ExpDlgHookProcPtr;
_
filterProc:
ExpModalFilterProcPtr;
yourDataPtr:

UNIV

Ptr)

:

OSErr;

The reply parameter contains a pointer from the new subscriber reply, new publisher reply,
or the section options reply records.
You can automatically center the dialog box by passing (—1, —1) in the where parameter.
The expansionDITLresID parameter should be 0 or a valid dialog item list (‘DITL') resource
ID. This integer is the ID of a dialog item list whose items are appended to the end of the
standard dialog item list. The dialog items keep their relative positions, but they are moved as
a group to the bottom of the dialog box. See the Dialog Manager chapter in Volume I for
additional information on dialog item lists.
The filterProc parameter should be a valid expandable modal filter procedure pointer or NIL.
This procedure is called by the ModalDialog procedure. This function allows you to map real
events (such as a mouse-down event) to an item hit (such as clicking a Cancel button). For

instance, you may want to map a keyboard equivalent to an item hit.

The dlgHook parameter should be a valid expandable dialog hook procedure pointer or NIL.
This procedure is called after each call to the ModalDialog procedure. The dialog hook
procedure takes the appropriate action, such as filling in a check box. The itemOffset
parameter to the procedure is the number of items in the dialog item list before your
expansion dialog items. You need to subtract the item offset from the item hit to get the
relative item number in the expansion dialog item list. The return value from the dialog hook
procedure is the absolute item number.
The yourDataPtr parameter is reserved for your use. It is passed back to your hook and
modal-dialog filter function. This parameter does not have to be of type Ptr—it can be any
32-bit quantity that you want. In Pascal, you can pass in register A6 for yourDataPtr, and
make dialog hook and filter procedure local functions without the last parameter. The stack
frame is set up properly for these functions to access their parent local variables. See the
Standard File Package chapter in this volume for detailed information.
For the NewPublisherExpDialog and NewSubscriberExpDialog functions, all the pseudoitems for the Standard File Package such as hookFirstCall(—1), hookNullEvent(100),
hookRebuildList(101), and hookLastCall(—2) can be used, as well as
hookRedrawPreview(150).

Edition Manager Routines

4-75

hee

=)
-¥
==
=

K<
—

ts
=}
a
ge
i)

Ler |

Inside Macintosh, Volume VI

For the SectionOptionsExpDialog function, the only valid pseudo-items are hookFirstCall(—1),
hookNullEvent(100), hookLastCall(—2), emHookRedrawPreview( 150),
emHookCancelSection(160), emHookGoToPublisher(161), emHookGetEditionNow(162),
emHookSendEditionNow(162), emHookManualUpdateMode(163), and

emHookAutoUpdateMode( 164).

If you have an expandable dialog hook function, it must contain the following parameters.
FUNCTION

MyExpDlgHook

(itemOffset:
DialogPtr;

Integer;

itemHit:

yourDataPtr:

Integer;

Ptr)

:

theDialog:

Integer;

If you have an expandable modal-dialog filter function, it must contain the following
parameters.
FUNCTION

MyExpModalFilter

(theDialog:

DialogPtr;

EventRecord;
Integer;

Locating a Publisher and

VAR

itemOffset:

yourDataPtr:

Edition From

theEvent:
Integer;

Ptr)

:

VAR

itemHit:

Boolean;

a Subscriber

The GetEditionInfo function returns information about a section’s edition such as its location,

last modification date, creator, and type.
FUNCTION

GetEditionInfo

(sectionH:

SectionHandle;

EditionInfoRecord)

:

VAR

editionInfo:

OSErr;

The sectionH parameter is a handle to the section record for a given section. The editionInfo
parameter contains an edition information record. The GetEditionInfo function returns the
public information contained in the section’s control block.
The Edition Manager synchronizes to ensure that the existing edition name corresponds to the
Finder’s existing edition name. If the control block field of the section record is NIL, or the
edition cannot be located, the GetEditionInfo function returns an fnfErr result code.
TYPE

EditionInfoRecord

=

RECORD

crDate:

TimeStamp;

{date

edition

mdDate:
fdCreator:
fdType:

TimeStamp;
OSType;
OSType;

{ was
{date
{file
{file

created}
of last
change}
creator}
type}

container

container:

EditionContainerSpec

{the

edition}

END;

The crDate field contains the creation date of the edition. The mdDate field contains the
modification date of the edition.

4-76

Edition Manager Routines

}

The Edition Manager

The fdCreator and fdType fields are the creator and type of the edition file. The container
field includes a volume reference number, directory ID, filename, script, and part number
for the edition.

Result codes

noErr
fnfErr
editionMerInitErr

0
—43
—450)

No error
Not registered or file moved
Manager not initialized

When the user wants to locate the publisher for a particular subscriber (by choosing Open
Publisher in the subscriber options dialog box), the action code 'goto' is returned to you.
Use the GetEditionInfo function to find the edition container. You should next use the
GoToPublisherSection function to open the document containing the publisher.
Use the GoToPublisherSection function to resolve the alias in the edition to find the document
containing its publisher. In general, this function internally uses the GetStandardFormats
function to get the alias to the publisher document and then resolves the alias. It next sends the
Finder an Apple event to open the document (which launches its application if necessary) and,
after the publisher is registered, sends a Section Scroll event to the publisher.
As an optimization, if there is a registered publisher, the GoToPublisherSection function
simply sends a Section Scroll event to the publisher.
If the edition does not contain an alias and there are no registered publishers, then the
GoToPublisherSection function sends an Open Documents event to open the edition to
the creating application.
If the edition container is not an edition file (such as when you are using bottlenecks to

subscribe to non-edition files), the GoToPublisherSection function sends the Finder an

Apple event to open that file.
FUNCTION

dee

GoToPublisherSection

(container:

EditionContainerSpec)

:

OSErr;

co
~~

a.
mee

a
pase
=

eet
—

=<
—

The container parameter includes the edition volume reference number, directory ID, and
filename. You obtain the edition container by calling the GetEditionInfo function.

)
—

=

a

Fa
@

In addition, you may also receive resolve alias errors.
Result codes

noErr

editionMegrInitErr
badSubPartErr

0

—450
—454

ar)

No error

Manager not initialized

Invalid edition container

Edition Manager Routines

4-77

Inside Macintosh, Volume VI

Edition

Container

Formats

The Edition Manager calls the GetStandardFormats function to get the alias used in the
GoToPublisherSection function and to get the preview shown in the subscriber dialog
box. You probably do not need to call this function directly.
FUNCTION

GetStandardFormats

(container:

EditionContainerSpec;

previewFormat:

FormatType;

publisherAlias,

formats:

:

VAR

preview,

Handle)

OSErr;

The container parameter is a pointer to the edition volume reference number, directory ID,
filename, and part.
You should pass in valid handles for the formats that you want and NIL for the formats that
you don’t want. The handles are resized to the size of the data.
The preview parameter tries to find one of four formats: 'prvw', 'PICT', 'TEXT’, or 'snd'.
The publisherAlias parameter reads the format kPublisherDocAliasFormat (‘alis'), and the
formats parameter reads the virtual format kFormatListFormat (‘fmts'). The first format that
was written returns in the preview handle and the previewFormat parameter is set to its type.
If one of the requested formats cannot be found, GetStandardFormats returns a noTypeErr
result code.
Result codes

noErr
noTypeErr
editionMerInitErr

Reading

0
—102
—450

and Writing

No error
Edition container not found
Manager not initialized

Non-Edition

Files

The Edition Manager never opens or closes an edition container directly—it calls the current
edition opener. See “Subscribing to Non-Edition Files” earlier in this chapter for additional
information.
To override the standard opener function, you should create an opener function that contains
the following parameters.
FUNCTION

MyOpener

(selector:

EditionOpenerVerb;

EditionOpenerParamBlock)

:

VAR

PB:

OSErr;

When this function is called by the Edition Manager, the selector parameter is set to one of the
edition opener verbs (eoOpen, eoClose, eoOpenNew, eoCloseNew, eoCanSubscribe). The

PB parameter contains an edition opener parameter block record.

Use the GetEditionOpenerProc function to locate the current edition opener procedure.
FUNCTION

GetEditionOpenerProc

(VAR

opener:

EditionOpenerProcPtr)

The opener procedure returns the pointer to the current edition opener procedure.
4-78

Edition Manager Routines

:

OSErr;

The Edition Manager

Use the SetEditionOpenProc function to provide your own edition opener procedure.
FUNCTION

SetEditionOpenerProc

(opener:

EditionOpenerProcPtr)

:

OSErr;

The opener parameter is a pointer to the edition opener procedure that you are providing.
Use the CallEditionOpenerProc function to call an edition opener procedure pointer.
FUNCTION

CallEditionOpenerProc

(selector:

EditionOpenerVerb;

EditionOpenerParamBlock;

EditionOpenerProcPtr)

:

VAR

PB:

routine:

OSErr;

When this function is called by the Edition Manager, the selector parameter is set to one of the

edition opener verbs (eoOpen, eoClose, eaOpenNew, eoCloseNew, eoCanSubscribe). The

PB parameter contains an edition opener parameter block record.
TYPE

EditionOpenerParamBlock

=

RECORD

info:

EditionInfoRecord;

{edition container to
{ be subscribed to}
{publisher or }
}
{ subscriber

sectionH:

SectionHandle;

document:

FSSpecPtr;

{document

{

requesting

open}

passed}

fdCreator:

OSType;

{Finder

ioRefNum:

Longint;

{reference

ioProc:

FormatIOProcPtr;

{routine
{

creator

type}

number}

to

read

}

formats}

success:

Boolean;

{reading
or writing
{ was successful}

formatsMask:

SignedByte

{formats

{

}

required

}
to

}

subscribe}

END;

The routine parameter is a pointer to an edition opener procedure.
To override the standard reading and writing functions, you should create an IO function that
contains the following parameters.
FUNCTION

MyIO

(selector:
OSErr};

FormatIOVerb;

VAR

PB:

FormatIOParamBlock)

Set the selector parameter to one of the format I/O verbs (ioHasFormat, ioReadFormat,

ioNewFormat, ioWriteFormat). The PB parameter contains a format I/O parameter

block record.

Edition Manager Routines

4-79

—

Sar
oy
—
Tr
~ede
i
~~
a
_
—
as
—
=
~
ae
—
~

go

oO
er |

Inside Macintosh, Volume VI

Use the CallFormatIOProc function to call a format IO procedure.
FUNCTION

CallFormatIOProc

(selector:

FormatIOVerb;

FormatIlOParamBlock;

VAR

PB:

routine:

FormatIOProcPtr)

OSErr;

Set the selector parameter to one of the format I/O verbs (ioHasFormat, ioReadFormat,
ioNewFormat, ioWriteFormat). The PB parameter contains a format I/O parameter

block record.
TYPE

FormatIOParamBlock

=

RECORD
ioRefNum:

LongInt;

{reference

format:

FormatType;

{edition

formatIndex:

Longint;

{opener-specific

offset:

LongInt;

{ of formats}
{offset
into

format}

buffPtr:

Ptr;

{data

here}

buffLen:

LongInt

{length

END;

The routine parameter is a pointer to a format I/O procedure.

4-80

Edition Manager Routines

number}
format

starts
of

data}

type}

enumeration

}

The Edition Manager

SUMMARY

OF

THE

EDITION

MANAGER

Constants
CONST

{resource

types}

rSectionType

=

“sect.” s

{resource

stSubscriber
stPublisher

=
=

SO;
SOA;

{subscriber section type}
{publisher section type}

{update modes}
sumAutomatic

=

O06

{subscriber

{section

type

for

a

section}

types}

{
sumManual

=

L;

=

pumManual

=

{edition

container

subpart

0;
143

new

}

automatically}

{subscriber

{
pumOnSave

receives

editions

receives

editions

new

}

manually}

{publisher

sends

{

editions

on

{publisher

does

{

new

{

request }

new

}

save}

editions

not

send

until

user

}
}

number}

kPartsNotUsed

=

0;

{edition

kPartNumberUnknown

=

-l;

{not

{preview size}
kPreviewWidth

=

120:

{preview

width}

x

kPreviewHeight

=

120);

{preview

height}

=

{special formats}
kPublisherDocAliasFormat

=

‘alis';

kPreviewFormat
kFormatListFormat

=
=

‘prvw"';
'fmts';

{alias record from the }
{ edition to publisher}

=
=
Am

{

ey

=
=
=

a
2}
@s

{bits

for

is

the

in

whole

version

file}

7.0}

{'PICT' thumbnail sketch}
{list of all available }
formats

and

their

=
is

sizes}

formatMask}

kPICTformatMask
kTEXTformatMask
ksndFormatMask
{Finder

used

types

for

edition

{graphics
format}
{text
format}
{sound
format}

files}

kPICTEditionFileType
kTEXTEditionFileType
ksndEditionFileType

=
=
=

‘'edtp';
“edtt';
‘edie s

{contains
'PICT',
}
{ "TEXT",
and. }
{ 'snd ' file types}

kUnknownEditionFileType

=

‘edtu';

{unknown

file

type}

Summary of the Edition Manager

4-81

Inside Macintosh, Volume VI

{miscellaneous}
kFormatLengthUnknown

{message

IDs

for

=

Apple

events

sectionEventMsgClass

<1;

{length

sent
=

by

the

'sect';
'read';

{Section

Read

=

'writ';

{Section

Write

sectionScrollMsgID
sectionCancelMsgID

=
=

'scrl';
'cncl';

{Section
{Section

Scroll
Cancel

=

stacked
'stdf';
'nfdr';

dialog boxes}
{new publisher and
{ new subscriber}
{new folder}

=

'rplc';

{replace

dialog}

sfStatWarnDialogRefCon

=

'stat';

{warning

dialog}

sfErrorDialogRefCon
emOptionsDialogRefCon

=
=

'err
';
'optn';

{error dialog}
{options
dialog}

emCancelSectionDialogRefCon
emGotoPubErrDialogRefCon

=
=

'cncl';
'gerr';

{cancel
{locate

{pseudo-item

saat sre

i

=

1503:

{for

}

events}
events}

=

for

the

events}

sfNewFolderDialogRefCon

hits

by

events}

sfReplaceDialogRefCon

}

section}
publisher}

NewPublisher

or

}

emHookCancelSection
emHookGoToPublisher

=
=

160;
T61%

{ NewSubscriber dialogs}
{for SectionOptions dialog}
{for SectionOptions dialog}

emHookGetEditionNow

=

162;

{for

SectionOptions

dialog}

emHookSendEdit

=

162;

{for

SectionOptions

dialog}

=

163;

{for

SectionOptions

dialog}

=

164;

{for

SectionOptions

dialog}

ionNow

emHookManualUpdat

eMode

emHookAut oUpdat eMode

Types
TimeStamp
EditionRefNum

=
=

LongInt;
Handle;

{seconds
{for use

Updat eMode

=

Integer;

{sumAutomatic,

{
SectionType

=

SignedByte;

FormatType

=

PACKED

SectionHandle

=

SectionPtr

SectionRecord
RECORD

version:

4-82

sent

Manager}

=

emHookRedrawPreview

TYPE

Edition

sectionWriteMsgID

displaying

unknown}

Manager}

events

sectionReadMsgID

{refCon field when
sfMainDialogRefCon

Data

format

Edition

{Apple

{

of

=

since 1904}
in Edition I/O}
}

sumManual,

}

{ pumOnSave,
pumManual}
{stSubscriber
or stPublisher}

ARRAY[1..4]

OF

CHAR;

{similar

to

{

Scrap

by

the

ResType

used

Manager}

“SectionPtr;

*SectionRecord;

=

SignedByte;

Summary of the Edition Manager

{always

1

in

version

7.0}

}

The Edition Manager

kind:
mode:

SectionType;
UpdateMode;

{publisher
{automatic

mdDate:

TimeStamp;

{last

sectionID:

Longint;

{application-specific,

refCon:

Longint;

{ unique per document}
{application-specific}

alias

AliasHandle;

{handle

to

alias

record}

and

set

up

the

{The
{

following

fields

RegisterSection

are

private

change

are

subscriber}
manual}
to

section}

by

}

}

function.}

subPart:

LongInt;

{private}

controlBlock:

Handle;

{private}

refNum:

EditionRefNum

{private}

nextSection:

or
or

SectionHandle;

{private}

END;

EditionContainerSpecPtr =*EditionContainerSpec;
EditionContainerSpec
=
RECORD

theFile:

FSSpec;

{file
{

END;

containing

edition

}

data}

theFileScript:
thePart:

ScriptCode;
Longint;

{script code of filename}
{which part of file,
}

thePartName:

Str31;

{ always
kPartsNotUsed}
{mot used
in version 7.0}

thePartScript:

FormatsAvailable

ScriptCode

=

ARRAY[0..0]

{not

used

in

version

7.0}

OF

RECORD

b

theType:

FormatType;

{format

type

theLength:

LongInt

{length

of

{ type}

for

an

edition

edition}

se

format

=

}

EditionInfoRecord

RECORD

S

2

END;

=

%

crDate:

TimeStamp;

{date

mdDate:

TimeStamp;

{date

of

fdCreator:

OSType;

{file

creator}

fdType:
container:

OSType;
{file type}
EditionContainerSpec
{the edition}

{

was

edition

container

e

}

created}
last

change}

END;

Summary of the Edition Manager

4-83

Inside Macintosh,

Volume V1

NewPublisherReply

=

RECORD
canceled:

Boolean;

{user

replacing:

Boolean;

usePart:
preview:

Boolean;
Handle;

{user chose existing }
{ filename for an edition}
{always FALSE in version 7.0}

canceled

{handle
{

to

'TEXT',

previewFormat:

FormatType;

container:

EditionContainerSpec

{type

of

{edition

dialog

'prvw',
or

'snd'

box}

'PICT',

}

data}

preview}
chosen}

END;

NewSubscriberReply

=

RECORD

canceled:

Boolean;

formatsMask:
container:

SignedByte;
{formats
EditionContainerSpec
{edition

{user

canceled

dialog

box}

required}
selected}

END;

SectionOptionsReply
RECORD

=

canceled:

Boolean;

{user

canceled

changed:

Boolean;

{changed

sectionH:

SectionHandle;

{handle to the specified
{ section record}

action:

ResType

{action

the

dialog
section

box}
record}

}

codes}

END;

EditionOpenerVerb
EditionOpenerParamBlock

=
=

(eoOpen, eoClose,
eoCanSubscribe) ;

eoOpenNew,

eoCloseNew

RECORD

info:

sectionH:

EditionInfoRecord;
{edition container to }
{ be subscribed to}
SectionHandle;
{publisher or
subscriber}

document :
fdCreator:
ioRefNum:

FSSpecPtr;
OSType;
LongInt;

{ requesting
open}
{document
passed}
{Finder creator
type}
{reference
number}

success:

Boolean;

{routine
{reading

formatsMask:

SignedByte

{ successful}
{formats
required

ioProc:

FormatIOProcPtr;

{
END;

4-84

Summary of the Edition Manager

to
or

subscribe}

read formats}
writing was }
to

}

The Edition Manager

Format IlOVerb

=

(ioHasFormat,

ioReadFormat,

ioNewFormat,

ioWriteFormat) ;
FormatIOParamBlock

=

RECORD

ioRefNum:

Longint;

{reference

format:

FormatType;

{edition

format Index:

LongInt;

{opener-specific
{

of

number}
format

type}
enumeration

}

formats}

offset:
buff£Ptr:

LongInt;
PEL;

{offset
into
{data
starts

buffLen:

Longint

{length

of

format}
here}

data}

END;

Routines

Initializing the Edition
FUNCTION

Creating
FUNCTION

Manager

InitEditionPack

and

:

Registering

OSErr;

a Section

NewSection

(container:

EditionContainerSpec;

sectionDocument:

SectionType;
initialMode:

SectionHandle)
FUNCTION

RegisterSection

FSSpecPtr;

kind:

sectionID:
LongInt;
UpdateMode;
VAR sectionH:

: OSErr;

(sectionDocument:
FSSpec;
sectionH:
SectionHandle;
VAR aliasWasUpdated:

in
=

Boolean)

=

:

OSErr;

FUNCTION

UnRegisterSection

(sectionH:

SectionHandle)

:

OSErr;

=

FUNCTION

IsRegisteredSection

(sectionH:

SectionHandle)

:

OSErr;

}

FUNCTION

AssociateSection

(sectionH:
SectionHKandle;
°
newSectionDocument:
FSSpecPtr)

a

is

“

OSErr;

Creating
FUNCTION

and

Deleting

an Edition

CreateEditionContainerFile

Container

(editionFile:
FSSpec;
fdCreator:
OSType;
editionFileNameScript:
ScriptCode)
OSErr;

FUNCTION

DeleteEditionContainerFile

(editionFile:

FSSpec)

:

OSErr;

Summary of the Edition Manager

4-85

Inside Macintosh,

Volume VI

Setting and

Locating

FUNCTION

a Format

SetEditionFormatMark

Mark

(whichEdition:
FormatType;

FUNCTION

GetEditionFormatMark

EditionRefNum;
setMarkTo:

whichFormat:

LongInt)

(whichEdition:
EditionRefNum;
FormatType;
VAR currentMark:

:

OSErr;

whichFormat:
LongInt)

OSErr;

Reading
FUNCTION

in Edition

Data

OpenEdition

(subscriberSectionH:

EditionRefNum)
FUNCTION

EditionHasFormat

(whichEdition:

FormatType;
FUNCTION

ReadEdition

FormatType;
:

SectionHandle;

VAR

refNum:

OSErr;

EditionRefNum;

VAR

(whichEdition:
Size)

:

formatSize:

EditionRefNum;
buffPtr:

UNIV

whichFormat:

Size)

:

OSErr;

whichFormat:

Ptr;

VAR

buffLen:

OSErr;

Writing out Edition Data
FUNCTION

OpenNewEdition

(publisherSectionH:
SectionHandle;
fdCreator:
OSType; publisherSectionDocument:
FSSpecPtr;
VAR refNum: EditionRefNum)
: OSErr;

FUNCTION

WriteEdition

(whichEdition:
FormatType;

EditionRefNum;
buffPtr:

UNIV

whichFormat:

Ptr;

buffLen:

Size)

OSErr;

Closing an Edition After Reading or Writing
FUNCTION

CloseEdition

(whichEdition:
Boolean)

Displaying
FUNCTION

Dialog

:

EditionRefNum;

successful:

OSErr;

Boxes

GetLastEditionContainerUsed

(VAR

container:

EditionContainerSpec)

OSErr;
FUNCTION

NewSubscriberDialog

(VAR

reply:

NewSubscriberReply)

OSEYr;
FUNCTION

NewPublisherDialog

(VAR

reply:

OSEHrxs

4-86

Summary of the Edition Manager

NewPublisherReply)

The Edition Manager

FUNCTION

SectionOptionsDialog

(VAR reply:
OSErr;

SectionOptionsReply)

FUNCTION

NewSubscriberExpDialog

(VAR

NewSubscriberReply;

reply:

where:
Point;
expansionDITLresID:
Integer;
dlgHook:

ExpDlgHookProcPtr;

filterProc:

ExpModalFilterProcPtr;
UNIV Ptr)
OSErr;

FUNCTION

NewPublisherExpDialog

(VAR

reply:

where:

NewPublisherReply;

Point;

Integer;

yourDataPtr:

expansionDITLresID:

dlgHook:

ExpDlgHookProcPtr;

filterProc:

ExpModalFilterProcPtr;
UNIV Ptr)
OSErr};

FUNCTION

SectionOptionsExpDialog

yourDataPtr:

(VAR reply:
SectionOptionsReply;
where:
Point; expansionDITLresID:
Integer;

dlgHook:

ExpDlgHookProcPtr;

filterProc:

ExpModalFilterProcPtr;
UNIV

Ptr)

Locating a Publisher and Edition From
FUNCTION

GetEditionInfo

(sectionH:

a Subscriber

SectionHandle;

EditionInfoRecord)

FUNCTION

GoToPublisherSection

Edition

Container

FUNCTION

GetStandardFormats

(container:

VAR

editionInfo:

OSErr;

EditionContainerSpec)

OSErr;

r
u

Formats

lm!

(container:
EditionContainerSpec;
VAR
previewFormat:
FormatType;
preview,

publisherAlias,

Reading

yourDataPtr:

OSErr;

and Writing

Non-Edition

formats:

Handle)

OSErr;

files

opener:

—

GetEditionOpenerProc

(VAR

FUNCTION

SetEditionOpenerProc

(opener:

FUNCTION

CallEditionOpenerProc

(selector:
EditionOpenerVerb;
VAR PB:
EditionOpenerParamBlock;
routine:

EditionOpenerProcPtr)

EditionOpenerProcPtr)

EditionOpenerProcPtr)
CallFormatIOProc

(selector:

eal
ne
-_
i
—
ae
_
re
-)

o

FUNCTION

FUNCTION

—
wee
_
—
~
—
—)
—

FormatIOProcPtr)

OSErr;

OSErr;

FormatIOVerb;

FormatIOParamBlock;

OSErr;

VAR

PB:

routine:
OSErr;

Summary of the Edition Manager

4-87

’

Inside Macintosh,

Volume VI

Application-Defined
FUNCTION

Routines
(itemOffset:
Integer;
itemHit:
Integer;
theDialog:
DialogPtr; yourDataPtr:
Ptr)

MyExpD1gHook

Integer;

FUNCTION

FUNCTION

MyExpModalFilter

MyOpener

(theDialog:
DialogPtr;
VAR theEvent:
EventRecord;
itemOffset:
Integer;
VAR
itemHit:
Boolean;

Integer;

yourDataPtr:

(selector:

EditionOpenerVerb;

EditionOpenerParamBlock)
FUNCTION

(selector:

MyIO

Format

Result

FormatIOVerb;

IOParamBlock)

:

Ptr)

VAR

:

OSErr;

VAR

PB:

OSErr;

Codes

noErr
abortErr
eofErr
fnfErr
flLckedErr

No error
Publisher has written a new edition
No additional data in the format
Edition container not found

rfNumErr

permErr

Bad edition reference number
Not a subscriber

noTypeErr

Format not available

Publisher writing to an edition
Section doing I/O

fBsyErr

Not a publisher

wrPermErr
memFullErr
userCanceledErr

editionMerInitErr
badSectionErr

notRegisteredSectionErr

badSubPartErr

multiplePublisherWrn

containerNotFoundWrmn
notThePublisherWrn

4-88

PB:

—460
—46]
—463

Could not load package
User chose Cancel from dialog box
Manager not initialized or could not load package
Not a valid section type
Not registered
Bad edition container spec or invalid edition container
Already is a publisher
Alias was not resolved

Not the publisher

Summary of the Edition Manager

THE

EVENT

MANAGER

About This Chapter
About the Event Manager
Introduction to Events
Low-Level Events
Operating-System Events
High-Level Events
Event Processing
The Event Loop
Event Masks
Switching Contexts
Specifying Memory Requirements and Scheduling Options
The Structure of a 'SIZE' Resource
Creating a 'SIZE' Resource
Using the Event Manager
Receiving Low-Level Events
Responding to Operating-System Events
Receiving High-Level Events
Identifying High-Level Event Senders and Receivers
Sending High-Level Events
Requesting Return Receipts
Responding to Events From Other Applications
Searching for a Specific High-Level Event
Event Manager Routines
Receiving Events
Sending Events
Receiving a Specific High-Level Event
Converting Process Serial Numbers and Port Names
Summary of the Event Manager

wi

S3)
<
@
=

_

a

—
AS
—

=
=
ge

@e
“

5-]

Inside Macintosh, Volume VI

5-2

The Event Manager

ABOUT

THIS

CHAPTER

This chapter describes how your application can use the Toolbox Event Manager to send events
to other applications and to receive events from other applications. The Toolbox Event Manager
in system software version 7.0 provides routines for sending and receiving a new type of event,
a high-level event. In addition, Apple Computer, Inc. has defined a protocol for high-level
events called the Apple® Event Interprocess Messaging Protocol. High-level events that adhere
to this protocol are called Apple events. Your application can also define other types of highlevel events and send them to applications, either locally or across a network.
This chapter also describes the operation of the multitasking environment formerly known as
MultiFinder®, which is now an integral part of the Macintosh® Operating System in system
software version 7.0. In this environment, numerous applications can be open simultaneously,
cooperatively sharing the available system resources. The Macintosh Operating System coordinates the execution of multiple applications by sending another type of event, an operatingsystem event, to applications whenever their execution status changes or whenever processor
time is available for background processing. Your application takes advantage of this multitasking capability primarily by receiving operating-system events that guide its execution.
The Event Manager routines that let your application communicate with other applications

depend on the services of the Program-to-Program Communications (PPC) Toolbox and are

available in system software version 7.0. Before using any of the routines that handle highlevel events, you should first use the Gestalt function to determine that the PPC Toolbox is
present. You can also use Gestalt to determine which multitasking features of the Operating
System are present. See the Compatibility Guidelines chapter in this volume for a full account
of using Gestalt.
The ability to have multiple applications open at once is available when running system software version 7.0 or when running MultiFinder in system software versions 5.0 and 6.0. Any
significant differences between the multitasking environment of version 7.0 and that provided
by MultiFinder in earlier system versions are noted at the appropriate locations in this chapter.
In system software earlier than version 7.0, there is no recommended way to determine
whether MultiFinder is running or whether other applications are open if it is running. When
running in system software version 7.0, applications that need to know what other applications
are open (for example, to send high-level events to them) can get that information by calling
one of three functions: the PPCBrowser function or the IPCListPorts function (both docu-

mented in the Program-to-Program Communications Toolbox chapter in this volume) or the
GetNextProcess function (documented in the Process Management chapter in this volume).
The information in this chapter supplements the information in the Toolbox Event Manager
chapter of Inside Macintosh, Volume | and Volume V. (In this chapter, the term Event
Manager refers to the Toolbox Event Manager, not the Operating System Event Manager.)
In addition, the sections on cooperative multitasking supersede the information in the
Programmer’s Guide to MultiFinder.

—

a

<
‘)
—
=

ool

rd
—

as
~

—

—

as

_—

ve

‘)
Lar |

To use this chapter, you should be familiar with the way in which the Macintosh Operating
System manages processes. See “About Process Management” in the Process Management
chapter in this volume for a detailed description of how the Operating System schedules
processes, performs context switches, and launches applications. If you want to communicate with applications across a network, then you should be familiar with the discussion of
authentication in the Program-to-Program Communications Toolbox chapter in this volume.
About This Chapter

9

5-3

Inside Macintosh,

Volume VI

ABOUT

EVENT

THE

MANAGER

Most Macintosh programs are event-driven: they decide what to do from moment to moment
by asking the Event Manager for events and responding to them one by one in whatever way
is appropriate. The Event Manager is your application’s primary link to the user, to other
applications that are running at the same time as your application, to the various managers that
are controlling operations in the Macintosh, and to the Operating System itself. Events sent to
your application from these various sources can communicate important information to it and
help ensure its smooth operation.
You can use the Event Manager to
m receive key presses and mouse clicks as input for your application
m receive indication that your application’s windows need to be activated or updated
w allow other applications to use the available system resources when no events are
pending for your application
m send events to other applications
m receive events from other applications
m respond to events received from other applications
= search for a specific event from another application
This chapter provides a brief introduction to events and then discusses a number of particular
topics that are related to high-level events and the multitasking environment that is standard in
system software version 7.0. It explains

= how to structure your main event loop to receive and process events
= how to create a 'SIZE' resource to specify your application’s memory requirements and
scheduling options
= how to receive and process high-level events
= how to send high-level events to other applications
This chapter also provides some information about Apple events, Apple’s new protocol
governing a class of high-level events. Additional information about Apple events, including
descriptions of how to process the required Apple events, is provided in the Apple Event
Manager chapter in this volume.

5-4

About the Event Manager

The Event Manager

INTRODUCTION

TO

EVENTS

Events are of various types, distinguished according to their origin and meaning. On the most
basic level, events are created every time a user presses a key on the keyboard, presses the
mouse button, releases the mouse button, or inserts a disk.
Still other events can arise from changes in the processing status of an application. For
example, if a user brings an application to the foreground, the Operating System sends a
resume event to that application. Some of the work of reactivating the application is done
automatically, both by the Operating System and by the Window Manager; the resume
event is an indication for your application to take care of any further processing needed
as a result of the application being reactivated.
In system software version 7.0, the Event Manager recognizes a new type of event—the
high-level event—that allows communication and information transfer between cooperating
applications. For example, a spreadsheet application may want to obtain some information
from a database application. The spreadsheet can send a high-level event to the database
requesting the information; the database can then reply with the requested information by
sending another high-level event back to the spreadsheet.

Low-Level

Events

Events that report actions by the user (such as pressing the mouse button, typing on the
keyboard, or inserting a disk) and events that report that the Event Manager has no other
events to report (null events) are called /ow-level events because they report very low-level
hardware and software occurrences. Figure 5-1! depicts the relationships among the
Operating System Event Manager, the Toolbox Event Manager, the Window Manager,
and a single application.
The Operating System Event Manager detects and reports very low-level events such as
changes in the attached hardware. Hardware-related events are mouse clicks, key presses,
disk insertions, and so forth.

Other low-level events can arise from changes in windows on the screen. For example, if
a user has several documents open while running an application, the user can switch from
one document to another by clicking in the appropriate window. Before your application is
sent such an event, the Window Manager does some work for you, such as highlighting
the newly activated window and unhighlighting the deactivated window. As illustrated in
Figure 5-1, activate and update events are not placed into the event queue but are sent directly
to the Toolbox Event Manager.
Applications can generate events themselves and send them (using the PostEvent function) to
the Operating System Event Manager for processing. These types of events are applicationspecific. In an environment where only one application can execute at a time, applicationdefined events allow your application to send events to itself. You should be careful not to
post events that are not normally placed in the event queue (such as activate events).
Note: In system software version 7.0, the work done by application-defined events
must be accomplished using Apple events or other high-level events.

Introduction to Events

5-5

9 1|

e9
<
@

i

-

aA

jot

i)
=}

te)

ge

a")

Lear |

Inside Macintosh,

Volume

VI

Key up

Key down

Auto key

Mouse up
Mouse down

Disk
insert

||

OS Event

=,

Manager

|

|

Event 20
Event 19

:

- queue

|

:

Window

Manager

Evert

Activate

Event 1

|

|

Update

Toolbox Event

Manager

a.

||

Application-defined

Event stream

<a
=

Figure 5-1. Events in a single application environment

Operating-System

Events

The cooperative multitasking environment introduces a new type of event to allow the Operating
System to communicate information to an application about changes in the operating status of
that application. For example, when your application is switched into the background, the
Operating System sends it a suspend event. Then, when your application is switched back into
the foreground, it receives a resume event. These types of events are known as operatingsystem events.
Figure 5-2 illustrates how the Event Manager helps provide this cooperative multitasking environment. The main new source of events is the Macintosh Operating System itself, which sends
suspend, resume, and mouse-moved events to applications through the Toolbox Event Manager.
(In system software versions earlier than 7.0, these events are sent by MultiFinder.) In addition
to the event queue created by the Operating System Event Manager, the Toolbox Event Manager
maintains a separate event queue for each open application. The events in the Operating System
Event Manager queue are always sent to the foreground application, but other events (for
example, update events from the Window Manager) can be sent to background applications.
5-6

Introduction to Events

The Event Manager

Key up

Key down

Auto key
Mouse up

Mouse down
Disk

lI

insert

OS Event

2

Manager

Event 20
Event 19

Burt

- queue

:
|

Window

=

MultiFinder

Mm

Event stream

Vv

Event 5
Event 4

| Eventi
{

:

Suspend
Resume

Manager

OA

defined

Mouse moved

Toolbox Event

a

Application-

|

||

Activate
Update

Manager

Event 1

Event 25
Event 24

|

| Eventi
{|

Event 10
Event 9

|

| Event

|

{}

=)
uw
ec)
<
o

Figure 5-2. Events in a multi-application environment

=

-

Because your application might need to execute differently depending on whether it is
running in the foreground or in the background, you can inspect the low bit of the message
field of an operating-system event to determine whether the event is a suspend or a resume
event. For example, if you need to notify the user of some special occurrence while your
application is executing in the background, you cannot simply put up an alert box. Instead,
you should use the Notification Manager to queue a notification request that will be presented
to the user at the appropriate moment.
When your application receives a suspend event, it does not actually become inactive until it
makes its next request to receive events from the Event Manager. At the time that it receives
the suspend event, your application can inspect the convertClipboard flag in the message field
Introduction to Events

5-7

<
=

$9
ge
io

ver |

Inside Macintosh,

Volume VI

of the event record to see whether it should convert any local scrap into the global scrap.
Your application should also hide any floating windows, selections, and so on. Then you
should call WaitNextEvent to relinquish the processor and allow the Operating System to
schedule other processes for execution. It is important to minimize the processing you do in
response to a suspend event because otherwise the machine may appear sluggish.
When control returns to your application, the first event it receives is a resume event. Your
application may now convert the global scrap back to its private scrap, if necessary. As part
of the resume or suspend event, the Operating System informs your application if the
Clipboard has changed by setting bit | of the message field of the event record.
There are two other kinds of operating-system events, mouse-moved events and
application-died events. A mouse-moved event is sent to an application to indicate
that the user has moved the mouse outside of the region specified to the WaitNextEvent
routine. The application-died event is sent whenever an application launched by your
application terminates or crashes.
Note: Some early versions of MultiFinder do not send application-died events, and
your application should not depend on receiving them. These events are provided
primarily for use by debuggers. In system software version 7.0, application-died
events are now sent as Apple events.

High-Level

Events

In system software version 7.0, the Event Manager introduces a new type of event, the highlevel event, along with a number of new Event Manager routines that let applications communicate with each other by exchanging high-level events. A high-level event is an event that
your application can send to another application to send it some information, to receive from
it some information, or to have it perform some action. For example, your application can
send an event to another application instructing that application to perform a specific action,
such as adding a row to a spreadsheet or changing the font size of a paragraph. Your application can also send an event to another application requesting information from that
application—for example, requesting a dictionary application to return the definition of a
particular word. When you send a high-level event to another application, you can also
include additional information or commands in an optional data buffer. For example, your
application can use a high-level event to send a list of new words and definitions to a
dictionary application.
Figure 5-3 shows the general event-handling mechanism in system software version 7.0.
Three different applications are communicating with one another by sending and receiving
high-level events. High-level events are placed in a separate event queue maintained by the
Operating System. The Operating System maintains a high-level event queue for each
application that has announced itself as capable of receiving high-level events. The high-level
event queues are limited in size only by available memory.
Note: Because high-level events are not stored in the Operating System event queue,
you cannot flush high-level events by calling the FlushEvents procedure.

5-8

Introduction to Events

The Event Manager

A
Eee

Disk
friaert

|

Key down
Auto key
Mouse up

O/S Event
Manager

Mouse down

PPC
Toolbox

I

Event

queue

Window
Manager
—

Event 20

°

|

Activate

Update

Hees
[

Event 19

[| Event1

\|

i

poets)

[eent!

=

a
|

[| Eventt

|
Mouse moved
Suspend

| Resume

level

a

.

]

[Eventi

High-

: event
|

queue

,

;~G ococs

mM

Event 5
Event 4

Event stream
wi
Event 25
Event 24

Event 10
Event 9

Event 1

| Event 1 |

| Event 1

f

J

Event 1

Toolbox Event
va

ven

J

J
=

J

ui

fy
<

7c)

Figure 5-3. Events in system software version 7.0

~

——

Pa
—

For effective communication between applications, your application must define the set of
high-level events it responds to and let other applications know the events it accepts. By
implementing the capabilities to send events to and receive events from other applications,
you allow other applications to interact with your application and provide enhanced
capabilities to your users.

Introduction to Events

=)
—

te]

a
fo)
ar |

5-9

Inside Macintosh,

Volume

VI

Generally, there is no restriction on the type of processing that one application can request
from another by sending it a high-level event. For a high-level event sent by one application
to be understood by another application, however, the sender and receiver must agree on a
protocol, that is, on the way the event is to be interpreted. Apple events are high-level events
whose structure and interpretation are determined by the Apple Event Interprocess Messaging
Protocol.
To make your application 7.0-friendly, you should support the required Apple events, as
described in the Apple Event Manager chapter in this volume. In addition, you may want
your application to support other common Apple events. For example, the Edition Manager
uses Apple events to communicate information about document sections among the various
applications that may publish sections or subscribe to them. The Edition Manager sends the

appropriate Apple events to applications that want to maintain up-to-date subscriber sections

within their documents. If a user alters a section of a document that has previously been
published and updates the edition, the Edition Manager might post an Apple event to the
application indicating that a new edition is available. The application receiving the Apple
event can then update the subscriber or ignore the information, as the user dictates. For
complete information on responding to Apple events sent by the Edition Manager, see the
Edition Manager chapter in this volume.

To ensure compatibility and smooth interaction with other Macintosh applications, you
should use the Apple event protocol for high-level events whenever possible. You should
define new protocols only if your application must communicate with applications on other
computers that use different protocols or if your application has other special needs. For
complete information about Apple events and on implementing the required set of Apple
events, see the Apple Event Manager chapter in this volume.
Note: All Macintosh system software that sends or receives high-level events uses
the Apple events protocol.

EVENT

PROCESSING

In system software version 7.0, the cooperative multitasking capabilities previously available
through MultiFinder are an integral part of the Operating System. As a result, applications ,
running under version 7.0 must process events and reserve memory in ways that contribute
to the smooth operation of all applications that are open. In practice, this means that you
should retrieve events from the Event Manager by using the WaitNextEvent function and that
you should include a 'SIZE' resource that specifies a reasonable memory partition size. This
section shows how to retrieve events from the Event Manager, how to mask out unwanted
events, and how to specify memory and scheduling options for your application.

The

Event

Loop

In applications that are event-driven (that is, which decide what to do at any time by receiving
and responding to events), you can obtain information about events that are pending by
calling Event Manager routines. Since you call these routines repeatedly, the section of code
in which you request events from the Event Manager usually takes the form of a loop; this
section of code is the event loop.
5-10

Event Processing

The Event Manager

A simple event loop might look something like the one given in Listing 5-1. It consists of an
endless loop that retrieves an event and decides whether it is a null event. If the event is not a
null event, the event loop calls DoEvent, an application-defined procedure, to process the
event. Otherwise, the procedure calls an application-defined idling procedure, Doldle.
Listing 5-1. A simple event loop
PROCEDURE

EventLoop;

VAR
cursorRgn:

RgnHandle;

gotEvent:

Boolean;

event:

EventRecord;

BEGIN
cursorRgn

:=

REPEAT
gotEvent

NewRgn;

an

empty

region

WaitNextEvent

(everyEvent,

AdjustCursor(event.where,

cursorRgn) ;

IF

:=

{pass

gotEvent

THEN

DoEvent

(event)

the
event,

first

time

GetSleep,

thru}
cursorRgn) ;

ELSE

UNTIL

DolIdle;
FALSE;

{loop

forever}

END;

The DoEvent procedure must determine what kind of event the call to WaitNextEvent retrieved
and act accordingly. Notice that the parameter passed to DoEvent is the event record received
by WaitNextEvent. Essentially, the procedure is just a large conditional statement that branches
according to the value of the what field of the event record. Listing 5-2 defines a simple
DoEvent procedure.
Listing 5-2. Processing
PROCEDURE
BEGIN
CASE

DoEvent

(event:

event.what

OF

events

EventRecord) ;

mouseDown:

DoMouseDown
mouseUp:
DoMouseUp
keyDown,

(event)

;
wn

(event)

;

<
@

autokey:

DoKeyDown

activateEvt:
DoActivate
updateEvt:
DoUpdate

=_s

(event);

=

| aren!

as
et

(event) ;

=

&

Ge

is)

(event);

OSEvt:

DoOSEvent

(event) ;

kHighLevelEvent:
DoHighLevelEvent

(event) ;

END;
END;

{DoEvent }

Event Processing

5-11

Inside Macintosh,

Volume VI

The main addition to your application’s event loop in system software version 7.0 is the
recognition of high-level events (using the constant kHighLevelEvent) and the appropriate
processing of those events. The procedure defined in Listing 5-2 calls DoHighLevelEvent,
an application-defined routine, to interpret the high-level event further.

Event

Masks

Several of the Event Manager routines can be restricted to operate on a specific event type or
group of types. You do this by disabling (or “masking out”) the events you are not interested
in receiving. To specify which event types an Event Manager routine governs, supply a
parameter known as an event mask. Masks for each individual event type are available as
predefined constants:
CONST

everyEvent
mDownMask

{every
event}
{mouse-Gown }

mUpMask

{mouse-up }
{key-down }

keyDownMask
keyUpMask

{key-up}

{auto-key}

autoKeyMask
updateMask

{update}

diskMask

{disk-inserted}

activMask
highLevelEventMask

{activate}
{high-level}

osMask

{operating-system}

You can form any particular mask you need by adding or subtracting mask constants.
For example, to request the next available event that is not a mouse-up event, you

can use the code
myErr

:=

WaitNextEvent

(everyEvent-mUpMask,

myEvent,

mySleep,

myMRgnHnd) ;

Note that masking out types of events does not remove those events from the Operating
System event queue. If a type of event is masked out, it is simply ignored by the Toolbox
Event Manager when it reads the event queue. Note also that you cannot mask out null
events. Even if every other kind of event is disabled, the Event Manager reports a null event.
In system software version 7.0, you can mask out high-level events by subtracting the
constant highLevelEventMask from your event mask. (This constant has the same value
as the defunct constant networkMask.)

Switching

Contexts

Applications running in the background receive processing time when the front application
makes an event call (that is, calls WaitNextEvent, GetNextEvent, or EventAvail) and there

are no events pending for that front application. An application running in the background
should relinquish the CPU regularly to ensure a timely return to the foreground application
when necessary.
5-12

Event Processing

The Event Manager

In system software version 7.0 (or under MultiFinder in earlier versions), the available

processing time is distributed among multiple applications through a procedure known as
context switching (or just sw itching). When a context switch occurs, the Process Manager
allocates processing time to a process that is different from the one that had been receiving
processing time. Two types of context switching may occur: major and minor. All switching
occurs at a well-defined time, namely, when an application calls WaitNextEvent.
A major switch is a complete context switch: an application’s windows are moved from the
background to the foreground, or vice versa. In a major switch, two applications are
involved, the one being switched to the foreground and the one being switched to the
background. The A5 worlds of both applications are switched, as well as the relevant lowmemory environment. If those applications receive suspend and resume events, they are so
notified at the time that a major switch occurs.
Major switching does not occur when a modal dialog box is the frontmost window, although

minor switching (discussed next) can still occur. To determine whether major switching can

occur, the Operating System checks (among other things) to see if the window definition
procedure of the frontmost window is dBoxProc because the type dBoxProc is specifically
reserved for modal dialog boxes. (Major switching can still occur when a movable modal
dialog box is the frontmost window.)

A minor switch occurs when an application is switched out to give time to background
processes. A minor switch always involves two applications, a background application and
the application yielding time to it (which may be some other background application). In a
minor switch, the A5 worlds of those two applications are switched, as are the low-memory
environments. However, the layers of windows are not switched, and neither application
receives either suspend or resume events.
Note: Your application can also get switched out if it calls a Toolbox routine that
makes an event call. For example, your application may get switched out when calling
ModalDialog.

Specifying

Memory

Requirements

and

Scheduling

Options

Every application executing under system software version 7.0, as well as every application
executing under MultiFinder, should contain a 'SIZE' resource. One of the principal functions of the 'SIZE' resource is to inform the Operating System about the memory size
requirements for the application (hence the name 'SIZE') so that the Operating System can
set up an appropriately sized partition for the application. The 'SIZE' resource is also used
to indicate certain scheduling options to the Operating System, such as whether the application can run in the background, whether it can accept suspend and resume events, and so
forth. The 'SIZE’ resource in system software version 7.0 contains additional information
indicating whether the application is 32-bit clean, whether the application wishes to receive
notification of the termination of any applications it has launched, and whether the application
wishes to receive high-level events.
This section explains the structure of a 'SIZE' resource and the meaning of each of its fields.
It also shows how to specify the Rez input for a 'SIZE' resource. You are responsible for
creating the information in this resource.

Event Processing

5-13

2 |

es
<

oO
=|

pat

a
—
SS
=
$9

ve

i

Ler

|

Inside Macintosh,

The

Structure

Volume VI

of a 'SIZE'

Resource

A 'SIZE' resource consists of a 16-bit flags field, followed by two 32-bit size fields. The
flags field specifies operating characteristics of the application, and the size fields indicate the
minimum and preferred partition sizes for the application. The minimum partition size
is the actual limit below which your application will not run. The preferred partition size
is the memory size at which your application can run most effectively and which the Operating
System attempts to secure upon launch of the application. If that amount of memory is
unavailable, the application is placed into the largest contiguous block available, provided that
it is larger than the specified minimum size.
Note:

If the amount of available memory is between the minimum and the preferred

sizes, the Finder™ displays a dialog box asking if the user wants to run the application using the amount of memory available. If your application does not have a
‘SIZE' resource, it is assigned a default partition size of 512 KB.

When you define a 'SIZE' resource, you should give it a resource ID of —1. A user can
modify the preferred size in the Finder’s information window for your application. If the user
does alter the partition size, the Operating System creates a new 'SIZE' resource having
resource ID 0. At application launch time, the Launch function looks for a 'SIZE' resource

with ID 0; if this resource is not found, it uses your original 'SIZE' resource with ID -1.
This new 'SIZE' resource is also created when the user modifies any of the other settings in
the resource.

Listing 5-3 shows the structure of the 'SIZE' resource.
Listing 5-3. A template for a 'SIZE' resource
Cype

"SIZE"

{

boolean

reserved;

/*reserved* /

boolean

ignoreSuspendResumeEvents,

boolean

acceptSuspendResumeEvents;
reserved;

/*ignores

boolean

cannotBackground,

events*/
events*/

/*does

no

background

processing* /

boolean

canBackground;

needsActivateOnFGSwitch,
doesActivateOnFGSwitch;

/*can use background
null
/*needs
activate
event*/

boolean

backgroundAndForeground,

boolean

onlyBackground;
dontGetFrontClicks,

/*aop

getFrontClicks;

/*needs

activate
a

/*app

has

no

/*no

mouse

/*get

ignoreAppDiedEvents,

boolean

acceptAppDiedEvents;
not32BitCompatible,

/*aopp

boolean

is32BitCompatible;
notHighLevelEventAware,

boolean

isHighLevelEventAware;
onlyLocalHLEvents,

/*works
/*can't

Event Processing

no
has

boolean

localAndRemoteHLEvents;

5-14

suspend-resume

/*accepts
suspend-resume
/*reserved* /

user
user

use

launchers

with

interface*/
on

events

/*applications
/*works

event*/

interface*/

events

mouse

events*/

use

24-bit

resume*/

on

resume*/

this*/
this*/

addr*/

with
24- or 32-bit
addr*/
use high-level
events*/

/*can use high-level
events*/
/*only
local
high-level
events*/
/*also

remote

high-level

events*/

The Event Manager

boolean

notStationeryAware,

/*can't

boolean

isStationeryAware;
dontUseTextEditServices,

/*can use stationery documents* /
/*can't use inline services*/

use

useTextEditServices;
reserved;

/*can

boolean

use

stationery

inline

documents*/

services*/

/*reserved* /

boolean

reserved;

/*reserved*/

boolean

reserved;

unsigned

longint;

/*reserved* /
/*memory
sizes

unsigned

longint;

are

in

bytes*/

/*preferred
memory
size*/
/*minimum memory
size*/

he

The nonreserved bits in the flags field have the following meanings.
Flag

descriptions

acceptSuspendResumeEvents

When set, indicates that your application can process suspend
and resume events (which the Operating System sends to
your application before sending it into the back-ground or
when bringing it into the foreground). In this way, your
application knows when to process the global scrap.

canBackground

When set, indicates that your application wants to receive
null event processing time while in the background. If your
application has nothing to do in the background, you
should not set this flag.

doesActivateOnFGS
witch

When set, indicates that your application takes responsibility
for activating and deactivating any windows in response to a
suspend or resume event. If the acceptSuspendResumeEvents

flag is set, if the doesActivateOnFGSwitch flag is not set,

and if the application is suspended, then the application
receives an activate event. However, if you set the
doesActivateOnFGSwitch flag, then your application won’t
receive activate events, and you must take care of activation
and deactivation when it receives the corresponding suspend
or resume event. This means that if the application’s window
is frontmost, the suspend event should be treated as though a
deactivate event were received as well (assuming that both the
doesActivateOnFGS
witch and acceptSuspendResumeEvents
flags are set). For example, scroll bars should be deactivated,
blinking insertion points should be hidden, and selected text
should be deselected if your application moves to the background. If you do not set this flag, then a window must be
created to force the activate and deactivate events to occur.
onlyBackground

When set, indicates that your application runs only in the
background. Usually this is because it does not have a user
interface and cannot run in the foreground.

Event Processing

5-15

Inside Macintosh,

Volume VI

getFrontClicks

When set, indicates that your application is to receive the
mouse-down and mouse-up events that are used to bring
your application into the foreground when the user clicks in
your application’s frontmost window. Typically, the user
simply wants to bring your application into the foreground,
so it is usually not desirable to receive the mouse events
(which would probably move the insertion point or start
drawing immediately, depending on the application). The
Finder is one application, however, that has the
getFrontClicks flag set.

acceptAppDiedEvents

When set, indicates that your application is to be notified
that an application launched by this application has terminated or crashed. See the Process Management chapter in
this volume for more information about launching applications and receiving Application Died events.

is32BitCompatible

When set, indicates that your application can be run with
the 32-bit Memory Manager. You should not set this flag
unless you have thoroughly tested your application on a
32-bit system (such as a Macintosh IIci running system
software version 7.0 in 32-bit mode, or under A/UX®).

isHighLevelEventA ware

When set, indicates that your application can send and
receive high-level events. If this flag is not set, the Event
Manager does not give your application high-level events
when you call WaitNextEvent. There is no way to mask out
types of high-level events; if this flag is set, you will receive
all types of high-level events sent to your application.

localAndRemoteHLEvents

When set, indicates that your application is to be visible to
applications running on other computers on a network (in
addition to applications running on the local machine). If
this flag is not set, your application does not receive highlevel events across a network.

isStationery Aware

When set, indicates that your application can recognize
stationery documents. If this flag is not set and the user
opens a stationery document, the Finder duplicates the
document and prompts the user for a name for the
duplicate document.

useTextEditServices

When set, indicates that your application can use the inline
text services provided by TextEdit. See the TextEdit chapter
in this volume for information about the inline input
capabilities of TextEdit.

Note: If you set the acceptSuspendResumeEvents flag, you should also set the
doesActivateOnFGSwitch flag.
The modifiers field in the event record now contains additional information about a mousedown event. In system software version 7.0, the activeFlag modifier flag in the modifiers
field of a mouse-down event record is set to indicate that the mouse-down event caused a
foreground switch. Your application can use this flag to determine whether to process the
5-16

Event Processing

The Event Manager

mouse-down event (probably depending on whether the clicked item was visible before the
foreground switch). This modifier is set for all mouse-down events that cause a foreground
switch, regardless of whether your application’s getFrontClicks flag is set or whether the
mouse click was in your application’s front window. In system software versions prior to
7.0, this flag is never set for mouse-down events, and your application cannot tell if the
mouse click caused a foreground switch. As a result, your application should always process
a mouse-down event if its getFrontClicks flag is set.
Listing 5-4 shows the input for a sample 'SIZE' resource.
Listing 5-4. The Rez input for a sample 'SIZE' resource
resource

'SIZE'

(-1)

{

reserved,

/*reserved* /

accept SuspendResumeEvents,

/*accepts

reserved,

/*reserved*/

suspend-resume

events*/

canBackground,

/*can

doesActivateOnFGSwitch,

/*needs

backgroundAndForeground,
dontGetFrontClicks,
ignoreAppDiedEvents,

/*app has a user
interface*/
/*no mouse events
on resume*/
/*applications
use this*

use
no

background

null

activate

event*/

with

is32BitCompatible,

/*works

isHighLevelEventAware,
localAndRemoteHLEvents,

/*can use high-level
events*/
/*also
remote high-level
events*/

isStationeryAware,
dontUseTextEditServices,

/*can use stationery
documents* /
/*can't
use
inline
input
services*/

reserved,

/*reserved* /

reserved,

/*reserved* /

reserved,

/*reserved* /

kPrefSize
kMinSize

*
*

1024,
1024

/*preferred
/*minimum

24-

memory
memory

or

32-bit

events*/

addr*/

size*/
size*/

}}

This resource specification indicates, among other things, that the application is 32-bit clean,
can handle stationery documents, and accepts both local and network high-level events. You
are responsible for defining the constants kPrefSize and kMinSize; for example, if you set
kPrefSize to 50, the preferred partition size will be 50 KB.

Creating

a 'SIZE'

un

Resource

Ss)

When creating a 'SIZE' resource, you first need to determine the various operating characteristics of your application. For example, if your application has nothing useful to do when
it is in the background, then you should not set the canBackground flag. Similarly, if you
have not tested your application in an environment that uses all 32 bits of a handle or pointer
for memory addresses, then you should not set the is32BitCompatible flag.
Next, you need to determine what your application’s memory requirements are likely to be.
There is no simple formula for determining the appropriate partition size requirements for all
applications because so many factors affect memory requirements. An application’s memory
requirements depend on the static heap size, the dynamic heap, the A5 world, and the stack.
The static heap size includes objects that are always present during the execution of the
application—for example, code segments, Toolbox data structures for window records, and
Event Processing

5-17

<
<)
=}
=

=<

se
X)

—)
i)
ge
©
“

Inside Macintosh,

Volume

VI

so on. Dynamic heap requirements come from various objects created on a per-document basis
(which may vary in size proportionally with the document itself) and objects that are required
for specific commands or functions. The size of the AS world depends on the amount of global
data and the number of intersegment jumps the application contains. Finally, the stack contains
variables, return addresses, and temporary information. The application stack size varies
among computers, so you should base your values for the stack size according to the stack size
required on a Macintosh Plus (8 KB). The Process Manager automatically adjusts your

requested amount of memory to compensate for the different stack sizes on different machines.
For example, if you request 512 KB, more stack space (approximately 16 KB) will be
allocated on machines with larger default stack sizes.
Unfortunately, it is simply impossible to forecast all of these conditions with any great degree
of reliability. You should be able to determine reasonably accurate estimates for the stack
size, static heap size, A5 world, and jump table. In addition, you can use tools such as
MacsBug’s heap-exploring commands to help you empirically determine your application’s
dynamic memory requirements.

USING

THE

EVENT

MANAGER

You can use the Toolbox Event Manager to receive information about hardware-related
events, about changes in the appearance of your application’s windows, or about changes
in the operating status of your application. You can also use the Event Manager to communicate directly with other applications. This communication can include sending events to other
applications, receiving events from other applications, and searching for specific events from
other applications.
The events that your application can send to and receive from other applications are called
high-level events. Your application can both send and receive high-level events, but it
generally only receives low-level events and should not send them. Your application receives
both low-level and high-level events in the same way, which is by asking the Event Manager
for the next available event. If the event your application receives is a high-level event, your
application might need to use another Event Manager routine to retrieve an optional data
buffer accompanying that event.

Receiving

Low-Level

Events

Applications receive events one at a time by asking the Event Manager for the next available
event. You use Event Manager routines to receive (or in the case of EventAvail, simply to
look at) the next available event that is pending for your application. The Event Manager
returns to your application an event record, which includes the relevant information about
that event.
Your application can use the WaitNextEvent, GetNextEvent, and EventAvail functions to
retrieve events from the Event Manager. GetNextEvent returns the next available event of
a specified type. Further, if the event returned is in the event queue, GetNextEvent removes
it from the queue. EventAvail is just like GetNextEvent, except that if the event reported
is in the event queue, it is left there. EventAvail thus allows your application to look at the
next event in the event queue without actually processing the event.
5-18

Using the Event Manager

The Event Manager

You should use the WaitNextEvent function to retrieve an event from the Event Manager.
WaitNextEvent requires four parameters: an event mask, an event record, a sleep value,
and a mouse region. If WaitNextEvent returns successfully, the event record contains
information about the retrieved event. The sleep parameter specifies the amount of time (in
ticks) that your application agrees to relinquish the processor if no events are pending for
it. When that time expires or when an event becomes available for your application, the
Process Manager schedules your application for execution. In general, you should specify
a value greater than 0 in the sleep parameter so that other applications can receive processing
time if they need it. Your application should not sleep more than 15 ticks if you use TextEdit
because the fastest cursor blink occurs every 15 ticks.
The mouseRgn parameter to WaitNextEvent specifies a screen region that lets you determine
the conditions when your application is to receive notice of mouse-moved events. Your
application receives mouse-moved events only when the mouse is outside of the specified
region and your application is the foreground process. You can use the mouseRgn parameter
as a convenient way to change the shape of the cursor—for example, when the mouse moves
from the content area of a window to the scroll bar.
Note: If your application calls WaitNextEvent, it should not call the SystemTask
procedure.
For low-level events, the event record filled in by WaitNextEvent has the following structure:
TYPE

EventRecord

=

RECORD

what:

Integer;

{event

code}

message:

Longint;

{event

message}

when:

LongInt;

{ticks

since

where:

Point;

{mouse

location}

modifiers:

Integer

{modifier

startup}

flags}

END;

For high-level events, however, several of the fields of the event record have different
meanings. See “Receiving High-Level Events” later in this chapter.

Responding

to Operating-System

Events

mn

Se

Operating-system events are of type osEvt and are assigned the event code previously
assigned to app4Evts (type 4 application events).

<
@
=}

—s

Ka
—
to

CONST

osEvt

=

=

15;

—

ga

oO

|

If your application does not handle suspend and resume events (as indicated by a flag in its
'SIZE' resource), then the Operating System has to trick your application into performing
scrap coercion to ensure that the contents of the Clipboard can be transferred from one
application to another. This process adds to the time it takes to move the foreground
application to the background and vice versa and thereby makes the user interface look
cumbersome.

Using the Event Manager

5-19

Inside Macintosh,

Volume

VI

Your application should respond to a suspend event by moving its private scrap into the —
Clipboard and then returning to the main event loop. Also, your application can do anything
else necessary to get ready for a major switch. When your application receives a resume event
and if the Clipboard has been altered, your application should copy the contents of the
Clipboard, convert them back to its private scrap, and do anything else required for a foreground switch. After processing the scrap in this way, your application resumes executing.
Note: When switched into the background, an application should hide its
Clipboard window. The contents of the Clipboard are not valid unless the
application is frontmost.
In an osEvt event record, the message field contains information indicating whether the event
is a Mouse-moved, suspend, or resume event and whether Clipboard conversion is required
when the application resumes execution. The message field has the following structure:
Bit

Meaning

0)

0 if a suspend event

l

0 if Clipboard conversion not required
1 if Clipboard conversion required

2-23

Reserved

24-31

suspendResumeMessage if a suspend or resume event
mouseMovedMessage if a mouse-moved event

1 if a resume event

CONST

suspendResumeMessage
mouseMovedMessage

=

$01;

{suspend

or

resume

I

Note that you need to examine the low byte of the message field to determine what kind of
operating-system event you have received. The messages passed in bits 24—31 are defined
by constants:

SFA;

{mouse-moved

event}

event}

If the event is a suspend or resume event, you need to examine the first bit of the high byte to
figure out whether that event is a suspend or resume event. Bits 0 and | are meaningful only
if bits 24-31 indicate that the event is a suspend or resume event. You can use the constants
resumeFlag and convertClipboardFlag to determine whether the event is a resume event, and
whether Clipboard conversion is required:
CONST

resumeFlag
convertClipboardFlag

5-20

Using the Event Manager

=

ie;

{resume

event}

2;

{Clipboard

conversion

required}

The Event Manager

Receiving

High-Level

Events

In system software version 7.0, your application can receive a high-level event when it
retrieves an event from the Event Manager. As always, your application determines what kind
of event it has received by looking at the what field of the event record returned by the Event
Manager. The event code for high-level events is defined by a constant name.
CONST

kHighLevelEvent

=

232

For high-level events, two fields of the event record have special meanings. The message
field and the where field of the event record together define the specific type of high-level
event and are interpreted as type OSType, not LongInt or Point. The message field contains
the event class of this high-level event. For example, Apple events sent by the Edition
Manager have the event class 'sect'. You can define your own class of events that are specific
to your application. If you have registered your application signature, then you can use your
signature to define the class of events that belong to your application. Note, however, that
Apple reserves all lowercase letters and nonalphabetic characters for the classes of events
defined by Apple.
For high-level events, the where field in the event record contains a second message
specifier, called the event ID. The event ID defines the particular type of event (or message)
within the class of events defined by the event class. For example, the Section Read Apple
event sent by the Edition Manager has event class 'sect' and event ID 'read'. The Open
Documents Apple event sent by the Finder has event class 'aevt' and event ID 'odoc'. You
can define your own set of event IDs, corresponding to your own event class. For example,
if the message field contains 'biff' and the where field contains 'cmd1', then the high-level
event indicates the type of event defined by 'cmd1' within the class of events defined by the
application with the signature 'biff.
Unlike low-level events and operating-system events, high-level events may not be completely
determined by the event record returned to your application when it calls WaitNextEvent. For
example, you might still need to know which other application sent you the high-level event
or what additional data that application wants to send you. This further information about the
high-level event is available to your application by calling the AcceptHighLevelEvent function.
The additional information associated with a high-level event includes
m the identity of the sender of the event

7)

m aunique number that identifies this particular event

<
@

bree!
\~u

—

a

os

<

m the address and length of a data buffer that can contain optional data

_—
io)
—

~

ee)
j=)

To obtain this additional information, your application must call AcceptHighLevelEvent
before calling WaitNextEvent again. By convention, calling AcceptHighLevelEvent
indicates that your application intends to process the high-level event.

@
ex |

Note: Because the where field of an event record for a high-level event is used to
select a specific kind of event (within the class determined by the message field),
high-level event records do not contain the mouse position at the time of the event.
Moreover, it is dangerous to interpret the where field before interpreting the what
field because different event classes can contain overlapping sets of event IDs.
Using the Event Manager

5-21

Inside Macintosh, Volume VI

The section “Responding to Events From Other Applications” later in this chapter describes
how to use the AcceptHighLevelEvent function.

Identifying

High-Level

Event

Senders

and

Receivers

When you receive a high-level event, part of the information returned by AcceptHighLevelEvent
is the sender of the event. You can use that information to respond selectively to requests made
by other applications or to know which application to send any replies to. The information about
the sender is provided in the form of a target ID record, defined as follows:
TYPE

TargetID

=

RECORD
sessionID:

LongIint;

{session

reference

name:

PPCPortRec;

{sender's

port

name}

number}

location:

LocationNameRec;

{sender's

port

location}

recvrName:

PPCPortRec

{reserved}

END;

The sessionID field corresponds to the session reference number created by the PPC
Toolbox. This is a 32-bit number that uniquely identifies

a PPC Toolbox session (or

conneciion) with another application. The name and location fields contain the sender’s
port name and port location (and have no meaning when posting an event). If the
sending application is on the same machine as the receiving application, you can
determine the sending application’s process serial number by calling the
GetProcessSerialNumberFromPortName function.
When you post a high-level event, you can specify its recipient in one of four ways:
= by port name and port location (specified in a target ID record)
m by asession ID
by the application’s creator signature
m by aprocess serial number
Note that to specify the recipient of a high-level event sent to an application across a network,
you can use only its target ID or its session ID. You can use any of the four ways when

sending high-level events to applications on the local machine.

When you are replying to a high-level event, it is easy to identify the recipient because you
can use the target ID record that you receive from AcceptHighLevelEvent, the session ID
contained in that target ID record, or the process serial number (if the receiving process
is local). Note that replying by session ID is always the fastest way to respond to a highlevel event.
When you are not replying to a previous event, you need to determine the identity of the
target application yourself. You can use one of several methods to do this. If the target
application is on the local machine, you can search for that application’s creator signature
or its process serial number by calling the GetProcessInformation function. See “Getting
Information About Other Processes” in the Process Management chapter of this volume

5-22

Using the Event Manager

The Event Manager

for a detailed explanation of GetProcessInformation and for examples of using it to generate
a list of process serial numbers of all open processes on the local machine.
If the application to which you want to send a high-level event is located on a remote machine,
you need to identify it either by its session ID or by its target ID. You can call the PPCBrowser
function to let the user browse for a specific port. You can call the IPCListPorts function to
obtain a list of all ports registered with the target PPC Toolbox. See the Program-to-Program
Communications Toolbox chapter in this volume for an explanation of both of these functions.

Sending

High-Level

Events

You use the PostHighLevelEvent routine to send a high-level event to another application.
When doing so, you need to provide six pieces of information:
m an event record with the event class and event ID assigned appropriately
m the identity of the recipient of the event
m aunique number that identifies this particular event
m a data buffer that can contain optional data
m the length of the data buffer
w options determining how the event is posted
Note: To send an Apple event, use the Apple Event Manager function AESend. The
Apple Event Manager uses the Event Manager to post Apple events. For information
on posting Apple events, see the Apple Event Manager chapter in this volume.
As indicated in the previous section, you can identify the recipient of the high-level event in
one of four ways. Listing 5-5 illustrates how to send a high-level event to an application on
the local machine. In this example, an application is sending an event to an application whose
signature is 'boff’.
Listing 5-5. Posting a high-level event by application signature
PROCEDURE

PostTest;

ul

VAR

myEvent:
myRecvID:
myOpts:

EventRecord;
OSType;
LongInt ;

myErr:

OSErr;

les
ei

{an event
record}
{receiver
ID}
{posting options}

<

oO

=

-

<
oo

~
=
ee)
ve

BEGIN

@
od

myEvent.what
:= kHighLevelEvent;
myEvent.message
:= LongInt('boff');
myEvent.where
:= Point (LongInt('cmdl'));
myOpts
:= receiverIDisSignature
+ nReturnReceipt;
myRecvID
myErr
:=

:=
'boff';
PostHighLevelEvent

IF

<>

myErr

DoError

noErr

(myErr)

(myEvent,

@myRecvID,

0,

NIL,

0,

myOpts);

THEN

;

END;

Using the Event Manager

5-23

Inside Macintosh, Volume VI

In this example, there is no additional data to transmit, so the sending application provides NIL
as the pointer to the data buffer and sets the buffer length to 0. Note that the receiver is specified by its creator signature and that the sender requests a return receipt. The myOpts parameter
specifies posting options, which are of two types: delivery options and options associated with
the receiverID parameter. You can specify one or more delivery options to indicate if you want
the other application to receive the event at the next opportunity and to indicate if you want
acknowledgment that the other application received the event. You use the options associated
with the receiverID parameter to indicate how you are specifying the recipient of the event. To
set the various posting options, use constants.
CONST

nAttnMsg

=

$00000001;

{give

priorityMask
nReturnReceipt

=
=

SOOOOOOFF;
§00000200;

{return

systemOpt

=

SOOO000FOO0;

receiverIDisTargetID
receiverIDisSessionID
receiverIDisSignature
receiverIDisPSN

=
=
=

§00005000;
$00006000;
$00007000;
$00008000;

receiverlIDMask

=

$SOOO00F0O00;

ionsMask

{ID
{ID
{ID
{ID

this

is
is
is
is

message

receipt

priority}

requested}

target ID}
PPC session ID}
creator signature}
process serial num}

When you specify the receiving application in the receiverID parameter, you can use these
constants to specify the receiver of the event by session ID, process serial number, signature,
or target ID. Any of these specifications allows you to send an event to another application on
the local machine. To send events to an application on a remote machine, you can specify the
recipient only by the session ID or target ID.
When you specify the receiver of the event by target ID, use the constant receiverI[DisTargetID
in the postingOptions parameter and specify a pointer to a target ID record for the receiverID
parameter.
TYPE

TargetID

=

RECORD

sessionID:
name:

LongInt;
PPCPortRec;

location:

LocationNameRec;

recvrName:

PPCPortRec

{unused

for

posting}

END;

When you pass a target ID record, you need to specify only the name and location fields. You
can use the IPCListPorts function to list all of the existing port names along with information
on whether the port will accept authenticated service on the machine specified by the port
location name. For information on how to use the IPCListPorts function, see the PPC
Toolbox chapter in this volume.
You can also use the PPCBrowser function to fill in a target ID record. Listing 5-6 illustrates
how to use the PPCBrowser function to post a high-level event. In this example, the sending
application wants to locate a dictionary application and have the dictionary return the
definition of a word to it.

5-24

Using the Event Manager

The Event Manager

Listing 5-6. Using the PPCBrowser function to post a high-level event
FUNCTION

PostWithPPCBrowser

(aTextPtr:

Ptr;

VAR
myHLEvent:

EventRecord;

myErr:

OSErr;

myNumTries:

Integer;

myPortInfo:

PortInfoRec;

myTarget:
BEGIN
{use

:=

to

get

the

PPCBrowser('Select

{copy

=

NoErr

portname

into
:=

OSErr;

an

Application',

‘Application',

myPortInfo,

myHLEvent.what

FALSE,

'');

myTarget.name}

:=

kHighLevelEvent;
:=

LongInt('Dict');

myHLEvent.where

:=

Point(LongInt('Defn'));

{if

is

broken,

connection

PostHighLevelEvent;
the event
one more

myNumTries

NIL,

myPortInfo.name;

myHLEvent.message

a

:

THEN

myTarget.name

{
{

)

target}

myTarget.location,
IF myErr
BEGIN

LongInt

TargetID;

PPCBrowser

myErr

textlength:

:=

then

sessClosedErr

to reestablish
time}

is

returned

the

connection,

(myHLEvent,

@myTarget,

just

to

}

post

}

0;

REPEAT

myErr

:=

PostHighLevelEvent

textlength,

myNumTries
UNTIL

(myErr

:=
<>

myNumTries

+

sessClosedErr)

0,

aTextPtr,

receiverIDisTargetID) ;

1;
OR

(myNumTries

>

1);

END;

PostWithPPCBrowser

:=

myErr;

{return

any

error}

END;

This example puts up a dialog box asking the user to select a dictionary. When one is selected,
this code posts a high-level event to that dictionary application asking for the definition of the
selected text. Note that the sending application and the receiving application must both agree
that definition queries are to be of event class 'Dict' and event ID 'Defn’. It is necessary to
define a private protocol only in cases where no suitable Apple event exists.

wi

ic
<

i‘
|

“>

2

Note: You should avoid passing handles to the receiving application in an attempt to
share a block of data. It is better to put the relevant data into a buffer (as illustrated in
Listing 5-6) and pass the address of the buffer. If you absolutely must share data by
passing a handle, make sure that the block of data is located in the system heap.

—

pa)

~

se)

ttj=)
oO

If a high-level event is posted successfully, PostHighLevelEvent returns the result code
noErr, which indicates only that the event was successfully passed to the PPC Toolbox.
Your application needs to call another Event Manager routine (EventAvail, GetNextEvent,
or WaitNextEvent) to give the other application an opportunity to receive the event.

Using the Event Manager

5-25

Inside Macintosh, Volume VI

The event you send may require the other application to return some information to your
application by sending a high-level event back to your application. You can scan for the
response by using GetSpecificHighLevelEvent. If your application must wait for this event,
you might want to display a watch cursor or take other action as appropriate to your application. You also might want to implement a timeout mechanism in case your application never
receives a response to the event.

Requesting

Return

Receipts

When you post a high-level event, you can request a return receipt by including the constant
nReturnReceipt as one of the posting options. This requests that the Event Manager send
your application a high-level event that tells you whether the other application accepted your
event. Note that this does not necessarily mean that the other application performed any action
you might have requested from it.
A return receipt is a high-level event having an event class and an event ID indicated by the

two constants:
CONST

HighLevelEventMsgClass

=

rtrnReceiptMsgID

'jaym';
'rtrn":

Return receipts are posted by the Event Manager on the machine of the receiving application
(and not by the receiving application itself). No data buffer is associated with a return receipt.
However, the posting Event Manager sets the modifiers field of the high-level event record to
one of the following values:
CONST

msgWasNotAccepted

=

msgWasFullyAccepted

=

Q;
Li

msgWwasPartiallyAccepted

=

ee

The constant msgWasNotAccepted indicates that your event was not accepted by the
receiving application. This means that the receiving application was notified of the arrival
of your event (through WaitNextEvent) but did not call AcceptHighLevelEvent to accept
the event. The constant msgWasFullyAccepted indicates that the receiving application
did call AcceptHighLevelEvent and retrieved all the data in the optional data buffer.
The constant msg WasPartially Accepted indicates that the receiving application called
AcceptHighLevelEvent, but that the application’s data buffer was too small to hold the
data sent with your application and that the receiving application called WaitNextEvent
before retrieving the rest of the buffer.
Note that a return receipt does not indicate the identity of the receiving application. To determine on whose behalf the Event Manager has sent you a particular return receipt, you need to
call AcceptHighLevelEvent. When AcceptHighLevelEvent returns successfully, the sender
parameter contains a target ID record with the fields filled in for the receiving application.
With return receipts, the msgLen parameter is 0, the msgBuff parameter is NIL, and the
msgRefCon field contains the unique number of the refCon parameter of the original highlevel event sender (that is, your application).
5-26

Using the Event Manager

The Event Manager

Responding

to Events

From

Other Applications

You can identify high-level events by the value in the what field of the event record. The
message and where fields further classify the type of high-level event. Your application can
choose to recognize as many events as are appropriate. Some high-level events may be fully
specified by their event record only, while others may include additional information in an
optional buffer. To get that additional information or to find the sender of the event, use the
AcceptHighLevelEvent function.
Note: To respond to an Apple event, use the Apple Event Manager, as described in
the Apple Event Manager chapter in this volume.
Listing 5-7 illustrates how to call AcceptHighLevelEvent. In general, you cannot know in
advance how big the optional data buffer is, so you can allocate a zero-length buffer and then
resize it if the call to AcceptHighLevelEvent returns the error bufferlsSmall.
Listing 5-7. Accepting a high-level event
VAR

myTarg:

TargetID;

myRefCon:

Longint;

myBuff:

Ptr;

myLen:
myErr:

Longint;
OSErry

{target

ID

{start

with

record}

BEGIN

myLen

:=

myBuff
myErr
IF

0;
:=

:=

myErr

a

0-byte

buffer}

NIL;
AcceptHighLevelEvent
=

bufferIsSmall

(myTarg,

myRefCon,

myBuff,

myLen);

THEN

BEGIN

myBuff
myErr

:=

:=

NewPtr(myLen) ;
{get new pointer}
AcceptHighLevelEvent (myTarg,
myRefCon,

myErr

<>

noErr

myBuff,

myLen);

END;

IF

THEN

DoError

(myErr)

;

wm

END;

Sontial
\~u

The ID of the sender of the event is returned in the first parameter, which is a target ID record.
You can inspect the fields of that record to determine which application sent the event. That
record also contains the session reference number that identifies this communication as well
as the port name and port location of the sender. If the high-level event requires that you
return information, you can use the value returned in the sender parameter to send an event
back to the requesting application.
The buffer parameter points to any additional data associated with the event. Any data in the
additional buffer is defined by the particular high-level event. On input, the length parameter
contains the size of the buffer. If no error occurs, on output the length parameter contains the

Using the Event Manager

5-27

<
)
=}
—

<Lael
S

=}
SY)

ge
fo)
ler

Inside Macintosh,

Volume VI

size of the message accepted. If the error bufferlsSmall occurs, the length parameter contains
the size of the message yet to be received. The reference constant parameter is a unique
number your application can use to identify communication associated with this event.

Searching

for a Specific

High-Level

Event

Sometimes you do not want to accept the next available high-level event pending for your
application. Instead, you might want to select one such event from among all the high-level
events in your application’s high-level event queue. For example, you might want to look
for a return receipt for a high-level event you previously posted before processing other highlevel events.
You can select a specific high-level event by calling the GetSpecificHighLevelEvent function.
One of the parameters you pass to this function is a filter function that you provide. Your filter
function should examine an event in your application’s high-level event queue and determine
if that message is the kind of event you wish to receive. If it is, your filter function returns
TRUE. This indicates that your filter function does not want to inspect any more events. If
the filter function finds an event of the desired type, it should call AcceptHighLevelEvent to
retrieve it. When your function returns TRUE, the GetSpecificHighLevelEvent function itself
returns TRUE.
If your filter function returns FALSE for an event in the high-level event queue,
then GetSpecificHighLevelEvent looks at the next event in the high-level event queue
and executes your filter function. If the filter function returns FALSE for all the high-level
events in the queue, then GetSpecificHighLevelEvent itself returns FALSE to your
application.
Here’s how you declare the filter function whose address you pass to
GetSpecificHighLevelEvent:
FUNCTION

aFilter

(yourDataPtr:
sender:

Ptr;

TargetID)

msgBuff:
:

HighLevelEventMsgPtr;

Boolean;

The yourDataPtr parameter indicates the criteria your function should use to search for a
specific event. The msgBuff parameter contains a pointer to a high-level event message
record that has this structure:
TYPE

HighLevelEventMsg

=

RECORD
HighLevelEventMsgHeaderLength:
version:

Integer;
Integer;

reservedl:
theMsgEvent:
userRefCon:
postingOptions:

LongInt;
EventRecord;
LongInt;
LongInt;

msgLength:

Longint

END;

5-28

Using the Event Manager

The Event Manager

When you call GetSpecificHighLevelEvent and it executes your filter function for a high-level
event waiting in the high-level event queue, the fields of HighLevelEventMsg are filled in by
the Event Manager. You can then compare the fields of this record to the information you
pass in the yourDataPtr parameter to determine if that event suits your needs. For example,
the yourDataPtr parameter might contain the signature of a return receipt. You can test its
value against the event class contained in the theMsgEvent field of the high-level event
message record.

EVENT

MANAGER

ROUTINES

In system software version 7.0, the Event Manager includes routines for receiving events,
sending high-level events, receiving high-level events, and searching for specific highlevel events.

Receiving

Events

You can use the WaitNextEvent function to receive events one at a time from the Event

Manager.

FUNCTION

WaitNextEvent

(eventMask:
sleep:

Integer;

LongInt;

VAR

theEvent:

mouseRgn:

EventRecord;

RgnHandle)

:

Boolean;

The WaitNextEvent function returns in the theEvent parameter the next available event of a
specified type or types and, if the event is in the event queue, removes it from the queue. If no
events are pending for your application, WaitNextEvent waits for a specified amount of time
for an event. (During this time, processing time may be allocated to background processes.) If
an event occurs, it is returned as the value of the parameter theEvent. If no event occurs (and
the queue is empty), WaitNextEvent returns a null event in theEvent. WaitNextEvent returns
FALSE if the event being returned is a null event; otherwise, WaitNextEvent returns TRUE.
The eventMask parameter specifies which kinds of events are to be returned; this parameter is
interpreted as a sum of event mask constants (listed earlier in “Event Masks”). If no event of

any of the designated types is available, WaitNextEvent returns a null event.

The sleep parameter specifies the number of ticks (sixtieths of a second) that your application
agrees to relinquish the processor if no events are pending for it.
The mouseRgn parameter specifies a region inside of which mouse movement does not
cause mouse-moved events. In other words, your application receives mouse-moved events
only when the cursor is outside of the specified region. The region is specified in global
coordinates. If you pass an empty region or a NIL region handle, mouse-moved events are
not generated. Note that your application should recalculate the mouseRgn parameter when it
receives a mouse-moved event or it will continue to receive mouse-moved events as long as
the cursor position is outside the original mouseRgn.

Event Manager Routines

5-29

Inside Macintosh,

Volume

VI

Some high-level events may be fully specified by their event record only, while others may
include additional information in an optional buffer. To get any additional information and
to find the sender of the event, use the AcceptHighLevelEvent function.
AcceptHighLevelEvent

FUNCTION

VAR msgRefcon:
TargetID;
(VAR sender:
VAR msgLen:
Ptr;
msgBuff:
LongInt;
Longint)

:

OSErr;

The sender of the event is specified in the sender parameter, which is a target ID record. The
sender parameter contains the session reference number that identifies this communication
and the port name and port location of the sender.
The msgRefcon parameter is a unique number that is used to identify this event. If you send a
response to this event, you should specify the same value of msgRefcon so that the sender of
the event can associate the reply with the original request.
The msgBuff parameter points to any additional data associated with the event. The msgLen
parameter contains the size of the buffer. Your application is responsible for allocating the
memory for the additional data pointed to by the msgBuff parameter. If the msgBuff parameter
points to an area in memory that is not large enough to hold all the data associated with the
event, AcceptHighLevelEvent returns the result code bufferlsSmall. If AcceptHighLevelEvent
returns the result code bufferIsSmall, the msgLen parameter contains the number of bytes
remaining. You can call AcceptHighLevelEvent again to receive the rest of the data.
Result codes

noErr
bufferIsSmall
noOutstandingHLE

Sending

0
—607
-608

No error
Buffer is too small
No outstanding high-level event

Events

You can use the PostHighLevelEvent routine to send a high-level event to another application.
FUNCTION

PostHighLevelEvent

(theEvent:

EventRecord;

Longint};

msgRefcon:

msgLen:

LongInt;

receiverID:
LongInt;

Ptr

msgBuff:

postingOptions:

{UNIV
Ptr;

LongInt)

OSErrY;

You specify the event to send in the parameter theEvent and include any additional data for
the event by providing a pointer to a data buffer in the msgBuff parameter. The msgLen
parameter specifies the size of the data buffer. The receiverID parameter specifies the recipient
of the event. The msgRefcon parameter specifies a unique number associated with this event.
Your application can set this field to any value it chooses.
You can specify the receiver of the event by session ID, process serial number, signature, or
port name and port location. You can use any of these specifications to send an event to
another application on the local machine. You can use only the session ID or port name and
port location to send an event to an application on a remote machine.

5-30

Event Manager Routines

The Event Manager

You use the postingOptions parameter to specify delivery options and options associated with
the receiverID parameter. You can specify one or more delivery options to indicate whether
you want the other application to receive the event at the next opportunity and to indicate
whether you want acknowledgment that the event was received by the other application. You
use the options associated with the receiverID parameter to indicate how you are specifying
the recipient of the event.
If the application to which you are sending a high-level event terminates, you will receive
sessionClosedErr when you next call PostHighLevelEvent. If you do not care about any state
information about that session, you can just resend your event. Otherwise, you must restart
another session and resend your event.
If your application is running in the background and posts a high-level event that requires
the network authentication dialog box to be displayed, your application will receive a
noUserInteractionAllowed result code. This prevents a background application from
displaying a modal dialog. Instead, you can use the Notification Manager to inform the
user that your application needs attention. When the user brings your application to the
foreground, you can repost the event. If the reposting is successful, your application can
return to the background and continue to post high-level events without further user
interaction. Note that the error noUserInteractionAllowed is returned only on the first
posting of a high-level event to a remote target.
Result codes
noErr
connectionInvalid

(0)
—609

sessionClosedErr

—917

noUserlInteractionAllowed

Receiving

a Specific

—610

No error
Connection is invalid

Cannot interact directly with user
Session closed

High-Level

Event

You can use the GetSpecificHighLevelEvent function to select and optionally retrieve a
specific high-level event from the high-level event queue.
FUNCTION

GetSpecificHighLevelEvent

(aFilter:
GetSpecificFilterProcPtr;
yourDataPtr:
UNIV Ptr;
VAR err:
OSErr)

:

Boolean;

mn
ty
=
ce

==

You specify your filter function in the aFilter parameter. GetSpecificHighLevelEvent calls your
filter function once for each event in the high-level event queue until your filter function returns
TRUE or the end of the queue is reached. You use the yourDataPtr parameter to specify the
criteria your filter function should use to select a specific event. For example, you can specify
the yourDataPtr parameter as a msgRefcon value to search for a particular event or as a pointer
to a target ID record to search for a specific sender of an event. Or you can search for a specific
class of event.

Result codes
noErr

noOutstandingHLE

8)

—608

No error

No outstanding high-level event

Event Manager Routines

5-3]

—_
—_

—_

a

aan

X)=
=
7
oO

oe

Cd

=

:

Inside Macintosh, Volume VI

Here’s how you declare the filter function aFilter:
FUNCTION

aFilter

(yourDataPtr:
sender:

Ptr;

TargetID)

msgBuff:
:

HighLevelEventMsgPtr;

Boolean;

The yourDataPtr parameter indicates the criteria your filter function should use to search

for a specific event. The msgBuff parameter contains a pointer to a record of type
HighLevelEventMsg, which provides information about the event: the event record for
the high-level event, the posting options of the event, and so forth. The sender parameter
contains the target ID of the application that sent the event.
Your filter function can compare the contents of the yourDataPtr parameter with the contents
of the msgBuff or senderID parameters. If your filter function finds a match, it should return
TRUE. If your filter function does not find a match, it should return FALSE. Your filter
procedure can call AcceptHighLevelEvent, if necessary.

Converting

Process

Serial

Numbers

and

Port

Names

The Event Manager provides two utility functions to convert between process serial numbers
and port names. Both functions are intended to map serial numbers to port names (or vice
versa) for applications open on the local machine. They do not return useful results for
applications open on remote machines.
Use GetProcessSerialNumberFromPortName to get the serial number of the process
registered at a specific port.
FUNCTION

GetProcessSerialNumberFromPortName

(portName:

PPCPortRec;

VAR

PSN:
ProcessSerialNumber)
OSErr;

The portName parameter specifies the port name registered to a process whose serial number
you want. The process serial number is returned in the PSN parameter. You can use the
returned process serial number to send a high-level event to that process. Do not interpret the
value of the serial number.
Result codes
noErr

noPortErr

0

—90)3

No error

Invalid port name

Use GetPortNameFromProcessSerialNumber to get the port name registered to a process
having a specific process serial number.
FUNCTION

GetPortNameFromProcessSerialNumber

(VAR

portName:

PSN:

PPCPortRec;

ProcessSerialNumber)

OSErr;

The PSN parameter specifies the process serial number that you want to map to a port name.
The port name is returned in the portName parameter.
Result codes

noErr
procNotFound

5-32

0
—600

Event Manager Routines

No error
No eligible process with specified process serial
number

The Event Manager

SUMMARY

OF

THE

EVENT

MANAGER

Constants
CONST

{event masks}
everyEvent

=

=L;

mDownMask

=

2F

{mouse-down }

mUpMask

=

4;

{mouse-up}

keyDownMask
keyUpMask

=
=

8
264

{key-down }
{key-up}

autoKeyMask

=

32;

{auto-key}

updateMask

=

64;

{update}

diskMask
activMask

=
=

128)
2567

{disk-inserted}
{activate}

highLevelEventMask

=

1024;

{high-level}

osMask

=

-32768;

{flags
for suspend and
resumeFlag
convertClipboardFlag
{message

codes

for

resume
— a
we

{every

event}

{operating-system}

events}
{resume event}
{Clipboard conversion

operating-system

events}

suspendResumeMessage

$01;

{suspend

or

resume

mouseMovedMessage

SFA;

{mouse-moved

event}

{event

codes

for

operating-system

osEvt

=

15%

kHighLevelEvent

=

23;

{high-level

event

posting

and

high-level

events}

this

message

options}
{give

=

$00000001;

=

SOOQOOOO0FF;

nReturnReceipt

=

§$00000200;

{return

systemOptionsMask
receiverIDisTargetID
receiverIDisSessionID
receiverIDisSignature
receiverIDisPSN
receiverIDMask

=
=
=
=
=
=

$OO000FO00;
§00005000;
$00006000;
$00007000;
$00008000;
SOOO00F000;

{ID
{ID
{ID
{ID

nAttnMsg

priorityMask

{class

and

ID

values

for

return
=

'jaym';

rtrnReceiptMsgID

=

"Fern";

in

is
is
is
is

receipt

event}

priority}

requested}

target ID}
PPC session ID}
creator signature}
process serial num}

wn
e3|

| oe

<

<—
—

—_

a
—
as
=)
—
—
nn
$9
ge
o@
ar |

receipt}

HighLevelEventMsgClass

{modifiers
values
msgWwasNotAccepted

required}

return receipt}
= Oe

msgwasFullyAccepted
msgWasPartiallyAccepted

=
=

Li
2;

Summary of the Event Manager

5-33

Inside Macintosh, Volume VI

Data
TYPE

Types
TargetID

=

RECORD

sessionID:

Longint;

{session

name:

PPCPortRec;

{sender's

reference
port

name}

number}

location:

LocationNameRec;

{sender's

port

location}

recvrName:

PPCPortRec

{reserved}

END;
TargetIDPtr

HighLevelEventMsg

=

“TargetID;

=

RECORD

HighLevelEventMsgHeaderLength:

Integer;

version:

Integer;

reservedl:
theMsgEvent:

LongInt;
EventRecord;

userRefCon:

LongIint;

postingOptions:

Longint;

msgLength:

LongInt

END;

HighLevelEventMsgPtr

=

GetSpecificFilterProcPtr

“HighLevelEventMsg;
=

ProcPtr;

Routines

Receiving
FUNCTION

Events

WaitNextEvent

(eventMask:

Integer;

EventRecord;
RgnHandle)
FUNCTION

AcceptHighLevelEvent

Sending
FUNCTION

(VAR

:

sender:

VAR

sleep:

theEvent:

LongInt;

mouseRgn:

Boolean;
TargetID;

Longint;

msgBuff:

Longint)

:

Ptr;

VAR
VAR

msgRefcon:
msgLen:

OSErr;

Events
PostHighLevelEvent

(theEvent:

EventRecord;

receiverID:

{UNIV LongInt};
msgRefcon:
LongInt;
msgBuff:
Ptr;
msgLen:
LongInt;
postingOptions:
LongInt)
: OSErr;

5-34

Summary of the Event Manager

Ptr

The Event Manager

Receiving
FUNCTION

a Specific

High-Level

GetSpecificHighLevelEvent

Event

(aFilter:

GetSpecificFilterProcPtr;

yourDataPtr:
Boolean;

Converting
FUNCTION

Process

Serial Numbers

and

GetProcessSerialNumberFromPortName

UNIV

Ptr;

VAR

err:

Port Names

(portName:

PPCPortRec;

ProcessSerialNumber)
FUNCTION

GetPortNameFromProcessSerialNumber

(VAR

portName:

{filter

function

FUNCTION

aFilter

for

:

PSN:

OSErr;
PSN:

OSErr;

Routines

GetSpecificHighLevelEvent }
(yourDataPtr:

Ptr;

msgBuff:

HighLevelEventMsgPtr;
TargetID)

Result

VAR
:

PPCPortRec;

ProcessSerialNumber)

Application-Defined

OSErr)

:

sender:

Boolean;

Codes

noErr
procNotFound
bufferlsSmall

0
—600
-—607

Noerror
No eligible process with specified process serial number
Buffer is too small

connectionInvalid
noUserInteractionAllowed

—609
-610

Connection is invalid
Cannot interact directly with user

noOutstanding HLE

-—608

No outstanding high-level event

Summary of the Event Manager

5-35

THE

APPLE

EVENT

MANAGER

About This Chapter
About the Apple Event Manager
Introduction to Apple Events
Types of Apple Events
Components of Apple Events
Data Structures Within Apple Events
Responding to Apple Events
Requesting Services Through Apple Events
Using the Apple Event Manager
Accepting an Apple Event
Installing Entries Into the Apple Event Dispatch Tables
Handling the Required Apple Events
Required Apple Events
Handling the Open Application Event
Handling the Open Documents Event
Handling the Print Documents Event
Handling the Quit Application Event
Handling Apple Events Sent by the Edition Manager
Handling the Create Publisher Event
Getting Data out of an Apple Event
Getting Data out of a Parameter
Getting Data out of an Attribute
Getting Data out of a Descriptor List
Writing Apple Event Handlers
Replying to an Apple Event
Disposing of Apple Event Data Structures
Interacting With the User
Creating an Apple Event
Adding Parameters to an Apple Event
Specifying a Target Address
Sending an Apple Event
Dealing With Timeouts
Writing an Idle Function
Writing a Reply Filter Function
Writing and Installing Coercion Handlers
The Application Died Event
Apple Event Manager Routines
Creating and Managing the Apple Event Dispatch Tables
Dispatching Apple Events

Getting Parameters and Attributes From Apple Events
Counting the Items in Descriptor Lists
Getting Items From Descriptor Lists
Getting Data and Keyword-Specified Descriptor Records From AE Records
Requesting User Interaction
Requesting More Time to Respond to Apple Events
Suspending and Resuming Apple Event Handling
Creating Apple Events
Creating and Duplicating Descriptor Records
Creating Descriptor Lists and AE Records

a
>
s
Ae
@

is
<

@

=|
2
=
=
$9

—_-

—

ga

‘co
ser |

Inside Macintosh, Volume VI

89

90

91
93
96
98
99
100
101
103
105

Adding Items to Descriptor Lists

Adding Data and Keyword-Specified Descriptor Records to AE Records

Adding Parameters and Attributes to Apple Events
Sending Apple Events
Getting the Sizes and Descriptor Types of Descriptor Records
Deleting Descriptor Records
Deallocating Memory for Descriptor Records
Coercing Descriptor Types
Creating and Managing the Coercion Handler Tables
Creating and Managing the Special Handler Tables
Summary of the Apple Event Manager

The Apple Event Manager

ABOUT

THIS

CHAPTER

This chapter describes Apple® events and how your application can use the Apple Event

Manager to receive and process the required set of Apple events sent by the Finder™. This

chapter also describes how to use the Apple Event Manager to send Apple events to other
applications and how to process Apple events received from other applications.
As explained in the Event Manager chapter in this volume, the Event Manager in system
software version 7.0 introduces high-level events, along with a number of new Event
Manager routines that let applications communicate with each other by sending high-level
events. Using Event Manager routines, your application can create and process its own
high-level events.

However, effective interapplication communication requires that applications agree on a standard set of conventions—a common vocabulary. To provide such a standard, Apple Computer,
Inc., has defined a protocol called the Apple Event Interprocess Messaging Protocol
(AEIMP). High-level events that adhere to this protocol are called Apple events. You can
help ensure effective communication with other applications by using this protocol.
System software uses Apple events to communicate information to your application; you
should support the required set of Apple events sent by the Finder to your application. In
addition, you can support Apple events that are common to many applications. Using the
routines of the Apple Event Manager, you can use Apple events to communicate with other
applications in a standard way. Using Apple events to ensure better cooperation between
your application and other applications helps users to get the most out of any one application
or to use the best features from many applications—in effect, combining the features of
many applications to achieve the desired result.
By following the standards specified by AEIMP, you can also define your own Apple events.
You can choose to publish these so that other applications can use them, or you may choose
to keep them unpublished for exclusive use by your own applications.
The Apple Event Manager is available only in system software version 7.0. To determine
whether the Apple Event Manager is available, use the Gestalt function described in the
Compatibility Guidelines chapter of this volume.
The interapplication communications architecture of system software version 7.0 consists
of three main components: the Apple Event Manager, the Event Manager, and the Programto-Program Communications (PPC) Toolbox. See the Introduction to the System Software

Version 7.0 Environment chapter in this volume for an overview of the relationships among
these components. If you intend to use high-level events that do not rely on AEIMP, read
the Event Manager chapter of this volume. This chapter describes the information you need
to know to support Apple events in your application. To allow your application to send
Apple events to applications on remote computers, you may wish to use the PPCBrowser
function, which is described in the Program-to-Program Communications Toolbox chapter
of this volume.

an

While the Apple events used by the Edition Manager are discussed in this chapter, you must
refer to the Edition Manager chapter of this volume for a full discussion of how to implement
the Edition Manager’s publish and subscribe features.

==

r<

—

=

i

For descriptions of all publicly available Apple events, see the Apple Event Registry,
available from Macintosh® Developer Technical Support.
About This Chapter

>
—
=
ce)
=
<
o

—
A

a

Vi)
iS
“

6-3

Inside Macintosh,

Volume V1

ABOUT

APPLE

THE

EVENT

MANAGER

Apple events provide your application with a standard mechanism for communicating with
other applications. You can use Apple events and the Apple Event Manager to
m respond to the required Apple events (Open Application, Open Documents, Print
Documents, and Quit Application) that are sent by the Finder
m respond to the Apple events sent by the Edition Manager and allow users to share
data among documents created by multiple applications
m provide services to other applications
m request services from other applications
By supporting the required Apple events, your application can take advantage of the more
reliable launch and termination mechanisms built into system software version 7.0. You can
also take advantage of the services provided by the Edition Manager by responding to the
Apple events sent by the Edition Manager. These and additional core Apple events can be used
by nearly all applications to communicate with system software or with other applications.
You can also support functional-area Apple events related to your application in order to
provide services to other applications or to request services from other applications. Finally,
if your application defines Apple events for all the actions that a user can perform, you can
record user actions by generating the corresponding Apple event for each action, saving a
copy of the Apple event, and then sending the Apple event to your own application for
handling. Apple events that are recorded in this way can later be played back to automate
tasks previously performed by the user.
To support Apple events in your application, you must
m decide which Apple events (in addition to the required ones) to support
m set bits in the 'SIZE' resource to indicate that your application supports
high-level events
m create an Apple event dispatch table
m

include code to handle high-level events in your main event loop

m handle the Apple events your application receives and wishes to support
m create the Apple events you wish your application to generate
This chapter begins with an introduction to Apple events and then describes
m the required Apple events that your application must support to be 7.0-friendly
= how to use the Apple Event Manager to send and process Apple events

6-4

About the Apple Event Manager

The Apple Event Manager

INTRODUCTION

TO

APPLE

EVENTS

Applications typically use Apple events to request services from and provide services to
other applications. For example, the Open Documents event, sent by the Finder, requests
that your application open specified documents. When your application supports this Apple
event, it should respond by opening those documents in the manner that your application
normally opens documents.
A transaction involving Apple events is initiated by a client application, which sends an
Apple event to request a service (for example, printing a list of files, spell-checking a list of
words, or performing a numerical calculation). The application providing the service is called
a server application. These applications can reside on the same local computer or on
remote computers connected to a network.
Figure 6-1 shows a common Apple event, the Open Documents event. You see that the
Finder application is the client; it requests that the SurfWriter application open the documents
named Dec. Invoice and Nov. Invoice. The SurfWriter application responds to the Finder’s
request by opening windows containing the specified documents.
Apple event
Open Documents
Dec. Invoice
Nov.
;

Client
Sateen
application

Invoice

“4
4

é
a

Dec. Invoice

—aE Nov.
Invoice HE
FEN —_
>

|

My Company
San Francisco, Ca

h

2

Finder

|

Server
ae
application
c—>

Design
Art
_Film___
TOTAL

$200
$500
$200
$900

SurfWriter

Figure 6-1. An Open Documents event

The Finder is also the source application of the Open Documents event. A source application
is one that sends an Apple event to another application or to itself. In Figure 6-1, the SurfWriter
application is the target application of the event. The target application is the one addressed
to receive the Apple event. The terms client application and source application are not always
synonymous, nor are the terms server application and target application. Typically, an Apple
event client sends an Apple event requesting a service from an Apple event server; in this case,
the server is the target application of the Apple event. The Apple event server may send back a
different Apple event as a response—in which case, the client becomes the target of the
responding Apple event.

a)

a

Ss

is@

Ss
<
ic)

=ce
<4
—
a
=
=

ge

Ss

Introduction to Apple Events

6-5

Inside Macintosh,

Types

Volume VI

of Apple

Events

Apple events fall into one of several broad categories.
= Required Apple events consist of four core Apple events that the Finder sends
to applications. These events are called Open Documents, Open Application, Print
Documents, and Quit Application. They are a subset of the core Apple events and are
described in detail later in this chapter.
= Core Apple events are used by nearly all applications to communicate. The suite of
core Apple events is described in the Apple Event Registry; Apple recommends that all
applications support the core Apple events.
= Functional-area Apple events are supported by applications with related features.
Apple events related to text manipulation for word-processing applications and Apple
events related to graphics manipulation for drawing applications are examples of
functional-area Apple events. Functional-area Apple events are defined by Apple in
consultation with interested developers and are published in the Apple Event Registry.
Apple recommends that all developers support functional-area Apple events appropriate
for their types of applications.
= Custom Apple events are defined by a developer for use by the developer’s own
applications. You should register all of your custom Apple events with Macintosh
Developer Technical Support. You can choose to publish your Apple events in the
Apple Event Registry so that other applications can share them, or you may choose to
keep them unpublished for exclusive use by your own applications.

Components

of Apple

Events

An Apple event consists of attributes (which identify the Apple event and denote its task) and,
often, parameters (which contain data to be used by the target application). An application uses
the Apple Event Manager to create an Apple event. Using arguments you pass to the
AECreateAppleEvent function and to other Apple Event Manager routines, the Apple Event
Manager constructs the necessary data structures containing attributes and parameters and
converts these structures into an Apple event. Applications must use the Apple Event
Manager’s AESend function to transmit the Apple event. After receiving an Apple event,
om
must use Apple Event Manager routines to extract the attributes and parameters of
the event.
Attributes are a fundamental component of Apple events. Apple event attributes are
records that identify the event class, event ID, target application, and other characteristics
of an Apple event. Taken together, the attributes of an Apple event denote the task to be
performed on any data specified in the Apple event’s parameters. You do not have any
direct way to access the data stored in these records. You must use Apple Event Manager
routines to extract or specify the attributes.
An Apple event parameter is a record containing data that the target application uses.
Unlike Apple event attributes (which contain information that can be used by both the Apple
Event Manager and the target application), Apple event parameters contain data used only by
the target application. For example, an attribute like the event ID is used by the Apple Event

6-6

Introduction to Apple Events

The Apple Event Manager

Manager to call a handler from the server application’s dispatch table, and the server application must have a handler to process the event identified by that attribute. By comparison,
the list of documents contained in a parameter to an Open Documents event is used only by
the server application. As with attributes, you do not have any direct way to access the data
structure of a parameter. You have to use Apple Event Manager functions to extract data
from or put data into parameters.
Note that Apple event parameters are different from the parameters of Apple Event Manager
functions. Apple event parameters are records private to the Apple Event Manager; function
parameters are arguments you pass to the function or that the function returns to you. You
typically specify the Apple event parameters (as well as the attributes) in parameters to Apple
Event Manager functions. For example, the AEGetParamPtr function uses a buffer to return
the data contained in an Apple event parameter. You specify which Apple event parameter in
one of the parameters of the AEGetParamPtr function.
Apple events are identified by their event class and event ID attributes. The event class is
the attribute that identifies a group of related Apple events. The event class appears in the
message field of the event record for an Apple event. For example, the four required Apple
events (in fact, all core Apple events) have the value ‘aevt' in the message fields of their event
records. The value ‘aevt' can also be represented by the kCoreEventClass constant. Several
event classes are shown here.
Event class

Value

kCoreEventClass
‘aevt'
kAEFinderEvents
'"FNDR'
kSectionEventMsgClass _ 'sect’

Description
A core Apple event
An event that the Finder accepts
An event sent by the Edition Manager

The event ID is the attribute that identifies the particular Apple event within its event class. In
conjunction with the event class, the event ID uniquely identifies the Apple event and communicates what action the Apple event should perform. (The event IDs appear in the where field
of the event record for an Apple event.) For example, the event ID of an Open Documents event
has the value 'odoc' (which can also be represented by the kAEOpenDocuments constant). The
kCoreEventClass constant in combination with the kAEOpenDocuments constant identifies the
Open Documents event to the Apple Event Manager.

Event ID

Value

Description

kAEOpenApplication
kAEOpenDocuments
kAEPrintDocuments
kAEQuitApplication

‘oapp'
‘odoc'
‘pdoc'
‘quit’

Open your application
Open documents
Print documents
Quit your application

jaddy 9

Shown here are the event IDs for the four required Apple events.

u

r

The target application’s address is another required attribute. As previously described, the
target application is the one addressed to receive the Apple event. Your application can send
an Apple event to itself or to another application (on the same computer or on a remote
computer connected to the network).

<
<)
_

=

a
rn
oo
o>

|
ey
ge
@
“I

Introduction to Apple Events

6-7

Inside Macintosh,

Volume

VI

As with attributes, there are various types of Apple event parameters. A direct parameter
contains the data to be acted upon by the server application. For example, a list of documents
is contained in the direct parameter of the Print Documents event. Direct parameters are
usually required parameters—parameters that the server application needs in order to
carry out the task denoted by the Apple event. Some Apple events also take additional
parameters, which the server application uses in addition to the data specified in the
direct parameter. For example, an Apple event for arithmetic operations may include
additional parameters that specify operands in an equation. Additional parameters may be
required or optional.
An optional parameter is a supplemental parameter that also can be used to specify data
to the server application. Optional parameters need not be included in an Apple event; default
values for optional parameters are part of the event definition. The server application that
handles the event must supply default values if the optional parameters are omitted.
Figure 6-2 shows in greater detail the components of the Open Documents event that was
introduced in Figure 6-1.
Open Document event
Event class attribute:
kCoreEventClass
Event ID attribute:
kAEOpenDocument

Client

application

——

Server

Target address attribute:

application

application with the

aa

signature 'WAVE'

_

:

ae

j

Finder

=

45

1

Direct parameter:
list of files
(Dec.Invoice

1

%

|

SurfWriter

= ~

Now

Invoice

=|

My Company

nn
Design

$200

“TOTAL

$800

An

$500

rey |

Nov. Invoice)

Figure 6-2. Major components of an Open Documents event
To process the information contained in the Open Documents event, the SurfWriter application uses the AEProcessAppleEvent function. The AEProcessAppleEvent function provides
an easy way for your application to identify the event class and event ID of the Apple event
and to direct the Apple Event Manager to call the code in your program that handles the
Apple event.

Data

Structures

Within

Apple

Events

Applications must use Apple Event Manager functions to create and send an Apple event. The
Apple Event Manager constructs its own internal data structures to contain the information in
an Apple event. To gain access to this data, the target application also must use Apple Event
Manager functions. Neither the sender nor the receiver of an Apple event can directly manipulate the data inside an Apple event; each must rely on Apple Event Manager functions to do
so. This section describes the data structures that the Apple Event Manager uses to create and
to process Apple events.
6-8

Introduction to Apple Events

The Apple Event Manager

Descriptor records are the fundamental structures from which Apple events are constructed.
A descriptor record is a data structure of type AEDesc; it consists of a handle to data and a
descriptor type that identifies the type of the data referred to by the handle.
TYPE

AEDesc

=

RECORD

{descriptor

descriptorType:
dataHandle:

DescType;
Handle

record}

{type of data being
passed}
{handle
to data being passed}

END;

The data referred to by the dataHandle field in the descriptor record is private to the Apple Event
Manager. You can supply or extract this data only by using Apple Event Manager routines.
The descriptor type is a structure of type DescType, which in turn is of data type ResType—
that is, a four-character string. Constants are usually used in place of these four-character
strings when referring to descriptor types. Descriptor types represent various data types. Here
is a list of descriptor type constants, their values, and the types of data they represent.
Descriptor type

Value

Description

typeBoolean
typeChar
typeSMInt
typeInteger

‘bool’
"TEXT"
'shor'
‘long'

Boolean value
Unterminated string
16-bit integer
32-bit integer

typeFloat
typeLongInteger
typeShortInteger
typeLongFloat
typeShortFloat
typeExtended
typeComp
typeMagnitude
typeAEList
typeAERecord
typeAppleEvent
typeTrue
typeFalse
typeAlias
typeEnumerated
typeType
typeAppParameters
typeProperty
typeFSS
typeKeyword
typeSectionH
type WildCard
typeApplSignature
typeSessionID
typeTargetID

‘doub'
‘long’
‘shor'
‘'doub'
‘sing’
‘exte’
‘comp’
‘magn’
‘list’
'reco'
‘aevt
‘true’
‘fals'
‘alis'
‘enum’
‘type’
‘appa’
‘prop’
‘Ess *
'keyw'
‘sect’
iti faced
‘sign’
‘ssid’
‘targ’

SANE double
32-bit integer
16-bit integer
SANE double
SANE single
SANE extended
SANE comp
Unsigned 32-bit integer
List of descriptor records
List of keyword-specified descriptor records
Apple event record
TRUE Boolean value
FALSE Boolean value
Alias record
Enumerated data
Four-character code for event class or event ID
Process Manager launch parameters
Apple event property
File system specification
Apple event keyword
Handle to a section record
Matches any type
Application signature
Session ID
Target ID record

a
>
=
o
St
5
S
=

‘null’

NULL or nonexistent data

<7

typeSMFloat

typeProcessSerialNumber
typeNull

'sing'

‘psn

'

SANE® single

Process serial number

Introduction to Apple Events

6-9

A

Inside Macintosh,

Volume VI
&

Figure 6-3 illustrates a descriptor record with a descriptor type of typeType, which specifies that
the data in the descriptor record must consist of a four-character code. The data in this particular
descriptor record is specified by the constant kCoreEventClass, whose value is 'aevt’.
Data type AEDesc

Descriptor type:

typeType

Data:

(kCoreEventClass)

Event class

Figure 6-3. A descriptor record with event class data
A descriptor record that contains the address of the target or source of an Apple event is called
an address descriptor record.
TYPE

AEAddressDesc

=

AEDesc;

{address

descriptor

record}

As you will see later, the address can be specified as an application signature, a process serial
number, a session ID, a target ID record, or a data type that you define.
Data for attributes and parameters is contained in descriptor records. The attributes and
parameters themselves are identified by keywords. The AEKeyword data type is defined
as a four-character code.
TYPE

AEKeyword

=

PACKED

ARRAY[1..4]

OF

Char;

{keyword
{

for

a

descriptor

}

record}

Constants are typically used for keywords. Shown here is a list of these keyword constants,
their four-character codes, and the attributes and parameters they represent.
Attribute keyword

Value

Description

keyAddressAttr
keyEventClassAttr
keyEventIDAttr
keyEventSourceAttr
keyInteractLevelAttr

‘addr’
‘evcl’
‘evid'
‘esre'
‘inte’

keyMissedKeywordAttr

‘miss’

keyOptionalKeywordAttr
keyReturnIDAttr
keyTimeoutAttr

'optk'
'rtid'
‘timo’

keyTransactionIDAttr

‘tran’

Address of target application
Event class of Apple event
Event ID of Apple event
Source of the Apple event
Settings for allowing the Apple Event Manager
to bring a server application to the foreground
First required parameter remaining in an
Apple event
List of optional parameters for the Apple event
Return ID for reply Apple event
Length of time in ticks that the client will
wait for a reply or a result from the server
Transaction ID identifying a series of
Apple events

6-10

Introduction to Apple Events

The Apple Event Manager

Parameter keyword

Value

Description

keyDirectObject
keyErrorNumber
keyErrorString
keyProcessSerialNumber

os
‘errn’
‘errs:
‘psn
'

Direct parameter
Error number parameter
Error string parameter
Process serial number parameter

A data structure of type AEKeyDesc consists of a keyword and a descriptor record. This data
structure, called a keyword-specified descriptor record, is used by the Apple Event
Manager to fully identify and describe an attribute or a parameter of an Apple event.
TYPE

AEKeyDesc
RECORD

=

{keyword-specified

descriptor

descKey:

AEKeyword;

{keyword}

descContent:

AEDesc

{descriptor

record}

record}

END;

Figure 6-4 illustrates a keyword-specified descriptor record for the event class attribute of an
Open Documents event. The keyEventClassAttr keyword identifies its descriptor record as
containing event class data. The data is of the typeType descriptor type, and the data identifies
the event class as kCoreEventClass.
Data type AEKeyDesc

Keyword:

keyEventClassAttr

Descriptor record:
Descriptor type:

typeType

ate:

(kCoreEventClass)

Event class

Figure 6-4. A keyword-specified descriptor record for the event class attribute of
an Open Documents event
When extracting data from an Apple event, you use Apple Event Manager functions to return
data in a buffer specified by a pointer, or to return descriptor records containing the data, or
to return lists of descriptor records (called descriptor lists) containing the data. As previously
noted, the descriptor record (of data type AEDesc) is the fundamental structure in Apple events,
and it contains a handle to data. A descriptor list is a data structure of type AEDescList
defined by the data type AEDesc—that is, a descriptor list is a descriptor record that contains a
list of other descriptor records.
TYPE

AEDescList

=

AEDesc;

{list

of

descriptor

>

Ss
=)—
@

es

records}

<
@

=

a

An example of a descriptor list that you will be using is the direct parameter for the Open
Documents event. As illustrated in Figure 6-5, this descriptor list is a list of descriptor
records that contain alias records to filenames. (The Alias Manager chapter of this volume
describes alias records in detail.)
Introduction to Apple Events

“

2a

bs)

=
i)
go
@

en

6-1]

|

Inside Macintosh, Volume VI

Data type AEDescList
Descriptor type:

typeAEList

Data:

“s,

List of descriptor records:
Descriptor type:

| typeAlias
Alias record for filename

Data:

(Nov. Invoice)

Descriptor type:

| typeAlias
Alias record for filename
(Dec. Invoice)

Data:

Figure 6-5. A descriptor list for a list of aliases
Closely related to a descriptor list is a structure of data type AERecord; in fact, it is defined by
the data type AEDescList.
TYPE

AERecord

=

AEDescList;

{list
{

of

keyword-specified

descriptor

}

records}

While a descriptor list is a descriptor record that contains a list of other descriptor records,
an AE record of data type AERecord contains a list of keyword-specified descriptor records
describing parameters. A descriptor list of data type AERecord contains no attributes, only
parameters.
There is one final data structure to consider: the Apple event record. An Apple event
record is a structure of data type AppleEvent defined as an AE record. It is used for
describing a full-fledged Apple event.
TYPE

AppleEvent

=

AERecord;

{list
{

of

attributes

necessary

for

an

and
Apple

parameters

}

event}

An Apple event record is basically a descriptor record (of descriptor type typeAppleEvent) with
a handle to a list of keyword-specified descriptor records. These descriptor records describe
the attributes and parameters for an Apple event. When you use the AECreateAppleEvent
function, the Apple Event Manager creates an Apple event record containing the attributes for
an Apple event’s event class, event ID, target address, return ID, and transaction ID. You then
use Apple Event Manager functions such as AEPutParamDesc to add parameters to the Apple
event. Figure 6-6 shows an example of an Apple event—a structure containing a list of
keyword-specified descriptor records that name the attributes and parameters of an Open
Documents event.

6-12

Introduction to Apple Events

The Apple Event Manager

Data type AppleEvent
Descriptor type:

typeAppleEvent

Data:

List of attributes and parameters
Event class attribute

Keyword:
Descriptor record:

keyEventClassAttr
Descriptor type:

typeType

Data:

Event class
(kCoreEventClass)

Event ID attribute

Keyword:

keyEventiDAttr

Descriptor record:

Descriptor type:

typeType
Event ID

Date:

(kAEOpenDocuments)

Target application attribute
Keyword:
BOCAS

aeons

keyAddressAtir
Descriptor type:

typeApplSignature

Data:

Target application’s
address ('WAVE')

Direct parameter
Keyword:
DeschPiar Taeor:

keyDirectObject
Descriptor type:

typeAEList

Data:

List of descriptor
records:

Descriptor type:
Data:

| typeAlias
Alias record for filename

(Nov. Invoice)

Descriptor type:
Data:

|

“

| typeAlias

>
<)

=om

Alias record for filename

(Dec. Invoice)

=
<
7)
=

= |

—

2

Ty

=

Figure 6-6. Data structures within an Open Documents event

ge<7)
“

Introduction to Apple Events

6-13

Inside Macintosh, Volume VI

The internal structure of an Apple event record is nearly identical to an AE record. They differ
in the content referred to by the data handles that they contain: the former has a list of attributes
and, possibly, parameters referred by its handle; the latter contains only parameters. However,
you can pass an Apple event record to any Apple Event Manager function that expects an AE
record. Since both are structures of data type AEDescList, which is derived from the data type
AEDesc, you can pass Apple event records, AE records, descriptor lists, and descriptor
records to any Apple Event Manager functions that expect records of data type AEDesc.

The data in Apple event records, AE records, and descriptor lists—all of which are descriptor
records—is private to the Apple Event Manager. The Apple Event Manager maintains these
different data structures because it stores different kinds of information in their handles.
Although all the information you need is available by calling the appropriate Apple Event
Manager functions, the Apple Event Manager needs a way to tell these different descriptor
records apart. It does this by looking at their data types.

Responding

to Apple

Events

A client application uses the Apple Event Manager to create and send an Apple event requesting
a service. A server application responds by using the Apple Event Manager to process the
Apple event, to extract data from the attributes and parameters of the Apple event, and to return
a result to the client application. The server provides its own routines for performing the action
requested by the client’s Apple event.
As its first step in supporting Apple events, your application must be able to respond to the
required Apple events sent by the Finder. If you plan to implement publish and subscribe
capabilities, your application must respond to the Apple events sent by the Edition Manager.
You can also respond to Apple events sent by your own application or by other applications. This section provides a quick overview of the steps your application takes in responding
to Apple events.
To respond to Apple events, your application must
m test for high-level events in its event loop
m use the AEProcessAppleEvent function to process Apple events
m provide handler routines for the Apple events it supports
m

use Apple Event Manager functions to extract the parameters and attributes from
Apple events

m use the AEInteractWithUser function—if your application requires input from the user
when your application is responding to an Apple event—to bring your application to the
foreground to interact with the user
m

return a result for the client

Note that in order for your application to respond to Apple events sent from remote computers,
the user of your application must allow network users to link to your application. The user
does this by selecting your application from the Finder and choosing Sharing from the File
menu and then clicking the Allow Remote Program Linking check box. If the user has not yet
started program linking, the Sharing command offers to display the Sharing Setup control
panel so that the user can start program linking. The user must also authorize remote users for
6-14

Introduction to Apple Events

The Apple Event Manager

program linking by using the Users and Groups control panel. Program linking and setting up
authenticated sessions are described in the Program-to-Program Communications Toolbox
chapter in this volume.
An Apple event (like all high-level events) is identified by a message class of kHighLevelEvent
in the what field of the event record. You test the what field of the event record to determine
whether an event is a high-level event. If the what field contains the kHighLevelEvent constant
and your application defines any high-level events other than Apple events, test the message
field of the event record to determine whether the high-level event is something other than an
Apple event. If the high-level event is not one that you’ve defined for your application, assume
that it is an Apple event. (Note that you are encouraged to use Apple events instead of defining
your own high-level events whenever possible.)
After determining that an event is an Apple event, use the AEProcessAppleEvent function to
let the Apple Event Manager identify the event. Figure 6-7 shows how the SurfWriter
application accepts and begins to process an Apple event sent by the Finder.
Apple event
Open Documents
Dec. Invoice
Nov. Invoice

Client
application

Server
application

—_

3

Finder

SurfWriter
Ta

Event loop
CASE event.what OF
kHighLevelEvent:
DoHighLevelEvent(event)
=o
DoHighLevelEvent(event)

CASE event.message OF
myHighLevelEvent?: ...
myHighLevelEvente: ...
OTHERWISE
AEProcessAppleEvent(event)

Apple Event Manager

Figure 6-7. Accepting and processing an Open Documents event
The AEProcessAppleEvent function begins processing the Apple event. The
AEProcessAppleEvent function identifies the Apple event by examining the data in the
event class and event ID attributes. The AEProcessAppleEvent function in turn uses that
data to call the Apple event handler that your application provides for that event. An Apple
event handler is a function that extracts the pertinent data from the Apple event,
performs the action requested by the Apple event, and returns a result. For example, if the
event has an event class of kCoreEventClass and an event ID of kAEOpenDocuments, the
AEProcessAppleEvent function calls your application’s routine for handling the Open
Documents event.
Introduction to Apple Events

6-15

i 9)

>

eee

—_

—

=
®

S3)

<
@_

al

~~

2
—

=
=
_
gO
o

Inside Macintosh,

Volume VI

You install Apple event handlers by using the AEInstallEventHandler function. This function

creates an Apple event dispatch table that the Apple Event Manager uses to map Apple

events to handlers in-your application. After being called by the AEProcessAppleEvent
function to process an-Apple event, the Apple Event Manager reads the Apple event dispatch

table and, if your application has installed a handler for that Apple event, calls your handler to
finish responding to the event. Figure 6-8 shows how the flow of control passes from your
application to the Apple Event Manager and back to your application.
Server

L AEProcessAppleEvent(event)
Event
Handler
Open Documents| @ MyHandleODoc | ~—
Print Documents | @MyHandlePDoc

Call MyHandleODoc
MyHandleODoc(anAppleEvent)
« extract list of documents
from direct parameter
* open each document in a
window
* return function result and,
if appropriate, error string

Figure 6-8. The Apple Event Manager calling the handler for an Open Documents event
Your Apple event handlers must generally perform the following tasks:
m extract the parameters and attributes for the Apple event

= check that all the required parameters have been extracted
= set user interaction level preferences if necessary and, if your application needs to interact
with the user, use the AEInteractWithUser function to bring it to the foreground
m perform the action requested by the Apple event
m dispose of any copies of descriptor records that have been created
m

6-16

return a result for the client

Introduction to Apple Events

The Apple Event Manager

You must use Apple Event Manager functions to extract the data from Apple events. You can
also use Apple Event Manager functions to get data out of descriptor records, descriptor lists,
and AE records. Most of these routines are available in two forms: one that uses a buffer to
return a copy of the desired data, and one that returns a copy of the descriptor record containing the data. The following list shows the main functions you can use to access the data of an
Apple event.
Function

Description

AEGetParamPtr

Uses a buffer to return the data contained in a parameter; used,

for example, to extract the result code from the keyErrorNumber
parameter of a reply Apple event.

AEGetParamDesc

Returns the descriptor record or descriptor list for a parameter;
used, for example, to extract the descriptor list for a list of alias
records specified in the direct parameter of the Open Documents
event.

AEGetAttributePtr

Uses a buffer to return the data contained in an attribute; used, for
example, to determine the source of an Apple event by extracting
the data from the keyEventSourceAttr attribute.

AEGetAttributeDesc

Returns the descriptor record for a parameter; used, for example,
to make a copy of a descriptor record containing the address of
an application.

AECountltems

Returns the number of descriptor records in a descriptor list;
used, for example, to determine the number of alias records for
documents specified in the direct parameter of the Open
Documents event.

AEGetNthPtr

Uses a buffer to return the data for a descriptor record that is
contained in a descriptor list; used, for example, to extract a
document’s alias record from the descriptor list specified in the
direct parameter of the Open Documents event.

AEGetNthDesc

Returns a descriptor record from a descriptor list; used, for
example, to get the descriptor record containing an alias record
from the list specified in the direct parameter of the Open
Documents event.

You can specify the descriptor type of the resulting data for these functions; if this is different
from the descriptor type of the attribute or parameter, the Apple Event Manager attempts to
coerce it to the specified type. In the direct parameter of the Open Documents event, for
example, each descriptor record in the descriptor list is an alias record; each alias record
specifies a document to be opened. As explained in the File Manager chapter of this volume,
all your application usually needs is the file system specification (FSSpec) record of the
document. When you extract the descriptor from the descriptor list, you can request that the
Apple Event Manager return the data to your application as a file system specification record
instead of as an alias record.

Nn
>
Ss
ic)

emes

@

es
<
@

=oo
<<
—
)

m_

et

ee)

ge
@

er

Introduction to Apple Events

6-17

Inside Macintosh,

Volume VI

After extracting all known parameters, your handler should check that it retrieved all the
required parameters by checking whether the keyMissedKeywordAttr attribute exists. If
the attribute exists, then your handler has not retrieved all the required parameters, and it
should return an error.
In some cases, the server may need to interact with the user when it handles an Apple event.
For example, your handler for the Print Documents event may need to display a print options

dialog box and get settings from the user before printing. Your handler should always use the

AEInteractWithUser function before displaying a dialog box or alert box or otherwise interacting with the user. By specifying one of these flags to the AESetInteractionAllowed function,
you can set your application’s user interaction level preferences.
Flag

Description

kAEInteractWithSelf

User interaction with your server application in response to an
Apple event may be allowed only when the client application is
your own application—that is, only when your application is
sending the Apple event to itself.

kAEInteractWithLocal

User interaction with your server application in response to an
Apple event may be allowed only if the client application is on
the same computer as your application; this is the default if the
AESetInteractionAllowed function is not used.

kAEInteractWithAll

User interaction with your server application in response to
an Apple event may be allowed for any client application on
any computer.

For a server application to allow user interaction in response to the client’s Apple event,
two conditions must be met. First, the client application must request that your server application allow user interaction. Second, your server application must allow user interaction
in response to the Apple event sent from that client application as described in the previous
list. If these conditions are met and your application needs to interact with the user, the
AEInteractWithUser function brings your application to the foreground if it isn’t already in

the foreground. Your application can then display its dialog box or alert box or otherwise

interact with the user. AEInteractWithUser brings your server application to the front either
directly or after the user responds to a notification request.
When your application acts on an Apple event, it should perform the standard action requested
by that event. For example, if the Apple event is the Open Documents event, your application
should open the specified documents in titled windows just as if the user had selected each
document from the Finder and then chosen Open from the File menu. You should strive to
create routines that can be called in response to both user events and Apple events. To do this,
you need to isolate code for interacting with the user from the code that performs the requested
action—such as opening a document. You then call the code that performs the requested action
from your Apple event handler.
When you extract a descriptor record by using the AEGetParamDesc, AEGetAttributeDesc,
AEGetNthDesc, or AEGetKeyDesc function, the Apple Event Manager creates a copy of the
descriptor record for you to use. When your handleris finished using a copy of a descriptor
record, you should dispose of it—and thereby deallocate the memory it uses—by calling the
AEDisposeDesc function.
6-18

Introduction to Apple Events

The Apple Event Manager

The required Apple events ask your application to perform tasks—open your application,
open or print documents, or quit your application. Other Apple events may ask your
application to return data. For example, if your application is a spelling checker, the client
probably expects data in the form of a list of misspelled words to be returned from your
application. If a reply is requested, the Apple Event Manager prepares a reply Apple event
for the client by passing a default reply Apple event to your handler. The default reply
Apple event has no parameters when it is passed to your handler. Your handler can add any
parameters to the reply Apple event. If your application is a spelling checker, for example,
you can return a list of misspelled words in a parameter.
Your handler routine should always set its function result either to noErr if it successfully
handles the Apple event or to a nonzero result code if an error occurs. If an error occurs, the
Apple Event Manager adds a keyErrorNumber parameter to the reply Apple event; this
parameter contains the result code that your handler returns. The client should check whether
the keyErrorNumber parameter exists to determine whether your handler performed the
requested action. In addition to returning a result code, your handler can also return an error
string in the keyErrorString parameter of the reply Apple event. The client can use this string
in an error message to the user.
If the source requested a reply, the Apple Event Manager returns the reply Apple event to the
source. The reply Apple event is identified by the event class kCoreEventClass and by the event
ID kAEAnswer. When you have finished using the reply Apple event, you should dispose of
it—and thereby deallocate the memory it uses—by calling the AEDisposeDesc function.
When your handler returns a result code to the Apple Event Manager, you have finished your
response to the client’s Apple event. Figure 6-9 shows the entire process of responding to an
Apple event. The next section describes how to send an Apple event.

Requesting

Services

Through

Apple

Events

Your application can use Apple events to request services from other applications. By using
Finder events, for example, your application can simulate the behavior of the Finder by
requesting that the Finder perform such operations as launching an application on your
behalf. By using functional-area Apple events, your application can request services from
applications related to your own—for example, asking a spelling checker application to check
the text in a document created by your application. All publicly available Apple events are
defined and published in the Apple Event Registry. Consult the Apple Event Registry for the
format and function of Apple events that your application may wish to send.
The previous section describes how a server application responds to a client application’s
request for services. This section briefly describes the steps your application must take to act
as a client application and request such services. To request a service through an Apple event,
your application must

‘= \

=

= create an Apple event by calling the AECreateAppleEvent function
= use Apple Event Manager functions to add parameters and any other necessary attributes
to the Apple event

eee
A
—
Ld
—

Le)
=
a

<
<7)
—

_

= call the AESend function to send the Apple event

a

—
—

i

= dispose of any copies of descriptor records that you have created

ne
ee

Ey
geic

m process the reply Apple event (optional)

ar

Introduction to Apple Events

6-19

o

Inside Macintosh, Volume VI

Appl e event
Dec. Invoice
Nov. Invoice

Client

Server

application

application

(>

Finder

SurfWriter

JN

4,

Event loop
CASE event.what OF
kHighLevelEvent:
DoHighLevelEvent(event)
DoHighLevelEvent(event)
CASE event.message OF
myHighLevelEvent1: ...
myHighLevelEvente: ...
OTHERWISE

AEProcessAppleEvent(event)}

Apple Event Manager
Apple event dispatch table
Event
Handler
Open Documents|

@ MyHandleODoc

Print Documents | @MyHandlePDoc

Call MyHandleODoc |

MyHandleODoc(anAppleEvent)
e extract list of documents

Bill to:

from direct parameter

pide A

Sen | ae
%
|
TOTAL
$900

—

e open each document in a

a
.

window
* return function result and,
if appropriate, error string
iether Ee
a

Return reply Apple event|

Apple event
noErr function result

Figure 6-9. Responding to an Open Documents event

6-20

Introduction to Apple Events

The Apple Event Manager

Use the AECreateAppleEvent function to create an Apple event record. Using the arguments
you pass to the AECreateAppleEvent function, the Apple Event Manager constructs the data
structures describing the event class, the event ID, and the target address attributes of an Apple
event. The event class and event ID, of course, identify the particular event you wish to send.
The target address identifies the application to which you wish to send the Apple event.
To act as a server application for your application, the target must support high-level events
and must be open. The server can be your own application, another application running on
the user’s computer, or an application running on another user’s computer connected to the
network. Your application should offer some facility to launch a server application if it is not
already running. It is recommended that you use the Open Selection event (identified by the
event class KAEFinderEvents and the event ID kAEOpenSelection) to request that the Finder
launch applications; however, the Process Manager also provides a means for your application to launch other applications. See the Apple Event Registry for information on Finder
events, and see the Process Management chapter in this volume for information on using the
Process Manager.
Your application should also offer a facility to allow the user to choose among the various
applications available as servers. The PPCBrowser function allows users to select target applications on the user’s computer as well as those available on computers connected to the
network. The PPCBrowser function presents a standard user interface for choosing a target
application, much as the Standard File Package provides a standard user interface for opening
and saving files. See the Program-to-Program Communications Toolbox chapter of this volume
for details on using the PPCBrowser function.
If the server application is on a remote computer on a network, the user of that computer must
allow program linking to the server application. The user of the server application does this
by selecting the application from the Finder and choosing Sharing from the File menu and
then clicking the Allow Remote Program Linking check box. If the user has not yet started
program linking, the Sharing command offers to display the Sharing Setup control panel so
that the user can start program linking. The user must also authorize remote users for program linking by using the Users and Groups control panel. Program linking and setting up
authenticated sessions are described in the Program-to-Program Communications Toolbox
chapter in this volume.
There are two other attributes you specify in the AECreateAppleEvent function: the reply ID and
the transaction ID. For the reply ID attribute, you’ll usually specify the kAutoGenerateReturnID
constant to the AECreateAppleEvent function. This constant ensures that the Apple Event
Manager generates a unique return ID for the reply Apple event returned from the server. For
the transaction ID attribute, you'll usually specify the kAnyTransactionID constant, which
indicates that this Apple event is not one of a series of interdependent Apple events.
The Apple event record created with the AECreateAppleEvent function serves as a template for
the Apple event you want to send. To add the remaining attributes and parameters necessary
for your Apple event, you must use these additional Apple Event Manager functions.

“
~~

~~

—
A

Function
AEPutParamPtr

s=)wrt

Description

@

cs)

Takes a keyword, descriptor type, and pointer to data, converts
them into a parameter, and adds the parameter to or replaces it in
an Apple event record; used, for example, to place numbers into
the parameters of an Apple event requesting that the server
perform a calculation.
Introduction to Apple Events

6-21

<

@

=

—

<<
—
=

—

—_

~
ve
a
“

Inside Macintosh,

Volume

VI

Function

Description

AEPutParamDesc

Takes a keyword and a descriptor record, converts them into a
parameter, and adds the parameter to or replaces it in an Apple
event record; used, for example, to place a descriptor list
containing alias records into the direct parameter of an Apple
event that requests a server to manipulate files.

AEPutAttributePtr

Takes a keyword, descriptor type, and pointer to data, converts
them into an attribute, and adds the attribute to or replaces it in an
Apple event record; used, for example, to change the event ID of
an Apple event record that is waiting to be sent.

AEPutAttributeDesc

Takes a keyword and a descriptor record, converts them into an
attribute, and adds the attribute to or replaces it in an Apple event
record; used, for example, to replace the descriptor record used
for the target address attribute in an Apple event record waiting to
be sent.

Descriptor records and descriptor lists are the basic components from which an Apple event
record is constructed; these are passed to the AEPutParamDesc and AEPutAttributeDesc

functions. Use the following functions to create descriptor records and descriptor lists.
Function

Description

AECreateDesc

Takes a descriptor type and a pointer to data and converts them
into a descriptor record; used, for example, to create a descriptor
record that is used as an attribute or a parameter in an Apple
event record.

AEPutPtr

Takes a descriptor type and a pointer to data, converts them into a
descriptor record, and adds the record to a descriptor list; used,
for example, to place into a descriptor list a number that is used
as the parameter of an Apple event requesting a calculation.

AEPutDesc

Adds a descriptor record to a descriptor list; used, for example, to

add into the descriptor list an alias record that is used as the direct
parameter of an Apple event requesting file manipulation.

After you add all the attributes and parameters required for the Apple event, use the AESend

function to send the Apple event. The Apple Event Manager uses the Event Manager to

transmit the Apple event to the server application.

The AESend function requires that you specify whether and how your application should
wait for a reply from the server. When the server receives your Apple event, the Apple Event
Manager prepares a reply Apple event for your application by passing a default reply Apple
event to the server. The Apple Event Manager returns any nonzero result code from the
server's handler in the keyErrorNumber parameter of the reply Apple event. If your application wants to return an error string, add it to the reply Apple event in the keyErrorString
parameter. The server can also use this reply Apple event to return any data you requested—
for example, the results of a numerical calculation or a list of misspelled words.

6-22

Introduction to Apple Events

The Apple Event Manager

You specify how your application should wait for a reply by using one of these flags in the
sendMode parameter of the AESend function.
Flag

Description

kAENoReply

Your application does not want a reply Apple event; the server
processes your Apple event as soon as it has the opportunity.

kAEQueueReply

Your application wants a reply Apple event; the reply appears in
your event queue as soon as the server has the opportunity to
process and respond to your Apple event.

kAEWaitReply

Your application wants a reply Apple event and is willing to give
up the processor while waiting for the reply; for example, if the
server application is on the same computer as your application,
your application yields the processor to allow the server to
respond to your Apple event.

If you specify the kAEWaitReply flag, you may provide an idle function. This function should
process any events that occur while your application is waiting for a reply. You supply a
pointer to your idle function as a parameter to the AESend function. So that your application
can process other Apple events while it is waiting for a reply, you can also specify an optional
filter function to the AESend function that filters Apple events.
If your Apple event may require the user to interact with the server application (for example,
to specify print or file options), you can communicate your user-interaction preferences
to the server by specifying one of the following flags in the sendMode parameter of the
AESend function.

Flag

Description

kAENeverlInteract

The server application should never interact with the user in
response to this Apple event. If this flag is set, AEInteractWithUser
does not bring the server application to the foreground (this is the
default when an Apple event is sent to a remote application).

kAECanInteract

The server application can interact with the user in response to
this Apple event—by convention, if the user needs to supply
information to the server. If this flag is set and the server allows
interaction, AEInteractWithUser brings the server application to
the foreground (this is the default when an Apple event is sent to
a local application).

kAEAIwayslInteract

The server application can interact with the user in response to
this Apple event—by convention, even if no information is
needed from the user. If this flag is set and the server allows
interaction, AEInteractWithUser brings the server application to
the foreground. The Apple Event Manager does not distinguish
between this flag and the kAECanInteract flag—distinguishing
between them is the responsibility of the server application.

i 9)
ee
<)
i
_

—

o

es)

<
O
—

a
a

<4
—
TO)
_

oo

ee)
it~)

O
a

Introduction to Apple Events

6-23

Inside Macintosh,

Volume VI

Flag

Description

kAECanSwitchLayer

If both the client and server allow interaction and this flag is set,
AEInteractWithUser brings the server directly to the foreground
if adherence to the principle of user control allows. If the action
would be contrary to this principle, AEInteractWithUser uses
the Notification Manager to request that the user bring the server
application to the foreground. If both the client and server allow
interaction and this flag is not set, AEInteractWithUser always
uses the Notification Manager to request that the user bring the
server application to the foreground.

The server can set its own interaction preferences. The interaction of your client’s preferences
and the server’s is explained in “Interacting With the User” later in this chapter.
After you send an Apple event, your application is responsible for disposing of the Apple
event record—and thereby deallocating the memory it uses—by calling the AEDisposeDesc
function. If you create one descriptor record and add it to another, the Apple Event Manager
creates a copy of the newly created one and adds that copy to the existing one. For example,
you might use the AECreateDesc function to create a descriptor record that you wish to add to
an Apple event. When you use the AEPutParamDesc function, it creates a copy of your
newly created descriptor record and adds that copy as a parameter to an existing Apple event.
Your application should dispose of all the descriptor records that are created in order to add
parameters and attributes to an Apple event. You normally dispose of your Apple event and
its reply after you receive a result from the AESend function. You should dispose of these
even if AESend returns an error result. If your application requests a reply Apple event, your
application must also dispose of the reply Apple event when finished processing it.
Your application can request a reply Apple event. If you specify the kAEWaitReply flag, the
reply Apple event is returned in a parameter you pass to the AESend function. If you specify
the kAEQueueReply flag to the AESend function, the reply Apple event is returned in the
event queue. In this case, the reply is identified by the event class kCoreEventClass and the
event ID kAEAnswer; your application processes reply events that it receives in its event
queue in the same manner that server applications process Apple events, as described earlier
in “Responding to Apple Events.”
Your application should check for the keyErrorNumber parameter of the reply Apple event to
ensure that the server performed the requested action. Any error messages that the server
returns for you to display to your user will appear in the keyErrorString parameter.
When your handler is finished using a copy of a descriptor record used in the reply Apple
event, you should dispose of them both—and thereby deallocate the memory they use—by
calling the AEDisposeDesc function.
The next section, “Using the Apple Event Manager,” describes in greater detail the routines
necessary for sending and responding to Apple events.

6-24

Introduction to Apple Events

The Apple Event Manager

USING

THE

APPLE

EVENT

MANAGER

The following sections explain in more detail how to use the Apple Event Manager to receive,
accept, and send Apple events. The first two sections describe how to accept and process
Apple events and how to install entries into the Apple event dispatch table. The following
section fully explains how your application should handle the required Apple events, and it
provides code that shows sample handlers for the required Apple events.
Additional sections describe how to
a handle events that support publish and subscribe features
m get data out of an Apple event
= write handlers that perform the action requested by an Apple event
= reply to an Apple event
m dispose of Apple event data structures
= interact with the user when processing an Apple event
m create an Apple event
m send an Apple event
a write an idle function
a write areply filter function
m write and install coercion handlers

= use the Application Died event to ascertain the termination of an application that has been
launched by your application
The Apple Event Manager is available only in system software version 7.0. Use the Gestalt
function with the gestaltAppleEventsAttr selector to determine whether the Apple Event
Manager is available. In the response parameter, the bit defined by the constant
gestaltAppleEventsPresent is set if the Apple Event Manager is available.
CONST

gestaltAppleEventsAttr
gestaltAppleEventsPresent

=

'evnt';

=

0;

selector}
{Gestalt
}
then
is set,
{if this bit
{ Apple
Event
Mgr's available}

>

>

SS

gt

\e*)

f=
<

i)

=)oo
24
a
i

=
ga

@
ar

Using the Apple Event Manager

6-25

Inside Macintosh,

Accepting

Volume VI

an Apple

Event

To accept Apple events (or any other high-level events), you must set the appropriate flags
in your application’s 'SIZE' resource and include code to handle high-level events in your
application’s main event loop.
Two flags in the 'SIZE' resource determine whether an application receives high-level events:
a The isHighLevelEventAware flag must be set for your application to receive any highlevel events.

= The localAndRemoteHLEvents flag must be set for your application to receive highlevel events sent from another computer on the network.
Note that in order for your application to respond to Apple events sent from remote computers,
the user of your application must also allow network users to link to your application. The user
does this by selecting your application from the Finder and choosing Sharing from the File
menu and then clicking the Allow Remote Program Linking check box. If the user has not yet
started program linking, the Sharing command offers to display the Sharing Setup control
panel so that the user can start program linking. The user must also authorize remote users for
program linking by using the Users and Groups control panel. Program linking and setting up
authenticated sessions are described in the Program-to-Program Communications Toolbox
chapter in this volume.
For a complete description of the 'SIZE' resource, see the Event Manager chapter in this
volume.
Apple events (and other high-level events) are identified by a message class of kHighLevelEvent
in the what field of the event record. You can test the what field of the event record to determine
whether the event is a high-level event.
Listing 6-1 is an example of a procedure called from an application’s main event loop that
handles events, including high-level events. The procedure determines the type of event
received and then calls another routine to take the appropriate action.
Listing 6-1. A DoEvent
PROCEDURE

DoEvent

(event:

procedure

EventRecord);

BEGIN
CASE

event.what

OF

{determine

the

type

of

event}

mouseDown:

DoMouseDown

(event) ;

{handle

kinds

other

{handle high-level
kHighLevelEvent:
DoHighLevelEvent

of

events}

events,

including

(event);

END;
END;

6-26

Using the Apple Event Manager

Apple

events}

The Apple Event Manager

Listing 6-2 is an example of a DoHighLevelEvent procedure that handles Apple events and also
handles the high-level event identified by the event class mySpecialHLEventClass and the event
ID mySpecialHLEventID. Note that, in most cases, you should use Apple events to communicate with other applications.
Listing 6-2.
PROCEDURE

A DoHighLevelEvent procedure for handling Apple events and
other high-level events

DoHighLevelEvent

(event:

EventRecord) ;

VAR
myErr:

OSErr;

BEGIN

IF

(event.message

(LongInt
BEGIN

{it's

a

=

LongInt

(event.where)

high-level

myErr
:=
IF myErr
DoError

event

=

(mySpecialHLEventClass))
LongInt

that

AND

(mySpecialHLEventID))

doesn't

use

THEN

AEIMP}

HandleMySpecialHLEvent
(event) ;
<> noErr THEN
(myErr)

;

{perform

the

necessary

the

event

error

handling}

END
ELSE
BEGIN

{otherwise,

myErr
IF

:=

assume

that

is

an

Apple

event}

AEProcessAppleEvent
(event) ;

myErr <> noErr THEN
DoError (myErr) ;

END;
END;

If your application accepts high-level events that do not follow the Apple Event Interprocess
Messaging Protocol (AEIMP), you must dispatch these high-level events before calling
AEProcessAppleEvent. To dispatch a high-level event that does not follow AEIMP, for each
event you should check the event class, the event ID, or both to see if the event is one that
your application can handle.
After receiving a high-level event (and, if appropriate, checking whether it is a type of highlevel event other than an Apple event), your application typically calls the AEProcessAppleEvent
function. The AEProcessAppleEvent function determines the type of Apple event received, gets
the event buffer that contains the parameters and attributes of the Apple event, and calls the
corresponding Apple event handler routine in your application.
You should provide a handler routine for each Apple event that your application supports.
Your handler routine for a particular Apple event is responsible for performing the action
requested by the Apple event, and your handler can optionally return data in the reply
Apple event.

2)
Se
~~
—

eA

—

~

—

After your handler finishes processing the Apple event and adds any parameters to the default
reply, it should return a result code to AEProcessAppleEvent. If the client application is waiting
for a reply, the Apple Event Manager returns the reply Apple event to the client.

Le)
—
J

<
ia”)

=|

—_

a
oad
as
=
—
_

i
ge

ce
ber |

Using the Apple Event Manager

6-27

Inside Macintosh, Volume V1

Installing

Entries

Into the Apple

Event

Dispatch

Tables

When your application receives an Apple event, use the AEProcessAppleEvent function to
retrieve the data buffer of the event and to route the Apple event to the appropriate Apple
event handler in your application. Your application supplies an Apple event dispatch table to
provide a mapping between the Apple events your application supports and the Apple event
handlers provided by your application.
To install entries into your application’s Apple event dispatch table, use the
AEInstallEventHandler function. You usually install entries for all of the Apple events
that your application accepts into your application’s Apple event dispatch table.
For each Apple event your application supports, you should install entries in your Apple
event dispatch table that specify
m the event class of the Apple event
m the event ID of the Apple event
m the address of the Apple event handler for the Apple event
m areference constant
You provide this information to the AEInstallEventHandler function. In addition, you indicate
to the AEInstallEventHandler function whether the entry should be added to your application’s
Apple event dispatch table or the system Apple event dispatch table.
The system Apple event dispatch table is a table in the system heap that contains
handlers that are available to all applications and processes running on the same computer.
The handlers in your application’s Apple event dispatch table are available only to your application. If AEProcessAppleEvent cannot find a handler for the Apple event in your application’s
Apple event dispatch table, it looks in the system Apple event dispatch table for a handler. If it
doesn’t find a handler there either, it returns the errAEEventNotHandled result code.
Listing 6-3 illustrates how to add entries for the required Apple events to your application’s
Apple event dispatch table.
Listing 6-3. Inserting entries for required Apple events into an application’s
Apple event dispatch table
myErr

:=

AEInstallEventHandler

(kCoreEventClass,

kAEOpenApplication,

IF myErr
myErr
:=

@MyHandleOAPP,
0,
FALSE);
<> noErr THEN DoError(myErr);
AEInstallEventHandler
(kCoreEventClass,
kAEOpenDocuments,

IF

<>

myErr

myErr
IF

myErr

myErr
IF

6-28

:=

:=

myErr

noErr

THEN

DoError

AEInstallEventHandler
<>

noErr

THEN

DoError

AEInstallEventHandler
<>

noErr

THEN

DoError

@MyHandleODOC,
(myErr) ;

0,

(kCoreEventClass,
@MyHandlePDOC,
(myErr) ;

kAEPrintDocuments,
0,

(kCoreEventClass,
@MyHandleQUIT,
(myErr) ;

Using the Apple Event Manager

FALSE);

FALSE);
kAEQuitApplication,

0,

FALSE);

The Apple Event Manager

The code in Listing 6-3 creates an entry for all required Apple events in the Apple event
dispatch table. The first entry creates an entry for the Open Application event. The entry
indicates the event class and event ID of the Open Application event and the address of the
handler for that event and specifies 0 as the reference constant. This entry is installed into
the application’s Apple event dispatch table.
The reference constant is passed to your handler by the Apple Event Manager each time your
handler is called. Your application can use this reference constant for any purpose. If your
application doesn’t use the reference constant, use 0 as the value.
The last parameter to the AEInstallEventHandler function is a Boolean value that determines
whether the entry is added to the system Apple event dispatch table or to your application’s
Apple event dispatch table. To add the entry to your application’s dispatch table, use FALSE
as the value of this parameter. If you specify TRUE, the entry is added to the system’s Apple
event dispatch table.
If you add a handler to the system Apple event dispatch table, the handler that you specify
must reside in the system heap. If there was already an entry in the system Apple event

dispatch table for the same event class and event ID, it is replaced. Therefore, if there is an

entry in the system Apple event dispatch table for the same event class and event ID, you
should chain it to your system handler as explained in “Creating and Managing the Apple
Event Dispatch Tables” later in this chapter.
Note: When an application calls a system Apple event handler, the A5 register is
set up for the calling application. For this reason, if you provide a system Apple
event handler, it should never use A5 global variables or anything that depends on a
particular context; otherwise, the application that calls the system handler may crash.

For any entry in your Apple event dispatch table, you can specify a wildcard value for the
event class, event ID, or both. You specify a wildcard by supplying the typeWildCard
constant when installing an entry into the Apple event dispatch table. A wildcard value
matches all possible values.
For example, if you specify an entry with the typeWildCard event class and the
kAEOpenDocuments event ID, the Apple Event Manager dispatches Apple events of
any event class and an event ID of kAEOpenDocuments to the handler for that entry.
If you specify an entry with the kCoreEventClass event class and the typeWildCard event ID,
the Apple Event Manager dispatches Apple events of the kCoreEventClass event class and
any event ID to the handler for that entry.
If you specify an entry with the typeWildCard event class and the typeWildCard event ID, the
Apple Event Manager dispatches all Apple events of any event class and any event ID to the
handler for that entry.
If the AEProcessAppleEvent function cannot find a handler for an Apple event in either the
application’s Apple event dispatch table or the system Apple event dispatch table, it returns
the result code errAEEventNotHandled to the Apple event server. If the client is waiting for a
reply, AESend also returns this result code as its function result.

“

S

=@

&
<

@

i)—_

<2
—
oo

=

2
ge
@

Using the Apple Event Manager

6-29

Inside Macintosh, Volume VI

If your application supports the Edition Manager, you should also add entries to your application’s Apple event dispatch table for the Apple events that your application receives from
the Edition Manager. Listing 6-4 shows how to add entries for these Apple events to your
application’s Apple event dispatch table.
Listing 6-4. Inserting entries for Apple events sent by the Edition Manager into an
application’s Apple event dispatch table
myErr

:=

AEInstallEventHandler(sectionEventMsgClass,

sectionReadMsgID,

@MyHandleSectionReadEvent,
IF

myErr

myErr

:=

<>

noErr

THEN

DoError

(myErr)

0,

FALSE);

;

AEInstallEventHandler(sectionEventMsgClass,
sectionWriteMsgID,
@MyHandleSectionWriteEvent,

IF

myErr

myErr

<>

:=

noErr

THEN

DoError

AEInstallEventHandler

(myErr)

myErr

<>

noErr

THEN

DoError

FALSE);

(sectionEventMsgClass,
sectionScrollMsgID,
@MyHandleSectionScrollEvent,

IF

0,

;

(myErr)

0,

FALSE);

;

See “Handling Apple Events Sent by the Edition Manager” later in this chapter for the
parameters associated with these events. See the Edition Manager chapter in this volume
for information on how your application should respond to the Apple events sent by the
Edition Manager.

Handling

the Required

Apple

Events

This section describes the required Apple events—the Apple events your application must
support to be 7.0-friendly—and the descriptor types for all parameters of the required
Apple events. It also describes how to write the handlers for these events, and it provides
sample code.
To support the required Apple events, you must set the necessary flags in the 'SIZE' resource
of your application, install entries into your application’s Apple event dispatch table, add
code to the event loop of your application to recognize high-level events, and call the
AEProcessAppleEvent function, as described in the preceding two sections. You must also
write handlers to handle each Apple event; this section describes how to write these handlers.

Required

Apple

Events

When a user opens or prints a file from the Finder, the Finder sets up the information your
application can use to determine which files to open or print. In version 7.0, if your application supports high-level events, the Finder communicates this information to your application
through the required Apple events.
The Finder sends one of the required Apple events to your application to request that it open
or print a list of documents, inform it that the Finder has just opened your application, or
inform it that the Finder is about to terminate your application.

6-30

Using the Apple Event Manager

The Apple Event Manager
These are the required Apple events.
Apple event

Requested action

Open Application

Perform tasks associated with opening your application

Open Documents

Open the specified documents

Print Documents

Print the specified documents

Quit Application

Perform tasks—such as releasing memory, requesting the user to
save documents, and so on—associated with quitting; when appropriate, the Finder sends this event to an application immediately
after sending it a Print Documents event or if the user chooses
Restart or Shut Down from the Finder’s Special menu

The Finder uses the required Apple events as part of the new mechanisms in system software
version 7.0 for launching and terminating applications. This new method of communicating
Finder information to your application replaces the mechanisms used in earlier versions of
system software.
Applications that do not support high-level events can still use the CountAppFiles, GetAppFiles,
and ClrAppFiles procedures (or the GetAppParms procedure) to get the Finder information. See
the Segment Loader chapter of Volume II for information on these routines. To make your
application 7.0-friendly and compatible with earlier versions of system software, it must support
both the old and new mechanisms.
Use the Gestalt function to determine whether the Apple Event Manager is present. If it is and
the isHighLevelEventAware flag is set in your application’s 'SIZE' resource, your application receives the Finder information through the required Apple events.
If your application accepts high-level events, the Finder sends it an Open Application, Open
Documents, or Print Documents event immediately after launching your application. Upon
receiving any of these events, your application should perform the action requested by
the event.

Note: This section describes the required Apple events as they are sent by the
Finder. When sent by other applications or processes, these same Apple events—
which are among the core Apple events described in the Apple Event Registry—can
include optional parameters not listed here. To be 7.0-friendly, your application only
needs to handle the required parameters that are described in this section.
“N

Open Application—perform tasks associated with opening an application

~

=)
>)
—

—

_—

Event class

kCoreEventClass

Event ID

kAEOpenApplication

Parameters

None

Requested action

Perform any tasks—such as opening an untitled document window—
that you would normally perform when a user opens your application.

<")

3)
<
@
—

—

—
a
Cae

Using the Apple Event Manager

6-31

£9
—

ed

$9
So]
@

“

Inside Macintosh,

Volume

V1

Open Documents—open

the specified documents

Event class

kCoreEventClass

Event ID

kAEOpenDocuments

Required parameter
Keyword:
Descriptor type:
Data:

keyDirectObject
typeAEList
A list of alias records for the documents to be opened

Requested action

Open the documents specified in the keyDirectObject parameter.

Print

Documents—print

the specified

Event class

kCoreEventClass

Event ID

kAEPrintDocuments

documents

Required parameter
Keyword:
keyDirectObject
Descriptor type: — typeAEList
Data:
A list of alias records for the documents to be printed
Requested action

Quit

Print the documents specified in the keyDirectObject parameter without
opening windows for the documents.

Application—perform

tasks

associated

with

quitting

Event class

kCoreEventClass

Event ID

kAEQuitApplication

Parameters

None

Requested action

Perform any tasks that your application would normally perform when
the user chooses Quit. Such tasks typically include asking the user if
he or she wants to save documents that have been changed. When
appropriate, the Finder sends this event to an application immediately
after sending it a Print Documents event or if the user chooses Restart
or Shut Down from the Finder’s Special menu.

Your application needs to recognize only two descriptor types to handle the required Apple
events: descriptor lists and alias records. The Open Documents event and Print Documents
event use descriptor lists to store a list of documents to open. Each document is specified as
an alias record in the descriptor list.
You can retrieve the data that specifies the document to open as an alias record, or you can
request that the Apple Event Manager coerce the alias record to a file system specification
(FSSpec) record. The file system specification record provides a standard method of
identifying files in version 7.0. See the File Manager chapter in this volume for a complete
description of how to specify files using file system specification records.

6-32

Using the Apple Event Manager

The Apple Event Manager

Handling

the Open

Application

Event

When the user opens your application, the Finder uses the Process Manager to launch your
application. On startup, your application typically performs any needed initialization, and then
begins to process events. If your application supports high-level events, your application
receives the Open Application event.
To handle the Open Application event, your application should do just what the user expects
it to do when your application is opened. For example, your application might open a new
untitled window in response to an Open Application event.
Listing 6-5 shows a handler that processes the Open Application event. The Open Application
event does not have any required parameters. This handler first calls an application-defined
function called MyGotRequiredParams. This function checks to see if the Apple event contains any required parameters. By definition, the Open Application event should not contain
any required parameters so, if the Apple event does contain any, the handler returns an error.
Otherwise the handler opens a new document window.
Listing 6-5. A handler for the Open Application event
FUNCTION

MyHandleOApp

(theAppleEvent,reply:
handlerRefcon:

AppleEvent;

LongInt)

:

OSErr;

VAR

myErr:

OSErr;

BEGIN

myErr
IF

:=

myErr

MyGotRequiredParams
<>

noErr

MyHandleOApp

(theAppleEvent) ;

THEN

:=

myErr

:=

noErr;

ELSE
BEGIN
DoNew;

MyHandleOApp
END;
END;

The MyGotRequiredParams function checks that all required parameters have been extracted
from the Apple event. See Listing 6-11 in “Writing Apple Event Handlers” later in this chapter
for a description of the MyGotRequiredParams function.

Handling

the Open

Documents

Event

To handle the Open Documents event, your application should open the documents specified
in the Apple event. The Open Documents event contains a list of documents to open in its
direct parameter. Your application extracts this information and then opens the specified
documents.
Listing 6-6 shows a handler for the Open Documents event. The handler illustrates how to
open the documents referred to in the direct parameter.

N
>

~
—

~~

—

o@

ics)
<
7)
—

ae

—<
a
pee
as
oe

|
1
ve
ie)
=“

Using the Apple Event Manager

6-33

Inside Macintosh,

Volume VI

Listing 6-6. A handler for the Open Documents event
FUNCTION
VAR

MyHandleODoc

(theAppleEvent,reply:
AppleEvent;
handlerRefcon:
LongiInt)
: OSErr;

myFSS:
docList:
myErr:
index,
itemsInList:
actualSize:
keywad:
returnedType:

BEGIN

{get

myErr
IF

the

:=

myErr

{check

direct

FSSpec;
AEDescList;
OSErr;
LongInt;
Size;
AEKeyword;
DescType;

parameter--a

descriptor

AEGetParamDesc(theAppleEvent,
docList);
<> noErr THEN DoError (myErr) ;

for

missing

required

list--and

put

keyDirectObject,

END;

the

myErr

:=

{now

get

{ data
to
FOR index

number

of

descriptor

AECountItems

(docList,

each

descriptor

an
:=

into

docList}

typeAEList,

parameters}

myErr
:= MyGotRequiredParams (theAppleEvent) ;
IF myErr
<> noErr THEN
{an error
occurred}
BEGIN
{do the necessary
error
MyHandleODoc
:= myErr;
Exit
(MyHandleODoc) ;

{count

it

record

records

in

the

itemsInList);

handling}

list}

from

the

list,

FSSpec
record,
and open
1 TO itemsInList
DO

the

associated

coerce

the

returned

}

file}

BEGIN

myErr

myErr

AEGetNthPtr(docList,
index,
typeFSS,
keywd,
returnedType,
@myFSS,
Sizeof(myFSS),
actualSize);
<> noErr THEN DoError (myErr) ;

IF

myErr

IF

myErr

:=

AEDisposeDesc(docList) ;

myErr
END;

:=

MyHandleODoc

:= MyOpenFile(@myFSS) ;
<>

:=

noErr

THEN

DoError

(myErr);

noErr;

END;

The handler in Listing 6-6 first uses the AEGetParamDesc function to get the direct parameter
(specified by the keyDirectObject keyword) out of the Apple event. The handler requests
that AEGetParamDesc return a descriptor list in the docList variable. The handler then
checks to make sure that it has retrieved all of the required parameters by calling the
MyGotRequiredParams function (see Listing 6-11 for a description of this routine).

Once the handler has retrieved the descriptor list from the Apple event, it uses AECountItems
to count the number of descriptors in the list. Using the returned number as an index, the
handler can get the data of each descriptor record in the list. This handler requests that the
AEGetNthPtr function coerce the data in the descriptor record to a file system specification
record. The handler can then use the file system specification record as a parameter to its
own routine for opening files.
For more information on the AEGetParamDesc function, see “Getting Data out of a Parameter’
later in this chapter. Also see “Getting Data out of a Descriptor List” for further information on
the AEGetNthPtr and AECountltems functions.
6-34

Using the Apple Event Manager

?

The Apple Event Manager

After extracting the file system specification record that describes the document to open, your
application can use this record to open the file. For example, in Listing 6-6, the code passes
the file system specification record to its routine for opening files, the MyOpenFile function.
The MyOpenFile function is designed so that it can be called both in response to the Open
Documents event and to events generated by the user. For example, when the user chooses
Open from the File menu, the code that handles the mouse-down event uses the StandardGetFile
procedure to let the user choose a file; it then calls MyOpenFile, passing the file system specification record returned by StandardGetFile. By isolating code that performs a requested action
from code that interacts with the user, you can easily adapt your application to handle Apple
events that request the same action.
Note that your handler should use the AEDisposeDesc function to dispose of the descriptor
list when your handler no longer requires the data in it. Your handler should also return a
result code.

Handling the Print Documents

Event

To handle the Print Documents event, your application should print the documents specified
in the Apple event. The Print Documents event contains a list of documents to print in its
direct parameter. Your application extracts this information and then prints the specified
documents. Your application should not open any windows for the documents. Also note
that your application should remain open after processing the Print Documents event; when
appropriate, the Finder sends your application a Quit Application event immediately after
sending it a Print Documents event.
Listing 6-7 shows a handler for the Print Documents event. This handler is similar to the
handler for the Open Documents event. The code illustrates how to print the documents
referred to in the direct parameter.
Listing 6-7. A handler for the Print Documents event
FUNCTION

MyHandlePDoc

(theAppleEvent,reply:
AppleEvent;
handlerRefcon:
LongInt)
: OSErr;

VAR

myFSS:

FSSpec;

docList:

myErr:
index,

AEDescList;
OSErr;
LongInt;

itemsInList:

actualSize:

Size;

keywad:
returnedType:

AEKeyword;
DescType;

BEGIN

{get
the
myErr
:=

direct
parameter--a
descriptor
list--and
put
it into docList}
AEGetParamDesc(theAppleEvent,
keyDirectObject,
typeAEList,
docList);
<> noErr THEN DoError (myErr) ;
IF myErr
{check
for missing
required parameters}
myErr
:= MyGotRequiredParams (theAppleEvent) ;
IF myErr
<> noErr THEN
{an error
occurred}
BEGIN

{do

the

necessary

MyHandlePDoc

:=

error

a
>
c
~
S
©
=

handling}

=

myErr;

L

Exit (MyHandlePDoc) ;

(Continued)

END;

Using the Apple Event Manager

6-35

fe
©

Inside Macintosh,

Volume VI

Listing 6-7. A handler for the Print Documents event (Continued)
{count

myErr

the

:=

{now

get

FOR

index

{

data

number

of

descriptor

AECountItems

to

each

BEGIN

myErr

FSSpec

:=

1

:=

IF

myErr

IF

myErr

myErr

descriptor

an

TO

records

(docList,

record

record,

from

and

itemsInList

print

the

list}

the

the

list,

coerce

associated

the

file}

returned

}

DO

AEGetNthPtr(docList,

:=

in

itemsInList) ;

@myFSS,

<>

noErr

THEN

DoError

<>

noErr

THEN

DoError

index,

typeFSS,

(myErr)

;

(myErr)

;

Sizeof(myFSS),

MyPrintFile(@myFSS) ;

keywd,

returnedType,

actualSize) ;

END;

END;

myErr
:= AEDisposeDesc(docList);
MyHandlePDoc
:= noErr;

Handling the Quit Application

Event

To handle the Quit Application event, your application should take any actions that are
necessary before it is terminated (such as saving any open documents). Listing 6-8 shows
an example of a handler for the Quit Application event.
When appropriate, the Finder sends your application a Quit Application event immediately
after a Print Documents event. The Finder also sends your application a Quit Application
event if the user chooses Restart or Shut Down from the Finder’s Special menu.
Listing 6-8. A handler for the Quit Application event
FUNCTION

MyHandleQuit

(theAppleEvent,reply:
handlerRefcon:

AppleEvent;

LongInt)

:

OSErr;

VAR

userCanceled:
myErr:
BEGIN
{check

for

myErr

:=

IF

myErr

Boolean;
OSEYY;

missing

required

parameters}

MyGotRequiredParams
<>

noErr

THEN

{an

(theAppleEvent)
error

;

occurred}

BEGIN
{do

the

necessary

MyHandleQuit

Exit

:=

error

handling}

myErr;

(MyHandleQuit) ;

END;

userCanceled
:=
IF userCanceled

MyPrepareToTerminate;
THEN

MyHandleQuit
ELSE

:=

userCanceledErr

MyHandleQuit

:=

noErr;

END;

The handler in Listing 6-8 calls another function supplied by the application, the
MyPrepareToTerminate function. This function saves the documents for any open windows
and returns a Boolean value that indicates whether the Quit request was canceled by the user.
6-36

Using the Apple Event Manager

The Apple Event Manager

This is another example of isolating code for interacting with the user from the code that
performs the requested action. Structuring your application in this way allows your application to use the same routine when responding to a user event (such as choosing the Quit
command from the File menu) or to the corresponding Apple event. (For a description of the
MyGotRequiredParams function, see “Writing Apple Event Handlers” later in this chapter.)
Note that your handler must not call the ExitToShell procedure. In Listing 6-8, the application
calls the ExitToShell procedure only if the handler returns noErr as its function result.

Handling

Apple

Events

Sent

by the

Edition

Manager

If your application provides publish and subscribe capabilities, it should handle the Apple
events sent by the Edition Manager in addition to the required Apple events. Your application
should also handle the Create Publisher event. The Create Publisher event is described in the
next section.
The Edition Manager sends your application Apple events to communicate information about
the publishers and subscribers in your application’s documents. Specifically, the Edition
Manager uses Apple events to notify your application
= when the information in an edition is updated
= when your application needs to write the data from a publisher to an edition
m when your application should locate a particular publisher and scroll the document to
that location
The Apple events sent by the Edition Manager to your application are the Section Read event,
Section Write event, and Section Scroll event.
Section

Read—read

information

into

Event class

SectionEventMsgClass

Event ID

SectionReadMsgID

Required parameter
Keyword:
Descriptor type:
Data:
Requested action
Section

the specified

section

keyDirectObject
typeSectionH
A handle to the section record of the subscriber whose edition
contains updated information
Update the subscriber with the new information from the edition.

Write—write

the specified

section

to an

edition

aN

Event class

SectionEventMsgClass

>

Event ID

SectionWriteMsgID

—

Required parameter
Keyword:
Descriptor type:
Data:

keyDirectObject
typeSectionH
.
A handle to the section record of the publisher

=
=)
2
=

Requested action

Write the publisher’s data to its edition,

a9

.

.

.

;

.

>

wa

Using the Apple Event Manager

ber |

6-37

Inside Macintosh,

Section

Volume VI

Scroll—scroll

the

document

to the

specified

section

Event class

SectionEventMsgClass

Event ID

SectionScrollMsgID

Required parameter
Keyword:
Descriptor type:
Data:

keyDirectObject
typeSectionH
A handle to the section record of the publisher to scroll to

Requested action

Scroll the document to the publisher identified by the specified
section record.

See the Edition Manager chapter in this volume for details on how your application should
respond to these events.

Handling

the Create

Publisher

Event

If your application supports publish and subscribe capabilities, it should also handle the

Create Publisher event.
Create

Publisher—create

a publisher

Event class

kAEMiscStdSuite

Event ID

kAECreatePublisher

Required parameter

None

Optional parameter
Keyword:
Descriptor type:
Data:
Optional parameter
Keyword:
Descriptor type:
Data:

keyDirectObject
— typeObjectSpecifier
The part of the document to publish. If this parameter is omitted,
publish the current selection.
keyAEEditionFileLoc
typeAlias

An alias record that contains the location of the edition container to

create. If this parameter is omitted, use the default edition container.

Requested action

Create a publisher for the specified data using the specified location
for the edition container. If the data isn’t specified, publish the
current selection. If the location of the edition isn’t specified, use
the default location.

When your application receives the Create Publisher event, it should create a publisher by
writing the publisher’s data to an edition. The data of the publisher, and the location and
name of the edition, are defined by the Apple event. If the Create Publisher event includes a
keyDirectObject parameter, then your application should publish the data contained in the
parameter. If the keyDirectObject parameter is missing, then your application should publish
the current selection. If the document doesn’t have a current selection, your handler for the
event should return a nonzero result code.
6-38

Using the Apple Event Manager

The Apple Event Manager

If the Create Publisher event includes a keyAEEditionFileLoc parameter, then your application should use the location and name contained in the parameter as the default location and
name of the edition. If the key AEEditionFileLoc parameter is missing, then your application
should use the default location and name your application normally uses to specify the
edition container.
Listing 6-9 shows a handler for the Create Publisher event. This handler checks for the
keyDirectObject parameter and the keyAEEditionFileLoc parameter. If either of these is not
specified, the handler uses default values. The handler uses the DoNewPublisher function, an
application-defined function, to create the publisher and its edition, create a section record,

and update other data structures associated with the document. See Listing 4-4 in the Edition
Manager chapter for an example of the DoNewPublisher function.
Note that the handler uses the AEInteractWithUser function to determine whether user interaction is allowed. If user interaction is allowed, the handler sets the promptForDialog variable
to TRUE, indicating that the DoNewPublisher function should display the publisher dialog
box. If user interaction is not allowed, the handler sets the promptForDialog variable to
FALSE, and the DoNewPublisher function does not prompt the user for the location or name
of the edition.
Listing 6-9. A handler for the Create Publisher event
FUNCTION

MyHandleCreatePublisherEvent

(theAppleEvent,reply:
AppleEvent;
handlerRefcon:
LongInt)
: OSErr;

VAR

myErr:
returnedType:

OSBry:
DescType;

thePublisherDataDesc:

AEDesc;

actualSize:

Longint;

promptForDialog:

Boolean;

thisDocument :

MyDocumentiInfoPtr;

preview:

Handle;

previewFormat:

Format Type;

defaultLocation:

EditionContainerSpec;

BEGIN

MyGetDocumentPtr(thisDocument) ;
AEGetParamDesc(theAppleEvent,

myErr

:=

CASE

myErr

keyDirectObject,

typeObjectSpecifier,

thePublisherDataDesc) ;

OF

errAEDescNotFound:
BEGIN

{use

the current
selection
as the publisher
and
}
displays
for later when DoNewPublisher
{ set up info
:= MyGetPreviewForSelection(thisDocument) ;
preview
previewFormat
:=
'TEXT';

preview}

2)

>

—

=@

END;

noErr:
{use the
{ (which
{ set up

Sz

publisher

}

as the
parameter
keyDirectObject
and}
variable),
in the thePublisherDataDesc
is returned
preview}
displays
for later when DoNewPublisher
info

data

in

<
a)

|—

=<
Lol
=

=

he

(Continued)

Using the Apple Event Manager

6-39

Ge

a?)
™

Inside Macintosh,

Volume VI

Listing 6-9. A handler for the Create Publisher event (Continued)
MySet

InfoForPreview(thePublisherDataDesc,

thisDocument,

previewFormat) ;

preview,

OTHERWISE

:=

myErr

;

(myErr)

DoError
END;

keyAEEditionFileLoc,

AEGetParamPtr(theAppleEvent,

returnedType,
typeFSS,
@defaultLocation.theFile,
actualSize);
SizeOf(FSSpec),

CASE myErr OF
errAEDescNotFound:

location as the edition container}
default
:= MyGetDefaultEditionSpec(thisDocument,

{use the
myErr

defaultLocation) ;

NOETY:

{the

BEGIN

keyAEEditionFileLoc

parameter

}

location}
a default
contained
art
ation.theP
:= kPartsNotUsed;
defaultLoc
{

defaultLocation.theFileScript

:=

smSystemScript;

END;
OTHERWISE

DoError

(myErr)

;

END;

:=

myErr
IF

myErr

MyGotRequiredParams
<>

(theAppleEvent)

;

THEN

noErr

BEGIN

appropriately}
the error
{handle
:= myErr;
MyHandleCreatePublisherEvent
END;

promptForDialog
myErr

:=

:=

(AEInteractWithUser(kAEDefaultTimeout,

@MyIdleFunction)

DoNewPublisher(thisDocument,

preview,

noErr);

promptForDialog,

previewFormat,

and keyErrorString
{add keyErrorNumber
:= myErr;
MyHandleCreatePublisherEvent

NIL,

=

parameters

defaultLocation) ;
if

desired}

END;

Getting Data out of an Apple Event
The Apple Event Manager stores the parameters and attributes of an Apple event in a format
that is internal to the Apple Event Manager. You use Apple Event Manager functions to
retrieve the data from an Apple event and return it to your application in a format your application can use.
The Apple Event Manager provides functions that retrieve data from parameters and attributes.
Most of these functions are available in two forms: one that returns the desired data in a
specified buffer and one that returns a descriptor record containing the same data. For
example, the AEGetParamPtr function returns the data of a specified parameter, and the
AEGetParamDesc function returns the descriptor record of a specified parameter.
6-40

Using the Apple Event Manager

The Apple Event Manager

You can also use Apple Event Manager functions to get data out of descriptor records,
descriptor lists, and AE records. You use similar functions to put data into descriptor
records, descriptor lists, and AE records.
When your handler receives an Apple event, you'll typically use the AEGetParamPtr,
AEGetAttributePtr, AEGetParamDesc, or AEGetAttributeDesc function to get the data
out of the Apple event.
Some Apple Event Manager functions let your application request that the data be returned
using any descriptor type, even if it is different from the original descriptor type. If the
original data is of a different descriptor type, the Apple Event Manager attempts to coerce the
data to the requested descriptor type.
For example, the AEGetParamPtr function lets you specify the desired descriptor type of the
resulting data.
VAR
theAppleEvent:
returnedType:

AppleEvent;
DescType;

multResult:
actualSize:

Longint;
Size;

myErr:

QOSBrxr;

myErr

:=

AEGetParamPtr(theAppleEvent,
returnedType,

keyMultResult,
@multResult,

typeLongInteger,

SizeOf(multResult),

actualSize) ;

In this example, the desired type is specified in the third parameter by the typeLongInteger
descriptor type. This requests that the Apple Event Manager coerce the data to the type
defined by this descriptor type (a long integer) if it is not already of this type.
To ensure that no coercion is performed and that the descriptor type of the result is of the
same type as the original, you can specify typeWildCard for the desired descriptor type.
The Apple Event Manager returns the descriptor type of the resulting data in the fourth
parameter. This is useful information when you specify typeWildCard as the desired
descriptor type; you can determine the descriptor type of the resulting data by examining
the fourth parameter.
The Apple Event Manager can coerce many different types of data into another. For
example, the Apple Event Manager can convert alias records to file system specification
records, integers to Boolean data types, and characters to numeric data types, in addition
to other data type conversions.
N

You can also provide your own coercion handlers to coerce other data types. See “Writing
and Installing Coercion Handlers” later in this chapter for information on the coercion
provided by the Apple Event Manager and how to provide your own coercion handlers.

ta

)

rae

=

ba)
Loan!

e“

Parameters are keyword-specified descriptor records. You can use AEGetParamDesc to get
the descriptor record of a parameter, or you can use AEGetParamPtr to get the data out of the
descriptor record of a parameter. Attributes are also keyword-specified descriptor records,
and you can use similar routines to get the descriptor record of an attribute or to get the data
out of an attribute.
Using the Apple Event Manager

6-4]

<

@

=

-_

=<
—

iy

=

ms

ge
®
™

Inside Macintosh,

Volume VI

The following sections show examples of how to use the AEGetParamPtr, AEGetAttributePtr,
AEGetParamDesc, or AEGetAttributeDesc function to get the data out of an Apple event.

Getting

Data out of a Parameter

You can use the AEGetParamPtr or AEGetParamDesc function to get the data out of a parameter. Use the AEGetParamPtr function to return the data contained in a parameter. Use the
AEGetParamDesc function when you need to get the descriptor record of a parameter. You
often use the AEGetParamDesc function to extract the descriptor list from a parameter.
You can also use the AEGetKeyPtr function to return the data contained in a parameter. The
AEGetKeyPtr function provides an additional feature—you can use this function to get data
out of an AE record. See “Getting Data and Keyword-Specified Descriptor Records From AE
Records” later in this chapter for information on this function.
For example, you use an Apple Event Manager function to get the data out of a Section Read
event. The Edition Manager sends your application a Section Read event to tell your application to read updated information from an edition into the specified subscriber. The direct
parameter of the Apple event contains a handle to the section record of the subscriber. You
can use the AEGetParamPtr function to get the data out of the Apple event.
You specify the Apple event that contains the desired parameter, the keyword of the desired
parameter, the descriptor type the function should use to return the data, a buffer to store
the data, and the size of this buffer as parameters to the AEGetParamPtr function. The
AEGetParamPtr function returns the descriptor type of the resulting data and the actual size

of the data, and it places the requested data in the specified buffer.
VAR

sectionH:
theAppleEvent:

SectionHandle;
AppleEvent;

returnedType:
actualSize:

DescType;
Size;

myErr:

OSErr;

myErr

:=

AEGetParamPtr(theAppleEvent,
returnedType,

keyDirectObject,
@sectionH,

typeSectionH,

SizeOf(sectionH),

actualSize);

In this example, the keyDirectObject keyword specifies that the AEGetParamPtr function
should extract information from the direct parameter; AEGetParamPtr returns the data in the
buffer specified by the sectionH variable.
You can request that the Apple Event Manager return the data using the descriptor type of the
original data or you can request that the Apple Event Manager coerce the data into a descriptor
type that is different from the original. You can specify the desired descriptor type as
typeWildCard if you don’t want any coercion performed—in which case, the AEGetParamPtr
function returns the original descriptor type of the parameter.
The typeSectionH descriptor type specifies that the returned data should be coerced to a

handle to a section record. You can use the information returned in the sectionH variable to

identify the subscriber and read in the information from the edition.

6-42

Using the Apple Event Manager

The Apple Event Manager

In this example, the AEGetParamPtr function returns in the returnedType variable the descriptor type of the resulting data. In most cases, the descriptor type of the resulting data matches
the requested descriptor type, unless the Apple Event Manager wasn’t able to coerce the data
to the specified descriptor type. If the coercion fails, the Apple Event Manager returns the
errAECoercionFail result code.
The AEGetParamPtr function returns the actual size of the data in the actualSize variable.
If the value returned in the actualSize variable is greater than the amount your application
allocated for the buffer to hold the returned data, your application can increase the size
of its buffer to this amount, and get the data again. You can also choose to use the
AEGetParamDesc function when your application doesn’t know the size of the data.
You can use the AEGetParamDesc function to return the descriptor record of a parameter.
This function is useful, for example, when extracting descriptor lists from a parameter.
You specify the Apple event that contains the desired parameter, the keyword of the desired
parameter, the descriptor type the function should use to return the descriptor record, and a
buffer to store the returned descriptor record as parameters to the AEGetParamDesc function.
The AEGetParamDesc function returns the descriptor record using the specified descriptor type.
For example, the direct parameter of the Open Documents event contains a descriptor list that
specifies the documents to open. You can use the AEGetParamDesc function to get the
descriptor list out of the direct parameter.
VAR
docList:

AEDescList;

theAppleEvent:

AppleEvent;

myErr:

OSErr;

myErr

:=

AEGetParamDesc(theAppleEvent,

keyDirectObject,

typeAEList,

GocList) ;

In this example, the Apple event specified by the variable theAppleEvent contains the desired
parameter. The keyDirectObject keyword specifies that the AEGetParamDesc function
should get the descriptor record of the direct parameter. The typeAEList descriptor type
specifies that the descriptor record should be returned as a descriptor list. In this example,
the AEGetParamDesc function returns a descriptor list in the docList variable.
The descriptor list contains a list of descriptor records. To get the descriptor records and their
data out of a descriptor list, use the AECountItems function to find the number of descriptor
records in the list, and then make repetitive calls to the AEGetNthPtr function to get the data
out of each descriptor record. See “Getting Data out of a Descriptor List” later in this chapter
for more information.
>)

Note that the AEGetParamDesc function copies the descriptor record from the parameter.
When you’re done with a descriptor record that you obtained from AEGetParamDesc, you
must dispose of it by calling the AEDisposeDesc function.

a=
a
——
—_

sS—
@

Py

@

—
—
—_—

2
—

tw]
=]
~
ge
a)
“i

Using the Apple Event Manager

6-43

Inside Macintosh,

Volume V1

Getting Data out of an Attribute
You can use the AEGetAttributePtr or AEGetAttributeDesc function to get the data out of the
attributes of an Apple event.
You can get the data out of an attribute using the AEGetAttributePtr function. You specify the
Apple event that contains the desired attribute, the keyword of the desired attribute, the
descriptor type the function should use to return the data, a buffer to store the data, and the
size of this buffer as parameters to the AEGetAttributePtr function. The AEGetAttributePtr
function returns the descriptor type of the returned data and the actual size of the data, and it
places the requested data in the specified buffer.
For example, this code gets the data out of the keyEventSourceAttr attribute of an Apple event.
VAR

theApoleEvent:

AppleEvent;

returnedType:

DescType;

sourceOfAE:

Integer;

actualSize:
myErr:

Size;
OSErr;

myErr

:=

AEGetAttributePtr(theAppleEvent,

keyEventSourceAttr,

typeShortInteger,
SizeOf

(sourceOfAE),

returnedType,

@sourceOfAE,

actualSize);

The keyEventSourceAttr keyword specifies the attribute to get the data from. The
typeShortInteger descriptor type specifies that the data should be returned as a short
integer; the returnedType variable contains the actual descriptor type that is returned. You
also must specify a buffer to hold the returned data and specify the size of this buffer.
The AEGetAttributePtr function returns the actual size of the data returned in the actualSize
variable. You can check this value to make sure you got all the data.
As with the AEGetParamPtr function, you can request that AEGetAttributePtr return the data
using the descriptor type of the original data, or you can request that the Apple Event Manager
coerce the data into a descriptor type that is different from the original.
In this example, the AEGetAttributePtr function returns the requested data in the soureeOfAE
variable, and you can determine the source of the Apple event by examining this value.
The next example shows how to use the AEGetAttributePtr function to get data out of the
keyMissedKeywordAttr attribute. After your handler extracts all known parameters from an
Apple event, it should check whether the keyMissedKeywordAttr attribute exists. If it does,
then your handler did not get all of the required parameters.
Note that if AEGetAttributePtr returns the errAEDescNotFound result code, then the
keyMissedKeywordAttribute does not exist—which indicates that your application has
extracted all of the required parameters. If AEGetAttributePtr returns noErr, then the
keyMissedKeywordAttribute does exist—which indicates that your handler did not get
all of the required parameters.

6-44

Using the Apple Event Manager

The Apple Event Manager

myErr

:=

AEGetAttributePtr(theAppleEvent,
typeWildCard,
actualSize) ;

keyMissedKeywordAttr,
returnedType,

NIL,

0,

The data in the keyMissedKeywordAttr attribute contains the first required parameter, if any,
that your handler didn’t retrieve. If you want this data returned, specify a buffer to hold the
data and specify the size of the buffer. Otherwise, as in this example, specify NIL as the
buffer and 0 as the size of the buffer.

Getting Data out of a Descriptor List
You can use the AECountItems function to count the number of items in a descriptor list, and
you can use AEGetNthDesc or AEGetNthPtr to get a descriptor record or its data out of a
descriptor list.
The Open Documents event contains a direct parameter that specifies the list of documents to
open. The list of documents is contained in a descriptor list. After extracting the descriptor list
from the parameter, you can determine the number of items in the list and then extract each
descriptor record from the descriptor list. See Figure 6-6 in “Data Structures Within Apple
Events” earlier in this chapter for a depiction of the Open Documents event.
For example, when your handler receives an Open Documents event, you can use the
AEGetParamDesc function to return the direct parameter as a descriptor list. You can then
use AECountltems to return the number of descriptor records in the list.
VAR

theAppleEvent:

AppleEvent;

docList:

AEDescList;

itemsInList:

Longint;

myErr:

OSErr;

myErr
myErr

:=

AEGetParamDesc(theAppleEvent,

:=

docList) ;
AECountItems(docList,
itemsInList) ;

keyDirectObject,

typeAEList,

The AEGetParamDesc function returns in the docList variable the descriptor list from
the direct parameter of the Open Documents event. You specify this list to the
AECountlItems function.
You specify the descriptor list whose items you want to count in the first parameter to
AECountltems. The Apple Event Manager returns the number of items in the list in the second
parameter. When extracting the descriptor records from a list, you often use the number of
items as a loop index. Here’s an example:

fo 9)
oe
~~
—

FOR

index

:=

1

TO

itemsInList

~

a=)

DO

—

cas)

BEGIN

{for

each

descriptor

record

in

the

list,

get

its

=

<
@

data}

=}

END;

—

2
—
as
~
—
a

&
ge

fe)
“

Using the Apple Event Manager

6-45

Inside Macintosh,

Volume VI

The format of the descriptor records in a descriptor list is private to the Apple Event Manager.
You must use the AEGetNthPtr or AEGetNthDesc function to extract descriptor records from
a descriptor list.
You specify the descriptor list that contains the desired descriptor records and an index as
parameters to the AEGetNthPtr function. The index represents a specific descriptor record
in the descriptor list. AEGetNthPtr returns the data from the descriptor record represented
by the specified index.
You also specify the descriptor type the function should use to return the data, a buffer to
store the data, and the size of this buffer. The AEGetNthPtr function returns the keyword of
the parameter, the descriptor type of the returned data, and the actual size of the data, and it
places the requested data in the specified buffer.
Here’s an example that uses the AEGetNthPtr function to extract an item from the descriptor
list in the direct parameter of the Open Documents event.
myErr

:=

AEGetNthPtr(docList,
@myFSS,

index,

typeFSS,

Sizeof(myFSS),

keywd,

returnedType,

actualSize);

The docList variable specifies the descriptor list from the direct parameter of the Open
Documents event. The index variable specifies the index of the descriptor record to extract.
You can use the typeFSS descriptor type, as in this example, to specify that the data be returned
as a file system specification record. The Apple Event Manager automatically coerces the
original data type of the descriptor record from an alias record to a file system specification
record. The AEGetNthPtr function returns the keyword of the parameter in the keywd variable.
The function returns in the returnedType variable the descriptor type of the resulting data.
You specify a buffer to hold the desired data and the size (in bytes) of the buffer as parameters to the AEGetNthPtr function. In this example, the myFSS variable specifies the buffer.
The function returns the actual size of the data in the actualSize variable. If this size is larger
than the size of the buffer you provided, you know that you didn’t get all of the data for the
descriptor record.
Listing 6-10 shows a more complete example of extracting the items from a descriptor list in
the Open Documents event.
Listing 6-10. Extracting items from a descriptor list
VAR

index:

FOR

Longint;

itemsInList:

LongInt;

docList:
keywc:
returnedType:

AEDescList;
AEKeyword;
DescType;

myFSS:
actualSize:
myErr:

FSSpec;
Size;
OSErr;

index

:=

1

TO

itemsInList

DO

:=

AEGetNthPtr(docList,

BEGIN

myErr

@myFSS,

6-46

Using the Apple Event Manager

index,

typeFSS,

Sizeof(myFSS),

keywd,

returnedType

actualSize);

,

The Apple Event Manager

IF

myErr

myErr
:=
IF myErr

DoError

(myErr)

;

MyOpenFile(@myFSS) ;
<> noErr
THEN DoError

<>

noErr

THEN

(myErr)

;

END;

myErr

:=

AEDisposeDesc(docList);

Writing Apple

Event

Handlers

For each Apple event your application supports, you must provide a function called an Apple
event handler. The AEProcessAppleEvent function calls one of your Apple event handlers
when it processes an Apple event. Your Apple event handlers should perform any action
requested by the Apple event, add parameters to the reply Apple event if appropriate, and
return a result code.
The Apple Event Manager uses dispatch tables to route Apple events to the appropriate Apple
event handler. You must supply an Apple event handler for each entry in your application’s
Apple event dispatch table. Each handler must be a function that uses this syntax:
FUNCTION

MyEventHandler

(theAppleEvent:

AppleEvent;

handlerRefcon:

LongInt)

:

reply:

AppleEvent;

OSErr;

The parameter theAppleEvent is the Apple event to handle. Your handler uses Apple Event
Manager functions to extract any parameters and attributes from the Apple event and then
performs the necessary processing. The reply parameter is the default reply provided by the
Apple Event Manager. (“Replying to an Apple Event” later in this chapter describes how to
add parameters to the default reply.) The handlerRefcon parameter is the reference constant
stored in the Apple event dispatch table entry for the Apple event. Your handler can ignore
this parameter if your application does not use the reference constant.
After extracting all known parameters from the Apple event, every handler should determine
whether the Apple event contains any further required parameters. Your handler can check
that it retrieved all the required parameters by checking to see if the keyMissedKeywordAttr
attribute exists. If the attribute exists, then your handler has not retrieved all the required
parameters. If additional required parameters exist, then your handler should immediately
return an error. If the attribute does not exist, then the Apple event does not contain any more
required parameters.
Listing 6-11 shows a function that checks for a keyMissedKeywordAttr attribute. A handler
calls this function after getting all the parameters it knows about from an Apple event.
Listing 6-11. A function that checks for a keyMissedKeywordAttr attribute
FUNCTION

VAR

MyGotRequiredParams

returnedType:

DescType;

myErr:

OSErY;

actualSize:

BEGIN

myErr

:=

(theAppleEvent:

AppleEvent)

:

OSErr;

a

ee
a3

Size;

AEGetAttributePtr

7

Si
(theAppleEvent,

typeWwildCard,

actualSize)

;

=

keyMissedKeywordAttr,

returnedType,

NIL,

a

0,

=

(Continued)
Using the Apple Event Manager

6-47

Ks

Inside Macintosh,

Volume VI

Listing 6-11. A function that checks for a keyMissedKeywordAttr attribute (Continued)
IF

myErr

=

errAEDescNotFound

THEN

MyGotRequiredParams
:= noErr
ELSE IF myErr
= noErr
THEN
MyGotRequiredParams
ELSE

:=

{you got
all
{ parameters}
{you

errAEEventNotHandled
{the call
to

{
MyGotRequiredParams

:=

missed

the

a

required

required

}

parameter}

AEGetAttributePtr

}

failed)

myErr;

END;

The code in Listing 6-11 uses the AEGetAttributePtr function to get the keyMissedKeywordAttr
attribute. This attribute contains the first required parameter, if any, that your handler didn’t
retrieve. If AEGetAttributePtr returns the errAEDescNotFound result code, the Apple event
doesn’t contain a keyMissedKeywordAttr attribute. If the Apple event doesn’t contain this
attribute, then your handler has extracted all of the required parameters.
If the AEGetAttributePtr function returns noErr as the result code, then the attribute does
exist, meaning that your handler has not extracted all of the required parameters. In this case,
your handler should return an error and not process the Apple event.
The first remaining required parameter is specified by the data of the keyMissedKeywordAttr
attribute. If you want this data returned, specify a buffer to hold the data. Otherwise, specify
NIL as the buffer and 0 as the size of the buffer. If you specify a buffer to hold the data,
you can check the value of the actualSize parameter to see if the data is larger than the buffer
you allocated.

Replying

to an Apple

Event

Your handler routine for a particular Apple event is responsible for performing the action
requested by the Apple event, and can optionally return data in a reply Apple event. The
Apple Event Manager passes a default reply Apple event to your handler. The default reply
Apple event has no parameters when it is passed to your handler. Your handler can add
parameters to the reply Apple event. If the client application requested a reply, the Apple
Event Manager returns the reply Apple event to the client.
The reply Apple event is identified by the kCoreEventClass event class and by the
kAEAnswer event ID.
When your handler finishes processing an Apple event, it returns a result code to
AEProcessAppleEvent. The AEProcessAppleEvent function returns this result code as its
function result. If your handler returns a nonzero result code, the Apple Event Manager
also returns this result code to the client application by putting the result code into a
keyErrorNumber parameter for the reply Apple event. The client can check for the existence
of this parameter to determine whether the handler performed the requested action.
The client application specifies whether it wants a reply Apple event or not by specifying
flags (represented by constants) in the sendMode parameter of the AESend function.

6-48

Using the Apple Event Manager

The Apple Event Manager

If the client specifies the kAEWaitReply flag in the sendMode parameter, the AESend
function does not return until the timeout expires or the server returns a reply. When the
server returns a reply, the reply parameter to AESend contains the reply Apple event that
your handler returned to the AEProcessAppleEvent function.
If the client specified the kAEQueueReply flag, the client receives the reply event in its normal
processing of other events.
If the client specified the kAENoReply flag, your handler may return a reply Apple event to
AEProcessAppleEvent, but this reply is not returned to the client.
Your handler routine should always set its function result to noErr if it successfully handles
the Apple event or to a nonzero result code if an error occurs. The Apple Event Manager automatically adds any nonzero result code that your handler returns to a keyErrorNumber
parameter in the reply Apple event. In addition to returning a result code, your handler can
also return an error string in the keyErrorString parameter of the reply Apple event. Your
handler should provide meaningful text in the keyErrorString parameter, so that the client
can display this string to the user if desired.
Listing 6-12 shows how to add the keyErrorString parameter to the reply Apple event. See
‘Adding Parameters to an Apple Event” later in this chapter for a description of the
AEPutParamPtr function.
Listing 6-12. Adding the keyErrorString parameter to the reply Apple event
FUNCTION

MyHandler

(theAppleEvent:

AppleEvent;

handlerRefcon:

LongInt)

:

reply:

AppleEvent;

OSErr;

VAR

myErr:

OSErr;

ervrStr:

Str255;

BEGIN

{if

an

error

{

function

IF

myErr

occurs

and

noErr

THEN

<>

BEGIN
myErr;

MyHandler

:=

{add

string

error

when

result

handling

error

string

an

Apple

event,

set

the

}

accordingly}

}
Apple Event
code to be returned--the
{result
{ Manager
adds
this
result
code
to the reply
}
{ Apple event
as the keyErrorNumber
parameter}
parameter

to

the

default

reply}

errStr
:=
'Reason why error occurred';
myErr
:= AEPutParamPtr(reply,
keyErrorString,
typeChar,
@errStr[1],
length(errStr));
Exit

(MyHandler) ;

—
>

END;

END;

SS

If your handler needs to return data to the client, it can add parameters to the reply Apple
event. For example, Listing 6-13 shows how a handler for the Multiply event (an imaginary
Apple event that asks the server to multiply two numbers) might return the results of the
multiplication to the client.

3©

fe)
<
©
=
—_~

=g9

=
=
ge

is)
bey

Using the Apple Event Manager

6-49

Inside Macintosh, Volume VI

Listing 6-13. Adding parameters to the reply Apple event
reply:
AppleEvent;
LongInt)
: OSErr;

(theAppleEvent:
handlerRefcon:

MyMultHandler

FUNCTION

AppleEvent;

VAR
myErr:

OSErr;

numberl,number2:

LongInt;

replyResult:

Longint;

actualSize:

Size;

returnedType:

DescType;

BEGIN
{get
{

put

the

numbers

the

to

numbers

multiply

in

the

from

numberl

the
and

parameters
number2

of

{ then perform
the requested multiplication}
myErr
:= MyDoMultiply(theAppleEvent,
numberl,
number2,

{return
IF

myErr

the
=

result
noErr

of

the

multiplication

in

the

the

variables

reply

Apple
and

event;

}

}

replyResult);

Apple

event}

THEN

BEGIN

myErr

:=

AEPutParamPtr(reply,

keyDirectObject,

@replyResult,
MyMultHandler

:=

typeLongInteger,

SizeOf(replyResult));

myErr;

END;

{if
{

an

error

accordingly,

occurs,
as

set

shown

the
in

function

Listing

result

and

error

string

}

6-12}

END;

Disposing of Apple Event Data Structures
Whenever you use Apple Event Manager functions to create a descriptor record, descriptor
list, or Apple event record, the Apple Event Manager allocates memory for these data
structures. Likewise, when you extract a descriptor record by using Apple Event Manager
functions, the Apple Event Manager creates a copy of the descriptor record for you to use.
Whenever you are done using a descriptor record or descriptor list that you have created or

extracted from an Apple event, you must dispose of the descriptor record—and thereby
deallocate the memory it uses—by calling the AEDisposeDesc function.

Also, when you are done using the Apple event specified in the AESend function and

finished with the reply Apple event, you should dispose of their descriptor records using the

AEDisposeDesc function. You should dispose of them even if AESend returns a nonzero
result code.

Once you are done using them, you should dispose of any Apple event data structures created
or returned by these functions:
AECoerceDesc

AEDuplicateDesc

AECreateAppleEvent

AEGetKeyDesc

AECoercePtr

AECreateDesc
AECreateList

6-50

AEGetAttributeDesc

AEGetNthDesc
AEGetParamDesc

Using the Apple Event Manager

The Apple Event Manager

Even if you add a descriptor record to an Apple event (for example, when you create a
descriptor record by calling AECreateDesc and then put a copy of it into a parameter of an
Apple event by calling AEPutParamDesc), you’re still responsible for disposing of the
original descriptor record.
In one case, the Apple Event Manager does take care of disposing of the Apple event data
structures for you: when your handler returns to AEProcessAppleEvent, the Apple Event
Manager disposes of the Apple event and the reply Apple event. Note that your handler is still
responsible for disposing of any Apple event data structures created when extracting data
from the Apple event. The Apple event and reply Apple event that your handler receives are
only copies of the originals. The client application is responsible for disposing of the original
data structures.

Interacting With the User
When your application receives an Apple event, it may need to interact with the user. For
example, your application may need to display a dialog box asking for additional input or
confirmation from the user. You must make sure that your application is in the foreground
before interacting with the user. To do this, use the AEInteractWithUser function before

actually interacting with the user. The AEInteractWithUser function checks the user interaction preferences set by the client application and the server application and, if user interaction
is allowed, brings your application to the front (either directly or by posting a notification
request) if it is not already in the front.
If both the client and server applications allow user interaction, AEInteractWithUser usually
posts a notification request; AEInteractWithUser brings the server to the front after the user
responds to the notification request. The AEInteractWithUser function can also bring the
server application directly to the front—but only when doing so is in accordance with the
principle of user control and if the client allows it.
Both the client and server specify their preferences for user interaction: the client specifies
whether the server should be allowed to interact with the user, and the server specifies when
it will allow user interaction while processing an Apple event.
An application that sends an Apple event indicates its preferences for how the server application should interact with the user by setting various flags in the sendMode parameter to
AESend. The Apple Event Manager translates these flags into the corresponding flags in the
keyInteractLevelAttr attribute of the Apple event, and sets them.
The server application sets its preferences by using the AESetInteractionAllowed function.
This function lets your application specify whether it allows interaction with the user as
a result of receiving an Apple event from itself; from itself and other processes on the
local machine; or from itself, local processes, and processes from another computer on
the network.

oO
—
—_
—

Your application calls the AEInteractWithUser function before interacting with the user. If
AEInteractWithUser returns the noErr result code, then your application is currently in the
front and your application is free to interact with the user. If AEInteractWithUser returns the
errAENoUserInteraction result code, then the conditions didn’t allow user interaction and
your application should not interact with the user.

—
@

Ss
<

)

=

on

2
—
x)
=
=
=|
o@
eR

Using the Apple Event Manager

6-51

Inside Macintosh,

Volume VI

The client application sets user interaction preferences by setting flags in the sendMode
parameter to the AESend function. The Apple Event Manager automatically adds the specified
flags to the keyInteractLevelAttr attribute of the Apple event. These flags are represented by
constants and are described here.
Flag

Description

kAENeverlInteract

The server application should never interact with the user in
response to this Apple event. If this flag is set, AEInteractWithUser
does not bring the server application to the foreground (this is the
default when an Apple event is sent to a remote application).

kAECanInteract

The server application can interact with the user in response to
this Apple event—by convention, if the user needs to supply
information to the server. If this flag is set and the server allows
interaction, AEInteractWithUser brings the server application to
the foreground (this is the default when an Apple event is sent to
a local application).

kAEAIwaysInteract

The server application can interact with the user in response to
this Apple event—by convention, even if no information is
needed from the user. If this flag is set and the server allows
interaction, AEInteractWithUser brings the server application to
the foreground. The Apple Event Manager does not distinguish
between this flag and the kAECanInteract flag—distinguishing between them is the responsibility of the server application.

If the client application doesn’t specify any of the user interface flags, the Apple Event
Manager sets either the kAENeverInteract or the kAECanInteract flag in the
keyInteractLevelAttr attribute of the Apple event, depending on the location of the server
application. If the server application is on a remote computer, the Apple Event Manager
sets the kAENeverInteract flag as the default. If the server application is on the local computer,
the Apple Event Manager sets the kAECanInteract flag as the default.
In addition, the client application can set another flag in the sendMode parameter to AESend
to request that the Apple Event Manager immediately bring the server application to the front
(instead of posting a notification request)—if user interaction is allowed and if the user
interface guidelines permit.
Flag

Description

kAECanSwitchLayer

6-52

__ If both the client and server allow interaction and this flag is set,
AEInteractWithUser brings the server directly to the foreground
if adherence to the principle of user control allows. If the action
would be contrary to this principle, AEInteractWithUser uses
the Notification Manager to request that the user bring the server
application to the foreground. If both the client and server allow
interaction and this flag is not set, AEInteractWithUser always
uses the Notification Manager to request that the user bring the
server application to the foreground.

Using the Apple Event Manager

The Apple Event Manager

When a server application calls AEInteractWithUser, the function first checks to see if the
kAENeverInteract flag in the keyInteractLevelAttr attribute of the Apple event is set. (The
Apple Event Manager sets this attribute according to the flags specified in the sendMode
parameter of AESend.) If the kAENeverInteract flag is set, AEInteractWithUser immediately
returns the errAENoUserInteraction result code. If the client specified kAECanInteract or
kAEAIwaysInteract, AEInteractWithUser checks the server’s preferences for user interaction.
The server sets its user interaction preferences by using the AESetInteractionAllowed
function. You use this function to tell the Apple Event Manager the processes for which your
application is willing to interact with the user.
myErr

:=

AESetInteractionAllowed(level) ;

The level parameter is of type AEInteractAllowed.
TYPE

AEInteractAllowed

=

(kAEInteractWithSelf,

kAEInteractWithLocal,

kAEInteractWithAll) ;

You can specify one of these values for the interaction level.
Flag

Description

kAEInteractWithSelf

User interaction with your server application in response to an
Apple event may be allowed only when the client application is
your own application—that is, only when your application is
sending the Apple event to itself.

kAEInteractWithLocal

_ User interaction with your server application in response to an
Apple event may be allowed only if the client application is on
the same computer as your application; this is the default if the
AESetInteractionAllowed function is not used.

kAEInteractWithAll

User interaction with your server application in response to
an Apple event may be allowed for any client application on
any computer.

If the server application does not set the user interaction level, AEInteractWithUser uses

{addy
ceU

If the application sent itself an Apple event (that is, the application is both the client and the
server), AEInteractWithUser always allows user interaction. If the client application is a process on the local machine, and the server set the interaction level to the kAEInteractWithLocal
or kAEInteractWithAll flag, then AEInteractWithUser allows user interaction. If the client is a
process on a remote computer on the network, AEInteractWithUser allows user interaction
only if the server specified the kAEInteractWithAll flag for the interaction level. In all other
cases, AEInteractWithUser does not allow user interaction.

9

kAEInteractWithLocal as the value.

<
<7)

=—

<

—

=

=

ee)

ge
&

Using the Apple Event Manager

6-53

Inside Macintosh, Volume VI

and server's preferWhen AEInteractWithUser allows user interaction (based on the client’s
directly or after
front—either
the
to
application
ences), AEInteractWithUser brings the server
code.
result
noErr
a
returns
the user responds to a notification request—and then
If AEInteractWithUser cannot bring the server application to the front within the specified
timeout value, AEInteractWithUser returns the errAETimeout result code.
Your application may want to provide the user with a method of setting the interaction level.
For example, some users may not want to be interrupted while background processing of an
Apple event occurs, or they may not want to respond to dialog boxes when your application
is handling Apple events sent from another computer.
Listing 6-14 illustrates the use of the AEInteractWithUser function. You call this function
before your application displays a dialog box or otherwise interacts with the user when
processing an Apple event. You specify a timeout value, a pointer to a Notification Manager
record, and the address of an idle function as parameters to AEInteractWithUser.
Listing 6-14. Using the AEInteractWithUser function
myErr
IF

:=

AEInteractWithUser

(kAEDefaultTimeOut,

myErr
<> noErr THEN
{the attempt
to interact
DoError

failed,

do

any

NIL,

error

@MyIdleFunction) ;

handling}

(myErr)

ELSE
{interact

{

or

by

with

the

user

by

interacting

in

any

displaying

a

other

that

way

dialog

is

box

}

necessary}

DisplayMyDialogBox;

You can set a timeout value, in ticks, in the first parameter to AEInteractWithUser. Use the

kAEDefaultTimeout constant if you want the Apple Event Manager to use a default value for
the timeout value. The Apple Event Manager uses a timeout value of about one minute if you
specify this constant. You can also specify the KNoTimeOut constant if your application is
willing to wait an indefinite amount of time for a response from the user. Usually you should
provide a timeout value, so that your application can complete processing of the Apple event
in a reasonable amount of time.
You can provide a pointer to a Notification Manager record in the second parameter, or
you can specify NIL to use the default record provided by AEInteractWithUser. The
AEInteractWithUser function only uses a Notification Manager record when user interaction
is allowed and the kAECanSwitchLayer flag in the keyInteractLevelAttr attribute is not set.
The last parameter to AEInteractWithUser specifies an idle function provided by your application. Your idle function should handle any update events, null events, operating-system
events, or activate events while your application is waiting to be brought to the front. See
“Writing an Idle Function” later in this chapter for more information.

Creating

an Apple

Event

You create an Apple event by using the AECreateAppleEvent function. You specify the event
class and event ID, the target address, the return ID, and the transaction ID to the function. The
AECreateAppleEvent function creates and returns an Apple event with the attributes set as your
6-54

Using the Apple Event Manager

The Apple Event Manager

application requested. You should not directly manipulate the contents of the Apple event;
rather, use Apple Event Manager functions to add additional attributes or parameters to it.
This example creates a Multiply event using the AECreateAppleEvent function. You specify
the event class, the event ID, the address of the server application, a return ID, a transaction
ID, and a buffer to store the returned Apple event as parameters to AECreateAppleEvent.
myErr

:=

AECreateAppleEvent

(kArithmeticClass,

kMultEventID,

targetAddress,
kAutoGenerateReturnID,
kAnyTransactionID,
theAppleEvent) ;

The event class here is identified by the kArithmeticClass constant and specifies that this event
belongs to a specific class of Apple events for arithmetic operations. The event ID specifies the
particular Apple event within the class—in this case, an Apple event to perform multiplication.
You specify the target of the Apple event in the third parameter to AECreateAppleEvent. The
target address can identify an application on the local computer or another computer on the
network. You can specify the address using a target ID record or session ID. For processes on
the local computer, you can also use a process serial number or application signature to specify
the address. See “Specifying a Target Address” later in this chapter for more information.
You specify the return ID of the Apple event in the fourth parameter. The return ID provides a
way to associate this Apple event with the server’s reply. The AECreateAppleEvent function
assigns the specified return ID value to the keyReturnIDAttr attribute of the Apple event. If
a server returns an Apple event in response to this event, the server should use the same
return ID. When you receive an Apple event, you can check the keyReturnIDAttr attribute
to determine whether the event is a response to an outstanding Apple event. You can use the
kAutoGenerateReturnID constant to request that the Apple Event Manager generate a return
ID that is unique to this session for the Apple event.
The fifth parameter specifies the transaction ID attribute of the Apple event. A transaction
refers to a sequence of Apple events that are sent back and forth between the client and server
applications, beginning with the client’s initial request for a service. All Apple events that are
part of one transaction must have the same transaction ID.
You can use a transaction ID to indicate that an Apple event is one of a sequence of Apple
events related to a single transaction. The kAnyTransactionID constant indicates that the
Apple event is not part of a transaction.
The AECreateAppleEvent function creates an Apple event with only the specified attributes
and no parameters. To add parameters or additional attributes, use other Apple Event
Manager functions.

Adding

Parameters

to an Apple

Event

‘ew

\

>.
»

—

You can use the AEPutParamPtr or AEPutParamDesc function to add parameters to an Apple
event. When you use either of these functions, the Apple Event Manager adds the specified
parameter to the Apple event.

4

omen

ed

—

@

—
~

<

oO
—
a

oad

Use the AEPutParamPtr function when you want to add data specified in a buffer as the
parameter of an Apple event. You specify the Apple event, the keyword of the parameter to
add, the descriptor type, a buffer that contains the data, and the size of this buffer as paramUsing the Apple Event Manager

6-55

a
—

=)
~
—
As
~

ge
~

@

—

;

Inside Macintosh,

Volume VI

eters to the AEPutParamPtr function. The AEPutParamPtr function creates the descriptor
record and adds the parameter to the Apple event.
For example, this code adds a parameter to the Multiply event using the AEPutParamPtr
function.
CONST

keyOperandl

=

'OPNI1';

VAR

numberl1:
theAppleEvent:

LongInt;
AppleEvent;

myErr:

OSErr;

numberl
myErr
:=

:= 10;
AEPutParamPtr(theAppleEvent,
@numberl,

keyOperandl,

typeLongiInteger,

SizeOf(numberl1));

In this example, the Apple Event Manager adds the parameter containing the first number to
the specified Apple event.
Use the AEPutParamDesc function to add data specified in a descriptor record to an Apple
event. The descriptor record you specify must have been previously created using the
AECreateDese or AEDuplicateDesc function.
You specify the descriptor type, a buffer that contains the data, and the size of this buffer as
parameters to the AECreateDesc function. The AECreateDesc function returns the descriptor
record that describes the data.
This example creates a descriptor record for the second parameter of the Multiply event:
VAR

number2:

LongIint;

multParam2Desc:

AEDesc;

myErr:

OSETr;

number2
myErr

:=
:=

8;

AECreateDesc(typeLongInteger,

@number2,

SizeOf

(number2),

multParam2Desc);

In this example, the AECreateDesc function creates a descriptor record with the typeLongInteger
descriptor type and the data identified in the number? variable.
Once you have created a descriptor record, you can use AEPutParamDesc to add the data to
a parameter of an Apple event. You specify the Apple event to add the parameter to, the
keyword of the parameter, and the descriptor record of the parameter as parameters to the
AEPutParamDesc function.
This example adds a second parameter to the Multiply event using the AEPutParamDesc
function.
CONST

keyOperand2

myErr

:=

6-56

=

'OPN2';

AEPutParamDesc(theAppleEvent,

Using the Apple Event Manager

keyOperand2,

multParam2Desc) ;

The Apple Event Manager

This example adds the keyOperand2 keyword and the descriptor record created in the
previous example as the second parameter to the specified Apple event.
The previous examples showed how to add parameters to the imaginary Multiply event. After
adding parameters to an Apple event, you can send the Apple event using the AESend function.
See “Sending an Apple Event” later in this chapter for information on using this function.

Specifying

a Target Address

When you create an Apple event, you must specify the address of the target. The target
address identifies the particular application or process that you want to send the Apple event
to. You can send Apple events to applications on the local machine or on remote computers
on the network.
These are the descriptor types that identify the four methods of addressing an Apple event.
typeApplSignature
typeSessionID
typeTargetID
typeProcessSerialNumber

The application signature of the target
The session ID of the target
The target ID record of the target
The process serial number of the target

To address an Apple event to a target on a remote computer on the network, you must use
either the typeSessionID or typeTargetID descriptor type.
If your application sends an Apple event to itself, it should address the Apple event using a
process serial number. Use the kCurrentProcess constant to specify the process serial number
of your application. This is the fastest way for your application to send an Apple event to itself.
You can use any of the four address types when sending an Apple event to another application on the local computer. To allow the user to choose the target of an Apple event, use the
PPCBrowser function. The PPCBrowser function presents a standard user interface for
choosing a target application, much as the Standard File Package provides a standard user
interface for opening and saving files.
The PPCBrowser function returns information about the application the user chose in a target
ID record. (Listing 6-16 later in this section shows how to use the PPCBrowser function to
let the user choose a target.)
The Event Manager chapter in this volume describes all four types of addresses. Your application can also use another address type, if it also provides a coercion handler that coerces the
address type into one of the four address types that the Apple Event Manager recognizes. See
“Writing and Installing Coercion Handlers” later in this chapter for more information.
You specify the address using an address descriptor record (a descriptor record of data type
AEAddressDesc). You must create a descriptor record of this type and then supply the
address descriptor record as a parameter to the AECreateAppleEvent function.
You can use the AECreateDesc function to add any of the four target addresses to an address
descriptor record. Listing 6-15 shows four possible ways to create an address, each using a
different address type.

i 9)

>

i)

feo

S3)
<
i)
=

—

2
—

+s)

=

ey)
tj]

g

Using the Apple Event Manager

6-57

Inside Macintosh, Volume VI

Listing 6-15. Creating a target address
PROCEDURE

targetAddress2,
(VAR targetAddressl,
SetTargetAddresses
targetAddress4:
targetAddress3,
TargetID;
toTargetID:
AEAddressDesc;
ProcessSerialNumber;
thePSN:
OSType;
theSignature:
PPCSessRefNum) ;
theSessionID:

VAR

myErr:
BEGIN
myErr

myErr

OSErr;

:=

AECreateDesc(typeTargetID,
targetAddressl);

@toTargetID,

:= AECreateDesc(typeProcessSerialNumber,

myErr

:=

myErr

:=

SizeOf(toTargetID),

@thePSN,

SizeOf(thePSN),

targetAddress2) ;
AECreateDesc(typeApplSignature,
@theSignature,
SizeOf (theSignature),
targetAddress3) ;
AECreateDesc(typeSessionID,
@theSessionID,
SizeOf(theSessionID),
targetAddress4) ;

END;

You specify the descriptor type for the address, a pointer to the buffer containing the address,
and the size of the buffer to the AECreateDesc function to create an address descriptor record.
The AECreateDesc function returns an address descriptor record with the specified
characteristics.
After creating an address, you can specify the address in the AECreateAppleEvent function.

See “Creating an Apple Event” earlier in this chapter for an example using the
AECreateAppleEvent function.

When you specify an address to the AECreateAppleEvent function, the Apple Event Manager
stores the address in the keyAddressAttr attribute of the Apple event.
You can use the PPCBrowser function to create a target ID record. Listing 6-16 shows how
to use the information returned from the PPCBrowser function to create a target ID record.
You can then use AECreateDesc to create the address descriptor record for an Apple event.
Listing 6-16. Specifying a target address in an Apple event
FUNCTION

GetTargetAddress(myPrompt:
Str255;
myAppStr:
Str255;
VAR myPortInfo:
PortInfoRec;
VAR targetAddress:
AEAddressDesc;
VAR toTargetID:
targetID)
: OSErr;

VAR
myErr:
BEGIN
myErr
IF

OSErr;
{use PPCBrowser
to let user choose
the target}
:= PPCBrowser(myPrompt,
myAppStr,
FALSE,
toTargetID.location,

myPortInfo,

NIL,

myErr
<> noErr THEN
DoError (myErr)
ELSE
BEGIN
toTargetID.name
:= myPortInfo.name;

6-58

Using the Apple Event Manager

'');

The Apple Event Manager

{create
the descriptor
record
for the target
address}
AECreateDesc(typeTargetID,
@toTargetID,
SizeOf(toTargetID),
targetAddress);
myErr <> noErr THEN
DoError (myErr);

myErr
IF

END;

:=

END;
GetTargetAddress

:=

myErr;

See the Program-to-Program Communications Toolbox chapter in this volume for more
information on using the PPCBrowser function.

Sending

an Apple

Event

To send an Apple event, you first create an Apple event, add parameters and attributes to the
Apple event, and then use the AESend function to send it.
When you send an Apple event, you specify various options to indicate how the server should
handle the Apple event. You request a user interaction level from the server and specify
whether the server can directly switch to the foreground if user interaction is needed, whether

your application is willing to wait for a reply Apple event, whether reconnection is allowed,
and whether your application wants a return receipt for the Apple event.

You specify these options in the sendMode parameter to AESend. Here are the constants that
represent these options.
CONST

KAENoReply
kAEQueueReply

=
=

$00000001;
$00000002;

kAEWaitReply

=

$00000003;

kAENeverInteract

=

$00000010;

kAECanInteract

=

$00000020;

kAEAlwaysInteract

=

{client
{client
{ reply

{client
{

$00000040;

kAEDontReconnect

=

$00000080;

kAEWantReceipt

=

a

reply

and

not

interact

with

user

}
}

}

{ for this Apple
event}
{server may interact with
}
for this Apple
event
{ user

{ to supply
{server may

{

{

=

wants

{ will
give up processor}
{server
application
should

$00000030;

kAECanSwitchLayer

doesn't
want
reply}
wants
server
to }
in event
queue}

nReturnReceipt;

user

even

for

if

information}
interact with

this

no

Apple

event

information

5

,

}

}

{ is required}
{server
should come directly
{ to foreground when
}
{ appropriate}
{don't
reconnect
if there
}
{ is a PPC sessClosedErr}
{client
wants
return receipt}

}

If your application wants a reply Apple event, specify the kAEQueueReply or kAEWaitReply
flag. If your application wants to receive the reply Apple event in its event queue, use
kAEQueueReply. If your application wants to receive the reply Apple event in the reply parameter of AESend and is willing to give up the processor while waiting for the reply, use
kAEWaitReply. If your application does not want a reply Apple event and does not need to
wait for the server to handle the Apple event, specify kNoReply.
Using the Apple Event Manager

6-59

~\
>

ae

—

~
~
—
°

—

ic

<
C
=
—)

_"

a

—

+)
i)
a
—

vo

©

—

;

Inside Macintosh, Volume VI

In most cases, your application should use kAEWaitReply or KAENoReply. You should not
use kAEQueueReply if your application is sending an Apple event to itself.
If your application specifies KAENoReply or kAEQueueReply, the AESend function returns
immediately after using the Event Manager to send the event. In this case, a noErr result code
from AESend indicates that the Apple event was successfully sent by the Event Manager; it
does not mean that the server accepted or handled the Apple event.
Also, the reply parameter to AESend does not contain valid data on return from AESend if
your application specifies kAENoReply or kAEQueueReply. The kAENoReply flag indicates
that the Apple Event Manager will not return the reply Apple event to your application. The
kAEQueueReply flag indicates that your application wants to receive the reply in its event
queue rather than through the reply parameter of AESend.
If your application specifies kAEWaitReply, the Apple Event Manager uses the Event
Manager to send the event. The Apple Event Manager then calls the WaitNextEvent function
on behalf of your application, causing your application to yield the processor. This gives the
server application a chance to receive and handle the Apple event. Your application continues
to yield the processor until the server handles the Apple event or the request times out.
You use one of the three flags—kAENeverInteract, kAECanInteract, and kAEAIwaysInteract—
to specify whether the server should interact with the user when handling the Apple event.
Specify kAENeverlnteract if the server should not interact with the user when handling the
Apple event. You might specify this constant if you don’t want the user to be interrupted while
the server is handling the Apple event.
Use the kAECanInteract flag if the server should interact with the user when necessary—for
example, if the user needs to supply information to the server. Use the kAEAlwaysInteract
flag if the server should interact with the user even when no information is needed from the
user. Note that it is the responsibility of the server and client applications to agree on how to
interpret the KAEAI]waysInteract flag.
If the client application does not set any one of the user interaction flags, the Apple Event
Manager sets a default, depending on the location of the target of the Apple event. If the server
application is on a remote computer, the Apple Event Manager sets the kAENeverlnteract flag
as the default. If the target of the Apple event is on the local computer, the Apple Event
Manager sets the KAECanInteract flag as the default.
The server application should call AEInteractWithUser if it needs to interact with the user. If
user interaction is allowed, the Apple Event Manager brings the server to the front if it is not
already the foreground process. If the kAECanSwitchLayer flag is set and the principle of
user control permits, the Apple Event Manager directly brings the server application to the
front. If the action is contrary to the principle of user control, the Apple Event Manager posts
a notification request to inform the user to bring the server application to the front.
You should specify the kKAECanSwitchLayer flag only when the client and server applications
reside on the same computer. In general, you should not set this flag if it would be confusing
or inconvenient to the user for the server application to unexpectedly come to the front.
Specify the kAEDontReconnect flag if the Apple Event Manager should not reconnect if it
receives a session closed error from the PPC Toolbox. If you don’t set this flag, the Apple
Event Manager automatically attempts to reconnect and reestablish the session.

6-60

Using the Apple Event Manager

The Apple Event Manager

Specify the kAEWantReceipt flag if your application wants notification that the server did
not accept the Apple event. If you specify this flag, the AESend function returns the
errAEEventNotHandled result code if the server did not accept the Apple event.
Listing 6-17 illustrates how to send a Multiply event (an imaginary Apple event for multiplying two long integers). It first creates an Apple event, adds parameters containing the
numbers to multiply, then sends it, specifying various options. It also illustrates how to
handle the reply Apple event that contains the result.
Note: If you want to send Apple events, your application must also handle the
required Apple events. See “Handling the Required Apple Events” earlier in this
chapter for information on how to support the required Apple events.
Listing 6-17.
FUNCTION

MySendMultiplyEvent

Sending an Apple event

(serverAddress:
AEAddressDesc;
firstOperand:
LongInt;
secondOperand:
LongIint;
replyResultLongInt:
LongInt)
OSErr;

CONST

kArithmeticClass
kMultiplyEventID

=
=

'ARTH';
'MULT';

{event
{event

class for arithmetic Apple
ID for Multiply event}

keyMultOperand1
keyMultOperand2

=
=

'‘OPN1';
‘'OPN2';

{keyword
{keyword

theAppleEvent:
reply:
returnedType:

AppleEvent;
AppleEvent ;
DescType;

myErr:
errStr:
errNumber:

OSErr;
Str255:
Longint;

for
for

events}

first
parameter}
second parameter}

VAR

actualSize:

LongInt;

BEGIN

myErr

:=

AECreateAppleEvent

(kArithmeticClass,
serverAddress,

kMultiplyEventID,

kAutoGenerateReturnID,

kAnyTransactionID,
IF

myErr <> noErr THEN
DoError(myErr);
{failed

{add

the

myErr

:=

first

to

event}

AEPutParamPtr(theAppleEvent,
keyMultOperandl,
typeLongiInteger,
@firstOperand,

myErr <> noErr THEN
DoError (myErr) ;
{failed

{

{add the
myErr
:=

the

operand}

SizeOf
IF

create

theAppleEvent);

dispose

(firstOperand)

);

to

parameter--be

add

of

first

the

event

before

sure

leaving

to}

routine}

>

second operand with the proper
keyword}
AEPutParamPtr(theAppleEvent,
keyMultOperand2,

>
—

A

igo)
—

typeLongInteger,
@secondOperand,
SizeOf (secondOperand)
) ;

@

IF

myErr <> noErr THEN
DoError (myErr) ;
{be sure
to dispose
of the event
and first
}
{ parameter
before
leaving
routine}
myErr
:= AESend(theAppleEvent,
reply,
kAEWaitReply
+ kAENeverInteract,
kAENormalPriority,
120,
@myIdleFunction,
NIL);

(Continued)

Using the Apple Event Manager

6-61

=

<
@

~

—
rd
—

XZ
vo
Cael
as
-_

v2

@
ue

Inside Macintosh, Volume VI

Listing 6-17. Sending an Apple event (Continued)
IF

myErr

=

noErr

BEGIN
:=

{Apple

event

it

successfully

if

get

result

{
myErr

THEN

{check

was
code

successfully

returned

AEGetParamPtr(reply,

by

Sizeof
(myErr

{if

=

BEGIN

myErr

:=

doesn't

{

then

the

{

the

reply

{

the

direct

|

Apple
Apple

handler}

typeLongInteger,

actualSize);

(errNumber

exist

}

server's

@errNumber,

(errNumber),

errAEDescNotFound)

keyErrorNumber

the

keyErrorNumber,

returnedType,
IF

sent}

handled--

or

event
event

=

server
was

noErr)

THEN

returned

contains

the

}

handled--

result

in

}

}

parameter}

AEGetParamPtr(reply,
keyDirectObject,
typeInteger,
returnedType,
@replyResultLongInt,

SizeOf (replyResultLongInt),
MySendMultiplyEvent
Exit

noErr

successfully

:=

actualSize);

noErr;

(MySendMultiplyEvent) ;

END
ELSE
BEGIN
myErr

:=

{server
returned an
AEGetParamPtr(reply,

error,
so get error
string}
keyErrorString,
typeChar,

returnedType,
@errStr,
Sizeof(errStr),
actualSize);
IF

myErr

=

noErr

THEN

MyDisplayError(errStr);
END;

END
ELSE
BEGIN

{the Apple
event wasn't
successfully
dispatched,
}
{ the request
timed out,
the user canceled,
or other

error}

END;

MySendMultiplyEvent

:=

myErr;

END;

The code in Listing 6-17 first creates an Apple event with kArithmeticClass as the event class
and kMultiplyEventID as the event ID. It also specifies the server of the Apple event. See
“Specifying a Target Address” earlier in this chapter for information on various ways to
specify a target address. See “Creating an Apple Event” earlier in this chapter for more information on how to create an Apple event.
The Multiply event shown in Listing 6-17 contains two parameters, each of which specifies a
number to multiply. See “Adding Parameters to an Apple Event” earlier in this chapter for
examples of how to specify the parameters for the AEPutParamPtr function.
After adding the parameters to the event, the code uses AESend to send the event. The first

parameter to AESend specifies the Apple event to send—in this example, the Multiply event.
The next parameter specifies the reply Apple event.
This example specifies kAEWaitReply in the third parameter, indicating that the client is
willing to yield the processor for the specified timeout value (120 ticks, or 2 seconds). The
kAENeverInteract flag indicates that the server should not interact with the user when
6-62

Using the Apple Event Manager

The Apple Event Manager

processing the Apple event. The Multiply event is sent using normal priority, meaning it
is placed at the end of the event queue. You can specify the kAEHighPriority flag to place
the event in the front of the event queue.
The next to last parameter specifies the address of an idle function. If you specify
kAEWaitReply you should provide an idle function. This function should process any
update events, null events, operating-system events, or activate events that occur while
your application is waiting for a reply. See “Writing an Idle Function” later in this chapter
for sample code that shows an idle function.
The last parameter to AESend specifies a filter function. You can supply a filter function
to filter high-level events that your application might receive while waiting for a reply Apple
event. You can specify NIL for this parameter if you do not need to filter high-level events
while waiting for a reply. See “Writing a Reply Filter Function” later in this chapter for
more information.
If AESend returns a noErr result code and your application specified kAEWaitReply, you
should first see whether a result code was returned from the handler routine by checking the
reply Apple event for the existence of the parameter whose keyword is keyErrorNumber. If
the keyErrorNumber parameter does not exist or contains the noErr result code, you can use
AEGetParamPtr to get the parameter you’re interested in from the reply Apple event.
The code in Listing 6-17 checks the function result of AESend. If AESend returns noErr, the
code then checks the replyErrorNumber parameter of the reply Apple event to determine
whether the server successfully handled the Apple event. If this parameter exists and indicates
that an error occurred, then the code gets the error string out of the keyErrorString parameter.
Otherwise, the server performed the request, and the reply Apple event contains the answer to
the multiplication request.
When you are done using the Apple event specified in the AESend function and finished
with the reply Apple event, you must dispose of their descriptor records using the
AEDisposeDesc function.

Dealing

With

Timeouts

When your application calls AESend and chooses to wait for the server to handle the Apple
event, it can also specify the maximum amount of time that it is willing to wait for a response.
You can specify a timeout value in the tumeOutInTicks parameter to AESend. You can either
specify a particular length of time, in ticks, that your application is willing to wait, or you can
specify the KNoTimeOut constant or the kAEDefaultTimeout constant.
Use the kNoTimeOut constant to indicate that your application is willing to wait forever
for a response from the server. You should use this value only if your application is
guaranteed that the server will respond in a reasonable amount of time. You should also
implement a method of checking if the user wants to cancel. The idle function that you
specify as a parameter to AESend should check the event queue for any instances of
Command-period and immediately return TRUE as its function result if it finds a request
to cancel in the event queue.

N

—

—_

—_

@

Use the kAEDefaultTimeout constant if you want the Apple Event Manager to use a default
value for the timeout value. The Apple Event Manager uses a timeout value of about one
minute if you specify this constant.

=
uo
<
‘)
~
~
~
<2
—
AS
oe
—

dl

pe)
ge
@

—

Using the Apple Event Manager

6-63

;

Inside Macintosh, Volume VI

Note that if you set the kAEWaitReply flag and the server doesn’t have a handler for the
Apple event, AESend returns immediately with the errAEEventNotHandled result code.
If the server doesn’t respond within the length of time specified by the timeout value, AESend
returns the errAETimeout result code. This result code does not necessarily mean that the
server failed to perform the requested action; it only means that the server did not complete
processing within the specified time. The server might still be processing the Apple event, and
it might still send a reply.
If the server finishes processing the Apple event sometime after the time specified in the
timeout parameter has expired, it returns a reply Apple event to AEProcessAppleEvent. The
Apple Event Manager then returns the reply to the client in the reply parameter that the client
originally passed to the AESend function.
This means your application can continue to check the reply Apple event to see if the server
has responded, even after the time expires. If the server has not yet sent the reply when the
client attempts to extract data from the reply Apple event, the Apple Event Manager functions
return the errAEReplyNotArrived result code. Once the reply Apple event returns from the
server, the client can extract the data in the reply.
Additionally, the server can determine the timeout value specified by the client by examining

the keyTimeoutAttr attribute in the Apple event. You can use the value of this attribute as a

rough estimate of how much time your handler has to respond. You can assume that your
handler has less time to respond than the timeout value, because transmitting the Apple event
uses some of the available time, as does transmitting the reply Apple event back to the client.
If your handler needs more time than is specified in the keyTimeoutAttr attribute, you can

reset the timer by using the AEResetTimer function. This function resets the timeout value of
an Apple event to its starting value.

Writing an Idle Function
This section describes how to write an idle function when using the AESend or
AEInteractWithUser function.
When your application sends an Apple event, you can wait for the server application to receive
and finish handling the Apple event, or you can continue processing. If your application
chooses to continue processing, the AESend function returns immediately after using the Event
Manager to send the event. If your application chooses to wait for the server to handle the
event, the AESend function does not return until either the server application finishes handling
the Apple event or a specified amount of time expires.
Your application specifies its preferences by setting flags in the sendMode parameter to
AESend. Your application can specify kAENoReply if it does not want to receive a reply,
kAEQueueReply if it wants to receive the reply in its event queue, or KAEWaitReply if it
wants the reply returned in the reply parameter of AESend and is willing to give up the
processor while waiting for the reply.
If your application specifies the kAEWaitReply flag, the AESend function calls WaitNextEvent
on behalf of your application. This yields the processor to other processes, so that the server
has an opportunity to receive and process the Apple event sent by your application. While your
application is waiting for a reply, it cannot receive events unless it provides an idle function.
6-64

Using the Apple Event Manager

The Apple Event Manager

If your application provides a pointer to an idle function as a parameter to the AESend
function, AESend calls your idle function whenever an update event, null event, operatingsystem event, or activate event is received for your application. Your application can process
high-level events that it receives while waiting for a reply by providing a reply filter function.
See the next section, “Writing a Reply Filter Function,” for more information.
In a similar manner, when your application calls the AEInteractWithUser function, your
application can also yield the processor. If AEInteractWithUser needs to post a notification
request to bring your application to the front, your application yields the processor until the
user brings your application to the front. To receive events while waiting for the user to bring
your application to the front, you must provide an idle function.
If your application provides a pointer to an idle function as a parameter to the
AEInteractWithUser function, AEInteractWithUser calls your idle function whenever
an update event, null event, operating-system event, or activate event is received for
your application.
An idle function must use this syntax:
FUNCTION

MyIdleFunction

(VAR

theEventRecord:

VAR

sleepTime:

LongInt;

EventRecord;

VAR

mouseRgn:

RgnHandle)

:

Boolean;

The parameter theEventRecord is the event record of the event to process. The sleepTime
parameter and mouseRgn parameter are values that your idle function sets the first time it is
called; thereafter they contain the values your function set. Your idle function should return a
Boolean value that indicates whether your application wishes to continue waiting. Set the

function result to TRUE if your application is no longer willing to wait for a reply from the

server or for the user to bring the application to the front. Set the function result to FALSE if
your application is still willing to wait.
The first time your idle function is called, it receives a null event. At this time, you should set
the values for the sleepTime and mouseRgn parameters. These parameters are used in the
same way as the sleep and mouseRgn parameters of the WaitNextEvent function. Specify in
the sleepTime parameter the amount of time (in ticks) during which your application agrees to
relinquish the processor if no events are pending for it.
In the mouseRgn parameter, you specify a screen region that determines the conditions in
which your application is to receive notice of mouse-moved events. Your idle function
receives mouse-moved events only if your application is the front application and the mouse
strays outside the region you specify.
Your idle function receives only update events, null events, operating-system events, and
activate events. When your idle function receives a null event, it can use the idle time to update
status reports, animate cursors, or perform similar tasks. If your idle function receives any of
the other events, it should handle the event as it normally would if received in its event loop.
Listing 6-18 shows an example of an idle function that can be used as an idle function
for AESend or AEInteractWithUser. The idle function processes update events, null events,
operating-system events, and activate events. The first time the function is called it receives a
null event. At this time, it sets the sleepTime and mouseRgn parameters. The function
continues to process events until the server finishes handling the Apple event or the user
brings the application to the front.
Using the Apple Event Manager

6-65

—
>

—

~~

SS—
©
ie
<
©
|

=

-

2
—

)—

_

fh
tim)
c)

oe

Inside Macintosh, Volume VI

Your application should implement a method of checking to see if the user wants to cancel.
The MyCancelInQueue function in Listing 6-18 checks the event queue for any instances of
Command-period and immediately returns TRUE as its function result if it finds a request to
cancel in the event queue.

FUNCTION

Listing 6-18.

An

(VAR

event:

EventRecord;

VAR

sleeptime:

LongInt;

VAR

mouseRgn:

RgnHandle)

MyIdleFunction

idle function

:

Boolean;

VAR

hiByte:

CHAR;

myErr:

OSErr;

BEGIN

MyIdleFunction
:=
{the MyCancelInQueue
IF

FALSE;
function

MyCancelInQueue

checks

the

event

queue

for

Command-period}

THEN

BEGIN

MyIdleFunction
Exit

:=

TRUE;

(MyIdleFunction) ;

END;

CASE

event.what

OF

updateEvt,

activateEvt,

{every

kOSEvent:

{

of

idle

function

should

handle

these

kinds

your

app}

}

events}

BEGIN

AdjustCursor(event.where,
DoEvent

(event)

gCursorRgn) ;

;

END;

nullEvent:
BEGIN
{set

the

mouseRgn

sleeptime
DolIdle;

sleepTime
:=

and

mouseRgn

parameters}

gCursorRgn;

:=

10;

{use

the

{the

application's

correct

value
idle

for

handling}

END
END;

{CASE}

END;

Writing a Reply Filter Function
If your application calls AESend and chooses to yield the processor to other processes while
waiting for a reply, you can provide an idle function to process update, null, operating-system,
and activate events and, additionally, you can provide a reply filter function to process highlevel events. The previous section describes how an idle function processes events.
Your reply filter function can process any high-level events that it is willing to handle while
waiting for a reply Apple event. For example, your application can choose to handle Apple
events from other processes while waiting. Note, however, that your application must
maintain any necessary state information. Your reply filter function must not accept any
Apple events that can change the state of your application and make it impossible to return
to its previous state.
6-66

Using the Apple Event Manager

The Apple Event Manager
A reply filter function must use this syntax:
FUNCTION

MyWaitReplyFilter

(VAR

theEventRecord:

EventRecord;

transactionID:
LongInt;
returnID:
: Boolean;
AEAddressDesc)
sender:

LongInt;

The parameter theEventRecord is the event record for a high-level event. The next three parameters contain valid information only if the event is an Apple event. The transactionID parameter
is the transaction ID for the Apple event. The returnID parameter is the return ID for the Apple
event. The sender parameter contains the address of the application or process that sent the
Apple event.
Your reply filter function should return TRUE as the function result if you want to accept
the Apple event; otherwise it should return FALSE. If your filter function returns TRUE, the
Apple Event Manager calls the AEProcessAppleEvent function on behalf of your application,
and your handler routine is called to process the Apple event.

Writing and

Installing Coercion

Handlers

When your application extracts data from a parameter, it can request that the Apple Event
Manager return the data using a descriptor type that is different from the original descriptor
type. For example, when extracting data from the direct parameter of the Open Documents
event, you can request that the alias records be returned as file system specification records.
The Apple Event Manager can automatically coerce many different types of data from one to
another. Table 6-1 later in this section shows descriptor types and the sorts of coercion that
the Apple Event Manager can perform.
You can also provide your own routines, referred to as coercion handlers, to coerce other
descriptor types. To install your own coercion handlers, use the AEInstallCoercionHandler
function. You specify as parameters to this function
m the descriptor type of the data coerced by the handler
m the descriptor type of the resulting data
w the address of the coercion handler for this descriptor type
m areference constant
w a Boolean value that indicates whether your coercion handler expects the data to be
specified as a descriptor record or as a pointer to the actual data
ws a Boolean value that indicates whether your coercion handler should be added to your
application’s coercion table or the system coercion table
The system coercion table is a table in the system heap that contains handlers that are available to all applications and processes running on the same computer. The handlers in your
application’s coercion table are available only to your application. When the Apple Event
Manager is attempting to coerce data, it first looks for a coercion handler in your application’s
coercion table. If it cannot find a handler for the descriptor type, it looks in the system coercion
table for a handler. If it doesn’t find a handler there either, it returns the errAEHandlerNotFound
result code.

an

>

—

zz@
=
<
7)
~
—

=<
—
i

=

&
8=]
@

“

Using the Apple Event Manager

6-67

Inside Macintosh, Volume VI

If you add a handler to the system coercion table, the handler that you specify must reside in
the system heap. If there was already an entry in the system coercion table for the same
descriptor type, it is replaced. Therefore, if there is an entry in the system coercion table for
the same descriptor type, you should chain it to your system handler as explained in “Creating
and Managing the Coercion Handler Tables” later in this chapter.
Note: When an application calls a system coercion handler, the A5 register is set up
for the calling application. For this reason, if you provide a system coercion handler,
it should never use A5 global variables or anything that depends on a particular
context; otherwise, the application that calls the system coercion handler may crash.
You can provide a coercion handler that expects to receive the data in a descriptor record or a
buffer referred to by a pointer. When you install your coercion handler, you specify how
your handler wishes to receive the data. It’s more efficient for the Apple Event Manager to
provide your coercion handler with a pointer to the data so, whenever possible, you should
write your coercion handler so that it can accept a pointer to the data.
A coercion handler that accepts a pointer to data must be a function with the following syntax:
FUNCTION

MyCoercePtr

(typeCode:
toType:
VAR

DescType;
DescType;

result:

AEDesc)

dataPtr:

Ptr;

handlerRefcon:
:

dataSize:

Size;

LongIint;

OSErr;

The typeCode parameter is the descriptor type of the original data. The dataPtr parameter is a
pointer to the data to coerce; the dataSize parameter is the length, in bytes, of the data. The
toType parameter is the desired descriptor type of the resulting data. The handlerRefcon
parameter is a reference constant that is stored in the coercion table entry for the handler and
passed to the handler by the Apple Event Manager whenever the handler is called. The result
parameter is the resulting descriptor record returned by your coercion handler.
Your coercion handler should coerce the data to the desired descriptor type and return the
resulting data in the descriptor record specified by the result parameter. Your handler should
return the noErr result code if your handler successfully performs the coercion, and a nonzero
result code otherwise.
A coercion handler that accepts a descriptor record must be a function with the following syntax:
FUNCTION

MyCoerceDesc

(theAEDesc:

AEDesc;

toType:

DescType;

handlerRefcon:
LongInt;
VAR result:
AEDesc)
: OSErr;

The parameter theAEDesc is the descriptor record that contains the data to be coerced. The
toType parameter is the descriptor type of the resulting data. The handlerRefcon parameter is
a reference constant that is stored in the coercion table entry for the handler and passed to the
handler by the Apple Event Manager whenever the handler is called. The result parameter is
the resulting descriptor record.
Your coercion handler should coerce the data in the descriptor record to the desired descriptor
type and return the resulting data in the descriptor record specified by the result parameter.
Your handler should return an appropriate result code.

6-68

Using the Apple Event Manager

The Apple Event Manager

Table 6-1 lists the descriptor types that the Apple Event Manager provides coercion for. The
first column shows the descriptor type of the data to be coerced, and the second column
shows the descriptor types that the Apple Event Manager can coerce it to.
Note: For many Apple Event Manager functions, the Apple Event Manager attempts
to coerce data to the descriptor type you specify even if the result is no longer
meaningful. To ensure that no coercion is performed and that the descriptor type of
the result is of the same descriptor type as the original, specify typeWildCard for the
desired type.
Table

6-1.

| Coercion handling provided by the Apple Event Manager

Original
descriptor type

Desired

descriptor type

Description

typeChar

typeInteger
typeLongInteger
typeSMInt
typeSMFloat
typeShortInteger
typeLongFloat
typeShortFloat
typeExtended
typeComp
typeMagnitude

Any string that is a valid
representation of a number
can be coerced into an
equivalent numeric value.

typeInteger
typeLongInteger
typeSMInt
typeSMFloat
typeShortInteger
typeLongFloat
typeShortFloat
typeExtended
typeComp
typeMagnitude

typeChar

Any numeric descriptor type
can be coerced into
the equivalent text string.

typelnteger

typeInteger
typeLongInteger
typeSMInt
typeSMFloat

Any numeric descriptor type
can be coerced into any other
numeric descriptor type.

typeLongInteger
typeSMInt
typeSMFloat
typeShortInteger
typeLongFloat
typeShortFloat
typeExtended
typeComp
typeMagnitude
typeTrue
typeFalse

typeShortInteger

typeLongFloat
typeShortFloat
typeExtended
typeComp
typeMagnitude
typeBoolean
typeBoolean

“n

>

SS

=)
The result is the Boolean value
TRUE.
The result is the Boolean value

FALSE.

(Continued)

Using the Apple Event Manager

6-69

iS)
<
©
=

-

=<
—
p9
=
o>
Ge
fe)
-

Inside Macintosh,

Table

6-1.

Volume VI

Coercion handling provided by the Apple Event Manager (Continued)

Original
descriptor type

Desired
descriptor type

a
Description

typeEnumerated

typeBoolean

The enumerated value ‘true’

typeBoolean

typeEnumerated

The Boolean value FALSE

typeShortInteger

typeBoolean

A value of 1 becomes the
Boolean value TRUE. A value
of 0 becomes the Boolean
value FALSE.

typeBoolean

typeShortInteger

A value of FALSE becomes 0.
A value of TRUE becomes |.

typeAlias

typeFSS

An alias record is coerced into a
file system specification record.

typeAppleEvent

typeAppParameters

An Apple event is coerced into a
list of application parameters for
the LaunchParamBlockRec
parameter block.

any descriptor type

typeAEList

A descriptor record is coerced
into a descriptor list containing a
single item.

typeAEList

type of list item

A descriptor list containing a
single descriptor record is
coerced into a descriptor record.

The

Application

Died

becomes the Boolean value
TRUE. The enumerated value
‘fals' becomes the Boolean
value FALSE.

becomes the enumerated value
‘fals'. The Boolean value
TRUE becomes the enumerated
value ‘true’.

Event

If an application launched by your application terminates, either normally or as the result of
an error, the Process Manager can notify your application by sending it an Apple event—the
Application Died event. To receive this notification, you must set the acceptAppDied flag in
your application’s 'SIZE' resource. (For a complete description of the 'SIZE' resource, see
the Event Manager chapter in this volume.) See the Process Management chapter in this
volume for information on how your application can launch other applications.

6-70

Using the Apple Event Manager

The Apple Event Manager

Application

Died—inform

that an application

Event class

kCoreEventClass

Event ID

kAEApplicationDied

Required parameters
Keyword:
Descriptor type:
Data:
Keyword:
Descriptor type:
Data:
Requested action

has terminated

keyErrorNumber
typeLongInteger
A sign-extended OSErr value. A value of noErr indicates normal
termination; any other value indicates that the application terminated
due to an error.
keyProcessSerialNumber
typeProcessSerialNumber
The process serial number of the application that terminated.
None. This Apple event is sent only to provide information.

The Process Manager gets the value of the keyErrorNumber parameter from the system global
variable DSErrCode. This value can be set either by the application before it terminates or by
the Operating System (which can occur as the result of a hardware exception or other problem).

APPLE

EVENT

MANAGER

ROUTINES

This section describes the routines you use to manage Apple event dispatch tables, process
Apple events, get parameters and attributes from Apple events, get data from Apple event data
structures, create Apple event data structures, add parameters and attributes to Apple events,
send Apple events, get information about and delete descriptor records, and coerce descriptor
types. Result codes appear at the end of each function as applicable.

Creating

and

Managing

the Apple

Event

Dispatch

Tables

An Apple event dispatch table contains entries that specify the event class and event ID that
refer to one or more Apple events, the address of the handler routine that handles those Apple
events, and a reference constant. You use the AEInstallEventHandler function to add entries
to the Apple event dispatch table. Using this function sets up the initial mapping between the
handlers in your application and the Apple events that they handle.
If you need to remove any of your Apple event handlers after this mapping is established,
you can use the AERemoveEventHandler function. To get the address of a handler currently
in the Apple event dispatch table, use the AEGetEventHandler function.

>

S
<=)—

You use the AEInstallEventHandler function to add an entry to either the application or the
system Apple event dispatch table.
To create an entry in the Apple event dispatch table, supply the event class, event ID, and
address of the handler routine that handles Apple events of the specified event class and event
ID. You also specify a reference constant that the Apple Event Manager passes to your
handler routine whenever your handler processes an Apple event.
Apple Event Manager Routines

N

6-71

)
G3)
©
—

a

—_

2

—

£9
=}
£9
tj)
So
=

Inside Macintosh,

FUNCTION

Volume VI

AEInstallEventHandler

AEEventClass;
(theAEEventClass:
handler:
AEEventID;
theAEEventID:
handlerRefcon:
EventHandlerProcPtr;
: OSErr;
Boolean)
isSysHandler:
Longint;

The parameters theAEEventClass and theAEEventID specify the event class and event ID of
the Apple events to be handled by the handler for this dispatch table entry. For these
parameters, you must provide one of the following combinations:
a the event class and event ID of a single Apple event to be dispatched to the handler for
this dispatch table entry
= the typeWildCard constant for the AEEventClass and an event ID for theAEEventID,
which indicates that Apple events from all event classes whose event IDs match
theAEEventID should be dispatched to the handler for this dispatch table entry
m an event class for theAEEventClass and the typeWildCard constant for theAEEventID,
which indicates that all events from the event class theAEEventClass should be
dispatched to the handler for this dispatch table entry
a the typeWildCard constant for both the parameters theAEEventClass and theAEEventID,
which specifies that all Apple events should be dispatched to the handler for this
dispatch table entry
The handler parameter is a pointer to an Apple event handler for this dispatch table entry.
Note that a handler in the system dispatch table must reside in the system heap; this means
that if the value of the isSysHandler parameter is TRUE, the handler parameter should point
to a location in the system heap. Otherwise, if you put your system handler code in your
application heap, you must remove the handler when your application quits by using the
AERemoveEventHandler function.
The handlerRefcon parameter is a reference constant that is passed by the Apple Event
Manager to the handler each time the handler is called. If your handler doesn’t use a reference
constant, use 0 as the value of this parameter.
The isSysHandler parameter specifies the Apple event dispatch table to which you want to
add the handler. If the value of isSysHandler is TRUE, the Apple Event Manager adds the
handler to the system Apple event dispatch table. Entries in the system Apple event dispatch
table are available to all applications. If the value of isSysHandler is FALSE, the Apple Event
Manager adds the handler to your application’s Apple event dispatch table. The application
Apple event dispatch table is searched first; the system Apple event dispatch table is searched
only if the necessary handler is not found in your application’s Apple event dispatch table.
If there was already an entry in the specified event handler table for the same event class and
event ID, it is replaced. Therefore, before installing a handler for a particular Apple event
into the system dispatch table, use the AEGetEventHandler function to determine whether the
table already contains a handler for that event. If an entry exists, AEGetEventHandler returns
a reference constant and a pointer to that event handler. Chain these to your event handler by
providing pointers to the previous handler and its reference constant in the handlerRefcon
parameter of AEInstallEventHandler. When your handler is finished, use these pointers
to call the previous handler. If you remove your system handler, be sure to reinstall the
chained handlers.
6-72

Apple Event Manager Routines

The Apple Event Manager

Note: When an application calls a system Apple event handler, the A5 register is
set up for the calling application. For this reason, if you provide a system Apple
event handler, it should never use A5 global variables or anything that depends on a
particular context; otherwise, the application that calls the system handler may crash.
Result codes

noErr
paramErr
memFullErr

0
-50
-108

Noerror
Parameter error (handler pointer is NIL or odd)
Not enough room in heap zone

The AEGetEventHandler function gets an entry from an Apple event dispatch table.
FUNCTION

AEGetEventHandler

(theAEEventClass:

AEEventID;

VAR

AEEventClass;

handler:
ndle

VAR handlerRefcon:
Boolean)
: OSErr;

theAEEventID:

EventHandlerProcPtr;

LongInt;

isSysHandler:

The parameter theAEEventClass is the value of the event class field of the dispatch table entry
for the desired Apple event handler, and the parameter the AEEventID is the value of the event
ID field of the dispatch table entry for the desired Apple event handler. You can use the
typeWildCard constant for either or both of these parameters. (For an explanation of wildcard
values, see the earlier description of the AEInstallEventHandler function.)

In the handler parameter, the AEGetEventHandler function returns a pointer to the Apple
event handler.
In the handlerRefcon parameter, the AEGetEventHandler function returns the reference
constant that is passed by the Apple Event Manager to the Apple event handler each time the
handler is called.
The isSysHandler parameter specifies the Apple event dispatch table from which to get the
handler. If isSysHandler is TRUE, the AEGetEventHandler function returns the handler from
the system dispatch table. If isSysHandler is FALSE, AEGetEventHandler returns the handler
from your application’s dispatch table.
Result codes
noErr
errAEHandlerNotFound

0
-1717

Noerror
No handler found for an Apple event

r

jaddy

(theAEEventClass:
AEEventClass;
theAEEventID:
AEEventID;
nandler:
EventHandlerProcPtr;
isSysHandler:
Boolean)
: OSErr;

<
&

The parameter theAEEventClass is the event class for the handler to be removed. The parameter
theAEEventID is the event ID for the handler to be removed. You can use the typeWildCard
constant for either or both of these parameters. (For an explanation of wildcard values, see the
earlier description of the AEInstallEventHandler function.)
Apple Event Manager Routines

i

AERemoveEventHandler

r

FUNCTION

9

The AERemoveEventHandler function removes an entry from an Apple event dispatch table.

6-73

=

a

2

1 el

pe)

~

Pt)
go
@
Lew

|

Inside Macintosh,

Volume

VI

The handler parameter is a pointer to the Apple event handler to be removed. Although the
parameters theAEEventClass and theAEEventID would be sufficient to identify the handler to
be removed, providing the handler parameter is a safeguard that ensures that you’re removing
the correct handler.
The isSysHandler parameter specifies the Apple event dispatch table from which to remove
the handler. If isSysHandler is TRUE, AERemoveEventHandler removes the handler from
the system dispatch table. If isSysHandler is FALSE, AERemoveEventHandler removes the
handler from your application’s dispatch table.
Result codes
noErr
errAEHandlerNotFound

Dispatching

Apple

0
—1717

No error
No handler found for an Apple event

Events

After receiving a high-level event (and optionally checking whether it is a type of high-level
event other than an Apple event that your application might support), your application
typically calls the AEProcessAppleEvent function to determine the type of Apple event
received and to call the corresponding handler routine.
The AEProcessAppleEvent function looks first in the application Apple event dispatch table
and then in the system Apple event dispatch table for an entry that matches the event class
and event ID of the specified Apple event. If AEProcessAppleEvent finds a matching entry,
it calls the handler for that Apple event.
FUNCTION

AEProcessAppleEvent

(theEventRecord:

EventRecord)

:

OSErr;

The parameter theEventRecord is the event record for the Apple event.
If the AEProcessAppleEvent function cannot find a handler for an Apple event in either
the application or system Apple event dispatch table, the Apple Event Manager returns
the result code errAEEventNotHandled to the server application (as the result of the
AEProcessAppleEvent function). The Apple Event Manager also returns this result code
to the client application if the client is waiting fora reply.
Result codes

noErr
memFullErr
bufferlsSmall
noOutstandingHLE
errAECorruptData
errAENewerVersion
errAENotAppleEvent
errAEEventNotHandled

6-74

0
—108
—607
—608
—1702
—1706
—1707
-1708

Apple Event Manager Routines

No error
Not enough room in heap zone
Buffer is too small
No outstanding high-level event
Data inan Apple event could not be read
Need anewer version of the Apple Event Manager
Event is not an Apple event
Event wasn’t handled by an Apple event handler

The Apple Event Manager

Getting

Parameters

and Attributes

From

Apple

Events

You use the AEGetParamPtr and AEGetParamDesc functions to gain access to the parameters
of an Apple event. You use the AEGetAttributePtr and AEGetAttributeDesc functions to gain
access to the attributes of an Apple event.
The AEGetParamPtr function uses a buffer to return the data contained in a specified
parameter of an Apple event.
FUNCTION

AEGetParamPtr

(theAppleEvent:
AEKeyword;

DescType;
VAR

AppleEvent;

desiredType:

dataPtr:

actualSize:

Ptr;

Size)

theAEKeyword:

DescType;

VAR

maximumSize:
:

typeCode:

Size;

OSErr;

The parameter theAppleEvent is the Apple event containing the desired parameter.
The parameter theAEKeyword is the keyword that specifies the desired parameter.
The desiredType parameter specifies the descriptor type of the resulting data; if the desired
parameter is not of this type, the Apple Event Manager attempts to coerce it into this type. If
the value of desiredType is typeWildCard, no coercion is performed, and the descriptor type
of the returned data is the same as the descriptor type of the parameter. The returned data’s
descriptor type is returned in the typeCode parameter.
The dataPtr parameter is a pointer to the buffer for storing the returned data.
The maximumSize parameter is the maximum length, in bytes, of the data to be returned. You
must allocate at least this amount of storage for the buffer specified by the dataPtr parameter.
The AEGetParamPtr function returns in the actualSize parameter the actual length, in bytes,
of the data for the Apple event parameter. If this value is larger than the value of
maximumSize, not all of the data for the Apple event parameter was returned.
Result codes

noErr
memFullErr
errAECoercionFail

Q
—108
-1700

errAEDescNotFound
errAEWrongDataType
errAENotAEDesc
errAEReplyNotArrived

-1701
-1703
—1704
-—1718

No error
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type
Descriptor record was not found
Wrong descriptor type
Nota valid descriptor record
Reply has not yet arrived

a

The AEGetParamDesc function returns the descriptor record for an Apple event parameter.

>

—)
3

fe")

FUNCTION

AEGetParamDesc

(theAppleEvent:

AppleEvent;

AEKeyword;

desiredType:

VAR

AEDesc)

result:

:

tj

theAEKeyword:

<

DescType;

@

— |

poe

OSErr;

io
—

&

=

qe

The parameter theAppleEvent is the Apple event containing the desired parameter.
Apple Event Manager Routines

@
Ler 3

6-75

Inside Macintosh,

Volume

VI

The parameter theAEKeyword is the keyword that specifies the desired parameter.
The desiredType parameter specifies the descriptor type of the resulting descriptor record;
if the parameter is not of this type, the Apple Event Manager attempts to coerce it into this _
type. If the value of desiredType is typeWildCard, no coercion is performed, and the descriptor type of the resulting descriptor record is the same as the descriptor type of the Apple
event’s parameter.
The AEGetParamDesc function returns in the result parameter the resulting descriptor record.
This function creates a new descriptor record by copying the descriptor record from the
parameter. Your application is responsible for using the AEDisposeDesc function to dispose
of the resulting descriptor record once you are finished using it.
If the function returns a nonzero result code, a descriptor record with the typeNull descriptor
type is returned. A descriptor record of this type does not contain any data.
Result codes

noErr
memFullErr
errAECoercionFail

Q
—108
—1700

errAEDescNotFound
errAENotAEDesc
errAEReplyNotArrived

-1701
-1704
—1718

Noerror
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type
Descriptor type was not found
Nota valid descriptor record
— Reply has not yet arrived

The AEGetAttributePtr function uses a buffer to return the data contained in an Apple
event attribute.
FUNCTION

AEGetAttributePtr

(theAppleEvent:
AEKeyword;
VAR

AppleEvent;

desiredType:

typeCode:

DescType;

maximumSize:
Size;
Size)
: OSErr;

VAR

theAEKeyword:

DescType;
dataPtr:

Ptr;

actualSize:

The parameter theAppleEvent is the Apple event containing the desired attribute.
The parameter theAEKeyword is the keyword that specifies the desired attribute.
The desiredType parameter is the descriptor type of the data to be returned; if the desired
attribute is not of this type, the Apple Event Manager attempts to coerce it into this type. If the
value of desiredType is typeWildCard, no coercion is performed, and the descriptor type of
the returned data is the same as the descriptor type of the attribute. The returned data’s
descriptor type is returned in the typeCode parameter.
The dataPtr parameter is a pointer to the buffer for storing the data that is returned.
The maximumSize parameter is the maximum length, in bytes, of the data to be returned.
The AEGetAttributePtr function returns in the actualSize parameter the actual length, in bytes,
of the data for the attribute. If this value is larger than the value of maximumSize, not all of
the data for the attribute was returned.
6-76

Apple Event Manager Routines

The Apple Event Manager

Result codes

noErr
memFullErr
errAECoercionFail

QO
-108
—1700

errAEDescNotFound
errAENotAEDesc
errAEReplyNotArrived

-1701
-1704
-1718

Noerror
Not enough room in heap zone
Data could not be coerced to the requested

descriptor type

Descriptor type was not found
Nota valid descriptor record
— Reply has not yet arrived

The AEGetAttributeDesc function returns the descriptor record for an Apple event attribute.
FUNCTION

AEGetAttributeDesc

(theAppleEvent:
AEKeyword;
VAR

AppleEvent;

desiredType:

result:

AEDesc)

:

theAEKeyword:

DescType;
OSErr;

The parameter theAppleEvent is the Apple event containing the desired attribute.
The parameter theAEKeyword is the keyword that specifies the desired attribute.
The desiredType parameter is the descriptor type of the descriptor record to be returned; if the
desired attribute is not of this type, the Apple Event Manager attempts to coerce it into this
type. If the value of desiredType is typeWildCard, no coercion is performed, and the descriptor type of the resulting descriptor record is the same as the descriptor type of the attribute.
The AEGetAttributeDesc function returns in the result parameter the resulting descriptor
record. This function creates a new descriptor record by copying the descriptor record from
the parameter. Your application is responsible for using the AEDisposeDesc function to
dispose of the resulting descriptor record once you are finished using it.
If the function returns a nonzero result code, a descriptor record with the typeNull descriptor
type is returned. A descriptor record of this type does not contain any data.
Result codes

noErr
memFullErr
errAECoercionFail

Q
—108
-1700

errAEDescNotFound
errAENotAEDesc
errAEReplyNotArrived

-1701
-1704
-1718

Noerror
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type
Descriptor record was not found
Nota valid descriptor record
— Reply has not yet arrived
i)

Counting the Items in Descriptor Lists

3S
hs

~
—

The AECountltems function counts the number of descriptor records in a descriptor list.
FUNCTION

AECountItems

(theAEDescList:

LongIint)

:

AEDescList;

VAR

@

Ss)

<
@

—
-—
-

theCount:

2—

OSErr;

©

—
—

~
ti

The parameter theAEDescList is the descriptor list to be counted.
Apple Event Manager Routines

@
“

6-77

Inside Macintosh,

Volume VI

The AECountItems function returns the number of descriptor records in the list in the
parameter theCount.
Result codes
noErr
errAENotAEDesc

Getting

Q
-1704

Items From

Noerror
Nota valid descriptor record

Descriptor

Lists

You can use the AEGetNthPtr and AEGetNthDesc functions to gain access to the data in a
descriptor list. You can use the AEGetArray function to get data from an array contained in
a descriptor list.
The AEGetNthPtr function uses a buffer to return the data for a descriptor record in a
descriptor list.
FUNCTION

AEGetNthPtr

(theAEDescList:

AEDescList;

index:

LongInt;

GesiredType:
DescType;
VAR theAEKeyword:
AEKeyword;
VAR typeCode:
DescType;
dataPtr:

Ptr;

maximumSize:

Size;

VAR

actualSize:

Size)

OSErr;

The parameter theAEDescList is the descriptor list containing the desired descriptor record.
The index parameter specifies the position of the desired descriptor record in the list (for
example, 2 specifies the second descriptor record).
The desiredType parameter is the descriptor type of the resulting data; if the descriptor record
is not of this type, the Apple Event Manager attempts to coerce it into this type. If the value of
desiredType is typeWildCard, no coercion is performed, and the descriptor type of the
resulting data is the same as the descriptor type of the original descriptor record.
If you are getting data from a list of keyword-specified descriptor records, the keyword of the
specified descriptor record is returned in the parameter theAEKeyword; otherwise, the value
typeWildCard is returned.
The returned data’s descriptor type is returned in the typeCode parameter.
The dataPtr parameter is the pointer to the buffer for storing the data.
The maximumSize parameter is the maximum length, in bytes, of the data to be returned.
The AEGetNthPtr function returns in the actualSize parameter the actual length, in bytes, of
the data for the descriptor record. If this value is larger than the value of maximumSize, not
all of the data for the descriptor record was returned.
Result codes

noErr
memFullErr
errAECoercionFail

6-78

Q
—108
-1700

Apple Event Manager Routines

Noerror
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type

The Apple Event Manager

errAEDescNotFound
errAEWrongDataType
errAENotAEDesc
errAEReplyNotArrived

-1701
-1703
—-1704
-—1718

Descriptor record was not found
Wrong descriptor type
Nota valid descriptor record
Reply has not yet arrived

The AEGetNthDesc function returns a descriptor record from a descriptor list.
FUNCTION

AEGetNthDesc

(theAEDescList:

AEDescList;

desiredType:
DescType;
AEKeyword;
VAR result:

index:

LongInt;

VAR theAEKeyword:
AEDesc)
: OSErr;

The parameter theAEDescList is the descriptor list from which to get the descriptor record.
The index parameter is the position of the descriptor record to get (for example, 2 specifies
the second descriptor record in the list).
The desiredType parameter is the descriptor type of the resulting data; if the descriptor record
is not of this type, the Apple Event Manager attempts to coerce it into this type. If the value
of desiredType is typeWildCard, no coercion is performed, and the descriptor type of the
resulting descriptor record is the same as the descriptor type of the original descriptor record.
If you are getting data from a list of keyword-specified descriptor records, the AEGetNthDesc
function returns the keyword of the specified descriptor record in the parameter theAEKeyword;
otherwise, AEGetNthDesc returns the typeWildCard constant.
The AEGetNthDesc function returns in the result parameter the resulting descriptor record.
This function creates a new descriptor record by copying the descriptor record from the
parameter. Your application is responsible for using the AEDisposeDesc function to dispose
of the resulting descriptor record once you are finished using it.
If the function returns a nonzero result code, a descriptor record with the typeNull descriptor
type is returned. A descriptor record of this type does not contain any data.

errAEDescNotFound
errAENotAEDesc
errAEReplyNotArrived

-1701
—1704
—1718

Noerror
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type
— Descriptor record was not found
Nota valid descriptor record
— Reply has not yet arrived

The AEGetArray function converts an Apple event array (an array created with the AEPutArray
function and stored in a descriptor list) into the corresponding Pascal or C array.
AEGetArray

(theAEDescList:
arrayPtr:

AEDescList;

arrayType:

AEArrayDataPointer;

VAR

itemType:

DescType;

VAR

VAR

itemCount:

LongiInt)

:

AEArrayType;

maximumSize:

itemSize:

r

FUNCTION

<
<7)

Size;

a
—

Size;

_

2

OSErr;

—

as
~
—
—_
as
—

ga

The parameter theAEDescList is the descriptor list from which to get the array.
Apple Event Manager Routines

9

Q
—108
-1700

jaddy

noErr
memFullErr
errAECoercionFail

u

Result codes

&

—:

6-79

Inside Macintosh, Volume VI

The arrayType parameter is the Apple event array type to be converted. This is specified by
one of the following constants: kAEDataArray, KAEPackedArray, kAEHandleArray,
kAEDescArray, or KAEKeyDescArray.
The arrayPtr parameter is a pointer to the buffer for storing the array.
The maximumSize parameter is the maximum length, in bytes, of the data to be returned.
For packed, data, and handle arrays, the itemType parameter returns the descriptor type of the

array elements that are returned.

For packed and data arrays, the itemSize parameter returns the size, in bytes, of the array
elements that are returned.
The itemCount parameter returns the number of items in the resulting array.
Result codes

noErr
memFullErr
errAEWrongDataType
errAENotAEDesc
errAEReplyNotArrived

Getting
From

Data

AE

and

QO
—108
-1703
-1704
—1718

Noerror
Not enough room in heap zone
Wrong descriptor type
Nota valid descriptor record
Reply has not yet arrived

Keyword-Specified

Descriptor

Records

Records

You can use the AEGetKeyPtr and AEGetKeyDesc functions to get data and keywordspecified descriptor records out of an AE record or an Apple event.
The AEGetKeyPtr function uses a buffer to return the data contained in a keyword-specified
descriptor record. You can use this function to get data out of an AE record or an Apple
event record.
FUNCTION

AEGetKeyPtr

(theAERecord:

AERecord;

theAEKeyword:

desiredType:

DescType;

VAR

dataPtr:
Size)

:

Ptr;

maximumSize:

AEKeyword;

typeCode:

DescType;

Size;

actualSize:

VAR

OSErr;

The parameter theAERecord is the AE record from which to get data.
The parameter theAEKeyword is the keyword that specifies the desired descriptor record.
The desiredType parameter specifies the descriptor type of the resulting data; if the desired
data is not of this type, the Apple Event Manager attempts to coerce it into this type. If the
value of desiredType is type WildCard, no coercion is performed, and the descriptor type of
resulting data is the same as the descriptor type of the original data. The returned data’s
descriptor type is returned in the typeCode parameter.
The dataPtr parameter is a pointer to the buffer for storing the data.
6-80

Apple Event Manager Routines

The Apple Event Manager

The maximumSize parameter is the maximum length, in bytes, of the data to be returned.
The AEGetKeyPtr function returns in the actualSize parameter the actual length, in bytes, of
the data for the keyword-specified descriptor record. If this value is larger than the value of
maximumSize, not all of the data for the keyword-specified descriptor record was returned.
Result codes

noErr
memFullErr
errAECoercionFail

Q
—108
—1700

errAEDescNotFound
errAEWrongDataType
errAENotAEDesc
errAEReplyNotArrived

-1701
-—1703
—1704
—1718

Noerror
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type
Descriptor record was not found
Wrong descriptor type
Nota valid descriptor record
— Reply has not yet arrived

The AEGetKeyDesc function returns the descriptor record for a keyword-specified descriptor record. You can use this function to get a descriptor record out of an AE record or an
Apple event.
FUNCTION

AEGetKeyDesc

(theAERecord:

AERecord;

theAEKeyword:

desiredType:

DescType;

VAR

result:

AEKeyword;
AEDesc)

OSELY ;

The parameter theAERecord is the AE record from which to get the descriptor record.
The parameter theAEKeyword is the keyword that specifies the descriptor record to
be returned.
The desiredType parameter specifies the descriptor type of the resulting descriptor record; if
the original descriptor record is not of this type, the Apple Event Manager attempts to coerce
it into this type. If the value of desiredType is typeWildCard, no coercion is performed, and
the descriptor type of the resulting descriptor record is the same as the descriptor type of the
original descriptor record.
The AEGetKeyDesc function returns in the result parameter the resulting descriptor record.
This function creates a new descriptor record by copying the descriptor record from the AE
record. Your application is responsible for using the AEDisposeDesc function to dispose of
the resulting descriptor record once you are finished using it.
If the function returns a nonzero result code, a descriptor record with the typeNull descriptor
type is returned. A descriptor record of this type does not contain any data.
Result codes

9)

>

SS

noErr
memFullErr
errAECoercionFail

0
—108
—1700

errAEDescNotFound
errAENotAEDesc
errAEReplyNotArrived

-1701
—1704
—1718

eSC)

Noerror
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type
Descriptor record was not found
Nota valid descriptor record
— Reply has not yet arrived
Apple Event Manager Routines

3)
<
)

=)mal

2
—

=

tl

£9
©

ve

6-81

Inside Macintosh, Volume VI

Requesting

User

Interaction

Your server application may need to interact with the user while processing an Apple event.
Your application should use the AEInteractWithUser function before actually interacting with
the user in response to an Apple event. Your application can also specify its user interaction
preferences by using the AESetInteractionAllowed and AEGetInteractionAllowed functions.
A server application uses the AESetInteractionAllowed function to specify user interaction
preferences for responding to Apple events.
FUNCTION

AESetInteractionAllowed

(level:

AEInteractAllowed)

:

OSErr;

The level parameter must be one of three flags: kAEInteractWithSelf, kAEInteractWithLocal,
or kKAEInteractWithAll.
Specifying the kAEInteractWithSelf flag allows the server application to interact with the user
in response to an Apple event only when the client application and server application are the
same—that is, only when the application is sending the Apple event to itself.
Specifying the kAEInteractWithLocal flag allows the server application to interact with the
user in response to an Apple event only if the client application is on the same computer as the
server application; this is the default if the AESetInteractionAllowed function is not used.
Specifying the kAEInteractWithAll flag allows the server application to interact with the user
in response to an Apple event sent from any client application on any computer.
Result code
noErr

8)

No error

The AEGetInteractionAllowed function returns a value that indicates the user interaction
preferences for responding to an Apple event. The value returned is the interaction level set
by a previous call to AESetInteractionAllowed. The default value of kAEInteractWithLocal is
returned if your application has not used AESetInteractionAllowed to explicitly set the
interaction level.
FUNCTION

AEGetInteractionAllowed

(VAR

level:

AEInteractAllowed)

OSErr;

The level parameter returns one of the following flags: kAEInteractWithSelf,
kAEInteractWithLocal, or kAEInteractWithAll.
The kAEInteractWithSelf flag indicates that the server application may interact with the user
in response to an Apple event only when the client application and server application are the
same—that is, only when the application is sending the Apple event to itself.
The kAEInteractWithLocal flag indicates that the server application may interact with the user in
response to an Apple event only if the client application is on the same computer as the server
application. This is the default if your application has not used the AESetInteractionAllowed
function to explicitly set the interaction level.

6-82

Apple Event Manager Routines

The Apple Event Manager

The kAEInteractWithAll flag indicates that the server application may interact with the user in
response to an Apple event sent from any client application on any computer.
Result code
noErr

0

No error

A server application calls the AEInteractWithUser function before displaying a dialog box or
alert box or otherwise interacting with the user. If the user-interaction preference settings
permit the application to come to the foreground, this function brings your application to the
front, either directly or by posting a notification request.
FUNCTION

AEInteractWithUser

(timeOutInTicks:

NMRecPtr;

LongInt;

idleProc:

nmReqgPtr:

IdleProcPtr)

:

OSErr;

The timeOutInTicks parameter is the amount of time (in ticks) that your handler is willing to
wait for a response from the user.
The nmRegPtr parameter is a pointer to a Notification Manager record provided by your
application. You can specify NIL for this parameter to get the default notification handling
provided by the Apple Event Manager.
The idleProc parameter is a pointer to your application’s idle function, which handles events
while waiting for the Apple Event Manager to return control. For a description of how to
write this function, see “Writing an Idle Function” earlier in this chapter.
The AEInteractWithUser function checks to see if the client application set the kAENeverlInteract
flag for the Apple event and, if so, returns an error. If not, then the AEInteractWithUser function checks the server application’s preference set by the AESetInteractionAllowed function and
compares it against the source of the Apple event—that is, whether it came from the same
application, another application or process on the same computer, or an application or process
running on another computer. AEInteractWithUser returns the errAENoUserInteraction result
code if the user-interaction preferences don’t allow user interaction. If user interaction is
allowed, the Apple Event Manager brings your application to the front, either directly or by
posting a notification request. If AEInteractWithUser returns the noErr result code, then your
application is in the foreground and is free to interact with the user.
Result codes
noErr

Q}

errAETimeout

errAENoUserInteraction

—1712

—1713

Noerror

Apple event timed out

No user interaction allowed
mp

Requesting

More

Time

to Respond

to Apple

>

Events

"SS
S—

The AEResetTimer function resets the timeout value for an Apple event to its starting value. A
server application can call this function when it knows it cannot fulfill a client application’s
request (either by returning a result or by sending back a reply Apple event) before the client
application is due to time out.
FUNCTION

AEResetTimer

(reply:

AppleEvent)

:

OSErr;

Apple Event Manager Routines

@

cp)
<
@=}
-

<=iS)

i)
i]
ge

om
“y

6-83

Inside Macintosh,

Volume VI

The reply parameter is the default reply for an Apple event and is provided by the Apple
Event Manager. When AEResetTimer is called, the Apple Event Manager uses the default
reply to send a Reset Timer event to the client application; the Apple Event Manager for the
client application intercepts this Apple event and resets the client application’s timer for the
Apple event. (The Reset Timer event is never dispatched to a handler, and the client application does not need a handler for it.)
Result codes
noErr
errAEReplyNotValid

Suspending

and

0
—1709

No error
AEResetTimer was passed an invalid reply

Resuming

Apple

Event

Handling

The AESuspendTheCurrentEvent function suspends the processing of the Apple event that is
currently being handled.
FUNCTION

AESuspendTheCurrentEvent

(theAppleEvent:

AppleEvent)

:

OSErr;

The parameter theAppleEvent is the Apple event whose handling is to be suspended. Although
the Apple Event Manager doesn’t need the parameter theAppleEvent to identify the Apple
event currently being handled, providing this parameter is a safeguard that ensures that you
are suspending the correct Apple event.
After a server application makes a successful call to the AESuspendTheCurrentEvent function,
it is no longer required to return a result or a reply for the Apple event that was being handled.
It can, however, return a result if it later calls the AEResumeTheCurrentEvent function to

resume event processing.

The Apple Event Manager does not automatically dispose of Apple events that have been
suspended or of their default replies. (The Apple Event Manager does, however, automatically dispose of a previously suspended Apple event and its default reply if the server later
resumes processing of the Apple event by calling the AEResumeTheCurrentEvent function.)
If your server application does not resume processing of a suspended Apple event, it is
responsible for using the AEDisposeDesc function to dispose of both the Apple event and its
default reply when you are finished with them.
Result code
noErr

0

No

error

The AEResumeTheCurrentEvent function informs the Apple Event Manager that your application wants to resume the handling of a previously suspended Apple event or that it has
completed the handling of the Apple event.
FUNCTION

AEResumeTheCurrentEvent

(theAppleEvent,
reply:
AppleEvent;
dispatcher:
EventHandlerProcPtr;
handlerRefcon:

LongInt)

:

OSErr;

The parameter theAppleEvent is the Apple event whose processing is to be resumed.
6-84

Apple Event Manager Routines

The Apple Event Manager

The reply parameter is the default reply that is automatically provided by the Apple Event
Manager for the Apple event.
The dispatcher parameter is one of the following:
m a pointer to a routine for handling the event
mw the kAEUseStandardDispatch constant, which causes the Apple event to be dispatched
in the way it was when it was first received
mw the kAENoDispatch constant, which tells the Apple Event Manager that the processing
of the Apple event is complete and that it does not need to be dispatched
If the value of the dispatcher parameter is not kAEUseStandardDispatch, the handlerRefcon
parameter is a reference constant that is passed to the handler when the handler is called. If
the value of the dispatcher parameter is kAEUseStandardDispatch, the Apple Event Manager
ignores the handlerRefcon parameter and instead passes the reference constant that is stored
in the Apple event dispatch table entry for the Apple event. (If you want to pass the same
reference constant that is stored in the Apple event dispatch table, your application can obtain
the reference constant by calling the AEGetEventHandler function.)
Result code
noErr

0

No error

The AESetTheCurrentEvent function specifies the Apple event to be handled. There is
generally no reason for your application to use this function. Instead of calling this function,
your application should let the Apple Event Manager go through the dispatch tables to set
the current Apple event.
FUNCTION

AESetTheCurrentEvent

(theAppleEvent:

AppleEvent)

:

OSErr;

The parameter theAppleEvent is the Apple event that is to be handled.
The AESetTheCurrentEvent function is used only to avoid going through the dispatch tables,
and is used only in the following way:
|. An application suspends handling of an Apple event by calling the
AESuspendTheCurrentEvent function.
2. The application calls the AESetTheCurrentEvent function to inform the Apple Event
Manager that it is handling the Apple event that was previously suspended. It thereby
makes the identity of the Apple event currently being handled available to routines
that call the AEGetTheCurrentEvent function.

noErr

ea

<=)

3. The application handles the Apple event. When it is finished, it calls the
AEResumeTheCurrentEvent function with the value kAENoDispatch to tell the
Apple Event Manager that the processing of the event is complete and that the
Apple event does not need to be dispatched.
Result code

>)

gah
@

&<
@

i)_

2—

=

ned

is)

@)

ge

&

No error

Apple Event Manager Routines

6-85

Inside Macintosh,

Volume VI

The AEGetTheCurrentEvent function returns the Apple event that is currently being handled.
In many applications, the handling of an Apple event involves one or more long chains of

calls to routines within the application. The AEGetTheCurrentEvent function makes it

unnecessary for these calls to include the current Apple event as a parameter; the routines can
simply call AEGetTheCurrentEvent to get the current Apple event when it is needed.
FUNCTION

AEGetTheCurrentEvent

(VAR

theAppleEvent:

AppleEvent)

OSErr;

This function returns the Apple event that is currently being handled in the parameter
theAppleEvent.
Result code
noErr

Creating

0

Apple

No error

Events

The AECreateAppleEvent function creates an Apple event with several important attributes
but no parameters.
FUNCTION

AECreateAppleEvent

(theAEEventClass:

AEEventClass;

theAEEventID:
AEEventID;
AEAddressDesc;
returnID:
transactionID:
LongInt;
VAR result:
AppleEvent)

target:
Integer;
:

OSErr;

The parameter theAEEventClass is the event class of the Apple event to be created.
The parameter theAEEventID is the event ID of the Apple event to be created.
The target parameter is the address of the server application. See “Specifying a Target
Address” earlier in this chapter for information on how to address an Apple event.
The returnID parameter is the return ID assigned to this Apple event; if the
kAutoGenerateReturnID constant is used as the value, the Apple Event Manager
assigns a return ID that is unique to the current session.
The transactionID parameter is the transaction ID for this Apple event. A transaction refers to

a sequence of Apple events that are sent back and forth between the client and server applica-

tions, beginning with the client’s initial request for a service. All Apple events that are part of
a transaction must have the same transaction ID.

The AECreateAppleEvent function returns in the result parameter the resulting Apple event.
Your application is responsible for using the AEDisposeDesc function to dispose of the
resulting Apple event once you are finished using it.
If the function returns a nonzero result code, a descriptor record with the typeNull descriptor
type is returned. A descriptor record of this type does not contain any data.

6-86

Apple Event Manager Routines

The Apple Event Manager

Result codes
noErr
memFullErr

Creating

and

0)
—108

No error
Not enough room in heap zone

Duplicating

Descriptor

Records

The AECreateDesc function takes data and converts it into a descriptor record.
FUNCTION

AECreateDesc

(typeCode:

DescType;

Size;

result:

VAR

dataPtr:

AEDesc)

:

Ptr;

dataSize:

OSErr;

The typeCode parameter is the descriptor type for the resulting descriptor record.
The dataPtr parameter is a pointer to the data for the descriptor record.
The dataSize parameter is the length, in bytes, of the data for the descriptor record.
The AECreateDesc function returns in the result parameter the resulting descriptor record.
This function creates a new descriptor record by copying the descriptor record from the
parameter. Your application is responsible for using the AEDisposeDesc function to dispose
of the resulting descriptor record once you are finished using it. You normally do this after
receiving a result from the AESend function.
If the function returns a nonzero result code, a descriptor record with the typeNull descriptor
type is returned. A descriptor record of this type does not contain any data.
Result codes
noErr
memFullErr

0
—108

No error
Not enough room in heap zone

The AEDuplicateDesc function makes a copy of a descriptor record.
FUNCTION

AEDuplicateDesc

(theAEDesc:

AEDesc;

VAR

result:

AEDesc)

OSErr;

The parameter theAEDesc is the descriptor record to be copied.
The AEDuplicateDesc function returns in the result parameter the resulting descriptor record.
This function creates a new descriptor record by copying the descriptor record from the
parameter. Your application is responsible for using the AEDisposeDesc function to dispose
of the resulting descriptor record once you are finished using it. You normally do this after
receiving a result from the AESend function.

co a)
>

—
—_
—

—_

—

La)

If the function returns a nonzero result code, a descriptor record with the typeNull descriptor
type is returned. A descriptor record of this type does not contain any data.
It’s common for applications to send Apple events that have one or more attributes or parameters in common. For example, if you’re sending a series of Apple events to the same application, the address attribute is the same. In these cases, the most efficient way to create the
Apple Event Manager Routines

6-87

eo<
@

~

—

rd

=

—
—

dl

i)
vo
is")

Inside Macintosh,

Volume

VI

necessary Apple events is to make a template Apple event that you can then copy—by calling
the AEDuplicateDesc function—as needed. You then fill in or change the remaining parameters and attributes of the copy, send the copy by calling AESend, and then dispose of the
copy—by calling AEDisposeDesc—after AESend returns a result.
Result codes
noErr
memFullErr

Creating

0
—108

No error
Not enough room in heap zone

Descriptor Lists and AE

Records

The AECreateList function creates an empty descriptor list or AE record.
FUNCTION

AECreateList

(factoringPtr:

Ptr;

Boolean;

resultList:

VAR

factoredSize:

Size;

AEDescList)

isRecord:
:

OSErr;

You can compress descriptor lists—thereby saving both space and, in some cases, transmission time—by isolating data at the beginning of each descriptor record that is the same for
all descriptor records in the list. This common data is sent only once for all the descriptor
records in the list. When an application gets descriptor records from a compressed descriptor
list, the Apple Event Manager automatically decompresses them.
The factoringPtr parameter is a pointer to the data at the beginning of each descriptor that is
the same for all descriptor records in the list. (The method for compressing descriptor lists
is analogous to extracting the common factor from two or more numbers.) If there is no
common data, or if you decide not to isolate the common data, provide NIL as the value of
the factoringPtr parameter.
The factoredSize parameter is the size of the common data. If there is no common data, or if
you decide not to isolate the common data, the value of factoredSize must be 0.
The isRecord parameter is a Boolean value that specifies the kind of list to create. If you set
its value to TRUE, the Apple Event Manager creates an AE record. If you set its value to
FALSE, the Apple Event Manager creates a descriptor list.
The AECreateList function returns in the resultList parameter the resulting descriptor list or
AE record. This function creates a new descriptor record by copying the descriptor record
from the parameter. Your application is responsible for using the AEDisposeDesc function to
dispose of the resulting descriptor record once you are finished using it. You normally do this
after receiving a result from the AESend function.
If the function returns a nonzero result code, a descriptor record with the typeNull descriptor
type is returned. A descriptor record of this type does not contain any data.
Result codes
noErr
paramErr

memFullErr

6-88

0
—50

—108

No error
Parameter error (handler pointer is NIL or odd)

Not enough room in heap zone

Apple Event Manager Routines

The Apple Event Manager

Adding

Items to Descriptor Lists

The AEPutPtr function takes data specified in a buffer and converts it to a descriptor record
that it adds to a descriptor list.
FUNCTION

AEPutPtr

(theAEDescList:
DescType;

AEDescList;

dataPtr:

Ptr;

index:

dataSize:

LongInt;

typeCode:

Size)

OSErr;

:

The parameter theAEDescList is the descriptor list to which to add a descriptor record.
The index parameter is the position in the list for the descriptor record (for example,
2 specifies that it must be the second descriptor record). If there was already a descriptor
record at that position, it is replaced. If the value of index is 0, the descriptor record is
added at the end of the list.
The typeCode parameter is the descriptor type for the resulting descriptor record.
The dataPtr parameter is a pointer to the data for the descriptor record.
The dataSize parameter is the length, in bytes, of the data for the descriptor record.
Result codes

noErr
memFullErr
errAEWrongDataType
errAENotAEDesc
errAEBadListltem
errAEIllegalIndex

QO
—108
-—1703
—1704
—1705
-1719

Noerror
Not enough room in heap zone
Wrong descriptor type
Nota valid descriptor record
Operation involving a list item failed
Nota valid list index

The AEPutDesc function adds a descriptor record to a descriptor list.
FUNCTION

AEPutDesc

(theAEDescList:
theAEDesc:

AEDescList;

AEDesc)

:

index:

LongInt;

OSErr;

The parameter theAEDescList is the descriptor list to which you are adding a descriptor record.
The index parameter is the position in the list for the descriptor record (for example,
2 specifies that it must be the second descriptor record). If there was already a descriptor
record at that position, it is replaced. If the value of index is 0, the descriptor record is
added to the end of the list.

The parameter theAEDesc is the descriptor record to be added to the list.

“n

>

—)

Result codes

noErr
memFullErr
errAEWrongDataType
errAENotAEDesc
errAEBadListltem
errAEIIlegalIndex

=

fas)

QO
—108
-1703
—1704
—1705
-1719

cs)

Noerror
Not enough room in heap zone
Wrong descriptor type
Nota valid descriptor record
Operation involving a list item failed
Nota valid list index
Apple Event Manager Routines

<

@

~

a

2
—

f
)

pe)
ge
@

=y

6-89

Inside Macintosh,

Volume

VI

The AEPutArray function puts the data for an Apple event array into a descriptor list.
FUNCTION

AEPutArray

(theAEDescList:

AEDescList;

arrayType:

arrayPtr:

AEArrayDataPointer;

itemSize:

Size;

itemCount:

AEArrayType;

itemType:

LongInt)

:

DescType;
OSErr;

The parameter theAEDescList is the descriptor list into which to put the Apple event array. If
there are any items already in the descriptor list, they are replaced.
The arrayType parameter is the Apple event array type to be created. This is specified by
one of the following constants: kAEDataArray, KAEPackedArray, kAEHandleArray,
kAEDescArray, or KAEKeyDescArray. The kAEDataArray constant refers to an array of
integers; kAEPackedArray refers to an array of characters; kAEHandleArray refers to an
array of handles; kAEDescArray refers to an array of descriptor records; and
kAEKeyDescArray refers to an array of keyword-specified descriptor records.
If you are putting an array into a compressed descriptor list (see the description of the
AECreateList function for information about compressing descriptor lists), the data for each
array element must include the data that is common to all the descriptor records in the list. The
Apple Event Manager automatically isolates the data you specified in the call to AECreateList
that is common to all the elements of the array.
The arrayPtr parameter is a pointer to the buffer containing the array.
For packed, data, and handle arrays, the itemType parameter specifies the descriptor type of
array items to be created.
For packed and data arrays, the itemSize parameter specifies the size, in bytes, of the array
items to be created.
The itemCount parameter is the number of elements in the array.
Result codes

noErr
memFullErr
errAEWrongDataType
errAENotAEDesc

Adding
to AE

Data and

Q
—108
-1703
—1704

Noerror
Not enough room in heap zone
Wrong descriptor type
Nota valid descriptor record

Keyword-Specified

Descriptor

Records

Records

The AEPutKeyPtr function takes a pointer to data, a descriptor type, and a keyword and
converts them into a keyword-specified descriptor record that it adds to an AE record.
FUNCTION

AEPutKeyPtr

(theAERecord:

AERecord;

typeCode:
DescType;
Size)
: OSErr;

theAEKeyword:

dataPtr:

Ptr;

AEKeyword;

dataSize:

The parameter theAERecord is the AE record to which to add a keyword-specified
descriptor record.
6-90

Apple Event Manager Routines

The Apple Event Manager

The parameter theAEKeyword is the keyword specifying the descriptor record. If there was
already a descriptor record with this keyword, it is replaced.
The typeCode parameter is the descriptor type for the keyword-specified descriptor record.
The dataPtr parameter is a pointer to the data for the keyword-specified descriptor record.
The dataSize parameter is the length, in bytes, of the data for the keyword-specified
descriptor record.
Result codes

noErr
memFullErr
errAEWrongDataType
errAENotAEDesc
errAEBadListltem

Q
-108
-1703
-1704
-1705

Noerror
Not enough room in heap zone
Wrong descriptor type
Nota valid descriptor record
Operation involving a list item failed

The AEPutKeyDesc function takes a descriptor record and a keyword and converts them into
a keyword-specified descriptor record that it adds to an AE record.
FUNCTION

AEPutKeyDesc

(theAERecord:
theAEDesc:

AERecord;
AEDesc)

:

theAEKeyword:

AEKeyword;

OSErr;

The parameter theAERecord is the AE record to which to add the keyword-specified
descriptor record.
The parameter theAEKeyword is the keyword specifying the descriptor record. If there
was already a keyword-specified descriptor record with this keyword, it is replaced.
The parameter theAEDesc is the descriptor record for the keyword-specified
descriptor record.
Result codes

noErr
memFullErr
errAEWrongDataType
errAENotAEDesc
errAEBadListltem

Adding

Parameters

Q
—108
-1703
—1704
-1705

Noerror
Not enough room in heap zone
Wrong descriptor type
Nota valid descriptor record
Operation involving a list item failed

and Attributes to Apple

Events

Nn
>

The AEPutParamPtr function takes a pointer to data, a descriptor type, and a keyword and
converts them into a parameter that it adds to an Apple event.
FUNCTION

AEPutParamPtr

(theAppleEvent:
AppleEvent;
theAEKeyword:
AEKeyword;
typeCode:
DescType;
dataPtr:
dataSize:

Size)

:

—

A

—
_
—

@

e3)
<
<7)
=
-

Ptr;

<
—

OSErr;

Apple Event Manager Routines

ey)
=
i
ge
io

6-9]

Inside Macintosh,

Volume VI

The parameter theAppleEvent is the Apple event to which you are adding a parameter.
The parameter theAEKeyword is the keyword for the parameter. If there was already a
parameter with this keyword in the Apple event, it is replaced.
The typeCode parameter is the descriptor type for the parameter.

The dataPtr parameter is a pointer to the data for the parameter.
The dataSize parameter is the length, in bytes, of the data for the parameter.
Result codes

noErr
memFullErr
errAEWrongDataType
errAENotAEDesc
errAEBadListltem

0)
—108
—1703
—1704
—1705

No error
Not enough room in heap zone
Wrong descriptor type
Not a valid descriptor record
Operation involving a list item failed

The AEPutParamDesc function takes a descriptor record and a keyword and converts them
into a parameter that it adds to an Apple event.
FUNCTION

AEPutParamDesc

(theAppleEvent:
AEKeyword;

ApoleEvent;

theAEDesc:

theAEKeyword:

AEDesc)

:

OSErr;

The parameter theAppleEvent is the Apple event to which you are adding a parameter.
The parameter theAEKeyword is the keyword for the parameter. If there was already a
parameter with this keyword in the Apple event, it is replaced.
The parameter theAEDesc is the descriptor record for the parameter.
Result codes

noErr
memFullErr
errAEWrongDataType
errAENotAEDesc
errAEBadListltem

0
—108
—1703
—1704
—1705

No error
Not enough room in heap zone
Wrong descriptor type
Not a valid descriptor record
Operation involving a list item failed

The AEPutAttributePtr function takes a pointer to data, a descriptor type, and a keyword and
converts them into an attribute that it adds to an Apple event.
FUNCTION

AEPutAttributePtr

(theAppleEvent:
AEKeyword;

Ptr;

AppleEvent;

typeCode:

dataSize:

Size)

theAEKeyword:

DescType;

:

dataPtr:

OSErr;

The parameter theAppleEvent is the Apple event to which you are adding an attribute.
The parameter theAEKeyword is the keyword of the attribute. If there was already an
attribute with this keyword in the Apple event, it is replaced.
6-92

Apple Event Manager Routines

The Apple Event Manager

The typeCode parameter is the descriptor type for the attribute.
The dataPtr parameter is a pointer to the buffer containing the data to be assigned to the attribute.
The dataSize parameter is the length, in bytes, of the data to be assigned to the attribute.
Result codes

noErr
memFullErr
errAECoercionFail

0
—108
-—1700

errAENotAEDesc

—-1704

No error
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type
Not a valid descriptor record

The AEPutAttributeDesc function takes a descriptor record and a keyword and converts them
into an attribute that it adds to an Apple event.
FUNCTION

AEPutAttributeDesc

(theAppleEvent:
AEKeyword;

AppleEvent;

theAEDesc:

theAEKeyword:

AEDesc)

:

OSErr;

The parameter theAppleEvent is the Apple event to which you are adding an attribute.
The parameter theAEKeyword is the keyword of the attribute. If there was already an
attribute with this keyword in the Apple event, it is replaced.
The parameter theAEDesc is the descriptor record to be assigned to the attribute. The
descriptor type of the specified descriptor record should match the defined descriptor type
for that attribute. For example, the keyEventSourceAttr attribute has the typeShortInteger
descriptor type.
If the descriptor type required for the attribute is different from the descriptor type of the
descriptor record, the Apple Event Manager attempts to coerce the descriptor record into the
required type, with one exception: the Apple Event Manager does not attempt to coerce the
data for an address attribute, thereby allowing applications to use their own address types.
Result codes

0
—108
—1700

errAENotAEDese

= -1704

No error
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type
Not a valid descriptor record
9

noErr
memFullErr
errAECoercionFail

Events

joaddy

Apple

>

The AESend function sends an Apple event.

>

-

Sending

oe

FUNCTION

AESend

=
=
noe

(theAppleEvent:
AppleEvent;
VAR reply:
AppleEvent;
sendMode:
AESendMode;
sendPriority:
AESendPriority;
timeOutInTicks:
LongInt;
idleProc:
IdleProcPtr;
filterProc:

EventFilterProcPtr)

:

<—
1

od

Ped

a
ge

OSErr;

Apple Event Manager Routines

@
"

6-93

Inside Macintosh,

Volume V1

The parameter theAppleEvent specifies the Apple event to be sent.

The reply parameter specifies the reply Apple event that is returned if you specify the
kAEWaitReply flag in the sendMode parameter. (If you specify the kAEQueueReply flag in
the sendMode parameter, you receive the reply Apple event in your event queue.) If you
specify either the kAEQueueReply flag or the KAENoReply flag, the data in the reply Apple
event returned by this function is not valid. If this function returns a nonzero result, it also
returns in the reply parameter a descriptor record whose descriptor type is typeNull—that is,
one that does not contain data. If you specify kAEWaitReply, your application is responsible
for using the AEDisposeDesc function to dispose of the resulting descriptor record.
The sendMode parameter allows you to specify the following: the reply mode for the Apple
event (set with one of the constants kAENoReply, kAEQueueReply, or kAEWaitReply);

the interaction mode (set with one of the constants kAENeverlInteract, kAECanInteract, or
kAEAIwaysInteract); the layer switch mode (set with the kAECanSwitchLayer constant); the
reconnection mode (set with the kAEDontReconnect constant); and the return receipt mode

(set with the kAEWantReceipt constant). You obtain the value for this parameter by adding the
appropriate constants. These flags are stored in the interaction level attribute, whose keyword
is keyInteractLevelAttr. The sendMode flags are described in a later part of this section.
In the sendPriority parameter, you specify flags that determine whether the Apple event is put
at the back of the event queue (the kAENormalPriority flag) or at the front of the queue (the
kAEHighPriority flag).
If the reply mode specified in the sendMode parameter is kAEWaitReply, or if a return receipt
is requested, the timeOutInTicks parameter specifies the length of time (in ticks) that the client
application is willing to wait for the reply or return receipt from the server application before
timing out. Most applications should use the kAEDefaultTimeout constant, which tells the
Apple Event Manager to provide an appropriate timeout duration. If the value of this parameter is KNoTimeOut, the Apple event never times out.
The idleProc parameter specifies a pointer to a function for any tasks (such as displaying a
wristwatch or spinning beach ball cursor) that the application performs while waiting for a
reply or a return receipt (see “Writing an Idle Function” earlier in this chapter).
The filterProc parameter specifies a pointer to a routine that accepts certain incoming Apple
events that are received while the handler waits for a reply or a return receipt and filters out
the rest (see “Writing a Reply Filter Function” earlier in this chapter).
You can use one of the following flags in the sendMode parameter to specify the reply mode
for an Apple event. Only one of these flags may be set.
Flag

Description

kAENoReply

Your application does not want a reply Apple event; the server
processes your Apple event as soon as it has the opportunity.

kAEQueueReply

Your application wants a reply Apple event; the reply appears in
your event queue as soon as the server has the opportunity to
process and respond to your Apple event.

6-94

Apple Event Manager Routines

The Apple Event Manager
Flag

Description

kAEWaitReply

Your application wants a reply Apple event and is willing to give
up the processor while waiting for the reply; for example, if the
server application is on the same computer as your application,
your application yields the processor to allow the server to
respond to your Apple event.

You can communicate your user-interaction preferences to the server by specifying one of
these flags in the sendMode parameter of the AESend function. Only one of these flags may
be set.

Flag

Description

kAENeverInteract

The server application should never interact with the user
in response to this Apple event. If this flag is set,
AEInteractWithUser does not bring the server application to
the foreground (this is the default when an Apple event is
sent to a remote application).

kAECanInteract

The server application can interact with the user in response to
this Apple event—by convention, if the user needs to supply
information to the server. If this flag is set and the server allows
interaction, AEInteractWithUser brings the server application to
the foreground (this is the default when an Apple event is sent to
a local application).

kAEAIwaysInteract

The server application can interact with the user in response to
this Apple event—by convention, even if no information is
needed from the user. If this flag is set and the server allows
interaction, AEInteractWithUser brings the server application to
the foreground. The Apple Event Manager does not distinguish
between this flag and the kAECanInteract flag—distinguishing between them is the responsibility of the server application.

The flags in the following list specify the layer switch mode, the reconnection mode, and the
return receipt mode. Any of these flags may be set.
Flag

Description

kAECanSwitchLayer

If both the client and server allow interaction and this flag is set,
AEInteractWithUser brings the server directly to the foreground
if adherence to the principle of user control allows. If the action
would be contrary to this principle, AEInteractWithUser uses the
Notification Manager to request that the user bring the server
application to the foreground. If both the client and server allow
interaction and this flag is not set, AEInteractWithUser always
uses the Notification Manager to request that the user bring the
server application to the foreground.

a)
>,
-

S
——

ed

—

<")
—
~~

<
<)

—_
~
—

2
—

xX
—

_

Pe
tf)
oe

“

Apple Event Manager Routines

6-95

Inside Macintosh,

Volume VI

Flag

Description

kAEDontReconnect

Specifies that the Apple Event Manager must not automatically
try to reconnect if it receives a sessClosedErr result code from
the PPC Toolbox.

kAEWantReceipt

The sender wants to receive a return receipt for this Apple event
from the Event Manager. (Getting a return receipt means only
that the receiving application accepted the Apple event; the
Apple event may or may not be handled successfully after it is
accepted.) If the receiving application does not send a return
receipt before the request times out, AESend returns
errAETimeout as its function result.

If the Apple Event Manager cannot find a handler for an Apple event in either the application
or system Apple event dispatch table, it returns the result code errAEEventNotHandled to the
server application (as the result of the AEProcessAppleEvent function). If the client is waiting
for a reply, the Apple Event Manager also returns this result code to the client.
AESend returns noErr as the function result if the Apple event was successfully sent by the
Event Manager. A noErr result from AESend does not indicate that the Apple event was
handled successfully; it only indicates that the Apple event was successfully sent by the Event
Manager. If a result code other than noErr is returned by the handler, and if the client is
waiting for a reply, it is returned in the keyErrorNumber parameter of the reply Apple event.
Result codes

noErr
memFullErr
connectionInvalid
errAEEventNotHandled

Q
-108
—609
—1708

Noerror
Not enough room in heap zone
Connection is invalid
Event wasn’t handled by an Apple event
handler
-1710 _ Invalid sending mode was passed
—1711
User canceled out of wait loop for reply
or receipt
-1712
Apple event timed out
-1716
Unknown Apple event address type

errAEUnknownSendMode
errAEWaitCanceled
errAETimeout
errAEUnknownAddressType

Getting the Sizes and

Descriptor Types

of Descriptor Records

The AESizeOfNthItem function returns the size and descriptor type of a descriptor record in a
descriptor list.
FUNCTION

AESizeOfNthItem

(theAEDescList:

AEDescList;

VAR

DescType;

;:

typeCode:

VAR

index:

LongInt;

dataSize:

Size)

OSErY:

The parameter theAEDescList is the descriptor list containing the descriptor record.
The index parameter is the position of the descriptor record in the list (for example, 2 specifies
the second descriptor record).
6-96

Apple Event Manager Routines

The Apple Event Manager

The AESizeOfNthItem function returns the descriptor type of the descriptor record in the
typeCode parameter.
This function returns the length, in bytes, of the data contained in the descriptor record in the
dataSize parameter.
Result codes
noErr
errAEDescNotFound
errAEReplyNotArrived

Q
Noerror
-1701
Descriptor record was not found
—1718 — Reply has not yet arrived

The AESizeOfKeyDesc function returns the size and descriptor type of a keyword-specified
descriptor record in an AE record.
FUNCTION

AESizeOfKeyDesc

(theAERecord:
AEKeyword;

VAR

AERecord;
VAR

dataSize:

theAEKeyword:

typeCode:

Size)

:

DescType;

OSErr;

The parameter theAERecord is the AE record containing the desired keyword-specified
descriptor record.
The parameter theAEKeyword is the keyword that specifies the desired descriptor record.
This function returns the descriptor type of the desired keyword-specified descriptor record in
the typeCode parameter.
This function returns the length, in bytes, of the data contained in the keyword-specified
descriptor record in the dataSize parameter.
Result codes

noErr
errAEDescNotFound
errAENotAEDesc
errAEReplyNotArrived

Q
-1701
—1704
—1718

Noerror
|
Descriptor record was not found
Nota valid descriptor record
— Reply has not yet arrived

The AESizeOfParam function returns the size and descriptor type of an Apple event parameter.
FUNCTION

AESizeOfParam

(theAppleEvent:
AEKeyword;
VAR

AppleEvent;
theAEKeyword:
typeCode:
DescType;

VAR

Size)

dataSize:

:

OSErr;
“N

The parameter theAppleEvent is the Apple event containing the parameter.

er
—

—

—

\

—

Cc

The parameter theAEKeyword is the keyword that specifies the desired parameter.

—
~

<
a0)

The function returns the descriptor type of the parameter in the typeCode parameter.

-_

—

Comal

The function returns the length, in bytes, of the data contained in the desired parameter in the
dataSize parameter.

A
—
SS
—

oe

ts]
ge
@

a

Apple Event Manager Routines

6-97

Inside Macintosh, Volume VI

Result codes

noErr
errAEDescNotFound
errAENotAEDesc
errAEReplyNotArrived

Q
-1701
-1704
—1718

No error
Descriptor record was not found
Nota valid descriptor record
Reply has not yet arrived

The AESizeOfAttribute function returns the size and descriptor type of an Apple event
attribute.
FUNCTION

AESizeOfAttribute

(theAppleEvent:
AEKeyword;
VAR

AppleEvent;
theAEKeyword:
typeCode:
DescType;

VAR

Size)

dataSize:

:

OSErr;

The parameter theAppleEvent is the Apple event containing the attribute.
The parameter theAEKeyword is the keyword that specifies the attribute.
The function returns the descriptor type of the attribute in the typeCode parameter.
The function returns the length, in bytes, of the data contained in the attribute in the

dataSize parameter.
Result codes

noErr
errAEDescNotFound
errAENotAEDesc
errAEReplyNotArrived

Deleting

Descriptor

Q
Noerror
-1701 — Descriptor record was not found
-1704
Nota valid descriptor record
—1718 — Reply has not yet arrived

Records

The AEDeleteItem function deletes a descriptor record from a descriptor list.
FUNCTION

AEDeleteItem

(theAEDescList:

AEDescList;

index:

LongInt)

OSErr;

The parameter theAEDescList is the descriptor list containing the descriptor record to
be deleted.
The index parameter is the position of the descriptor record to delete (for example, 2 specifies
the second item).
Result codes

noErr
errAEDescNotFound
errAENotAEDesc
errAEBadListltem

6-98

QO
Noerror
-1701 — Descriptor record was not found
-1704
Nota valid descriptor record
-1705
Operation involving a list item failed

Apple Event Manager Routines

The Apple Event Manager

The AEDeleteKeyDesc function deletes a keyword-specified descriptor record from an
AE record.
FUNCTION

AEDeleteKeyDesc

(theAERecord:

AERecord;

AEKeyword)

:

theAEKeyword:

OSErr;

The parameter theAERecord is the AE record containing the keyword-specified descriptor
record to be deleted.
The parameter theAEKeyword is the keyword that specifies the descriptor record to
be deleted.
Result codes

noErr
errAEDescNotFound
errAENotAEDesc
badListItem

0
-1701
-1704
—1705

Noerror
Descriptor record was not found
Nota valid descriptor record
Operation involving a list item failed

The AEDeleteParam function deletes an Apple event parameter.
FUNCTION

AEDeleteParam

(theAppleEvent:
AEKeyword)

:

AppleEvent;

theAEKeyword:

OSErr;

The parameter theAppleEvent is the Apple event containing the parameter to be deleted.
The parameter theAEKeyword is the keyword that specifies the parameter to be deleted.
Result codes

noErr
errAEDescNotFound
errAENotAEDesc
errAEBadListltem

Deallocating

Memory

0
-1701
-1704
—1705

No error
Descriptor record was not found
Nota valid descriptor record
Operation involving a list item failed

for Descriptor

Records

The AEDisposeDesc function deallocates the memory used by a descriptor record. Because
all Apple event structures (except for keyword-specified descriptor records) are descriptor
records, you can use AEDisposeDesc for any of them.
FUNCTION

AEDisposeDesc

(VAR

theAEDesc:

AEDesc)

:

“N

OSErr;

~~
a
—

‘aw

"SS—

ie")
wee

The parameter theAEDesc is the descriptor record to deallocate.

J

<
‘<)
_—

_

Result code
noErr

a

Q

x
—
as
—
=
~

Noerror

—

ge

<)
a|

Apple Event Manager Routines

6-99

Inside Macintosh,

Coercing

Volume VI

Descriptor Types

The AECoercePtr function takes a pointer to data and a desired descriptor type and attempts to
coerce the data into the desired descriptor type. If successful, it creates a descriptor record
containing the newly coerced data.
FUNCTION

AECoercePtr

Size;
dataSize:
Ptr;
dataPtr:
DescType;
(typeCode:
: OSErr;
AEDesc)
VAR result:
DescType;
toType:

The typeCode parameter is the descriptor type of the source data.
The dataPtr parameter is a pointer to the data to be coerced.
The dataSize parameter is the length, in bytes, of the data to be coerced.
The toType parameter is the desired descriptor type of the resulting descriptor record.
The AECoercePtr function returns in the result parameter the resulting descriptor record. This
function creates a new descriptor record by copying the descriptor record from the parameter.
Your application is responsible for using the AEDisposeDesc function to dispose of the
resulting descriptor record once you are finished using it.
If the function returns a nonzero result code, a descriptor record with the typeNull descriptor
type is returned. A descriptor record of this type does not contain any data.
Note:

To avoid infinite recursion, AECoercePtr must never be called by an

application-supplied coercion routine.
Result codes

noErr
memFullErr
errAECoercionFail

Q
—108
-1700

No error
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type

The AECoerceDesc function coerces the data in a descriptor record to another descriptor type.
FUNCTION

AECoerceDesc

(theAEDesc:
AEDesc)
:

AEDesc;
OSErr;

toType:

DescType;

VAR

result:

The parameter theAEDesc is the descriptor record whose data is to be coerced.
The toType parameter is the desired descriptor type of the resulting descriptor record.
The AECoerceDesc function returns in the result parameter the resulting descriptor record.
This function creates a new descriptor record by copying the descriptor record from the
parameter. Your application is responsible for using the AEDisposeDesc function to dispose
of the resulting descriptor record once you are finished using it.
If the function returns a nonzero result code, a descriptor record with the typeNull descriptor
type is returned. A descriptor record of this type does not contain any data.
6-100

— Apple Event Manager Routines

The Apple Event Manager

Note: To avoid infinite recursion, AECoerceDesc must never be called by an
application-supplied coercion routine.
Result codes

noErr
memFullErr
errAECoercionFail

Creating

and

0
—108
—1700

Managing

Noerror
Not enough room in heap zone
Data could not be coerced to the requested
descriptor type

the Coercion

Handler Tables

The AEInstallCoercionHandler function installs a coercion handler routine in either the

application or system coercion table.
FUNCTION

AEInstallCoercionHandler

(fromType:

DescType;

handler:

ProcPtr;

toType:

DescType;

handlerRefcon:

Longint;
fromTypeIsDesc:
isSysHandler:
Boolean)
:

Boolean;
OSErr;

The fromType parameter is the descriptor type of the data coerced by the handler, and the
toType parameter is the descriptor type of the resulting data. If there was already an entry in
the specified coercion handler table for the same source descriptor type and result descriptor
type, it is replaced.
Therefore, before installing a handler for a particular descriptor type into the system coercion
table, use the AEGetCoercionHandler function to determine whether the table already contains
a handler for that descriptor type. If an entry exists, AEGetCoercionHandler returns a reference
constant and a pointer to that handler. Chain these to your coercion handler by providing
pointers to the previous handler and its reference constant in the handlerRefcon parameter of
AEInstallCoercionHandler. When your handler is finished, use these pointers to call the
previous handler. If you remove your system handler, be sure to reinstall the chained handlers.

b

The fromTypelsDesc parameter specifies the form of the data to be coerced. If its value is
TRUE, the coercion handler expects the data to be passed as a descriptor record. If its value
is FALSE, the coercion handler expects a pointer to the data to be coerced. Because it is more
efficient for the Apple Event Manager to provide a pointer to data than to a descriptor record,
all coercion routines should accept a pointer to data if possible.

i

The handlerRefcon parameter is a reference constant that is passed by the Apple Event Manager
to the handler each time the handler is called. If your handler doesn’t expect a reference constant, use 0 as the value of this parameter.

{addy 9

The handler parameter is a pointer to the coercion handler routine. Note that a handler in the
system coercion table must reside in the system heap; this means that if the value of the
isSysHandler parameter is TRUE, the handler parameter should point to a location in the
system heap. Otherwise, if you put your system handler code in your application heap, you
must remove the handler when your application quits by using the AERemoveCoercionHandler
function.

>

a)
|

oo

<=
ma

o
i]
~
ity)
©
“

Apple Event Manager Routines

6-101

Inside Macintosh, Volume VI

The isSysHandler parameter specifies the coercion table to which to add the handler. If its
value is TRUE, the handler is added to the system coercion table and made available to all

applications. If its value is FALSE, the handler is added to the application coercion table.
Note that a handler in the system coercion table must reside in the system heap; this means
that if the value of the isSysHandler parameter is TRUE, the handler parameter must point to
a location in the system heap.
Note: When an application calls a system Apple event handler, the A5 register is set
up for the calling application. For this reason, if you provide a system Apple event
handler, it should never use A5 global variables or anything that depends on a
particular context; otherwise, the application that calls the system handler may crash.
Result codes
noErr
memFullErr

0
—108

No error
Not enough room in heap zone

The AEGetCoercionHandler function returns the handler for a specified descriptor
type coercion.
FUNCTION

AEGetCoercionHandler

(fromType:
DescType;
toType:
DescType;
VAR handler:
ProcPtr;
VAR handlerRefcon:
Longint;

VAR

isSysHandler:

fromTypeIsDesc:
Boolean)

:

Boolean;

OSErr;

The fromType parameter is the descriptor type of the data coerced by the handler, while the
parameter toType is the descriptor type of the resulting data.

The function returns a pointer to the coercion handler routine in the handler parameter.
The function returns a reference constant in the handlerRefcon parameter. The Apple Event
Manager passes this reference constant to the handler each time the handler is called.
If the function returns TRUE in the fromTypelsDesc parameter, the coercion handler expects
the data to be passed as a descriptor record. If the function returns FALSE, the coercion
handler expects a pointer to the data.
The isSysHandler parameter specifies the coercion table from which to get the handler. If its
value is TRUE, the handler is taken from the system coercion table. If its value is FALSE,

the handler is taken from the application coercion table.
Result codes
noErr

memFullErr

errAEHandlerNotFound

QO

—108

-—1717

Noerror

Not enough room in heap zone
No coercion handler found

'

The AERemoveCoercionHandler function removes a coercion handler routine from either the

application or system coercion table.
FUNCTION

6-102

AERemoveCoercionHandler

Apple Event Manager Routines

(fromType:

DescType;

handler:
Boolean)

ProcPtr;
: OSErr;

toType:

DescType;

isSysHandler:

The Apple Event Manager

The fromType parameter is the descriptor type of the data coerced by the handler.
The toType parameter is the descriptor type of the resulting data.
The handler parameter is a pointer to the coercion handler routine. Although the fromType and
toType parameters would be sufficient to identify the handler to be removed, providing the
handler parameter is a safeguard to ensure that you remove the correct handler.
The isSysHandler parameter specifies the coercion table from which to remove the handler.
If its value is TRUE, the handler is removed from the system coercion table. If its value is
FALSE, the handler is removed from the application coercion table.
Result codes
noErr

Q

memFullErr

errAEHandlerNotFound

Creating

and

Managing

-108

—1717

Noerror

Not enough room in heap zone
Nocoercion handler found

the Special

Handler

Tables

The AEInstallSpecialHandler function installs a handler in a special handler table.
FUNCTION

AEInstallSpecialHandler

(functionClass:
ProcPtr;
OSErr;

AEKeyword;

isSysHandler:

handler:

Boolean)

The functionClass parameter is the keyword for the special handler that’s installed. There is
currently only one value allowed for this parameter: the keyPreDispatch constant, which
identifies a handler routine that is called immediately before the Apple Event Manager
dispatches an Apple event. If there was already an entry in the specified special handler table
for the same value of functionClass, it is replaced.
The handler parameter is a pointer to the special handler. Note that a handler in the system
handler table must reside in the system heap; this means that if the value of the isSysHandler
parameter is TRUE, the handler parameter should point to a location in the system heap.
Otherwise, if you put your system handler code in your application heap, you must remove
the handler when your application quits by using the AERemoveSpecialHandler function.
The isSysHandler parameter specifies the special handler table to which to add the handler. If
its value is TRUE, the handler is added to the system handler table and made available to all
applications. If its value is FALSE, the handler is added to the application handler table.
Note: When an application calls a system Apple event handler, the A5 register is set
up for the calling application. For this reason, if you provide a system Apple event
handler, it should never use A5 global variables or anything that depends on a
particular context; otherwise, the application that calls the system handler may crash.

nN
>

)

seb
@

—

~

<

Result codes

noErr
paramErr
memFullErr
errAENotASpecialFunction

oe

Q
—50
—108
—1714

No error
Parameter error (handler pointer is NIL or odd)
Not enough room in heap zone
Wrong keyword for a special function
Apple Event Manager Routines

6-103

oS
~”_

<<
—

=
=

~

nS
ve

[¢°)

Inside Macintosh,

Volume VI

The AEGetSpecialHandler function returns a specified special handler.
FUNCTION

AEGetSpecialHandler

VAR handler:
AEKeyword;
(functionClass:
Boolean)
isSysHandler:
ProcPtr;
OSErr;

The functionClass parameter is the keyword that specifies the desired special handler. There
is currently only one value allowed for this parameter: the keyPreDispatch constant, which
identifies a handler routine that is called immediately before the Apple Event Manager
dispatches an Apple event.
The function returns a pointer to the special handler in the handler parameter.
The isSysHandler parameter specifies the special handler table from which to get the handler.
If its value is TRUE, the handler is taken from the system handler table. If its value is FALSE,
the handler is taken from the application handler table.
Result codes
noErr
memFullErr
errAENotASpecialFunction

0
—108
—1714

No error
Not enough room in heap zone
Wrong keyword for a special function

The AERemoveSpecialHandler function removes a handler from a special handler table.
FUNCTION

AERemoveSpecialHandler

(functionClass:

AEKeyword;

handler:

isSysHandler:

Boolean)

OSErr;

:

ProcPtr;

The functionClass parameter is the keyword for the special handler to be removed. There is
currently only one value allowed for the functionClass parameter: the keyPreDispatch
constant, which identifies a handler routine that is called immediately before the Apple Event
Manager dispatches an Apple event.
The handler parameter is a pointer to the special handler to be removed. Although the
functionClass parameter would be sufficient to identify the handler to be removed, providing
the handler parameter is a safeguard to ensure that you remove the correct handler.
The isSysHandler parameter specifies the special handler table from which to remove the
handler. If its value is TRUE, the handler is taken from the system handler table. If its value
is FALSE, the handler is removed from the application handler table.
Result codes
noErr
memFullErr
errAENotASpecialFunction

6-104

QO
—108
—1714

— Apple Event Manager Routines

No error
Not enough room in heap zone
Wrong keyword for a special function

The Apple Event Manager

SUMMARY

OF THE

APPLE

EVENT

MANAGER

Constants
CONST

gestaltAppleEventsAttr

=

‘'evnt';

{selector

=

Ov

{if this bit set,
then }
{ Apple Event Mgr's available}

=

types}
"pool";

typeChar

=

SPEXTN

{unterminated

typeSMInt

=

“shor;

{16-bit

gestaltAppleEventsPresent

{Apple event
typeBoolean

descriptor

{Boolean

for

Apple

value}
string}

integer}

typeiInteger

=

‘long';

{32-bit

typeSMFloat
typeFloat

=
=

‘seing's;
'doub';

{SANE
{SANE

single}
double}

typeLongInteger
typeShort Integer
typeLongFloat
typeShortFloat

=
=
=
=

‘long’;
‘shor;
adoub';
'ging';

{SANE

extended}

typeExtended

'exte';

=

=
=

'comp';
'magn';

typeAERecord

=
=

list"s
'reco';

typeComp
typeMagnitude

events}

integer}

{32-bit integer}
{16-bit integer}
{SANE double}
{SANE single}
{SANE comp}
{unsigned 32-bit

integer}

typeAppleEvent

=

‘'aevt';

records}
of descriptor
{list
}
{list of keyword-specified
{ descriptor
records}
record}
{Apole event

typeTrue

=

Crue's

{TRUE

typeFalse

=

‘'fals';

{FALSE

=

‘'alis';

typeEnumerated
typeType

=
=

‘enum';
*ty¥pe';

typeAppParameters

=

‘appa';

typeProperty

=

typeFSS
typeKeyword
typeSectionH

=
=
=

"prop" ;
**
ties

typeAEList

typeAlias

typewildCard
typeApplSignature

{alias

Boolean

value}
value}

record}

{enumerated data}
}
for
code
{Four-character
class
or event
ID}
{ event
}
launch
Manager
{Process
{

'keyw';
'sect';

parameters}
event property}
specification}
{file system
keyword}
{Apple event
to a section record}
{handle

=,

ERR 5

{matches

=
=

'sign';
'ssid';

{application
ID}
{session

"tang;

{target

'psn

{process
{NULL or

typeSessionID
=
typeTarget ID
typeProcessSerialNumber
=
typeNull

Boolean

=

*;

'null';

{Apple

any

ID

type}

signature}
record}

serial
number}
data}
nonexistent

Summary of the Apple Event Manager

— 6-105

Inside Macintosh, Volume VI

{keywords

for

Apple

event

parameters}

=

'eoen'y

{direct

parameter}

keyErrorNumber

=

“ern;

{error

number

keyErrorString
key ProcessSerialNumber

=

"errs :
';
‘psn

string parameter}
{error
serial number param}
{process

keyDirectObject

{keywords
for Apple event
attributes}
keyTransactionIDAttr
= *tran';

{transaction

keyReturnIDAttr

ID}

=

‘rtid";

{return

ID}

keyEventClassAttr

=

*evel”;

{event

class}

keyEventIDAttr
keyAddressAttr
keyOptionalKeywordAttr

=
=
=

'evid';
*agear'’;
'‘optk';

{event ID}
{target application}
{list of optional
}

keyTimeoutAttr

=

'timo';

{

parameters

{

Apple

keyInteractLevelAttr

=

'inte';

{keywords for special
keyPreDispatch

keySelect
{event

=
=

'esrc';
‘miss';

handlers}
'phac';

Proc

}

of

ticks

the

client

}

to

Event Mgr
server to

allow

Apple

}

to bring }
foreground}

{source application}
{first required parameter
{

remaining

{

event}

in

an

Apple

}
}

‘selh';

{identifies a handler }
{ routine that is called }
{ immediately before the }
{ Apple Event Manager }
{ dispatches an Apple event}
{another selector}

'aevt';

{event

class}

kCoreEventClass

=

{
{event

the

wait}

{settings

{
{
keyEventSourceAttr
keyMissedKeywordAttr

will

for

event}

{mumber
{

Apple

class

for

core

}

events}

IDs}

kAEOpenApplication

=

‘oapp';

{event ID for
{ Application

Open }
event}

kAEOpenDocuments

=

"“sdoc? ;

{event

Open

{

kAEPrintDocuments

=

"“pdoc";

ID

for

Documents

{event
{

ID

}

event}

for

Documents

Print

=

QULE' z

{event ID for
{ Application

Quit }
event}

kAEAnswer

=

"anor";

{event

Apple

“obit';

{ replies}
{event ID for

=

{

Summary of the Apple Event Manager

Died

ID

}

event}

kAEQuitApplication

kAEApplicationDied

6-106

parameter}

for

event}

event

}

Application

}

The Apple Event Manager

{constants

{

the

for

setting

the

keyInteractLevelAttr

sendMode

parameter

attribute}

of

AESend

and

for

kAENoReply

=

$00000001;

{client

doesn't

kAEQueueReply

=

$00000002;

kAEWaitReply

=

$00000003;

{client
{ reply
{client

wants server to }
in event queue}
wants a reply and

{

will

give

want

up

}

reply}

}

processor}

kAENeverInteract

=

$00000010;

{server application should
{ not interact with user }
{ for this Apple event}

kAECanInteract

=

$00000020;

{server

{
{
kAEAlwaysInteract

=

kAECanSwitchLayer

=

kAEDont Reconnect

kAEWantReceipt

$00000030;

$00000040;

may

{constants

for

the

{server

may

{

for

user

directly

}

=

=

{don't

is

parameter

{constant
for the returnID parameter
kAutoGenerateReturnID
= -1;

{constant

for

transaction

reconnect

PPC

=

{constants
for timeout
kAEDefault Timeout
kNoTimeOut

durations}
= -l;
= -2;

the

of

}

wants

return

receipt}

AESend}

event

event

at

the

back

of

}

queue}
of

}

AECreateAppleEvent }
{tells Apple Event
Manager

}

{

to

{

return

{the

{

generate

a

unique

}

ID}

parameter

-1;

Apple

part

of

a

event

is

not

transaction}

{use default
timeout
{never
time out}

}

value}

of AEResumeTheCurrentEvent }
{don't
redispatch
the
}

{
=

there

{put event
at the
front
{ the event queue}

Bis

dispatcher
= Os

kAEUseStandardDispatch

if

sessClosedErr}

IDs}

kAnyTransactionID

{constants
for
kAENoDispatch

foreground

}

appropriate}

a

of

{put

nAttnMsg;

}

when

to

}

event

{

{
kAEHighPriority

with

Apple

{

{
nReturnReceipt;

$00000000;

interact
this

}

$00000080;

=

}

{ even if no information
{ is required}
{server should come }

=

sendPriority

with

user for this Apple event
to supply information}

{client

kAENormal Priority

interact

}

Apple

event}

—
a

—

~

—

~
—_—

Le")

{redispatch
the Apple event
}
{ by using
its entry
in the
}
event
dispatch
table}
{ Apple

—
&.

<
o
a

_

onal

a

heme

as
~

—_

—
as
~

ve
@

wee ;

Summary of the Apple Event Manager

6-107

Inside Macintosh,

Data

Volume VI

Types

TYPE

AEEventClass

PACKED

=

ARRAY[1..4]

AEEventID

=

OF

Char;

{event class
{ high-level

Char;

{event

PACKED

ARRAY[1..4]

OF

AEKeyword
PACKED

=
ARRAY[1..4]

OF

{
Char;

{keyword

for

a

descriptor

}

record}

DescType

=

AEDesc =
RECORD
descriptorType:

DescType;

{descriptor record}
{type of data being

Handle

{handle

dataHandle:

}

high-level

a

for

ID

event}

{
ResType;

for a }
event}

{descriptor

to

type}

data

passed}

being

passed}

END;
AEKeyDesc

=

{keyword-specified
}
record}
{ descriptor

RECORD
GescKey:

AEKeyword;

{keyword}

descContent:

AEDesc

{descriptor

AEAddressDesc

=

AEDesc;

{address

descriptor

record}

AEDescList

=

AEDesc;

{list

of

descriptor

records}

AERecord

= AEDescList;

{list

of

keyword-specified

record}

END;

{

AppleEvent

=

AESendMode

=

AERecord;

LongInt;

{list

AEInteractAllowed

=

=

Integer;

{

an

an

that

Apple

and

necessary

}
for

determine
event
of

how

is

sent}

an

Apple

kAEInteractWithLocal,

{what

processes

interact

}

event}

{send priority
{ event}

(kAEInteractWithSelf,
kAEInteractWithAll1) ;

— Summary of the Apple Event Manager

Apple

{flags

records}

attributes

parameters

{

6-108

of

{

{
AESendPriority

descriptor

}

with

may

}

the

user}

}

}

The Apple Event Manager

AEEventSource

=

(kAEUnknownSource,
kAELocalProcess,

kAEDirectCall,
kAESameProcess,
kAERemoteProcess) ;
of

{the source
{ event}
AEArrayType

=

(kAEDataArray,

}

Apple

kAEPackedArray,
kAEHandleArray,
kAEKeyDescArray) ;

kAEDescArray,

{type of
{ array}
AEArrayData

an

an

Apple

event

}

=

RECORD

{data
{

case AEArrayType
kAEDataArray:

for

an

Apple

event

}

array}

OF

(AEDataArray:

ARRAY[0..0]

kAEPackedArray:

OF

Integer);

(AEPackedArray:
kAEHandleArray:

PACKED

(AEHandleArray:
kAEDescArray:

ARRAY[0..0]

OF

Handle);

(AEDescArray:
kAEKeyDescArray:

ARRAY[0..0]

OF

AEDesc);

ARRAY[0O..0]

OF

AEKeyDesc);

(AEKeyDescArray:

ARRAY[0..0]

OF

Char);

END;

AEArrayDataPointer

=

EventHandlerProcPtr

*“AEArrayData;
=

ProcPtr;

{pointer
{

IdleProcPtr

=

ProcPtr;

EventFilterProcPtr

=

ProcPtr;

to

handler

an

Apple

event

{pointer
to an app's
{ idle
function}

}

{pointer

filter

{

}

routine}

to

an

app's

}

procedure}

Routines

Creating
FUNCTION

and

Managing

the Apple

AEInstallEventHandler

Event

Dispatch

(theAEEventClass:
AEEventClass;
theAEEventID:
AEEventID;
handler:
EventHandlerProcPtr;
Longint;

FUNCTION

AEGetEventHandler

Tables
=
a

handlerRefcon:

isSysHandler:

Boolean)

:

=
OSErr;

(theAEEventClass:
AEEventClass;
theAEEventID:
AEEventID;
VAR handler:
EventHandlerProcPtr;
VAR handlerRefcon:
LongInt;

isSysHandler:

Boolean)

:

OSErr;

—
<
o

~—

ad
—_

—
ove
&
oy
ee
f
f=)

a0)
_—

Summary of the Apple Event Manager

— 6-109

‘

Inside Macintosh,

FUNCTION

Volume VI

theAEEventID:
AEEventID;
handler:
EventHandlerProcPtr;
isSysHandler:

Boolean)

Dispatching

Apple

AEEventClass;

(theAEEventClass:

AERemoveEventHandler

:

OSErr;

Events

FUNCTION

AEProcessAppleEvent

Getting

Parameters

FUNCTION

AEGetParamPtr

(theEventRecord:

and Attributes

From

EventRecord)

Apple

:

OSErr;

Events

(theAppleEvent:
AppleEvent;
theAEKeyword:
AEKeyword;
desiredType:
DescType;
VAR typeCode:
DescType;
dataPtr:
Ptr;

maximumSize:

Size;

VAR

actualSize:

Size)

OSErr;
FUNCTION

AEGet

ParamDesc

(theAppleEvent:
AppleEvent;
theAEKeyword:
AEKeyword;
desiredType:
DescType;
VAR

FUNCTION

AEGetAttributePtr

result:

AEDesc)

(theAppleEvent:
AEKeyword;
VAR

:

AppleEvent;

desiredType:

typeCode:

DescType;

maximumSize:

OSErr;

Size;

VAR

theAEKeyword:

DescType;
dataPtr:

Ptr;

actualSize:

Size)

OSErr;
FUNCTION

AEGetAttributeDesc

(theAppleEvent:
AEKeyword;
VAR

AppleEvent;

desiredType:

result:

AEDesc)

:

theAEKeyword:

DescType;
OSErr;

Counting the Items in Descriptor Lists
FUNCTION

AECountItems

(theAEDescList:

LongInt)

Getting

Items From

FUNCTION

AEGetNthPtr

Descriptor

:

AEDescList;

VAR

theCount:

OSErr;

Lists

(theAEDescList:

AEDescList;

index:

LongInt;

desiredType:
DescType;
VAR theAEKeyword:
AEKeyword;
VAR typeCode:
DescType;
dataPtr:

Ptr;

maximumSize:

Size;

VAR

actualSize:

Size)

OSErr}
FUNCTION

AEGetNthDesc

(theAEDescList:

AEDescList;

desiredType:
DescType;
AEKeyword;
VAR result:

6-110

Summary of the Apple Event Manager

index:

LongInt;

VAR theAEKeyword:
AEDesc)
: OSErr;

The Apple Event Manager

FUNCTION

AEGetArray

(theAEDescList:

AEDescList;

AEArrayType;

arrayPtr:

maximumSize:

Size;

Getting Data and Keyword-Specified
From AE Records
FUNCTION

AEGetKeyPtr

(theAERecord:

Descriptor

AERecord;

FUNCTION

AEGetKeyDesc

actualSize:

(theAERecord:

Size)

AERecord;

AEKeyword;
desiredType:
AEDesc)
: OSErr;

Requesting

User

LongInt)

itemCount:

VAR

Records

theAEKeyword:

desiredType:
DescType;
VAR
dataPtr:
Ptr;
maximumSize:
VAR

DescType;

itemType:

VAR

Size;

VAR itemSize:
OSErr;

arrayType:

AEArrayDataPointer;

:

AEKeyword;

typeCode:
Size;

DescType;

OSErr;
theAEKeyword:
DescType;

VAR

result:

Interaction

FUNCTION

AESetInteractionAl
lowed

(level:

FUNCTION

AEGetInteractionAl
lowed

(VAR

AEInteractAllowed)

level:

AEInteractAl

:

OSErr;

lowed)

OSErr;

FUNCTION

AEInteractWithUser

(timeOutInTicks:
NMRecPtr;

LongInt;

idleProc:

nmReqPtr:

IdleProcPtr)

OSErr;

FUNCTION

More Time to Respond

AEResetTimer

Suspending

and

to Apple

(reply:

Resuming

Apple

Events

AppleEvent)

:

OSErr;

Event Handling

FUNCTION

AESuspendTheCurrentEvent

(theAppleEvent:

AppleEvent)

FUNCTION

AEResumeTheCurrentEvent

(theAppleEvent,reply:

:

OSErr;

AppleEvent;

AESetTheCurrentEvent

(theAppleEvent:

FUNCTION

AEGetTheCurrentEvent

(VAR

AppleEvent)

:

OSErr;

i

a

FUNCTION

9

dispatcher:
EventHandlerProcPtr;
handlerRefcon:
LongInt)
: OSErr;

jaddy

Requesting

theAppleEvent:

<
@

AppleEvent)

—

—

_

OSErr;

rd=
+)
_—

—)

et)
ge
(ee)
me :

Summary of the Apple Event Manager

6-111

Inside Macintosh,

Creating

Volume VI

Apple

Events
AEEventClass;
(theAEEventClass:
target:
AEEventID;
theAEEventID:
Integer;
returnID:
AEFAddressDesc;

AECreateAppleEvent

FUNCTION

transactionID:
:

AppleEvent)

Creating
FUNCTION

and

Duplicating

AECreateDesc

FUNCTION

AEDuplicateDesc

Descriptor

result:

VAR

LongInt;
OSErr;

Records

(typeCode:

DescType;

Size;

VAR

result:

AEDesc)

dataPtr:

(theAEDesc:

AEDesc;

VAR

Ptr;

:

dataSize:

OSErr;

result:

AEDesc)

OSErr;

Creating
FUNCTION

Descriptor
AECreateList

Lists and AE

Records

(factoringPtr:
isRecord:

Ptr;

Boolean;

factoredSize:
VAR

Size;

resultList:

AEDescList)

OSErr;

Adding

Items to Descriptor Lists

FUNCTION

AEPutPtr

(theAEDescList:
AEDescList;
index:
typeCode:
DescType;
dataPtr:
Ptr;
Size)
: OSErr;

LongInt;
dataSize:

FUNCTION

AEPutDesc

(theAEDescList:

LongInt;

theAEDesc:

FUNCTION

AEPutArray

AEDescList;

AEDesc)

(theAEDescList:

FUNCTION

AEPutKeyPtr

itemType:

DescType;
LongInt)

Keyword-Specified

(theAERecord:
typeCode:

Size)
FUNCTION

AEPutKeyDesc

:

arrayType:

AEArrayDataPointer;

itemSize:
:

AERecord;

Size;

OSErr;

Descriptor

DescType;

Records

theAEKeyword:

dataPtr:

Ptr;

(theAERecord:

Summary of the Apple Event Manager

AERecord;
theAEDesc:

theAEKeyword:
AEDesc)

:

AEKeyword;

dataSize:

OSErr;

AEKeyword;

6-112

arrayPtr:

itemCount:

index:

OSErr;

AEDescList;

AEArrayType;

Adding Data and
to AE Records

:

OSErr;

The Apple Event Manager

Adding

Parameters

FUNCTION

AEPutParamPtr

FUNCTION

and Attributes to Apple
(theAppleEvent:

AppleEvent;
theAEKeyword:
AEKeyword;
typeCode:
DescType;
dataPtr:
dataSize:
Size)
: OSErr;

AEPutParamDesc

(theAppleEvent:
AEKeyword;

FUNCTION

AEPutAttributePtr

(theAppleEvent:

Size)

(theAppleEvent:
AEKeyword;

Sending
FUNCTION

Apple

:

Ptr;

theAEKeyword:

AEDesc)

AppleEvent;

typeCode:

GataSize:
AEPutAttributeDesc

AppleEvent;

theAEDesc:

AEKeyword;

FUNCTION

Events

:

OSErr;

theAEKeyword:

DescType;

dataPtr:

Ptr;

OSErr;

AppleEvent;

theAEDesc:

theAEKeyword:

AEDesc)

:

OSErr;

Events

AESend

(theAppleEvent:

AppleEvent;

VAR

reply:

AppleEvent;
sendMode:
AESendMode;
sendPriority:
AESendPriority;
timeOutInTicks:
LongInt;
idleProc:

IdleProcPtr;

EventFilterProcPtr)

Getting

the Sizes

and

FUNCTION

AESizeOfNthItem

Descriptor

Types

:

filterProc:

OSErr;

of Descriptor

(theAEDescList:

AEDescList;

VAR

DescType;

typeCode:

index:

VAR

Records
LonglInt;

dataSize:

Size)

OSErr;
FUNCTION

AESizeOfKeyDesc

(theAERecord:
AEKeyword;

VAR
FUNCTION

FUNCTION

AESizeOfParam

AESizeOfAttribute

Descriptor

dataSize:

:

DescType;

OSErr;

VAR

Size)

dataSize:

:

OSErr;

(theAppleEvent:

AppleEvent;

AEKeyword;

typeCode:

VAR

dataSize:

Size)

:

theAEKeyword:
DescType;

OSErr;

Records

=
>

AEDeleteItem

(theAEDescList:

FUNCTION

AEDeleteKeyDesc

(theAERecord:

OSErr;

AEKeyword)
AEDeleteParam

Size)

AppleEvent;
theAEKeyword:
typeCode:
DescType;

FUNCTION

FUNCTION

theAEKeyword:

typeCode:

(theAppleEvent:
AEKeyword;
VAR

VAR

Deleting

AERecord;
VAR

AEDescList;
AERecord;

:

index:

[=

LongInt)

=

ie

theAEKeyword:

s

OSErr;

(theAppleEvent:
AppleEvent;
AEKeyword)
: OSErr;

ys
theAEKeyword:

Summary of the Apple Event Manager

=
e

6-113

Inside Macintosh, Volume VI

Deallocating

Memory

AEDisposeDesc

FUNCTION

Coercing
FUNCTION

Records

for Descriptor
(VAR

OSErr;

:

AEDesc)

theAEDesc:

Descriptor Types

AECoercePtr

(typeCode:
DescType;
dataPtr:
Size;
toType:
DescType;
VAR

Ptr;
dataSize:
result:
AEDesc)

OSErr;
FUNCTION

AECoerceDesc

(theAEDesc:
result:

Creating
FUNCTION

and

Managing

AEDesc;

AEDesc)

:

the Coercion

AEInstallCoercionHandler

toType:

AEGetCoercionHandler

(fromType:
handler:

DescType;
toType:
DescType;
ProcPtr;
handlerRefcon:

Longint;

fromTypeIsDesc:

(fromType:
VAR
VAR
VAR

AERemoveCoercionHandler

Creating
FUNCTION

and

Managing

DescType;

(fromType:

AEGetSpecialHandler

Boolean)

:

AERemoveSpecialHandler

toType:

DescType;

:

OSErr;

toType:

DescType;

isSysHandler:

OSErr;

(functionClass:

AEKeyword;

isSysHandler:

handler:

Boolean)

(functionClass: AEKeyword;
VAR handler:
ProcPtr;
isSysHandler:
:

OSErr;

(functionClass:
ProcPtr;
OSErr;

6-114

OSErr;

Handler Tables

Boolean)
FUNCTION

DescType;
ProcPtr;

ProcPtr;
OSErr;

FUNCTION

Boolean;
:

Boolean)

handler:

the Special

AEInstallSpecialHandler

Boolean)

handler:
ProcPtr;
handlerRefcon:
LongInt;
fromTypeIsDesc:
Boolean;

isSysHandler:
FUNCTION

VAR

Handler Tables

isSysHandler:
FUNCTION

DescType;

OSErr;

Summary of the Apple Event Manager

AEKeyword;

isSysHandler:

handler:

Boolean)

The Apple Event Manager

Application-Defined
FUNCTION

Routines

MyEventHandler

(theAppleEvent :
handlerRefcon:

FUNCTION

MyIdleFunction

(VAR

AppleEvent;
Longint)
:

theEventRecord:

MyWaitReplyFilter

(VAR

theEventRecord:

returnID:

sender:
FUNCTION

MyCoercePtr

VAR

mouseRgn:

EventRecord;

transactionID:
AEAddressDesc)
: Boolean;

(typeCode:

LongInt;

DescType;

AppleEvent;

EventRecord;

VAR sleepTime:
Longint;
RgnHandle)
: Boolean;
FUNCTION

reply:
OSErr;

dataPtr:

Ptr;

LongInt;

dataSize:

Size;
toType:
DescType;
handlerRefcon:
Longint;
VAR result:
AEDesc)
: OSErr;
FUNCTION

MyCoerceDesc

(theAEDesc:

AEDesc;

handlerRefcon:
OSErr;

Result

toType:

LongInt;

VAR

DescType;
result:

AEDesc)

Codes

noErr
paramErr
memFullErr
bufferlsSmall
noOutstandingHLE
connectionInvalid
errAECoercionFail

0
—50
—108
-607
—608
—609
—1700

errAEDescNotFound
errAECorruptData
errAEWrongDataT ype
errAENotAEDesc
errAEBadListltem
errAENewerVersion
errAENotAppleEvent
errAEEventNotHandled
errAEReplyNotValid
errAEUnknownSendMode
errAEWaitCanceled
errAETimeout
errAENoUserInteraction
errAENotASpecialFunction
errAEParamMissed
errAEUnknownAddressType
errAEHandlerNotFound
errAEReplyNotArrived
errAEIIlegalIndex

—1701
—1702
—1703
—1704
—1705
-1706
—1707
—1708
—1709
-1710
—1711
—1712
-1713
-1714
-—1715
—1716
-1717
—1718
-1719

Noerror
Parameter error (handler pointer is NIL or odd)
Not enough room in heap zone
Buffer is too small
No outstanding high-level event
Connection is invalid
Data could not be coerced to the requested
descriptor type
Descriptor record was not found
Data in an Apple event could not be read
Wrong descriptor type
Nota valid descriptor record
Operation involving a list item failed
Need a newer version of the Apple Event Manager
Event is not an Apple event
Event wasn’t handled by an Apple event handler
AEResetTimer was passed an invalid reply
Invalid sending mode was passed
User canceled out of wait loop for reply or receipt
Apple event timed out
Nouser interaction allowed
Wrong keyword fora special function
Handler did not get all required parameters
Unknown Apple event address type
No handler found for an Apple event or a coercion
Reply has not yet arrived
Nota valid list index

=
a
=
_
PS
=
=
=
ga

Summary of the Apple Event Manager

6-115

Inside Macintosh,

Volume VI

Assembly-Language
Trap

Macros

Information

Requiring

Routine

Selectors

_Pack8&
Selector

Routine

SOLIE
$0204
$0219
$021A
$021B
$021D

AESetInteractionAllowed

$022C
$0405
$0407
$040E
$0413
$0413
$0500

AESetTheCurrentEvent

$022B

$0501

$052D

$0603

$0609
$0610
$0610
$061C
$0627
$0706
$0720
$0723
$0812
$0812
$0818
$0825
$0826
$0828
$0829
$0829
$082A
$091F
$0921
$0A02
$0A08
$OA16
$0A22

$0A0B

$OAO0F

AEDisposeDesc

AEResetTimer
AEGetTheCurrentEvent

AEProcessAppleEvent

AEGetInteractionAllowed

AESuspendTheCurrentEvent
AEDuplicateDesc
AECountltems
AEDeleteltem

AEDeleteKeyDesc
AEDeleteParam

AEInstallSpecialHandler
AERemoveSpecialHandler
AEGetSpecialHandler
AECoerceDesc
AEPutDesc

AEPutKeyDesc

AEPutParamDesc
AEInteractWithUser
AEPutAttributeDesc
AECreateList
AERemoveEventHandler
AERemoveCoercionHandler

AEGetKeyDesc

AEGetParamDesc
AEResumeTheCurrentEvent
AECreateDesc
AEGetAttributeDesc
AESizeOfAttribute

AESizeOfKeyDesc

AESizeOfParam
AESizeOfNthItem
AEInstallEventHandler
AEGetEventHandler
AECoercePtr
AEPutPtr
AEPutAttributePtr
AEInstallCoercionHandler
AEGetNthDesc

AEPutKeyPtr

$OAOF

$0BOD

AEPutParamPtr
AEPutArray

6-116

Summary of the Apple Event Manager

The Apple Event Manager

Selector

$0B 14

$0B24
$0D0C
$0D17
$0E11
$0E11
$OEI5

$100A

Routine

AECreateAppleEvent

AEGetCoercionHandler

AEGetArray
AESend

AEGetKeyPtr

AEGetParamPtr
AEGetAttributePtr
AEGetNthPtr

>)
~

~~
)

Acs
@

cs!
4

<

oO

=—

2ee
a)
=
=

ge
@
er |

Summary of the Apple Event Manager

6-117

THE PROGRAM-TO-PROGRAM
COMMUNICATIONS TOOLBOX
About This Chapter
About the PPC Toolbox
Ports, Sessions, and Message Blocks
Setting Up Authenticated Sessions
Using the PPC Toolbox
PPC Toolbox Calling Conventions
Specifying Port Names and Location Names
Opening a Port
Browsing for Ports Using the Program Linking Dialog Box
Obtaining a List of Available Ports
Preparing for a Session
Initiating a PPC Session
Receiving Session Requests
Accepting or Rejecting Session Requests
Exchanging Data During a PPC Session
Reading Data From an Application
Sending Data to an Application
Ending a Session and Closing a Port
Invalidating Users
PPC Toolbox Routines
The PPC Toolbox Parameter Block and Completion Routine
Initializing the PPC Toolbox
Using the Program Linking Dialog Box
Obtaining a List of Ports
Opening and Closing a Port
Starting and Ending a Session
Receiving, Accepting, and Rejecting a Session
Reading and Writing Data
Locating a Default User and Invalidating a User
Summary of the PPC Toolbox

|
—_—
w
—
w

)
pe
S

2

=:
A

The PPC Toolbox

ABOUT

THIS

CHAPTER

This chapter describes how you can use the Program-to-Program Communications (PPC)
Toolbox to send and receive low-level message blocks between applications.
The PPC Toolbox can be used by different applications located on the same computer or
across a network of Macintosh® computers. The PPC Toolbox is available only in system
software version 7.0. To test for the existence of the PPC Toolbox, use the Gestalt function,
described in the Compatibility Guidelines chapter of this volume.
Read this chapter if you want your application to transmit and receive data from other applications that support the PPC Toolbox. Applications that utilize the PPC Toolbox must be open
and connected to each other to exchange data. The PPC Toolbox allows you to send large
amounts of data to other applications; it is typically useful for code that is not event-based.
The PPC Toolbox is called by the Macintosh Operating System and can also be called by
applications, device drivers, desk accessories, or other programs.
The PPC Toolbox provides a method of communication that is particularly useful for applications that are specifically designed to work together and are dependent on each other for
information. For example, suppose one user organizes large amounts of data using a database
application and another user filters and plots the same data using a plotting application. If
both applications use the PPC Toolbox, these two applications can directly transmit data to
each other when both applications are open and connected to each other.
You can also use the PPC Toolbox if your application communicates with other applications
using high-level events or Apple® events, and your application allows the user to choose
another application to communicate with. You can use a PPC Toolbox routine that provides a
standard user interface to display a dialog box on the user’s screen that lists other applications
that are available to exchange information. See “Browsing for Ports Using the Program
Linking Dialog Box” later in this chapter for detailed information. Elsewhere in this volume,
see the Events Manager chapter for information on high-level events, and see the Apple Event
Manager chapter for information on Apple events.
The PPC Toolbox uses the AppleTalk® Data Stream Protocol (ADSP) and the Name-Binding
Protocol (NBP). For detailed information on ADSP, see the AppleTalk Manager chapter in
this volume. For further information on NBP, see the AppleTalk Manager chapters in
Volume I, Volume V, and this volume.
Note: The sample applications “store data,” “display data,” “send and receive,”
“make memo,” and “spell quick” used in this chapter are not actual products of Apple
Computer, Inc. They are used for illustrative purposes only.
>

~I
—

S
~

—

OQ
=

About This Chapter

7-3

°

2

4
x

Inside Macintosh,

Volume VI

ABOUT

PPC

THE

TOOLBOX

The PPC Toolbox provides you with the ability to
= exchange data with other open applications on the same computer or across a network of
Macintosh computers
a browse through a listing of applications that are available to exchange data
m verify user identities for communication across a network
To utilize the PPC Toolbox to exchange data between open applications, each application
involved must support the PPC Toolbox.
This chapter first defines the main elements of the PPC Toolbox and then discusses how to
m set up your application for communication
m use security features prior to establishing communication
= locate other applications that can exchange data
m initiate communication between applications
m accept or reject incoming communications requests
m transmit and receive data between applications
= terminate communication between applications

PORTS,

SESSIONS,

AND

MESSAGE

BLOCKS

To initiate communication between applications, you must first open a port. A port is a portal
through which your application can exchange information with another application. A port is
designated by a port name and a location name.
A port name is a unique identifier for a particular application on a computer. The port name
contains a name string, a type string, and a script code for localization. The location name
identifies the location of the computer on the network. The location name contains an object
string, a type string, and a zone. An application can specify an alias location name by
modifying its type string.
Your application can open as many ports as it requires as long as each port name is unique
within a particular computer. See “Specifying Port Names and Location Names” later in this
chapter for detailed information on port names and location names.

7-4

Ports, Sessions, and Message Blocks

The PPC Toolbox

Through its port, an open application can communicate with another open application during a
session. One port can support any number of communication sessions. During a session, an
application sends and receives data in the form of a message block. The PPC Toolbox treats
each block of data as a byte stream and delivers it in the same sequence in which it was sent.
The words port name, location name, session, and message block are programmatic terms.
You should not use them in the user interface of your application or in your user documentation. Instead, refer to a file that contains executable code as an application program. An
application program that opens and uses PPC ports supports program linking. When you link
two application programs together, you are forming a program link. A link allows two application programs to communicate with each other—you unlink two application programs
when you break the link between them. You can compare the link between two application
programs to the communication established using telephones. For example, a program link is

similar to a telephone connection that enables various forms of communication such as

human-to-human, modem-to-modem, and facsimile machine-to—facsimile machine.

Figure 7-1 shows a database application on one computer that has initiated a session with a
spreadsheet application located on another computer on the network.

Port name

store data,

|

Port name
display data,

L database
PPC

Toolbox

ES

/

PPC Toolbox

Session

)

—

Location name

Location name

|

Jane Doe’s Macintosh:PPCToolBox
@ twilight

Joe Smith’s Macintosh:PPCToolBox
@ loading

Figure 7-1. A PPC Toolbox session between two applications
The database application’s port name consists of “store data” (the name string) and “database”
(the type string). Its location name consists of “Jane Doe’s Macintosh” (the object string),
“PPCToolBox” (the type string), and “twilight” (the AppleTalk zone).
The spreadsheet application’s port name consists of “display data” (the name string) and
“spreadsheet” (the type string). Its location name consists of “Joe Smith’s Macintosh”
(the object string), “PPCToolBox” (the type string), and “loading” (the AppleTalk zone).
~]
—
A
en
J

O
—
~
4

Ports, Sessions, and Message Blocks

7-5

i)
—

—_
—_
onl
~

“”

5

Inside Macintosh,

SETTING

UP

Volume VI

AUTHENTICATED

SESSIONS

Network communication must be active to initiate sessions with other computers across a
network. The user must activate AppleTalk in the Chooser and enable program linking
using the Sharing Setup icon located in the Control Panels folder inside the System Folder.
Figure 7-2 displays the Sharing Setup icon.

ie
Sharing Setup

Figure 7-2. The Sharing Setup icon
Figure 7-3 shows the Sharing Setup control panel that the Finder™ displays when the user
opens the Sharing Setup icon.
EC]

Sharing Setup ae
Network

Identity

Owner Name:

| Jane Doe

Owner Password: [eoccccee

Macintosh Name:

(Stop

}

}
|

| Jane Doe's Macintosh

: File sharing is on, Click Stop to prevent other
i users from accessing shared folders.

Program linking is on. Click Stop to prevent other

i users from linking to your shared programs.

Figure 7-3. The Sharing Setup control panel
To permit other computers to initiate sessions with the owner’s computer, the owner of the
computer must click the Start button underneath Program Linking (Start toggles with Stop).
The Sharing Setup control panel then indicates “Program linking is on. Click Stop to prevent
other users from linking to your shared programs.” To prevent other computers from
initiating sessions, an owner simply clicks Stop underneath Program Linking. The Sharing
Setup control panel then indicates “Program linking is off. Click Start to allow other users to
link to your shared programs.” Clicking the Start or Stop button also enables or disables the
transmission of incoming Apple events across the network.
If a user clicks the Stop button while there are active incoming sessions (sessions initiated by

other users), an alert box (shown in Figure 7-4) appears on the user’s screen.

7-6

Setting Up Authenticated Sessions

The PPC Toolbox

There are users Currently linked to your
programs, and the links will be
immediately broken.

Figure 7-4. The session termination alert box
If a user clicks OK, all active sessions initiated by other users are immediately terminated.
Note that it is still possible for the owner of the computer to initiate sessions, even though
other users may not initiate sessions with the owner’s computer.
The PPC Toolbox establishes the identity of users through the process of authentication.
The authentication mechanism of the PPC Toolbox identifies each user through an assigned
name and password. Each session initiated with a port that is located on a remote computer
requires authentication (unless guest access is enabled) before a session is permitted.
Sessions between applications located on the same computer never require authentication.
A computer’s owner can establish access for other users and guests by opening the users and
groups icon located in the Control Panels folder. When an owner opens the users and groups
icon, the Finder displays the users and groups control panel. The users and groups control
panel allows an owner to specify the names and passwords of other users whose computers
can initiate sessions with his or her ports across the network. When the computer’s owner
opens the users and groups control panel, the Guest icon appears. If the owner’s name is
specified in the Sharing Setup control panel, an icon with the owner’s name also appears.
To specify a particular new user, the owner chooses New User from the File menu. The
owner should type in the user’s name. When the owner opens a user icon in the users and
groups control panel, the Finder displays the users and groups dialog box on the owner’s
screen. Figure 7-5 shows the users and groups dialog box for a particular user.
(BOS

|

Jane Doe Sz)

File Sharing

A

&

Allow User to Connect

[X] Allow User to Change Password
&) Allow User to See Entire Volume

a]

I>

Groups:

eS

Program
&

Linking

Allow remote users to
link to programs on this Macintosh
~I

~~
rr

Figure 7-5. The users and groups dialog box
Setting Up Authenticated Sessions

J

©
ae

7-7

©

=
-F
x

Inside Macintosh,

Volume VI

To permit authenticated session requests, the owner can specify a password for each user.
The owner allows other users to utilize the PPC Toolbox by clicking the check box under
Program Linking. If the owner clicks the check box again, all active sessions initiated by
this particular user are immediately terminated. The user termination alert box (shown in
Figure 7-6) is displayed as a warning.

"Jane Doe" is currently connected to this
Macintosh, and will be immediately
disconnected.

Figure 7-6. The user termination alert box
When the owner opens a Guest icon in the users and groups control panel, the Finder
displays the guest dialog box on the owner’s screen. Authentication is not required if the
owner permits guest access. Figure 7-7 shows the guest dialog box.
O
|

<Guesb

File Sharing

i

(_] Allow guests to connect

eS

Program

Linking

&X] Allow guests to link

to programs on this Macintosh

Figure 7-7. The guest dialog box
By clicking the check box under Program Linking, the owner permits guests to communicate
using the PPC Toolbox or Apple events.
As an example of the authentication process, one user might decide to make a dictionary service
available to other users. Another user may wish to employ this service in a word-processing
program. Assuming both programs support the PPC Toolbox, the word-processing program
attempts to gain access to the dictionary service that is open on the other user’s computer by
initiating a session. When the word-processing application requests a session, the PPC Toolbox
attempts to authenticate the user by requesting a user name and a password (unless guest access
is enabled). If the authentication process verifies the user’s identity and the dictionary application accepts the request for a session, a session is established and the user can access the dictionary’s data.
Figure 7-8 illustrates the authentication process that occurs when a user attempts to initiate
a session.

7-8

Setting Up Authenticated Sessions

The PPC Toolbox

Macintosh computer

Macintosh computer

Authentication

|

PPC Toolbox

|

=|

PPC Toolbox

Figure 7-8. The PPC Toolbox authentication process

USING THE

PPC TOOLBOX

This section describes
a PPC Toolbox calling conventions
m Opening a port

a listing all available port locations on the network
= indicating that a port is available to accept session requests
m initiating a session
m accepting and rejecting session requests
m reading and writing data during a session
m ending a session after data is transmitted and received
a closing a port when it is no longer needed to transmit or receive data
a invalidating users
To begin, you must determine whether the PPC Toolbox is available on the user’s computer
system by using the Gestalt function. The Gestalt selector is gestaltPPCToolboxAttr. A noErr
result code indicates that the PPC Toolbox is present.
—

i)

—

w
‘CD

—

Using the PPC Toolbox

7-9

=~
=
~
~
—
—
~
~
~

”~

Inside Macintosh,

Volume VI

The Gestalt function returns a combination of the following constants: gestaltPPCToolboxPresent,
gestaltPPCSupportsRealTime, gestaltPPCSupportsOutGoing, and gestaltPPCSupportsIncoming.
The PPC Toolbox currently supports only sessions in real time. The Gestalt function returns
gestaltPPCSupportsRealTime by default. If this bit is not set, you need to initialize the PPC

Toolbox.

The Gestalt function returns gestaltPPCSupportsOutGoing to indicate support of outgoing
sessions across a network of Macintosh computers. If this bit is not set, the user hasn’t
enabled AppleTalk in the Chooser.
The Gestalt function returns gestaltPPCSupportsIncoming if the user has enabled program

linking in the Sharing Setup control panel. If this bit is not set, the user either hasn’t enabled

AppleTalk in the Chooser or hasn’t enabled program linking in the Sharing Setup control panel.
Use the PPCInit function to initialize the PPC Toolbox.
err

:=

PPCInit;

Listing 7-1 illustrates how you use the PPCInit function to initialize the PPC Toolbox.
Listing 7-1. Initializing the PPC Toolbox using the PPCInit function
FUNCTION

MyPPCInit

:

OSErr;

VAR

PPCAttributes:

LongInt;

err:

OSErr;

BEGIN {myPPCInit}
err := Gestalt (gestaltPPCToolboxAttr,
IF

err

=

THEN

PPCAttributes) ;

noErr
{PPC

Toolbox

is

present}

BEGIN

IF

BAND(PPCAttributes,
THEN

{PPC

Toolbox

gestaltPPCSupportsRealTime)
needs

=

0

initialization}

BEGIN

{initialize
err

<=

{test
err

the

PPC

Toolbox

and

set

function

result}

PPCINit:
the

:=

attributes

Gestalt

for

the

PPC

Toolbox}

(gestaltPPCToolboxAttr,
PPCAttributes) ;

END;

IF

BAND(PPCAttributes,

gestaltPPCSupportsOutGoing)

<>

0

you

may

THEN
{ports

7-10

can

be

ELSE;
{it's

likely

{

want

to

{

the

tell

Chooser}

Using the PPC Toolbox

opened
that
the

to

the

AppleTalk
user

to

outside
is

world}

disabled,

activate

so

AppleTalk

from

}
}

The PPC Toolbox

IF

BAND(PPCAttributes,

gestaltPPCSupportsIncoming)

<>

0

THEN

{ports

{

can

outside

be

opened

world

location

names

program

linking

is

the

to

can

with

that

the

}

disabled,

so

you

program

linking

see}

ELSE;

{it's

likely

{

may

want

{

from

the

that

to

tell

Sharing

user

Setup

start

control

}

}

panel}

END;

MyPPCInit
END;

:=

err;

{MyPPCInit}

Figure 7-9 illustrates a database application (on the left) that has initiated a session with a

spreadsheet application (on the right) to exchange data using the PPC Toolbox. This figure
includes an example of the sequence of PPC Toolbox routines executed by these applicdtions.
Detailed descriptions of the functions appear in the sections that follow.

ao

PPCBrowser
StartSecureSession

|

=>
———>

prc

ppc | +

Toolbox

Toolbox

|PRcopeni

=
~<— _

PPCAccept

Prone

peel:

—>

<——

|
—
=< — PPCWrite

PPCEnd

9 ——>

<—

PPCRead

cee

ppcEnd

+ Ppa

~I

Figure 7-9. Database and spreadsheet applications using the PPC Toolbox

_

7
vent

ww

©

—_

Using the PPC Toolbox

7-11

©

[—)

7
—)
vA

Inside Macintosh, Volume VI

To establish a session, each application must first open a port using the PPCOpen function.
The spreadsheet application prepares to receive session requests by calling the PPCInform
function.
Before initiating a session or opening a port, the database application can let the user browse
through the list of available ports (using the PPCBrowser function). If the user decides to
communicate with the spreadsheet application, the database application initiates a session with
the spreadsheet application’s port using the StartSecureSession function. After the PPC
Toolbox authenticates the user name and password of the initiating port, the spreadsheet
application accepts the session request (using the PPCAccept function).
Once the session is established, the applications exchange information in the form of message
blocks (using the PPCRead and PPCWrite functions). During a session, an application can
both read from and write message blocks to another application. After the information

exchange is done, each application ends the session (PPCEnd) and then closes its port
(PPCClose) when it quits.

The PPCOpen function returns a port reference number. The port reference number is a
reference number for the port through which you are requesting a session. The database
application uses the port reference number in subsequent calls to the StartSecureSession
and PPCClose functions. The StartSecureSession function returns a session reference
number. The session reference number is used to identify the session during the exchange

of data. It is used in subsequent calls to the PPCWrite, PPCRead, and PPCEnd functions.

The PPCOpen function returns a port reference number that the spreadsheet uses in
subsequent calls to the PPCInform and PPCClose functions. The PPCInform function
returns a session reference number that is used in subsequent calls to the PPCAccept,
PPCRead, PPCWrite, and PPCEnd functions.

PPC

Toolbox

Calling Conventions

Most PPC Toolbox functions can execute synchronously (meaning that the application cannot
continue until the function completes execution) or asynchronously (meaning that the application is free to perform other tasks while the function is executing). The PPC Toolbox functions
that can only be executed synchronously include PPCInit, PPCBrowser, StartSecureSession,
DeleteUserldentity, and GetDefaultUser. All other PPC Toolbox functions can execute
asynchronously or synchronously. Here’s an example:
FUNCTION

MyPPCFunction

(pb:

PPCParamBlockPtr;

async:

Boolean)

:

OSErr;

The pb parameter should point to a PPC parameter block. The async parameter is TRUE if
the function is to be executed asynchronously.
Note: The PPCInform, PPCRead, and PPCWrite functions should always be
executed asynchronously, because they require interaction from the other application
in the session before they complete execution.
The PPCParamBlockRec data type defines the PPC parameter block.

7-12

Using the PPC Toolbox

The PPC Toolbox

TYPE

PPCParamBlockRec

=

RECORD

CASE

Integer

OF

0:
1:

(openParam:
(informParam:

PPCOpenPBRec) ;
PPCInformPBRec)

2:

(startParam:

PPCStartPBRec)

3:
4;

(acceptParam:
(rejectParam:

PPCAccept PBRec)
PPCRejectPBRec)

5:
6:
7:

(writeParam:
(readParam:
(endParam:

PPCWritePBRec) ;
PPCReadPBRec) ;
PPCEndPBRec) ;

{PPCWrite params}
{PPCRead params}
{PPCEnd params}

8:

(closeParam:

PPCClosePBRec)

{PPCClose

9:

(listPortsParam:

IPCListPortsPBRec)

;

;

{PPCOpen params}
{PPCInform params}

{PPCStart
;
;

;

{PPCAccept
{PPCReject

params}
params}
params}

params}

{IPCListPorts
{

}

params}

END;

Your application transfers ownership of the PPC parameter block (and any buffers or records
pointed to by the PPC parameter block) to the PPC Toolbox until a PPC function completes
execution. Once the function completes, ownership of the parameter block (and any buffers
or records it points to) is transferred back to your application. If a PPC Toolbox function is
executed asynchronously, your program cannot alter memory that might be used by the PPC
Toolbox until that function completes.
A PPC Toolbox function that is excuted asynchronously must specify NIL or the address of a
completion routine in the ioCompletion field of the PPC parameter block. You should use the
ioResult field to determine the actual result code when an asynchronously executed PPC
Toolbox function completes.
If you specify NIL in the ioCompletion field, you should poll the ioResult field of the PPC
parameter block after the function is called in order to determine whether the PPC function
has completed the requested operation. You should poll the ioResult field within the event
loop of your application. If the ioResult field contains a value other than |, the function has
completed execution. Note that you must not poll the ioResult field at interrupt time to
determine whether the function has completed execution.
If you specify a completion routine in the ioCompletion field, it is called at interrupt time
when the PPC Toolbox function completes execution.
A

Warning: Completion routines execute at the interrupt level and must preserve
all registers other than AO, Al, and DO-D2. (Note that MPW® C and MPW
Pascal do this automatically.) Your completion routine must not make any calls to
the Memory Manager directly or indirectly, and it can’t depend on the validity of
handles to unlocked blocks. The PPC Toolbox preserves the application global
register A5. a

You can write completion routines in C, Pascal, or assembly language.
declared in Pascal has this format:
PROCEDURE

MyCompletionRoutine

(pb:

A completion routine

PPCParamBlockPtr) ;

x)

The pb parameter points to the PPC parameter block passed to the PPC Toolbox function.

~

ro

OQ
|

Using the PPC Toolbox

7-13

°
cs
-¥
Po

Inside Macintosh, Volume VI

You may call another PPC Toolbox function from within a completion routine, but the function called must be executed asynchronously. It is recommended that you allocate parameter
blocks of data type PPCParamBlockRec so that you may reuse the pb parameter to call
another PPC Toolbox function from within a completion routine. For example, you should
call either the PPCAccept function or the PPCReject function asynchronously from within a
PPCInform completion routine to accept or reject the session request.
If your application is executing PPC Toolbox functions asynchronously, you may want to
define your own record type to hold all data associated with a session. You can attach the
data to the end of the parameter block. Here’s an example:
TYPE

SessRecHndl
= “SessRecPtr;
SessRecPtr
= “SessRec;
SessRec

=

RECORD
pb:

PPCParamBlockRec;

thePPCPortRec:
theLocationNameRec:

PPCPortRec;
LocationNameRec;

theUserName:

Stxr32

{must

be

first

item

in

record}

END;

The additional data elements in your record can be accessed during execution of a completion
routine by coercing the pb parameter to a pointer to your record type.

Specifying

Port Names

and

Location

Names

Before initiating a session, you must open a port to communicate with other programs. A
port name and location name identify each port. An application can open as many ports as
it requires as long as each port name is unique within a particular computer. You specify
both the port name and the location name in the PPC parameter block.
Figure 7-10 illustrates a single Macintosh computer with two applications, and their
corresponding port names and location names.
To open a port, you need to specify a port name. A port name consists of a name string, a
type string, and a script code for localization. For example, you can designate “make memo”
as the application’s name string, “word processor” as its type string, and ““smRoman” as its
script code.
A port name is defined by a PPC port record. The PPC port record contains a script code,
name string, port kind selector, and type string. The script code is an integer script identifier
used for localization. The name string consists of a 32-byte character string that designates
the application name. You should keep both the script code and the name string in a resource.
The port kind selector is an integer that selects the kind of type string. You should make
it consistent internationally. The type string can be either a 32-byte character string or a
4-character creator and a 4-character application type. See the Finder Interface chapter for
information on creators and file types. See the Worldwide Software Overview chapter
for information on script codes and localization.

7-14

Using the PPC Toolbox

The PPC Toolbox

Port name

Port name

make memo,

store data,

word processor

database

i

PPC

Toolbox

/)

—

Location name

Jane Doe's Macintosh:PPCToolBox
@ twilight

Figure 7-10. Two Macintosh applications and their corresponding ports
The PPCPortRec data type defines the PPC port record.
TYPE

PPCPortRec

=

RECORD

nameScript:

ScriptCode;

{script

name:

Str32;

{port
name
in program
{ linking
dialog box}

portKindSelector:

PPCPortKinds;

{general
{

CASE

PPCPortKinds

identifier}

category

of

}

}

application}

OF
ppcByString:
(portTypeStr:
ppcByCreatorAndtType:

Str32);

(portCreator:
OSType;
portType:
OSType)
END;

The location name identifies the location of the computer on the network. The PPC Toolbox
provides the location name when the user starts up the computer. The location name is
specified in the standard Name-Binding Protocol (NBP) form, <object string>:PPCToolBox
@<AppleTalk zone>. The object string is the name provided in the Sharing Setup control
panel in the Control Panels folder. By default, the type string is “PPCToolBox”. The
AppleTalk zone is the zone to which the particular Macintosh computer belongs. For
example, “Jane Doe’s Macintosh:PPCToolBox @twilight” specifies the object string, type
string, and AppleTalk zone for a particular computer.

~I
lao

7)

O

oe]

Using the PPC Toolbox

7-15

So

=

re
4

Inside Macintosh,

Volume VI

The LocationNameRec data type defines the location name record. The locationKindSelector
field can be set to ppcNoLocation, ppeNBPLocation, or ppcNBPTypeLocation.
TYPE

LocationNameRec

=

RECORD

locationKindSelector:
CASE

PPCLocationKind

PPCLocationKind;

{which

variant}

OF

{ppcNoLocation:

storage

ppcNBPLocation:

not

{NBP

PpcNBPTypeLocation:

used

(nbpEntity:
name

by

value}

entity}

(nbpType:

Str32);

{just

the

NBP

for

the

PPCOpen

{

this

EntityName) ;

type

string

}

function}

END;

The ppcNoLocation constant is used when the location received from or passed to a PPC
Toolbox function is the location of the local machine.
The ppcNBPLocation constant is used when a full NBP entity name is received from or
passed to a PPC Toolbox function.
Note: You should assign an NBP value directly—do not pack it using
nbpSetEntity.
The ppcNBPTypeLocation constant is used only by the PPCOpen function when an alias
location name is needed.
The NBP type to be used for the alias location name is passed in the location name record’s
nbpType field. Alias location names allow you to filter the NBP objects (Macintosh computers)
displayed by the program linking dialog box (shown in Figure 7-12) using the PPCBrowser
function. See “Browsing for Ports Using the Program Linking Dialog Box” later in this chapter
for information on the PPCBrowser function.
An alias location name could be used to advertise a service (such as a dictionary service) that

is available to any application located on the network. For example, “Joe Smith’s Macintosh:
dictionary @ozone” specifies the object string, type string, and AppleTalk zone for a particular dictionary service.
To search for all dictionary services available within a zone, you use the PPCBrowser
function and a filter. Figure 7-11 illustrates a Macintosh dictionary service application,
its corresponding port name, and its alias location name.

Opening

a Port

To open a port and associate a name with it, use the PPCOpen function. Listing 7-2 illustrates
how you use the PPCOpen function to open a port. In this listing, the name is “Inside
Macintosh” and the port type string is “Example”. The location name is <object string>:PPC
Example@ <AppleTalk zone>.

7-16

Using the PPC Toolbox

The PPC Toolbox

Port name

spell quick,
dictionary
PPC Toolbox

Location name

Joe Smith's Macintosh:PPCToolBox
@ ozone
Alias location name

Joe Smith's Macintosh:dictionary@
ozone

Figure 7-11. The PPC Toolbox and a dictionary service application
Listing 7-2. Opening
FUNCTION

MyPPCOpen(VAR

thePortRefNum:

VAR

a PPC

port

PPCPortRefNum;

nbpRegisteredFlag:

Boolean)

:

OSErr;

VAR
thePPCOpenPBRec:
thePPCPortRec:

PPCOpenPBRec;
PPCPortRec;

theLocationNameRec:

LocationNameRec;

BEGIN
WITH

thePPCPortRec

DO

BEGIN

{nameScript

and

name

should

{ localization}
nameScript
:= smRoman;
name

:=

'Inside

be

{Roman

resources

to

allow

easy

}

script}

Macintosh';

{the port
type
should always be hard-coded
to allow the
}
{ application
to find ports
of a particular
type even after
{ the name
is localized}
portKindSelector
:= ppcByString;
portTypeStr

:=

}

'Example';

END;

WITH

theLocationNameRec

DO

BEGIN

locationKindSelector

nopType

:=

'PPC

:=

ppcNBPTypeLocation;

Example';

END;

~]

(Continued)

—
—

OQ

oe.

Using the PPC Toolbox

7-17

o

=

¥

Inside Macintosh,

Volume

VI

Listing 7-2. Opening a PPC port (Continued)
WITH

thePPCOpenPBRec

DO

BEGIN

serviceType
resFlag

:=

:=

portName

ppcServiceRealTime;

0;
:=

{must

be

0

{make

this

for

7.0}

@thePPCPortRec;

locationName

:=

networkVisible

@theLocationNameRec;
:=

TRUE;

{

entity

on

a

visible
the

}

network}

END;

MyPPCOpen

:=

thePortRefNum

PPCOpen(@thePPCOpenPBRec,

:=

FALSE) ;

{synchronous }

thePPCOpenPBRec.portRefNum;

nbpRegisteredFlag

:=

thePPCOpenPBRec.nbpRegistered;

END;

The PPCOpen function opens a port with the port name and location name specified in the
name and location fields of the parameter block. When the PPCOpen function completes
execution, the portRefNum field returns the port reference number. You can use the port

reference number in the PPCInform, PPCStart, StartSecureSession, and PPCClose functions

to refer to the port you have opened.

Browsing

for Ports

Using the Program

Linking

Dialog

Box

Before initiating a session, you can use either the PPCBrowser function or the IPCListPorts
function to locate a port to communicate with.
Use the PPCBrowser function to display the program linking dialog box (shown in
Figure 7-12) on the user’s screen.
Note: Because this function displays a dialog box on the user’s screen, you must not
call the PPCBrowser function from an application that is running in the background.

Choose

a program

to link to:

Macintoshes

Jane Doe's Macintosh
Joe Smith's

Macintosh

Programs

| display data
spell

AppleTalk

quick

Zones

loading
ozone
twilight

Figure 7-12. The program linking dialog box
7-18

ty

Finder

Using the PPC Toolbox

|

The PPC Toolbox

In the program linking dialog box, the user chooses the computer, zone, and application. The
zone list is not displayed if there is no network connection. Figure 7-13 shows the dialog box
without the zone list.
Choose

a program

to link to:

Macintoshes

Jane Doe's Macintosh
Joe

Smith's

Macintosh

Programs

am)

display data
Finder

quick

|

|

spell

Figure 7-13. The program linking dialog box without a zone list
As shortcuts for the user, the program linking dialog box supports standard keyboard
equivalents. Pressing Command-period or the Esc (Escape) key selects Cancel—pressing
Enter or Return selects the OK button.
Each list is sorted in alphabetical order. As in the Chooser, the current list is indicated by a
thick outline around its border. The program linking dialog box supports keyboard navigation
and use of the arrow keys to select items from the current list. Pressing Tab or clicking the
rectangle of another list switches the current list. Pressing Shift-Tab reverses the order in
which the lists are selected. In addition, double-clicking an application name in the Programs
list of the program linking dialog box is equivalent to clicking the OK button.
The PPCBrowser function allows users to browse for PPC ports.
err

:=

PPCBrowser

(prompt,

applListLabel,

thePortInfo,

portFilter,

defaultSpecified,

theLocation,

theLocNBPType) ;

If the defaultSpecified parameter is TRUE, the PPCBrowser function tries to select the PPC
port specified by the parameters theLocation and thePortInfo when the program linking dialog
box first appears. If the default cannot be found, the PPCBrowser selects the first PPC port
in the list.
An application can open multiple ports as long as each port name is unique within a particular
computer. Unique ports can have duplicate name fields but different types. For example, you
can designate “make memo” as the application’s name string and “word processor” as its type
string. You can also designate a separate port as “make memo” (the application’s name string)
and “text only” (its type string).

ae |

ac)
~~

Using the PPC Toolbox

7-19

OQ
ae
°
=
S
cS)

*

Inside Macintosh,

Volume VI

In such a case, the PPCBrowser function does a secondary sort based on the port type. Ports
with a type selector of ppcByCreatorAndType are displayed before ppcByString ports, and
types are sorted alphabetically within each type selector.
The PPCBrowser function uses the IPCListPorts function to obtain the list of existing ports on
a particular computer within a particular zone. The portFilter parameter of the PPCBrowser
function allows you to filter the list of PPC ports before it displays them in the program linking
dialog box. If this parameter is NIL, the names of all the existing PPC ports returned by the
IPCListPorts function are displayed. If the portFilter field is not NIL, it must contain a pointer
to a port filter function that you create.
Listing 7-3 illustrates how you use a sample port filter function. In this listing, the
MyBrowserPortFilter function returns TRUE for ports with the port type string
“Example”.
Listing 7-3. Using a port filter function
FUNCTION

MyBrowserPortFilter(theLocationNameRec:
thePortInfoRec:

LocationNameRec;

PortInfoRec)

:

Boolean;

BEGIN
IF

thePortInfoRec.name.portKindSelector

=

ppcByString

THEN

IF

ELSE

thePortInfoRec.name.portTypeStr
=
THEN MyBrowserPortFilter
:= TRUE
ELSE MyBrowserPortFilter
:= FALSE
MyBrowserPortFilter
:= FALSE;

'Example'

END;

The PPCBrowser function calls your filter function once for each port on the selected
computer. Your function should return TRUE for each port you want to display in the
program linking dialog box, and FALSE for each port that you do not want to display.
Do not modify the data in the filter function parameters theLocationNameRec and
thePortInfoRec.
The PPCBrowser function returns the selected port name in the parameter thePortInfo. The
IPCListPorts function returns the port names in the area of memory pointed to by the
bufferPtr field of the IPCListPorts parameter block. Both functions specify each port name
in a port information record.
TYPE

PortInfoRec

=

RECORD

filleri:

SignedByte;

{space

authRequired:
name:

Boolean;
PPCPortRec

{authentication
{port
name}

holder}
required}

END;

If the authRequired field is TRUE, the port requires authentication before a session can
begin. You should use the StartSecureSession function to initiate a session with this port. If
this field returns FALSE, you can use either the PPCStart function or the StartSecureSession
function to initiate a session. See “Initiating a PPC Session” later in this chapter for detailed
information. The name field of the port information record specifies an available port name.
7-20

Using the PPC Toolbox

The PPC Toolbox

Listing 7-4 illustrates how you use the PPCBrowser function to display the program linking
dialog box in order to obtain the location and name of a port chosen by the user. In this

listing, the PPCBrowser function builds lists of zones (shown in the AppleTalk Zones list of

the program linking dialog box), objects (shown in the Macintoshes list), and ports (shown
in the Programs list). In this example, the PPCBrowser function next tries to default to object
‘“Moof'™” in the “Twilight” zone. If it matches the object and zone, it also tries to default to
the port “Inside Macintosh” with the port type “Example”.
Note that the data in the records LocationNameRec and PortInfoRec is used to match the
names in the program linking dialog box. The data has nothing to do with the NBP type
used by NBPLookup or the filtered PPC ports that show up in the program linking dialog
box. NBPLookup uses the NBP type supplied in theLocNBPType. The PPC port names
are filtered using the MyBrowserPortFilter function shown in the previous listing.
Listing 7-4. Browsing through dictionary service ports
FUNCTION

MyPPCBrowser(VAR

theLocationNameRec:

VAR

thePortInfoRec:

LocationNameRec;

PortiInfoRec)

:

OSErr;

VAR

prompt:
applListLabel:
defaultSpecified:
theLocNBPType:

Str255;
Str255;
Boolean;
Str32s

BEGIN

prompt

:=

'Choose

applListLabel

:=

defaultSpecified

WITH

an

example

to

link

to:';

'Examples';
:=

TRUE;

theLocationNameRec

DO

BEGIN

locationKindSelector
WITH

nbpEntity

:=

ppcNBPLocation;

DO

BEGIN

objStr

:=

'Moof™';

{typeStr

is

ignored}

zoneStr

:=

'Twilight';

END;
END;

WITH

thePortInfoRec.name

DO

BEGIN

{nameScript
and
{ localization}

name

should

be

nameScript
:= smRoman;
{Roman
name := 'Inside Macintosh';
{the port
type should
{ application
to find

resources

to

allow

easy

}

script}

always be hard-coded
to allow the
}
ports
of a particular
type even after

}

{ the name
is localized}
portKindSelector
:= ppcByString;
portTypeStr

:=

a |

'Example';

—

END;

~
v

—

(Continued)

Using the PPC Toolbox

7-21

@)
rj

S.
=e
*

Inside Macintosh,

Volume VI

Listing 7-4. Browsing through dictionary service ports (Continued)
{when building
the list
of objects
(Macintoshes),
{ those with the NBP type
"PPC Example"}
theLocNBPType
MyPPCBrowser

:=
:=

'PPC

Example';

{match

PPCBrowser(prompt,

this

NBP

only

}

type}

applListLabel,

theLocationNameRec,

show

defaultSpecified,

thePortInfoRec,

@myBrowserPortFilter,

theLocNBPType) ;

END;

Obtaining a List of Available Ports
To generate a list of ports without displaying dialog boxes, you can use the IPCListPorts
function. The IPCListPorts function allows you to obtain a list of ports on a particular
computer within a particular zone. To obtain a list of ports, several steps are required.
First, use the GetZoneList function to obtain a list of zones. Next, you must use the

PLookupName function to obtain a list of computers with ports. After establishing the

zone and the computer, you can use the IPCListPorts function to obtain the list of available

ports. See the AppleTalk Manager chapter in this volume for information on the GetZoneList
function. See the AppleTalk Manager chapters in Volume II and Volume V for information
on the PLookupName function.
Listing 7-5 illustrates how you use the IPCListPorts function to obtain a list of ports on a
particular computer. This function returns a list of port information records in the buffer
pointed to by the parameter thePortInfoBufferPtr. The actual number of port information
records is returned in the parameter theActualCount.

Listing 7-5. Using the [PCListPorts function to obtain a list of ports
FUNCTION

MyIPCListPorts(theStartIndex:

Integer;

VAR theActualCount:
theZoneStr:
Str32;
PortInfoArrayPtr)

theRequestCount:

Integer;
theObjStr:
thePortInfoBufferPtr:
:

Integer;
Str32;

OSErr;

VAR

theIPCListPortsPBRec:

IPCListPortsPBRec;

thePPCPortRec:

PPCPortRec;

theLocationNameRec:

LocationNameRec;

BEGIN

{list

all

PPC

ports

WITH
thePPCPortRec
BEGIN

at

the

specified

location}

DO

nameScript
:= csRoman;
name
:=
'=';
{match
portKindSelector
:= ppcByString;

all

names}

POrTctTypeSty

{match

all

types}

supply

the

x=

22"

END;

{The
{

7-22

the

application
list

must

returned

by

choose

and

GetZoneList.

Using the PPC Toolbox

Then,

NBP

the

zone

string

application

from

must

}
}

The PPC Toolbox

choose

and

supply

NBPLookup.

This

don't
supply
the NBP type
WITH

the

NBP

example

object
looks

your own
string. }

NBP

theLocationNameRec

DO

string

for

type,

NBP

you

from
type

should

the

list

returned

"PPC

Example".

use

"PPCToolBox"

If

by

}

you
for

}
}

BEGIN

locationKindSelector
WITH

nbpEntity

:=

ppcNBPLocation;

DO

BEGIN

ebjStr

«=

typeStr
zoneStr

theObjStxr;
:=
:=

'PPC Example';
theZoneStr;

END;
END;

WITH

theIPCListPortsPBRec

DO

BEGIN

startIndex

:=

requestCount
portName

theStartIndex;
:=

:=

theRequestCount;

@thePPCPortRec;

locationName

:=

bufferPtr

thePortInfoBufferPtr;

:=

@theLocationNameRec;

END;

MyIPCListPorts
theActualCount

:=

IPCListPorts(@theIPCListPortsPBRec,
theIPCListPortsPBRec.actualCount;

FALSE) ;

END;

The IPCListPorts function returns information about ports that are on the computer specified in
the locationName field of the list ports parameter block. If the locationName field is NIL or if
the locationKindSelector field in the location name record is ppcNoLocation, the IPCListPorts
function returns only the port names for the local computer.
The bufferPtr field points to an area of memory that contains the requested port names. You
are responsible for allocating enough memory to hold the requested port names. The buffer
length must be equal to
sizeof

(PortInfoRec)

Preparing

*

requestCount

for a Session

To communicate, you can open a port for your application and make it available to receive
session requests, to initiate sessions, or both. Applications that are able to receive session
requests can choose to accept or reject incoming session requests.
Before an application can accept and establish a session with another application, the PPC
Toolbox authenticates the initiating user (unless guest access is enabled or the applications
are located on the same computer). Once a session begins, the two applications can exchange
data with each other.

I
~~
"

-Q
oe

Using the PPC Toolbox

7-23

S
=y
SPa

Inside Macintosh, Volume VI

Initiating

a PPC

Session

Once you have established the name and the location of the port that you want to communicate with, you can initiate a session. You can use either the StartSecureSession function or
the PPCStart function to initiate a session. The StartSecureSession function displays several
dialog boxes on the user’s screen to identify each user who requests a session. You may
prefer to use the PPCStart function for low-level code such as that used for drivers, which
typically do not provide a user interface. You may also prefer to use PPCStart when the
application you are initiating a session with does not require authentication. The [PCListPorts
and PPCBrowser functions return information about whether a particular port requires
authentication.
Note: Do not call the StartSecureSession function from an application that is
running in the background, since it requires that several dialog boxes appear on
the user’s screen.
The StartSecureSession function provides authentication services to identify each user who
requests a session. This function combines the processes of prompting for user name and
password and initiating a session into one synchronous procedure call. If authentication fails,
the PPC Toolbox rejects the incoming session request.
err

:=

StartSecureSession

(pb,

userName,

guestSelected,

useDefault,

allowGuest,

prompt);

Set the useDefault parameter to TRUE if you want the StartSecureSession function to use the
default user identity (described later in this section). If the default user identity cannot be
authenticated, the StartSecureSession function displays a dialog box to allow a user to log on.
Figure 7-14 shows the user identity dialog box.

S&S

Link to “store data” on
“Jane

Doe’s

Macintosh”

as:

© Guest

@) Registered User

Name:

Joe Smith

|

Figure 7-14. The user identity dialog box
The prompt parameter of the StartSecureSession function allows you to specify a line of text
that the dialog box can display. The allowGuest parameter specifies whether to enable the
Guest radio button. If a port requires authentication, you should set this parameter to FALSE.

7-24

Using the PPC Toolbox

The PPC Toolbox

The userName parameter specifies the name of the user who is attempting to initiate a
session. If the user name is not specified, the user identity dialog box appears on the
user’s screen with the owner name provided from the Sharing Setup control panel.
If the user enters an invalid password, the StartSecureSession function displays the dialog
box shown in Figure 7-15.

Sorry,

this password

Please try again.

was

refused.

Figure 7-15. The incorrect password dialog box
After the user clicks OK, the user identity dialog box reappears in the foreground so that the
user can enter the password again.
If the user’s name is invalid, the StartSecureSession function displays the dialog box shown
in Figure 7-16.

Sorry, this user name was refused.
Please try another name.

|

OK

Figure 7-16. The invalid user name dialog box
After the user clicks OK, the user identity dialog box reappears so that the user can enter a
new user name.
The StartSecureSession function remains in this loop until a secure session is initiated or
the user clicks Cancel in the user identity dialog box. If a secure session is initiated,
StartSecureSession returns the user reference number in the corresponding field in the
PPCStart parameter block. The user reference number represents the user name and
password. A user reference number of 0 indicates that a session has been initiated with
guest access. See “Setting Up Authenticated Sessions” earlier in this chapter for detailed
information.
Before your application quits, you need to invalidate all user reference numbers obtained with
the StartSecureSession function except for the default user reference number and the guest
reference number (0). See “Invalidating Users” later in this chapter for detailed information.
Using the PPC Toolbox

7-25

I
a")
~

Q
|

°
=

5*

Inside Macintosh, Volume VI

Listing 7-6 illustrates how to use the StartSecureSession function to establish an authenticated
session. This listing shows only one session, although your application may conduct multiple
sessions at one time.
Listing 7-6. Using the StartSecureSession function to establish a session
FUNCTION

MyStartSecureSession(thePortInfoPtr:

PortInfoPtr;

theLocationNamePtr:

LocationNamePtr;

thePortRefNum:
PPCPortRefNum;
VAR theSessRefNum:
PPCSessRefNum;
VAR

theUserRefNum:

LongInt;

VAR

theRejectInfo:

LongInt;

VAR

userName:

VAR

guestSelected:

Str32;
Boolean)

:

OSErr;

VAR

thePPCStartPBRec:

PPCStartPBRec;

useDefault:

Boolean;

allowGuest:
err:

Boolean;
OSErr?}

BEGIN

WITH

thePPCStartPBRec

DO

BEGIN

ioCompletion
portRefNum

:=
:=

serviceType
resFlag

:=

portName

NIL;

thePortRefNum;

:=

{from

the

PPCOpen

{from

the

PPCBrowser

}

PPCBrowser

}

0;
:=

@thePortInfoPtr®.name;

{

locationName

:=

theLocationNamePtr;

:=

0;

function}

{from
{

userData

function}

ppcServiceRealTime;

the

function}

{application-specific
{

data

that

{

function

the

}

PPCInform

}

sees}

END;

{try to connect
with
useDefault
:= TRUE;

default

{highlight

the

button

allowGuest

:=

err

:=

Guest
NOT

user

identity}

appropriately}

thePortInfoPtr®.authRequired;

StartSecureSession(@thePPCStartPBRec,
allowGuest,

IF

err

=

noErr

userName,

guestSelected,

useDefault,
stringPtr(NIL)%);

THEN

BEGIN

theSessRefNum

:=

thePPCStartPBRec.sessRefNum;

theUserRefNum

:=

thePPCStartPBRec.userRefNum;

END
ELSE

IF

err

=

userRejectErr

THEN
{return
rejectInfo
from the PPCReject
function}
theRejectInfo
:= thePPCStartPBRec.rejectInfo;
MyStartSecureSession
:= err;
END;

7-26

Using the PPC Toolbox

The PPC Toolbox

For low-level code such as that used for drivers (which typically do not provide a user
interface), you can use the PPCStart function instead of the StartSecureSession function
to initiate a session. You can also use the IPCListPorts function (instead of displaying
the program linking dialog box) to obtain a list of ports.
If the authRequired field of the port information record contains FALSE, the port allows
guest access. If the authRequired field of the port information record contains TRUE,
use the PPCStart function and the user reference number obtained previously from the
StartSecureSession function to reestablish an authenticated session.
You can also attempt to log on as the default user using the GetDefaultUser function to
obtain the default user reference number and the default user name. The default user name
is established after the owner starts up the computer.
err

:=

GetDefaultUser

(userRef,

userName);

The userRef parameter is a reference number that represents the user name and password of
the default user. The userName parameter contains the owner name that is specified in the
Sharing Setup control panel.
The GetDefaultUser function returns an error when the default user identity does not exist (no
name is specified in the Sharing Setup control panel) or the user is not currently logged on.
Listing 7-7 illustrates how you use the PPCStart function to initiate a session. The PPCStart
function uses the port information record and the location name record to attempt to open a
session with the selected PPC port.
Listing 7-7. Initiating a session using the PPCStart function
FUNCTION

MyPPCStart

(thePortInfoPtr:

PortInfoPtr;

theLocationNamePtr:

LocationNamePtr;
thePortRefNum:
PPCPortRefNum;
VAR theSessRefNum:
PPCSessRefNum;
VAR theUserRefNum:
Longint;

VAR

theRejectInfo:

LongInt)

:

OSErr;

VAR

thePPCStartPBRec:

PPCStartPBRec;

userName:

Stxrs32:

err:

OSELX

BEGIN

WITH

thePPCStartPBRec

DO

BEGIN

ioCompletion
:= NIL;
portRefNum
:= thePortRefNum;
serviceType
:= ppcServiceRealTime;
resFlag
portName

:=

the

PPCOpen

function}

0;
:=

@thePortInfoPtr®.name;

locationName
userData

{from

:=

:=
0;

theLocationNamePtr;

{destination

port}

{destination

location}

{application-specific
{ data
for PPCInform}

}

END;

ae |

(Continued)

a>)
~

OQ
—

Using the PPC Toolbox

7-27

—)

=

S54

Inside Macintosh,

Volume VI

Listing 7-7. Initiating a session using the PPCStart function (Continued)
err

:=

IF

err

GetDefaultUser(thePPCStartPBRec.userRefNum,
<>

userName) ;

noErr

THEN

thePPCStartPBRec.userRefNum
IF

thePortInfoPtr*.authRequired
THEN

{port
{

a

{

this

err
ELSE

IF

selected

:=

default

user

AND

not

0;
(thePPCStartPBRec.userRefNum

allow

reference

guests

number,

and
so

you

you

do

cannot

not
log

=

0)

have

}

on

to

}

port}

authFailErr

{attempt

err

:=

=

noErr

err

does

:=

to

log

PPCStart

on}

(@thePPCStartPBRec,

FALSE);

THEN

BEGIN
theSessRefNum
theUserRefNum

:=
:=

thePPCStartPBRec.sessRefNum;
thePPCStartPBRec.userRefNum;

END

ELSE
IF

err

=

THEN
MyPPCStart

userRejectErr
{return

rejectInfo

theRejectInfo
<= errs;

:=

from

the

PPCReject

function}

thePPCStartPBRec.rejectiInfo;

END;

The port to which you wish to connect must have an outstanding PPCInform function to
successfully start a session. You cannot initiate a session with a port that is not able to
receive session requests.
If the port is open, has an outstanding PPCInform posted, and accepts your session request,
the PPCStart function returns a noErr result code and a valid session reference number. This
session reference number is used to identify the session during the exchange of data.

Receiving

Session

Requests

Your application can open as many ports as it requires as long as each port name is unique
within a particular computer. A single port can support a number of communication sessions.
To allow a port to receive session requests, use the PPCInform function. (Note that you must
open a port to obtain a port reference number before calling the PPCInform function.) A port
may have any number of outstanding PPCInform requests.
Listing 7-8 illustrates how you use the PPCInform function to allow a port to receive session
requests. In this listing, the parameter thePPCParamBlockPtr points to a PPC parameter block
record allocated by the application. The portRefNum, autoAccept, portName, locationName,
userName, and ioCompletion parameters of the PPC parameter block record must be supplied.
If you want to automatically accept all incoming session requests, you can set the autoAccept
field in the PPCInform parameter block.

7-28

Using the PPC Toolbox

The PPC Toolbox

Listing 7-8. Using the PPCInform function to enable a port to receive sessions
FUNCTION

MyPPCInform(thePPCParamBlockPtr:

thePPCPortPtr:

PPCParamBlockPtr;

PPCPortPtr;

theLocationNamePtr:

LocationNamePtr;
theUserNamePtr:
stringPtr;
thePortRefNum:
PPCPortRefNum)
: OSErr;
BEGIN

WITH

thePPCParamBlockPtr®.informParam

BEGIN

ioCompletion

portRefNum

:=
:=

autoAccept

:=

DO

@MyInformCompProc;

thePortRefNum;

{from

FALSE;

{the
{

portName

:=

thePPCPortPtr;

userName

:=

theUserNamePtr;

locationName

:=

{

the

PPCOpen

completion

handles

rejecting

function}

routine

accepting

requests}

}

or

}

theLocationNamePtr;

END;

MyPPCInform

:=

PPCInform(PPCInformPBPtr(thePPCParamBlockPtr),

TRUE)

;

{asynchronous }

END;

A PPC parameter block record is used instead of a PPCInform parameter block record so that
the same parameter block can be reused to make other PPC Toolbox calls from the PPCInform
completion routine. The parameter block and the records it points to cannot be deallocated until
all calls that use the parameter block and records have completed.
You should make the call to PPCInform asynchronously. For each function that you use
asynchronously, you should provide a completion routine. This procedure gets called at
interrupt time when the PPCInform function completes. If there are no errors, it sets the
global variable gSessionOpen to TRUE. The global variable gPBInUse is set to FALSE to
inform the application that the parameter block and the records it points to are no longer in use.
Listing 7-9 illustrates a completion routine for a PPCInform function. You can use the data
passed into your PPCInform completion routine (user name, user data, port name, and
location name) to determine whether to accept or reject the session request.
Listing 7-9. Completion routine for a PPCInform function
PROCEDURE

MyInformCompProc(pb:

PPCParamBlockPtr) ;

BEGIN

IF

pb*.informParam.ioResult

=

noErr

THEN
BEGIN

{decide

if

this

session

should

be

accepted

{ by looking
at data supplied by the
IF pb*.informParam.userData
<> -l

session

or

rejected

}

requester}

THEN

DoPPCAccept
(pb)
ELSE

I

DoPPCReject
(pb) ;
END

Using the PPC Toolbox

a)
ig)

(Continued)

‘o)

7-29

S
=
7
=)
*

oe

Inside Macintosh, Volume VI

Listing 7-9. Completion routine for a PPCInform function (Continued)
ELSE

{use a global
to tell
the application
it points
to can be
{ and the records
gPBInUse
:= FALSE;

that
PPCParamBlockRec
deallocated}

}

END;

Accepting

or Rejecting

Session

Requests

Use the PPCAccept function or the PPCReject function to accept or reject an incoming
session request.
A

Warning: If the PPCInform function (with the autoAccept parameter set to
FALSE) returns a noErr result code, you must call either the PPCAccept function
or the PPCReject function. The computer trying to initiate a session (using the
StartSecureSession function or the PPCStart function) waits (hangs) until the

session attempt is either accepted or rejected, or until an error occurs.

a

Listing 7-10 illustrates how you use the PPCAccept function to accept a session request. This
listing reuses the parameter block used in the PPCInform function, so the sessRefNum field
already contains the session reference number needed by the PPCAccept function.
Listing 7-10. Accepting a session request using the PPCAccept function
PROCEDURE

DoPPCAccept
(pb:

PPCParamBlockPtr) ;

VAR
err:

BEGIN

OSErr;

{accept

the

session}

pb* .acceptParam.ioCompletion

:=

@MyAcceptCompProc;

{the

sessRefNum

field

by

the

err

:=

(@pb*.acceptParam,

PPCAccept

is

set

PPCInform
TRUE);

function}

{asynchronous}

END;

For each function that you use asynchronously, you should provide a completion routine.
Listing 7-11 illustrates a completion routine for a PPCAccept function. This procedure gets
called at interrupt time when the PPCAccept function completes. If there are no errors, it
sets the global variable gSessionOpen to TRUE. The global variable gPBInUse is set to
FALSE to inform the application that the parameter block and the records it points to are no
longer in use.
You can use the session reference number in subsequent PPCWrite, PPCRead, and PPCEnd
functions once a session is accepted.

7-30

Using the PPC Toolbox

The PPC Toolbox

Listing 7-11. Completion routine for a PPCAccept function
PROCEDURE

MyAcceptCompProc(pb:

PPCParamBlockPtr) ;

BEGIN

IF

pb*.acceptParam.ioResult
THEN

{accept

completed

gSessionOpen

:=

=

noErr

so

the

session

{use a global
to tell
the application
{ and the records
it points
to can be
gPBIinUse

:=

is

completely

open}

TRUE;
that
PPCParamBlockRec
deallocated}

}

FALSE;

END;

Use the PPCReject function to reject an incoming session request. Listing 7-12 illustrates
how you use the PPCReject function to reject a session request.
This listing reuses the parameter block used in the PPCInform function, so the sessRefNum

field already contains the session reference number needed by the PPCReject function.
Listing 7-12. Rejecting a session request using the PPCReject function
PROCEDURE

DoPPCReject
(pb:

PPCParamBlockPtr) ;

3

VAR
err:

OSErr;

BEGIN

{reject

WITH

the

session}

pb*.rejectParam

DO

BEGIN

ioCompletion
:=
{the sessRefNum
rejectinfo

:=

@MyRejectCompProc;
field is set by the

PPCInform

function}

-1;

END;

err

:=

PPCReject

(@pb*.rejectParam,

TRUE);

{asynchronous}

END;

Listing 7-13 illustrates a completion routine for a PPCReject function. This procedure gets
called at interrupt time when the PPCReject function completes. In this example, the global
variable gPBInUse is set to FALSE to inform the application that the parameter block and
the records it points to are no longer in use.
Listing 7-13. Completion routine for a PPCReject function
PROCEDURE
BEGIN
{use
{

the

MyRejectCompProc(pb:

a

global

to

tell

records

it

points

gPBInUse

:=

the
to

PPCParamBlockPtr) ;

application
can

be

that

PPCParamBlockRec

and

}

deallocated}

FALSE;
~I

END;

~
~~

OQ
J

Using the PPC Toolbox

7-31

on

=

a
o
oA

Inside Macintosh,

Volume VI

Exchanging

Data During

a PPC

Session

After a session begins, each application can send data to and receive data from the other using a
sequence of message blocks. The PPC Toolbox treats each message block as a byte stream and
does not interpret the contents of the message block. The size of a message block can be between

0 and (232-1) bytes. The PPC Toolbox treats the buffer size as an unsigned long integer.

The PPC Toolbox delivers the message blocks in the same sequence as they are sent and
without duplicates. In Figure 7-17, an application transmits message blocks during a session.

Session
PPC Toolbox

--

[Block 3

{| Block
2 ]-e{ Blocki

}-

|

PPC Toolbox

Figure 7-17. Transmitting message blocks
For each message block, you specify a block creator, block type, and user data. The first
PPCWrite function that you use to create a new message block sets the attributes for the
block. The PPCRead function returns the block creator, block type, and user data attributes
for the current message block when the call completes.
Although the PPC Toolbox does not interpret these attributes, they can give the receiving
application information about how to process the contents of the message block. For
example, a database application may specify a counter to indicate the block number (block
number 20 of 30 total blocks) in the block creator field. This application could also specify
a code, such as 'DREC’, in the block type field to indicate that the information it contains
is a database record. In addition, this application could specify the length of the message
block in the user data field.

Reading

Data

From

an Application

An application can both read from and write data to another application during a session.
Use the PPCRead function during a session to read incoming blocks of data from another
application.
Once a session is initiated, you should have a PPCRead function pending. You can issue a
PPCRead function from inside a completion routine. This provides you with immediate
notification if an error condition arises or the session closes.
The blockCreator, blockType, and userData fields are returned for the block you are reading.
(These fields are set by the PPCWrite function.) To determine whether there is additional data
to be read, check the more field. This field is FALSE to indicate the end of a message block.
Listing 7-14 illustrates how you use the PPCRead function to read data during a session.
7-32

Using the PPC Toolbox

The PPC Toolbox

Listing 7-14. Using the PPCRead function to read data during a session
FUNCTION

MyPPCRead(thePPCReadPBPtr:
PPCSessRefNum;
Ptr)
< OSErr:

PPCReadPBPtr;
theBufferLength:

theSessRefNum:
Size;
theBufferPtr:

BEGIN
WITH

thePPCReadPBPtr”*

DO

BEGIN

ioCompletion
sessRefNum

:=
:=

NIL;

theSessRefNum;

{
theBufferLength;

bufferLength

:=

bufferPtr

theBufferPtr;

:=

{from
or

the
the

PPCStart

function

PPCInform

function}

}

END;

MyPPCRead

:=

PPCRead(thePPCReadPBPtr,

TRUE);

{asynchronous}

END;

You should make any calls to PPCRead asynchronously. You can provide a completion
routine that will be called when the PPCRead function has completed, or you can poll
the ioResult field of the PPC parameter block to determine whether the PPCRead function
has completed. A PPCRead completion routine can issue another asynchronous PPC
Toolbox call or set global variables. If another PPC Toolbox call is made from a completion
routine, then the PPCRead function must use a record of data type PPCParamBlockRec
instead of type PPCReadPBRec.
Listing 7-15 illustrates a function that can be used to poll the ioResult field of a record of data
type PPCReadPBRec. The function returns TRUE when the PPCRead function associated
with PPCReadPBRec has completed.
Listing 7-15. Polling the ioResult field to determine if a PPCRead function has completed
FUNCTION

MyReadComplete(thePPCReadPBPtr:

PPCReadPBPtr;

VAR

err:

OSErr)

Boolean;
BEGIN
err

:=

thePPCReadPBPtr®.ioResult;

MyReadComplete

:=

err

<>

1;

END;

Sending

Data to an Application

Use the PPCWrite function to send a message block during a session specified by the session
reference number.
You should call the PPCWrite function asynchronously. You can provide a completion
routine that will be called when the PPCWrite function has completed, or you can poll
the ioResult field of the PPC parameter block to detemine whether the PPC Write function
has completed. A PPCWrite completion routine can issue another PPC Toolbox call or set
global variables. If another PPC Toolbox call is made from a completion routine, then the
PPCWrite function must use a record of data type PPCParamBlockRec instead of type
PPCWritePBRec. Note that message blocks are sent in the order in which they are written.

~I
Comal
ww
ae
w
¢

ld

~

ee

Using the PPC Toolbox

7-33

~~
-

—

—

Ne

—)
*

4

)
|

Inside Macintosh,

Volume VI

Listing 7-16 illustrates how you use the PPCWrite function to write data during a session.
Listing 7-16. Using the PPCWrite function to write data during a session
PPCWritePBPtr;
MyPPCWrite(thePPCWritePBPtr:
PPCSessRefNum;
theBufferLength:

FUNCTION

Ptr)

:

theSessRefNum:
Size;

theBufferPtr:

OSErr;

BEGIN

WITH

thePPCWritePBPtr*

DO

BEGIN

ioCompletion
sessRefNum

:=
:=

bufferLength

NIL;

theSessRefNum;
:=

{from

the

{

PPCInform

the

PPCStart

function

or

}

function}

theBufferLength;

bufferPtr
:= theBufferPtr;
more
:= FALSE;

{no

userData
:= 0;
blockCreator
2=
"27???"
blockType
:=
'????';

{application-specific
{application-specific
{application-specific

more

data

to

read}
data}
data}
data}

END;

MyPPCWrite

:=

PPCWrite(thePPCWritePBPtr,

TRUE);

{asynchronous}

END;

The first PPC Write function that you use to create a new message block sets the block
creator, block type, and user data attributes for the block. These attributes are returned to
the application when it reads from the message block. Set the more field to FALSE to
indicate the end of the message block or set this field to TRUE if you want to append
additional data to a message block.
Listing 7-17 illustrates a function that can be used to poll the ioResult field of a record of data
type PPCWritePBRec. The function returns TRUE when the PPCWrite function associated
with PPCWritePBRec has completed.
Listing 7-17. Polling the ioResult field to determine if a PPCWrite function has completed
FUNCTION

MyWriteComplete(thePPCWritePBPtr:
VAR

err:

OSErr)

PPCWritePBPtr;
:

Boolean;

BEGIN

err

:=

thePPCWritePBPtr*.ioResult;

MyWriteComplete

:=

err

<>

1;

and

Closing

END;

Ending

a Session

a Port

After data is written and read in, use the PPCEnd function to end the session (identified by
the session reference number). You may receive an error if you use the PPCEnd function to
end a session that has already been terminated.
Listing 7-18 illustrates how you use the PPCEnd function to end a session.

7-34

Using the PPC Toolbox

The PPC Toolbox

Listing 7-18. Ending a PPC session using the PPCEnd function
FUNCTION

MyPPCEnd(theSessRefNum:

PPCSessRefNum)

:

OSErr;

VAR

thePPCEndPBRec:

PPCEndPBRec;

BEGIN

thePPCEndPBRec.sessRefNum
MyPPCEnd

:=

:=

theSessRefNum;

PPCEnd(@thePPCEndPBRec,

FALSE);

{synchronous}

END;

The PPCEnd function causes all calls to the PPCRead and PPCWrite functions to complete
(with a sessClosedErr result code) and invalidates the session reference number. The

PPCEnd function also releases any PPC Toolbox resources so that they can be reused.
Use the PPCClose function to close the port specified by the port reference number. When
you close a port, all sessions associated with a port are ended. Any active asynchronous calls
associated with a session then call their completion routines (if they have one).
Listing 7-19 illustrates how you use the PPCClose function to close a port.
Listing 7-19. Closing a PPC port using the PPCClose function
FUNCTION

MyPPCClose(thePortRefNum:

PPCPortRefNum)

:

OSErr;

VAR

theClosePBRec:

PPCClosePBRec;

BEGIN

theClosePBRec.portRefNum
MyPPCClose

:=

:=

thePortRefNum;

PPCClose(@theClosePBRec,

{from the
{ PPCOpen

FALSE);

}
function}

{synchronous}

END;

In this example, the call to PPCClose is made synchronously.

invalidating

Users

It is your responsibility to invalidate all user reference numbers obtained with the
StartSecureSession function before your application quits. However, while your application remains open, you may want to keep track of a user reference number to start a
session with a port, end it, and then later start another session with the same port.
Use the DeleteUserldentity function to invalidate the user reference number for a
particular user.
err

:=

DeleteUserIdentity

(userRef) ;

a |
—
w
—

w

OQ
|

Using the PPC Toolbox

7-35

o

=

oa
i)
A

Inside Macintosh,

Volume VI

The DeleteUserldentity function removes a user by invalidating the specified user reference

number. Note that you cannot invalidate the guest reference number (0) and, in most cases,

you should not dispose of the default user reference number.

Listing 7-20 illustrates how you use the DeleteUserldentity function to invalidate a user
reference number obtained from a StartSecureSession function. The sample code does not
invalidate the user reference number if it is either the default user reference number or the
guest reference number (0).

Listing 7-20. Using the DeleteUserldentity function to invalidate a user identity
FUNCTION

DeleteNewUserRefNum(newUserRef:

LongInt)

:

OSErr;

VAR

err:

OSErr;

defUserRef:

Longint;

defUserName:

Str32:

BEGIN
IF

newUserRef
<> 0
{user reference
BEGIN
err

:=

IF

err

THEN
number

passed

was

not

GetDefaultUser(defUserRef,
=

guest}

defUserName) ;

noErr

THEN

{there

BEGIN
IF

is

a

default

user}

newUserRef
<> defUserRef
THEN
{it’s not
the default,
err
:= DeleteUserIdentity

END
ELSE
{there
err

the

:=

is

no

default,

so

DeleteUserIdentity

DeleteNewUserRefNum

:=

so delete
it}
(newUserRef) ;

delete

it}

(newUserRef)

;

err;

END

ELSE
{user reference
number passed
DeleteNewUserRefNum
:= noErr;
END;

PPC

TOOLBOX

ROUTINES

This section describes the routines for
m

initializing the PPC Toolbox

m listing available ports
m opening and closing a port
= starting and ending a session
7-36

PPC Toolbox Routines

was

the

guest}

The PPC Toolbox

m accepting and rejecting a session
m reading and writing data
= obtaining the default user reference number and name
m invalidating a user reference number
Also included in this section is the PPC parameter block. Result codes appear after each
function where applicable.

The

PPC

Toolbox

Parameter

Block and Completion

Routine

PPC Toolbox functions require a pointer to a PPC parameter block. You must fill out any
fields of the parameter block that the specific PPC Toolbox function requires.
TYPE

PPCParamBlockRec

=

RECORD
CASE Integer OF
0:
(openParam:

PPCOpenPBRec)

;

{PPCOpen
;

params}

1:

(informParam:

PPCInformPBRec)

{PPCInform

2:

(startParam:

PPCStartPBRec)

3:

(acceptParam:

PPCAccept

4:
5:

(rejectParam:
(writeParam:

PPCReject PBRec) ;
PPCWritePBRec) ;

{PPCReject params}
{PPCWrite params}

6:
7:
8:

(readParam:
(endParam:
(closeParam:

PPCReadPBRec) ;
PPCEndPBRec) ;
PPCClosePBRec) ;

{PPCRead params}
{PPCEnd params}
{PPCClose params}

9:

(listPortsParam:

IPCListPortsPBRec)

{IPCListPorts

;

PBRec)

{PPCStart
;

params}
params}

{PPCAccept

{

params}

}

params}

END;

The qLink, csCode, intUse, intUsePtr, and reserved fields are used internally by the PPC
Toolbox. Your application should not rely on the PPC Toolbox to preserve these fields
across calls.
Figure 7-18 shows the PPC Toolbox parameter blocks. Note that the reserved fields are not
included in the illustration.
Your application transfers ownership of the PPC Toolbox parameter block (and any buffers
or records pointed to by the PPC Toolbox parameter block) to the PPC Toolbox until a PPC
function is complete. Once the function completes, ownership of the parameter block (and
any buffers or records it points to) is transferred back to your application. If a PPC Toolbox
function is executed asynchronously, your program cannot alter memory that might be used
by the PPC Toolbox until that function completes.
A PPC Toolbox function that is executed asynchronously must specify NIL or the address of
a completion routine in the ioCompletion field of the PPC parameter block. The ioResult field
should be used to determine the actual result code when an asynchronously executed PPC
Toolbox function completes.

~
Coal

w

~~

‘o

bj

PPC Toolbox Routines

7-37

=)
=
=
=)
~

PPCOpenPBRec

PPCClosePBRec

po rtRefNum

po rtRefNum

38

40
42
44
45
46
48
50
52
54
55
56
57
58

62

66

PPCinformPBRec

|_ po portRefNum | portRefNum
po

b-

ke

Ee

|

Liter
serviceType>
resFlag ->

—

portName

PPCStartPBRec

| sessRefNum |
<}¢——_

bie

|

—@- serviceType
autoAccept >

porName

sessRefNum
<}$-—

serviceType
resFlag

|

portName

PPCEndPBRec
|_

filler

PPCAcceptPBRec PPCRejectPBRec PPCWritePBRec

PPCReadPBRec |IPCListPortsPBRec

cs

=

ie

a=

LS

| ss

filler

| sessRefNum | sessRefNum

be,
Lg

|

le

i

Meee

| Ee

ie

be

&

oe

a

LL

2

networkVisible >>

<4 nbpRegistered

|_locationName | locationName
|

[-

——_

|

userName

Po—s2

je)

rejectinfo

+

userData
}+——

——

Le

filler1

—

Mere

Fiters

filler

==>

| requestCount

tes
| bufferLength

\— actual Count
+

L

es

=

| sessRefNum

bufferLength

|

—>

_

Lo

actualLength
<¢——

|

bufferPtr
—more
filler2

userData

|
-|~<t

Ts

e—>

| actualLength
|
<$——

userData
SS

bufferPtr
==
more
filler2
userData

Fa

te

ty

| blockCreator
se

| blockCreator
|
<+—

—

i

_ blockType
Pe

Figure 7-18. The PPC Toolbox parameter blocks

startindex

_—

rejectinfo

| _userRefNum
fae

filler

|__

—— =

~@- requestType

ES

le

ee

—

fillert

ia

| sessRefNum | sessRefNum

Dy eng

| _locationName

fillert

|

blockType

4

ee

——>

portName

Sa
|

locationName

bufferPtr

—

[A aUuinjo, ‘Ysolulavp apisuy

8E-L

Offset

The PPC Toolbox

If you specify a completion routine in the ioCompletion field, it is called at interrupt time
when the PPC Toolbox function completes execution.
A

Warning: Completion routines execute at the interrupt level and must preserve
all registers other than AO, Al, and DO—D2. (Note that MPW C and MPW Pascal
do this automatically.) Your completion routine must not make any calls to the
Memory Manager, directly or indirectly, and it can’t depend on the validity of
handles to unlocked blocks. The PPC Toolbox preserves the application global
register A5. a

You can write completion routines in C, Pascal, or assembly language. A completion routine
declared in Pascal is
PROCEDURE

MyCompletionRoutine

(pb:

PPCParamBlockPtr) ;

The pb parameter points to the PPC parameter block passed to the PPC Toolbox function.

Initializing

the

PPC

Toolbox

Use the PPCInit function to initialize the PPC Toolbox.
FUNCTION

PPCInit

On entry
On exit

:

OSErr;

DO: 0

DO: result code

After initialization, most PPC Toolbox routines can execute either synchronously or
asynchronously.
Result codes
noErr
noGlobalsErr

0
—904

No error
System unable to allocate memory, critical error

Note that a noGlobalsErr result code indicates that the PPC Toolbox is not loaded properly.

Using the Program

Linking

Dialog

Box

You can use either the PPCBrowser function or the IPCListPorts function to locate a port to
communicate with.
Use the PPCBrowser function to display the program linking dialog box, which allows a
user to select a port to communicate with.

I
reed

A

~

QD
J

PPC Toolbox Routines

7-39

°
=
=a
S

“

Inside Macintosh,

FUNCTION

Volume VI

PPCBrowser

(prompt:

Str255;

applListLabel:

defaultSpecified:
LocationNameRec;
portFilter:
;

Str255;

Boolean;
VAR theLocation:
VAR thePortInfo:
PortInfoRec;

PPCFilterProcPtr;

theLocNBPType:

Str32)

OSErr;

The prompt parameter is a line of text that the PPCBrowser function displays as a prompt in
the program linking dialog box. If you specify NIL or an empty string is passed, the default
prompt “Choose a program to link to:” is used.
The app|ListLabel parameter specifies the title of the list of PPC ports. If you specify NIL or
an empty string is passed, the default title “Programs” is used.
If the defaultSpecified parameter is TRUE, the PPCBrowser function tries to select the PPC
port specified by the parameters theLocation and thePortInfo when the program linking dialog
box first appears. The locationKindSelector field in the location name record must be set to the
ppcNoLocation constant (which specifies the local computer) or the ppcNBPLocation constant
(which specifies the NBP object and NBP zone). The ppcNBPTypeLocation constant is not
supported for matching. When matching the location, only the object string and the zone
string of the entity name are used—the type string is ignored. When matching the port, the
entire PPC port record (script, name, and port type) is used in the port information record.

The location name record and the port information record can be left uninitialized if the
defaultSpecified parameter is FALSE. The authRequired field of the port information record
is ignored.
The portFilter parameter determines how the list of PPC ports is filtered. If this parameter is
NIL, the names of all existing PPC ports are displayed. If this parameter isn’t NIL, it must
be a pointer to a port filter function.
A sample declaration for a port filter function named MyPortFilter follows.
FUNCTION

MyPortFilter

(theLoc:

LocationNamePtr;

PortInfoPtr)

:

thePortInfo:

Boolean;

The PPCBrowser function calls your port filter function once for each port before it adds that
port to the dialog list. This function should return TRUE for each port that should be displayed
in the program linking dialog box, and FALSE for each port that shouldn’t be displayed.
The parameter theLocNBPType of the PPCBrowser function specifies the NBP type passed
to NBPLookup to generate the list of computers. If you specify NIL or an empty string is
passed, the default, “PPCToolBox”, is used. Note that the current computer is always
included in the list of computers (even if a location with the specified type does not exist for
it). If the parameter the LocNBPType contains either of the NBP wildcard characters (= or =),
the PPCBrowser function returns a paramErr result code.
If the PPCBrowser function returns noErr, the parameters theLocation and thePortInfo
specify the port chosen by the user. If the PPCBrowser returns a userCanceledErr result
code, the user clicked the Cancel button, and no port was selected. If the function returns a
memFullErr result code, there was not enough memory to load the PPCBrowser package,
and the dialog box did not appear.

7-40

PPC Toolbox Routines

The PPC Toolbox

Note: You must not call the PPCBrowser function from an application that is
running in the background, since this function displays a dialog box on the user’s
screen.
Result codes

noErr

0

memFullErr

—108

userCanceledErr

—128

No error

Not enough memory to load PPCBrowser
package
User decided not to conduct a session

Obtaining a List of Ports
Use the IPCListPorts function to generate a list of existing ports without displaying a dialog
box. The IPCListPortsPBRec data type defines the parameter block used by the IPCListPorts
function.

FUNCTION

IPCListPorts

(pb:

IPCListPortsPBPtr;

On entry

AO: pointer to a parameter block

On exit

DO: result code

async:

Boolean)

:

OSErr;

DO: selector (10)

Parameter block

~

12

ioCompletion

long

address of a completion routine

—

16

ioResult

word

result code

>

40

startIndex

word

index to the port entry list

>

42

requestCount

word

number of port names requested

—

4

actualCount

word

number of port names returned

>

46

portName

long

pointer to PPCPortRec

~

50

locationName

long

pointer to LocationNameRec

>

54

bufferPtr

long

pointer to array of PortInfoRec

If your application calls this function asynchronously, you must specify in the ioCompletion
field either the address of a completion routine or NIL. If ioCompletion is NIL, you should
poll the ioResult field of the PPC parameter block (from your application’s main event loop)
to determine whether the PPC Toolbox has completed the requested operation. A value in the
ioResult field other than | indicates that the call is complete. Note that it is unsafe to poll the
ioResult field at interrupt time since the PPC Toolbox may be in the process of completing a
call. See “PPC Toolbox Calling Conventions” earlier in this chapter for detailed information.
~~
a
~
—~

O

|

PPC Toolbox Routines

7-41

—)
i)

4

~

Inside Macintosh,

Volume VI

If you call the IPCListPorts function asynchronously, you must not change any of the fields
in the parameter block until the call completes. The port name, location name, and buffer
pointed to by IPCListPortsPBRec are owned by the PPC Toolbox until the call completes.
These objects must not be deallocated or moved in memory while the call is in progress.
The startIndex field specifies the index to the list of ports on the remote machine from which
the PPC Toolbox begins to get the list. In most cases, you'll want to start at the beginning,
so set the startIndex field to 0. The requestCount field specifies the maximum number of port
information records that can fit into your buffer.
The actualCount field returns the actual number of entries returned. Your program can use the

IPCListPorts function repeatedly to obtain the entire list of ports. Ports that are not visible to

the network are not included in the ports listing on a remote machine. (If you specify FALSE
for the network Visible field in the PPCOpen function, the port is not included in the listing of
available ports across a network.)
The portName field must contain a pointer to a PPC port record that specifies which PPC ports
to list. You can specify particular values in the PPC port record or you can use an equal sign
(=) in the name or the portTypeStr fields as a wildcard to match all port names or port types.

The locationName field should contain a pointer to a location name record that designates the
computer that contains the PPC ports you want returned. If the locationKindSelector field in
the location name record is ppcNoLocation or if the locationName pointer is NIL, then the
location is the local machine. If the locationKindSelector field in the location name record is
ppcNBPLocation, then the location is a remote machine designated by the location name
record’s nbpEntity field.
The IPCListPorts function returns an array (list) of port information records in the area of

memory pointed to by bufferPtr. Make sure that the buffer pointed to by the bufferPtr field is

at least sizeof(PortInfoRec) * requestCount.
Result codes

noErr
notinitErr
nameTypeErr

0
—900
-902

noGlobalsErr
localOnlyErr
sess TableErr
noResponseErr
badPortNameErr
networkErr
badLocNameErr

—904
—905
—907
-915
—919
—925
—931

Opening

No error
PPC Toolbox has not been initialized yet
Invalid or inappropriate locationKindSelector in
location name
System unable to allocate memory, critical error
Network activity is currently disabled
PPC Toolbox is unable to create a session
Unable to contact application
PPC port record is invalid
An error has occurred in the network
Location name is invalid

and Closing a Port

You open a port using the PPCOpen function and close a port using the PPCClose function.
FUNCTION

7-42

PPCOpen

(pb:

PPCOpenPBPtr;

PPC Toolbox Routines

async:

Boolean)

:

OSErr;

The PPC Toolbox

On entry
On exit

AO: pointer to a parameter block
DO: selector (1)
DO: result code

Parameter block

>

12

ioCompletion

long

address of a completion routine

-

16

ioResult

word

result code

<—

38

portRefNum

word

—

44

serviceType

byte

+

45

resFlag

byte

port reference number of port
opened
service type requested—must be
ppcServiceRealTime
reserved field—must be 0

_

46

portName

long

pointer to PPCPortRec

cd

50

locationName

long

pointer to LocationNameRec

>

54

network Visible

byte

make this port network visible

<

50

nbpRegistered

byte

port location was registered on the
network

If your application calls this function asynchronously, you must specify in the ioCompletion
field either the address of a completion routine or NIL. If ioCompletion is NIL, you should
poll the ioResult field of the PPC parameter block (from your application’s main event loop)
to determine whether the PPC Toolbox has completed the requested operation. A value in the
ioResult field other than | indicates that the call is complete. Note that it is unsafe to poll the
ioResult field at interrupt time since the PPC Toolbox may be in the process of completing a
call. See “PPC Toolbox Calling Conventions” earlier in this chapter for detailed information.
If you call the PPCOpen function asynchronously, you must not change any of the fields in
the parameter block until the call completes. The port name and location name pointed to by
the PPCOpen parameter block record are owned by the PPC Toolbox until the call completes.
These objects must not be deallocated or moved in memory while the call is in progress.
The portRefNum field returns the PPC port identifier. Use this port reference number to
initiate a session for this particular port. Set the serviceType field to indicate that this port
accepts sessions in real time. For system software version 7.0, this field must always be
set to the ppcServiceRealTime constant. You must set the resFlag field to 0.
The portName field must contain a pointer to a PPC port record that specifies the name of the
PPC port to be opened.
The locationName field should contain a pointer to a location name record that designates the
location of the PPC port to be opened. If the locationName pointer is NIL, then the default
name PPC Toolbox is used. If a location name record is used, then the locationKindSelector
field in the location name record must be ppcNBPTypeLocation, and an alias location name
specified by the location name record’s nbpType field is used.

~
~

~~

CQ
oe

PPC Toolbox Routines

7-43

S

“s
*

Inside Macintosh, Volume VI

The network Visible field indicates whether the port should be made visible (for browsing
as well as incoming network requests). If you specify FALSE, this port is not visible in
the listing of available ports across a network (although it is still included within the local
machine’s listing of available ports).
The nbpRegistered field returns TRUE if the location name specified was registered on
the network.
Result codes

noErr
notinitErr
nameTypeErr

0
—900
—902

noPortErr
noGlobalsErr
badReqErr
portNameExistsErr
badPortNameErr
badServiceMethodErr

—9()3
—904
—909
-~910
—919
-—930

badLocNameErr
nbpDuplicateName

—931
—1027

No error
PPC Toolbox has not been initialized yet
Invalid or inappropriate locationKindSelector in
location name
Unable to open port
System unable to allocate memory, critical error
Bad parameter or invalid state for this operation
Another port is already open with this name
PPC port record is invalid
Service method is other than
ppcServiceRealTime
Location name is invalid
Location name represents a duplicate on this
computer

You use the PPCClose function to close the port specified by the port reference number.
FUNCTION

PPCClose

On entry
On exit

Parameter block
—
12

(pb:

PPCClosePBPtr;

async:

Boolean)

:

OSErr;

AO: pointer to a parameter block
DO: selector (9)
DO: result code

ioCompletion

long

address of a completion routine

«-

16

ioResult

word

result code

>

38

portRefNum

word

port reference number of port to
close

If your application calls this function asynchronously, you must specify in the ioCompletion
field either the address of a completion routine or NIL. If ioCompletion is NIL, you should
poll the ioResult field of the PPC parameter block (from your application’s main event loop)
to determine whether the PPC Toolbox has completed the requested operation. A value in
the ioResult field other than | indicates that the call is complete. Note that it is unsafe to
poll the ioResult field at interrupt time since the PPC Toolbox may be in the process of
completing a call. See “PPC Toolbox Calling Conventions” earlier in this chapter for detailed
information.
7-44

PPC Toolbox Routines

The PPC Toolbox

The portRefNum field specifies the PPC port identifier of the port to close. The port reference
number must be a valid port reference number returned from a previous call to the PPCOpen
function.
Result codes

noErr
notInitErr
noPortErr
noGlobalsErr

0
—900
—903
—904

Starting and Ending

No error
PPC Toolbox has not been initialized yet
Bad port reference number
System unable to allocate memory, critical error

a Session

You use the PPCStart or StartSecureSession function to initiate a session with another port,
and you use the PPCEnd function to end a session. The PPCStart function initiates a session
with the destination port specified in the name and location fields.
FUNCTION

PPCStart

On entry
On exit

(pb:

PPCStartPBPtr;

async:

Boolean)

:

OSErr;

AO: pointer to a parameter block
DO: selector (2)
DO: result code

Parameter block

>

12

ioCompletion

long

address of a completion routine

on

16

ioResult

word

result code

>

38

portRefNum

word

-

40

sessRefNum

long

>

at

serviceType

byte

>

45

resFlag

byte

port reference number of this
session
session reference number of this
session
service type requested—must be
ppcServiceRealTime
reserved field—must be 0

>
—

46
50

portName
locationName

long
long

pointer to PPCPortRec
pointer to LocationNameRec

—

54

rejectInfo

long

~

58

userData

long

value from PPCReject if session
was rejected
application-specific data

>

62

userRefNum

long

user reference number
~]
—
w
—
w

OQ
|
i)

PPC Toolbox Routines

7-45

cb
7%
—)

~

Inside Macintosh,

Volume V1

If your application calls this function asynchronously, you must specify in the ioCompletion
field either the address of a completion routine or NIL. If ioCompletion is NIL, you should
poll the ioResult field of the PPC parameter block (from your application’s main event loop)
to determine whether the PPC Toolbox has completed the requested operation. A value in the
ioResult field other than | indicates that the call is complete. Note that it is unsafe to poll the
ioResult field at interrupt time, since the PPC Toolbox may be in the process of completing a

call. See “PPC Toolbox Calling Conventions” earlier in this chapter for detailed information.

If you call the PPCStart function asynchronously, you must not change any of the fields in
the parameter block until the call completes. The port name and location name pointed to by
the PPCStart parameter block record are owned by the PPC Toolbox until the call completes.
These objects must not be deallocated or moved in memory while the call is in progress.
You specify the PPC port identifier in the portRefNum field. The port reference number is a
reference number for the port through which you are requesting a session. The value you
specify must correspond to the port reference number returned from the PPCOpen function.
The sessRefNum field returns a session identifier. This number, which is provided by the
PPC Toolbox, is used while data is being exchanged to identify a particular session. You
must set the serviceType field to indicate that the session is to be connected in real time.
For system software version 7.0, this field must always be set to the ppcServiceRealTime
constant. You must set the resFlag field to 0.
The portName field must contain a pointer to a PPC port record. The locationName field
should contain a pointer to a location name record or NIL. The PPC port record and the
location name record specify the name and location of the PPC port to initiate a session with,
and they are usually obtained from the PPCBrowser function. If the locationKindSelector
field in the location name record is ppcNoLocation or if the locationName pointer is NIL,
then the location is the local machine. If the locationKindSelector field in the location name
record is ppcNBPLocation, then the location is a remote machine designated by the location
name record’s nbpEntity field.
If the ioResult field of the PPC parameter block returns a userRejectErr result code, the
rejectInfo field contains the same value as the rejectInfo field in the PPCReject parameter
block. The rejectInfo field is defined by your application.
The initiating port can specify any information in the userData field. The PPCInform function
reports this data to the responding port upon its completion.
The userRefNum field specifies an authenticated user. The authentication mechanism of the
PPC Toolbox identifies each user through an assigned name and a password. A user reference
number of 0 indicates that you want to specify a guest.
Result codes

7-46

noErr
notinitErr
nameTypeErr

0
—900
—9()2

noPortErr
noGlobalsErr
localOnlyErr
destPortErr

—9()3
~904
—905
—906

PPC

Toolbox Routines

No error
PPC Toolbox has not been initialized yet
locationKindSelector is not ppcNBPLocation or
ppcNoLocation
Bad port reference number
System unable to allocate memory, critical error
Network activity is currently disabled
Port does not exist at destination

The PPC Toolbox

sessTableErr
noUserNameErr
userRejectErr
noResponseErr
portClosedErr
badPortNameErr
networkErr
noInformErr

—907
-91]
—9|2
—915
—916
—919
—925
—926

authFailErr
noUserRecErr
badServiceMethodErr

—927
—928
—930

guestNotAllowedErr

—932

PPC Toolbox is unable to create a session
User name unknown on destination machine
Destination rejected the session request
Unable to contact application
The port was closed
PPC port record is invalid
An error has occurred in the network
PPCStart failed because target application did not
have an inform pending
User’s password is wrong
Invalid user reference number
Service method is other than
ppcServiceRealTime
Destination port requires authentication

The StartSecureSession function prompts for user name and password and calls PPCStart—
all in one synchronous procedure call. Use the StartSecureSession function whenever a port
destination requires authentication.
FUNCTION

StartSecureSession

(pb:

PPCStartPBPtr;

useDefault:

VAR

Boolean;

VAR guestSelected:
: \OSErr;

userName:
allowGuest:

Boolean;

On entry

AO: pointer to a StartSecureParams record

On exit

DO: result code

Str32;
Boolean;

prompt:

Str255)

DO: selector (14)

Your program fills out a parameter block just as though it were calling the PPCStart function.
You specify all input fields in the parameter block except for the userRefNum field. The
userRefNum field is returned when the StartSecureSession function successfully completes.
The pb parameter is a pointer to the PPCStart parameter block.
The userName parameter is a pointer to a 32-byte character string to be displayed as the
user’s name. If the Pascal string length is 0, the default user name is used. The default
user name is the name specified in the Sharing Setup control panel. The default user
name is returned in the userName buffer.
Set the useDefault parameter to TRUE if you want the StartSecureSession function to use the
default user identity (and possibly prevent the user identity dialog box from appearing). The
allowGuest parameter specifies whether the Guest radio button in the user identity dialog box
is active. It is usually set to the inverse of the authRequired field in the port information
record. For example, if authRequired is TRUE, then allowGuest should be set to FALSE.
The guestSelected parameter returns TRUE if the user has logged on as a guest. The prompt
parameter of the StartSecureSession function allows you to specify a line of text that the
dialog box can display. Specify NIL or an empty string for the prompt parameter to enable
the PPC Toolbox to use the default prompt. The PPC Toolbox uses the default string “Link
PPC Toolbox Routines

7-47

~~]

a2)

~~
QO?
fae
o
=
S
%

Inside Macintosh, Volume VI

to <port name> on <object string> as:”. The port name is obtained from the name string of
the port name, and the object string is obtained from the object string of the location name.
Note: Do not call the StartSecureSession function from an application that is running
in the background, since this function requires that several dialog boxes appear on the
user’s screen.
Result codes

noErr
userCanceledErr
notinitErr
nameTypeErr

0)
—128
—900
—9()2

noPortErr
noGlobalsErr
localOnlyErr
destPortErr
sessTableErr
noResponseErr
portClosedErr
badPortNameErr
noUserRefErr
networkErr
noInformErr

—903
—904
—905
—906
—9()7
-915
-916
-919
—924
-925
-926

badServiceMethodErr

-930

guestNotAllowedErr

-—932

No error
User decided not to conduct a session
PPC Toolbox has not been initialized yet
locationKindSelector is not ppcNBPLocation or
ppcNoLocation
Bad port reference number
System unable to allocate memory, critical error
Network activity is currently disabled
Port does not exist at destination
PPC Toolbox is unable to create a session
Unable to contact application
The port was closed
PPC port record is invalid
Unable to create a new user reference number
An error has occurred in the network
PPCStart failed because application did not have
an inform pending
Service method is other than
ppcServiceRealTime
Destination port requires authentication

Use the PPCEnd function to end a session. This function completes all outstanding
asynchronous calls associated with the session reference number.
FUNCTION

PPCEnd

PPCEndPBPtr;

async:

Boolean)

On entry

AO: pointer to a parameter block

On exit

DO: result code

Parameter block
>
12

7-48

(pb:

:

OSErr;

DO: selector (8)

ioCompletion

long

address of a completion routine

-

16

ioResult

word

result code

>

40

sessRefNum

long

session reference number of session
to end

PPC Toolbox Routines

The PPC Toolbox

If your application calls this function asynchronously, you must specify in the ioCompletion
field either the address of a completion routine or NIL. If ioCompletion is NIL, you should
poll the ioResult field of the PPC parameter block (from your application’s main event loop)
to determine whether the PPC Toolbox has completed the requested operation. A value in the
ioResult field other than | indicates that the call is complete. Note that it is unsafe to poll the
ioResult field at interrupt time since the PPC Toolbox may be in the process of completing a
call. See “PPC Toolbox Calling Conventions” earlier in this chapter for detailed information.
You provide a session identifier in the sessRefNum field to identify the session that you are
terminating. The PPCStart, StartSecureSession, or PPCInform function returns the session
reference number.
Result codes

noErr
notInitErr
noGlobalsErr
noSessionErr

Receiving,

0
—900
—90)4
—908

Accepting,

and

No error
PPC Toolbox has not been initialized yet
System unable to allocate memory, critical error
Invalid session reference number

Rejecting

a Session

You use the PPCInform function to receive session requests. After the PPCInform function
completes (with the autoAccept field set to FALSE), you must accept or reject the session
request using the PPCAccept and PPCReject functions.
As long as a port has been opened, you can call the PPCInform function at any time. You can
have any number of outstanding PPCInform functions.
FUNCTION

PPCInform

On entry
On exit

(pb:

PPCInformPBPtr;

async:

Boolean)

:

OSErr;

AO: pointer to a parameter block
DO: selector (3)
DO: result code

Parameter block

—

12

ioCompletion

long

address of a completion routine

<

16

ioResult

word

result code

=>

38

portRefNum

word

—

40

sessRefNum

long

<

44

serviceType

byte

port reference number of this
session
session reference number of this
session
service type of this session

>

45

autoAccept

byte

if TRUE, session is accepted
automatically

PPC Toolbox Routines

I
a

~

(Continued)

OQ

7-49

S
=
>
S

—
”

Inside Macintosh,

Volume

VI

>

46

portName

long

>

50

locationName

long

ad

54

userName

long

pointer to PPCPortRec, may be
NIL
pointer to LocationNameRec, may
be NIL
pointer to Str32, may be NIL

—

58

userData

long

application-specific data

e

62

requestT ype

byte

network or local request

If your application calls this function asynchronously, you must specify in the ioCompletion

field either the address of a completion routine or NIL. If ioCompletion is NIL, you should

poll the ioResult field of the PPC parameter block (from your application’s main event loop)
to determine whether the PPC Toolbox has completed the requested operation. A value in the
ioResult field other than | indicates that the call is complete. Note that it is unsafe to poll the
ioResult field at interrupt time since the PPC Toolbox may be in the process of completing a
call. See “PPC Toolbox Calling Conventions” earlier in this chapter for detailed information.
If you call the PPCInform function asynchronously, you must not change any of the fields in
the parameter block until the call completes. The port name, location name, user name, and
buffer pointed to by the record of type PPCInformPBRec are owned by the PPC Toolbox
until the call completes. These objects must not be deallocated or moved in memory while the
call is in progress.
You provide the PPC port identifier in the portRefNum field. A PPCOpen function returns
the port identifier. The sessRefNum field returns a session identifier.
The serviceType field indicates the service type. For system software version 7.0, this field
always returns the ppcServiceRealTime constant.
If you set the autoAccept field to TRUE, session requests are automatically accepted as they
are received. When the PPCInform function completes execution with a noErr result code
and you set the autoAccept field to FALSE, you need to accept or reject the session.
A

Warning:

If the PPCInform function (with the autoAccept parameter set to

FALSE) returns a noErr result code, you must call either the PPCAccept function
or the PPCReject function. The computer trying to initiate a session using the
StartSecureSession function or the PPCStart function waits (hangs) until the

session attempt is either accepted or rejected, or until an error occurs.

a

The portName field must contain NIL or a pointer to a PPC port record. If the portName field
contains NIL, then the name of the PPC port that initiated the session is not returned. If the
portName field points to a PPC port record, then the PPC port record is filled with the name
of the PPC port that initiated the session when the PPCInform function completes.
The locationName field must contain NIL or a pointer to a location name record. If the
locationName field contains NIL, then the location of the PPC port that initiated the
session is not returned. If the locationName field points to a location name record, then
the location name record is filled with the location of the PPC port that initiated the session

7-50

PPC Toolbox Routines

The PPC Toolbox

when the PPCInform function completes. If the locationKindSelector field of the location
name record returned is ppcNoLocation, then the location is the local machine. If the
locationKindSelector field of the location name record returned is ppcNBPLocation, then
the location is a remote machine designated by the location name record’s nbpEntity field.
The userName field must contain NIL or a pointer to a 32-byte character string. If the
userName field contains NIL, then the user name string is not returned. If the userName
field points to a 32-byte character string, then the 32-byte character string is filled with
the name of the user making the session request (if authenticated) when the PPCInform
function completes.
When the PPCInform function completes, the userData field contains the user data provided
by the application making the session request. This field is transparent to the PPC Toolbox.
The application can send any data in this field.
When the PPCInform function completes, the requestType field contains either ppcRemoteOrigin
or ppcLocalOrigin, depending on whether the session request is initiated by a computer across
the network or by a port on the same computer.
You should execute the PPCInform function asynchronously.
Result codes

noErr
notinitErr
noPortErr

0)
—900
—903

noGlobalsErr
portClosedErr

—904
~916

No error
PPC Toolbox has not been initialized yet
Unable to open port or bad port reference
number
System unable to allocate memory, critical error
The port was closed

Use the PPCAccept function to indicate that an application is willing to accept an incoming
session request after a PPCInform function completes.
FUNCTION

PPCAccept

On entry
On exit

(pb:

PPCAcceptPBPtr;

async:

Boolean)

:

OSErr;

AO: pointer to a parameter block
DO: selector (4)
DO: result code

Parameter block

—

12

ioCompletion

long

address of a completion routine

-

16

ioResult

word

result code

>

40

sessRefNum

long

session reference number of session
to accept
~I
a)

youn
~

OQ

|
S
Sc

PPC Toolbox Routines

7-51

S
P|

Inside Macintosh,

Volume

VI

If your application calls this function asynchronously, you must specify in the ioCompletion
field either the address of a completion routine or NIL. If ioCompletion is NIL, you should
poll the ioResult field of the PPC parameter block (from your application’s main event loop)
to determine whether the PPC Toolbox has completed the requested operation. A value in the
ioResult field other than | indicates that the call is complete. Note that it is unsafe to poll the
ioResult field at interrupt time since the PPC Toolbox may be in the process of completing a
call. See “PPC Toolbox Calling Conventions” earlier in this chapter for detailed information.
The sessRefNum field specifies a session identifier. Use the session reference number
returned from the completed PPCInform parameter block to accept the session request.
Result codes

noErr

0)

notInitErr
noGlobalsErr
noSessionErr
badRegErr

~900
—904
—908
—9()9

No error

PPC Toolbox has not been initialized yet
System unable to allocate memory, critical error
Invalid session reference number
Invalid state for this operation

Use the PPCReject function to reject a session request after a PPCInform function completes.
FUNCTION

PPCReject

On entry
On exit

(pb:

PPCRejectPBPtr;

async:

Boolean)

:

OSErr;

AO: pointer to a parameter block
DO: selector (5)
DO: result code

Parameter block

—

12

ioCompletion

long

address of a completion routine

<

16

ioResult

word

result code

=>

40

sessRefNum

long

~

54

rejectInfo

long

session reference number of session
to reject
value to return if session is rejected

If your application calls this function asynchronously, you must specify in the ioCompletion
field either the address of a completion routine or NIL. If ioCompletion is NIL, you should
poll the ioResult field of the PPC parameter block (from your application’s main event loop)
to determine whether the PPC Toolbox has completed the requested operation. A value in the
ioResult field other than | indicates that the call is complete. Note that it is unsafe to poll the
ioResult field at interrupt time since the PPC Toolbox may be in the process of completing a
call. See “PPC Toolbox Calling Conventions” earlier in this chapter for detailed information.
The sessRefNum field specifies a session to be rejected. This must be a valid session
reference number returned from a previous PPCInform function. The rejectInfo field is
an optional field. The application receiving a session request may specify any data in this
field. The initiating application receives this information in the PPCStart parameter block.
7-52

PPC Toolbox Routines

The PPC Toolbox

Result codes

noErr
notInitErr
noGlobalsErr
noSessionErr
badReqErr

Reading

and

0
—900
—904
—908
—9()9

Writing

No error
PPC Toolbox has not been initialized yet
System unable to allocate memory, critical error
Invalid session reference number
Invalid state for this operation

Data

The PPCRead function reads incoming data from an application, and the
writes data to an application during a session.

PPC Write function

Use the PPCRead function to read message blocks during a session.
FUNCTION

PPCRead

(pb:

PPCReadPBPtr;

async:

Boolean)

On entry

AO: pointer to a parameter block

On exit

DO: result code

Parameter block
>
12

:

OSErr;

DO: selector (7)

ioCompletion

long

address of a completion routine

<-

16

ioResult

word

result code

>

40

sessRefNum

long

session reference number

>

ht

bufferLength

long

length of data buffer

oa

48

actualLength

long

actual length of data read

>

52

bufferPtr

long

pointer to data buffer

<-

56

more

byte

—

58

userData

long

TRUE if more data in this block to
be read
application-specific data

62

blockCreator

long

creator of block read

66

blockType

long

type of block read

—

If your application calls this function asynchronously, you must specify in the ioCompletion
field either the address of a completion routine or NIL. If ioCompletion is NIL, you should
poll the ioResult field of the PPC parameter block (from your application’s main event loop)
to determine whether the PPC Toolbox has completed the requested operation. A value in the
ioResult field other than | indicates that the call is complete. Note that it is unsafe to poll the
ioResult field at interrupt time since the PPC Toolbox may be in the process of completing a
call. See “PPC Toolbox Calling Conventions” earlier in this chapter for detailed information.

Ss)
—

ww

—

a

OQ
ae

PPC Toolbox Routines

7-53

°
=
=%
S
*

Inside Macintosh,

Volume

VI

If you call the PPCRead function asynchronously, you must not change any of the fields in
the parameter block until the call completes. The buffer pointed to by the record of data type
PPCReadPBRec is owned by the PPC Toolbox until the call completes. These objects must
not be deallocated or moved in memory while the call is in progress.
The sessRefNum field specifies a session to read data from. This must be a valid session
reference number returned from a previous PPCStart, StartSecureSession, or PPCInform
function. The bufferLength and bufferPtr fields specify the length and location of a buffer
the message block will be read into. Your application must allocate the storage for the buffer.
The actualLength field returns the actual size of the data read into your data buffer.
The more field is TRUE if the provided buffer cannot hold the remainder of the message
block. Your application may read a message block in several pieces. It is not necessary to
have a buffer large enough to read in the entire message block, so a message block can span
multiple calls to the PPCRead function.
Upon completion of the PPCRead function, the userData, blockCreator, and blockType fields
contain information regarding the contents of the message block. You specify these fields
using the PPCWrite function. See “Exchanging Data During a PPC Session” earlier in this
chapter for additional information.
You should execute the PPCRead function asynchronously.
Result codes

noErr
notInitErr
noGlobalsErr
noSessionErr
badReqErr
sessClosedErr

0
—900
—904
—908
—9()9
-917

No error
PPC Toolbox has not been initialized yet
System unable to allocate memory, critical error
Invalid session reference number
Invalid state for this operation
The session has closed

Use the PPCWrite function to write message blocks during a session.
FUNCTION

PPCWrite

On entry
On exit

(pb:

PPCWritePBPtr;

async:

Boolean)

:

OSErr;

AO: pointer to a parameter block

DO: selector (6)
DO: result code

Parameter block

7-54

>

[2

ioCompletion

long

address of a completion routine

—

16

ioResult

word

result code

=

40

sessRefNum

long

session reference number

>

44

bufferLength

long

length of data buffer

—

48

actualLength

long

actual length of data written

PPC Toolbox Routines

The PPC Toolbox

>

52

bufferPtr

long

pointer to data buffer

>

56

more

byte

—

58

userData

long

TRUE if more data in this block to
be written
application-specific data

—

62

blockCreator

long

creator of block written

>

66

blockT ype

long

type of block written

If your application calls this function asynchronously, you must specify in the ioCompletion
field either the address of a completion routine or NIL. If ioCompletion is NIL, you should
poll the ioResult field of the PPC parameter block (from your application’s main event loop)
to determine whether the PPC Toolbox has completed the requested operation. A value in the
ioResult field other than | indicates that the call is complete. Note that it is unsafe to poll the
ioResult field at interrupt time since the PPC Toolbox may be in the process of completing a
call. See “PPC Toolbox Calling Conventions” earlier in this chapter for detailed information.
If you call the PPCWrite function asynchronously, you must not change any of the fields in
the parameter block until the call completes. The buffer pointed to by the record of data type
PPCWritePBRec is owned by the PPC Toolbox until the call completes. These objects must
not be deallocated or moved in memory while the call is in progress.
The sessRefNum field specifies a session identifier. This must be a valid session reference
number returned from a previous PPCStart, StartSecureSession, or PPCInform function.
The bufferLength and bufferPtr fields specify the length and location of a buffer the message
block is sent to. If the PPCWrite function returns a noErr result code, the actualLength field
returns the actual size of the message block that was written.
Set the more field to TRUE to indicate that you will be using another PPC Write function to
append data to this message block. Set the more field to FALSE to indicate that this is the end
of the data in this message block.
The initiating port can specify any information in the userData field. The PPCRead function
reports this data to the responding port upon its completion.
Set the userData, blockCreator, and blockType fields for each message block that you create.
These fields can give the receiving application information about how to process the contents
of the message block. They are ignored when you append information to a message block.
Set the more field to TRUE to append additional data to a message block; otherwise, set this
field to FALSE. See “Exchanging Data During a PPC Session” earlier in this chapter for
additional information.
You should execute the
Result codes

noErr
notinitErr
noGlobalsErr
noSessionErr
badRegErr
sessClosedErr

PPC Write function asynchronously.

0
—900
—9()4
—908
—909
—917

No error
PPC Toolbox has not been initialized yet
System unable to allocate memory, critical error
Invalid session reference number
Invalid state for this operation
The session has closed

|
Caras

Vv
=
o}

OQ
aw
—)

PPC Toolbox Routines

7-55

=

i-e
—)
wv

Inside Macintosh,

Locating

Volume V1

a Default User and

Invalidating a User

The GetDefaultUser function returns the user reference number and the name of the default
user. The default user is specified in the Sharing Setup control panel. This function is useful
if your application uses the PPCStart function to initiate a session with an application that
does not support guest access.
FUNCTION

GetDefaultUser

(VAR

userRef:

LongInt;

VAR

userName:

Str32)

OSErY}

On entry
On exit

AO: pointer to a GetDefaultUserParams record
DO: selector (13)
DO: result code

If the GetDefaultUser function completes with no errors, then the userRef parameter returns
the user reference number that represents the user name and password of the default user.
The userName parameter must contain NIL or a 32-byte character string. If the userName
parameter contains NIL, then the user name string is not returned. If the userName parameter
is a 32-byte character string, the 32-byte character string contains the user name that is
specified in the Sharing Setup control panel when the GetDefaultUser function completes
(with no errors).

A

Warning: If you are using Pascal, you cannot pass NIL for the userName
parameter. For example, you cannot pass StringPtr(NIL)* due to Pascal range
checking of string bounds. a

Result codes

noErr
noDefaultUserErr

0
-922

noLoggedInErr

—923

No error
User has not specified owner name in Sharing
Setup control panel
Default user reference number does not yet exist

To invalidate a particular user name and corresponding password, use the DeleteUserldentity
function.
FUNCTION

DeleteUserIdentity

(userRef:

LongInt)

:

OSErr;

Trap macro
On entry

_DeleteUser
AO: pointer to a DeleteUserParams record

On exit

DO: result code

DO: selector (12)

You specify the reference number representing the user name and password to be deleted.
Result codes
noErr

noUserRecErr
7-56

0

~928

PPC Toolbox Routines

No error

Invalid user reference number

The PPC Toolbox

SUMMARY

OF

THE

PPC

TOOLBOX

onstants
CONST

{service

type)
{real
time
{ software

popcServiceRealTime

{gestalt

system
7.0}

}

selectors}

gestaltPPCToolboxAttr

‘ppc

gestaltPPCToolboxPresent

$0000;
$1000;

gestaltPPCSupportsRealTime

vs

{PPC
{PPC

Toolbox
Toolbox

{real

time

{

attributes}
is present}
only

software

in

version

system

}

7.0}

$0002;

{support
of outgoing
}
{ sessions
across a network}

gestaltPPCSupportsIncoming

$0001;

{user enabled program
}
in Sharing
Setup
{ linking

Il

PPCSupportsOutGoing

gestalt

{
{look-up

control

type}

{there is no PPCLocName
{ AppleTalk NBP}

pPCcNBPTypeLocation

{use
{ in

{port

}

panel}

ppcNoLocation
ppcNBPLocation

type}

{port

ppcByCreatorAndType

{

{
{session
request
ppcLocalOrigin

type

returned

in

the

=)
=

ppcRemoteOrigin

just
the
the rest

2;

use}

NBP type,
fill}
with default}

type

is

specified

as

}

standard

Mac

creator

and

}

is

in

{ type}
{port type

=. Bis

ppcByString

Data

only
in
version

string

Pascal

}

format}

PPCInform
function}
{session
initiated
on
{ local
computer}

}

{session

initiated

}

{

computer}

remote

on

Types

TYPE
PPCServiceType

=

PPCLocationKind

=

{service
{look-up

=

SignedByte;
Integer;
Integer;

PPCPortKinds

PPCSessionOrigin

type}
type}

=

{port

type}

SignedByte;

{local

or

PPCPortRefNum

=

PPCSessRefNum

=

Integer;
LongInt;

{port
reference
number}
{session
reference
number}

remote}

Summary of the PPC Toolbox

7-57

Inside Macintosh, Volume V1

LocationNamePtr

=

“LocationNameRec;

LocationNameRec
RECORD

locationKindSelector

PPCLocationkind;
{which

CASE

PPCLocationKind

variant}

OF

ppcNBPLocation:

(nbpEntity:

PPCNBPTypeLocation:

(nbpType:

{ppcNoLocation:

storage

not

}

{ used by this value}
EntityName) ;
{NBP name entity}
Str32)

{just

the

NBP

{

the

PPCOpen

for

type

string

}

function}

END;
PortInfoPtr

=

PortiInfoRec

=

*PortInfoRec;

RECORD

fillerl:
authRequired:

SignedByte;
Boolean;

{space holder}
{authentication

name:

PPCPortRec

{port

nameScript:

ScriptCode;

{script

name:

Str32;

{port

required}

name}

END;
PPCPortPtr
PPCPortRec
RECORD

=
=

“PPCPortRec;

{

portKindSelector:
CASE PPCPortKinds
ppcByString:

OF

identifier}
name

linking

shown

in

dialog

box}

program

PPCPortKinds;

{general category
{ application}

of

}

(portTypeStr:

Str32);
{32 characters}

(portCreator:

OSType;
portType:
OSType)
{4-character
creator
and

ppcByCreatorAndType:

{

END;
PPCParamBlockPtr

=

PPCParamBlockRec
RECORD

=

*“PPCParamBlockRec;

CASE Integer OF
0:
(openParam:
1:
(informParam:

PPCOpenPBRec) ;
PPCInformPBRec)

;

{PPCOPen params}
{PPCInform params}

2:
3:

(startParam:
(acceptParam:

PPCStartPBRec) ;
PPCAccept PBRec) ;

{PPCStart
params}
{PPCAccept
params}

4:

(rejectParam:

PPCRejectPBRec)

{PPCReject

5:

(writeParam:

PPCWritePBRec)

6:
7:

(readParam:
(endParam:

PPCReadPBRec) ;
PPCEndaPBRec) ;

8:

(closeParam:

PPCClosePBRec)

9:

(listPortsParam:

IPCListPortsPBRec)

END;

7-58

}

type}

Summary of the PPC Toolbox

;

;

{PPCWrite

params}

params}

{PPCRead params}
{PPCEnd params}
;

{PPCClose

params}

{IPCListPorts

params}

}

The PPC Toolbox

PortInfoArrayPtr

=

*PortInfoArray;

PortInfoArray

=

ARRAY[0..0]

PPCOpenPBPtr

=

PPCOpenPBRec

=

OF

PortInfoRec;

*“PPCOpenPBRec;

RECORD

qLink:

Ptr;

{private}

csCode:

Integer;

{private}

intUse:

Integer;

{private}

intUsePtr:

Ptr;

{private}

ioCompletion:

PPCCompProcPtr;

ioResult:

OSErr;

{address of
{ routine}
{completion

reserved:

ARRAY[1..5]

OF

a

completion

of

operation}

LongInt;
{private}

portRefNum:

PPCPortRefNum;

{PPC

fillerl:

Longint;

{space

serviceType:

PPCServiceType;

{real

resFlag:

SignedByte;

{reserved

portName:

PPCPort Ptr;

{name

of

port

to

locationName:

LocationNamePtr;

{location

of

port

networkVisible:

Boolean;

{

port

Boolean

identifier}

holder}
time

only}

field}
opened

to

be

for

}

}

}

is

visible

browsing}

{location
{

be

opened}

{port
{

nbpRegistered:

}

on

name

registered

}

network}

END;

PPCInformPBPtr
PPCInformPBRec
RECORD
qLink:

=
=

*PPCInformPBRec;

Ptr;

{private}

csCode:
intUse:

Integer;
Integer;

{private}
{private}

intUsePtr:

Ptr;

{private}

ioCompletion:

PPCCompProcPtr;

{address

of

a

completion

{completion

of

operation}

{

ioResult:

OSErr;

reserved:

ARRAY[1..5]

portRefNum:

PPCPortRefNum;

{port

sessRefNum:

PPCSessRefNum;

{session

serviceType:

PPCServiceType;

{real

autoAccept:

Boolean;

{automatic
session
{ acceptance}

}

portName:

PPCPort

{name

}

locationName:

LocationNamePtr;

{ initiated a session}
{location of port that
{ initiated a session}

userName:

StringPtr;

{name

OF

Ptr;

}

routine}

LongInt;
{private}

{

identifier}
identifier}

time

of

of

only}

port

user

initiated

a

that

that

}

session}

userData:

LongInt;

{application-defined}

requestType:

PPCSessionOrigin

{local

or

}

=
=
w
Sot

remote}

w

o)

END;

J

Summary of the PPC Toolbox

7-59

°
S
=h

Inside Macintosh, Volume VI

PPCStartPBPtr

=

PPCStartPBRec

=

*PPCStartPBRec;

RECORD

qLink:

Ptr;

{private}

csCode:

Integer;

{private}

intUse:

Integer;

{private}

intUsePtr:
L1oCompletion:

Ptr;
PPCCompProcPtr;

{private}
{address of
{ routine}

ioResult:
reserved:

OSErr;
ARRAY[1..5]

portRefNum:

PPCPortRefNum;

{identifier

PPCSessRefNum;
PPCServiceType;
Signed Byte;

{ port}
{session identifier}
{real time only}
{reserved field}

portName:

PPCPort Ptr;

{name

locationName:

LocationNamePtr;

rejectInfo:
userData:
userRefNum:

Longint;
LongInt;
Longint

{location of port to be }
{ opened}
{rejection of session}
{application-specific}
{specifies an authenticated

OF

{completion
LongInt;

a

completion

of

operation}

for

requested

}

{private}

sessRefNum:
serviceType:
resFlag:

{

of

port

to

be

}

opened}

user}

END;

PPCAcceptPBPtr

=

PPCAccept

=

PBRec

*“PPCAccept

PBRec;

RECORD
qLink:

Ptr;

{private}

csCode:
intUse:

Integer;
Integer;

{private}
{private}

intUsePtr:

Ptr;

{private}

ioCompletion:

PPCCompProcPtr;

{address

of

a

completion

{completion
LongInt;

of

operation}

{
ioResult:
reserved:

OSErr;
ARRAY[1..5]

fillerl:
sessRefNum:

Integer;
PPCSessRefNum

OF

}

routine}

{private}

{space holder}
{session identifier}

END;

PPCRejectPBPtr

=

PPCRejectPBRec

=

*PPCRejectPBRec;

RECORD

qLink:

Ptr;

{private}

csCode:
intUse:

Integer;
Integer;

{private}
{private}

intUsePtr:

Ptr;

{private}

ioCompletion:

PPCCompProcPtr;

{address

ioResult:

7-60

OSErr;

Summary of the PPC Toolbox

of

a

completion

{completion

of

operation}

{

routine}

}

}

The PPC Toolbox

reserved:

ARRAY(1..5]

OF

fillerl:

Integer;

sessRefNum:

PPCSessRefNum;

LongInt;
{private}
{space

holder}

{session

identifier}

filler2:
filler3:

Integer;

{space

holder}

Longint;

{space

holder}

filler4:

Longint;

{space

holder}

rejectiInfo:

LongInt

{rejection

of

session}

END;

PPCWritePBPtr
PPCWritePBRec

=

“PPCWritePBRec;

RECORD

qLink:

Ptr;

{private}

csCode:

Integer;

{private}

intUse:
intUsePtr:
ioCompletion:

Integer;

{private}

PErs

{private}

PPCCompProcPtr;

{address of
{ routine}

a

completion

{completion
LongInt;

of

operation}

ioResult:

OSErr:

reserved:

ARRAY[1..5]

fillerl:

{space

sessRefNum:

Integer;
PPCSessRefNum;

bufferLength:

Size;

{length

{ written}
{actual size
{location of

OF

}

{private}

actualLength:

Size;

bufferPtr:

Ptr;

more:

Boolean;

{

buffer

to

be

}

of data written}
buffer to be }

written}

data

to

be

}

written}

SignedByte;
LongInt;

{space

userData:

blockCreator:

OSType;

{creator

OSType

{type

blockType:

identifier}
of

{additional
{

filler2:

holder}

{session

holder}

{application-specific}
of

block

to

be

}

be

written}

{ written}
of

block

to

END;
PPCReadPBPtr

“PPCReadPBRec;

PPCReadPBRec

RECORD
qLink:

Ptr;

{private}

csCode:

Integer;

{private}

intUse:
intUsePtr:
ioCompletion:

Integer;

{private}
{private}
{address
of

ioResult:
reserved:

OSErr;

filleri:

Integer;
PPCSessRefNum;
Size;

Ptr

PPCCompProcPtr;

{
ARRAY[1..5]

OF

a

completion

of

operation}

}

routine}

{completion
LongInt;
{private}

sessRefNum:
bufferLength:

{space

holder}

{session
{length

~]

identifier}

of

buffer

to

be

Summary of the PPC Toolbox

read}

7-61

=
w

~~

-Q
a
o

xt

a
x

Inside Macintosh, Volume VI

actualLength:

{actual

Size;

{
bufferPtr:

Ptr;

{location
{

more:

Boolean;

filler2:

SignedByte;

size

of

the

data

}

read}
of

buffer

to

be

}

be

read}

read}

{additional
{space

data

to

holder}

userData:

Longint;

{application-specific}

blockCreator:

OSType;

{creator

of

blockType:

OSType

{type

block

of

block
to

to

be

be

read}

read}

END;
PPCEndaPBPtr
PPCEndPBRec

=
=

*PPCEndPBRec;

RECORD

qLink:

Ptr;

csCode:

Integer;

intUse:

Integer;

intUsePtr:
ioCompletion:

Ptr;
PPCCompProcPtr;

{private}
{private}
{private}
{private}

{address of
{ routine}
{completion

a

completion

of

operation}

ioResult:

OSErr;

reserved:

ARRAY[1..5]

fillerl:

Integer;

{space

sessRefNum:

PPCSessRefNum

{identifier of session
{ be terminated}

OF

}

LongInt;

{private}
holder}

to

}

END;

PPCClosePBPtr

=

PPCClosePBRec

=

*“PPCClosePBRec;

RECORD

qLink:

Per?

{private}

csCode:
intUse:

Integer;
Integer;

{private}

intUsePtr:
ioCompletion:

Ptr;
PPCCompProcPtr;

{private}

{private}

ioResult:

OSErr;

reserved:

ARRAY[1..5]

portRefNum:

PPCPortRefNum

OF

{address of
{ routine}
{completion

a

completion

}

of

operation}

of

port

a

completion

LongInt;

{private}
{identifier
{

be

to

}

closed}

END;
IPCListPortsPBPtr

=

IPCListPortsPBRec

=

“IPCListPortsPBRec;

RECORD

7-62

qLink:

Ptr;

csCode:

Integer;

intUse:

Integer;

intUsePtr:
ioCompletion:

Ptr;
PPCCompProcPtr;

Summary of the PPC Toolbox

{private}
{private}
{private}
{private}
{address
of
{ routine}

}

The PPC Toolbox

ioResult:

OSErr;

{completion
OF

of

reserved:

ARRAY[1..5]

filleri:

Integer;

{private}
{space holder}

startiIndex:

Integer;

{index

{
requestCount

:

operation}

LongInt;

Integer;

to

the

of

entries

{number
{

port

entry

}

list}
be

to

}

returned}

actualCount:
portName:

Integer;
PPCPort Ptr;

{actual
number
of port
{list
of port
names}

names}

locationName:
bufferPtr:

LocationNamePtr;
PortInfoArrayPtr

{location
of port
names}
{pointer
to a buffer}

END;

Routines
Initializing the
FUNCTION

PPCInit

PPC
:

OSErr;

Using the Program
FUNCTION

Toolbox

PPCBrowser

Linking Dialog Box
(prompt:
Str255;
applListLabel:
Str255;
defaultSpecified:
Boolean;
VAR theLocation:
LocationNameRec;
VAR thePortInfo:
PortInfoRec;

portFilter:
Str32)

;:

PPCFilterProcPtr;

theLocNBPType:

OSErr;

Obtaining a List of Ports
FUNCTION

Opening

IPCListPorts

(ob:

IPCListPortsPBPtr;

async:

Boolean)

:

OSErr;

and Closing a Port

FUNCTION

PPCOpen

(pb:

PPCOpenPBPtr;

FUNCTION

PPCClose

(pb:

PPCClosePBPtr;

async:
async:

Boolean)
Boolean)

:

OSErr;
:

OSErr;

a |
—

~

~
¢

—

Summary of the PPC Toolbox

7-63

ao
ww
~
—
—
—
—d

o
ws

4
,
4

Inside Macintosh, Volume VI

Starting and Ending

a Session

PPCStart

(pb:

FUNCTION

StartSecureSession

(pb:
PPCStartPBPtr;
VAR userName:
useDefault:
Boolean;
allowGuest:
VAR

guestSelected:

:

Boolean)

async:

PPCStartPBPtr;

FUNCTION

Boolean;

OSErr;

Str32;
Boolean;

prompt:

Str255)

OSErr;
FUNCTION

PPCEnd

Receiving,

(pb:

Accepting,

PPCEndPBPtr;

and

Rejecting

async:

Boolean)

:

OSErr;

a Session

FUNCTION

PPCInform

(pb:

PPCInformPBPtr;

async:

Boolean)

:

OSErr;

FUNCTION

PPCAccept

(pb:

PPCAcceptPBPtr;

async:

Boolean)

:

OSErr;

FUNCTION

PPCReject

(pb:

PPCRejectPBPtr;

async:

Boolean)

:

OSErr;

Reading

and

FUNCTION

PPCRead

(pb:

PPCReadPBPtr;

FUNCTION

PPCWrite

(pb:

PPCWritePBPtr;

Locating
FUNCTION

Writing

Data

a Default User and
GetDefaultUser

(VAR

async:

Boolean)

async:

:

Boolean)

OSErr;
:

OSErr;

Invalidating a User
userRef:

LongInt;

VAR

userName:

Str32)

OSErr;
FUNCTION

DeleteUserIdentity

Application-Defined
PROCEDURE
FUNCTION

7-64

LongInt)

:

OSErr;

Routines

MyCormpletionRoutine
MyPortFilter

(userRef:

(pb:

PPCParamBlockPtr) ;

(locationName:

LocationNameRec;

thePortInfo:

PortInfoRec)

Summary of the PPC Toolbox

:

Boolean;

The PPC Toolbox

Result

Codes

noErr

paramErr

memFullErr
userCanceledErr
notInitErr

nameTypeErr

noPortErr
noGlobalsErr

localOnlyErr

destPortErr
sess TableErr
noSessionErr

badReqErr
portNameExistsErr
noUserNameErr

userRejectErr
noResponseErr
portClosedErr

sessClosedErr
badPortNameErr
noDefaultUserErr

0
—50
—108
—128
—900
—902
—903
—9()4
—905
—906
—907
—908
—909
—910
—911
-912
—915
-916
—917
~919
—922

notLoggedInErr
noUserRefErr
networkErr
noInformErr

—923
—924
—925
—926

authFailErr
noUserRecErr
badServiceMethodErr

—927
—928
—930

badLocNameErr
guestNotAllowedErr
nbpDuplicate

—931
—932
—1027

No error
Illegal parameter
Not enough memory to load PPCBrowser package
User decided not to conduct a session
PPC Toolbox has not been initialized yet
Invalid or inappropriate locationKindSelector in
location name
Unable to open port or bad port reference number
System unable to allocate memory, critical error
Network activity is currently disabled
Port does not exist at destination
PPC Toolbox is unable to create a session
Invalid session reference number
Bad parameter or invalid state for this operation
Another port is already open with this name
User name unknown on destination machine
Destination rejected the session request
Unable to contact application
The port was closed
The session has closed
PPC port record is invalid
User has not specified owner name in Sharing Setup
control panel
Default user reference number does not yet exist
Unable to create a new user reference number
An error has occurred in the network
PPCStart failed because target application did not
have an inform pending
User’s password is wrong
Invalid user reference number
Service method is other than
ppcServiceRealTime
Location name is invalid
Destination port requires authentication
Location name represents a duplicate on this
computer

~]

~~
—

4

©)

mj

Summary of the PPC Toolbox

7-65

i)

=
a
o
nw

Inside Macintosh,

Volume

VI

Assembly-Language
Trap

Macros

Information

Requiring

Routine

Selectors

$A0DD
Selector

Routine

$0100

InitEditionPack

$0210
$0224

DeleteEditionContainerFile
GoToPublisherSection

$022A
$022C

GetEditionOpenerProc
SetEditionOpenerProc

$0206
$0208
$0226

$0232

$0236
$023A

$0316
$040C

$0412

$0422
$050E

$052E

$0530

$0604

$0618
$061E
$0620

$0814

$081A
$081C
$0A02
$0A28

$0B34
$0B38
$0B3C

7-66

UnRegisterSection
IsRegisteredSection

GetLastEditionContainerUsed

NewSubscriberDialog

NewPublisherDialog
SectionOptionsDialog
CloseEdition
AssociateSection

OpenEdition

GetEditionInfo
CreateEditionContainerFile

CallEditionOpenerProc
CallFormatIOProc

RegisterSection

EditionHasFormat
GetEditionFormatMark
SetEditionFormatMark

OpenNewEdition

ReadEdition
WriteEdition
NewSection
GetStandardFormats

NewSubscriberExpDialog
NewPublisherExpDialog
SectionOptionsExpDialog

Summary of the PPC Toolbox

ZK
—

_

=

a

=

>
C

NRK

ee
ee

RK CTOOOUODAIDAMNFSW

THE

DATA

ACCESS

C
c
wn
if 2

MANAGER

x—
=

=

i
ge
co

About This Chapter
About the Data Access Manager
The High-Level Interface
Sending a Query Through the High-Level Interface
Retrieving Data Through the High-Level Interface
The Low-Level Interface
Sending a Query Through the Low-Level Interface
Retrieving Data Through the Low-Level Interface
Comparison of the High-Level and Low-Level Interfaces
Using the Data Access Manager
Executing Routines Asynchronously
General Guidelines for the User Interface
Keep the User in Control
Provide Feedback to the User
Using the High-Level Interface
Writing a Status Routine for High-Level Functions
Using the Low-Level Interface
Getting Information About Sessions in Progress
Processing Query Results
Getting Query Results
Converting Query Results to Text
Creating a Query Document
User Interface Guidelines for Query Documents
Contents of a Query Document
Query Records and Query Resources
Query Records
Query Resources
Writing a Query Definition Function
Data Access Manager Routines
Asynchronous Execution of Routines
Initializing the Data Access Manager
High-Level Interface
Handling Query Documents
Handling Query Results
Low-Level Interface
Controlling the Session
Sending and Executing Queries
Retrieving Results
Installing and Removing Result Handlers
Summary of the Data Access Manager

—

8-1

Inside Macintosh,

8-2

Volume VI

io 2)

The Data Access Manager

p<)

—

pt)
~
-

°
C
g7)

ABOUT

THIS

i? 2)
M

CHAPTER

<

—
X)

—
eed

This chapter describes how your application can use the Data Access Manager to gain access
to data in another application. It also tells you how to provide templates to be used for data
transactions.
The Data Access Manager is available with system software version 7.0. Use the Gestalt
function described in the Compatibility Guidelines chapter of this volume to determine
whether the Data Access Manager is present.
The Data Access Manager allows your application to communicate with a database or other
data source even if you do not know anything about databases in general or the specific data
source with which the users of your software will be communicating. All your application
needs is a few high-level Data Access Manager functions and access to a file called a query
document. The query document, provided by another application, contains commands and
data in the format appropriate for the database or other data source. The string of commands
and data sent to the data source are referred to as a query. Note that a query does not
necessarily extract data from a data source; it might only send data or commands to a database
or other application.
The Data Access Manager makes it easy for your application to communicate with data
sources. You need only add a menu item that opens a query document, using a few standard
Data Access Manager functions to implement the menu selection. Users of your application
can then gain access to a database or other data source whenever they have the appropriate
query documents. A user of a word-processing program might use this feature, for example,
to obtain access to archived material, dictionaries in a variety of languages, or a database of
famous quotations. A user of a spreadsheet program might use a query document to obtain
tax records, actuarial tables, or other data. A user of an art or CAD program might download archived illustrations or designs. And for the user of a database application for the
Macintosh® computer, the Data Access Manager can provide the resources and power of a
mainframe database.
The Data Access Manager also provides a low-level interface for use by applications that are
capable of creating their own queries and that therefore do not have to use query documents.
If your application uses only the high-level interface and relies on query documents created
by other programs, then all the routines you need to know are described in this chapter.
However, if you want to create a query document or an application that uses the low-level
interface, then you must also be familiar with the command language used by the data server.
You need the information in this chapter if you want your application to be able to gain access
to data in other applications or if you want to write a query document.
Note: The Data Access Manager makes it easy for your application to communicate
with a database running on a remote computer, and this chapter generally assumes
that you are using it for that purpose. However, there is no reason why the database
could not be local—that is, running on the same computer as your application. To
implement such a system, you would have to have a database that runs on a
Macintosh computer and that has a command-language interface, plus a database
extension that can use that command language. In most cases, it would be much
simpler to run the database as a separate application and use the Clipboard to transfer
data into and out of the database.
About This Chapter

8-3

i)
iti=)
@

Inside Macintosh,

Volume VI

Note also that the program containing the data need not be a database. With the
appropriate database extension, your application could read data from a spreadsheet,
for example, or any other program that stores data.
Apple Computer, Inc. provides a database extension that uses Data Access Language (DAL).
A database extension provides an interface between the Data Access Manager and the
database or other program that contains the data. If you want to write an application that uses
the low-level interface to communicate with a Data Access Language server, or if you want to
create a query document that uses Data Access Language, you must be familiar with that
language. Data Access Language Programmer’s Reference, available from APDA®, fully
describes this language.

ABOUT

THE

DATA

ACCESS

MANAGER

The Data Access Manager constitutes a standard interface that allows Macintosh applications
to communicate with any number of databases or other data sources through a variety of data
servers. As used in this chapter, a data server is the application that acts as an interface
between the database extension on the Macintosh computer and the data source, which can
be on the Macintosh computer or on a remote host computer. A data server can be a database
server program, such as a Data Access Language server, which can provide an interface
to a variety of different databases, or it can be the data source itself, such as a Macintosh

application.

The Data Access Manager has two application interfaces: the high-level interface and the
low-level interface. If the proper database extension and query documents are available in
the user’s system, you can use the high-level interface to communicate with a data source
without having any knowledge of the command language that the data server uses. Even
if you use the low-level interface, your application can isolate the user from any specific
knowledge of the data source or the data server’s command language.
This section presents an overview and description of the Data Access Manager, including
diagrams and conceptual descriptions of the components and processes involved in using
the high-level and low-level interfaces. Next, “Using the Data Access Manager” includes
descriptions, flowcharts, and program fragments that provide a step-by-step guide to the
use of the high-level and low-level interfaces. “Creating a Query Document” describes the
contents and function of a query document. You do not have to read this section unless you
are writing an application that creates query documents, although if you are using the highlevel interface you might be interested to know just how a query document works.
Figure 8-| illustrates connections between Macintosh applications and a database on a remote
computer. The arrows in Figure 8-1 show the flow of information, not the paths of commands or control signals. See Figures 8-2 and 8-3 for the sequences involved in sending and
retrieving data.

8-4

About the Data Access Manager

io 2)
—

The Data Access Manager

\w/

ay
_

+)

>

wr)
or)
9”)
fz)
”

Macintosh computer

<

—

x)

~
et)
ga
i)
“

Databaseaware
application

A

Commands;
Query

Que
omamont

Databasenaive
application

Query
results

Commands

Query
results

Query

High-level interface

Y
Low-level interface

Data Access

Manager
Query

Query

!

results

oa
aeeee |
| Other database |!
|

Data Access omer
database extension

Remote computer

Query

Query
y | results
Data Access

Language server

Database]

|

7

extension

:

'

7
Y
areal
|
Otherdata
server

I

|

|Database

Figure 8-1. A connection with a database

The

High-Level

Interface

As Figure 8-1 shows, a database-naive application—that is, one that cannot prepare a query
for a specific data server—uses the Data Access Manager’s high-level routines to communicate
with a data server. Because the application cannot prepare a query, it must use a query document to provide one. A query document can contain code, called a query definition
function, that prompts the user for information and modifies the query before the Data
Access Manager sends it to the data server. The exact format of a query definition function
is described in “Writing a Query Definition Function” later in this chapter.
About the Data Access Manager

8-5

Inside Macintosh,

Volume VI

Note: The term query refers to any string of commands (and associated data) that
can be executed by a data server. A query can send data to a data source, retrieve data
from a data source, or reorganize the data in a data source. The Data Access Manager
does not interpret or execute the query; it only implements the interface (sometimes
called the application program interface, or API) that allows you to send the query to
the data server.
When you want to use the high-level routines to execute a query on a data server, you first
select a query document or allow the user to select one. You use high-level routines to
m get the query from the query document
execute the query definition function to modify the query
m send the query to the data server
m retrieve the results from any query that asks for information from the data source
m convert to text the results returned by a query
For example, suppose a company that makes rubber ducks has a database on a minicomputer
that contains a mailing list of all its customers. The database has a Data Access Language
interface and the company’s marketing manager has a Macintosh computer with an application
that uses high-level Data Access Manager routines to communicate with the remote database
server. As Figure 8-2 illustrates, the marketing manager must also have a query document,
created by another application, that she can use to get an address from the mailing list on the
remote minicomputer. The query document can be as complex or as simple as its creator cares
to make it; in this example, the query document is designed specifically to obtain addresses
from the rubber duck mailing list. The marketing manager might have several other query
documents available as well: one to extract a mailing list for a specific zip code, one to list all
of the customers who have made a purchase within the last year, and so on.
Notice that once the query document has sent the query to the data server, the Data Access
Manager handles the data retrieval. Although query documents and high-level Data
Access Manager routines make it very easy for you to request data from a data source,
there is no way for a query document to verify that data sent to a data source has been
successfully received. For that reason, it is recommended that you use the low-level

interface to send data to a data source or update data in a data source.

Sending

a Query

Through

the High-Level

Interface

To obtain a list of addresses from the mailing list, the marketing manager chooses the Open
Query menu command from the File menu in her application. From the list of query documents displayed, she chooses one named Rubber Duck Address List.
The application calls the Data Access Manager function DBGetNewQuery. This function
opens the Rubber Duck Address List query document and creates a partial query from the
information in the query document. The partial query specifies the type of data (character
strings) and the columns from which the data items should come (the name and address
columns). The partial query lacks some specific data (the rows that should be searched)
that is needed to complete the search criteria.

5-6

About the Data Access Manager

oO
—

The Data Access Manager

Nee
an
oY)
—_

pa)

>
°C
°C
igri

a
72)

User wants to obtain
a list of addresses

:

>o>
——
t

GF

Data

Database-

Access }

naive
application

«
[

Manager

Sends

weey
<—_}~

Checks status of
server periodically

a7)
—

|.

|B

— |

Ns

oO

Query

document

y

ff

as
—
_
as
pe)
itjo)
—

from mailing list

oad

a

K<
jomet

iti FERRER

Database server

until data is available

Mailing list
database

Translates
.| data

|e

U
Displays
data

Figure 8-2. Using high-level Data Access Manager routines
Next, the application calls the DBStartQuery function, which in turn calls the query definition
function in the query document. The query definition function displays a dialog box that asks
for the purchase dates to search. When the marketing manager types in the requested information and clicks OK, the query definition function adds the data to the partial query in
memory. The query is now ready to be executed.
Next, the DBStartQuery function sends the query to the Data Access Language database
extension, and the database extension sends the query over a communications network to
the remote Data Access Language server. Finally, the DBStartQuery function commands
the Data Access Language server to execute the query.

Retrieving

Data

Through

the

High-Level

Interface

When the application is ready to retrieve the data that it requested from the database, the
application calls the DBGetQueryResults function. This function determines when the data
is available, retrieves it from the data server, and places the data in a record in memory. The
application can then call the DBResultsToText function, which uses routines called result
handlers to convert each data item to a character string. The DBResultsToText function
passes to the application a handle to the converted data. The application then displays the list
of customers for the marketing manager.
Data items and result handlers are described in “Processing Query Results” later in
this chapter.
About the Data Access Manager

8-7

.

Inside Macintosh,

The

Volume VI

Low-Level

Interface

A database-aware application communicates through the low-level interface of the Data
Access Manager. You can use the low-level interface to
= initiate communication with the data server, sending the user name, password, and other
information to the data server
m send a query to the data server
m execute the query that you have sent to the data server
a halt execution of the query
m return status and errors from the data server
m send data to the data source
mw

retrieve data from the data source

For example, suppose once again that a company that makes rubber ducks has a mailing list
of all of its customers in a database on a minicomputer, and the database has a Data Access
Language interface. This time, suppose the Macintosh application the marketing manager is
using calls low-level Data Access Manager routines to communicate with the remote database
server. Figure 8-3 illustrates the use of the low-level interface. Notice that if you use the
high-level interface (Figure 8-2), the query document and the Data Access Manager prepare
the query, send the query, retrieve the query results, and translate the data for you. If you
use the low-level interface, however, you must perform these functions yourself.
User wants to obtain
a list of addresses

from mailing list

ue

Sends

Access

guery_i_.

Manager
aS
ey

“op

Application checks status
Database-

+

ees oe,

of server periodically

until data is available

+r

\/O
mun

Cae

Database server

im

Sends

Data

y

>

v

oO

o

Starts
session

oop]

|

Starts
session

Mailing list
database

aware:
application}

Le

Displays
data

Figure 8-3. Using low-level Data Access Manager routines
8-8

About the Data Access Manager

io <)

The Data Access Manager

—_
ww

oo

->,

+e)

>
©
©

Sending

a Query

Through

the

Low-Level

&
7)
”

Interface

=peed

To update the mailing list with a new address for customer Marvin M., the marketing manager
enters the new address into her application. The application prepares a Data Access Language
statement (a query) that specifies the type of data (a character string), the column into which
the data item should go (the address column), the row to be modified (the Marvin M. row),

plus the actual data the application wishes to send (Marvin M.’s address). The application then
passes this query to the Data Access Manager using the low-level interface. (The application
can send the query in several pieces or all at once.) The Data Access Manager sends the query
to the Data Access Language database extension in the Macintosh computer, and the database
extension sends the query to the remote Data Access Language server.

Retrieving

Data

Through

the Low-Level

Interface

Once the query begins executing, the application can periodically check with the data server to
determine whether the data is ready (Figure 8-3). When the data is available, the application
must retrieve it one data item at a time. An application that uses the low-level interface must
determine the data type of each data item, convert the data into a format that is meaningful to
the user, and store the data in memory allocated by the application. Data types are described
in “Getting Query Results” later in this chapter.
Note that neither the Data Access Manager nor the DAL database extension reads, modifies,
or acts on the query that an application sends to the data server. The data server does execute
the query, causing the data source to accept new data or prepare data for the application. To
use the low-level interface to communicate with a data server, your application must be
capable of preparing a query that can be executed by the data server.

Comparison

of the

High-Level

and

Low-Level

Interfaces

An application that uses the low-level interface to send a query to the data server must prepare
the query, initiate communication with the data server, send the query to the data server, and
execute the query. If it requested data to be returned, the application must determine when the
data is ready, and retrieve the data one item at a time. Each step in this process requires
calling one or more low-level routines.
The high-level interface between the Data Access Manager and the application, in contrast,
consists of only a few routines, each of which might call several low-level routines to
accomplish its tasks. For example, a single high-level function can call the query definition
function, initiate communication with the data server, send the query to the data server, and
execute the query.
Because the high-level interface is very easy to use and requires no specific knowledge of the
data source or database server, you can add high-level data access to your application very
easily. Then, whenever someone provides a query document for use with a specific data
server, the user can take advantage of the data access capability included in your application.
However, because there is no way for a query document to verify that data sent to a data
source has been successfully received, it is recommended that you use the low-level interface
to send data to a data source or update data in a data source.

About the Data Access Manager

8-9

2
=
2
ge
ic)
Law

|

Inside Macintosh,

Volume VI

Although in concept the low-level routines and high-level routines serve separate purposes,
there is nothing to prevent you from using calls to both in a single application. For example,
you might use low-level routines to send a query to a data server and high-level routines to
read the results and convert them to text.

USING

THE

DATA

ACCESS

MANAGER

There are at least three different ways in which you can use the Data Access Manager to
communicate with a data source.
m

You can use low-level interface routines to send queries and retrieve data from the data
source. In this case, your application must be capable of preparing a query in a language
appropriate for the data server.

m

You can use high-level interface routines to send queries and retrieve data from the data
source. In this case, you must have one or more query documents provided by another
application.

m

You can create your own query documents and use high-level interface routines to send
queries and retrieve data from the data source. In this case, your application must be
capable of preparing a query, but it can use the same query repeatedly once it has been
prepared.

This section describes how to use the high-level and low-level interfaces to the Data Access
Manager to send queries to a data server. This section also describes how to call Data
Access Manager functions asynchronously; how to determine the status of the high-level
functions at various points in their execution (and cancel execution if you so desire); how to
obtain information about Data Access Manager sessions that are in progress; and how to
retrieve query results and convert them to text.

Executing

Routines

Asynchronously

All of the Data Access Manager low-level routines and some of the high-level routines can
execute asynchronously—that is, the routine returns control to your application before the
routine has completed execution. Your application must call the WaitNextEvent function
periodically to allow an asynchronous routine to complete execution.
Note:

The database extension is responsible for implementing asynchronous

execution of Data Access Manager routines. For example, if you call the DBSend
function to send a query to a data server, and the database extension calls a device
driver, the database extension can return control to your application as soon as the
device driver has placed its routine in the driver I/O queue. If you attempt to
execute a routine asynchronously and the database extension that the user has
selected does not support asynchronous execution, the routine returns a result code
of recDBAsyncNotSupp and terminates execution.

8-10

Using the Data Access Manager

oo)

The Data Access Manager

=)

on

+e)
>

All Data Access Manager routines that can execute asynchronously take as a parameter a
pointer to a parameter block known as the asynchronous parameter block. If this pointer is
NIL, the function is executed synchronously—that is, the routine does not return control to
your application until execution is complete.

General

Guidelines

for

the

User

Interface

When you use the Data Access Manager to provide data access, you should keep two
important principles in mind: keep the user in control, and provide feedback to the user.

Keep the User in Control
When designing a data access feature or application, keep in mind that the user should have
as much access to the Macintosh computer’s abilities as possible. Design your application
so that most of the data access process happens in the background. Call the Data Access
Manager asynchronously whenever the database extension you are using supports asynchronous calls. Because data retrieval queries can take minutes or even hours to complete, they
should always run in the background.
After issuing a query, return control of the computer to users so that they may work on other
tasks or switch to other applications while the query runs. Whenever a background task
requires the user’s attention, follow the suggestions in the User Interface Guidelines chapter
of this volume regarding user notification. A background task should never take control from
the user by posting an alert box in front of the active application’s windows. Any message
that you post should identify the query that requires attention. For example, an alert box
might display the message “The query Get Employee Information was canceled because the
connection was unexpectedly broken.”
If your application allows more than one simultaneous connection to data sources, or allows
more than one query document to run, provide a modeless window that lists the open connections and queries, displays the status of each, and allows the user to cancel them if necessary.
Allow the user to limit the amount of disk space that must remain free after any transaction.
For example, a user may wish to specify that 1 MB of space always be free. Cancel any
transaction that would exceed the user’s limit and notify the user.

Provide

Feedback

to the

User

Keep the user informed about status, progress, and error conditions, and allow the user to
cancel an interaction whenever possible. Inform the user before the application becomes
modal and the computer becomes unavailable. Use the spinning beach ball cursor or the
animated wristwatch cursor to indicate a process that takes several seconds to complete.
Use a dialog box to indicate any process that lasts longer than a few seconds. For example,
connecting to a remote database could take a couple of minutes. In this case include a Cancel
button in the dialog box so that the user can cancel the operation. When possible, display a
progress indicator to show how long a process lasts. Warn the user before doing anything
potentially dangerous or irreversible, such as deleting all of a user’s data files to replace them
with data retrieved from a data source.

Using the Data Access Manager

8-11

iz)
©
oe
2)

+ 9)

<4
se

ew
=
oS)
ve
@

Inside Macintosh,

Volume VI

When a data retrieval query terminates prematurely, make the data that was retrieved available
to the user with a warning that it is incomplete. This allows the user to evaluate the partial
data before deciding whether to run the query again.

Using

the

High-Level

Interface

Use the high-level interface to the Data Access Manager if you want to use a query document
to do the work of communicating with a data source. You can use the high-level interface
to open a query document, execute the query definition function in the query document,
establish communication (initiate a session) with a data server, send the query to the data
server, execute the query, retrieve any data requested by the query, and convert the retrieved
data to text. Although two or three high-level routines accomplish most of these tasks, you
may need to call a few low-level routines as well to control a session with a data server.
Applications that implement this type of data access must provide user control and feedback
as described earlier in “General Guidelines for the User Interface.” In addition, you should
include an Open Query command in the File menu. The Open Query command is equivalent
to the Open (file) command in meaning. When the user chooses this command, display an
open file dialog box filtered to show only query documents (file type 'qery'). The user can
then choose the desired query document. The query document sends the query to the data
source. Depending on the type of query, the data source could receive information, send back
information, report the status of the data source, or perform some other task.
Figure 8-4 is a flowchart of a typical session using the high-level interface.
As Figure 8-4 illustrates, you must follow this procedure to use the high-level interface:
1. Call the InitDBPack function to initialize the Data Access Manager.
2. Select the query document that you want to use and determine the resource ID of the
‘qrsc' resource in that query document. You can use any method you like to select the
query document. One possibility is to use the StandardGetFile procedure to let the user
select the query document. A query document should contain only one ‘qrsc' resource;
you can then use the Resource Manager to determine the resource ID of the ‘qrsc'
resource in the document that the user selected. The StandardGetFile procedure is
described in the Standard File Manager chapter of this volume, and the Resource
Manager is described in Volume I.
3. Call the DBGetNewQuery function. The DBGetNewQuery function creates in memory
a data structure called a query record from the ‘qrsc' resource that you specify.
4. Call the DBStartQuery function specifying the handle to the query record that you
created with the DBGetNewQuery function (step 3).

You should also provide the DBStartQuery function with a handle to your status
routine. A status routine is a routine that you provide that can update windows,
check the results of the low-level calls made by the DBStartQuery and
DBGetQueryResults functions, and cancel execution of these functions when you
consider it appropriate to do so.

8-12

Using the Data Access Manager

oo)

The Data Access Manager

o

ou)

oe

mo

>

er]
°
is]
W
~”

| InitDBPack |

2—

v

=

=

Let Data

Access Manager

>

a
ve

No

initiate

“Sr!

communication

pBinit

for you?

io)
™

|

Y

i

rors

DBGetNewQuery

|

|

DBStartQuery

|

Requested__No,
data?
li

DBGetQueryResults |

v

Convert
data to
text?

ey

yes

|

DBResultsToText |

a

<a
<=

Yes ,_Usesame___No,y/
query record
again?

pgpisposeQuery|
v
Use new
document?

\
Yes .

Open
another No,
session?

Quit

Figure 8-4. A flowchart of a session using the high-level interface

Using the Data Access Manager

8-13

Inside Macintosh, Volume VI

The DBStartQuery function calls the query definition function referred to by the query
record (if any). The query definition function can prompt the user for information and
modify the query record.
After the query definition function has completed execution, the DBStartQuery function
calls your status routine so that you can update your windows if necessary. The
DBStartQuery function then checks to see if communication has been established with
the data server. If not, it calls your status routine so that you can put up a status dialog
box, and then calls the DBInit function to establish communication (initiate a session)

with the data server. The DBStartQuery function obtains the values it needs for the
DBlnit function parameters from the query record. When the DBInit function completes
execution, the DBStartQuery function calls your status routine again.

The DBInit function returns an identification number, called a session ID. This
session ID is unique; no other current session, for any database extension, has the
same session ID. You must specify the session ID any time you want to send data to or
retrieve data from this session. If you prefer, you can use the DBInit function to establish communication before you call the DBStartQuery function. In that case, you
must specify the session ID as an input parameter to the DBStartQuery function. See
“Using the Low-Level Interface” later in this chapter for more information on using
the DBInit function.
Once communication has been established, the DBStartQuery function calls the
DBSend function to send the query specified by the query record to the data server,
and, when the DBSend function has completed execution, calls your status routine.
Finally, the DBStartQuery function uses the DBExec function to execute the query.
The DBStartQuery function calls your status routine after the DBExec function has
completed execution (that is, the query has started executing and the DBExec function
has returned control to the DBStartQuery function) and again just before the
DBStartQuery function completes execution.
. If you requested data and want to know when the data is available, but do not want to
retrieve the data immediately, you can call the DBState function. This function tells you
when the data server has finished executing the query, but it does not retrieve the data.
If you requested data and want to retrieve it as soon as it is available, you do not have to
call the DBState function; go on to step 6 instead.
If you did not request data, you can use the DBState function to determine the status of
the query. When the data server has finished executing the query, skip to step 8.
. Call the DBGetQueryResults function. If the query has not finished executing, this function returns the rcDBExec result code. If the query has finished executing, the
DBGetQueryResults function calls the DBGetltem function repeatedly until the data
server has returned all of the data available.
The DBGetQueryResults function puts the returned data into a record that contains
handles to arrays that contain the data, the type of data in each column, and the length of
each data item. The Data Access Manager allocates the memory for this data in the
application heap.
The DBGetQueryResults function calls your status routine after it retrieves each data
item. You can use this opportunity to display the data item for the user and to give the
user the opportunity to cancel execution of the function. The DBGetQueryResults
8-14

Using the Data Access Manager

io 2)

The Data Access Manager

o

pe)

at

om)
>

i)
ie)

function also calls your status routine just before completing execution, so that you can
dispose of any memory allocated by the status routine, remove any dialog box that you
displayed, and update your windows if necessary.
To convert the returned data to text, go on to the next step. If you do not want to
convert the returned data to text, skip to step 9.

8. If you are finished using the query record, call the DBDisposeQuery function to dispose
of the query record and free all the memory associated with the query record. If you
want to reuse the same query, return to step 5. You should close the query document
when you are finished using it.
If you want to use a new query document, return to step 3.
9. When you are finished using the data source, you must use the DBEnd function to

terminate the session. You must call the DBEnd function after the DBInit function has
returned a nonzero session ID, even if it also returned an error.

Listing 8-1 illustrates the use of the high-level interface. This code sample initiates a session
with a remote database, lets the user select a query document to execute, opens the selected
file, finds a ‘qsrc' resource, and creates a query record. Next, it executes the query, checks
the status of the remote database server, retrieves the data when it’s available, and converts
this data to text. When the query has finished executing, the code disposes the query record,
ends the session, and closes the user-selected query document. In general, there’s no reason
why there can’t be multiple sessions open at once. You can identify each session by its
session ID. Listing 8-1 shows just one session.
Listing 8-1 assumes that you are using a database extension that supports asynchronous
execution of Data Access Manager routines. This listing shows just one possible approach to
sending a query and retrieving data asynchronously.

PROCEDURE

MyHiLevel

(VAR
VAR

Using the high-level interface

rr:
ResultsRecord;
MyTextHdl:
Handle;
thisSession:
LongInt;
VAR sessErr:
OSErr);

TYPE

{Define
{ A5 so

a
a

CRRec

RECORD

=

record
to include
space
for
completion
routine
can
find

QPB:
DBAsyncParamBlockRec;
appsA5:
LongInt

the current
it.}

value

in

}

{the parameter
block}
{append A5 to the parameter

block}

END;
CRRecPtr

=

“CRRec;

(Continued)

Using the Data Access Manager

2)

4

—

=
~
7
ge
&
“

7. Call the DBResultsToText function. This function calls a result handler function for
each data type. The result handler converts the data to text, places it in a buffer, and
returns a handle to the buffer. Some result handlers are provided with the Data Access
Manager; you can provide as many with your application as you wish. Result handlers
are discussed in “Converting Query Results to Text” later in this chapter.

Listing 8-1.

®

~”

8-15

Inside Macintosh, Volume VI

Listing 8-1. Using the high-level interface (Continued)
VAR
StartPB,

GetQRPB:

packErr,

startQErr,

SFR:

CRRec;

StandardFileReply;

getQErr,

disposeQErr:

OSErr;

getnewOErr,
gStartQErr,
gGetQRErr:
OSErr;
endErr,
fsopenErr,
fscloseErr,
resultsErr:OSErr;
gStart,

gqQueryResults:

Boolean;

qrscHandle:

Handle;

rsrelId:
rsrcType:

Integer;
ResType;

rsrcName:

Str255;

MyQHandle:

QueryHandle;

SavedResFile:

Integer;

TypeList:

SFTypeList;

fsRefNum:

Integer;

FUNCTION

INLINE

GetQPB:

CRRecPtr;

$2E88;

{MOVE.L

AO,

BEGIN
gStart
:= FALSE;
gQueryResults
:= FALSE;
sessErr
:= noErr;
packErr
:= InitDBPack;

{assume everything went
fine}
{initialize
the Data Access Mgr}

{Display a dialog box to
TypeList[0]
:= 'qery';

let

the

user

StandardGetFile(NIL,
1, TypeList,
IF SFR.sfGood
= FALSE THEN
BEGIN
EXIT

(SP) }

pick

a

query

document. }

SFR);

(MyHiLevel) ;

END;
fsopenErr

:=

FSpOpenRF(SFR.sfFile,

fsCurPerm,

fsRefNum);

IF fsopenErr
<> noErr THEN
BEGIN
sessErr
:= fsopenErr;
EXIT (MyHiLevel) ;
END;

SavedResFile
:= CurResFile;
UseResFile(isRefNum) ;
{A

query

document

qrscHandle

:=

should

have

{Save current
resource
file}
{get query
info
from here}
only

one

'‘qrsc'

resource. }

GetlIndResource('qrsc',1);

{There
shouldn't
be an error unless
there really
isn't
{ 'qrsc'
resource
in the file the user selected. }
IF

ResError

<>

noErr

THEN

BEGIN
sessErr

END;

8-16

:=

ResError;

EXIT (MyHiLevel);

Using the Data Access Manager

a

}

oa

The Data Access Manager

=
>

=
{Get

the

resource

ID

of

the

GetResInfo(qrscHandle,
{Create

a

'qrsc'

rsrcID,

2
=

resource}

rsrceType,

rsrcName) ;

oy

query

record using
the resource
ID.}
DBGetNewQuery(rsrcID,
MyQHandle);
<> noErr THEN

getnewOErr
:=
IF getnewQErr

=

BEGIN
sessErr

endErr

:=

getnewQErr

:=

;

DBEnd(thisSession,

NIL);

EXIT (MyHiLevel) ;
END;
StartPB.QPB.completionProc
:= @MyStartCompRoutine;
StartPB.appsA5
:= SetCurrentA5;
{save
this
for
{

{MyStartStatus
{

by

the

is

a

status

DBStartQuery

startQErr

:=

routine

function

completion

that

when

it

DBStartQuery(thisSession,

handles
calls

startQErr

<>

noErr

}

messages

sent

low-level

function. }

}

MyQHandle,

@MyStartStatus,
IF

a

the

routine}

@StartPB);

THEN

BEGIN

sessErr
:= startQErr;
IF thisSession
<> 0 THEN

endErr

:=

DBEnd(thisSession,

NIL);

EXIT (MyHiLevel) ;
END;
WHILE

NOT

{While
{

calls

gStart

waiting

DO

for

gStart

WaitNextEvent

to

to

go

give

TRUE,

other

the

routine

routines

a

GoDoSomething

chance

to

run.}

DBEnd(thisSession,

NIL);

}

BEGIN

END;

GoDoSomething;
{while}

{The
IF

DBStartQuery

gStartQErr

<>

call

has

noErr

THEN

completed. }

BEGIN
sessErr
:= gStartQErr;
IF thisSession
<> 0 THEN

endErr

:=

EXIT (MyHiLevel) ;
END;

GetQRPB.QPB.completionProc
GetQRPB.appsA5

:=

:=

SetCurrentA5;

@MyGetQRCompRoutine;
{save
{

this

completion

for

the

}

routine}

(Continued)

Using the Data Access Manager

8-17

Inside Macintosh, Volume VI

Listing 8-1. Using the high-level interface (Continued)
{MyGetQRStatus

{

by

the

{

function. }

getQErr
IF

is

a

status

DBGetQueryResults

:=

routine

that

function

when

handles

it

messages

calls

a

sent

}

low-level

}

DBGetQueryResults(thisSession,
rr,
kDBWaitForever,
@MyGetQORStatus,
@GetQRPB) ;

getQErr

<>

noErr

THEN

:=

getQErr;

BEGIN
sessErr

endErr
:= DBEnd(thisSession,
EXIT (MyHiLevel) ;

NIL);

END;
WHILE

NOT

gQueryResults

DO

BEGIN

GoDoSomething;
END;

{while}

{The

DBGetQueryResults

{

completed

{

data

IF

to

call

successfully,
text,

gGetQRErr

<>

has

completed.

Assuming

you

may

want

to

convert

return

memory

you

have

borrowed,

noErr

THEN

the

the
and

call

}

retrieved
end

the

}

session. }

BEGIN

sessErr

:=

gGetQRErr;

endErr
:= DBEnd(thisSession,
EXIT (MyHiLevel);

NIL);

END;
data

has

resultsErr

{The

:=

{The

current

{

the

next

{

query

been

query
'qrsc'

document.

disposeQErr

retrieved;

convert

DBResultsToText(rr,

:=

is

finished.

resource

This

of

DBDisposeQuery

endErr
:=
IF endErr

text.}

to

execute

}

or

just

elect

select

another

}

returns

to

the

caller.}

;
current

resource

FSClose(fsRefNum) ;
{close
the query
<> noErr THEN DoError(fscloseErr);

document}

{restore

DBEnd(thisSession,
NIL);
<> noErr THEN DoError(endErr) ;

END;

8-18

to

can

file,

(MyQHandle)

UseResFile(SavedResFile);
fscloseErr
:=
IF fscloseErr

You
the

example

it

MyTextHdl);

Using the Data Access Manager

file}

aH

The Data Access Manager

a
ow
as
—
—
as
_
x.
~~

zr)
©

®

{The

{

following

completion

two

routines

illustrate

one

way

to

implement

a

~”N
”

}

—<

routine. }

—

a)
—
—

oo

PROCEDURE

MyStartCompRoutine(aCRRecPtr:

ge

CRRecPtr);

@
-

VAR
curA5:

Longint;

BEGIN
aCRRecPtr
curA5

:=

gStart

{Do

:=

{get

the

param

block}

SetA5(aCRRecPtr%®.appsA5) ;

:=

GetQOPB;

{set

A5

to

the

app's

TRUE;

{query

has

been

{send

back

the

gStartQErr

:=

whatever

else

curA5
END;

:=

aCRRecPtr*.QPB.result;
you

want

to

A5}

started}
result

code}

do.}

SetA5(curA5);

{restore

original

A5}

{MyStartCompRoutine}

PROCEDURE

MyGetQRCompRoutine(aCRRecPtr:

CRRecPtr);

VAR

curA5:

LongiInt;

BEGIN

aCRRecPtr
curA5

:=

:=

GetQPB;

SetA5(aCRRecPtr’.appsA5) ;

gQueryResults

{Do

END;

:=

TRUE;

gGetQORErr

:=

whatever

else

curAS5

SetA5(curA5);

:=

want

the

param

block}

{set

A5

to

app's

{query

aCRRecPtr*®.QPB.result;
you

{get

to

{send

the

results
back

the

are

A5}
complete}

result

code}

do.}

{restore

original

A5}

{MyGetQRCompRoutine}

Writing a Status

Routine for High-Level

Functions

Both of the two main high-level functions, DBStartQuery and DBGetQueryResults, call lowlevel functions repeatedly. After each time they call a low-level function, these high-level
functions call a routine that you provide, called a status routine. Your status routine can check
the result code returned by the low-level function, and can cancel execution of the high-level
function before it calls the next low-level function. Your status routine can also update your
application’s windows after the DBStartQuery function has displayed a dialog box.
You provide a pointer to your status routine in the statusProc parameter to the DBStartQuery
and DBGetQueryResults functions.

Using the Data Access Manager

8-19

Inside Macintosh,

Volume VI

Here is a function declaration for a status routine.
FUNCTION

MyStatusFunc

(message:

Integer;

result:

dataPlaces,dataFlags:
dataPtr:

Ptr)

:

OSErr;

Integer;

dataLen,
dataType:

DBType;

Boolean;

Your status routine should return a value of TRUE if you want the DBStartQuery or
DBGetQueryResults function to continue execution, or FALSE to cancel execution of the
function. In the latter case, the high-level function returns the userCanceledErr result code.
Note: If you call the DBStartQuery or DBGetQueryResults function asynchronously, you cannot depend on the A5 register containing a pointer to your application’s global variables when the Data Access Manager calls your status routine.
The message parameter tells your status routine the current status of the high-level function
that called it. The possible values for the message parameter depend on which function called
your routine.
The value of the result parameter depends on the value of the message parameter, as
summarized in the following list.
Message

Result

kDBUpdateWind

0

kDBAboutTolnit

0

kDBInitComplete

Result of DBInit

kDBSendComplete

Result of DBSend

kDBExecComplete

Result of DBExec

kDBStartQueryComplete

Result of DBStartQuery

kDBGetlItemComplete

Result of DBGetItem

kDBGetQueryResultsComplete

Result of DBGetQueryResults

The dataLen, dataPlaces, dataFlags, dataType, and dataPtr parameters are returned only
by the DBGetQueryResults function, and only when the message parameter equals
kDBGetItemComplete. When the DBGetQueryResults function calls your status routine
with this message, the dataLen, dataPlaces, and dataType parameters contain the length,
decimal places, and type of the data item retrieved, and the dataPtr parameter contains a
pointer to the data item.
The least significant bit of the dataFlags parameter is set to | if the data item is in the last
column of the row. The third bit of the dataFlags parameter is | if the data item is NULL.

8-20

Using the Data Access Manager

oe
=

The Data Access Manager

=

ro)
_
as
Pe
~~
»

ir)

You can use this information, for example, to check the data to see if it meets some criteria

of interest to the user, or to display each data item as the DBGetItem function receives it.

_
—_
As
oo

The DBGetQueryResults function returns a results record, which contains a handle to
the retrieved data. The address in the dataPtr parameter points inside the array specified by
this handle. Because the dataPtr parameter is not a pointer to a block of memory allocated
by the Memory Manager, but just a pointer to a location inside such a block, you cannot use
this pointer in any Memory Manager routines (such as the GetPtrSize function). Note also
that you cannot rely on this pointer remaining valid after you return control to the
DBGetQueryResults function.
The following constants can be sent to your status routine in the message parameter by the
DBStartQuery function:
{DBStartQuery

status

messages}

kDBUpdatewind

=

0;

{update

windows}

kDBAboutToInit

=

1;

{about

to

kDBInitComplete

=

2;

{DBInit

has

completed}

call

DBInit}

kDBSendComplete

=

3;

{DBSend

has

completed}

kDBExecComplete

=

4;

{DBExec

has

completed}

kDBStartQueryComplete

=

5;

{DBStartQuery

DBStartQuery
message constant

is

about

to

complete}

Meaning

kDBUpdateWind

The DBStartQuery function has just called a query definition
function. Your status routine should process any update events
that your application has received for its windows.

kDBAboutTolnit

The DBStartQuery function is about to call the DBInit function
to initiate a session with a data server. Because initiating the
session might involve establishing communication over a
network, and because in some circumstances the execution of
a query can tie up the user’s computer for some length of time,
you might want to display a dialog box giving the user the
option of canceling execution at this time.

kDBInitComplete

The DBInit function has completed execution. When the
DBStartQuery function calls your status routine with this
message, the result parameter contains the result code
returned by the DBInit function. If the DBInit function returns
the noErr result code, the DBStartQuery function calls the
DBSend function next. If the DBInit function returns any
other result code, you can display a dialog box informing
the user of the problem before returning control to the
DBStartQuery function. The DBStartQuery function then
returns an error code and stops execution.

Using the Data Access Manager

K<
—
pe

You can use the constants kDBLastColFlag and KDBNullFlag to test for these flag bits.

CONST

©
i$")
fz)
”

8-21

ge
i)
“

Inside Macintosh, Volume VI

DBStartQuery
message

constant

Meaning

kDBSendComplete

The DBSend function has completed execution. When the
DBStartQuery function calls your status routine with this
message, the result parameter contains the result code returned
by the DBSend function. If the DBSend function returns the
noErr result code, the DBStartQuery function calls the DBExec
function next. If the DBSend function returns any other result
code, you can display a dialog box informing the user of the
problem before returning control to the DBStartQuery function.
The DBStartQuery function then returns an error code and stops
execution.

kKDBExecComplete

The DBExec function has completed execution. When the
DBStartQuery function calls your status routine with this
message, the result parameter contains the result code returned
by the DBExec function. If the DBExec function returns the
noErr result code, the DBStartQuery function returns control to
your application next. If the DBExec function returns any other
result code, you can display a dialog box informing the user of
the problem before returning control to the DBStartQuery
function. The DBStartQuery function then returns an error code
and stops execution.

kDBStartQueryComplete

The DBStartQuery function has completed execution and is
about to return control to your application. The function result is
in the result parameter passed to your status routine. Your status
routine can use this opportunity to peform any final tasks, such
as disposing of memory that it allocated or removing from the
screen any dialog box that it displayed.

The following constants can be sent to your status routine in the message parameter by the
DBGetQueryResults function:
CONST

{DBGetQueryResults

status

kDBGetItemComplete
kDBGetQueryResultsComplete

messages}
=
=

63
7;

{DBGetItem
has completed}
{DBGetQOueryResults
has
}

{

DBGetQueryResults
message

constant

kDBGetItemComplete

8-22

completed}

Meaning
The DBGetltem function has completed execution. When the
DBGetQueryResults function calls your status routine with this
message, the result parameter contains the result code returned
by the DBGetlItem function. The DBGetQueryResults function
also returns values for the dataLen, dataPlaces, dataType,
dataFlags, and dataPtr parameters, as discussed earlier in
this section.

Using the Data Access Manager

oo)

The Data Access Manager

—_
ww

~
=
+=)
>

2)
©
&
7)

DBGetQueryResults
message constant

”

Meaning

2

For each data item that it retrieves, the DBGetQueryResults
function calls the DBGetItem function twice: once to obtain
information about the next data item and once to retrieve the data
item. The DBGetQueryResults function calls your status routine
only after calling the DBGetItem function to retrieve a data item.

ge

onal

SS)

rs

If your status routine returns a function result of FALSE in
response to the kDBGetItemComplete message, the results
record returned by the DBGetQueryResults function to your
application contains data through the last full row retrieved.
Data types and results records are described in “Getting Query
Results” later in this chapter.
kDBGetQueryResultsComplete
The DBGetQueryResults function has completed execution and
is about to return control to your application. The function result
is in the result parameter passed to your status routine. Your
status routine can use this opportunity to peform any final tasks,
such as disposing of memory that it allocated or removing from
the screen any dialog box that it displayed.
Listing 8-2 shows a status routine for the DBStartQuery function. This routine updates the
application’s windows in response to the kDBUpdateWind message, displays a dialog box
giving the user the option of canceling before the data access is initiated, and checks the
results of calls to the DBInit, DBSend. and DBExec functions. If one of these functions

returns an error, the status routine displays a dialog box describing the error.
Listing 8-2. A sample status routine
FUNCTION

MyStartStatus(message:

Integer;

result:

OSErr;

dataLen,dataPlaces,dataFlags:
Integer;
dataType:
DBType;
dataPtr:
Ptr)
: Boolean;
VAR

myString:

Str255;

continue:

Boolean;

BEGIN

continue

:=

TRUE;

{assume

user

wants

to

continue

with

the

query}

CASE message
OF
kDBUpdateWinda:
BEGIN

{A
{

qdef

function

activate

and

has
update

MyDoActivate;
MyDoUpdate;
END;

just

been

events

{find
{find

and
and

called.

and

handle

handle
handle

Find

your

}

accordingly.}

activate
events}
update
events}

{kDBUpdateWind}

(Continued)

Using the Data Access Manager

8-23

te

£

Inside Macintosh, Volume VI

Listing 8-2. A sample status routine (Continued)
kDBAboutToInit:
BEGIN

{about

to

initiate

a

{MyDisplayDialog is
{ It takes as input
{

and

returns

a

session}

a
a

routine that displays a dialog
string you want to display }

Boolean

telling

{ whether

to

continue. }

myString

:=

'The

Data

Access

session.

This

want

to

DBStartQuery

Manager
could

is

take

}

}

about
a

box.

to

open

while.

Do

a

you

continue?';

MyDisplayDialog(@myString,

continue);

END;
{kDBAboutToInit}
kDBInitComplete:
BEGIN
{The

{

DBInit

function

error,

let

the

user

IF result
BEGIN

<>

noErr

has

completed

know

what

execution.

it

If

there's

an

}

is.}

THEN

CASE result
OF
rcDBError:
BEGIN

myString

:=

'The Data
open the

Access Manager was unable to
session.
Please check your

connections

and

try

again

{DisplayString displays a dialog box
{ the string you want to display.}
DisplayString (@myString) ;

later.';

containing

}

END;
rcDBBadDDev:
BEGIN

myString

:=

'The

Data

the

database

in

order

with

DisplayString

your

Access
to

Manager

extension
open

a

system

cannot

find

file

needs

it

session.

Please

administrator

to

a copy of this
(@myString) ;

file.';

'The

Data

Access

Manager

was

unable

open

the

session.

The

error

code

a

box

containing

check

obtain

END;
ELSE
BEGIN

myString

:=

to
returned

was'

{DisplayError

displays

dialog

to display
{ the string you want
DisplayError(@myString,
result);
END;

END;

{CASE

result}

END;

END;

8-24

{kDBInitComplete}

Using the Data Access Manager

plus

an

error

}
code. }

oa
—

The Data Access Manager

Ld

~

—

a

x)

©
@

if 2)

M

kDBSendComplete:

<

BEGIN

rx)

{The DBSend
function has completed
{ error,
let the user know what
it
IF

result

<>

noErr

execution.
is.}

If

there's

an

~
SS)

}

ge

a")
—

THEN

BEGIN

IF

result

=

rcDBError

THEN

BEGIN
myString

:=

'An

error

Data

occurred

Access

while

Manager

was

the
trying

to

send the query.
Please
try again
later.';
DisplayString

(@myString)

;

END;

ELSE
BEGIN

myString

:=

'An

error

occurred

Data

Access

send

the

while

Manager

query.

The

was

the
trying

error

to

code

returned

was '

DisplayError(@myString,

result);

END;

END;
END;

{kDBSendComplete}

kDBExecComplete:
BEGIN

{The
{

DBExec

error,

IF

result

BEGIN
IF

function

let

the

<>

noErr

result

=

user

has

what

execution.

it

If

there's

an

}

is.}

THEN

rcDBError

BEGIN
myString

completed

know

:=

THEN

'The Data Access
Manager was
unable
to execute
the query.
There may be a problem with the

query

document

Check

with

DisplayString

or

your

with

system

(@myString)

the

database.

administrator.';

;

END;

ELSE
BEGIN
myString

:=

'An error occurred while
Data Access
Manager was
execute
the query.
The
returned

DisplayError(@myString,

the
trying
to
error code

was'
result);

END;

END;
END;

{kDBExecComplete}

(Continued)

Using the Data Access Manager

8-25

Inside Macintosh, Volume VI

Listing 8-2. A sample status routine (Continued)
kDBStartQueryComplete:
BEGIN
{The
{ to

DBStartQuery
function
is about
to return control
your application.
You can clean
up memory
}

{

and

any

dialog

boxes

{

MyCleanUpWindows

is

you
a

left

routine

on
that

the

screen.

does

}

}

that.}

MyCleanUpWindows;
END;
{kDBStartQueryComplete}
END;

{CASE

message}

MyStartStatus

:=

continue;

END;

Using

the Low-Level

Interface

You can use the low-level interface to establish communication (initiate a session) with a data

server, send a query to the data server, execute the query, and retrieve any data requested by
the query. You call one or more low-level routines to accomplish each of these tasks.

Applications that implement this type of data access must provide user control and feedback,
as described in “General Guidelines for the User Interface” earlier in this chapter. When the
data source is ready to return data, you can retrieve it all and then display it to the user, or you
can display the data as it arrives. If the data arrives slowly, it’s best to display it one record at
a time as it arrives. This way the user can preview the data, decide if it’s the desired
information, and cancel the query if not.
Figure 8-5 is a flowchart of a typical session using the low-level interface.
As Figure 8-5 illustrates, you must follow this procedure to use the low-level interface:
1. Call the InitDBPack function to initialize the Data Access Manager.
2. Call the DBInit function to establish communication with the data server. The DBInit
function returns an identification number, called a session ID. This session ID is
unique; no other current session, for any database extension, has the same session ID.

You must specify the session ID any time you want to send data to or retrieve data from

this session.

The DBInit function requires as input parameters the name of the database extension
and character strings for the host system, user name, password, and connection string.
All of these parameters depend on the user and the user’s computer system, including
the specific database extension, host computer, data server, and database management
software in use. You will not know the user name and password when you are writing
an application, and you might not know the values of any of these parameters. Therefore, you must display a dialog box that prompts the user for the necessary information.

8-26

Using the Data Access Manager

oo
—

The Data Access Manager

ad

p>
swa
~

CG
e)
©

| InitDBPack

M
<2)

|

ee
$9
—_
ft
ge
fe)

ee

—

|

—

7 >.

“%

> ~<
Command string
Data

data

item

or
item?

| DBSenditem |

string

|

|

No

Command

DBSend

al

|

Query

complete?
| Yes

|

DBExec
|

—

DBState

No

— Query finished

|
i

executing?
i

A

Renuesien

Send

:

No

|

another -No__,,
query?

| Yes

—+r!DBGetitem

>

Yes

4

|

DBEnd
\

|

Open

a>

session?

Soe quit

A

te

No

Last data
item?

Yes

Figure 8-5. A flowchart of a session using the low-level interface

Using the Data Access Manager

8-27

Inside Macintosh,

Volume VI

Depending on the database extension you are using, the DBInit function might return a
session ID of zero if it fails to initiate a session, or it might return a nonzero session ID
and a result code other than noErr. In the latter case, you can pass the session ID to the
DBGetErr function to determine the cause of the error. If the DBInit function returns a
nonzero session ID and a result code other than noErr, you must call the DBEnd
function before making another attempt to open the session.
. Prepare a query, and send it to the data server by calling the DBSend and DBSendItem
functions one or more times.

An application that uses the low-level interface must be capable of creating a query for
the data server in the language and format required by that data server.
The DBSend function sends a query or a portion of a query to the data server. The data
server appends this portion of the query to any portion you sent previously. Because
the Data Access Manager and data server do not modify the string you send in any way,
they do not insert any delimiter between fragments of queries that you send to the data
server. If you want a blank or a semicolon to be included between query fragments, or
if you want to use return characters to divide the query into lines of text, you must
include them in the character string that you send with the DBSend function. The data
string that you send with the DBSend function can be any length up to 64 KB.
The DBSendItem function sends a single data item to the data server. Use the
DBSendItem function to send data items to the data source in the same format as they
are retrieved from the data source by the DBGetItem function. You must specify the
data type as an input parameter and, for any data type that does not have an implied
length, you must specify the length as well. The database extension or the data server
(depending on how the system is implemented) converts the data item to a character
string and appends it to the query, just as a query program fragment is appended to the
query by the DBSend function.
You can call the DBSend and DBSendlItem functions as many times as you wish to
send your query to the data server.
Listing 8-3 sends the Data Access Language query fragment “print 451+222;” to the
Data Access Language server.
. Use the DBExec function to initiate execution of the query.
Depending on the way the system you are using is implemented, the DBExec function
might return control to your application as soon as the query has begun execution.
. Use the DBState function to determine the status of the data source.

The DBState function tells you when the data server has finished executing the query
you just sent. If you have requested data, the data server stores the data you requested
but does not send it to your application until you request it explicitly. The DBState
function tells you when the data is available; if data is available, go on to step 6. If you
wish to send another query, return to step 3. If you are finished using the data source,
skip to step 7.

8-28

Using the Data Access Manager

2)

The Data Access Manager

—_
‘ww

~

_

=

+
i

er)

er)
o&
NM
2)
Zs

Listing 8-3. Sending a query fragment

—

&
=
ie)

VAR

valuel:

LongInt;

value2:

LongInt;

textl:

Beri5;

text2:

Stris;

text3:

Stri5;

Gi:

OSErr;

tf
a
“

BEGIN

textl
valuel

s=
:=

"print
451;

';

CExED

se

value2

:=

fey
222;

Fext3:.

2s,

Ue"

rc

:=

DBSend

(sessID,
P2CStr(StringPtr(ORD(@textl1))),
LENGTH (text1),
NIL);

IF

re

=

THEN

rc

:=

noErr

DBSendItem

(sessID,

typeInteger,

Ptr(ORD(@valuel)),
IF

re

=

rc

:=

noErr

IF

re

=

rc

:=

re

=

re

:=

noErr

(sessID,

P2CStr(StringPtr(ORD(@text2))),
(text2),

NIL);

(sessID,
typeInteger,
0,
O,
Ptr (ORD(@value2)),
NIL);

O,

THEN

DBSend

(sessID,

P2CStr(StringPtr(ORD(@text3))),

LENGTH (text3),
MySendFragment

0,

THEN

DBSendItem

noErr

0,

THEN

DBSend

LENGTH
IF

0,
NIL);

:=

NIL);

rc;

END;

6. Call the DBGetItem function repeatedly to retrieve the data.
The DBGetltem function retrieves the next data item from the data server. You can also
use this function to obtain information about the next data item without retrieving the
data. When you use the DBGetItem function to retrieve a data item, you must specify
the location and size of the buffer into which the function is to place that item. If you
know beforehand what kind of data to expect, you can allocate a buffer of the exact
size you need. If you do not know what type of data to expect, you can first call the
DBGetltem function with a NIL pointer to the data buffer. The DBGetItem function
then returns information about the next data item without actually retrieving it. You can
then allocate the appropriate buffer and call DBGetItem again.

Using the Data Access Manager

8-29

Inside Macintosh,

Volume VI

Alternatively, to avoid calling DBGetItem twice for each data item, you can allocate a
buffer that you expect to be of sufficient size for any data item and call the DBGetItem
function. If the buffer is not large enough for the data item, the DBGetItem function
returns the rcDBError result code, but still returns information about the data item. You
can then allocate the necessary buffer, call the DBUnGetlItem function to go back one
data item, and call the DBGetItem function again to retrieve the data item a second time.
The DBGetlItem function includes a timeout parameter that you can use to specify the
maximum amount of time that the database extension should wait to receive results from
the data server before canceling the command. If the database extension you are using
does not support asynchronous execution of routines, you can use the timeout
parameter to return control to your application while a query is executing. To use the
timeout parameter in this way, call the DBGetItem function periodically with a short
value set for the timeout parameter. Your application can then retrieve the next data
item as soon as execution of the query is complete without having to call the DBState
function to determine when data is available. The DBGetItem function ignores the

timeout parameter if you make an asynchronous call to this function.

7. When you are finished using the data source, you must use the DBEnd function to

terminate the session. You must call the DBEnd function after the DBInit function has
returned a nonzero session ID, even if it also returned an error.

Listing 8-4 uses the low-level interface to send a Data Access Language routine to the Data
Access Language server on a remote computer, and retrieves the results. The code initiates a
session with a remote database and calls the MySendFragment routine (Listing 8-3) to send a
query. Next, it executes the query, checks the status of the remote database server, and
retrieves the data when it’s available. This example retrieves only one data item. To retrieve
more than one data item, put the data-retrieval code in a loop.
Listing 8-4 assumes that the database extension does not support asynchronous execution of
Data Access Manager routines. For an example of asynchronous execution of routines, see
Listing 8-1.
Listing 8-4. Using the low-level interface
PROCEDURE

MyLoLevel

(VAR

thisSession:

LongInt;

VAR

theDDevName:
theHost,
thePasswd,

8-30

Stxr63

theUser:

Str255;

theConnStr:
sendErr,
endErr:

Str2557

packErr,
stateErr,

initErr,
getErr,

execErr:

myTimeout
myType:

:

Longint;
DBType;

len,
places,
flags:
myBuffer:
myDataInfo:
myDataReturned:

Integer;
Ptr;
Boolean;
Boolean;

Using the Data Access Manager

OSErr;
OSErr;

VAR

sessErr:

OSErr);

The Data Access Manager

BEGIN

sessErr

:=

noErr;

{assume

packErr

:=

InitDBPack;

{init

{Set

{
{

and

up

values

for

theConnStr.

the

user

to

theDDevName
theHost
theUser

:=

theConnStr

initErr

display

some

of

dialog

fine}

Mgr}

theUser,

box

parameters.}

thePasswd,

prompting

}

}

Host
System
User';

Name';

'secret';

:=

‘extra

stuff

as

needed';

:= DBInit(thisSession,

initErr

a

went

Access

theHost,

these

thePasswd,

IF

Data

'DAL';

'The
'Joe

thePasswd

can

supply

:=

:=
:=

theDDevName,

You

everything

the

<>

noErr

theDDevName,
theConnStr,

theHost,

theUser,

NIL);

THEN

BEGIN

sessErr
:= initErr;
IF thisSession <> 0

THEN

endErr

:=

DBEnd(thisSession,

NIL);

EXIT (MyLoLevel) ;
END;

{Send a query or
{ MySendFragment

sendErr
{If
{

:=

IF

MySendFragment

there's

DBSend

query
fragment
to the
is such a routine.}

an

or

sendErr

error,

(thisSession)

then

DBSendItem.

probably
forget

DBEnd(thisSession,

NIL);

noErr

data

server.

}

;
something

Don't

<>

remote

to

end

went
the

wrong

with

}

session. }

THEN

BEGIN

sessErr

:=

endErr
EXIT

:=

sendErr;

(MyLoLevel) ;

END;

{The

{

the

query

query

execErr
IF

:=

execErr

has

will

been

sent.

return

This

data. }

DBExec(thisSession,
=

noErr

example

assumes

that

}

NIL);

THEN

BEGIN

{While

waiting

{

let

other

apps

{

GoDoSomething

for

stateErr

run

does

by

<>

calling

rcDBExec

you

can

WaitNextEvent.

}

}

that. }

stateErr
:= rcDBExec;
WHILE
(stateErr
= rcDBExec)
DO
BEGIN
GoDoSomething;
stateErr
:= DBState(thisSession,

NIL);

END;

(Continued)

Using the Data Access Manager

8-31

Inside Macintosh, Volume VI

Listing 8-4. Using the low-level interface (Continued)
{DBState
returned a result
{ If it's
rceDBValue,
there

code other
than rcDBExec.
are results
to retrieve.

{ Otherwise,

an

IF

it's

stateErr

=

probably

rcDBValue

}
}

error.}

THEN

BEGIN

{Call

DBGetItem

once

to

{

the

data

and

call

{

to

item

actually

myTimeout

:=

get

the

get

info

on

DBGetItem

data

}
a

second

time

ticks

=

secs}

}

item. }

2*60;

{2*60

2

myType
:= typeAnyType;
myDataInfo
:= FALSE;
WHILE NOT myDataInfo
DO
BEGIN

getErr

:=

DBGetItem(thisSession,
len,

{If

you

timed

{

control

IF

getErr

ELSE

IF

out,

then

returns,

=

getErr
ELSE

=

=

give

continue

rcDBBreak

getErr

places,

rcDBValue

flags,

myType,

NIL,

control.

getting

THEN

noErr

up

myTimeout,

the

NIL);

When

}

info. }

GoDoSomething

OR
THEN

myDataInfo

:=

TRUE

BEGIN

sessErr

endErr

:=

:=

getErr;

DBEnd(thisSession,

NIL);

EXIT (MyLoLevel);
END;
END;

{while}

{At this point, you may want to examine the info
{ about the data item before calling DBGetItem a
{ second time to actually retrieve it.}
{GimmeMySpace returns a pointer
{ the data item to go.}
myBuffer
:= GimmeMySpace(len) ;
myDataReturned
:= FALSE;
WHILE NOT myDataReturned

to

where

you

}
}

want

}

DO

BEGIN

getErr

:=

{If

timed

you

DBGetItem(thisSession,
len,
places,

out,

then

give

up

myTimeout,
myType,
flags,
myBuffer,
NIL);

control.

When

}

{ control
returns,
continue
getting
the data.}
IF getErr
= rcDBBreak THEN GoDoSomething
ELSE IF getErr
= noErr OR
getErr
ELSE

8-32

=

rcDBValue

Using the Data Access Manager

THEN

myDataReturned

:=

TRUE

aH

The Data Access Manager

0

pat)
a

bt]

>

ir)

©

&
2]
”

BEGIN

sessErr
endErr
EXIT

:=
:=

2
—

getErr;
DBEnd(thisSession,

&
~
&
i)

NIL);

(MyLoLevel) ;

oe

er

END;

END;

{while}

END
ELSE
END
ELSE
endErr

sessErr

sessSErr
:=

:=

:=

stateErr;

execErr;

DBEnd(thisSession,

NIL);

END;

Note that, even if you are using the low-level interface to send queries to the data server, you
might want to use the high-level functions to retrieve data and convert it to text.

Getting

Information

About

Sessions

in Progress

If your application is only one of several on a single Macintosh computer connected to data
servers, you can use the DBGetConnInfo and DBGetSessionNum functions to obtain
information about the sessions in progress. If you know the session ID (which is returned by
the DBInit function when you open a session), you can use the DBGetConnInfo function to
determine the database extension being used, the name of the host system on which the
session is running, the user name and connection string that were used to initiate the session,
the time at which the session started, and the status of the session. The status of the session
specifies whether the data server is executing a query or waiting for another query fragment,
whether there is output data available, and whether execution of a query ended in an error.
If you do not know the session ID, or if you want to get information about all open sessions,
you can specify a database extension and a session number when you call the DBGetConnInfo
function. Although there can be only one active session with a given session ID, session
numbers are unique only for a specific database extension. Because the database extension
assigns session numbers sequentially, starting with 1, you can call the DBGetConnInfo
function repeatedly for a given database extension, incrementing the session number each time,
to obtain information about all sessions open for that database extension. Your application
need not have initiated the session to obtain information about it in this fashion.
The DBGetSessionNum function returns the session number when you specify the session
ID. You can use this function to determine the session numbers for the sessions opened by
your own application. You might want this information, for example, so you can distinguish
your own sessions from those opened by other applications when you use the
DBGetConnInfo function to get information about all open sessions.

Using the Data Access Manager

8-33

Inside Macintosh,

Volume VI

Processing

Query

Results

You can use the low-level function DBGetltem to retrieve a single data item returned by a
query, or you can use the high-level function DBGetQueryResults to retrieve all of the
query results at once. If you use the DBGetQueryResults function, you can then use the
DBResultsToText function to convert the results to ASCII text. The DBResultsToText
function calls routines called result handlers, which are installed in memory by applications or
by system extensions (files containing 'INIT' resources). This section discusses the use
of the DBGetItem and DBGetQueryResults functions and describes how to write and install
a result handler.

Getting

Query

Results

The DBGetltem function retrieves a single data item that was returned by a data source in
response to a query. When you call the DBGetItem function, you specify the data type to be
retrieved. If you do not know what data type to expect, you can specify the typeAnyType
constant for the dataType parameter, and the data server returns the next data item regardless
of data type. It also returns information about the data item, including data type and length.
If you do not know the length of the next data item, you can specify NIL for the buffer
parameter in the DBGetItem function, and the data server returns the data type, length,
and number of decimal places without retrieving the data item. The next time you call the

DBGetltem function with a nonzero value for the buffer parameter, the function retrieves

the data item.

If you want to skip a data item, specify the typeDiscard constant for the dataType parameter.
Then the next time you call the DBGetItem function, it retrieves the following data item.
You should use the DBGetItem function if you want complete control over the retrieval of
each item of data. If you want the Data Access Manager to retrieve the data for you, use the
DBGetQueryResults function instead.
Table 8-1 shows the data types recognized by the Data Access Manager. You use a constant
to specify each data type, as follows:
CONST

{data

types}

typeAnyType

=

OF

{can

be

typeNone

=

‘none’;

{no

more

typeBoolean

=

* Boal*s

{Boolean}

typeSMInt

=

‘shor';

{short

integer}

typeSMFloat

=

‘sing’;

{short

floating

typeFloat
typeDate
typeTime

=
=
=

*@oub';
'date';
'time';

{floating
{date}
{time}

point}

typeTimeStamp

=

"tims';

{date

time}

typeChar
typeDecimal
typeMoney

=
s
=

“PET >
"Geel";
'mone';

{character}
{decimal
number}
{money value}

typevChar

=

'vcha';

{variable

character}

typeVBin

=

‘yvbin!';

{variable

binary}

typeInteger

8-34

=

"long";

Using the Data Access Manager

any

data

data

type}

expected}

{integer}

and

point}

oo)
—

The Data Access Manager

ww

as
_
a

=

od

er)

typeLChar
typeLBin

=
=

“iene:
VT Hin

{long
{long

typeDiscard

=

"“@ise*s

{discard

next

typeUnknown

=

"“ynkn';

{result

handler

{

type}

©
13"
/
M

character}
binary}

data

2—
©

data

—

item}

ed

9

for

unknown

Go

}

@
“

typeColBreak

=

*eolb" ;

{result

handler

for

column

break}

typeRowBreak

=

‘“rowb:';

{result

handler

for

end

line}

of

The writer of a database extension can define other data types to support specific data sources
or data servers.
Each data type has a standard definition, shown in Table 8-1. For example, if the DBGetItem
function returns the typeInteger constant for the dataType parameter, you know that the data
item represents an integer value and that a 4-byte buffer is necessary to hold it. Similarly, if
you are using the DBSendItem function to send to the data server a data item that you identify
as typeFloat, the data server expects to receive an 8-byte floating-point value.
Notice that some of these data types are defined to have a specific length (referred to as an
implied length), and some do not. The len parameter of the DBSendItem and DBGetlItem
functions indicates the length of an individual data item. The DBGetQueryResults function
returns a handle to an array of lengths, decimal places, and flags in the colInfo field of the
results record. The typeAnyType, typeColBreak, and typeRowBreak constants do not refer to
specific data types, and therefore the length specification is not applicable for these constants.
Table 8-1. Data types defined by the Data Access Manager
Constant

Length

Definition

typeAnyType

NA

Any data type (used as an input parameter to the DBGetItem
function only; never returned by the function).

typeNone

0

Empty.

typeBoolean

1 byte

TRUE (1) or FALSE (0).

typeSMInt

2bytes

Signed integer value.

typeInteger

4bytes

Signed long integer value.

typeSMFloat

4bytes

Signed floating-point value.

typeFloat

8 bytes

Signed floating-point value.

typeDate

4bytes

Date; a long integer value consisting of a year (most

typeTime

4bytes

Time; a long integer value consisting of an hour (0-23; most

significant 16 bits), month (8 bits), and day (least significant
8 bits).
significant 8 bits), minute (8 bits), second (8 bits), and

hundredths of a second (least significant 8 bits).

(Continued)

Using the Data Access Manager

8-35

Inside Macintosh,

Volume VI

Table 8-1. Data types defined by the Data Access Manager (Continued)
Constant

Length

Definition

typeTimeStamp

8 bytes

Date and time. A long integer date value followed by a long
integer time value.

typeChar

Any

Fixed-length character string, not NULL terminated. The
length of the string is defined by the specific data source.

typeDecimal

Any

Packed decimal string. A contiguous string of 4-bit nibbles,
each of which contains a decimal number, except for the low
nibble of the highest-addressed byte (that is, the last nibble in
the string), which contains a sign. The value of the sign
nibble can be 10, 12, 14, or 15 for a positive number or 11 or
13 for a negative number; 12 is recommended for a positive
number and 13 for a negative number. The most significant
digit is the high-order nibble of the lowest-addressed byte
(that is, the first nibble to appear in the string).
The total number of nibbles (including the sign nibble) must
be even; therefore, the high nibble of the highest-addressed
byte of a number with an even number of digits must be 0.
For example, the number +123 is represented as $123C

Bits 7

43
1

2

3

C

0 Address
A

A+1

and the number —1234 is represented as $01234D.
Bits 7

43
0

1

0 Address
A

2

3

A+1

4

D

A+2

The length of a packed decimal string is defined as the number
of bytes, including any extra leading 0 and the sign nibble. A
packed decimal string can have from 0 to 31 digits, not
including the sign nibble.
In addition to the length of a packed decimal string, each
data item has an associated value that indicates the number
of digits that follow the decimal place. The places parameter
in the DBGetItem and DBSendItem functions indicates the
number of decimal places in an individual data item. The
DBGetQueryResults function returns the number of decimal
places.
typeMoney

Any

Same as typeDecimal, but always has two decimal places.

type VChar

Any

Variable-length character string, NULL terminated.

8-36

Using the Data Access Manager

oe)
—

The Data Access Manager

ww

pe)

—s

ae

>

©

i)

@

Table 8-1. Data types defined by the Data Access Manager (Continued)

7)

i? 2)

i
—

a

Constant

Length

Definition

typeVBin

Any

Not defined. Reserved for future use.

typeLChar

Any

Not defined. Reserved for future use.

typeLBin

Any

Not defined. Reserved for future use.

typeDiscard

NA

Do not retrieve the next data item (used as an input parameter
to the DBGetItem function only; never returned by the

=

i
iio)
@
er

function).

typeUnknown

NA

A dummy data type for the result handler that processes any
data type for which no other result handler is available (used
as an input parameter to the DBInstallResultHandler,
DBRemoveResultHandler, and DBGetResultHandler
functions only; never returned by the DBGetlItem function).

typeColBreak

NA

A dummy data type for the result handler that the
DBGetQueryResults function calls after each item that is
not the last item in a row (used as an input parameter to the
DBInstallResultHandler, DBRemoveResultHandler, and

DBGetResultHandler functions only; never returned by the
DBGetltem function).

typeRowBreak

NA

A dummy data type for the result handler that the
DBGetQueryResults function calls at the end of each row

(used as an input parameter to the DBInstallResultHandler,

DBRemoveResultHandler, and DBGetResultHandler
functions only; never returned by the DBGetItem function).
The DBGetQueryResults function retrieves all of the data that was returned by a data source
in response to a query, unless insufficient memory is available to hold the data, in which
case it retrieves as many complete rows of data as possible. The DBGetQueryResults
function stores the data in a structure called a results record. You must allocate the results
record data structure and pass this record to the DBGetQueryResults function. The Data
Access Manager allocates the handles inside the results record. When your application is
finished using the results record, you must deallocate both the results record and the handles
inside the results record.

The results record is defined by the ResultsRecord data type.
TYPE

ResultsRecord
RECORD
numRows:

numCols:
colTypes:
colData:
coliInfo:

Integer;
Integer;

{number
{number

of
of

rows
retrieved}
columns
per row}

ColTypesHandle;
Handle;
ColiInfoHandle

{tyoe of data
in each
{array
of data
items}
{info about
each data

column}
item}

END;

Using the Data Access Manager

8-37

|

Inside Macintosh,

Volume VI

The numRows field in the results record indicates the total number of rows retrieved. If the
DBGetQueryResults function returns a result code other than rcDB Value, then not all of the
data actually returned by the data source was retrieved. This could happen, for instance, if the
user’s computer does not have sufficient memory space to hold all the data. In this case, your
application can make more space available (by writing the data in the data record to disk, for
example) and then call the DBGetQueryResults function again to complete retrieval of the data.
Note: The DBGetQueryResults function retrieves whole rows only; if it runs out of
space in the middle of a row, it stores the partial row in a private buffer so that the
data in the results record ends with the last complete row. Because the last partial row
is no longer available from the data server, you cannot start to retrieve data with the
DBGetQueryResults function and then switch to the DBGetItem function to complete
the data retrieval.
The numCols field indicates the number of columns in each row of data.

The colTypes field is a handle to an array of data types, specifying the type of data in each
column. The number of elements in the array is equal to the value in the numCols parameter.
Table 8-1 shows the standard data types.
The colData field is a handle to the data retrieved by the DBGetQueryResults function.
The colInfo field is a handle to an array of records of type DBColInfoRecord, each of which
specifies the length, places, and flags for a data item. There are as many records in the array
as there are data items retrieved by the DBGetQueryResults function. Here is the
DBColInfoRecord type definition:
TYPE

DBColInfoRecord

=

RECORD
len:

Integer;

{length

of

places:

Integer;

{places

for

decimal

{

data

items}

flags:

Integer

money

{flags

for

data

data

item}
and

}

item}

END;

The len field indicates the length of the data item. The DBGetQueryResults function returns a
value in this field only for those data types that do not have implied lengths; see Table 8-1.
The places field indicates the number of decimal places in data items of types typeMoney and
typeDecimal. For all other data types, the places field returns 0.
The least significant bit of the flags field is set to 1 if the data item is in the last column of the
row. The third bit of the flags field is 1 if the data item is NULL. You can use the constants
kDBLastColFlag and kKDBNullFlag to test for these flag bits.

Converting

Query

Results to Text

The DBResultsToText function provided by the high-level interface converts the data retrieved
by the DBGetQueryResults function into strings of ASCII text. This function makes it easier
for you to display retrieved data for the user.

8-38

Using the Data Access Manager

2)

The Data Access Manager

Y

—
—_

as
-_
>.

~~

For the DBResultsToText function to convert data of a specific type to text, either the application or the system software must have a routine called a result handler. With system software
version 7.0, Apple Computer, Inc. is providing system result handlers for the data types
listed here. (These data types are described in Table 8-1.)
Data type

Constant

Data

type

Boolean
Short integer
Integer
Short floating point
Floating point
Date

typeBoolean
typeSMInt
typeInteger
typeSMFloat
typeFloat
typeDate

Time
Date and time
Character
Decimal number
Money value
Variable character

Constant
typeTime
typeTimeStamp
typeChar
typeDecimal
typeMoney
type VChar

Note: Apple’s system result handler for the variable character (typeVChar) data
type strips trailing spaces from the character string.
In addition to the result handlers for these standard data types, Apple is providing the
following three system result handlers that do not correspond to any specific data type:
Data type

Constant

Unknown
Column break
End of line

typeUnknown
typeColBreak
typeRowBreak

The typeUnknown result handler processes any data type for which no other result handler is
available. The DBResultsToText function calls the typeColBreak result handler after each
item that is not the last item in a row. This result handler does not correspond to any data
type, but adds a delimiter character to separate columns of text. The default typeColBreak
result handler inserts a tab character. Similarly, the DBResultsToText function calls the
typeRowBreak result handler at the end of each row of data to add a character that separates
the rows of text. The default typeRowBreak result handler inserts a return character. Your
application can install your own typeColBreak and typeRowBreak result handlers to insert
whatever characters you wish—or to insert no character at all, if you prefer.
You can install result handlers for any data types you know about. When you call the
DBiInstallResultHandler function, you can specify whether the result handler you are installing is a system result handler. A system result handler is available to all applications that
use the system. All other result handlers (called application result handlers) are associated with a particular application. The DBResultsToText function always uses a result
handler for the current application in preference to a system result handler for the same data
type. When you install a system result handler for the same data type as an already installed
system result handler, the new result handler replaces the old one. Similarly, when you install
an application result handler for the same data type as a result handler already installed for the
same application, the new result handler replaces the old one for that application.

Using the Data Access Manager

8-39

er)
©
@
eZ)
i? 2)

<

—
as
Dl
—

od

iy)
ge
co
=“

Inside Macintosh,

Volume VI

Result handlers are stored in memory. The Data Access Manager installs its system result
handlers the first time the Macintosh Operating System loads the Data Access Manager
into memory. You must reinstall your own application result handlers each time your
application starts up. You can also install your own system result handlers each time
your application starts up, or you can provide a system extension (that is, a file with an
'INIT’ resource) that installs system result handlers each time the user starts up the system.
Here is a function declaration for a result handler function.
FUNCTION

MyResultHandler

(dataType:

DBType;

theLen,thePlaces,theFlags:

Integer;

theData:

Ptr;

theText:

Handle)

OSErr;

The dataType parameter specifies the data type of the data item that the DBResultsToText
function is passing to the result handler. Table 8-1 describes the standard data types.
The parameters theLen and thePlaces specify the length and number of decimal places of the
data item that the DBResultsToText function wants the result handler to convert to text.

The parameter theFlags is the value returned for the flags parameter by the DBGetItem

function. If the least significant bit of this parameter is set to 1, the data item is in the

last column of the row. If the third bit of this parameter is set to 1, the data item is NULL.
You can use the constants kDBLastColFlag and KDBNullFlag to test for these flag bits.
The parameter theData is a pointer to the data that the result handler is to convert to text.
The parameter theText is a handle to the buffer that is to hold the text version of the data. The
result handler should use the SetHandleSize function to increase the size of the buffer as
necessary to hold the new text, and append the new text to the end of the text already in the
buffer. The SetHandleSize function is described in the Memory Manager chapter of
Volume II.
If the result handler successfully converts the data to text, it should return a result code

of 0 (noErr).

You can use the DBInstallResultHandler function to install a result handler and the

DBRemoveResultHandler function to remove an application result handler. You can
install and replace system result handlers, but you cannot remove them.

The following line of code installs an application result handler. The first parameter
(typeInteger) specifies the data type that this result handler processes. The second parameter (MyTypeIntegerHandler) is a pointer to the result handler routine. The last parameter
(FALSE) is a Boolean specifying that this routine is not a system result handler.
err

:=

DBInstallResultHandler

(typeInteger,MyTypeIntegerHandler,
FALSE) ;

Listing 8-5 shows a result handler that converts the integer data type to text.

8-40

Using the Data Access Manager

oo
——

The Data Access Manager

MyTypeIntegerHandler

(datatype:

DBType;

theData:

Ptr;

theLen:

theText:

Integer;

Handle)

:

-_

a

~

—

>
oO
0°
fas)
w
7)
=]
—
rs

Listing 8-5. A result handler
FUNCTION

ws
Mw

—

_

oo

OSErr;

ge
oO
~

VAR

theInt:

Longint;

theTextLen:

LongInt;

temp:

Str255;

atemol:

PEL?

atemp2:

Longint;

atemp3:

Longint;

BEGIN
BlockMove(theData,

@theInt,

NumToString(theInt,

temp);

theTextLen

:=

sizeof(thelInt));
{convert

GetHandleSize(theText)

SetHandleSize(theText,

theTextLen

+

{get

to

text}

current

size

{grow
IF

(MemError

<>

noErr)

THEN

of

theText}

LongInt(LENGTH(temp)
);

TypeIntegerHandler

text
:=

handle}
MemError

ELSE
BEGIN

atempl
atemp2

:=
:=

Ptr(ORD(@temp)
);
LongiInt(theText”)

+

theTextLen;

atemp3
:= Longint (LENGTH(temp) );
{use BlockMove
to append
text}
BlockMove

(P2CStr(atempl),

TypeIntegerHandler

:=

Ptr(atemp2),

atemp3);

MemError;

END;
END;

CREATING

A QUERY

DOCUMENT

A query document is a file of type ‘gery’ that contains a ‘qrsc' resource and one or more
‘wstr’ resources, and may contain a ‘qdef' resource plus other resources. Query documents
make it possible for you to write applications that can communicate with data servers without
requiring familiarity with the command language used by the data server. Because a query
document is most useful if it can be used by many different applications, no query document
should depend on the presence of a particular application in order to function.
An application can call the DBGetNewQuery function to convert a ‘qrsc' resource into a
query record in memory. The query record points to a 'wstr' resource that contains either a
complete query or a template for a query. If the 'wstr' resource is a template, it contains the
commands and data necessary to create a query, without any information that the user must
add just before the query is sent. The 'qdef' resource contains a query definition function,
which can modify the query record and, if necessary, fill in the query template to create a
complete query. The DBStartQuery function sends the query pointed to by a query record to a
data server. The following sections describe the contents of a query document, describe
query records, and define the ‘qrsc’, 'wstr', and 'qdef’ resources.
Creating a Query Document

8-4]

Inside Macintosh,

User

Volume

Interface

VI

Guidelines

for Query

Documents

All query documents should behave in fundamentally the same way. They should be selfexplanatory and should never execute a query without an explicit command from the user.
When your application opens a query document, the query document should display a dialog
box with enough information about the query so that the user can decide if it’s the right query.
The dialog box should describe the purpose of the query, what kind of data it transfers and in

which direction, the type of data source it accesses, and any warnings or instructions. The

dialog box can describe how the user interprets the data, such as the name of each field in a
record. Figure 8-6 shows an example of a query document dialog box.
This dialog box should allow the user to cancel the request for data. In addition, it may be
useful to allow the user to set parameters with text boxes, check boxes, or radio buttons.
For example, a query to a database of financial information could provide a list of these
options: a trial balance, profit-and-loss statements, or net worth reports. Save the last set
of user-specified parameters with the query document. This way the user can review the
parameters used to generate the data or use the same parameters the next time.
Once a query starts running, it must be able to complete its task without user intervention. If a
query must run modally (that is, it must run to completion before returning control to the
user), display a dialog box that shows the query’s progress and be sure to return control to
the user as soon as possible. The philosophy of this process is similar to that of receiving
electronic mail—that is, inform the user when the information arrives, but let the user decide
when to read it.
Whenever possible, query documents should check data before it is transmitted to a data
source to be sure it’s compatible. Establish a connection with a data source only after you
have checked the data.

Contents

of

a Query

Document

The query document must contain
m one ‘qrsc' resource, as defined in the next section, “Query Records and Query
Resources”
w an 'STR#' resource that contains the name of the database extension to be used, plus

any host, user name, password, and connection string needed for the DBInit function

m one or more 'wstr' resources containing queries—that is, strings of commands and data
that the DBSend

function sends to the data server and that the DBExec

function executes

A 'wstr' resource consists of a 2-byte length field followed by a character string. (The w in
‘wstr' refers to the length word as opposed to the length byte used in an 'STR' resource.)
Each 'wstr' resource contains one query (or one query template, to be modified by the query

definition function before it is sent to the data server). The 'qrsc' resource includes an array that

lists the resource ID numbers of all of the 'wstr' resources in the query document and an index
into the array that specifies which one of the 'wstr' resources should be sent to the data server.
In addition, the query document may contain
m a‘qdef resource that contains a query definition function
m any resources needed by the query definition function, such as 'DLOG' and 'DITL'
resources (which support dialog boxes)

8-42

Creating a Query Document

o 2)

The Data Access Manager

po)

—s

pol
>
°

i)
sc)

a
an
=

Profit and Loss

——

=)

—

This query document accesses the accounting

—_

ew

mainframe and retrieves 4 corporate profit and
loss statement that is current as of the latest
postings.

Your Name: | _

ye

oO

ar

|

Your Password: | _

Figure 8-6. A query document dialog box
m resources to support a customized icon (to replace the default icon that the Finder™ uses
for files of type ‘gery'); see the Finder Interface chapter in this volume for more information on icon resources and the User Interface Guidelines chapter for guidelines for
customized icons.
Figure 8-7 illustrates the relationship between a query document, the query record, and the
query definition function. The following sections describe 'qrsc' resources, query records,
and 'qdef' resources in detail.
Query document

| 'wstr' resource h
I

| ‘qrsc' resource

|

‘qdef' resource

|

Displays dialog

box asking user

for information

y

feds
supplie

info

=>

SS

Modifies

query

recordand
current

Query record

Current query

H
|

|

|

||

—laaiaimanp|
ry ry
re

4

que
Partial query

ue
ey

Info:

123 M St.,

Mytown, Mo.|—

=
= Query definition
function

=

Completed
mv
Info:

123 M St.,

Mytown, Mo.

Figure 8-7. Function of a query document
Creating a Query Document

8-43

Inside Macintosh,

Query

Volume VI

Records

and

Query

Resources

The DBGetNewQuery function converts the ‘qrsc' resource in the query document into a
query record in memory. The query definition function can then modify the query record
before the application sends the query to the data server. This section describes a query
record, and then defines the format of a 'qrsc' resource. A later section, “Writing a Query
Definition Function,” describes 'qdef resources and query definition functions.

Query

Records

The QueryRecord data type defines a query record.
TYPE

QueryRecord
RECORD

=

version:
id:

Integer;
Integer;

{query
record
format
version}
{resource
ID of
'qrsc'}

queryProc:

Handle;

{handle

ddevName:

Str63;

{name

of

database

host:

Str255;

{name

of

host

user:

StrE2593

{name

of

password:

Str2553

{user's

connStr:

Str255;

{connection

currQuery:
numQueries:
queryList:
numRes:

Integer;
Tnteger;
QueryListHandle;
Integer;

{current
query}
{mumber of queries}
{handles
to queries}
{number of resources}

resList:
dGataHandle:

ResListHandle;
Handle;

{list
of resources}
{handle
to memory
for

refCon:

Longint

{reserved

to

qdef}
extension}

computer}

user}
password}
string}

for

use

by

qdef}
app}

END;

Field

descriptions

version

The version number of the query record format. For the Data Access
Manager released with system software version 7.0, the version number
is 0.

id

The resource ID of the ‘qrsc' resource from which the Data Access
Manager created this query record.

queryProc

A handle to the query definition function that the DBStartQuery function
calls. This handle is NIL if there is no query definition function—that is,
if the DBStartQuery function should send the query specified by this
query record to the data server without modifications.

ddevName

The database extension name used as a parameter to the DBInit function.

8-44

Creating a Query Document

io)

The Data Access Manager

oY
—
as
—
>,

host

©
i)
s")
WM
if 2)

The name of the host computer system used as a parameter to the
DBInit function.

<
Seal
ps]

tw
reed

a
ti)

user

The name of the user, used as a parameter to the DBInit function.

password

The user’s password, used as a parameter to the DBInit function.

connStr

The connection string used as a parameter to the DBInit function.

currQuery

An index value from | through numQueries, indicating which element in
the array of query handles represents the current query. The current query
is the one actually sent to the data server. If the query document contains
more than one 'wstr' resource, the query definition function can prompt
the user to select a new current query and modify this field in the query
record appropriately.

numQueries

The number of queries referred to by the queryList field.

queryList

A handle to an array of handles. Each handle in this array refers to a
query. Each query is created from a 'wstr' resource in the query
document and is stored in memory as a 2-byte length field followed by
ASCII text. (The length does not include the 2 bytes of the length field.)
The query definition function can create a new query. To add a new
handle to the array of handles, use the Memory Manager’s SetHandleSize
function to increase the size of the array. Don’t forget to change the value
of the numQueries field as well.

numRes

The number of resources referred to by the resList field.

resList

A handle to an array of records of type ResListElem. Each record in the
array contains the type and ID of a resource that is needed by the query
definition function.
TYPE

ResListElem

i)
“

=

RECORD
theType:
id:

ResType;
Integer

{resource
{resource

type}
ID}

END;

dataHandle

A handle to memory for use by the query definition function. When the
Data Access Manager first creates the query record, this field is NIL. The
query definition function can allocate memory and place a handle to it in
this field. The query definition function should dispose of any memory it
allocates before it returns control to the Data Access Manager.

refCon

The query record’s reference value. The application can use this field for
any purpose.

Creating

a Query Document

8-45

Inside Macintosh, Volume VI

Query

Resources

Each query document should contain a single ‘qrsc' resource. Here is the structure of the
‘qrsc' resource, in the format used by the Rez resource compiler supplied with MPW®.
type

‘qrsc'

{

Integer;

/*

version

Integer;
Integer;

/*
/*

ID
ID

of
of

*/
‘'qdef'
'STR#'

ddevName,

host,

connection
Integer;
/*

/*

array

Integer
wide

of
=

IDs

of

$$CountOf

array

'‘'wstr'

current

that

;

*/
that

user,

string

query

resources

(QueryArray)

resource
resource

contains

password,

*/

*/
contain

queries

/*

array

size

/*

ID

'‘'wstr'

*/

*/

QueryArray {

Integer;

of

resource

*/

}3
/*

array

in
Integer

wide

of

the
=

resource

query

types

document

$$CountOf

and

(ResArray)

array ResArray {
literal LongInt;
Integer;

IDs

for

other

resources

*/
;

/*

array

size

/*
/*

resource
resource

*/

type */
ID */

ie
} 3

The first field in the 'qrsc’ resource is the version number of the 'qrsc' format. For the Data
Access Manager released with system software version 7.0, the version number is 0.

The second field is the resource ID of the 'qdef' resource containing the query definition
function that the Data Access Manager is to call when it opens this 'qrsc' resource. Use an
ID of 0 if there is no query definition function for this resouree—that is, if the Data Access

Manager should send the query in this resource to the data server without modifications.

The third field is the ID of an 'STR#' resource that contains five Pascal strings corresponding
to some of the parameters used by the DBInit function. If the query definition function is
going to prompt the user for the values of these parameters before entering them in the query
record, they should be zero-length strings in the 'STR#' resource.
The sixth field in the 'qrsc’ resource is an array of ID numbers of the 'wstr' resources in the
query document. The fifth field is the size of the array of 'wstr' IDs, and the fourth field is an
index value indicating which element in the array of 'wstr' IDs represents the current query.
(The array elements are numbered starting with |.) The current query is the one actually sent
to the data server. If the query document contains more than one 'wstr' resource, the query
definition function can prompt the user to select the query to use and modify the current query
field in the query record appropriately.

8-46

Creating a Query Document

2)
—

The Data Access Manager

ad

ey)
_

ey

>
©

i)

The eighth field in the 'qrsc' resource is an array listing the resource types and IDs of all the
resources in the query document other than the standard resources included in all query
documents. The seventh field is the size of this array. The resources listed in this final array
are those used by the query definition function. This list should include resources embedded
in other resources, such as a 'PICT' resource that is included in a 'DITL' resource.

Writing a Query

Definition

Function

When the Data Access Manager creates a query record, it calls the query definition function
specified by the queryProc field in the query record. The purpose of the query definition function is to modify the query and the query record before the query is sent to the data
server. The query definition function can use dialog boxes to request information from the
user. Because a query document is most useful if it can be used by many different applications, no query definition function should depend on the presence of a particular application.
If you want to include a query definition function, you must make it the first piece of code in
a resource of type ‘qdef’ in the query document.
Here is a function declaration for a query definition function.
FUNCTION

MyQDef

(VAR

sessID:

LongInt;

query:

QueryHandle)

:

OSErr;

If the application has already initiated a session with the data server, the DBStartQuery function passes the session ID for that session in the sessID parameter to the query definition
function. If the query definition function receives a 0 in this parameter, then the Data Access
Manager has not initiated a session. In this case, the query definition function can return a 0
in the sessID parameter, or it can call the DBInit function to initiate a session and then return
the session ID in this parameter.
If the query definition function returns a 0 in the sessID parameter, the DBStartQuery
function calls the DBInit function and then calls the DBSend function to send a query to
the data server. If the query definition function returns a session ID in this parameter,
the DBStartQuery function calls the DBSend function immediately.
The query parameter to the query definition function specifies a handle to the query record.
The query definition function can modify any of the fields in the query record, including the
currQuery field that specifies which query is to be sent to the data server. In addition, the
query definition function can modify an existing query or create a new query, adding the
handle to the new query to the query list. Note that, because a query in memory consists only
of a 2-byte length value followed by a character string, the query definition function has to
know the exact contents and structure of a query in order to modify it.
The query definition function must return the noErr result code as the function result if the
function executed successfully. If it returns any other value, the DBStartQuery function does
not call the DBSend function. The query definition function can return any result code,
including noErr, userCanceledErr, or reDBError.
When the DBStartQuery function calls the query definition function, the current resource file
is the file that contains the 'qrsc' resource from which the Data Access Manager created the
query record. When the query definition function returns control to the Data Access Manager,
the current resource file must be unchanged.

Creating a Query Document

8-47

$7)
7)
”

i
el

SS)
=
~
ge
@
~

Inside Macintosh,

Volume VI

The query definition function can allocate memory and use the dataHandle field in the query
record to store a handle to it. The query definition function must free any memory it allocates

before terminating.

Listing 8-6 shows a query definition function that uses a dialog box to prompt the user for a
user name and password and then modifies the query record accordingly.

Listing 8-6. A query definition function
FUNCTION

MyQDef

(VAR

sessID:

LongInt;

query:

QueryHandle)

CONST
myNameItem
myPassWordItem

ia
8;

=

VAR

Integer;

myNumRes:
myResList:

ResListHandle;

myResLPtr:

ResListPtr;

my Index:

Integer;

myDialog:

DialogPtr;

myDlogID:

Integer;

itemType:
itemHName:

Integer;

Handle;
Handle;

itemHPasswad:
itemBox:

Rect;

mySTR:

Array

itemHit:

Integer;

myQOErr:

OsErr;

[1.2]

OF

Stx255%

BEGIN

{If

sessID

=f),

{
{

initiated .
session,
or

{

care

{

check

HLock

of

no
Your
it

can

t His:

the

:=

myResList

In

let

the

initiate

DBStartQuery

sessID

this example,
parameter. }

(query)

);

(Handle

myNumRes

session has been }
qdef may optionally
the

qdef

a

take

doesn't

}

query”*.numRes;

:= query”*.resList;
HLock (Handle(myResList)
);
myResLPtr
myResList*%;
myIndex

:=

{look

fora

WHILE

(myIndex
< myNumRes)
AND
(myResLPtr* [myIndex].theType

0;
"DLOG '

resource}

BEGIN
my Index

:=

myIndex

+

1;

END;

8-48

Creating a Query Document

<>

}

routine

"DLOG' )

DO

}

CO
a

The Data Access Manager

Nw
pa)
oe

pe)

>
er]
©,
is7]

{Was

a

IF

'DLOG'

resource

found,

myNumRes)

THEN

(myIndex

<

myDlogID

:=

{We

the

found

myResLPtr%*
'DLOG'

or

did

the

index

run

ww
77)
)

out?}

—

[myIndex]

£9
~
£9
ga

.id

resource. }

@
‘er |

ELSE
BEGIN

{The

'DLOG'

{

is

probably

wasn't

{

found;

okay;

it

record

exit

means

don't

get

and

the

query

MyODEF

:=

noErr;

HUnlock

(Handle

HUnlock

(Handle (myResList));

(query)

with

just

no

error.

that

the

This

query

}

}

modified. }

);

EXIT (MyQDef) ;

END;

{Found the 'DLOG' and its ID; now put up the
myDialog
:= GetNewDialog(myDlogID,
Ptr(NIL),
Set Port

(GrafPtr(myDialog)
);

{Now

you

can

{

the

query

{ What you
{ the qdef
of

change

the

query

record

change is entirely up
changes only the user

we

available
want

the

WindowPeek

myNameItem,

to

the

user

to

the

name

itemType,

filter

itemHit

and

=

itself.

ok

itemHName,

itemType,

routine

password

is

a

:=

the

LongInt

routine

fields

in

ModalDialog(myNamePasswdFltrFunc,
IF

query

}

}

itemBox) ;

itemHPasswd,

strings

itemBox);

}

edit.}

(myDialog)*.refCon

{myNamePasswdFltrFunc

{

the

record. }

GetDItem(myDialog,

{Make

or

to you.
In this example,
and password fields }

GetItext (itemHName,
mySTR[1]);
GetDItem(myDialog,
myPassWordItem,
GetItext (itemHPasswd,
mySTR[2]);

{

dialog box.}
WindowPtr(-1));

that

the

(@mySTR)

;

allows

the

user

user

and

dialag

box.}

to

edit

}

itemHit);

THEN

BEGIN
{The

{

user

fields

clicked

of

the

the

query

OK

button.

Update

the

password

}

record.}

query**.user
:= mySTR[1];
query”*.password
:= mySTR[2];
MyQDef

:=

noErr;

END

ELSE MyQDef
:= userCanceledErr;
HUnlock (Handle (query) ) ;

HUnlock

(Handle (myResList));

DisposDialog(myDialog) ;
END;

Creating a Query Document

8-49

Inside Macintosh,

DATA

Volume VI

ACCESS

MANAGER

ROUTINES

The Data Access Manager has high-level routines, low-level routines, and routines that
manipulate result handlers. This section describes all of the Data Access Manager routines.
All of the low-level routines and some of the high-level routines have as a parameter a pointer
to an asynchronous parameter block. If you specify a nonzero value for this parameter, the
database extension executes the function asynchronously—that is, it returns control to the
Data Access Manager before the routine has completed execution, and the Data Access
Manager returns control to your application. If you specify NIL for the pointer to the asynchronous parameter block, the database extension does not return control to your application
until the routine has finished execution. Your application must call the WaitNextEvent function periodically to allow an asynchronous routine to complete execution. The WaitNextEvent
function is described in the Event Manager chapter of this volume.
You can tell when an asynchronous routine has completed execution and check the result
code by looking at values in the asynchronous parameter block. The asynchronous parameter
block is described in the next section, ‘““Asynchronous Execution of Routines.”
Note: A noErr result code returned by a routine that has been called asynchronously
indicates only that the routine began execution successfully. You must check the
result field of the asynchronous parameter block for the final result of the routine.

Assembly-language note: You can invoke each of the Data Access
Manager routines with a macro that has the same name as the routine, but
preceded with an underscore; for example, the macro for the DBInit function
is named _DBInit. Each of these macros places a routine selector in the DO

register and calls the trap _Pack13. The routine selectors are listed in
“Summary of the Data Access Manager” at the end of this chapter.

Asynchronous

Execution

of Routines

Each Data Access Manager routine that can be called asynchronously (that is, that can return
control to your application before it has completed execution) takes as a parameter a pointer to
a parameter block known as the asynchronous parameter block. If this pointer is NIL, the
routine does not return control to your application until it has completed execution.
Note: The asynchronous parameter block is passed on to the database extension,
which is responsible for implementing the asynchronous routine. If the database
extension does not support asynchronous routines, the Data Access Manager returns
the reDBAsyncNotSupp result code and terminates execution of the routine.
The DBAsyncParamBlockRec data type defines the asynchronous parameter block.

8-50

Data Access Manager Routines

aH

The Data Access Manager

o

pS)

ns

ba)
>

©

st)
is")

TYPE

DBAsyncParamBlockRec

2)
N

=

=

RECORD

—

completionProc:

ProcPtr;

{pointer

result:

OSErr;

{result

userRef:

Longint;

{reserved

for

use

by

application}

ddevRef:

LongInt;

{reserved

for

use

by

database

use

by

Data

{
reserved:

LongIint

to

of

completion

=
=
tS)
ge

routine}

call}

@

}

extension}

{reserved

for

Access

Mgr}

END;

DBAsyncParmBlkPtr

=

*DBAsyncParamBlockRec;

The completionProc field is a pointer to a completion routine that the database extension calls
when it has completed executing the asynchronous function. Before calling the completion
routine, the Data Access Manager places a pointer to the asynchronous parameter block in the
AO register. If you do not want to use a completion routine, set this parameter to NIL.
The database extension sets the result field to | while the routine is executing, and places the
result code in it when the routine completes. Your application can poll this field to determine
when an asynchronous routine has completed execution.
The userRef field is reserved for the application’s use. Because the Data Access Manager
passes a pointer to the parameter block to the completion routine, you can use this field to
pass information to the completion routine.
The ddevRef field is reserved for use by the database extension, and the reserved field is
reserved for use by the Data Access Manager.
You can use the DBKill function to cancel an asynchronous routine.

Initializing the Data Access

Manager

You must initialize the Data Access Manager before you can use it.
FUNCTION

InitDBPack

:

OSErr;

The InitDBPack function initializes the Data Access Manager. You must call the InitDBPack
function before you call any other Data Access Manager routines. If the Data Access Manager
has already been initialized, the InitDBPack function returns the noErr result code but does
nothing else.
The interface routine that implements the InitDBPack function includes a version number for
the Data Access Manager. If the Data Access Manager is a different version from that specified by the interface routine, then the InitDBPack function returns the reDBWrongVersion
result code.
Result codes
noErr
rcDBWrongVersion

0
—812

No error
Wrong version number

Data Access Manager Routines

8-5]

Inside Macintosh,

Volume

VI

High-Level

Interface

The high-level interface to the Data Access Manager allows applications to manipulate query
documents and to get the results of the query provided by a query document. The use and
contents of query documents are discussed in “Creating a Query Document” earlier in
this chapter.

Handling

Query

Documents

The routines described in this section open query documents, create query records, dispose
of query records, and use query documents to establish communication with and send queries
to a data server.
FUNCTION

DBGetNewQuery

(queryID:

Integer;

VAR

query:

QueryHandle)

OSErr;

The DBGetNewQuery function creates a query record from the 'qrsc' resource with the
resource ID you specify in the queryID parameter. The query parameter returns a handle to
the query record. The resource file that contains the ‘qrsc' resource must remain open until
after the DBStartQuery function has completed execution. If you do not already know the
resource ID of the ‘qrsc' resource (for example, if you call the StandardGetFile procedure to
let the user select the query document), you can use Resource Manager routines to determine
the resource ID. The StandardGetFile procedure is described in the Standard File Package
chapter of this volume, and the Resource Manager is described in Volume I.
Result codes
noErr
rcDBPackNotInited
FUNCTION

DBDisposeQuery

0)
—813

Query record built successfully
The InitDBPack function has not yet been called

(query:

QueryHandle)

:

OSErr;

The DBDisposeQuery function disposes of a query record and frees all the memory that the
Data Access Manager allocated when it created the query record. You should call this function
after you are finished using a query record.
The query parameter is a handle to the query record.
Result codes

noErr
rcDBPackNotInited

8-52

0)
—813

Query record disposed of successfully
The InitDBPack function has not yet been called

Data Access Manager Routines

DH
—

The Data Access Manager

FUNCTION

DBStartQuery

(VAR

sessID:

LongInt;

query:

statusProc:

ProcPtr;

asyncPB:

—_

=

_

pe

>
re)
oO
©
A
2)

QueryHandle;

2

DBAsyncParmBlkPtr)

—

~

=

OSErr;

=
ga

©
|

The DBStartQuery function performs the following tasks, in the order specified:
IP It calls the query definition function (if any) pointed to by the query record. The query
definition function modifies the query record and the query, usually by asking the user
for input. The query definition function can display a dialog box that gives the user the
option of canceling the query; if the user does cancel the query, the DBStartQuery
function returns the userCanceledErr result code.
. If you specify a nonzero value for the statusProc parameter, the DBStartQuery function
calls your status routine with the kDBUpdateWind constant in the message parameter so
that your application can update its windows.
. If you specify a nonzero value for the statusProc parameter, the DBStartQuery function
calls your status routine with the kDBAboutToInit constant in the message parameter so
that your application can display a dialog box informing the user that a session is about
to be initiated with a data server, and giving the user the option of canceling execution
of the function.
. If the sessID parameter is 0, the DBStartQuery function calls the DBInit function to
initiate a session, and returns a session ID.

. If you specify a nonzero value for the statusProc parameter and the DBStartQuery
function calls the DBInit function, the DBStartQuery function calls your status routine
with the kDBInitComplete constant in the message parameter and the result of the
DBInit function in the function result.
. The DBStartQuery function calls the DBSend function to send the query to the
data server.

. If you specify a nonzero value for the statusProc parameter, the DBStartQuery function
calls your status routine with the kDBSendComplete constant in the message parameter
and the result of the DBSend function in the result parameter.
. The DBStartQuery function calls the DBExec function to execute the query.
. If you specify a nonzero value for the statusProc parameter, the DBStartQuery function
calls your status routine with the KDBExecComplete constant in the message parameter
and the result of the DBExec function in the result parameter.
10. If you specify a nonzero value for the statusProc parameter, the DBStartQuery function
calls your status routine with the kDBStartQueryComplete constant in the message
parameter and the result of the DBStartQuery function in the result parameter.
You can use the sessID parameter to specify a session ID if your application or another
application has already initiated a session with the data server. If you specify NIL for this
parameter, then the DBStartQuery function initiates a session and returns the session ID in the
sessID parameter.

Data Access Manager Routines

8-53

Inside Macintosh, Volume VI

You use the query parameter to specify a handle to a query record.
You can use the statusProc parameter to specify a pointer to a status routine that your application can use to update its windows after the query definition function has completed execution. (The DBStartQuery function does not attempt to update your application’s windows.)
The DBStartQuery function also calls your status routine before it initiates a session with a
data server, after it calls the DBInit function, after it calls the DBSend function, and after it

calls the DBExec function. Status routines are discussed in “Writing a Status Routine for
High-Level Functions” earlier in this chapter.

If you specify a pointer to an asynchronous parameter block in the asyncPB parameter, the
DBStartQuery function calls the DBInit, DBSend, and DBExec functions asynchronously.
As soon as the DBInit function has started execution, it returns control to your application.
Your application must then call the WaitNextEvent function periodically to allow these
asynchronous routines to run, and it must check the result field of the asynchronous

parameter block to determine when each routine has completed execution.
Result codes

noErr
userCanceledErr
rcDBError

Q
—128
-802

rcDBBadSessID
rcDBBadDDev

-—806
—808

rcDBAsyncNotSupp

-—809

rcDBPackNotlnited

-813

Handling

Query

Noerror
User canceled the query
Error initiating session, sending text, or
executing query
Session ID is invalid
Couldn’t find the specified database extension, or
error occurred in opening database extension
The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called

Results

The routines in this section retrieve query results and convert them to text.
FUNCTION

DBGetQueryResults

(sessID:

LongiInt;

VAR

results:

timeout:

LongiInt;

asyncPB:

DBAsyncParmBlkPtr)

ResultsRecord;

statusProc:

ProcPtr;
:

OSErr;

The DBGetQueryResults function retrieves the results returned by a query and places them in
memory. If there is sufficient memory available, this function retrieves all of the results at
once. If the DBGetQucryResults function runs out of memory, it places as much data as
possible in memory, up to the last whole row. You can then make more memory available
and call the DBGetQueryResults function again to retrieve more data.
The DBGetQueryResults function can be used to retrieve the results of any query, not only
queries sent and executed by the DBStartQuery function.
The sessID parameter specifies the ID of the session from which you wish to retrieve results.

8-54

Data Access Manager Routines

o )
ee

The Data Access Manager

a—
_

p=)

>

The results parameter is the results record, which contains handles to the retrieved data.
Results records are described in “Getting Query Results” earlier in this chapter. You must
allocate the results record data structure and pass this record to the DBGetQueryResults
function. The Data Access Manager allocates the handles inside the results record. When your
application is finished using the results record, you must deallocate both the results record
and the handles inside the results record.
The timeout parameter specifies the value that the DBGetQueryResults function uses for
the timeout parameter each time it calls the DBGetItem function. The timeout parameter
specifies the maximum amount of time that the database extension should wait to receive
results from the data server before canceling the DBGetItem function. Specify the timeout
parameter in sixtieths of a second. To disable the timeout feature, set the timeout parameter
to the kDBWaitForever constant. Some database extensions ignore the timeout parameter
when you specify a nonzero value for the asyncPB parameter.
You can use the statusProc parameter to specify a pointer to a status routine that you provide.
The DBGetQueryResults function calls your status routine after it calls the DBGetItem
function to retrieve a data item. When it calls the status routine, the DBGetQueryResults
function provides the result of the DBGetltem function, the data type, data length, number
of decimal places, and flags associated with the data item, and a pointer to the data item.
Status routines are discussed in “Writing a Status Routine for High-Level Functions” earlier
in this chapter.
If you specify a pointer to an asynchronous parameter block in the asyncPB parameter, the
DBGetQueryResults function calls the DBGetItem function asynchronously for each data
item. As soon as the DBGetlItem function has started execution, it returns control to your
application. Your application must then call the WaitNextEvent function periodically to allow
this asynchronous routine to run, and it must check the result field of the asynchronous
parameter block to determine when the routine has completed execution.
Result codes

noErr
userCanceledErr
rcDBValue
rcDBError
rcDBBreak
rcDBExec
rcDBBadSessID
rcDBAsyncNotSupp

Q
—128
—801
—802
—804
-—805
—806
-809

rcDBPackNotInited

-813

FUNCTION

DBResultsToText

Query execution successful; no results returned
Function canceled by status routine
Data available
Query execution ended in an error
Function timed out
Query currently executing
Session ID is invalid
The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called

(results:
Handle)

ResultsRecord;
:

VAR

theText:

OSErr;

The DBResultsToText function calls result handlers to convert to text the data retrieved by the
DBGetQueryResults function. Result handlers are described in “Converting Query Results to
Text” earlier in this chapter.

Data Access Manager Routines

8-55

i)
)
>

NM
WM

<<
—

m
~
i]
j=)
@
ber |

Inside Macintosh,

Volume VI

The results parameter is the results record returned by the DBGetQueryResults function. The
parameter theText contains a handle to the converted text. This handle is allocated by the Data
Access Manager.
Result codes
noErr
rcDBPackNotInited

Low-Level

0
—813

No error
The InitDBPack function has not yet been called

Interface

The low-level interface to the Data Access Manager allows applications to open and close
sessions with a data server, send and execute queries, retrieve query results, and obtain
information about any current session.

Controlling the Session
The functions in this section initiate and close sessions, obtain information about sessions,

and cancel functions that were called asynchronously.
FUNCTION

DBInit

(VAR

sessID:

LongInt;

password,connStr:

ddevName:

Str255;

Str63;

asyncPB:

host,user,

DBAsyncParmBlkPtr)

OSErr;

The DBInit function initiates a session with a data server. You must initiate a session before
you call any Data Access Manager function that requires a session ID as an input parameter.
If the DBInit function returns a nonzero session ID, you must call the DBEnd function to
terminate the session, even if the DBInit function also returns a result code other than noErr.
Because the high-level function DBStartQuery can call the DBInit function, you do not have
to call the DBInit function if you have called the DBStartQuery function.
The DBInit function returns the session ID in the sessID parameter. This session ID is unique;
no other current session, for any database extension, has the same session ID. You must

specify the session ID any time you want to send data to or retrieve data from this session.
Depending on the database extension you are using, the DBInit function might return a

session ID of zero if it fails to initiate a session, or it might return a nonzero session ID and a
result code other than noErr. In the latter case, you can pass the session ID to the DBGetErr
function to determine the cause of the error.

The ddevName parameter is a string of no more than 63 characters that specifies the name of
the database extension. The name of the database extension is contained in the database
extension file in a resource of type 'STR' with an ID of 128. For the Data Access Language
database extension provided by Apple, for example, this string is “DAL”.
The host parameter specifies the name of the host system on which the data server is located.
This name depends on the manner in which the database extension initiates communication
with the data server and how the system administrator has set up the computer system.

8-56

Data Access Manager Routines

o)

The Data Access Manager

—)

ps)

-_-

ps)

>

The user parameter specifies the name of the user, and the password parameter specifies the
password associated with the user name.
The connStr parameter is a string that is passed to the data server, which might pass it on to
the database management software on the host computer. This string is necessary in some
systems to complete log-on procedures.
The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes

noErr
rcDBError
rcDBBadDDev
rcDBAsyncNotSupp

rcDBPackNotInited
FUNCTION

DBEnd

(sessID:

QO
—802
—808

No error
Error initiating session
Couldn’t find the specified database extension, or
error occurred in opening database extension
-809 _ The database extension does not support
asynchronous calls
-813
The InitDBPack function has not yet been called
LongInt;

asyncPB:

DBAsyncParmBlkPtr)

:

OSErr;

The DBEnd function terminates a session with a data server and terminates the network

connection between the application and the host computer. You must call the DBEnd function
to terminate a session.

The sessID parameter is the session ID that was returned by the DBInit function.
The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes
noErr

Q

No error

rcDBError

—802

Error ending session

rcDBAsyncNotSupp

-809

The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called

rcDBBadSessID

rcDBPackNotInited
FUNCTION

DBGetConniInfo

—806

-—813

Session ID is invalid

(sessID:

LongInt;

sessNum:

returnedID,version:

Integer;

LongInt;

VAR

VAR
ddevName:

Str63;
VAR host,user,network,connStr:
VAR start:
LongInt;
VAR state:
OSErr;
DBAsyncParmBl1kPtr)
: OSErr;

Str255;
asyncPB:

The DBGetConnInfo function returns information about the specified session, including
m

the version of the database extension

m the name of the host system on which the session is running
Data Access Manager Routines

8-57

QO
Q
@

wn
72)
a
—
$9

=

pe)
ve
@
=“

Inside Macintosh,

Volume VI

m the user name
= the connection string that was used to initiate communication
m the name of the network
m the time at which the session started, in ticks
w

the status of the session

In addition, if you include a nonzero value for the sessID parameter when you call the
DBGetConnInfo function, the function returns the name of the database extension. If
you use 0 for the sessID parameter and specify the database extension and session
number instead, the function returns the session ID.
You can use this function to get information about a particular session, or you can call the
function repeatedly, incrementing the session number each time, to get information about
all of the sessions associated with a particular database extension.
The sessID parameter is the session ID that was returned by the DBInit function. The
sessNum parameter is the session number of the session about which you want information.
You can specify either the session ID or the session number when you call the DBInit
function. If you specify the sessID parameter, use 0 for the sessNum parameter. If you
specify the sessNum parameter, then use 0 for the sessID parameter. If you specify the
sessNum parameter, you must specify a value for the ddevName parameter as well. If you
specify the session number and the database extension, then the DBGetConnInfo function
returns the session ID in the returnedID parameter.
The version parameter returns the version number of the database extension that is currently
in use.

The ddevName parameter is a string of no more than 63 characters that specifies the name of

the database extension. If you specify 0 for the session ID, you must include the name of the
database extension as well as a session number. If you specify a valid session ID, then the
DBGetConnInfo function returns the name of the database extension in the ddevName
parameter. The name of the database extension is contained in the database extension file in a
resource of type 'STR ' with an ID of 128. For the Data Access Language database extension
provided by Apple, for example, this string is “DAL”.

The host, user, and connStr parameters are the host, user, and connection strings that were
used to initiate communication with the data server.

The network parameter is the name of the network through which the database extension is
communicating with the data server. This parameter is an empty string if you are not communicating through a network.
The start parameter is the time, in ticks, at which this session was initiated.

The state parameter returns one of the following values to provide information about the
status of the session:
CONST

8-58

noErr
rcDBValue

=
=

0;
-80i;

{no error;
ready
for more
{output
data available}

rcDBError

=

-802;

{execution

rcDBExec

=

—805;

{busy;

Data Access Manager Routines

ended

currently

in

an

text}

error}

executing

query}

aH

The Data Access Manager

Y
—

=
~

a

CG
C

The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.

&
+N
*/

<<
—

as
~
—

el

=

Result codes
noErr
rcDBBadSessID

ge

&
ms

rcDBBadSessNum
rcDBBadDDev

Noerror
Session ID is invalid or database extension name is
invalid
-—-807 _ Invalid session number
—808
Couldn't find the specified database extension, or

rcDBAsyncNotSupp

-—809

rcDBPackNotInited

-813

FUNCTION

Q
—806

DBGetSessionNum

error occurred in opening database extension
The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called

(sessID:
asyncPB:

LongInt;

VAR

sessNum:

DBAsyncParmBlkPtr)

Integer;
:

OSErr;

The DBGetSessionNum function returns the session number of the session you specify with
the sessID parameter. The session number is unique for a particular database extension, but
the same session number might be in use for different database extensions at the same time.
The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes
noErr
rcDBBadSessID
rcDBAsyncNotSupp
rcDBPackNotInited
FUNCTION

DBKill

0 No error
—806
Session ID is invalid
-809 _ The database extension does not support
asynchronous calls
-813
The InitDBPack function has not yet been called

(asyncPB:

DBAsyncParmBlkPtr)

:

OSErr;

The DBKill function cancels the execution of the asynchronous call specified by the asyncPB
parameter.
The asyncPB parameter is a pointer to the asynchronous parameter block.
Result codes
noErr
rcDBError
rcDBBadAsynchPB
rcDBPackNotInited

0
—802
-810
-813

Asynchronous routine canceled successfully
Error canceling routine
Invalid parameter block specified
The InitDBPack function has not yet been called

Data Access Manager Routines

8-59

Inside Macintosh,

Sending

and

Volume VI

Executing

Queries

The functions in this section send queries or portions of queries to the data server, execute a
query that has been sent, return information about queries that have been sent, and halt
execution of queries that are executing.
FUNCTION

DBSend

(sessID:

LongInt;

asyncPB:

text:

Ptr;

DBAsyncParmB1lkPtr)

len:
:

Integer;

OSErr;

The DBSend function sends a query or a portion of a query to the data server. The data server
appends this portion of the query to any portion you sent previously. Because the Data
Access Manager does not modify the string you send in any way, it does not insert any
delimiter between fragments of queries that you send to the data server. If you want a blank
or a semicolon to be included between query fragments, or if you want to use return
characters to divide the query into lines of text, you must include them in the character string
that you send with this function.
The data server does not execute the query until you call the DBExec function.
The sessID parameter is the session ID that was returned by the DBInit function.
The text parameter is a pointer to the query or query fragment that you want to send to the
data server. The query or query fragment must be a character string. The len parameter
specifies the length of the character string. If the len parameter has a value of —1, then the
character string is assumed to be NULL terminated (that is, the string ends with a NULL
byte); otherwise, the len parameter specifies the number of bytes in the string.
The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes

noErr
rcDBError
rcDBBadSessID
rcDBAsyncNotSupp

0
—802
-—806
-809

rcDBPackNotInited

-813

FUNCTION

DBSendItem

(sessID:

No error
Error trying to send text
Session ID is invalid
The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called
LongInt;

dataType:

flags:
Integer;
buffer:
Ptr;
DBAsyncParmB1kPtr)
: OSErr;

DBType;

len,places,

asyncPB:

The DBSendItem function sends a single data item to the data server. You can use this
function to send to the data server the data that you wish to include in a query. The database
extension or the data server (depending on how the system is implemented) converts the
data item to a character string and appends it to the query, just as the DBSend function
appends a query program fragment to the query. The query is not executed until you call
the DBExec function.

8-60

Data Access Manager Routines

o

The Data Access Manager

0
ry=
$9
>

G
a
o
i?)

The sessID parameter is the session ID that was returned by the DBInit function.

i? 2)

<—

£9
=
fo

The dataType, len, and places parameters specify the data type, length, and number of
decimal places for the data item that you are sending to the data server. The database
extension and data server ignore the len parameter if the data type has an implied length.
The database extension and data server ignore the places parameter for all values of the
dataType parameter except typeDecimal and typeMoney. Data types are discussed in
“Getting Query Results” earlier in this chapter.

itj=)

Me

The buffer parameter is a pointer to the memory location of the data item that you want to
send. When you use the DBSendItem function to send an item of data to a data server,
the database extension and data server format the data according to the data type, length,
and decimal places you specify, convert it to a character string, and append the data to
the query.
Set the flags parameter to 0. There are no flags currently defined for the DBSendItem function.
The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes
noErr

Q

No error

rcDBError

—802 _ Error trying to send item

rcDBAsyncNotSupp

-809

rcDBBadSessID

rcDBPackNotInited
FUNCTION

DBExec

(sessID:

—806

-813

Session ID is invalid

The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called

LongInt;

asyncPB:

DBAsyncParmBlkPtr)

:

OSErr;

The DBExec function initiates execution of a query that you have sent to the data server. Use
the DBSend and DBSendlItem functions to send a query to the data server. Use the DBState
function to determine the status of a query after you have initiated execution.
The sessID parameter is the session ID that was returned by the DBInit function.
The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes

noErr
rcDBError
rcDBBadSessID
rcDBAsyncNotSupp

Q
—802
—806
-809

rcDBPackNotInited

—813

Execution has begun
Error trying to begin execution
Session ID is invalid
The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called

Data Access Manager Routines

8-61

Inside Macintosh,

FUNCTION

Volume VI

DBState

(sessID:

Longint;

asyncPB:

DBAsyncParmBlkPtr)

:

OSErr;

The result code returned by the DBState function indicates the status of the data server. You
can use this function to determine whether the data server has successfully executed a query
and whether it has data available for you to retrieve.
The sessID parameter is the session ID that was returned by the DBInit function.
The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes

noErr
rcDB Value
rcDBError
rcDBExec
rcDBBadSessID
rcDBAsyncNotSupp

0
—801
—802
—805
—806
-809

rcDBPackNotInited

-813

FUNCTION

DBGetErr

(sessID:

Noerror; ready for more text
Output data available
Error executing function
Query currently executing
Session ID is invalid
The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called
LongInt;

item2,errorMsg:

VAR

errl,err2:

Str255;

asyncPB:

LongInt;

VAR

iteml,

DBAsyncParmB1lkPtr)

OSEIrr}

The DBGetErr function retrieves error codes and error messages from a data server. You can
use this function to obtain information when a low-level function returns the result code
rcDBError. If the DBState function returns the reDBError result code, indicating that
execution of a query ended in an error, the error information can help you debug the query.
The meaning of each error code and error message returned by this function depends on the
data server with which you are communicating; see the documentation for that data server for
more information.
The sessID parameter is the session ID that was returned by the DBInit function.
The errl and err2 parameters return the primary and secondary error codes. The item1 and
item2 parameters return strings that describe the objects of the error message. The errorMsg
parameter returns the error message.
The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes
noErr

8-62

Q

rcDBError
rcDBBadSessID
rcDBAsyncNotSupp

—802
—806
-809

rcDBPackNotInited

-813

No error

Error retrieving error information
Session ID is invalid
The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called

Data Access Manager Routines

KH
_—

The Data Access Manager

\w/

_
=
&

>
i)
©

FUNCTION

DBBreak

i$"

(sessID:

LongInt;

abort:
Boolean;
DBAsyncParmBlkPtr)
: OSErr;

eZ)
~

asyncPB:

4

—

=
_

ed

The DBBreak function can halt execution of a query and reinitialize the data server, or it can
unconditionally terminate a session with a data server. You can use this function to cancel a
query if you determine that it is taking too long to complete execution, for example.
The sessID parameter is the session ID that was returned by the DBInit function.
If the abort parameter is TRUE (nonzero), the data server halts any query that is executing

and terminates the current session. If the abort parameter is FALSE (0), the data server halts

any query that is executing and reinitializes itself.

The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes

noErr
rcDBError
rcDBBadSessID
rcDBAsyncNotSupp

0
—802
—806
-809

rcDBPackNotInited

-813

Retrieving

Execution has begun
Break or abort attempt was unsuccessful
Session ID is invalid
The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called

Results

The functions in this section allow you to retrieve a data item from the data server, to obtain
information about the next data item, and to retrieve the same data item more than once.
FUNCTION

DBGetItem

(sessID:

LongInt;

DBType;

VAR

asyncPB:

timeout:

LongInt;

len,places,flags:

DBAsyncParmB1lkPtr)

VAR

Integer;
:

dataType:
buffer:

Ptr;

OSErr;

The DBGetltem function retrieves the next data item from the data server. You can also use
this function to obtain information about the next data item without retrieving the data. You
can use the DBGetlItem function after you have executed a query and the DBState function
has returned the rcDB Value result code, indicating that data is available. You can repeat the
DBGetltem function as many times as is necessary to retrieve all of the data returned by the
data source in response to a query.
The sessID parameter is the session ID that was returned by the DBInit function.
You can use the timeout parameter to specify the maximum amount of time that the database
extension should wait to receive results from the data server before canceling the function.
Specify the timeout parameter in sixtieths of a second. To disable the timeout feature, set the
timeout parameter to the kDBWaitForever constant. If the timeout period expires, the
DBGetltem function returns the reDBBreak result code. The DBGetItem function ignores the
timeout parameter if you call the function asynchronously.

Data Access Manager Routines

8-63

i)
ga
a~

Inside Macintosh,

Volume VI

One use for the timeout parameter is to call the DBGetItem function periodically with a short
value set for this parameter in order to return control to your application while a query 1s
executing. Your application can then retrieve the next data item as soon as execution of
the query is complete without having to call the DBState function to determine when data
is available.
You can set the dataType parameter to specify the data type that you expect the next data item
to be. If the item is not of the expected data type, the database extension returns the
rcDBBadType result code. If you want to retrieve the next data item regardless of type, set
the dataType parameter to the typeAnyType constant. To skip the next data item, set the
dataT ype parameter to the typeDiscard constant. The data server sets the dataT ype parameter
to the actual type of the data item when it retrieves the data item or returns information about
the data item. Data types are discussed in “Getting Query Results” earlier in this chapter.
Set the len parameter to the length of the data buffer pointed to by the buffer parameter. If you
use the DBGetItem function to obtain information only (by setting the buffer parameter to
NIL), then the data server ignores the len parameter. The data server sets the len parameter to
the actual length of the data item when it retrieves the data item or returns information about
the data item.
The data server returns in the places parameter the number of decimal places in data items of
types typeMoney and typeDecimal. For all other data types, the data server returns 0 for the
places parameter.
The buffer parameter is a pointer to the location where you want the retrieved data item to be
stored. You must ensure that the location you specify contains enough space for the data item
that will be returned. To determine the data type, length, and number of decimal places of the
next data item without retrieving it, specify NIL for the buffer parameter.
If the least significant bit of the flags parameter is set to 1, the data item is in the last column
of the row. If the third bit of this parameter is set to 1, the data item is NULL. You can use
the constants kDBLastColFlag and kDBNullFlag to test for these flag bits.
The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes

noErr
rcDBNull

Q
—800

Noerror; no next data item
The data item was NULL

rcDBError

—802

retrieved
Execution ended in an error

rcDBBreak
rcDBBadSessID

—804
—806

Function timed out
Session ID is invalid

rcDBPackNotInited

-813

rcDB Value
rcDBBadType

rcDBAsyncNotSupp

8-64

—801

—803

-809

A nonzero data item was successfully
Next data item not of requested data type

The database extension does not support
asynchronous calls
The InitDBPack function has not yet been called

Data Access Manager Routines

°°)

The Data Access Manager

o

Ss

=

>,

>

2)
if)
oO

FUNCTION

DBUnGetItem

(sessID:

LongInt;

asyncPB:

2)
A

DBAsyncParmBlkPtr)

2
—

OSErr;

+)
1]

&

ve

@
Lar |

The DBUnGetltem function reverses the effect of the last call to the DBGetItem function,
in the sense that the next time you call the DBGetItem function it retrieves the same item a
second time. It does not remove the just-retrieved data item from the input buffer. The
DBUnGetltem function can reverse the effect of only one call to the DBGetItem function;
you cannot use it to step back through several previously retrieved data items.
The sessID parameter is the session ID that was returned by the DBInit function.
The asyncPB parameter is a pointer to the asynchronous parameter block. If you do not want
to call the function asynchronously, set this parameter to NIL.
Result codes
noErr

()

No error

rcDBError

—802

rcDBAsyncNotSupp

-809 _ The database extension does not support
asynchronous calls
-813
The InitDBPack function has not yet been called

rcDBBadSessID

rcDBPackNotInited

Installing and

—806

Error executing function

Session ID is invalid

Removing

Result

Handlers

The functions in this section install, remove, and return pointers to result handlers. Result
handlers are discussed in “Converting Query Results to Text” earlier in this chapter.
FUNCTION

DBInstallResultHandler

(dataType:

DBType;

isSysHandler:

theHandler:

Boolean)

:

ProcPtr;

OSErr;

The DBInstallResultHandler function installs a result handler for the data type specified by
the dataType parameter. The result handler is then used by the DBResultsToText function to
convert data of the specified type into a character string.
The parameter theHandler is a pointer to the result handler. The isSysHandler parameter
specifies whether the result handler is an application result handler—to be used only when the
DBResultsToText function is called by the application that installed the result handler—
or a system result handler—to be used by every application running on the system. If the
isSysHandler parameter is TRUE, the result handler is a system result handler.
When you install an application result handler, it replaces any result handler with the same
name previously installed by that application. Similarly, when you install a system result
handler, it replaces any existing system result handler with the same name. Before you
temporarily replace an existing result handler, use the DBGetResultHandler function to obtain
a pointer to the present handler, and save the present result handler in your application’s
private storage. Then you can reinstall the original result handler when you are finished using
the temporary one.

Data Access Manager Routines

8-65

Inside Macintosh,

Volume VI

Because an application result handler is used in preference to a system result handler if both
are available, you can temporarily replace a system result handler for purposes of your
application by installing an application result handler for the same data type. You can then use
the DBRemoveResultHandler function to remove the application result handler and return to
using the system result handler whenever you wish.
Result codes
noErr
rcDBPackNotlnited
FUNCTION

0
—813

No error
The InitDBPack function has not yet been called

DBGetResultHandler

(dataType:

DBType;

getSysHandler:

VAR

theHandler:

Boolean)

:

ProcPtr;

OSErr;

The DBGetResultHandler function returns a pointer to a result handler for the data type
specified with the dataType parameter. The pointer is returned in the parameter theHandler.
If you set the getSysHandler parameter to FALSE (0), the function returns a pointer to the
current application result handler for the specified data type, or it returns NIL if there is no
application result handler for that data type. If you set the getSysHandler parameter to TRUE

(nonzero), the function returns a pointer to the current system result handler for the specified

data type, or it returns NIL if there is no system result handler for that data type.

You can use this function to obtain a pointer to a result handler so that you can use
it to convert to text an individual data item retrieved by the DBGetlItem function. The
DBGetQueryResults function automatically converts to text all of the data pointed to
by the results record.
Result codes
noErr
rcDBNoHandler
rcDBPackNotInited
FUNCTION

—811

Q

-813

DBRemoveResultHandler

Noerror
There is no handler for this data type installed
for the current application
The InitDBPack function has not yet been called
(dataType:

DBType)

:

OSErr;

The DBRemoveResultHandler function removes from memory the application result handler
for the data type that you specify with the dataType parameter. This function cannot remove a
system result handler.
Result codes
noErr
rcDBNoHandler
rcDBPackNotInited

8-66

—811

O

-813

No error
There is no handler for this data type installed
for the current application
The InitDBPack function has not yet been called

Data Access Manager Routines

o )

The Data Access Manager

pat)
as
pa)
>
C
©
o&

SUMMARY

OF THE

DATA

ACCESS

#2)
if 4)

MANAGER

4
emt

an
f)
——_
a=)
tio

a)
or}

Constants
{DBStartQuery

status

messages}
FWD PR

kDBAboutToInit

kDBInitComplete
kDBSendComplete

{DBGetQueryResults

Mm

kDBExecComplete
kDBStartQueryComplete
status

‘

{DBInit

has

completed}

’

{DBSend

has

completed}

;
a

.
‘
.
’

{DBExec has completed}
{DBStartQuery
is about

types}
0;

{can

be

typeNone
typeBoolean

‘none';

{no

more

'HooL' ;

{Boolean}

typeSMIint

'snor' }
"long" ;

=

i

typeAnyType

typeInteger
typeSMFloat

‘Sing’;

any

{short

type}

expected}

floating

'date';
‘time';

{date}

‘tims';

{date

typeChar

Bidbi.
Gl Rea

{character}

typeDecimal

'deci';

{decimal

typeMoney

‘mone';

{money

typeVvChar

point}

point}

{time}
and

time}

number}
value}

'vcha';

{variable

character}

typeVBin

'vbin';

{variable

binary}

typeLChar

‘lena;

{long

character}

{long

binary}

typeLBin

‘Tan!

typeDiscard

‘aise

typeUnknown
typeColBreak
typeRowBreak

'unkn';
‘colb';
'rowb';

kDBLastColFlag
kDBNullFlag
noErr

rcDBValue
rcDBError
rcDBExec

's

{discard next
data
item}
{result
handler
for unknown
{result

{result

handler

$0001;
$0004;
0;

-801;
-802;

~805;

for

handler

{infinite

kDBWaitForever

complete}

{short integer}
{integer}

‘'doub';

typeTime
typeTimeStamp

data

data

{floating

typeFloat
typeDate

to

messages}
= 6;
{DBGetItem has completed}
{DBGetQueryResults
has completed}
= 7;

kDBGet ItemComplete
kDBGetQueryResultsComplete
{data

‘

{update windows}
{about
to call DBInit}

0;

kDBUpdatewind

il

CONST

for

timeout

item

is

last

{data

item

is

NULL}

{no

error;

ready

end

column

for

more

type}

break}

of

value

{data

data

column

line}

for
of

DBGetItem}
the

row}

text}

{output
data available}
{execution
ended
in an error}
{busy;
currently
executing
query}

Summary of the Data Access Manager

8-67

Inside Macintosh, Volume VI

Data
TYPE

Types
DBType

=

OSType;

DBAsyncParamBlockRec
RECORD
completionProc:
result:

{data

type}

=

userRef:

Longint;

{pointer to completion routine}
{result of call}
{reserved for use by application}

ddevRef:

Longint;

{reserved

for

use

by

database

Longint

{reserved

for

use

by

Data

reserved:

ProcPtr;
OSErr;

extension}

Access

Mgr}

END;

DBAsyncParmB1kPtr
QueryArray

=

“DBAsyncParamBlockRec;

ARRAY[0..255]

OF

Handle;

QueryListPtr = “QueryArray;
QueryListHandle
“QueryListPtr;
ResListElem

=

RECORD
theType:
id:

{resource
{resource

ResType;
Integer

type}
ID}

END;

ResListArray
ResListPtr =

ARRAY[0..255]
“ResListArray;

ResListHandle
QueryPtr

=

=

OF

ResListElem;

“ResListPtr;

“QueryRecord;

QueryHandle

=

“QueryPtr;

QueryRecord
RECORD

version:
id:

Integer;

{query

{resource

queryProc:

Integer;
Handle;

{handle

to

ddevName:

Str63;

{name

of

database

host:

Str255;

{name

of

host

user:

Str255;

{name

of

password:

{user's

connStr:
currQuery:

Stx255;
Str255;
Integer;

numQueries:
gqueryList:

Integer;
QueryListHKandle;

{number of queries}
{handles to queries}

numRes:

Integer;

resList:

ResListHandle;

{number of resources}
{list
of resources}

dataHandle:
refCon:

Handle;
Longint

END;

Summary of the Data Access Manager

record
ID

format
of

version}

'qrsc'}

qdef}

extension}

computer}

user}
password}

{connection
{current

{handle
{reserved

string}

query}

to

memory

for

for

by

use

qdef}
app}

\o
—

The Data Access Manager

ResultsRecord
RECORD
numRows:

Integer;

{number

of

rows

numCols:

Integer;

{number

of

columns

colTypes:

ColTypesHandle;

colData:
colinfo:

Handle;
ColInfoHandle

{type

of

data

2
&—
—
a
==)
ve

retrieved}
in

per
each

row}

er

column}

{array of data items}
{info about each data

END;

item}

ColTypesPtr
= “ColTypesArray;
ColTypesHandle
= “ColTypesPtr;
=

ARRAY[0..255]

DBColiInfoRecord

OF

DBType;

=

RECORD

len:

Integer;

{length

of

places:

Integer;

{places

for

{
flags:

data

{flags

Integer

data

item}

decimal

and

money

}

items}

for

data

item}

END;
ColinfoPtr
= *“ColInfoArray;
ColInfoHandle
= “*ColiInfoPtr;
ColiInfoArray

=

ARRAY[0..255]

OF

DBColInfoRecord;

Routines

Initializing the Data Access
FUNCTION

InitDBPack

High-Level
FUNCTION

+=)

2)
<)
oO
a
77)

=

ColTypesArray

\ew/
at
tf

Interface:

DBGetNewQuery

Manager

OSErr;

Handling
(queryID:

Query

Documents

Integer;

VAR

query:

QueryHandle)

OSErr;
FUNCTION

DBDisposeQuery

(query:

FUNCTION

DBStartQuery

(VAR sessID:
LongInt;
ProcPtr;
statusProc:
DBAsyncParmB1kPtr)

QueryHandle)

OSErr;
query:
QueryHandle;
asyncPB:
OSErr;

Summary of the Data Access Manager

8-69

Inside Macintosh, Volume VI

Interface:

High-Level
FUNCTION

DBGetQueryResults

Handling

Query

Results

(sessID:

LongInt;

VAR

timeout:

LongInt;

DBAsyncParmBlkPtr)
FUNCTION

DBResultsToText

(results:

ResultsRecord;

results:

statusProc:

:

ProcPtr;

asyncPB:

OSErr;

ResultsRecord;

VAR

theText:

Handle)

OSErr;

Low-Level
FUNCTION

Interface:

DBInit

Controlling

the Session

(VAR sessID:
LongInt;
ddevName:
user,password,connStr:
Str255;
DBAsyncParmBlkPtr)

FUNCTION

DBEnd

(sessID:

:

Str63;
host,
asyncPB:

OSErr;

LongInt;

asyncPB:

DBAsyncParmBlkPtr)

LongInt;

sessNum:

Integer;

OSErry
FUNCTION

DBGetConnInfo

(sessID:

returnedID,version:
Str63;

VAR

LongInt;

VAR

VAR

ddevName:

host,user,network,connStr:

Str255;

VAR start:
LongInt;
VAR state:
OSErr;
asyncPB:
DBAsyncParmBlkPtr)
: OSErr;
FUNCTION

FUNCTION

DBGetSessionNum

DBKill

Low-Level

Interface:

(sessID:

LongiInt;

VAR

sessNum:

asyncPB:

DBAsyncParmBlkPtr)

(asyncPB:

DBAsyncParmBlkPtr)

Sending

and

Executing

DBSend

(sessID:

Longint;

text:

FUNCTION

DBSendItem

(sessID:

Longint;

dataType:

Integer;

DBAsyncParmBlkPtr)
DBExec

(sessID:

Ptr;

:

OSErr;

len:

Integer;

DBType;

len,

DBAsyncParmBlkPtr)

places,flags:

FUNCTION

:

OSErr;

Queries

FUNCTION

asyncPB:

Integer;
:

: OSErr;

buffer:

Ptr;

asyncPB:

OSErr;

LongiInt;

asyncPB:

DBAsyncParmBlkPtr)

LongInt;

asyncPB:

DBAsyncParmBlkPtr)

LongInt;

VAR

OSErr;
FUNCTION

DBState

(sessID:
OSErr;

FUNCTION

DBGetErr

(sessID:

errl,err2:

iteml,item2,errorMsg:
DBAsyncParmBlkPtr)
FUNCTION

DBBreak

(sessID:

LongInt;

DBAsyncParmBlkPtr)

8-70

Summary of the Data Access Manager

:

Str255;

asyncPB:

OSErr;

abort:
:

LongiInt;

Boolean;

OSErr;

asyncPB:

VAR

oo

The Data Access Manager

Low-Level Interface: Retrieving Results
FUNCTION

DBGetItem

(sessID:

LongInt;

timeout:

DBAsyncParmBlkPtr)
DBUnGetItem

Installing and
FUNCTION

(sessID:
LongiInt;
; OSbrr:

Removing

:

(dataType:

DBType;

DBGetResultHandler

(dataType:

DBRemoveResultHandler

Application-Defined
FUNCTION

MyStatusFunc

(dataType:

theHandler:

DBType;

:

VAR

theHandler:

Boolean)

DBType)

:

:

ProcPtr;

OSErr;

OSErr;

Routines
(message:

Integer;

dataType:
MyResultHandler

ProcPtr;

OSErr;

result:

OSErr;

dataLen,dataPlaces,dataFlags:

FUNCTION

a

DBAsyncParmBlkPtr)

Boolean)

getSysHandler:
FUNCTION

VAR
flags:

OSErr;

asyncPB:

isSysHandler:
FUNCTION

LongInt;

len,places,
asyncPB:

Result Handlers

DBInstallResultHandler

Integer;

DBType;

dataPtr:

Ptr)

(dataType:

DBType;

theLen,thePlaces,theFlags:

Integer;

theData:

Ptr;

theText:

:

Boolean;

Handle)

OSErr;
FUNCTION

MyQDef

(VAR

sessID:

LongInt;

query:

QueryHandle)

OSErr;

Result

Codes

noErr
userCanceledErr
rcDBNull
rcDBValue
rcDBError
rcDBBadType
rcDBBreak
rcDBExec
rcDBBadSessID
rcDBBadSessNum_
rcDBBadDDev

0
—128
—800
-801
—802
—803
—804
—805
—806
—-—807
—808

A

>

“

dataType:
DBType;
VAR
Integer;
buffer:
Ptr;

FUNCTION

=)

No error
User canceled the query
The data item was NULL
Data available or successfully retrieved
Error executing function
Next data item not of requested data type
Function timed out
Query currently executing
Session ID is invalid
Invalid session number
Couldn’t find the specified database extension, or
error occurred in opening database extension

Summary of the Data Access Manager

8-71

Inside Macintosh,

Volume

VI

rcDBAsyncNotSupp —809
rcDBBadAsynchPB
rcDBNoHandler

-810
-811

rcDBWrongVersion
rcDBPackNotInited

—812
—813

Assembly-Language

The database extension does not support
asynchronous calls
Invalid parameter block specified
There is no handler for this data type installed
for the current application
Wrong version number
The InitDBPack function has not yet been called

Information

Asynchronous

Parameter

completionProc
result
userRef
ddevRef
reserved

long
word
long
long
long

Block

Query

long
word

Record

Data

version
id
queryProc
ddevName
host
user
password
currQuery
numQueries
queryList
numRes

word
word
long
64 bytes
256 bytes
256 bytes
256 bytes
word
word
long
word

dataHandle
refCon

long
long

resList

Results
numRows
numCols
colTypes
colData
colLens

8-72

long

Record

Data
word
word
long
long
long

Structure

pointer to completion routine
result of call
for application’s use
for database extension’s use
for internal use

Data Structure for Resource
theType
id

Data

List in Query

Record

resource type
resource ID

Structure
version
ID of 'qrsc' this came from
handle to query def proc
database extension name
host
user
—_ other connection info
current query
number of queries in query list
handle to list of queries
number of resources in resource list

handle to list of other resources
data used by query def proc
query’s reference value

Structure
number of rows in result
number of columns per row
data type array
actual results
length array

Summary of the Data Access Manager

o )

The Data Access Manager

=;
=

_

=

>

Trap

Macros

Requiring

Routine

O°
er)
ig")

wn

Selectors

wn

ea
—

&
~
&
ge

_Pack13

Cc

ar

Selector
$0100

$020E

$0210

$0215

Routine
InitDBPack

DBKill

DBDisposeQuery

DBRemoveResultHandler

$030F

DBGetNewQuery

$0408
$0409
$040D
$0413
$050B
$0514

DBExec
DBState
DBUnGetltem
DBResultsToText
DBBreak
DBInstallResultHandler

$0605
$0706

DBGetSessionNum
DBSend

$0403

$0516

$0811
$0A12
$0B07

$OE02
SOEOA

$100C
$1704

DBEnd

DBGetResultHandler

DBStartQuery
DBGetQueryResults
DBSendItem
DBInit
DBGetErr

DBGetlItem

DBGetConnInfo

Summary of the Data Access Manager

8-73

Inside Macintosh,

8-74

Volume VI

\©

THE

FINDER

INTERFACE

About This Chapter
About the Finder Interface
Finder-Related Resources
Creators, File Types, and the Signature Resource
Icon Resources
File Reference Resources
The Bundle Resource
The Size Resource
Messages When the Finder Can’t Find Your Application
Version Resources
How and When the Finder Launches Your Application
Finder-Related Changes to the User Interface
Stationery Pads
Edition Icons
Customized Icons
Aliases
Resolving Alias Files
Desk Accessories
Fonts, Sounds, and Other Movable Resources
Balloon Help for Icons
Finder Information in the Volume Catalog
The System Folder and Its Related Directories
Folder Organization
Finding Directories
The Desktop Database
History of the Desktop Database
Using the Desktop Database
Desktop Manager Routines
Locating and Opening the Desktop Database
Reading the Desktop Database
Adding to the Desktop Database
Deleting Entries From the Desktop Database
Manipulating the Desktop Database Itself
Summary of the Finder Interface

es J
2
—
~
lon
—

@
_

—
_
~

‘

eet

‘<”)
=“
=
as
~
O°
ra)

Inside Macintosh,

9-2

Volume VI

The Finder Interface

ABOUT

THIS

CHAPTER

The Finder™ is an application that works with the system software to manage the user’s

desktop display. This chapter describes how your application interacts with the Finder.
This chapter replaces the Finder Interface chapters in Volumes III and IV.
Read this chapter to learn how to
m set up the resources the Finder needs to display and start up your application
m= make your application compatible with the new interface features of the Finder
m use the new organization of the System Folder and its related directories
m check or change Finder-related information stored in a volume’s catalog
m read a volume’s database of icons, applications, and comments

To use this chapter, you should already be familiar with resources. Resources are collections
of data—such as menus, icons, and dialog box messages—and the code used by an application or by the system software. The Resource Manager chapter in Volume I introduces
resources, and the Resource Manager chapters in Volumes IV, V, and VI describe updates to
the Resource Manager.
This chapter does not explain how to use Apple® events to communicate with the Finder.
When a user opens or prints a file from the Finder, the Finder sends your application information so that your application can open or print the file. In system software version 7.0,
applications that support high-level events receive this information through the required
Apple events.
Refer to the Apple Event Manager chapter in this volume for instructions on how your application should respond to the required Apple events: Open Application, Open Documents, Print
Documents, and Quit Application. By supporting these Apple events, your application can take
advantage of the more reliable launch and termination mechanisms built into system software
version 7.0. In addition, your application can use another set of Apple events—called Finder
events—to request services from the Finder. For example, your application can ask the Finder
to perform such operations as launching another application on your behalf. See the Apple
Event Registry for the definitions of Finder events that your application may wish to support.

ABOUT

THE

FINDER

INTERFACE

The Finder is an application that manages the user’s desktop interface. It displays icons representing your application and the documents it creates, and it tracks user activity on the desktop.
When appropriate, the Finder starts up your application and tells it what documents to open or
print. To perform these tasks, the Finder relies on information you provide through resources.
When the user creates or installs a file, the File Manager initially stores some of this information in the volume catalog; the Finder extracts this information from the catalog and builds a
About the Finder Interface

9-3

Inside Macintosh,

Volume VI

desktop database for quick access to your resource information. This chapter describes how to
create the resources the Finder needs to build its desktop database, and how to gain access to
relevant data in the catalog and the desktop database. This chapter also discusses other Finderrelated information that could be of interest to you.
Like the rest of the Macintosh® computer’s system software, the Finder has become both
more powerful and more complicated since it was first released. The Finder includes a number
of new user interface features that have a small impact on applications.
The original desktop display was designed for a black-and-white monitor. In system software version 7.0, you can provide the Finder with color versions of your icons. You can also
define what the small versions of your icons should look like. (Before version 7.0, the
Finder scaled icons to half size.)

If your application supports the new stationery pad, Edition Manager, or Data Access Manager
features, you can create icons that distinguish the stationery pads, editions, or query documents
that users create with your application. You might also like your application to take advantage
of customized document icons. If, instead of producing an application, you produce and
distribute information documents (such as database files, stationery pads, query documents,
clip art libraries, or dictionaries) to be used by other applications, you can also provide icons
that distinguish your documents.
To take advantage of the new stationery pad feature when opening a document from the
Standard File Package, your application should check a Finder flag for the document to
determine if the document is stationery.
If your application bypasses the Finder or the Standard File Package when opening files of
any type, it should use the ResolveAliasFile function to open the correct file.
Users of system software version 7.0 no longer utilize the Font/DA Mover for installing
fonts, desk accessories, or other system resources. If you’re thinking about producing desk
accessories, you should probably create small applications instead because there will be little
distinction to users between desk accessories and applications. If you plan to produce fonts,
sounds, keyboard layouts, or script system resource collections, you need to provide them to
users as movable resource files; users of version 7.0 can install them by dragging their icons
to the System Folder icon instead of using the Font/DA Mover.
Users of system software version 7.0 have access to on-line assistance in the form of help
balloons. You can customize the help balloon that system software displays for your application icon.
In version 7.0, the System Folder contains a set of folders for storing related files. If your
application needs to store a file in the System Folder, put it in one of the new directories
described in this chapter. The Toolbox provides a new function, FindFolder, to help your
application utilize this new organization.
For each volume, the system software has always maintained a central database of informa-

tion used by the Finder. In version 7.0, that database is available to your application through
a set of Desktop Manager routines.
An important function of the Finder is to start up your application whenever the user opens it
from the Finder and whenever the user asks to open or print a document that has been created
by your application. “Messages When the Finder Can’t Find Your Application” later in
this chapter describes what happens when the Finder can’t find your application.
9-4

About the Finder Interface

The Finder Interface

Macintosh system software originally ran only one application at a time. System software
version 7.0 lets users run multiple applications simultaneously. (In previous versions of
system software, the MultiFinder® option provided this feature.) Your application is now
expected to provide the Finder with the information it needs to manage your application in a
shared-memory environment, as explained in the Compatibility Guidelines and Event Manager
chapters of this volume.
To help you make the best use of the Finder, this chapter
= describes the resources that the Finder uses to extract information about your application and documents (Generally, all applications should provide these resources for
their files.)
m introduces the new Finder features that might affect your application (Generally,
most applications should take advantage of some or all of these new features.)
m details the Finder information structure stored in a volume’s catalog (Generally,
most applications need to determine—and many might wish to set—information in
the catalog.)
m describes the new directories typically located in the System Folder and tells you how to
access them (Generally, many applications will want to access these new folders.)
m explains how to gain access to a volume’s database of icons, applications, and comments
(Generally, very few applications need to access this information because the Finder
maintains and displays it.)

FINDER-RELATED

RESOURCES

The Finder needs quick access to some key information about your application, including its
signature and the icons to display for it and for the documents it creates. You supply most of
this information in the resource fork of your application file.
The Finder extracts this information and uses it to maintain its own central database of the
resources it needs. The Finder records the location of your application on disk in this database so that it can find your application quickly when the user opens one of your documents.
For compatibility with the Finder, your application should have
m a signature resource, so that the Finder can identify and start up your application when a
user double-clicks documents created by your application
m aset of icon resources, to visually represent for the user your application and any
documents it creates
m aset of file reference resources, to link icons with the files types they represent and
to allow users to launch your application by dragging document icons to your application icon
m a bundle resource, to group together your application’s signature, icon, and file
reference resources
Finder-Related Resources

9-5

=
le 5)
—

o>)
=
@
|
=~

=oo

2)
ex |
ae
a

°
@

Inside Macintosh,

Volume

VI

m a size resource, to tell the Finder how much memory to allocate for your application
when it starts up and whether your application supports various system software
features
w either a name string resource in your application’s documents (to display the name
of your application if the user tries to open or print a document created by your
application when your application is missing) or a message string resource in your
application’s documents (to explain why the user can’t open or print a document used
by your application)
Note: Supply a name string resource for documents that you intend for users to
open with your application; supply a message string resource for documents (such as
a preferences file) that your application uses but which users shouldn’t open. You
supply only one of these resources in a document—never both.
Your application can also make use of these resources:
m

version resources, so that users can easily find out the version of your application and,
if applicable, the version of your application’s superset of files

a ahelp resource, which the Finder uses to display your customized Balloon Help 'M
message for your application, control panel, system extension, or desk accessory icon
If you sell or distribute data in the form of a document to be used by other applications, you
can assist users by providing
m an appropriate file type to allow users to open your document from the Finder by
dragging its icon to an application icon or by choosing the Open command from the
File menu within an application
m a family of icon resources to represent your document to the user
m aname string resource or message string resource, so the Finder can assist users who
try to open or print your documents from the Finder
m version resources, so that users can easily find out the version of your application and,
if your application file is one of a larger collection of files, the version of the entire
superset of files
These resources are described in the following sections.

Creators,

File Types,

and

the Signature

Resource

The Finder identifies your application through its signature, a unique, four-character
sequence. The signature must not conflict with the signature of any other application. To
ensure uniqueness, you must register your application’s signature with Apple Computer,
Inc. at Macintosh Developer Technical Support.
Note: There is no need to register your own resource types because they’re usually
used in your own applications or documents only.

9-6

Finder-Related Resources

The Finder Interface

You must include in your resource file a special resource that has the application’s signature
as Its resource type. By convention, the signature resource has a resource ID of 0. The
signature resource typically contains a string that specifies the name, version number, and
release date of your application. If you do not provide specific version information through a
'vers' resource (described in “Version Resources” later in this chapter), the Finder displays

the string stored in the signature resource when the user selects your application and chooses
Get Info from the File menu.
The following sample code illustrates a signature resource in Rez input format. (Rez is the
resource compiler provided with Apple’s Macintosh Programming Workshop [MPW®],

available from APDA®.)
type

'WAVE'

resource

as

'STR

'WAVE'

(0,

"MyApplication

';
purgeable)
2.0

©

1991"

{

/*

WAVE

is

the

/*

resource

ID

/*

default

Get

signature
is
Info

0

*/

*/
string

*/

ye

Note: The signature resource alone is not sufficient to fully establish your
application’s signature. You must also supply a bundle resource, described in
“The Bundle Resource” later in this chapter.
Whenever your application creates a document, it assigns the document a creator and a file
type. Typically, as described in “Finder Information in the Volume Catalog” later in this
chapter, your application sets its signature as the document’s creator. When a user doubleclicks a document or selects it and chooses Open or Print from the Finder’s File menu, the
Finder reads the creator field of that file to find the document's creator. The Finder then
searches for an application with a signature by that name. When it finds that application, the
Finder launches that application.
If the document’s creator is your application’s signature, for example, the Finder calls the
Process Manager to start your application. The Finder sets up the information your application needs to open or print the document. In version 7.0, applications that support high-level
events (that is, have the isHighLevelEventAware flag set in the 'SIZE' resource) receive the
Finder information through Apple events. The Apple Event Manager chapter in this volume
describes how your application processes Apple events to open or print files.
Applications that do not support high-level events can use the CountAppFiles, GetAppFiles,
and ClrAppFiles procedures or the GetAppParms procedure to get the Finder information.
See the Segment Loader chapter of Volume II for information on these routines.
As described in “Finder Information in the Volume Catalog” later in this chapter, your application typically assigns a file type to a document when it creates one. The file type can be a
type especially defined for your application, or it can be one of the existing general types,
such as those listed here.
File
type

Description

"APPL'
'DFIL'
'DRVR'

Launchable application
File for storing desk accessories
Driver
Finder-Related Resources

9-7

=)

co

ate

—
me
lm)
—

@
ox |

5
ry

_—

=}

ac)

Lew

°
o

|

Inside Macintosh,

Volume VI

File
type

Description

"FEIL
‘INIT'

File for storing fonts
System extension

'PRER'
'"RDEV'
'TEXT'
'adev'
‘appe’
'‘cdev'
‘edtp'
‘edts'
‘edtt’
fil’
"i fil’
‘kfil’
‘pref’
‘gery’
‘sexr
'sfil'

Printer driver
Chooser extension
Stream of ASCII characters
Network extension (like EtherTalk® 2.0)
Background-only application
Control panel
Edition for sharing graphics-oriented data
Edition for sharing sound-oriented data
Edition for sharing text-oriented data
Font
Script system resource collection
Keyboard layout
Preferences file
Query document for database access
System extension for script systems
Sound

"PICT"

'tfil’

'ttro'
Zsys'

QuickDraw™ picture

TrueType™ font

TeachText read-only file
A system file (such as the System file itself)

Note: Apple reserves the use of all signatures and file types whose names contain
only lowercase and nonalphabetic characters. Your signature and the file types created
especially for your application must contain at least one uppercase character. Since
the system software never displays signatures and file types to users, signatures and
file types can consist of character combinations that are incomprehensible to anyone
but you.
Like signatures, file types must be registered with Apple. Your application must have a file
type of 'APPL’. The creator field of your application file should contain its own signature.
Most programming environments provide a simple tool for setting the creator field of your
application file.
Your application can create documents of any type, and it can specify any application as
the creator. You could write a utility application, for example, that creates a new document
by opening one text file and appending onto it another text file. The application would
give the new document the same creator as the first original text file so that the Finder can
call on that application when the user wants to open or print the new document.
Assign the standard file type 'TEXT' to files that consist only of text—that is, a stream of
characters with return characters at the ends of paragraphs. Most word processors allow the
user to create text-only files. A document of file type "TEXT" can be opened or printed by
any application that accepts such file types. Your application can still assign its own signature
as the file’s creator so that the Finder can call on it to open or print the file when appropriate.
Users can also open a document created by your application—as well as a document of a file
type supported by your application—by selecting its icon and dragging it to your application’s icon. Because the document’s file type is stored in the catalog and the Finder stores a
9-8

Finder-Related Resources

The Finder Interface

list of your application’s supported file types in the desktop database, the Finder can determine whether to launch your application. If the document’s file type is supported by your
application, the Finder launches your application and passes it the name of the document.
(These topics are detailed in subsequent sections of this chapter.)
For example, if your application is a page layout program, it might create documents of its own
file type while also supporting documents of "TEXT' and 'PICT' file types. A user can launch
your application by dragging a document of any of these file types to your application icon.
Your application also relies on file types to determine which files to let the user open when
your application is running. When your application calls the Standard File Package to open
a file, your application supplies either a list of the file types that your application can open
or a filter function for those types. The open file dialog box then displays only files of the
specified types. (See the Standard File Package chapter in this volume for details.)

Icon

Resources

The Finder represents your files as icons. To distinguish your product on the desktop, you
can design your own icons for all the files associated with your application, including
m your application file itself
m standard documents created by your application
m stationery pads that users create from your application’s documents
a data-sharing editions that users create from your application’s documents
m other special documents, such as read-only, graphics, and query documents, which
are either created by your Macintosh application or provided by you for use by other
Macintosh applications
For most effective display, you should create an icon family for each of your files. An icon
family is the set of icons that represent a single object, such as an application or document,
on the desktop. An entire icon family consists of
m a large (32-by-32 pixel) black-and-white icon and mask (resource type 'ICN#')
= asmall (16-by-16 pixel) black-and-white icon and mask (resource type ‘ics#')
m a large (32-by-32 pixel) color icon with 4 bits of color data per pixel
(resource type ‘icl4')
mw asmall (16-by-16 pixel) color icon with 4 bits of color data per pixel
(resource type ‘ics4')
m a large (32-by-32 pixel) color icon with 8 bits of color data per pixel
(resource type ‘icl8')

= asmall (16-by-16 pixel) color icon with 8 bits of color data per pixel
(resource type ‘ics8’)

Finder-Related Resources

9.9

Inside Macintosh,

Volume V1

If you do not design your own icons, the Finder uses a set of its own default application and
document icons for display. Figure 9-1 shows the Finder’s default large black-and-white
icons. Note that the Finder in system software version 7.0 also displays desk accessories
with icons.

@

Application

Oe

Document

Bo =

Query
document

Preference

Edition

a)
System
extension

Q

Stationery
pad

&
Desk
accessory

Figure 9-1. Default large black-and-white icons
If you don’t want the Finder to display the default icons for your application, desk accessory,
or documents, you must at least define an 'TCN#' resource (called an icon list) for each icon.
The two icons defined in the 'TCN#' resource are a 32-by-32 pixel, black-and-white icon and
its mask. You can also define color and 16-by-16 pixel icons in other resources described in
this section. (If you don’t define color icons, the Finder displays the black-and-white icon
defined in your 'ICN#' resource on all displays, and if you don’t define 16-by-16 pixel icons,
the Finder algorithmically reduces the 32-by-32 pixel icon to half size when needed.)
An 'ICN#' resource defines one desktop icon. It contains two icon descriptions: the actual
icon for display on the desktop and an all-black mask that shows the area covered by the icon.
The Finder uses the mask to crop the icon’s outline into whatever background color or pattern
is on the desktop. The Finder then draws the icon into this shape. Therefore, it’s important
that the mask be exactly the same shape as the icon. The mask also defines the area that users
need to click to select the icon. Therefore, it’s best not to have any holes in the mask; otherwise, users may have trouble selecting your icon. Figure 9-2 shows an application icon and
its mask.

Figure 9-2, An application icon and its mask
An 'ICN#' resource is defined to be an array of String[128]. Typically, you use a high-level

tool like the ResEdit™ application, which is available through APDA, to create your 'ICN#'

resources. Figure 9-3 shows how the 'ICN#' resource for the icon and mask in Figure 9-2
was created using the ResEdit icon editor.
9-10

Finder-Related Resources

The Finder Interface
‘

S

o--

She

i °°

iE.

-

——

——

me
=

ill

DE ICN#s from Sur

Le
I> si

SurfWriter

Le |4
_
-]

—

7)

“

&

Icon Family 1D = 128 from Sur)

= j23

—

——

129

ual

o

Lau

r-4
3

“

@|6/8)
NWS
OOO |S

sate "teuere Ms

a8 88
G8 Be
Ge 8s
BE 8 oe
go
a
8
Ee

Hag

88
6

88

6

6

a

a

130

ac)

Fi

tov)
er)
@

131

8

Figure 9-3. The ResEdit view of an icon and its mask
When you are satisfied with the appearance of your icons, you typically use the DeRez
decompiler to convert your 'ICN#' resources into Rez input. Listing 9-1 is a partial listing
of the Rez input for the 'ICN#' resources shown in Figure 9-3. This listing and those that
follow in this chapter use Rez format to help you understand the format of the resources
and see how they work together.
Listing 9-1. 'I[CN#' resources for an application and its documents
resource

'ICN#'

(128,

{
S"00

Ti

B2

00"

$"00
'

00

OF

OO"

$"00

00

FF

00

$"00

00

OF

purgeable)

{

/*

application

icon

and

/*
/*

array:
2 elements */
first element:
the application

/*

each

/*

32

/*
/*

32nd line of icon
*/
second element:
the mask

*/

/*

32

*/

/*

32nd

O00"

line
lines

lines

line

holds
total

total

4

bytes

(32

for

icon

*/

for

of

mask

{

/*

text

goes

here

icon

mask

icon

bits)

*/

*/
*/

*/

}

};

resource

};

{
}

'ICN#'

(129,

/*

purgeable)

icon

data

document

icon

and

mask

*/

*/

(Continued)

Finder-Related Resources

9-]]

Inside Macintosh,

Volume VI

Listing 9-1. 'ICN#' resources for an application and its documents (Continued)
resource

'ICN#'

{
}

};
resource
{

}

(130,

/*

'ICN#'

purgeable)

icon

data

{/*

goes

stationery

here

document

icon

and

mask

*/

*/

(131, purgeable)
{/* edition
/* icon data goes here */

document

icon

and

mask

*/

You can also define a small (16-by-16 pixel) version of your icon in the 'ics#’ resource. The

Finder displays the small icon in windows when the user chooses by Small Icon from the
View menu. It also appears in the Application menu after the user launches your application
and in the Apple menu if the user places your application or an alias to it in the Apple Menu
Items folder. (Alias files and the Apple Menu Items folder are described, respectively, in
“Aliases” and “The System Folder and Its Related Directories” later in this chapter.)

You can define color versions of both large and small icons by using several resource types.

The resource for each icon variation has the same resource ID as the 'ICN#' resource that

defines the large black-and-white icon. For example, if the resource ID of your application

icon’s 'ICN#' resource is 128, its small black-and-white icon resource, 'ics#', should have
a resource ID of 128: and the ‘icl4', 'ics4', ‘icl8', and 'ics8’ resources should also have
resource IDs of 128.

Don’t define masks for your color icon resources. The 'icl4' and ‘icl8' resources use the
black-and-white icon mask defined in their companion '[CN#' resource, and the ‘ics4' and
‘ics8' resources use the black-and-white icon mask defined in their companion 'ics#' resource.
Because of this, the outline shapes of your color icons should exactly match those defined in
your 'ICN#' and 'ics#' resources.
ResEdit 2.1 includes an icon family editor to help you easily manage the creation of these
related resources. See the ResEdit Reference for details.
See the User Interface Guidelines chapter in this volume for information about the most
effective use of color and shape for your icons. Choose your colors from the 36 recommended icon colors in the system palette. (If you use ResEdit 2.1, these colors appear in a
palette when you choose Apple Icon Colors from the Color menu.) Note that you cannot
specify your own color table for these as you can with the 'cicn' resources described in the
Color QuickDraw chapter of Volume V.
For more information about color palettes, see the Graphics Overview, Color QuickDraw,
and Palette Manager chapters later in this volume. While the Palette Manager allows you to
define a palette for the system to use when it needs to define the color environment, you
should rely on the system palette colors for your icon family. Remember that users may often
use the Finder when your application is not running and that the user can switch to another
application when your application is running. Relying on the system palette gives your icons
a more consistent look in the Finder regardless of what the active application is. And because
users can change the desktop color and pattern, your application also gives users more
control over their work environment if your icons rely on the system palette. Users can
always alter your color definitions by selecting an icon and choosing a color from the Label
menu. The Finder then blends the chosen color into those of the selected icon. To restore the
original colors, users must choose None from the Label menu.
9-]2

Finder-Related Resources

The Finder Interface

If your application creates documents, it should also define at least two additional icon
families: one to be displayed for documents created by your application, and another to be
displayed when the user creates a stationery pad from one of your application’s documents.
(See “Stationery Pads” later in this chapter for a description of stationery pads.)
Your application might also define icons for other types of documents. If your application
supports data sharing through the Edition Manager, your application should also define an
icon family for editions. (For a description of edition file types, see “Edition Icons” later in
this chapter and the Edition Manager chapter of this volume.) If your Macintosh application is
a database program or serves as a source for data (as a spreadsheet program often does), you
might wish to create query documents so that other Macintosh applications can gain access to
that data through the Data Access Manager; in this case, your application should also define
an icon family for its query documents. (See the Data Access Manager chapter in this volume
for information on sharing data in this manner.)
If your application creates other variations of its documents, you can assist your users by
providing different icons for the different documents. For example, TeachText has separate
icon families to distinguish its read-only and graphics documents.
Figure 9-4 shows the large black-and-white icons for the various documents that the sample
SurfWriter application creates: text, stationery pad, and edition.

a] &) &
Text

Stationery
pad

Edition

Figure 9-4. Examples of document

icons

Defining icon resources is not enough to display your icons. In addition, you must follow
one of two sets of procedures:
=

If you are an application developer, you must define file reference resources and a
bundle resource for your application as described in the next two sections.

a If you are an information provider or database developer—that is, you provide documents that are used by other applications—you don’t need to create file reference
resources or a bundle resource to provide document icons on Macintosh computers
running system software version 7.0. You can instead create customized icons for your
documents as described in “Customized Icons” later in this chapter. (However, if you

want your document to appear with its own icons on earlier versions of system software, you must create a file reference resource and a bundle resource as described in
the next two sections. )

Note: In system software version 7.0, the Finder no longer uses the PlotIcon and
PlotCIcon procedures (described, respectively, in Volumes I and V) to draw icons.
If you use these procedures, note that they draw only those icons defined by 'ICN#'
and 'cicn' resources. These procedures will not draw any icons that are defined by
the icon resources new to system software version 7.0—namely, the ‘ics#', 'icl4',
‘ics4', 'icl8', and ‘ics8' resources.
Finder-Related Resources

9-13

=)

ery
—e
—
2

2.

oO
~

—

|

c—

o
a!
SS—
ro)
o

Inside Macintosh,

File

Volume VI

Reference

Resources

File reference (‘FREF') resources perform two main functions. First, they associate icons
you define with file types used by your application. Second, they allow users to drag
document icons to your application icon in order to open them from your application.
Create an 'FREF' resource for your application file itself and create separate 'FREF' resources
for each file type that your application can open. Listing 9-2 shows, in Rez input format, the
file reference resources for the SurfWriter application file, text documents, stationery pads,
and editions, and for TeachText read-only documents.
Listing 9-2. Using file reference resources
resource

'FREF'

'APPL',

0,

ig

purgeable)

{

/*

SurfWriter

application

/*

(208,
type

'APPL',

maps

to

'ICN#'

local

/*

leave

empty

string

for

w/

name:

not

ID

0

*/
in

implemented

'BNDL'

*/

*/

i
resource
'FREF'
'TEXT',
1,

/*

(209,
purgeable)
{
type
'TEXT',
maps

/*
to

SurfWriter
document
*/
'ICN#'
w/ local
ID 1 in

'BNDL'

*/

be
resource

'FREF'

'sEXT',

2,

(210,
/*

purgeable)

{

/*

SurfWriter

'sSEXT',

maps

to

'ICN#'

purgeable)

{

/*

SurfWriter

‘edtt',

maps

purgeable)

{

type

w/

stationery
local

pad

ID

2

in

edition

*/

*/
'BNDL'

*/

nu

ie
resource

'FREF'

‘edtt',

3,

(211,
/*

type

to

'ICN#'

w/

local

ID

3

in

'BNDL'

files

*/

*/

he
resource

'FREF'

‘ttro',
va

4,

(212,
/*

These

documents

/*

Finder

/*
/*

included here
SurfWriter's

uses

/*

TeachText

read-only

have

TeachText

as

TeachText's
so users
app icon

'ICN#'
can
*/

drag

for

their
these

these

creator.

*/

documents.

docs

to

*/

*/

i

Each 'FREF' resource specifies a file type and a local ID. The file type can be defined for
files created by your application only, for files created by other applications that your

application supports, or for files of the existing general types, such as "TEXT" or 'PICT".
As described in the next section, “The Bundle Resource,” the local ID maps the file type to an
‘ICN#' resource that is assigned the same local ID in the bundle. If you wanted two file types
to share the same icon, for example, you could create two separate 'FREF' resources that
share the same local ID, which the bundle would map to the same 'ICN#' resource. (Creating

9-14

Finder-Related Resources

The Finder Interface

two file types that share the same icon is not recommended, however, because a shared icon
would make it very difficult for the user to distinguish between the different file types on
the desktop.)

oo

rj

te
—

—~

ou
@
ms

—
_

If you provide your own icon for the stationery pads that users create from your application’s
documents, create an 'FREF' resource for your stationery pads. Assign this 'FREF' resource
a file type in the following manner: use the file type of the document upon which the stationery
pad is based, but replace the first letter of the original document’s file type with a lowercase s.
As with other 'FREF' resources, you map this to an 'l\CN#' resource in the bundle. (This
convention necessitates that you make the names of your documents’ file types unique in
their last three letters.) For example, in Listing 9-2, the 'sEXT' file type assigned within the
'FREF' resource is used for stationery pads created from documents of the 'TEXT'" file type.
In this case, when the isStationery bit (described in “Finder Information in the Volume
Catalog” later in this chapter) is set on a document of file type "TEXT’, the Finder looks in
the SurfWriter application’s 'BNDL' resource to determine what icon is mapped to documents
of type 'sEXT". The Finder then displays the document using the stationery pad icon shown
in Figure 9-4.
When the user drags a document icon to your application icon, the Finder checks a list of
your 'FREF' resources. If the document’s file type appears in the 'FREF' resource list,
the Finder launches your application with a request to open that document.
If your application supports file types for which it doesn’t provide icons, you can still
define 'FREF' resources for them, and then users can launch your application by dragging
these document icons to your application icon. For example, the 'FREF' resource with
resource ID 212 in Listing 9-2 is created so that the Finder launches the SurfWriter application when users drag TeachText read-only documents to the SurfWriter application icon.
Since these documents have TeachText as their creator, the Finder displays the icon that the
TeachText application defines for them in its own bundle.
If your application supports the Open Documents event, you can also specify disks, folders,
and a wildcard file type for all possible files in your 'FREF' resources so that users can
launch your application by dragging their icons to your application icon. As explained in the
Apple Event Manager chapter, the Open Documents event is one of the four required Apple
events. After the Finder uses the Process Manager to launch an application that supports
high-level events, the Finder sends the application an Open Documents event, which includes
a list of alias records for desktop objects that the application should open.
Since alias records can specify volumes and directories as well as files, an Open Documents
event gives you the opportunity to handle cases where users drag disk or folder icons to your
application. Create an 'FREF' resource and specify ‘disk’ as the file type to allow users to
drag hard disk and floppy disk icons to your application icon. Create an 'FREF' resource and
specify ‘fold’ to allow users to drag folder icons to your application icon. Create an 'FREF'

resource that specifies '****' as the file type to allow users to drag all file types—including
applications, system extensions, documents, and so on, but not including disks or folders—
to your application icon. If you create three 'FREF' resources that specify ‘disk’, 'fold', and
"ee" as their file types and if your application supports the Open Documents event, you
effectively allow users to launch your application by dragging any desktop icon to your
application icon. It is up to your application to open disks, folders, or all possible file types in
a manner appropriate to the needs of the user.

Finder-Related Resources

9-15

—_

—_

@
“
eC)
AD
i)
te]

Inside Macintosh,

Volume VI

The

Resource

Bundle

A bundle is a resource that associates all of the resources used by the Finder for your appli-

cation; in particular, it associates your application and its documents with their icons. The
bundle resource (‘BNDL') contains

m the application’s signature and the resource ID of its signature resource (which should
always be 0)
w the assignment of local IDs to the resource IDs of all 'ICN#' resources defined for
the application
m the assignment, for compatibility reasons, of local IDs to 'FREF' resource IDs (For
consistency, these can be the same local IDs that are assigned inside the 'FREF'
resources, but they don’t have to be—they only need to be unique for every
'FREF'

resource.)

When the Finder first displays your application on the user’s desktop, it checks the catalog
(as described in “Finder Information in the Volume Catalog” later in this chapter) to see if
your application has a bundle. If it doesn’t, the Finder displays the default icons shown in
Figure 9-1. If your application has a bundle, the Finder installs the information from the
‘BNDL' resource and all its bundled resources into either the desktop database for a hard

disk or into the Desktop file for a floppy disk and uses this information to display icons for
the file types associated with your application.

You must assign local IDs to your 'ICN#' resources within your 'BNDL' resource. Make
sure that for all your file types with icons, these local IDs match the local IDs you assigned
inside their corresponding 'FREF' resources. In the Desktop file on floppy disks (and on

hard disks running earlier versions of system software), the Finder renumbers the resource

IDs that you’ve assigned to your resources to avoid conflicts with the resources of other
applications. Therefore, the bundle has to rely on these local IDs to map icon list resources
to their file reference resources; that is, the 'BNDL' resource uses the local ID you assign

to an 'I[CN#' resource to map it to the 'FREF' resource that has the same local ID assigned
inside itself.
For example, the 'FREF' resource with resource ID 208 in Listing 9-2 shows that the file
type 'APPL' (the SurfWriter application file) is assigned a local ID of 0. In the 'BNDL'
resource shown in Listing 9-3, you see that local ID 0 is assigned to the 'ICN#' resource
with resource ID 128. This maps the icon defined by this resource (see Figure 9-3) to the

SurfWriter application file. Listing 9-3 shows the bundle resource for the icons and 'FREF'
resources defined in Listings 9-1 and 9-2.
Listing 9-3. Using a bundle resource
resource

(128,

purgeable)

'WAVE',

'BNDL'

/*

SurfWriter

{

0,

/*

resource

ID

/*

mapping

local

/*

SurfWriter

signature
of

bundle

resource

ID

*/

*/

signature

resource:

should

be

0

*/

{
'ICN#',

IDs

in

'FREF's

to

'ICN#'

IDs

*/

{

9-16

0,

128,

/*

'‘FREF’

with

local

ID

0

maps

to

‘ICN#'

res

ID

128

*/

1,

129,

/*

'FREF'

with

local

ID

1

maps

to

'ICN#'

res

ID

129

*/

Finder-Related Resources

The Finder Interface
=

2,

130,

/*

'FREF'

with

3

134

/*

'FREF'

with

/*
/*

no ‘FREF' with local ID 4 in this
icons used for 'ttro'
TeachText's

local
local

ID
ID

2
3

maps
maps

to
to

'ICN#'
‘ICN#'

res
res

ID
ID

*/
list:
file type

130
131

*/
*/

—
~J

—

=

-)
ee

i)
“

*/

—

=—
o®

'FREF',
10,

/*
208,

local

resource

IDs

for

'FREF's:

no

duplicates

/*

local

ID

10

assigned

to

'FREF'

res

ID

208

L1,9209;;-/*

local

ID

11

assigned

to

'FREF"*

res

ID

209

*/

12,

210,

/*

local

ID

12

assigned

to

'FREF'

res

ID

210

*/

13,

211,

/*

local

ID

13

assigned

to

'FREF'

res

ID

211

*/

14,

212

/*

local

ID

14

assigned

to

'FREF'

res

ID

212

*/

=

*/

=

i)
@

*/

+

In Listing 9-3, notice that you also assign local IDs to 'FREF' resources inside the 'BNDL'
resource. This assignment is superfluous because the Finder doesn’t map these local IDs to
any other resources. The local ID assignment for 'FREF' resources inside the bundle was
implemented for the earliest versions of Macintosh system software, and it remains this way
today to maintain backward compatibility. For compatibility with the format of the 'BNDL'
resource, assign local IDs to 'FREF' resource IDs. You may number them any way you like,
except that each local ID in this particular list must be unique.
Of all the icon resource types that make up an icon family, you need to list only the 'ICN#'
resource in the 'BNDL' resource. The Finder automatically recognizes and loads all the other

members of the icon family.

If the user drags documents created by other applications to your application icon, and if you
have created 'FREF' resources for these documents’ file types, the Finder launches your
application and passes it the names of the documents. You should create 'FREF' resources
for all file types that your application supports. Do not provide icon resources for file types
created by other applications because the Finder won’t use them, but will instead use the
icon resources defined by the documents’ creators. Though the local IDs of such an 'FREF'
resource are superfluous in the 'FREF' resource and at the bottom of the 'BNDL' resource,
the resource formats require that you provide local IDs in both.
For example, notice in Listing 9-2 that the 'FREF' resource with resource ID 212 is assigned
a local ID of 4, but that no 'ICN#' resource 1s assigned to local ID 4 in the 'BNDL' resource
in Listing 9-3. This 'FREF' resource, which specifies a file type of 'ttro', was created in
Listing 9-2 to make the Finder launch the SurfWriter application when users drag TeachText
read-only documents to the SurfWriter application icon. No icon mapping is made for this file
type in the SurfWriter application’s bundle because the Finder displays the icons defined for
it by the TeachText application. The 'FREF' resource with resource ID 212 is assigned to
local ID 14 in the 'BNDL' resource in Listing 9-3 because the format of the resource requires
a local ID for all 'FREF' associated resources.
You alert the Finder that your application has a bundle resource by setting a bit in the
file’s Finder flags field. (Most development environments provide a simple tool for setting
the bundle bit. “Finder Information in the Volume Catalog” later in this chapter describes
Finder flags.)

Finder-Related Resources

9-]7

Inside Macintosh,

Volume VI

Figure 9-5 illustrates how the bundle resource created in Listing 9-3 uses local IDs to map
icon list resources to file reference resources.
‘BNDL'

resource

Application signature 'WAVE'

‘ICN#' resource

type
File
‘APPL!

' ICN#' ii(icon resource)

Resource ID Local ID
mapping
& 128 ——?%0

~d

Local ID
0
'FREF' resource
Resource ID

‘ICN#' resource

Al

resource

Resource ID

Signature resource ID 0

Resource ID
128

FREF'

209

*

File type

Resource ID
129

:
Resource ID Local ID
Mapping
Be 129 ——®%1

~<d

‘TEXT’
Local ID
1

'FREF' resource

‘ICN#' resource

Resource ID
210

File type

Resource ID

130

Resource ID Local ID

pe

130

——e2

mapping

<d

2

FREF'

'ICN#' resource

resource

Resource ID
211

:

;

'SEXT'
Local ID

;

Resource ID
131

Resource ID Local ID

—e

131

—e3

mapping

‘edtt'

<—

Local ID
3

Figure 9-5, Linking 'ICN#' and 'FREF' resources in a 'BNDL' resource
Figure 9-5 illustrates two main concepts: first, that one bundle ties together all the icon resources
and file reference resources for your application and all of its documents; and second, that the
icon resources and their associated file reference resources are mapped together by local IDs. In
Figure 9-5, the application file’s 'ICN#' resource has resource ID 128 while its 'FREF' resource
has resource ID 208. For maintainability, you should probably assign the same resource ID to a
file’s 'FREF' resource that you assigned to its 'ICN#' resource. However, because the Finder
renumbers these whenever it adds them to a Desktop file, you must map them by using local
IDs. In Figure 9-5, the application file’s 'ICN#' resource is assigned local ID 0. This maps the
icon to the file type described by the 'FREF' resource with local ID 0—in this case, the 'FREF'
resource with resource ID 208.
Figure 9-5 also illustrates the general steps you must take to provide icons for applications
and documents. These steps are enumerated here in more detail and assume that you are using
9-18

Finder-Related Resources

The Finder Interface

a tool, such as ResEdit, that allows you to open and edit several resources simultaneously.
(Remember that these resources must have resource IDs of 128 or greater.)

=}

=

eal
eS

os

@

To provide your application with icon families for itself and for its documents, follow
these steps:

=“
—

=)—
&

a
a=

1. Create an icon list (‘ICN#') resource for your application file.

&

©

2. Create the other members of the icon family of the application file—resources of types

‘ics#', 'icl8', 'icl4', 'ics8', and ‘ics4'—and give each of these the same resource ID as
the 'ICN#' resource.

3. Create a bundle (‘BNDL’) resource.

4. Within the bundle resource, list the resource ID of the application file’s 'ICN#' resource
and assign it a local ID of 0.
5. Create an 'FREF' resource for the application file.
6. Within the 'FREF' resource, assign the application a file type of 'APPL' and assign it a
local ID of 0.
7. Within the bundle resource, list the resource ID of the 'FREF' resource for the application file and assign it a unique local [D—for example, 0 to maintain consistency with
the local ID assigned in the 'FREF' resource.
8. Create another icon family—consisting of resources of types 'ICN#,' 'ics#', 'icl8',
‘icl4', ‘ics8', and 'ics4'—to represent one type of document that your application
creates.
9. Within the application’s bundle resource, list the resource ID of the document’s 'ICN#'
resource and assign it a local ID of 1.
10. Create an 'FREF' resource for the document.

11. Within the 'FREF' resource for the document, assign it a file type (for example,
'TEXT' or 'edtt') and assign it a local ID of 1.
12. Within the bundle resource, list the resource ID of the 'FREF' resource for the document and assign it a unique local [D—for example, | to maintain consistency with the
local ID assigned in the 'FREF' resource.
13. Assigning unique local IDs for every type of document your application creates, repeat
steps 8 through 12.
14. If your application supports file types of other applications, define 'FREF' resources
for them, but do not create icon resources for them.
15. Create a signature resource (as previously described in “Creators, File Types, and the
Signature Resource”) with resource ID 0; in it, set the creator to your signature.
16. Set the file’s hasBundle bit, and clear its hasBeenInited bit in the file’s Finder flags.
(Finder flags are described in “Finder Information in the Volume Catalog” later in
this chapter.)
17. Save and close all of the resources. (When your restart your Macintosh, the application should appear with its own icon. If you later alter any of your icons, clear the
hasBeenInited bit and rebuild your desktop database by pressing the Command-Option
keys when restarting.)
Finder-Related Resources

‘oe

9-19

.$°)

Inside Macintosh,

The

Size

Volume VI

Resource

The 'SIZE' resource tells the Finder and the Process Manager which features your application
supports and how much memory to allocate when it starts up your application. The following
sample code illustrates a 'SIZE' resource.
resource

'SIZE'

(-1,

purgeable)

{

reserved,
acceptSuspendResumeEvents,
reserved,
canBackground,

doesActivateOnFGSwitch,
backgroundAndForeground,
dontGetFrontClicks,

ignoreAppDiedEvents,
is32BitCompatible,
isHighLevelEventAware,
localAndRemoteHLEvents,
isStationeryAware,
dontUseTextEditServices,
reserved,
reserved,
reserved,
kPrefSize
kMinSize

*
*

1024,
1024

yy

Set up your application’s 'SIZE' resource with a resource ID of —1. The user can change the

preferred memory size requested for your application. If the user does change the memory

size, the Finder stores the new size in a 'SIZE' resource with a resource ID of 0. When it
launches your application, the Finder looks first for a 'SIZE' resource with an ID of 0. If it
finds none, it uses the 'SIZE' resource with an ID of -1.
Notice that the tenth field, isHighLevelEventAware, tells the Finder that this application
supports high-level events. The application must then be able to process the four required
Apple events—Open Application, Open Documents, Print Documents, and Quit Application—
that the Finder sends in response to actions that the user performs from the desktop. See the
Apple Event Manager and Event Manager chapters of this volume for more information about
handling high-level events.
Notice that the twelfth field, isStationery Aware, tells the Finder that this application supports
stationery pads, which are described in “Stationery Pads” later in this chapter.

For a complete description of the 'SIZE' resource and its fields, see the Event Manager

chapter in this volume.

Messages

When

the

Finder

Can’t

Find

Your

Application

When the user double-clicks a file or selects it and chooses either the Open or the Print
command from the Finder’s File menu, the Finder looks for the application whose signature

9-20

Finder-Related Resources

The Finder Interface

is stored in the file’s creator field. The Finder starts up that application and tells it which
documents the user wants to open or print. If the Finder cannot find the creator application,
it displays an alert box.

‘S
Le sy 4
me

—

~

lm]
ee

@

Lane 4

—

If the document is of either file type 'TEXT' or 'PICT' and if the TeachText application is
available, an alert box asks the user whether the TeachText application should be used to
open the document. For documents of any other file type, or if the TeachText application is
not present, the Finder displays an alert box like the one shown in Figure 9-6.

The

document

that

created

opened,

“Instructions”

because
it

the

could

could

application
not

be

not

be

program

found.

Figure 9-6. The default application-unavailable alert box
Your application should store one of two string resources in its documents to make the alert
box message more useful than the default shown in Figure 9-6.
Before displaying the default message shown in Figure 9-6, the Finder looks in the document
for one of two special 'STR ' resources: a message string or a name string. If the Finder can’t
find the document’s creator on any mounted volume, it looks first for the message string
resource. Provide a message string resource if you do not intend for users to open the file.
The message should explain why the file can’t be opened. If the Finder does not find a
message string resource, it looks for the name string resource. Provide a name string resource
if you intend for users to open the file. The name string should be your application’s name;
the Finder displays it in an alert box to inform the user that your application is needed.
You supply either the message string resource or the name string resource; don’t supply both.
Supply a message string resource for documents (such as a preferences file) that your application uses but that users should not open; supply a name string resource for documents that
you intend for users to open with your application.
Your name string resource (an 'STR ' resource with a resource ID of —16396) should contain
e name of your application. For example, an application named SurfWriter has a name
string resource that looks like this:
resource

'STR

'

(-16396,

purgeable)

{

/*

the

application

name

*/

"SurfWriter"

‘3

Use the AddResource and WriteResource procedures (described in the Resource Manager
chapter of Volume I) to store this resource in the documents created by your application.
Then, if the user tries to open or print one of your application’s documents when your
application is not present, the Finder can specify your application’s name in the alert box, as
illustrated in Figure 9-7.

Finder-Related Resources

9-2]

—

~
_
om

Lew

~

°
is)

|

Inside Macintosh,

Volume VI

The

(

document

“Instructions”

opened, because
*“SurfWriter”’

could

not

be

the application

could

not

be found.

as

Figure 9-7. The application-unavailable alert box specifying an application’s name
Your message string resource (an 'STR ' resource with a resource ID of —16397) should
explain why the user cannot open or print a document. Use this resource for files—such as
your application’s preferences file—that are not intended to be opened or printed by the user.
Register a signature (as explained in “Creators, File Types, and the Signature Resource”
earlier in this chapter) that is different from the signature of your application, and set this
signature as the creator of files that you don’t want your users to open. This ensures that the
Finder displays your message instead of launching your application when the user doubleclicks these documents.
The following resource illustrates a customized message explaining why the user cannot open
a preferences file:
resource
"This

'STR

"SurfWriter.

“this

'

(-16397,

document

document

You

purgeable)

describes
cannot

must

be

user

open

stored

or

in

{

/*

the

preferences
print

the

this

message
for

the

document.

Preferences

*/
application

"

To

be

effective,

"

folder

in

the

"

System

"Folder."

};

Figure 9-8 shows the alert box generated by this resource.

(%

This document describes user preferences
for the application SurfWriter. You cannot
open or print this document. To be
effective, this document must be stored in
the Preferences folder in the System
Folder.

|

OK

}

Figure 9-8. The application-unavailable alert box with a customized message
Note that if your application creates documents of file types 'TEXT' or 'PICT’, if the
TeachText application is available, and if your application is missing when the user tries
to open them from the Finder, the Finder always displays the alert box shown in Figure 9-9.
For these file types, the Finder displays this alert box even if you provide name or message
string resources.

9-22

Finder-Related Resources

The Finder Interface

()

The

document

“Instructions”

could

not

be

opened, because the application program
that created it could not be found. Do you
want to open it using “TeachText”?

(Cancer) (Cor)

Figure 9-9, The application-unavailable alert box for "TEXT" and 'PICT' documents

Version

Resources

You can use 'vers' resources to record version information for your application. If the user
opens the Views control panel, clicks the Show Version box, and then chooses any command
from the View menu other than by Icon or by Small Icon, filenames and their version
numbers from the 'vers' resource appear in the active Finder window. The Finder also
displays version information when the user selects your application and chooses Get Info
from the File menu.
The 'vers' resource allows you to store a version number, a version message, and a region
code. (Because the Get Info command’s information window already displays the name of
your application, the version message should not include the name of your application.) Each
‘vers’ resource uses this Rez template:
type

‘'vers'

{

byte;
byte;
byte;

/*
/*
/*

first part
of version
number
in BCD */
second and third parts of version
number
development=0x20,
alpha=0x40,
beta=0x60,

byte;

/*

stage

of

prerelease

integer;

/*

region

code,

pstring;

/*

version

number

as

pstring;

/*

version

message

in

version

*/
release=0x80

*/

*/

International

Utilities

*/

*/
*/

You can use 'vers' resources to assign version information to an individual file and, if it is a
part of a larger collection of files, to the entire superset of files. The 'vers' resource with a
resource ID of | specifies the version of the file; the 'vers' resource with a resource ID of 2
specifies the version of the set of files.
The following sample code illustrates the 'vers' resources, in Rez input format, for a spelling
checker application and for the word-processing system of which it is a part. Notice that the
spelling checker is version 1.1 while the set of files that compose the entire word-processing
system is version 2.0.
resource
0x01,
gt

ENP

"1.1

'vers'
(1,
purgeable)
Ox01,
release,
0x00,

{
verUS,

Salads

(US),

©

My

Company,

Inc.

1991"

};

Finder-Related Resources

9-23

Inside Macintosh,

resource
0x02,

Volume V1

'vers'
(2,
purgeable)
0x00,
release,
0x00,

{
verUS,

EDO

"(for

SurfWriter

2.0)"

¥3

Figure 9-10 illustrates how these resources are displayed in the information window.
===

wipedut Info B=

x

(@®

|

WipeOut
(for Surfwriter 2.0)

Product

Kind
: application program

and

Sizeize : 27K 27K on disk
(26,672 ytes
byt used)d
disk (26,

name

version

from

‘vers’ (2) resource

Where: Loma Prieta: Programming: wipeOut

Created:
Modified:

Mon, Apr 1, 1991, 7:04 PM
Thu, Sep 5, 1991, 7:19PM

+——

Version: 1.1 (US), © My Company, Inc.
1991

Comments:
luse this application like electronic typing
correction fluid.

:Memory

:
ia

Locked

File version number
and company copyright
from 'vers' (1) resource

toveipensensessoerecnrtensonassascceses :

Suggestedsize:
Current size:

128

K
K

Figure 9-10. The version data in the information window
You can store version resources in any kind of file, not just an application. If your application does not contain a 'vers' resource with a resource ID of |, the Finder displays the string
from your signature resource as the version information in the information window for
your application.

How

and

When

the Finder

Launches

Your

Application

The previous sections in this chapter explain the resources that the Finder uses to display and
launch your application. This section provides a brief summary of how the Finder—using the
previously described resources—starts up your application whenever the user requests the
Finder to launch your application or to open or print a document supported by your application.
The simplest scenarios under which the Finder launches your application occur when the user
double-clicks your application icon or selects it and chooses Open from the Finder’s File menu.
In these cases, the Finder calls the Process Manager to start your application. The Process
Manager creates a partition of memory for your application, loads your code into this partition,
and sets up the stack, heap, and A5 world for your application. The Process Manager returns
control to the Finder, which then relinquishes control to your application. (See the Process
Management chapter in this volume for more information.) Your application then performs the
tasks necessary to open itself—such as opening an untitled document window, for example.

9-24

Finder-Related Resources

The Finder Interface

When the user requests the Finder to open or print a document supported by your application,
the Finder calls the Process Manager and launches your application in the same way, except
that the Finder also sets up the information your application needs to open or print the document and passes this information to your application. This information includes a list of files
to open or print. Applications that do not support high-level events use the CountAppFiles,
GetAppFiles, and ClrAppFiles procedures or the GetAppParms procedure to get this information. In system software version 7.0, applications that support high-level events receive
this information through Apple events. The Apple Event Manager chapter in this volume
describes how your application processes Apple events to open or print files.
The user can request the Finder to open documents created by your application by doubleclicking one of their icons, and the user can request the Finder to open or print documents by
selecting one or more icons and choosing Open or Print from the Finder’s File menu. The
Finder reads the creator field of each selected file to find the document’s creator. Typically (as
described in “Finder Information in the Volume Catalog” later in this chapter), your application sets the four-character string specified in its signature resource as the creator of its documents. The Finder searches for the application whose signature matches each document’s
creator. If the document’s creator matches your application’s signature, the Finder calls the
Process Manager, launches your application, and then passes your application the name of
the selected document or selected multiple documents. Your application should then open the
documents in titled windows or print them, as appropriate.
If the user tries to open documents created by your application and your application is missing,
the Finder displays an alert box telling the user that your application is missing. The Finder
displays the name of your application in this alert box if you provide your documents with a
string resource (of resource ID —16396) containing your application’s name.
Sometimes when your application is already running, the user might double-click a document
created by your application. If your application supports high-level events, the Finder sends
your application the Open Documents event. If your application does not support high-level
events, the Process Manager accommodates the user by simulating a mouse-down event that
calls your application’s menu command for opening files. The Process Manager accomplishes
this by first looking for a File menu with an item named Open. Since some applications do not
have a File menu and since others use a command with a different name, the Process Manager
then looks in the application’s resource fork for 'mstr' and 'mst#' resources with resource
IDs 102 and 103. An 'mstr' resource has the same format as an 'STR' resource. An 'mstr'
resource with resource ID 102 should contain the name of the menu containing the Open
command. An 'mstr’ resource with resource ID 103 should contain the name of the menu
item containing the Open command. An 'mst#' resource has the same format as an 'STR#'
resource. An 'mst#' resource with resource [D 102 should contain the name or names of the
menu or menus containing the Open command. An 'mst#' resource with resource ID 103
should contain the name or names of the menu item or items containing the Open command.
The user can also request the Finder to launch your application by dragging one icon or several
icons to your application’s icon. The Finder determines whether to launch your application
by comparing the document’s file type (which is stored in the volume catalog) against the list
of your application’s supported file types. The Finder compiles this list from the 'FREF'
resources you create for your application; the Finder stores this list in the desktop database.
If the document’s file type appears in the 'FREF' list for your application, the Finder calls
the Process Manager, launches your application, and passes it the name of the selected document or selected multiple documents. Your application should then open the documents in
titled windows.

Finder-Related Resources

9-25

\o
~j

nate
_—

—

vol
—_
©
:
—

—
ee

—

=
<
—

:

—

as”
=

©)
©

Inside Macintosh,

Volume VI

If your application supports the Open Documents event, you can also specify disks, folders,
and a wildcard file type for all other files in your 'FREF' resources so that users can launch
your application by dragging their icons to your application icon. After the Finder uses the
Process Manager to launch an application that supports high-level events, the Finder sends
the application an Open Documents event, which includes a list of alias records for desktop
objects that the application should open. It is up to your application to open disks, folders, or
all possible file types in a manner appropriate to the needs of the user.
To support stationery, your application should specify the isStationeryAware constant in
its 'SIZE' resource and always check the isStationery bit of a document passed to it by the
Finder. If the isStationery bit is set for a file that the user wants to open, your application
should copy the stationery pad’s contents into a new document and open the document in
an untitled window. (Stationery is described in the next section.)

System software version 7.0 allows users to create aliases, which are desktop objects that
represent other files, directories, or volumes. If the user opens an alias that represents a
document created by your application, the Finder resolves the alias for you; that is, it passes
your application the name and location of the document itself, not the alias. (Aliases are
described in the next section.)

FINDER-RELATED

CHANGES

TO

THE

USER

INTERFACE

The Finder in system software version 7.0 offers a number of new interface features, most of
which have no effect on applications. This section summarizes the new features that might
affect your application.

Stationery

Pads

System software version 7.0 supports stationery pads, which are special documents used
as templates. Opening a stationery pad should not open the document itself; instead, it should
open a new document with the same contents as the stationery pad. To turn any document
into a stationery pad, the user selects it, chooses Get Info from the File menu, and clicks the
Stationery pad check box in the information window. The Finder tags a document as being a
stationery pad by setting the isStationery bit in the file’s Finder flags field (see “Finder
Information in the Volume Catalog” later in this chapter for a description of Finder flags).
When the user opens a stationery pad from the Finder, the Finder first checks your application’s 'SIZE' resource to see if your application supports stationery (see “The Size Resource”
earlier in this chapter). If the isStationeryAware bit is not set, the Finder creates a new document from the template and prompts the user for a name. The Finder then starts up your
application as usual, passing it the name of the new document.
If the isStationeryAware bit is set, the Finder informs your application that the user has
opened a document and passes your application the name of the stationery pad. To support
stationery, your application should
m specify the isStationeryAware constant in its 'SIZE' resource
m always check the isStationery bit of a document passed to it by either the Finder or the
Standard File Package
9-26

Finder-Related Changes to the User Interface

The Finder Interface

The isStationery bit alone identifies whether a document is stationery. If the isStationery bit is
set for a file that the user wants to open, your application should copy the template’s contents
into a new document and open the document in an untitled window.

\©
|
=
—

i=7
&
“

tmx
ne

As described in the Standard File Package chapter in this volume, your application can check
the sfFlags field of the standard file reply record to determine whether the isStationery bit is
set. Unlike the Finder, the Standard File Package always passes your application the
stationery pad itself, not a copy of it, regardless of the setting of the isStationery bit. When
the user opens a stationery pad from within your application, the Standard File Package
checks your application’s 'SIZE' resource. If your application does not support stationery,
the Standard File Package displays an alert box warning the user that the stationery pad itself,
not a copy of it, is being opened. As you can see, the user can still easily change the template
and mistakenly write over it by choosing Save without assigning a new name. You can
prevent this unnecessary user frustration by making your application stationery-aware.
You can supply the icon to be displayed for stationery pads created from your application’s
documents by using the resources described in “Finder-Related Resources” earlier in
this chapter.
If you do not supply your own stationery pad icon, the Finder uses the default stationery pad
icon illustrated in Figure 9-1.
In your documentation, tell users to choose the Get Info command to make stationery pads.
You may also want to give examples of useful stationery pads created with your application.
For example, if your application supports text and graphics, you may provide samples of
stationery pads for business letterheads or billing statements.

Edition

Icons

New to system software version 7.0 is the Edition Manager, which enables users to share and
automatically update data from numerous documents and applications. For example, a user
might want to capture sales figures and totals from within a spreadsheet and then include this
information in a word-processing document that summarizes sales for a given month. If both
the spreadsheet and word-processing applications support the Edition Manager, the user
begins by selecting data within the spreadsheet document and creating a publisher. The
spreadsheet application then writes a copy of that data to a separate file, called an edition. The
edition is represented by an icon; by default, it appears as the icon shown in Figure 9-1.
If the user opens a word-processing document and creates a subscriber to the spreadsheet
document’s edition, the word-processing application then incorporates the desired sales
figures and totals from the spreadsheet document’s edition into the document.
If you want your application to publish or subscribe to data among its own documents or
among documents created by other applications that support the Edition Manager, see the
Edition Manager chapter in this volume. If your application creates editions, consider creating
an icon that uniquely identifies your editions and that associates them with your application’s
documents. See “Icon Resources” earlier in this chapter for information about creating icon
resources. The file type for your edition containers should be ‘edtt' (for text-oriented data),
‘edtp' (for graphics-oriented data), or 'edts' (for sound-oriented data); and the creator, of
course, should be the signature of your application.

Finder-Related Changes to the User Interface

9-27

re

a

&
‘en

a)

pe)
C8
a")

Inside Macintosh,

Volume VI

Customized

Icons

You can create customized icons for your documents. Users can also create customized
icons. Customized icons are stored with resource ID —16455 in the resource fork of the file.
(Compare this to the method described in “Finder-Related Resources” earlier in this chapter
whereby icons are defined through a bundle resource and its associated icon list and file
reference resources.)

In system software version 7.0, the user can customize individual icons. By selecting a file

and choosing Get Info from the File menu, the user sees the information window for that file.
The user can then select the icon displayed in the upper-left corner of the information window
and use the Paste command in the Edit menu to replace it with a picture from the Clipboard.
The Finder creates a family of icons based on the user’s customized icon, assigns a resource
ID of —16455 to each icon resource in the family, stores these resources in the resource fork of

the file that the icon represents, and sets the hasCustomlcon bit in the file’s Finder flags field.
Your application can use the same strategy to provide customized icons to the documents that
it creates. For example, a drawing application might create miniature versions of the illustrations contained within its documents and use those for the documents’ icons.
If you are a database developer who creates and distributes query documents that support
the Data Access Manager, you can also use this strategy to create icons that identify your
database’s query documents. Similarly, if instead of producing an application you produce
and distribute information (such as database files, stationery pads, clip art libraries, or
dictionaries) to be used by other applications, you might want to provide icons that distinguish your documents.

To make the version 7.0 Finder display customized icons for a document, you must create—
at least—an 'ICN#'’ resource with resource ID —16455 and store it in the document’s
resource fork. (To create this while your application is running, your application can call the
AddResource procedure, described in the Resource Manager chapter in Volume I.) You can
use the following constant in place of the ID number.
CONST

kCustomIconResource

=

-16455;

{res

ID

for

custom

icon}

If you provide only an 'TCN#' resource, the Finder uses a black-and-white icon on all screen

displays and automatically reduces it when a small version of the icon is required. To create
color versions and to define a small version of the icon, create an entire icon family as
described in “Icon Resources” earlier in this chapter.

After creating icon resources with the kCustomIconResource constant as their IDs, you must
set the hasCustomIcon bit in the file’s Finder flags field. To prevent users from changing
these icons, set the nameLocked bit in the file’s Finder flags field. (Most development
environments for version 7.0 provide tools for setting these bits. “Finder Information in the
Volume Catalog” later in this chapter describes Finder flags.)
Note:

If you want your document to appear with its own icons on earlier versions

of system software, you must create a file reference resource and a bundle resource
for it as described in “File Reference Resources” and “The Bundle Resource” earlier

in this chapter.

9-28

Finder-Related Changes to the User Interface

The Finder Interface
\o

Aliases

me
—

=

°
—

The Finder for system software version 7.0 allows the user to create multiple desktop icons to
represent a single document or other desktop object (such as a disk, a folder, or the Trash).

One of the icons represents the actual file; the others are aliases that point to the file. An alias
is an object on the desktop that represents some other file, directory, or volume. An alias
looks like the icon of its target, but its name is displayed in a different style. The style depends
on the system script; for Roman and most other scripts, alias names are displayed in italic.
To the user, the icons of the actual file and its aliases are functionally identical. Aliases give
the user more flexibility in organizing the desktop and offer a convenient way to store a local
copy of a large or dynamic file that resides on a file server.
As a desktop object, the alias depicts a file called the alias file, which contains a record that
points to the file, directory, or volume represented by the icon. Alias files are created and
managed by the user through the Finder.
Although your application shouldn’t create alias files or change users’ desktop aliases, your
application can create and use its own alias records for storing identifying information about

files or directories. An alias record is a data structure that identifies a file, folder, or volume.

Whenever your application needs to store file or directory information, you can record the
location and other identifying information in an alias record. The next time your application
needs the file or directory, you can use the Alias Manager to locate it, even if the user has
renamed it, copied it, restored it from backup, or moved it. You can also use alias records to
identify objects on other volumes, including AppleShare® volumes. See the Alias Manager
chapter of this volume for details about creating and managing information in alias records.
Ordinarily, when the user wants to open or print files, your application does not need to
be concerned with whether they are aliases because both the Finder and the Standard File
Package resolve aliases before passing them to your application. If the user opens an alias
that represents a document created by your application, the Finder passes your application
the name and location of the document itself, not the alias. Similarly, when the user opens
an alias from within your application, the Standard File Package passes your application the
name of the target document.
If your application bypasses the Finder or the Standard File Package when manipulating
documents, it should check for and resolve aliases itself by using the ResolveAliasFile
function.

Resolving

Alias

Files

The ResolveAliasFile function is part of the Alias Manager and is available only in system
software version 7.0. Use the Gestalt function with the Gestalt selector gestaltAliasMgrAttr
to determine whether you can use the ResolveAliasFile function.
An alias file contains an alias record, stored as a resource of type ‘alis’, that points to the target
of the alias (see the Alias Manager chapter of this volume for a description of alias records).The
alias file might also contain the target object’s icon descriptions. The Finder identifies an alias
file by setting the isAlias bit in the file’s Finder flags field (see “Finder Information in the
Volume Catalog” later in this chapter for a description of Finder flags).

Finder-Related Changes to the User Interface

9-29

&

;
_
_
—

—
-_

@
—

;

—

as”
~
oO
@

Inside Macintosh,

Volume VI

An alias file that represents a document typically has the same type and creator as the file it
represents. However, many desktop objects—such as disks, folders, and the Trash—do not
have file types. Instead, alias files for these objects are assigned special file types, called alias
types. Here are the alias types for those desktop objects for which users can provide aliases:

Desktop object

Alias
type

Constant

Apple Menu Items folder
AppleShare drop folder
Application
Control Panels folder
Exported AppleShare folder
Extensions folder
File server
Floppy disk
Folder
Hard disk
Mounted AppleShare folder
Other objects that can contain files
Preferences folder
PrintMonitor Documents folder
Shared AppleShare folder
Startup Items folder
System Folder
Trash

'faam'
'fadr'
‘adrp'
‘fact’
‘faet'
'faex'
'srvr'
‘flpy'
'fdrp'
‘hdsk'
‘famn’
‘drop’
'fapf'
‘fapn'
'fash'
‘fast’
'fasy'
‘trsh'

kAppleMenuFolderAliasType
kDropFolderAliasT
ype
kApplicationAliasType
kControlPanelFolderAliasType
kExportedFolderAliasType
kExtensionFolderAliasType
kContainerServerAliasType
kContainerFloppyAliasType
kContainerFolderAliasType
kContainerHardDiskAliasType
kMountedFolderAliasType
kContainerAliasType
kPreferencesFolderAliasType
kPrintMonitorDocsFolderAliasType
kSharedFolderAliasType
kStartupFolderAliasType
kSystemFolderAliasType
kContainerTrashAliasType

(The Extensions, Preferences, Apple Menu Items, Control Panels, Startup Items, and

PrintMonitor Documents folders are described in “The System Folder and Its Related
Directories” later in this chapter.)

Since users of system software version 7.0 can replace files with aliases, if your application
opens a file or a directory without going through the Finder or the Standard File Package (if, for
example, it uses preference files or dictionary files), it should always call the ResolveAliasFile
function just before opening the file.
FUNCTION

ResolveAliasFile

(VAR

theSpec:

FSSpec;

resolveAliasChains:

Boolean;
VAR targetisFolder:
Boolean;
wasAliased:
Boolean)
: OSErr;

VAR

ResolveAliasFile, like all other Alias Manager routines, accepts and returns file specifications only in the form of file system specification records defined by the FSSpec data type,
described in the File Manager chapter of this volume. The file system specification record
represents a simple and complete description of a file system object. It contains a volume
reference number, a parent directory ID, and a name. Use the new File Manager function

MakeFSSpec to convert other forms of file identification, such as full pathnames, into file
system specifications.
You specify the file or directory you plan to open by passing a file system specification
record in the parameter theSpec. ResolveAliasFile returns the name and location of the target
file in theSpec.
9-30

Finder-Related Changes to the User Interface

The Finder Interface

ResolveAliasFile can follow a chain of aliases, up to a reasonable maximum defined for the
system, to the ultimate target. Set the resolveAliasChains parameter to TRUE if you want
ResolveAliasFile to resolve all aliases in a chain, stopping only when it reaches the target file.
Set it to FALSE if you want to resolve only one alias file, even if the target is another alias file.
The parameters targetIsFolder and wasAliased are return parameters only. ResolveAliasFile
always initializes these parameters to FALSE. It sets targetIlsFolder to TRUE if the parameter
theSpec points to a directory or a volume. It sets wasAliased to TRUE if the file originally
passed in the parameter theSpec points to an alias file.
ResolveAliasFile first checks the catalog entry for the file or directory specified in theSpec to
determine whether it is an alias and whether it is a file or a directory. If the object is not an
alias, ResolveAliasFile leaves theSpec unchanged, sets the targetIsFolder parameter to TRUE
for a directory or volume and FALSE for a file, sets wasAliased to FALSE, and returns
noErr. If the object is an alias, ResolveAliasFile resolves it, places the target in the parameter
theSpec, and sets the wasAliased flag to TRUE.
When ResolveAliasFile finds the specified volume and parent directory but fails to find the
target file or directory in that location, ResolveAliasFile returns a result code of fnfErr and
fills in the parameter theSpec with a complete file system specification record describing the
target (that is, the volume reference number, parent directory ID, and filename or folder
name). The file system specification record is valid, although the object it describes does not
exist. This information is intended as a “hint” that lets you explore possible solutions to the
resolution failure. You can, for example, use the file system specification record to create a
replacement for a missing file with the File Manager function FSpCreate.
If ResolveAliasFile receives an error code while resolving an alias, it leaves the input
parameters as they are and exits, returning the error code. In addition to any of these result
codes, ResolveAliasFile can also return any Resource Manager or File Manager errors.
Result codes
nsvErr
fnfErr

—35
—43

dirNFErr

—120

Volume not found
Target not found, but volume and parent directory found,
and theSpec parameter contains a valid file system
specification record
Parent directory not found

When opening a file without going through the Finder or the Standard File Package, you call
ResolveAliasFile immediately before opening the file. In Listing 9-4, the customized open
function, MyOpen, ensures that the file to be opened is the target file, and then opens the data
fork with the FSpOpenDF function.
Listing 9-4. Using the ResolveAliasFile function to open a file
FUNCTION

MyOpen(VAR
VAR

theSpec:
fRefNum:

FSSpec;
perm:
SignedByte;
Integer)
: OSErr;

VAR

myErr:

OSErr;

targetIisFolder:

Boolean;

wasAliased:

Boolean;
(Continued)

Finder-Related Changes to the User Interface

9-3]

. =)
le 9)4
—e

~
a
—

al

@
er |
_
~
—

oe

a)
ex}
AC)
as
—

@)
@

Inside Macintosh,

Volume VI

Listing 9-4. Using the ResolveAliasFile function to open a file (Continued)
BEGIN

fRefNum
myErr
IF

:=
:=

-1;

{initialize

ResolveAliasFile(theSpec,

targetIsFolder
myErr

ELSE

IF

:=

<>

targetIsFolder,

wasAliased);

THEN

paramErr

(myErr

TRUE,

fRefNum}

noErr

)

THEN

myErr
:= FSpOpenDF(theSpec,
MyOpen
:= myErr;

{cannot

open

a

{try

open

it}

perm,

to

folder}

fRefNum);

END;

Desk

Accessories

System software version 7.0 no longer employs the Font/DA Mover. Desk accessories
are now represented by icons, and users install desk accessories by dragging their icons to
the System Folder icon. The Finder then moves them to the Apple Menu Items folder.
(“The System Folder and Its Related Directories” later in this chapter describes the new
organization of the System Folder.) From the user’s point of view, there is little or no
distinction between desk accessories and applications in version 7.0.
Desk accessories now behave more like applications. When a desk accessory is open, its
name appears in the Application menu. A desk accessory can have its own About command
in the Apple menu, and it can be brought to the foreground and sent to background independently of other desk accessories.
As described in “Icon Resources” earlier in this chapter, you can design a family of icons for
your desk accessory and include all the icons used by applications: large, small, black-andwhite, 4-bit color, and 8-bit color icons. If you don’t provide icon resources, the Finder
displays your desk accessory icon by using a mirror image of the default application icon, as
shown in Figure 9-1.
Users don’t even need to store desk accessories in the Apple Menu Items folder. Instead,
users can store them as they store applications—that is, anywhere in the file system. Users
can open desk accessories from the Finder in the same way they open applications: by
double-clicking their icons or by selecting them and choosing Open from the File menu.
In previous versions of system software, the File menu for desk accessories included two
commands, Close and Quit. The user chose Close to close and quit the active desk accessory.
The user chose Quit to quit all desk accessories. In system software version 7.0, the Close
command closes the active window and the desk accessory remains open. The Quit command
now terminates the active desk accessory only. Close and Quit have keyboard equivalents of
Command-W and Command-Q, respectively.
Users of previous versions of system software are accustomed to opening their desk accessories from the Apple menu. Users of version 7.0 can use this convenient method to open any
of their applications. Any application or alias to an application that users drag to the Apple
Menu Items folder appears in the Apple menu. Choosing a name from the Apple menu, of
course, opens the application.
9-32

Finder-Related Changes to the User Interface

The Finder Interface

These similarities in installation, user access, and capability make desk accessories and applications more consistent in their appearance and behavior. There are no compelling reasons to
create desk accessories for system software version 7.0. Instead, if you wish to develop a
desk accessory-—like tool, it’s a better idea to write a small application, because desk accessories are generally more difficult to write and less powerful than applications.

\o
—ae? |
=
2.

o
vr |

~
==

a")
a

S

—_

You may decide to upgrade your existing desk accessory instead of rewriting it as an application, or you may wish to write a desk accessory because you want it to run in previous
versions of system software where MultiFinder is optional. If you create a desk accessory,
in your documentation you should instruct users of system software version 7.0 that if they
want the desk accessory to appear in the Apple menu, they should install it by dragging its
icon to the System Folder icon. A dialog box appears asking the user to verify that the desk
accessory should be installed in the Apple Menu Items folder. The user clicks OK to accept
this installation. The user also has the option to click Cancel to prevent the installation.
Note: If users drag a desk accessory icon to the open System Folder window
instead of to the System Folder icon, the Finder copies or moves the desk accessory
into the System Folder directory instead of installing it in the Apple Menu Items
directory.
You can also provide a message for your desk accessory that appears in an alert box when the
user chooses the About command from the Apple menu in system software version 7.0. To
provide this message, create a resource called 'dast' as an owned resource with a sub ID of 0.
For example, the 'dast' resource with a sub ID of 0 for a desk accessory with a 'DRVR' ID
of 12 (also called the owner ID in ResEdit) gets a resource ID of —16000. (See the Resource

Manager chapter in Volume I for a discussion of owned resources.) Your 'dast' resource
must contain a Pascal string only. When the user chooses the About command for your desk
accessory, this string appears in an alert box along with the icon you provide for your
desk accessory.
As described in “Balloon Help for Icons” later in this chapter, you can also provide a custom
help balloon message for your desk accessory icon that overrides the Finder’s default help
balloon for desk accessory icons.

Fonts,

Sounds,

and

Other

Movable

Resources

As described in the previous section, the Finder for system software version 7.0 provides the
services previously performed by the Font/DA Mover. You can now distribute fonts, sounds,
keyboard layouts, and script system resource collections in individual, movable resource files.
Like desk accessories, movable resources such as fonts, keyboard layouts, and sounds are
represented on the screen by icons. To install these resources, the user drags their icons to
the System Folder icon, and the Finder puts them in the System file. By double-clicking the
System Folder to open it and then double-clicking the System file so that it opens like a

folder, the user can see which movable resources are installed. (For a description of the new

organization of the System Folder, see ““The System Folder and Its Related Directories” later
in this chapter.)
To make one of these resources visible on the screen, assign it one of the special file types
defined by the Finder for movable resources. The following list shows the resources that can
be moved, their assigned file types, and their icons.
Finder-Related Changes to the User Interface

9-33

°
La)

Inside Macintosh,

Volume V1

File
type

Resource

Large blackand-white icon

A
Font

ffil’

Al

TrueType font

fil’

A

Sound

'sfil’

))

Keyboard layout

‘kfil’

Script system

‘i fil’

resource collection

Note: You can’t provide your own icons for these file types. Even if you define
icons in a movable resource’s bundle, the Finder displays the file using one of
the icons shown above. You or your users can give customized icons to these file
types (as described in “Customized Icons” earlier in this chapter) as long as the files
are not moved into the System file; but as soon as users install them into the System
file, the Finder displays them using the icons shown in the previous list.
The user can still store fonts and desk accessories in files that have suitcase icons, which is
how they were previously distributed for installation or saved by the user using the Font/DA
Mover. A suitcase file that holds desk accessories is of type 'DFIL', and a suitcase file that
holds fonts is of type 'FFIL'. All suitcase files have a creator of 'DMOV',
In your documentation, tell users to install fonts, sounds, or script system resource collections
by dragging their icons to the System Folder icon. A dialog box appears asking the user to
verify that the resource should be installed in the System file. The user clicks OK to accept the
installation. The user also has the option to click Cancel to prevent the installation.
Note: If users drag icons to the open System Folder window instead of to the
System Folder icon, the Finder copies or moves the files into the System Folder
directory instead of installing them into the System file.

Balloon

Help for Icons

The Finder offers Balloon Help on-line assistance for users. After the user chooses Show
Balloons from the Help menu, descriptive help balloons appear when the user moves the
cursor to an area of the screen (such as a menu, a window control, or a dialog box) that has a
help resource associated with it.
9-34

Finder-Related Changes to the User Interface

The Finder Interface

The Finder provides default help balloons for application, control panel, system extension,
and desk accessory icons. You can provide a customized help balloon for your application,
control panel, system extension, or desk accessory icon by adding an ‘hfdr' resource with
resource ID —5696 to the resource fork of your application. Figure 9-11 compares the default
help balloon with a customized help balloon for the SurfWriter application icon.

eS
=J
—s
—

—

Q.
@

Lee

=}

a
<7)
my r
a)
as
~~

CO
\¢")

Default help balloon
for an application icon

Customized help balloon
for an application icon

This is an application—a
program with which you can
perform 4 task or create a
document. Applications
include word processors,
graphics programs, and
spreadsheets.

Use the Surfwriter word
processor to create or
edit the most radical
documents ever written
on your Macintosh
computer .

Surfwriter

Surfiriter

Figure 9-11. Default and customized help balloons for application icons
Listing 9-5 shows the Finder help override resource and its associated 'STR ' resource that
are used for the customized help balloon in Figure 9-1 1.
Listing 9-5. Creating a help balloon resource for an application icon
resource

'hfdr'

(-5696,

purgeable)

HelpMgrVersion,

hmDefaultOptions,

{
HMSTRResItem
1001

/*

{

use

'STR

'

{

/*
0,

resource

help

0,

for
/*

1001

SurfWriter

header

app

icon

information

*/

*/

*/

}

};
resource
'STR
' (1001,
purgeable)
{ /* help message
for app icon
"Use the SurfWriter
word processor
to create or edit
the most
"radical
documents
ever written
on your Macintosh
computer."

*/
"

};

Note: You cannot override the default help balloon that the Finder uses for
document icons.
The Help Manager chapter of this volume describes in detail how to provide Balloon Help for
your application icon and for other elements of your application.

Finder-Related Changes to the User Interface

9-35

|

—

Inside Macintosh,

FINDER

Volume

VI

INFORMATION

IN THE

VOLUME

CATALOG

A catalog exists on every volume to maintain relationships between the files and directories
on that volume. (A volume is any storage medium formatted to contain files.) Although it’s
used mostly by the File Manager, the catalog also contains information used by the Finder.
The information for files is listed in data structures defined by the FInfo and FXInfo data
types; the information for directories is listed in data structures defined by the DInfo and
DXInfo data types.
Normally, your application sets the file type and the creator information in fields of the file’s

FInfo record when your application creates a new file. (For a discussion of the recommended
new functions available for creating files, see the File Manager chapter in this volume.) The
Finder manipulates the other fields in the FInfo record.
TYPE

FiInfo

=

RECORD

fdType:
fdCreator:

OSType;
OSType;

{file
{file

type}
creator}

fdFlags:

Integer;

{Finder

fdLocation:

Point;

{file's
location
{ directory}

fdFldr:

Integer

{directory
{ file}

flags}

that

in

}

contains

}

END;

You typically set a file’s type and creator when you create the file; for example, the
FSpCreate function takes a creator and a file type as parameters. After you have created a file,
you can use the GetFInfo function to return the FInfo record, then change the fdType and
fdCreator fields by using the SetFInfo function.
You can always check the information in this record by calling the GetFInfo or GetCatInfo

function. (See the File Manager chapter in Volume IV for information about these functions.)

In particular, you may want to check the file type or creator for a file, or you may want to
check or set one of your document’s Finder flags, which are listed here.

Flag name

Bit
number

isAlias

15

isInvisible

14

hasBundle

13

nameLocked

12

isStationery

11

9-36

Description
The file is an alias file. Reserved for directories—
in which case, set to 0.
The file or directory is invisible from the Finder
and from the Standard File Package dialog
boxes.
The file contains a bundle resource. Reserved for
directories—in which case, set to 0.
The file or directory can’t be renamed from the
Finder, and the icon cannot be changed.
The file is a stationery pad. Reserved for
directories—in which case, set to 0.

Finder Information in the Volume Catalog

The Finder Interface
\©

Bit
number

Flag name

hasCustomIcon

10

hasNoINITS

7

isShared

6

Reserved
hasBeenInited

The file or directory contains a customized icon.

9
8

requiresSwitchLaunch
colorReserved
color
isOnDesk

ce
5.

Description
Reserved; set to 0.
The Finder has recorded information from
the file’s bundle resource into the desktop
database and given the file or folder a position
on the desktop.
The file contains no 'INIT' resources; set to 0.
Reserved for directories; set to 0.
The application is available to multiple users.
Defined only for applications; otherwise, set
to 0.
Unused and reserved in version 7.0; set to 0.
Unused and reserved in version 7.0; set to 0.
Three bits of color coding.
Unused and reserved in version 7.0; set to 0.

5
4
|-3
0

Masks for two of these bits are available as predefined constants:
CONST

fHasBundle
fInvisible

=

8192;

{set

if

file

hes

a

16384;

{set

if

icon

is

invisible}

bundle}

Of these Finder flags, the only ones that you might ever want to set are these:
isInvisible. This flag specifies that a file is invisible from the Finder and from the
Standard File Package dialog boxes. Making a file invisible is generally not recommended. Not even temporary files need to be invisible because the Temporary Items
folder into which they should be written is invisible.

hasBundle. This flag specifies that a file has a 'BNDU resource that associates the

file with your own icons. When the Finder displays or manipulates a file, it checks
the file’s hasBundle bit (also called the bundle bit). If that bit is not set, the Finder
displays a default icon for that file type. If the hasBundle bit is set, the Finder checks
the hasBeenlInited bit. If the hasBeenlInited bit is set, the Finder uses the information
in the desktop database to display that file’s icon. If the hasBeenInited bit is not set,
the Finder installs the information from the bundle resource in the desktop database
and sets the hasBeenInited bit. Most development environments provide a simple tool
for setting the bundle bit when you create your application.
nameLocked. This flag specifies that a file cannot be renamed from the Finder and
that the file cannot have customized icons assigned to it by users.
isStationery. This flag specifies that a file is a stationery pad. To support stationery
pads, your application should check this bit for every document passed to it by either the
Finder or the Standard File Package. (As described in the Standard File Package chapter
in this volume, StandardGetFile and CustomGetFile return this flag in the sfType field
of the standard file reply record.) If the isStationery bit is set for a file that a user wants
to open, your application should copy the template’s contents into a new document and
open the document in an untitled window. (“Stationery Pads” earlier in this chapter
discusses stationery pads.)
Finder Information in the Volume Catalog

9-37

=

e
Ts
=

Inside Macintosh,

Volume V1

a hasCustomlIcon. This flag specifies that a file has a customized icon. “Customized
Icons” earlier in this chapter explains how users or your application can use customized

icons.

The Finder manipulates the fields in the FXInfo, DInfo, and DXInfo records; your application shouldn’t have to directly check or set any of these fields. The FXInfo and DXInfo
records have been changed slightly with system software version 7.0. To update the information presented in Volume V, the new definitions are shown here.
TYPE

FXInfo

=

RECORD
fdaIconID:

Integer;

fdUnused:

ARRAY[1..3]

{unusea

but

fdScript:

SignedByte;

{script

flag

SignedByte;

{reserved}

Integer;

{comment

LongInt

{home

fdXFlags:
fdComment

:

EdPutAway:

{icon
OF

ID}

Integer;
reserved

and

6

bytes}

of

open

code}

ID}

dir

ID}

END;

TYPE

DXInfo

=

RECORD
frScroll:

Point;

{scroll

frOpenChain:

LongIint;

{directory
{ folders}

position}

frScript :

SignedByte;

{script

frXFlags:
frComment :

SignedByte;
Integer;

{reserved}
{comment }

frPutAway:

Longint

{home

ID

flag

dir

chain
and

}

code}

ID}

END;

Previously reserved or unused fields in these two records are now partly used by the bytelength fdScript and frScript fields. These new fields are available for future enhancements of
the script display capability of the Finder.
Ordinarily, the Finder displays the names of all desktop objects in the current system script,
which depends on the region-specific configuration of the system. The high bit of the bytes in
the fdScript and frScript fields is set by default to 0, which causes the Finder to display the
filename or directory name in the current system script. If the high bit is set to 1, the Finder
and the Standard File Package display the filename and directory name in the script whose
code is recorded in the remaining 7 bits. However, in system software version 7.0, the
Window Manager and Dialog Manager have not been enhanced to support multiple simultaneous scripts, so the system script is used for displaying filenames and directory names in
dialog boxes, window titles, and other user interface elements used by the Finder. Therefore,
until the system software’s script capability is fully implemented, you should still treat these
fields as reserved.

9-38

Finder Information in the Volume Catalog

The Finder Interface

THE

SYSTEM

FOLDER

AND

ITS

RELATED

DIRECTORIES

The System Folder is a directory that stores essential system software such as the System
file, the Finder, and printer drivers. Since this directory has appeared on all Macintosh
computers, it’s also been a dependable place to store and locate files—some that Apple
software has installed, some that applications have installed, and some that users have
installed. But for users of earlier versions of system software, this led to cluttered System
Folders whose contents were often difficult to decipher or maintain.
System software version 7.0 introduces a new organization for the System Folder, which
contains a set of new subdirectories to hold related files. The Finder uses these subdirectories
to facilitate file management for the user. For example, by sorting and storing such files as
desk accessories, control panels, fonts, preferences files, system extensions, and temporary
files into separate folders for the user, the Finder keeps the top level of the System Folder
from being cluttered with dozens, or even hundreds, of files.
The user can easily install and remove fonts, sounds, keyboard layouts, control panels, and
system extensions by dragging their icons to the System Folder icon. The Finder then moves
them into the proper subdirectory. When a control panel icon is dragged to the System Folder
icon, for example, the Finder presents a dialog box that asks the user, “Place this control
panel into the “Control Panels’ folder?” The user accepts by clicking OK or declines by
clicking Cancel.
Note:

If users drag icons to the open System Folder window instead of to the

System Folder icon, the Finder copies or moves the files into the System Folder

directory instead of copying or moving them to the proper subdirectory.

Figure 9-12 shows a user’s view of the new directory organization typically found within the
System Folder.
Loma
14 items

Prieta

24.9 MB in disk

Em
16 items
System Folder

System

[i] 0 iterns

|

=

Z|

MB available

13.1

MB available

|

24.9 MB in disk
=

Trash

13.1

System Folder
=~

Finder

Startup Items

—

Preferences

Control Panels

Extensions

Apple Menu Items

PrintMonitor Documents

a

Cp

Y

Clipboard

eth

Figure 9-12. The System Folder and related folders
The System Folder and Its Related Directories

Inside Macintosh,

Volume V1

Additional related directories are located at the root directory. Notice the Trash window. It
shows the contents of the Trash directory, which is represented to the user by the Trash icon.
The Trash directory exists at the root level of the volume. In system software version 7.0, a
Macintosh sharing files among users in a network environment maintains separate Trash
subdirectories within a shared, network Trash directory. That is, for every user who opens a
volume located on a Macintosh server and drags an object to the Trash icon, the server creates

a separate, uniquely named Trash subdirectory for that user. All Trash subdirectories within a

shared, network Trash directory are invisible to users. On the desktop, the user sees only the
Trash icon of his or her local Macintosh computer. When the user double-clicks the Trash
icon, a window reveals the names of only those files that he or she has thrown away; no
distinction is made to the user as to which computers any of these files originated from.
At the root level of the volume, the Finder also maintains a Temporary Items folder and a
Desktop Folder, both of which are invisible to the user and so don’t appear in Figure 9-12.
Figure 9-12 illustrates the folder organization typically found on single-user systems. Of all
these related directories, your application is likely to use only the Preferences folder and the
Temporary Items folder. However, you cannot be certain of the location of these or any of
the other system-related directories. In the future, these system-related directories may not
be located in the System Folder or in the root directory. Therefore, you should always use
the new FindFolder function to help you locate these directories. The FindFolder function is
available only in system software version 7.0. Use the Gestalt function to determine if
FindFolder is available to your application.

Folder

Organization

Your application may freely use these two directories for storing and locating important files:
= Preferences, located in the System Folder, holds preferences files to record local
configuration settings. Your application can store its preferences file in this directory.
The active Finder Preferences file is always stored in the Preferences folder. Do not
use the Preferences folder to hold information that is to be shared by users on more
than one Macintosh computer on a network. Ensure that your application can always
operate even if its preferences file has been deleted.
a Temporary Items, located at the root level of the volume, holds temporary files
created by applications. The Temporary Items folder is invisible to the user. Your
application can place its temporary files in this directory. A temporary file should
exist only as long as your application needs to keep it open. As soon as your
application closes the file, your application should remove the temporary file. You
should also ensure that you are assigning a unique name to your temporary file so
that you don’t write over another application’s file.
It’s important to bear in mind a few rules about storing your application’s files. First, don’t
store any files at the top level of the System Folder. Use the Preferences directory or one of
the other directories described in the following list.
Second, use the FindFolder function described in the next section, “Finding Directories,” to
locate or put files in the right place. Don’t assume files are on the same volume as your application; they could be on a different local volume, or on a remote volume on the network.
Third, don’t store any files that multiple users may need to access, such as dictionaries and
format converters, in the Preferences directory or in any of the directories located in the
9-40)

The System Folder and Its Related Directories

The Finder Interface
\S

System Folder. Remember that the files in the System Folder are generally accessible only
to the person who starts up from the System file in that System Folder.

Le wy
canis

~

a
om
a

In system software version 7.0, there are other new directories that either the user or the
Finder uses for storing and locating important files; these directories are described here.
Generally, your application should not store files in these directories.

—

=
—s
ic)

oyi?)

= Apple Menu Items, located in the System Folder, holds the standard desk accessories
plus any other desk accessories, applications, files, folders, or aliases that the user wants
to display in the Apple menu. System software version 7.0 treats desk accessories like
applications, not like system resources. Desk accessories are no longer stored in a
volume’s System file. (For more detail, see “Desk Accessories” earlier in this chapter.)
Only the user and the Installer should put things into the Apple Menu Items folder.
a Control Panels, located in the System Folder, holds control panels. The Apple Menu
Items folder holds an alias to the Control Panels folder so that the user can also reach the
control panels through the Apple menu. Only the user and the Installer should put things
into the Control Panels folder.
=m Desktop

Folder, which is invisible to users of system software version 7.0, is

located at the root level of the volume. The Desktop Folder stores information about
the icons that appear on the desktop area of the screen. The user controls the contents
of the Desktop Folder by arranging icons on the screen. What appears on the screen to
the user is the union of the contents of Desktop Folders for all mounted volumes.

uw Extensions, located in the System Folder, holds extensions—that is, code that is not
part of the basic system software but that provides system-level services, such as printer
drivers and system extensions. Files of type 'INIT', previously called startup documents,
and of type 'appe', also known as background-only applications, are routed by the Finder
to this folder. Files of type 'scri' (system extensions for script systems) are also routed to
this folder. Only the user and the Installer should put things into the Extensions folder.
a PrintMonitor Documents, located in the System Folder, holds spooled documents
waiting to be printed. Only the printing software uses the PrintMonitor Documents folder.
= Rescued Items from volume name, located in the Trash directory, is a directory
created by the Finder at system boot, restart, or shutdown only when the Finder finds
items in the Temporary Items folder. Since applications should remove their temporary
files when they close them, the existence of a file ina Temporary Items folder indicates
a system crash. When the Finder discovers a file in the Temporary Items folder, the
Finder creates a Rescued Items from volume name directory that is named for the
volume on which the Temporary Items folder exists. For example, the Finder creates a
directory called Rescued Items from Loma Prieta when a file is discovered in the

Temporary Items folder on a volume named Loma Prieta. The Finder then moves the
temporary file to that directory so that users can examine the file in case they want to
recreate their work up to the time of the system crash. When a user empties the Trash,
all Rescued Items folders disappear. Only the Finder should put anything into Rescued
Items directories.
= Startup Items, located in the System Folder, holds applications and desk accessories
(or their aliases) that the user wants started up every time the Finder starts up. Only the
user should put things into the Startup Items folder. Note that there is a distinction
between startup applications that users put in the Startup Items folder and system
extensions of file type 'INIT' (previously called startup documents), which are typically
installed in the Extensions folder.
The System Folder and Its Related Directories

9-4]

@

Inside Macintosh,

Volume

V1

u System file, located in the System Folder, contains the basic system software plus
some system resources, such as font and sound resources. In version 7.0, the System
file behaves as a folder in this regard: although it looks like a suitcase icon, double-

clicking it opens a window that reveals movable resource files (such as fonts, sounds,

keyboard layouts, and script system resource collections) stored in the System file.
(“Fonts, Sounds, and Other Movable Resources” earlier in this chapter describes the
resources that can be moved into the System file.) Only the user and the Installer should
put resources into the System file.
w

Trash, located at the root level of a volume, holds items that the user moves to the

Trash icon. After opening the Trash icon, the user sees the collection of all items that the
user has moved to the Trash icon—that is, the union of all appropriate Trash directories
from all mounted volumes. A Macintosh set up to share files among users in a network
environment maintains separate Trash subdirectories for remote users within its shared,
network Trash directory. That is, for every remote user who opens a volume located on
a Macintosh file server and drags an object to the Trash icon, the server creates a
separate, uniquely named Trash subdirectory for that user. All Trash subdirectories and
the shared, network Trash directory are invisible to users. The Finder for system
software version 7.0 empties a Trash directory (or, in the case of a file server, a Trash
subdirectory) only when the user of that directory chooses the Empty Trash command.

Although the names of the visible system-related folders vary on different international
systems, the invisible directories Temporary Items and Desktop Folder keep these names on
all systems. System software assigns unique names for invisible Trash subdirectories.
Generally, you should store application-specific files in the folder with your application, not
in any of these system-related directories. Your application may want to provide users with a
mechanism to specify a directory in which to look for auxiliary files. For example, you could
design a customized version of the open file dialog box that allows users to specify a path to
locations where files are stored. This technique may be useful for finding files that are shared
by several applications. It’s also possible to track the location of files by using the Alias
Manager. For details, see the Alias Manager chapter in this volume.
When you design your application, it’s important to consider the user’s view of the tools that
you provide. In most cases you'll want to build your application so that the user deals with one
icon that represents the entire set of abilities your application provides. This scheme simplifies
the user’s world by restricting the complexity of installing and maintaining your product. If
you provide optional tools—such as a dictionary and thesaurus—that have their own icons,
it’s a good idea to allow these tools to work from any location in the file system rather than
relying on their storage somewhere in the System Folder.

Finding

Directories

You can use the FindFolder function to get the path information you need to gain access to
the directories described in the previous section. Those you’re most likely to want to access
are Preferences, Temporary Items, and Trash. For example, you might wish to check for the
existence of a user’s configuration file in Preferences, create a temporary file in Temporary
Items, or—if your application runs out of storage when trying to save a file—check how
much storage is taken by items in the Trash directory and report this to the user.
The FindFolder function is available only in system software version 7.0. Use the Gestalt
function with the Gestalt selector gestaltFindFolderAttr. Test the bit field indicated by the
9-42

The System Folder and Its Related Directories

The Finder Interface
‘©

gestaltFindFolderPresent constant in the response parameter. If the bit is set, then the
FindFolder function is present.

=
mie
—_
e
ae
@
ax |
—

—

CONST

gestaltFindFolderPresent

=

0;

{if this bit
{ FindFolder
f

is
is

_
_
_
@
ax |
—_
As

set,
}
present}

el

O°
a)

Your application passes the FindFolder function a target volume and a constant that tells it
which directory you’re interested in. FindFolder returns a volume reference number and a
directory ID. If the specified directory does not exist, FindFolder can create it and return the
new directory ID.
Don’t assume files are on the same volume as your application; they could be on a different
local volume or on a remote volume on a network.
The system-related directories in system software version 7.0, the folder types of these
directories, and the constants that represent them are listed here.

Directory

Folder
type

Constant

Apple Menu Items
Control Panels
Desktop Folder
Extensions
Preferences
PrintMonitor Documents
Shared, network Trash directory
Single-user Trash directory
Startup Items
System Folder
Temporary Items

‘amnu'
‘earl’
‘desk’
‘extn’
‘pref’
‘prnt’
‘empt'
‘trsh’
"strt’
‘macs'
‘temp’

kAppleMenuFolderType
kControlPanelFolderType
kDesktopFolderType
kExtensionFolderType
kPreferencesFolderT
ype
kPrintMonitorDocsFolderT
ype
kWhereToEmptyTrashFolderT
ype
kTrashFolderType
kStartupFolderType
kSystemFolderType
kTemporaryFolderType

Note: The Finder identifies the subdirectories of the System Folder, and their folder
types, in a resource of type 'fld#' located in the System file. Do not modify or rely on
the contents of the 'fld#' resource in the System file; use only the FindFolder function
and these constants to find the appropriate directories.
Use the kTrashFolderType constant to locate the current user’s Trash directory for a
given volume—even one located on a file server. On a file server, you can use the
kWhereToEmptyTrashFolderType constant to locate the parent directory of all logged-on
users’ Trash subdirectories.
In calls to FindFolder, you can also use these three constants:
CONST

kOnSystemDisk
kCreateFolder
kDontCreateFolder

=

$8000;
TRUE;

{use vRefNum
for the
{create
folder
if it

FALSE;

{don't

create

boot disk}
doesn't
exist}

folder}

The System Folder and Its Related Directories

9-43

Inside Macintosh,

Volume

VI

Call the FindFolder function to get a volume reference number and directory ID for any of
these directories.
FUNCTION

FindFolder

(vRefNum:

Integer;

Boolean;

VAR

Longint)

:

folderType:

foundVRefNum:

OSType;

Integer;

createFolder:
VAR

foundDirID:

OSErr;

The FindFolder function returns the volume reference number and directory ID of a specified
folder type for a specified volume.
You specify a volume reference number (or the constant
kOnSystemDisk for the boot disk) in the vVRefNum parameter. In the folderType parameter,
specify a constant from the previous list. Use the constant kCreateFolder in the createFolder
parameter to tell FindFolder to create a directory if it does not already exist; otherwise, use the
constant kDontCreateFolder. FindFolder puts the results in foundVRefNum and foundDirID.
Remember that the specified folder used for a given volume might be located on a different
volume in the future; therefore, do not assume the volume that you specify in vVRefNum and
the volume returned in foundVRefNum will be the same.
Note: Directories inside the System Folder are created only if the System Folder
directory exists. FindFolder will not create a System Folder directory even if the
kCreateFolder constant is specified.
The FindFolder function returns a nonzero result code if the folder isn’t found, and it can also
return other file system errors reported by the File Manager or Memory Manager.
Result codes
noErr
fnfErr

43

dupFNErr

—48

DESKTOP

DATABASE

THE

0

No error
Type not found in 'fld#' resource, or disk doesn’t have
System Folder support or System Folder in volume
header, or disk does not have desktop database support for
Desktop Folder—in all cases, folder not found
File found instead of folder

For quick access to the resources it needs, the Finder maintains a central desktop database
of information about the files and directories on a volume. The Finder updates the database
when applications are added, moved, renamed, or deleted.

Normally, your application won’t need to use the information in the desktop database or to
use Desktop Manager routines to manipulate it. Instead, your application should let the Finder
manipulate the desktop database and handle such Desktop Manager tasks as launching applications when users double-click icons, maintaining user comments associated with files, and
managing the icons used by applications.
Although there may be instances where you would like to gain access to the desktop database by using Desktop Manager routines, you should never change, add to, or remove any
of this information. Manipulating the desktop database is likely to wreak havoc on your
users’ systems.
9-44

The Desktop Database

The Finder Interface

In case you should discover some important need to retrieve information from the desktop
database or even to change the desktop database from within your application, Desktop
Manager routines are provided for you to do so. While your application probably won’t ever
need to use them, for the sake of completeness they are described in this section.

\S

e

=
a
©
cr

—

=
=)
=
ry
i)
Q
©
>

Much of the information in the desktop database comes from the bundle resources for
applications and other files on the volume. (See “Finder Information in the Volume Catalog”
earlier in this chapter for a discussion on setting the bundle bit of an application so that its
bundled resources get stored in the desktop database.) The desktop database contains all icon
definitions and their associated file types. It lists all the file types that each application can
open and all copies or versions of the application that’s listed as the creator of a file. The
desktop database also lists the location of each application on the disk and any comments that
the user has added to the information windows for desktop objects. The Desktop Manager
provides a new set of routines that lets your application retrieve this information from the
desktop database. These are described in “Desktop Manager Routines” later in this chapter.
The Finder maintains a desktop database for each volume with a capacity greater than 2 MB.
For most volumes, such as hard disks, the database is stored on the volume itself. For readonly volumes—such as some compact discs—that don’t contain their own desktop database,
the Desktop Manager creates it and stores it in the System Folder of the boot drive.
Note: If you distribute read-only media, it is generally a good idea to store on each
volume both a desktop database (for users running system software version 7.0) and
a Desktop file (for users running older versions of system software). Create a desktop
database on your master volume by pressing Command-Option when booting your
system with system software version 7.0. Then create a Desktop file by pressing
Command-Option and restarting your system with version 6.0.
For compatibility with older versions of system software, the Finder keeps the information for ejectable volumes with a capacity smaller than 2 MB in a resource file instead of
a database.
Although the Desktop Manager provides tools for both reading and changing the desktop
database, your application should not ordinarily change anything in the database. You can
read the database to retrieve information, such as the icons defined by other applications.
Note: The desktop database doesn’t store customized icons (that is, those with
resource IDs of —16455 described in “Customized Icons” earlier in this chapter),
so your application can’t retrieve them by using Desktop Manager routines.

History

of the

Desktop

Database

In earlier versions of system software, Finder information for each volume was stored in the
volume’s Desktop file, a resource file created and used by the Finder and invisible to the
user. This strategy meets the needs of a single-user system with reasonably small volumes.
The Desktop file is still used on ejectable volumes with a capacity less than 2 MB so that
these floppy disks can be shared with Macintosh computers running earlier versions of
system software. (Note, however, that resources can’t be shared. Since the Finder is always
running in system software version 7.0, it keeps each floppy disk’s Desktop file open, so
your application can’t read or write it.)
The Desktop Database

9-45

Inside Macintosh,

Volume VI

Because resources can’t be shared, a different strategy has been used for AppleShare _
volumes, which are available to multiple users over a network. The Desktop Manager in
system software version 7.0 uses the strategy for large local volumes that AppleShare file
servers have previously used for shared volumes. When a volume is first mounted, the
Finder collects the bundle information from all applications on the disk and builds the desktop
database. Whenever an application is added to or removed from the disk, the Finder updates
the desktop database. Through Desktop Manager routines, the database is also accessible to
any other application running on the system.

Using

the Desktop

Database

You can manipulate the desktop database with a set of low-level routines that follow the
parameter-block conventions used by the File Manager. (For a description of parameter
blocks, see the File Manager chapter of Volume IV.)
The desktop database functions use this parameter block:
TYPE

DTPBRec

=

RECORD

qLink:

QElemPtr;

qType:
ioTrap:

Integer;
Integer;

i1oCmdAdar

:

1oCompletion:

ioResult:

ioNamePtr:

{routine

Ptr;

{routine

ProcPtr;

trap}

address}

{completion

OSErr;

{result

code}

routine}

StringPtr;

{file,

i1oDTRefNum:

Integer;
Integer;

ioIndex:
ioTagiInfo:
ioDTBuffer:
ioDTRegCount :
ioDTActCount:

Integer;
Longint;
Ptr;
Longint;
Longint;

{ volume
name}
{volume reference
{desktop
database
{ number}

ioVRefNum:

filleri:

directory,

SignedByte;

{unused}

SignedByte;

filler2:

{icon

Integer;

1oDirID:

ioFiller3:
LoDTLgLen:

ioDTPyLen:

Longint;

Longint;

Longint

The Desktop Database

number}
reference

directory

}

{

length
database}

{physical
{

OF

length

of

desktop

of

database}
Integer;

{unused}
{parent
directory

{

ID}

creator}
type}

{unused}
{logical

Longint;

LOAPPLParID:
END;

{parent

{file
{file

Longint;

ARRAY[1..14]

}

type}
{unused}

OSType;
OSType;

ioFiller4:

or

{index into icon list}
{tag information}
{data buffer}
{requested length of data}
{actual length of data}

ioIconType:

ioFileCreator:
ioFileType:

9-46

{next
queue entry}
{queue
type}

application}

ID

desktop

of

}

}

}

The Finder Interface

Because you cannot use the Desktop Manager functions on a disk that does not have a desktop
database, call PBHGetVolParms to verify that the target disk has a desktop database before
calling any of the Desktop Manager functions. (For a description of the PBHGetVolParms
function and the bHasDesktopM¢gr bit that you should check, see the File Manager chapter in
this volume.)

rr
—

=

e
—

@

“

—

=}—
oD
=

ure
ry

Because the Finder uses the desktop database, the database is almost always open. When
the Desktop Manager opens the database, it assigns the database a reference number that
represents the access path. Use the PBDTGetPath function to get the reference number,
which you must specify when calling most other Desktop Manager functions (see the
following section, “Desktop Manager Routines”). If the desktop database is not open,
PBDTGetPath opens it.

i)

sa)

If you are manipulating the database in the absence of the Finder, you can open the database
with PBDTOpenInform, which performs the same functions as PBDTGetPath and also sets
a flag to tell your application whether the desktop database was empty when it was opened.
Your application should never close the database.
The Desktop Manager provides different functions for manipulating different kinds of
information in the database. Not all manipulations are possible with all kinds of data.
You can retrieve five kinds of information from the database:

mw

x

icon definitions

file types and icon types supported by a known creator
m= name and location of applications with a known creator
m user comments for a file or a directory
size and parent directory of the desktop database
To retrieve an icon definition, call PBDTGetIcon. You must specify a file creator, file type,
and icon type. The database recognizes both large and small icons, with 1, 4, or 8 bits of color
encoding. (See the earlier description of icons in “Finder-Related Resources” for details.)
To step through a list of all the icon types supported by an application, make repeated calls
to PBDTGetlconInfo. Each time you call PBDTGetIconInfo, you specify a creator and an
index value. Set the index to | on the first call, and increment it on each subsequent call until
PBDTGetIconInfo returns the result code afpItemNotFound. For each entry in the icon
list, PBDTGetIconInfo reports the icon type, the file type it is associated with, and the size of
its icon data.
To identify the application that can open a file with a given creator, call PBDTGetAPPL. In
each call to PBDTGetAPPL, you specify a creator (which is the application’s signature) and
an index value. An index value of 0 retrieves the “first choice” application—that is, the one
with the most recent creation date. By setting the index to | on the first call and incrementing it
on each subsequent call until PBDTGetAPPL returns the result code afpItemNotFound,
you can make multiple calls to PBDTGetAPPL to find all copies or versions of the application with this signature on the disk. PBDTGetAPPL returns them all in arbitrary order.
PBDTGetAPPL returns the name, parent directory ID, and creation date of each application
in the desktop database.
The Desktop Database

9-47

Inside Macintosh,

Volume VI

To retrieve the user comments for a file or directory, call PBDTGetComment. The user can
change comments at any time by typing in the comment box of the information window for
any desktop object.
Your application should not ordinarily call the functions for adding and removing data to and
from the database. If your application does need to write to or delete information from the
desktop database, it must call PBDTFlush to update the copy stored on the volume.
The following list summarizes the data manipulation functions.
Kind

of data

Read

Write

Remove

Icon definitions

PBDTGetlIcon

PBDTAddIcon

_—

Icon types
supported by
an application

PBDTGetlIconInfo

—

—_

PBDTAddAPPL

PBDTRemoveAPPL

Applications with
a given creator

© PBDTGetAPPL

User comments

PBDTGetComment

PBDTSetComment

PBDTRemoveComment

Entire desktop
database

PBDTGetInfo
(returns the size and
parent directory of
the database)

PBDTFlush
(updates the copy
stored on the
volume)

PBDTDelete and
PBDTReset (neither
should be called by
your application)

Desktop

Manager

Routines

This section describes the low-level routines for using the desktop database.
All low-level routines exchange parameters with your application through a parameter block.
When calling a low-level routine, you pass a pointer to the parameter block. See the introduction to low-level routines in the File Manager chapter of Volume IV for a description of the
standard parameters in a low-level routine.
Three Desktop Manager functions—namely, PBDTGetPath, PBDTOpenInform, and
PBDTCloseDown—trun synchronously only. All other Desktop Manager routines can
run either asynchronously or synchronously. There are three versions of each of these
routines. The first version takes two parameters: a pointer to the parameter block, and a
Boolean value that determines whether the routine is run asynchronously (TRUE) or

synchronously (FALSE). Here, for example, is the first version of a routine that retrieves
the user’s comment stored for a file or a directory:
FUNCTION

PBDTGetComment

(paramBlock:

DTPBPtr;

async:

Boolean)

:

OSErr;

The second version does not take a second parameter; instead, it adds the suffix “Async”’ to
the name of the routine.
FUNCTION

9-48

PBDTGetCommentAsync

The Desktop Database

(paramBlock:

DTPBPtr)

:

OSErr;

The Finder Interface

Similarly, the third version of the routine does not take a second parameter; instead, it adds

the suffix “Sync” to the name of the routine.
FUNCTION

PBDTGetCommentSync

‘S

=i

=

ome

—
i!
—

(paramBlock:

DTPBPtr)

:

@
=

OSErr;

—
—

—

onal
7)

ex!

All routines in this section are documented using the first version only. Note, however, that
the second and third versions of these routines do not use the glue code that the first versions
use and are therefore more efficient.

Assembly-language note: You can invoke each of the Desktop Manager
routines with a macro that has the same name as the routine preceded by an
underscore. These macros, however, aren’t really trap macros. Instead, they
expand to invoke the trap macro _HFSDispatch. The File Manager determines
which routine to execute from the routine selector, an integer placed in register
DO. The routine selectors appear in the assembly-language information in the
chapter summary.

Locating

and

Opening

the Desktop

Database

To get the access path to a database or to create a database if one doesn’t exist, use the
PBDTGetPath or PBDTOpenInform function. These routines run synchronously only.
FUNCTION

PBDTGetPath

Parameter block
on
16

(paramBlock:

DTPBPtr)

:

OSErr;

ioResult

word

result code

>

18

ioNamePtr

long

volume name or full pathname

>

22

ioVRefNum

word

volume reference number

—

24

ioDTRefNum

word

desktop database reference number

PBDTGetPath returns the desktop database reference number in the ioDTRefNum field, which
represents the access path to the database. You specify the volume by passing a pointer to its
name in the ioNamePtr field or a volume reference number in the ioVRefNum field. If the
desktop database is not already open, PBDTGetPath opens it and then returns the reference
number. If the desktop database doesn’t exist, PBDTGetPath creates it. If PBDTGetPath fails,
it sets the ioDTRefNum field to 0.

Note: You cannot use the desktop reference number as a file reference number in
any File Manager calls.
A

Warning: Do not call PBDTGetPath at interrupt time—it allocates memory in
the system heap. a

The Desktop Database

9-49

=
ba)
i)
@

Inside Macintosh, Volume VI

Result codes
noErr
ioErr
extFSErr
desktopDamagedErr

Q
—36
—58
-—1305

Noerror
= I/O error
External file system—file system identifier is nonzero
— The desktop database has become corrupted—the
Finder will fix this, but if your application is not running with the Finder, use PBDTReset or PBDTDelete

PBDTOpenInform performs the same function as PBDTGetPath, but it also reports whether
the desktop database was empty when it was opened.
FUNCTION

PBDTOpenInform

Parameter block
—
16

(paramBlock:

DTPBPtr)

:

OSErr;

ioResult

word

result code

>

18

ioNamePtr

long

volume name or full pathname

53

22

ioVRefNum

word

volume reference number

—

24

ioDTRefNum

word

desktop database reference number

a

28

ioTagInfo

long

return flag (in low bit)

If the desktop database was just created in response to PBDTOpenInform (and is therefore
empty), PBDTOpenInform sets the low bit in the ioTagInfo field to 0. If the desktop database
had been created before you called PBDTOpenInform, PBDTOpenInform sets the low bit in
the ioTagInfo field to 1.
Result codes
noErr
ioErr
paramErr
extFSErr
desktopDamagedErr

0
-36
-50
-58
-1305

Noerror
J/Oerror
Parameter error; use PBDTGetPath
External file system—file-system identifier is nonzero
— The desktop database has become corrupted—the
Finder will fix this, but if your application is not running with the Finder, use DTReset or DTDelete

The PBDTCloseDown function is used by system software to close the desktop database,
though your application should never do this itself. PBDTCloseDown runs synchronously
only, and though it will not close down the desktop databases of remote volumes, it will
invalidate all local DTRefNum values for remote desktop databases.
FUNCTION

PBDTCloseDown

(paramBlock:

DTPBPtr;)

:

OSErr;

Parameter block
—

16

ioResult

word

result code

4

24

ioDTRefNum

word

desktop database reference number

PBDTCloseDown closes the database specified in ioDTRefNum and frees all resources
allocated by PBDTOpenInform or PBDTGetPath.
9-50

The Desktop Database

The Finder Interface

A

=

Warning: Applications should not call PBDTCloseDown. The system software
closes the database when the volume is unmounted. a

Lee wy

—e
=

o.
ic)
—

=
i)

Result codes
noEff
ioErr
rfNumErr
extFSErr

Reading

the

a

0
—36
—51
—58

Desktop

No error
I/O error
Reference number invalid
External file system—file system identifier is nonzero

Database

To retrieve an icon definition, use the PBDTGetlIcon function.
FUNCTION

PBDTGetIcon

(paramBlock:

DTPBPtr;

async:

Boolean)

:

OSErr;

tbh

Tbh

Tita

Parameter block

12

ioCompletion

long

completion routine

16

ioResult

word

result code

24

ioDTRefNum

word

database reference number

28

ioTagInfo

long

reserved; must be initialized to 0

32

ioDTBuffer

long

pointer to icon data

36

ioDTReqCount

long

requested size of icon bitmap

40

ioDTActCount

long

actual size of icon bitmap

45

iolconType

byte

icon type

52

ioFileCreator

long

icon’s file creator

56

ioFileType

long

icon’s file type

PBDTGetlcon returns the bitmap for an icon that represents a file of a given type and creator.
You pass a pointer to the buffer for the icon bitmap in the ioDTBuffer field. The bitmap is
returned in the buffer pointed to by ioDTBuffer. You specify the desktop database in
ioDTRefNum, the file creator in ioFileCreator, and the file type in ioFileType. For the icon
type in iolconType, specify a constant from the following list.

—
WN

kLargelcon
kLarge4BitIcon
kLarge8BitIcon
kSmalllcon
kSmall4BitIcon
kSmall8BitIcon

Corresponding
resource type

Description

‘'ICN#'
‘icl4'
icl8'
ics#'
ics4'
ics8'

Large black-and-white icon with mask
Large 4-bit color icon
Large 8-bit color icon
Small black-and-white icon with mask
Small 4-bit color icon
Small 8-bit color icon

Value

'
'

'

Nn

Constant

!

The Desktop Database

9-5]

Low

|

ar)

iS)
ir)
@

Inside Macintosh, Volume VI

The value you supply in ioDTReqCount is the size in bytes of the buffer that you’ve allocated
for the icon’s bitmap pointed to by ioDTBuffer; this value depends on the icon type. Be sure
to allocate enough storage for the icon data; 1024 bytes is the largest amount required for any
icon under system software version 7.0. You can use a constant from the following list.

Constant

Value
(bytes in
bitmap)

Corresponding
resourcetype

Description

kLargeIconSize
kLarge4BitIconSize
kLarge8BitIconSize
kSmallIconSize
kSmall4BitIconSize
kSmall8BitIconSize

256
512
1024
64
128
256

'ICN#'
‘icl4'
‘icl8'
'ics#'
‘ics4'
‘ics8'

Large black-and-white icon with mask
Large 4-bit color icon
Large 8-bit color icon
Small black-and-white icon with mask
Small 4-bit color icon
Small 8-bit color icon

The value in ioDTActCount reflects the size of the bitmap actually retrieved. If ioDTActCount
is larger than ioDTReqCount, only the amount of data allowed by ioDTReqCount is valid.
Result codes

noErr
ioErr
rfNumErr
extFSErr
afpltemNotFound

0
—36
-51
—58
-5012

No error
I/O error
Reference number invalid
External file system—file system identifier is nonzero
Information not found

To retrieve the icon type and associated file type, use the PBDTGetIconInfo function.
FUNCTION

PBDTGetIconInfo

(paramBlock:

DTPBPtr;

async:

Boolean)

OSErr;

Parameter block
>

12

ioCompletion

long

completion routine

—

16

ioResult

word

result code

~

24

ioDTRefNum

word

database reference number

>

26

ioIndex

word

index into icon list

-

28

ioTagInfo

long

reserved; must be initialized to 0

<-

40

ioDTActCount

long

size of icon bitmap

<

45

iolconType

byte

icon type

>

52

ioFileCreator

long

icon’s file creator

-

56

ioFileType

long

icon’s file type

PBDTGetlconInfo retrieves the icon type and the associated file type of an icon in the database. You use it to identify the set of icons associated with a given creator. You specify the
creator by placing its signature in ioFileCreator, and you specify the database by placing
the desktop database reference number in the ioDTRefNum field. PBDTGetIconInfo returns
9-52

The Desktop Database

The Finder Interface
—

the size of the bitmap in ioDTActCount, the file type in ioFileType, and the icon size and
color depth in iolconType.

rr

me
~
ae
(om!

—

@
“

See the previous description of the PBDTGetIcon function for a list of values and their
constants returned by PBDTGetIconInfo in the iolconType field. Ignore any values that
may be returned in iolconType and that are not listed there; they represent special icons
used only by the Finder.

—

=]

os

@
“i
nee
©
©
@

To step through a list of the icon types supported by an application, make repeated calls to
PBDTGetlconInfo, specifying a creator and an index value for ioIndex each call. Set the
index to | on the first call, and increment it on each subsequent call until ioResult returns
afpItemNotFound.
Result codes

noErr
ioErr
rfNumErr

extFSErr
afpltemNotFound

0)
—36
—5]

—58
-—5012

No error
I/O error
Reference number invalid

External file system—file system identifier is nonzero
Information not found

To identify the application that can open a file with a given creator, use the PBDTGetAPPL
function.
FUNCTION

PBDTGetAPPL

(paramBlock:

DTPBPtr;

async:

Boolean)

:

OSErr;

Parameter block

>

12

ioCompletion

long

completion routine

—

16

ioResult

word

result code

ad

18

ioNamePtr

long

pointer to application’s name

oa

24

ioDTRefNum

word

database reference number

>

26

ioIndex

word

index into application list

-

28

ioTagInfo

long

application’s creation date

>

52

ioFileCreator

long

application’s signature

—

100

ioAPPLParID

long

application’s parent directory

For an application in the database specified in ioDTRefNum with the signature specified in
ioFileCreator, PBDTGetAPPL returns the filename in ioNamePtr, the parent directory ID in
ioAPPLParID, and the creation date in ioTagInfo. A single call, with ioIndex set to 0, finds the
application file with the most recent creation date. If you want to retrieve all copies of the application with the given signature, start with ioIndex set to | and increment until ioResult returns
afpItemNotFound; when called multiple times in this fashion, PBDTGetAPPL returns the
application’s copies, including the file with the most recent creation date, in arbitrary order.
Result codes

noErr
ioErr
rfNumErr
extFSErr
afpItemNotFound

0
—36
—5|
—58
-—5012

No error
I/O error
Reference number invalid
External file system—file system identifier is nonzero
Information not found
The Desktop Database

9-53

Inside Macintosh,

Volume

V1

To retrieve the user comments for a file or directory, use the PBDTGetComment function.
FUNCTION

PBDTGetComment

(paramBlock:

DTPBPtr;

async:

Boolean)

:

OSErr;

Parameter block

>

12

ioCompletion

long

completion routine

<<

16

ioResult

word

result code

—

18

ioNamePtr

long

pointer to file or directory name

>

24

ioDTRefNum

word

desktop database reference number

>

32

ioDTBuffer

long

pointer to comment text (200 bytes)

<-

40

ioDTActCount

long

comment size

>

48

ioDirID

long

parent directory of file or directory

PBDTGetComment retrieves the comment stored for a file or directory in the database specified in ioDTRefNum. You specify the filename or directory name and its parent directory ID
through ioNamePtr and ioDirID. You allocate a buffer big enough to hold the largest
comment, 200 bytes, and put a pointer to it in the ioDTBuffer field. PBDTGetComment
places the comment in the buffer as a plain text string and places the length of the comment
in ioDTActCount.
Result codes

noErr
ioErr
fnfErr
rfNumErr
extFSErr
afpltemNotFound

Adding

0
—36
—43
5]
—58
-5012

to the Desktop

No error
I/O error
File or directory doesn’t exist
Reference number invalid
External file system—file system identifier is nonzero
Information not found

Database

Your application should not ordinarily call the functions for adding data to the database.
If your application does need to write to or delete information from the desktop database, it
must call PBDTFlush to update the copy stored on the volume.
To add an icon definition to the desktop database, use the PBDTAddIcon function.
FUNCTION

PBDTAddIcon

(paramBlock:

DTPBPtr;

async:

Boolean)

:

OSErr;

Parameter block

9-54

-

12

ioCompletion

long

completion routine

—

16

ioResult

word

result code

~

24

ioDTRefNum

word

desktop database reference number

>

28

ioTagInfo

long

reserved; must be initialized to 0

=

32

ioDTBuffer

long

pointer to icon data

The Desktop Database

The Finder Interface
NS

>

36

ioDTReqCount

long

-

45

iolconType

byte

size of icon bitmap
icon type

>

52

ioFileCreator

long

icon’s file creator

ae

56

ioFileType

long

icon’s file type

|
=)

i=
7)
“

—

—_
_
~-

7)

=
Me

PBDTAddlcon adds an icon definition to the desktop database specified in ioDTRefNum.
You specify the creator and file type that the icon is associated with in the ioFileCreator and
ioFileType fields. For the icon type in iolconType, specify either a constant or a value from
the following list.

Constant
kLargelcon
kLarge4BitIcon
kLarge8BitIcon
kSmalllcon
kSmall4BitIcon
kSmall8BitIcon

Value
l
2
3
4
5
6

Corresponding
resource type _—_ Description
'ICN#'
‘icl4'
‘icl8'
‘iCS#'
‘ics4'
‘ics8'

Large black-and-white icon with mask
Large 4-bit color icon
Large 8-bit color icon
Small black-and-white icon with mask
Small 4-bit color icon
Small 8-bit color icon

The value you supply in ioDTReqCount is the size in bytes of the buffer that you’ve allocated
for the icon’s bitmap pointed to by ioDTBuffer; this value depends on the icon type. Be sure
to allocate enough storage for the icon data; 1024 bytes is the largest amount required for any
icon under system software version 7.0. You can use a constant from the following list.

Constant

Value
(bytesin
bitmap)

Corresponding
resource type

Description

kLargeIconSize
kLarge4BitIconSize
kLarge8BitIconSize
kSmalllconSize
kSmall4BitlconSize
kSmall8BitlconSize

256
512
1024
64
128
256

'ICN#'
‘icl4'
‘icl8'
'iCS#'
‘ics4'
‘ics8'

Large black-and-white icon with mask
Large 4-bit color icon
Large 8-bit color icon
Small black-and-white icon with mask
Small 4-bit color icon
Small 8-bit color icon

You pass a pointer to the icon bitmap in the ioDTBuffer field. You must initialize the ioTagInfo
field to 0.
If the database already contains an icon definition for an icon of that type, file type, and file
creator, the new definition replaces the old.
Result codes

noErr
ioErr
wPrErr
vLckdErr
rfNumErr
extFSErr
afpIconTypeError

0)
—36
—t4
—46
—5]
—58
—5030

No error
I/O error
Volume is locked through hardware
Volume is locked through software
Reference number invalid
External file system—file system identifier is nonzero
Sizes of new icon and one it replaces don’t match
The Desktop Database

9-55

ps
C
®

Inside Macintosh,

Volume VI

To add an application to the desktop database, use the PBDTAddAPPL function.
FUNCTION

PBDTAGGAPPL

Parameter block
=>
12

(paramBlock:

DTPBPtr;

async:

Boolean)

ioCompletion

long

completion routine

:

OSErr;

<-

16

ioResult

word

result code

>

18

ioNamePtr

long

pointer to application’s name

>

24

ioDTRefNum

word

desktop database reference number

~

28

ioTagInfo

long

reserved; must be set to 0

>

48

ioDirID

long

application’s parent directory

>

52

ioFileCreator

long

application’s signature

PBDTAddAPPL adds an entry in the desktop database specified in ioDTRefNum for an
application with the specified signature. You pass the application’s signature in ioFileCreator,
a pointer to the application’s filename in ioNamePtr, and the application’s parent directory ID
in ioDirID. Initialize ioTagInfo to 0.
Result codes

noErr
ioErr
fnfErr
wPrErr
vLckdErr
rfNumErr
extPSErr

0
—36
—43
—t4
—46
5]
—58

No error
1/O error
Application not present on volume
Volume is locked through hardware
Volume is locked through software
Reference number invalid
External file system—file system identifier is nonzero

To add a user comment for a file or a directory to the desktop database, use the
PBDTSetComment function.
FUNCTION

PBDTSetComment

Parameter block
>
12

(paramBlock:

DTPBPtr;

async:

Boolean)

ioCompletion

long

completion routine

:

OSErr;

-

16

ioResult

word

result code

->

18

ioNamePtr

long

pointer to file or directory name

-

24

ioDTRefNum

word

desktop database reference number

—

32

ioDTBuffer

long

pointer to comment text

>

36

ioDTReqCount

long

comment length

=>

48

ioDirID

long

parent directory of file or directory

PBDTSetComment establishes the user comment associated with a file or directory in the
database specified in ioDTRefNum. You specify the object name through ioNamePtr and the
parent directory ID in ioDirID. You put the comment as a plain text string in a buffer pointed
9-56

The Desktop Database

The Finder Interface

to by ioDTBuffer, and you specify the length of the buffer (in bytes) in ioDTReqCount. The
maximum length of a comment is 200 bytes; longer comments are clipped. Since the comment is a plain text string and not a Pascal string, the Desktop Manager relies on the value in
ioDTReqCount for determining the length of the buffer.
If the specified object already has a comment in the database, the new comment replaces the old.
Result codes
noErr
ioErr
fnfErr
wPrErr
vLckdErr
rfNumErr
extFSErr

0
—36
43
tH
—46
5]
—58

No error
I/O error
File or directory doesn’t exist
Volume is locked through hardware
Volume is locked through software
Reference number invalid
External file system—file system identifier is nonzero

Deleting Entries From the Desktop Database
Your application should not ordinarily call the functions for adding and removing data to and
from the database. If your application does need to write to or delete information from the
desktop database, it must call PBDTFlush to update the copy stored on the volume.
To remove an application from the desktop database, call the PBDTRemoveAPPL function.
FUNCTION

PBDTRemoveAPPL

Parameter block
~
12

(paramBlock:

DTPBPtr;

async:

Boolean)

ioCompletion

long

completion routine

:

OSErr;

+

16

ioResult

word

result code

-

18

ioNamePtr

long

pointer to application’s name

—

24

ioDTRefNum

word

desktop database reference number

>

48

ioDirID

long

application’s parent directory

>

32

ioFileCreator

long

application’s signature

PBDTRemoveAPPL removes the mapping information for an application from the database
specified in ioDTRefNum. You specify the application’s name through ioNamePtr, its parent
directory ID in ioDirID, and its signature in ioFileCreator.
You can call PBDTRemoveAPPL even if the application is not present on the volume.
Result codes

noErr
i0Err
wPrErr
vLckdErr
rfNumErr
extFSErr
afpItemNotFound

0
—36
—t4
—46
5]
—58
-5012

No error
I/O error
Volume is locked through hardware
Volume is locked through software
Reference number invalid
External file system—file system identifier is nonzero
Application not found
The Desktop Database

9-57

\o

i?
ee
_

—

=

@

=

—

=)
@

=e
=

=
©
@

Inside Macintosh,

Volume VI

To remove a user comment from the desktop database, call the PBDTRemoveComment function.
FUNCTION

PBDTRemoveComment

(paramBlock:

async:

DTPBPtr;

Boolean)

OSErr;

Parameter block
>
12

ioCompletion

long

completion routine

—

16

ioResult

word

result code

—>

18

ioNamePtr

long

pointer to filename or directory name

>

24

ioDTRefNum

word

database reference number

>

48

ioDirID

long

parent directory of file or directory

PBDTRemoveComment removes the comment associated with a file or directory from
the database specified in ioDTRefNum. You specify the file or directory name through
ioNamePtr and the parent directory ID in ioDirID. You cannot remove a comment if the
file or directory is not present on the volume. If no comment was stored for the file,
PBDTRemoveComment returns an error.
Result codes

noErr
ioErr
fnfErr
wPrErr
vLckdErr
rfNumErr
extFSErr
afpItemNotFound

Manipulating

0
—36
43
—44
46
—5]
—58
-5012

the Desktop

No error
I/O error
File or directory doesn’t exist
Volume is locked through hardware
Volume is locked through software
Reference number invalid
External file system—file system identifier is nonzero
Comment not found

Database

Itself

To save your changes to the desktop database, use the PBDTFlush function.
FUNCTION

PBDTFlush

(paramBlock:

DTPBPtr;

async:

Boolean)

:

OSErr;

Parameter block

>

12

ioCompletion

long

completion routine

ce

16

ioResult

word

result code

->

24

ioDTRefNum

word

database reference number

PBDTFlush writes the contents of the desktop database specified in ioDTRefNum to the volume.
Note: If your application has manipulated information in the database using any
of the routines described earlier in “Desktop Manager Routines,” you must call
PBDTFlush to update the copy stored on the volume.
9-58

The Desktop Database

The Finder Interface
)

Result codes
noErr
ioErr

wPrErr
vLckdErr
rfNumErr
extFSErr

0
—36

—
=,
=
—

No error
I/O error

—A4
—-46
-5]
—-58

o.
)
“

Volume is locked through hardware
Volume is locked through software
Reference number invalid
External file system—file system identifier is nonzero

—

—
~
@

Ty
er)
ie)

To determine the parent directory and the amount of space used by the desktop database on a
particular volume, use the PBDTGetInfo function.
FUNCTION

PBDTGetInfo

Parameter block
=
12

(paramBlock:

DTPBPtr;

async:

Boolean)

:

ioCompletion

long

completion routine

OSErr;

oan

16

ioResult

word

result code

oO

24

ioDTRefNum

word

desktop database reference number

>

26

ioIndex

word

number of files in desktop database

<

48

ioDirID

long

parent directory of desktop database

-

64

ioDTLgLen

long

logical length of database files

e

68

ioDTPyLen

long

physical length of database files

Specify the volume of the desktop database in ioDTRefNum. The parent directory of the
desktop database for the volume is returned in ioDirID. The sum of the logical lengths of the
files that constitute the desktop database for a given volume is returned in ioDTLgLen; the
sum of the physical lengths of the files that constitute the desktop database for a given volume
is returned in ioDTPyLen. The number of files maintained by the Desktop Manager is
returned in ioIndex. The volume containing the file is returned in ioDTRefNum.
Result codes

noErr
ioErr
rfNumErr
extFSErr

0
—36
-—-51
—-58

No err
I/O error
Reference number invalid
External file system—file system identifier is nonzero

The PBDTReset and PBDTDelete functions remove information from the desktop database.
Unless you are manipulating the desktop database in the absence of the Finder, you should
never use these functions.
FUNCTION

PBDTReset

(paramBlock:

DTPBPtr;

async:

Boolean)

:

OSErr;

Parameter block

>

12

ioCompletion

long

completion routine

-

16

ioResult

word

result code

=>

24

ioDTRefNum

word

database reference number

—

26

ioIndex

word

must be 0

The Desktop Database

9-59

Inside Macintosh,

Note:

Volume VI

Your application should never call PBDTReset.

PBDTReset removes all icons, application mappings, and comments from the desktop
database specified in ioDTRefNum. You can call PBDTReset only when the database is
open. It remains open after the data is cleared.
Result codes
noErr
ioErr
wPrErr
vLckdErr
rfNumErr
extFSErr
FUNCTION

36
44
46
Si
58

0

No error
I/O error
Volume is locked through hardware
Volume is locked through software
Reference number invalid
External file system—file system identifier is nonzero
(par amBlock:

PBDTDelete

DTPBPtr;

async:

Boolean)

:

OSErr;

Parameter block

=>

12

ioCompletion

long

completion routine

on

16

ioResult

word

result code

SS

22

ioVRefNum

word

volume reference number

>

26

ioIndex

word

must be 0

Note:

Your application should never call PBDTDelete.

PBDTDelete removes the desktop database from a local volume. You specify the volume by
passing a volume reference number in ioVRefNum. You can call PBDTDelete only when the
database is closed.
Result codes
noErr
ioErr
wPrErr
vLckdErr
rfNumErr
extFSErr

9-60

—36

46
5]
58

No error
I/O error
Volume is locked through hardware
Volume is locked through software
Reference number invalid
External file system—file system identifier is nonzero

The Desktop Database

The Finder Interface

SUMMARY

OF

THE

FINDER

INTERFACE

Constants
CONST

{Gestalt

selectors}

gestaltFindFolderAttr
{interpreting

=

Gestalt

selector

gestaltFindFolderPresent

{for

custom

{selector

=

0%

{if this bit
{ FindFolder

=

-16455;

{resource
ID for
icon}
{ custom

mapping

icons

to

ioIconType

in

the

desktop

1;

{ 'ICN#' }

kLarge4BitIcon

=

29

{*2e14"}

kLarge8BitIcon

=

3%

{'icl8'}

kSmalliIcon

=

as

{'ics#'}

kSmall4BitIcon
kSmal1l8BitIcon

=
=

Sy

{'ics4'}
{'ics8'}

allocating

storage

for

icon

data

in

the

desktop

kLargeIconSize

=

256;

{' ICN#' }

kLarge4BitIconSize

=

S12

f{iEe14*}

kLarge8BitIconSize
kSmallIconSize

=
=

1024;
G47

{*icls"}
{'ics#'}

kSmall4BitIconSize

=

128;

{'1084*"}

kSmall18BitIconSize

=

256;

{'ics8'}

=
=

8192;
16384;

{set
{set

kOnSystemDisk

=

$8000;

{use vRefNum
disk}
{ boot

kCreateFolder

=

TRUE;

{create

Finder

set,
}
present}

}

database}

flags}

fHasBundle
fInvisible
{for

is
is

database}

=

{for

FindFolder}

responses}

kLargeIcon

{for

for

icons}

kCustomIconResource

{for

"fold";

if
if

file
icon

has a bundle}
is invisible}

FindFolder}

{
kDontCreateFolder

for

folder

doesn't

}

it

}

if

exist}

=

FALSE;

{don't

=
=

"macs;
‘'desk';

{System Folder}
{Desktop
Folder}

kTrashFolderType

=

“treh*?

{single-user

kWhereToEmptyTrashFolderType

=

‘empt';

{shared,

kPrintMonitorDocsFolderType

=

‘'prnt';

{PrintMonitor
{ folder}

{for special
folder
kSystemFolderType
kDesktopFolderType

the

create

folder}

types}

Trash

network

dir}

Trash}

Documents

Summary of the Finder Interface

}

9-61

Inside Macintosh, Volume VI

kStartupFolderType

'SCrt" s

{Startup

kAppleMenuFolderType

‘amnu';

{Apple

kControlPanelFolderType

‘otal 3

{Control

kExtensionFolderType

"extn" >

{Extensions

kPreferencesFolderType

‘pret’:

kTemporaryFolderType

‘temp';

{Preferences
folder}
{Temporary
Items
folder}

{for alias types}
kContainerFolderAliasType

‘rarp" +

kContainerTrashAliasType

‘'trsh';

kContainerHardDiskAliasType

"hdsk';

kContainerFloppyAliasType

zing" ¢

kContainerServerAliasType

“srvr"* ;

kApplicationAliasTyve

‘adrp';

Items

Menu

folder}

Items

Panels

folder}

folder}

{'file'
type for
{ aliases}
{'file'
type for
{ folder aliases}
{'file'
type for
{ disk aliases}
{'file'
type for
{ disk aliases}
{'file'
type for
{ aliases}
{'file'
type for
{

folder}

application

folder

}

Trash

}

hard

}

floppy

}

server

}

}

aliases}

kContainerAliasType

'drop';

{'file'
{ other

type for all
containers}

kSystemFolderAliasType

'fasy';

{'file'

type

kAppleMenuFolderAliasType

'faam';

{ Folder alias}
{'file'
type for Apple }
{ Menu Items folder alias}

kStartupFolderAliasType

'fast';

{'file'

type

{

folder

Items

for

for

}

System

}

Startup

}

alias}

kPrintMonitorDocsFolderAliasType
‘fapn';
kPreferencesFolderAliasType

'fapt';

kControlPanelFolderAliasType

‘face;

kExtensionFolderAliasType

'faex';

kExportedFolderAliasType

'faet';

{'file'

type

‘Paar:

{

alias}

{'file'

kDropFolderAliasType

9-62

{'file'
type for Print- }
{ Monitor Doc alias}
{'file'
type for Prefer- }
{ ences folder alias}
{'file'
type for Control
}
{ Panels folder alias}
{'file'
type for Exten- }
{ sion folder alias}
folder

type

for
for

kSharedFolderAliasType

'fash';

{ folder alias}
{'file'
type for
{ folder alias}

kMountedFolderAliasType

‘famn';

{'file'

type

{

alias}

Summary of the Finder Interface

folder

for

export
drop

}
}

shared
mounted

}
}

The Finder Interface

Data
TYPE

N=

Types

s

DTPBPtr

=

DTPBRec

=

RECORD

“
s

*DTPBRec;
{parameter

block

qLink:

QElemPtr;

{next

qType:

Integer;

{queue

for

queue

desktop

database}

A

type}

ioTrap:

Integer;

{routine

trap}

Pie:

{routine

address}

ioCompletion:
ioResult:
ioNamePtr:

ProcPtr;
OSErr;
StringPtr;

{completion routine}
{result code}
{file,
directory,
or

ioVRefNum:

Integer;

{volume

ioDTRefNum:

Integer;

{desktop

ioIndex:

Integer;

{index

1oTaginfo:
i1oDTBuffer:

LongInt;
Ptr;

{tag information}
{data buffer}

1oDTReqCount:
ioDTActCount:

LongInt;
LongInt;

{requested
length
{actual
length of

fillerl:
iolconType:

SignedByte;
SignedByte;

{unused}
{icon type}

reference

Integer;

{unused}

LongInt;
OSType;
OSType;
LongiInt;

{parent directory
{file creator}
{file type}
{unused}

ioDTLgLen:

Longint;

{logical

LongInt;
ARRAY[1..14]

OF

number}

list}

of data}
data}

ID}

of

desktop

}

database}

{physical
{

ioFiller4:

length

name}

reference

icon

filler2:

volume

number}

database

into

i1oDirID:
ioFileCreator:
ioFileType:
ioFiller3:

LoDTPyLen:

s

entry}

ioCmdAddr:

{

©

length

of

desktop

}

database}
Integer;

{unused}
LOAPPLParID:

Longint

{parent
directory
{ application}

ID

of

}

END;

VersRecPtr
VersRecHndl
versRec

RECORD

=
=

“VersRec;
“VersRecPtr;

=

version

part

numericVersion:

NumVersion;

{numeric

{encoded

version

of

'vers'

countryCode:
shortVersion:

Integer;
Str255;

{region code
from int'l
{version number
string,

reserved:

Str255

{longMessage
string
{ shortVersion}

resource}

number}
utils}
worst
case}

packed

after

}

END;

Summary of the Finder Interface

9-63

Inside Macintosh, Volume VI

{Finder

information

records

in

the

volume

catalog}

FInfo
=
RECORD

fdType:
fdCreator:

OSType;
OSType;

{file
{file

type}
creator}

fdFlags:

Integer;

{Finder

fdLocation:
fdFldr:

Point;
Integer

{file's location in directory}
{directory that contains file}

flags}

END;

FXInfo

=

RECORD
fdIconID:

Integer;

{icon
OF

ID}

fdUnused:

ARRAY[1..3]

Integer;

fdScript:
fdXFlags:
fdComment :
fdPutAway:

SignedByte;
SignedByte;
Integer;
LongiInt

{script flag and
{reserved}
{comment ID}
{home dir ID}

ErSereli:

Point;

{scroll

position}

frOpenChain:
CFSeripe:

LongInt;
SignedByte;

{dir ID
{script

chain of
flag and

frXFlags:
frComment :

SignedByte;
Integer;

{reserved}
{comment }

frPutAway :

Longint

{dir

{unused

but

reserved

6

bytes}

code}

END;

DXInfo
RECORD

=

open
folders}
code}

ID}

END;

Routines

Resolving
FUNCTION

Alias Files

ResolveAliasFile

(VAR

theSpec:

FSSpec;

resolveAliasChains:

Boolean;
VAR targetIsFolder:
Boolean;
wasAliased:
Boolean)
OSErr;

Finding

Directories

FUNCTION

FindFolder

Locating

and Opening

FUNCTION

PBDTGet

FUNCTION
FUNCTION

9-64

VAR

Path

(vRefNum:

Integer;

folderType:

createFolder:

Boolean;

Integer;

foundDirID:

VAR

the Desktop

VAR

OSType;
foundVRefNum:

LongInt)

Database

(paramBlock:

DTPBPtr)

OSErr;

PBDTOpeniInform

(paramBlock:

DTPBPtr)

OSErr;

PBDTCloseDown

(paramBlock:

DTPBPtr)

OSErr;:

Summary of the Finder Interface

OSErr;

The Finder Interface

Reading

the

Desktop

~
=

Database

—
“J

a
co
_
~

_—

&

-

FUNCTION

PBDTGet Icon

(paramBlock:

DTPBPtr;

async:

Boolean)

;

er
_
_—

OSErr;

—

@®

— ri

—_—

FUNCTION

PBDTGet

IconAsync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTGet

IconSync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTGetIconInfo

(paramBlock:

DIPBPCr;

async:

as”
om

©
&

Boolean)

OSErr;

FUNCTION

PBDTGet

IconInfoAsync

(paramBlock:

DTPBPtr)

OSEryr;

FUNCTION

PBDTGet

IconInfoSync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTGetAPPL

(paramBlock:

DTPBPtr;

async:

Boolean)

OSErr;
FUNCTION

PBDTGetAPPLAsync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTGetAPPLSync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTGet

(paramBlock:

DTPBPtr;

Comment

async:

Boolean)

OSEr2r;

FUNCTION

PBDTGetCommentAsync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTGetComment
Sync

(paramBlock:

DTPBPtr)

OSErr;

Adding to the Desktop
FUNCTION

PBDTAddIcon

Database
(paramBlock:

DIPBPtr;;

async:

Boolean)

OSErr;

FUNCTION

PBDTAddIconAsync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTAddIconSync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTAGdGAPPL

(paramBlock:

DTPBPtr;

async:

Boolean)

OSErr;
FUNCTION

PBDTAGdAPPLAsync

(paramBlock:

DTPBPtr)

OSErY;

FUNCTION

PBDTAGGAPPLSync

(paramBlock:

DTPBPtr)

OSEryr;

FUNCTION

PBDTSetComment

(paramBlock:

DTPBPtr;

async:

Boolean)

OSErr;

FUNCTION

PBDTSetCommentAsync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTSetComment
Sync

(paramBlock:

DTPBPtr)

OSErr;

Summary of the Finder Interface

9-65

Inside Macintosh, Volume VI

Deleting
FUNCTION

Entries

From

the Desktop

PBDTRemoveAPPL

Database

(paramBlock:

DTPBPtr;

async:

Boolean)

OSErr;
FUNCTION

PBDTRemoveAPPLAsync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTRemoveAPPLSync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTRemoveComment

(paramBlock:

DTPBPtr;

async:

Boolean)

OSErr;
FUNCTION

PBDTRemoveCommentAsyne

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTRemoveCommentSync

(paramBlock:

DTPBPtr)

OSErrs

Manipulating

the Desktop

Database

Itself

FUNCTION

PBDTFlush

(paramBlock:

DTPBPtr;

FUNCTION

PBDTFlushAsync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTFlushSync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTGetInfo

(paramBlock:

DTPBPtr;

FUNCTION

PBDTGetInfoAsync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTGetInfoSync

(paramBlock:

DTPBPtr)

OSEYY}

FUNCTION

PBDTReset

(paramBlock:

DTPBPtr;

FUNCTION

PBDTResetAsync

(paramBlock:

DTPBPtr)

OSEFT}

FUNCTION

PBDTResetSync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTDelete

(paramBlock:

DTPBPtr;

FUNCTION

PBDTDeleteAsync

(paramBlock:

DTPBPtr)

OSErr;

FUNCTION

PBDTDeleteSync

(paramBlock:

DTPBPtr)

OSErr;

Result

Codes

noErr
nsrErr
ioErr
fnfErr

9-66

0
—35
—36
—43

async:

async:

async:

async:

Boolean)

OSErr;

Boolean)

OSErr;

Boolean)

OSErr;

Boolean)

OSErr;

No error
Volume not found
I/O error
For FindFolder: type not found in 'fld#' resource, or disk
doesn’t have System Folder support or System Folder in
volume header, or disk does not have desktop database
support for Desktop Folder—in all cases, folder not found
For ResolveAliasFile: Target not found, but volume and
parent directory found and theSpec parameter contains a
valid file system specification record
For Desktop Manager calls: file or directory doesn’t exist

Summary of the Finder Interface

The Finder Interface
wPrErr
vLckdErr
dupFNErr

—t4
—46
48

Volume is locked through hardware
Volume is locked through software
File found instead of folder

rfNumErr
extPSErr

—5]
—58

Reference number invalid
External file system—file system identifier is

paramErr

—50

dirNFErr
desktopDamagedErr

—120
—1305

afpItemNotFound
afpIconTypeError

—5012
—5030

Assembly-Language

i
5
&

Parameter error; use PBDTGetPath

=

e
ey

nonzero

o

Parent directory not found
The desktop database has become corrupted—
the Finder will fix this, but if your application is
not running with the Finder, use PBDTReset or
PBDTDelete
Information not found
Sizes of new icon and one it replaces don’t match

Information

Desktop

Manager

Parameter

—-

2

ioCompletion

long

completion routine

<

16

ioResult

word

result code

ioNamePtr

long

pointer to file, directory, or volume name

>

\)

Block

—

22

ioVRefNum

word

volume reference number

oS

24

ioDTRefNum

word

desktop database reference number

—>

26

ioIndex

word

index into icon list; or no. of files in database

~

28

ioTagInfo

long

tag information

=>

32

ioDTBuffer

long

pointer to icon data

—>

36

ioDTReqCount

long

requested size of icon data buffer

<

40

ioDTActCount

long

actual size of icon definition

&

45

iolconType

byte

icon’s type

=

48

ioDirID

long

parent directory

=>

§2

ioFileCreator

long

file creator

<>

56

ioFileType

long

file type

<

64

ioDTLgLen

long

logical length of database files

<

68

ioDTPyLen

long

physical length of database files

<

100

ioAPPLParID

long

application’s parent directory

Summary of the Finder Interface

9-67

Inside Macintosh, Volume VI

Trap

Macros

Requiring

Routine

_HFSDispatch
Selector

Routine

$0020

PBDTGetPath

$0022

PBDTAddIcon

$0021

$0023
$0024
$0025

$0026
$0027

$0028

$0029

$002A
$002B
$002C
$002D

$002E

PBDTCloseDown
PBDTGetlcon
PBDTGetlIconInfo
PBDTAddAPPL

PBDTRemoveAPPL
PBDTGetAPPL

PBDTSetComment

PBDTRemoveComment

PBDTGetComment
PBDTFlush
PBDTReset
PBDTGetInfo

PBDTOpentInform

$002F

PBDTDelete

9-68

Summary of the Finder Interface

Selectors

CONTROL

PANELS

About This Chapter
About Control Panels
Writing Control Panel Files
About the Monitors Control Panel
Designing an Extension for the Monitors Control Panel
The 'card' Resource
The 'mntr’ Resource
The Monitor Function
Messages to the Monitor Function
The 'RECT" Resource
The 'DITL' Resource
The 'ICON' and 'cicn' Resources
The 'vers' Resources
The 'STR#' Resource
The 'gama' Resources
The 'FREF', 'BNDL’, Icon Family, and Signature Resources
The 'INIT' Resource
A Sample of an Extension to the Monitors Control Panel
Including Another Control Panel Definition in a Monitors Extension File
Summary of the Extension File for the Monitors Control Panel

a

>

2)
=)

=-

meng

=

~

et)

i)

se
DN

10-1

Inside Macintosh, Volume VI

10-2

Control Panels

ABOUT

THIS

CHAPTER

All versions of the Macintosh® Operating System previous to system software version 7.0
provide a desk accessory called the Control Panel. The Control Panel allows users to control
certain system features, such as speaker volume, date and time, and desktop pattern. With
the release of System file version 4.1, documented in Volume V, the Control Panel became

extensible by the addition of control panel files (of file type 'cdev') to the System Folder. The
contents and operation of control panel files are described in the Control Panel chapter
of Volume V.

This chapter describes how to write a control panel file that is compatible with both the
earlier Control Panel and version 7.0, and how to write an extension for the Monitors

control panel file.

In this chapter, the dialog box defined by a file of file type 'cdev' is referred to as control
panel (as opposed to the Control Panel), and the file itself is referred to as a control panel
file.
Only the manufacturer of a video device should write an extension to the Monitors control
panel for that device. Therefore, if you are not developing a video card for the Macintosh
computer, you do not need the information in this chapter on the Monitors control panel.

PANELS

In system software version 7.0, the Control Panel desk accessory no longer exists as one
entity. Each of the individual control panels now appears as a modeless dialog box. Users
can open control panels in the same way as any other document, and several control panels
can be open at one time. The main reason to create a control panel file rather than an application is to maintain compatibility with the Control Panel for users who are using earlier
operating systems. Any control panel file that follows the rules and suggestions given in the
Control Panel chapter of Volume V will continue to work without problems in version 7.0.
A control panel can open in a window of any size. However, you may want to constrain any
new panels that you develop to fit in the space provided by the previous Control Panel desk
accessory. Doing so guarantees that the control panel can be opened either by the Control
Panel desk accessory in earlier versions of system software or by the Finder in version 7.0.
The user can store control panels in the Control Panels folder or the Apple® Menu Items
folder (both in the System Folder), or at any other location in the file system.
You should refer to a file of type 'cdev' as a control panel file in any user documentation that
you provide. Don’t pass on the file type name of this file or any other file to users.
The next section, “Writing Control Panel Files,” provides more information about developing
control panels that work in all versions of system software.
10-3

j

2.
a=}

~”

panel file is now displayed as an independent dialog box rather than as a panel in the Control
Panel desk accessory.

About Control Panels

i)
|
a

Lee

LE

eliminated. Instead, the Finder™ can now open each file of file type 'cdev'. Each control

CONTROL

CQ)

iY)
~

In system software version 7.0, the Control Panel, as a discrete desk accessory, has been

ABOUT

="
oS

Inside Macintosh,

WRITING

Volume VI

CONTROL

PANEL

FILES

You should keep the following points in mind if you are writing or modifying a control
panel file:
A control panel file displays a modeless dialog box with no menu bar. You can use the
editing functions in the Finder’s menu bar if necessary, but you cannot add any menu
choices. The Finder passes messages to your cdev function for the following standard
selections from the Edit menu: Undo, Cut, Copy, Paste, and Clear. Your cdev function
can respond to these messages when it is appropriate to do so; for example, if your
control panel has an editable text box, you can respond to these editing functions when
the insertion point is within this field. See the Control Panel chapter in Volume V for a
description of the cdev function.
The rectangles defined by the 'nrct' resource are no longer restricted to the size of the
Control Panel; however, to maintain compatibility with previous operating systems,
the rectangles’ coordinates should not exceed (—1,87,255,322).

There is no longer a guarantee that the resources provided by the Control Panel are
available when your control panel file is running. If your control panel file uses any
Control Panel resources, it might not run in version 7.0. If your control panel file
strictly follows the specifications in the Control Panel chapter of Volume V, however,
it should run with no difficulty in version 7.0.
Your control panel file can continue to use the CPDialog parameter passed to the cdev
function to obtain the dialog item list and the numItems parameter to determine the number of items in the dialog item list. If you use these parameters in your control panel file
to gain access to the items in your dialog item list, your control panel file will operate
correctly with both the Control Panel and the Finder. If you assume some value for the
numlItems parameter, however, your control panel file will not operate correctly in both
situations. Dialog item lists are described in the Dialog Manager chapter of Volume I.
If the 'mach' resource in your control panel file indicates that the cdev function cannot
run, the Finder displays an error message for the user and does not open the control
panel file. In contrast, the Control Panel does not display the icon for a control panel file
if the 'mach' resource indicates the cdev function cannot run. If your control panel file
can run on all Macintosh computers, set the 'mach' resource to $FFFF 0000. If your
control panel file can run only when certain hardware or software is present, set the
‘mach’ resource to $0000 FFFF. In the latter case, the Finder calls your cdev function
with the message parameter set to the constant macDev (8). Your cdev function should

then call the Gestalt function to determine the software and hardware configuration of
the machine. If your control panel file cannot run, return a result code of 0; if your
control panel file can run, return a result code of 1. The Gestalt function is described in
the Compatibility Guidelines chapter in this volume.
The Finder now handles the result codes returned by your cdev function. Whereas the
Control Panel dims the icon for a control panel file in response to certain result codes,
the Finder displays an error message but does not dim the control panel file icon.

10-4

Writing Control Panel Files

Control Panels

ABOUT

THE

MONITORS

CONTROL

PANEL

The Monitors control panel that is provided with system software version 7.0 is extensible. If
you are the developer of a video card, you can add items to the Monitors control panel that
allow users to control features of the video device.
The Monitors control panel allows a user to

—_

m select which one of the monitors connected to the computer system should display the
menu bar
m select which monitor to use as a startup screen
= inform the Operating System about the relative locations of the monitors
= control some features of the monitors, such as whether a color monitor displays in color
or in black and white, or the number of colors or gray-scale values to display
Figure 10-1 shows an example of the Monitors control panel.
nun

(JS

E===

monitors

—

Characteristics of selected monitor:

@ Grays:

oO Colors:

AES

a

—)
©
S)
=!

|
4.4b2

4

Drag monitors and menu bar to rearrange them.

(tent)
Figure 10-1. The Monitors control panel
As Figure 10-1 illustrates, the Monitors control panel now includes a button labeled Options;
when the user clicks this button, another dialog box appears with additional controls. When
you add an extension to the Monitors control panel, the controls you add appear in this dialog
box. In this chapter, the dialog box that appears when the user clicks the Options button in
the Monitors control panel is referred to as the Options dialog box. Figure 10-2 shows an
example of an Options dialog box. The OK and Cancel buttons are standard for all Options
dialog boxes. The screen-saver control (“Minutes before sleep”) is added by the Monitors
extension. If there is more than one video card installed in the computer, the Monitors control
panel shows all of the connected monitors. In this case, the user selects one monitor and
the Monitors control panel displays the Options dialog box for that monitor (monitor | in
Figure 10-1).

About the Monitors Control Panel

10-5

Ss

=
Ssw
=!
so
”M
——

Inside Macintosh,

Volume

VI

K

a

Macintosh Display Card S@24 GC ‘The Accelerated’

=

Cancel

Select monitor type:

Mac Il High-Res Monitor

vo
Minutes before sleep

A

|

ee te

Monitor Extension Example
Screen sayer

© 1990 Apple Computer, Inc.

| [ Identify |

Figure 10-2. An Options dialog box for a Monitors control panel
You should provide an extension to the Monitors control panel whenever you want to
provide users with a simple way to control your video device. However, if you require a
more complex interface—such as your own menu items or several levels of nested dialog
boxes—you should provide a small application rather than an extension to the Monitors
control panel. If you do provide a small application, you might want to instruct the user to
place it in the Control Panels folder within the System Folder.

DESIGNING AN EXTENSION
CONTROL PANEL

FOR

THE

MONITORS

If you develop a video card, you can provide a file of type 'cdev' that adds controls to the
Options dialog box of the Monitors control panel. An extension to the Monitors control panel
should control features of the video card only; a Monitors extension should not control systemwide features. For example, a Monitors control panel extension might allow the user to set the
virtual screen size for a single monitor, but not to set the size of the menu bar, which can
appear on any monitor.
It is not advisable to add a button to the Options dialog box that puts up yet another dialog
box. If the features that you want to implement require an extensive or complex set of

controls, it would be better to write a small application rather than an extension to the

Monitors control panel file.
A

10-6

Warning: Only the manufacturer of the video card should write an extension to
the Monitors control panel file. There can be only one extension to the Monitors
control panel file for each video card. Apple Computer, Inc., reserves the right to
supply control panel files for its own video cards. a

Designing an Extension for the Monitors Control Panel

Control Panels

The extension file for the Monitors control panel must be a file of type 'cdev' containing at
least the following resources:
m ‘card’ (ID can be any number from 4080 through —4065)
a ‘mntr’ (ID = 4096)
_

—)

=» 'RECT' (ID = -4096)

©
i)
~

a 'DITL' (ID = —-4096)

=

an)

Your Monitors extension file can also include any of the following resources:

as)
~

eo.

a 'ICON' (ID = -4096)
w

‘cicn' (ID =-—4096)

m

‘vers' (ID = 1)

i“ 2)

a ‘vers’ (ID = 2)
a 'STR#' (ID = -4096)
m

‘gama’ (ID can be any number from —4080 through -4065)

a 'FREF'
a ‘BNDL'
m icon family resources 'ICN#’, ‘ics#', 'icl8', 'icl4', 'ics8', and ‘ics4'
a ‘INIT'
m

signature resource

The following sections describe these resources. You can use resource ID numbers of -4080
through —4065 for any private resources in your Monitors extension.

The

'card'

Resource

The 'card' resource contains a Pascal string (that is, a length byte followed by an ASCII
string) identical to the name of a video card. (The name of a video card is located in the Board
sResource data structure in the ROM of the card, as described in Designing Cards and Drivers
for the Macintosh Family, second edition.) The extension file can contain as many ‘card!
resources as you wish, so that one extension file can handle several versions of one video
card. The Options dialog box displays the name in the 'card' resource unless you also include
an 'STR#' resource in the extension file, as described in “The 'STR#' Resource” later in this
chapter. The Slot Manager chapter in Volume V describes the SGetCString function. For a
description of video cards, see Designing Cards and Drivers for the Macintosh Family,
second edition.

Designing an Extension for the Monitors Control Panel

10-7

Inside Macintosh,

The

'mntr’'

Volume VI

Resource

The 'mntr' resource contains the code that carries out the functions of your Monitors extension. This resource must begin with a function that you provide, referred to in this chapter as
the monitor function. The parameters passed to the monitor function by the Monitors control
panel allow your code to determine what action to perform. You can use the function result to
keep a handle to local storage or to return an error code. These options are described in the
parameter descriptions in the next section.
An 'mntr' resource is a code resource. In MPW®, you can set the code resource type to
‘mntr' when you link the program.

The

Monitor

Function

The 'mntr' resource must contain a function that responds to the various events that can occur
while the Options dialog box is on the screen. The declaration for a monitor function named
MyMntr is as follows:
FUNCTION

MyMntr

(message,item,numItems:
mDialog:
screenNum:
VAR

Parameter

DialogPtr;
Integer;

scrnChanged:

Integer;

theEvent:
VAR

Boolean)

monitorValue:

screens:
:

LongInt;

EventRecord;
ScrnRsrcHandle;

LongInt;

descriptions

message

A message number, from the list defined in the following section, that
your monitor function can use to determine what action to take.

item

The dialog-item-list number of the item that the user clicked. To
calculate the dialog-item-list number in your 'DITL' resource, subtract
the number passed in the numItems parameter from the number in the
item parameter.
When the message parameter equals StartupMsg, the item parameter

indicates whether the user is a superuser—that is, whether the user can

be assumed to be very knowledgeable. If the user is a superuser, the
item parameter is 1; if not, it is 0.

numitems

|

monitorValue

10-8

The dialog-item-list number of the last standard item in the Options
dialog box. You number the items in your 'DITL' resource starting
with |; the Monitors control panel adds the value of the numItems
parameter to each number in the 'DITL' resource and uses the result
for the dialog-item-list number.
The result returned by your monitor function the last time it was called.
Because control panel routines cannot have global variables, you might
want to use the function result to return a handle to the storage of your
local data. This handle is then available in the monitorValue parameter
the next time the monitor function is called. The monitorValue parameter is Q the first time the Monitors control panel calls your monitor
function (that is, when the message parameter equals startupMsg).

Designing an Extension for the Monitors Control Panel

Control Panels

If your monitor function returns a function result in the range | through
255, the Monitors control panel interprets this result as an error and
closes your Options dialog box. Therefore, your monitor function
cannot receive a value in this range in the monitorValue parameter.
mDialog
theEvent

screenNum

The dialog pointer for the Options dialog box. See the Dialog Manager
chapter of Volume I for a description of dialog pointers.
The event record for an event that caused a hitMsg, nulMsg, or
keyEvtMsg message. See the Event Manager chapter of this volume
for a discussion of event records.
The number of the screen device (that is, the monitor) that the user has

selected. The Monitors control panel numbers monitors consecutively,
in the same order as the slots in which the cards are installed, starting
with |.

screens

scrnChanged

A handle to the 'scrn' resource. The 'scrn' resource is described in the

Graphics Devices Manager chapter of this volume.

A Boolean value that you can use to indicate whether you have modified the 'scrn’ resource. Set this parameter to TRUE if you have
modified the 'scrn' resource. When the scrnChanged parameter is
TRUE, the Monitors control panel checks the 'scrn' resource to make
sure that the values in it are still valid; if there is a problem, the
Monitors control panel tries to correct it.
This parameter makes it easier to implement a control that changes the
apparent area displayed on the screen. For example, your monitor
might be able to display either two pages of a document or a magnified
view of a single page. If the user changes the area displayed on one
screen in a system with multiple screens, the displays on adjacent
screens could overlap or show gaps. When you change the 'sern'
resource to implement this change, the coordinates of the global
rectangles for adjacent screens are no longer contiguous. In this case,
if you have set the scrnChanged parameter to TRUE, the Monitors
control panel shifts the virtual locations of the screens to eliminate the
gaps or overlaps.

Your monitor function can return either an error code or a value that you want to have

available the next time the Monitors extension is called. Each time the extension is called,

the monitorValue parameter contains the value that your monitor function returned the
last time it was called.

If an error occurs, your monitor function should display an error dialog box and then return a
value between | and 255. If your code returns a value in this range, the Monitors control
panel closes the Options dialog box immediately and no more calls are made to your code. If
your code returns an error in response to the initMsg or startupMsg message, the Monitors
control panel does not display the Options dialog box. You can display an alert box
describing the error before returning control to the Monitors control panel.

Designing an Extension for the Monitors Control Panel

10-9

=

=

OQ
S
~

te

=

=)

la

+s)
i}

ch
M

Inside Macintosh,

Messages

Volume VI

to the

Monitor

Function

The message passed as a parameter to the monitor function can have any of the values defined
by these constants:
CONST

initMsg

=

I;

{initialization}

okMsg

=

By

{user

clicked

OK

cancelMsg

=

{user

clicked

Cancel

hitMsg

=

3 Sy
4 As

nulMsg

=

5:3

{periodic

updateMsg
activateMsg

=:
=

6%
“7's

{update
event}
{not used}

deactivateMsg

=

SF

{not

keyEvtMsg

=

9%

{keyboard

superMsg

=:

Gs

{show

superuser

normalMsg

=:

THs

{show

only

startupMsg

=

12

{code

has

{user clicked
{ box}

button}

control

button}
in

Options

dialog

event}

used}
event}
controls}

normal
been

controls}

loaded}

Constant

Meaning

initMsg

Sent before the Options dialog box is displayed, after the Monitors
control panel has located any resources (such as 'gama' resources)
referred to by your monitor function. When you receive this message
you should execute initialization code. You can use initialization code
to set default values for controls and allocate memory for local storage,
for example.
If you do allocate storage, be sure to pass a handle to the storage as the
function result. The next time your extension is called, this value will be
available in the monitorValue parameter.
This message is preceded by the startup message and followed by either
the super message or the normal message.

okMsg

Indicates the user has clicked the OK button. The OK button is a standard control put in the Options dialog box by the Monitors control
panel. You should not make any changes irreversible until you receive
this message.
When the user clicks the OK button, the Monitors control panel hides
the Options dialog box and calls your monitor function with this
message. This is your last chance to check the values of dialog items
that the user might have changed. You should release any private
memory allocated by your extension file before returning control to the
Monitors control panel.

cancelMsg

10-10

Indicates the user has clicked the Cancel button. The Cancel button is a
standard control put in the Options dialog box by the Monitors control
panel. Return the computer system to the condition it was in before the
user clicked the Options button, release any private memory allocated
by your extension file, and return control to the Monitors control panel.

Designing an Extension for the Monitors Control Panel

}

Control Panels

Constant

Meaning

hitMsg

Indicates the user has clicked an enabled control in the Options dialog
box. The dialog-item-list number of the control is passed in the item
parameter to the monitor function; see the preceding section for a
discussion of this parameter.

nulMsg

updateMsg

Sent periodically to allow you to perform tasks that have to be done
repeatedly, such as blinking an insertion point. Do not assume any
particular timing for this message.

=

|

=

deactivateMsg

Sent on every activate event for which the Options dialog box becomes
inactive. Currently, this message is not used, because the Options
dialog box is modal. However, you should handle this message as you
would any activate event because in future versions of the Operating
System, this dialog box might be modeless.

keyEvtMsg

Sent on every keyboard event.

superMsg

Indicates the user is a superuser—that is, the user can be assumed to be
very knowledgeable. This message is sent when the user holds down
the Option key while clicking the Options button, and it could be sent
by other mechanisms in the future. You should display any controls that
you have reserved for such users.
This message or the normal message is sent immediately following the
initialization message.
Indicates you should not display controls reserved for superusers.
This message or the super message is sent immediately following the
initialization message.
Sent as soon as the code in your 'mntr' resource has been loaded,
before the Monitors control panel finds any resources referred to by
your monitor function. You can then load and modify any resources
that must allow for the capabilities of the computer system or for
superusers. You can use this opportunity, for example, to modify your
'DITL' resource to display special controls for superusers.
You can call the Gestalt function to determine the capabilities of the
user’s computer system, and you can check the value of the item
parameter to determine whether the user is a superuser. If the user is a
superuser, the Monitors control panel sets the item parameter to | when
it sends the startup message.
This message is the first message sent.
Designing an Extension for the Monitors Control Panel

S
=

—s
Lew

is)

Sent on every activate event for which the Options dialog box becomes
active. Currently, this message is not used, because the Options dialog
box is modal. However, you should handle this message as you would
any activate event, because in future versions of the Operating System
this dialog box might be modeless.

startupMsg

=

OQ

eS

Sent on every update event.

activateMsg

normalMsg

—

— 10-11

se

i? a)

Inside Macintosh,

Volume VI

The

Resource

'RECT'

You use the 'RECT' resource to describe the size and shape of the area taken up by your
controls. In assigning coordinates to your controls, assume that the origin (that is, the upperleft corner) of the local coordinate system for your dialog items is at (0,0). (In this coordinate
system, the Options dialog items displayed by the Monitors control panel would have a right

edge at 319 and a negative top coordinate.) The Monitors control panel expands the Options

dialog box, placing the rectangle defined by your 'RECT' resource so that its upper edge
starts immediately below the standard controls put in the Options dialog box by the Monitors
control panel. In Figure 10-2, for example, the OK and Cancel buttons and the Select monitor
type box are standard controls, and the screen-saver control has been added by a Monitors
extension.

Because the Monitors control panel transforms the coordinates of your controls to the

coordinate system that it uses for the Options dialog box, you must use the GetDItem
procedure (described in the Dialog Manager chapter of Volume I) to get the true locations
of your dialog items.

The

'DITL'

Resource

The 'DITL' resource is a standard dialog item list, as described in the Dialog Manager
chapters of Volumes I and V. For an example of this resource, see “A Sample of an
Extension to the Monitors Control Panel” later in this chapter.
You can start your controls immediately below the standard controls put in the Options dialog
box by the Monitors control panel, as shown in Figure 10-2. If you add additional controls
for superusers, you should separate the superuser controls from the other controls with a
horizontal dividing line, as illustrated in Figure 10-3.

|
Macintosh Display Card 8@24 GC ‘The Accelerated’

=
&

Cancel
Use Special Gamma

Select monitor type:

Mas Il Hidt-Res Gara tabke

Uncorrected Gamma

Minutes before sleep

g

Monitor Extension Example
Screen saver

© 1990 Apple Computer, Inc.

Filter Type

© Zirconian Filtration
@ Anti-Aliasing

Filter

Figure 10-3. An Options dialog box with superuser controls

10-12.

Designing an Extension for the Monitors Control Panel

Control Panels

To draw a dividing line, make it a separate dialog item of type userItem. The procedure for the
dialog item should consist of a FrameRect procedure that draws a |-pixel-high rectangle. The
coordinates for the dividing line are in the coordinate system used by your 'RECT" resource.
If you wish, you can use a gray pattern for this line in a manner similar to that used for divider
lines in menus. Dialog items are discussed in the Dialog Manager chapter of Volume I, and the

FrameRect procedure is described in the QuickDraw™ chapter of Volume I. Listing 10-1 later
in this chapter includes code to draw a dividing line.

—

fom)
\4

o

Mt

The

'ICON'

and

'cicn'

—

_

Resources

Ecol>
Font
ad
—

The 'ICON' resource defines a black-and-white icon. The 'cicn' resource, described in the
Color QuickDraw chapter of Volume V, defines a color icon. If you include either of these
resources in the Monitors extension file, the icon is displayed in the Options dialog box of
the Monitors control panel (Figures 10-2 and 10-3).

The

‘vers'

Resources

You can include 'vers' resources to provide version information for your Monitors extension
file. The 'vers' resource with a resource ID of 1 specifies the version of your Monitors
extension file. The 'vers' resource with a resource ID of 2 specifies the version of the group
to which your file belongs—for example, the version number of the video card that your
extension file supports. See the Finder Interface chapter in this volume for more information
on 'vers' resources.

The

'STR#'

Resource

If the name for the video card that you want to display in the Options dialog box is different
from the name in the declaration ROM

of the video card, you can include an 'STR#' resource.

This resource must contain pairs of Pascal strings. The first string in each pair must be
identical to the name of the video card as returned by the Slot Manager’s SReadDrvrName
function (minus the period that the Slot Manager prefixes to the name). The second string in
each pair is the name that you want to display in the Options dialog box. You can have as
many pairs of names in one 'STR#' resource as you wish; the Monitors control panel uses the
first match it finds.

The

'gama'

Resources

When the user presses the Option key while clicking the Options button in the Monitors
control panel, a list of gamma tables is displayed (Figure 10-3). The software driver for a
video card uses a gamma table to correct for the fact that the intensity of each color on a
video display is not linearly proportional to the intensity of the electron beam; in other words,
the gamma table helps the video driver to provide the most accurate colors possible for a
video display. Because the user might prefer a nonstandard color correction, many developers of video cards provide more than one gamma table for a given card.

Designing an Extension for the Monitors Control Panel

—_ 10-13

—
as ww
oe

—
veo

fs")
—

7]

Inside Macintosh,

Volume VI

To include one or more gamma tables for a video card, include in the Monitors extension file
a named resource of type 'gama' for each gamma table. The user can select which gamma
table to use with the monitor by clicking the name of that table, or the user can select the
default gamma table for that monitor by clicking the box that appears above the gamma table.
The default gamma table for a monitor is the one listed in the 'scrn' resource. Gamma tables
are discussed in Designing Cards and Drivers for the Macintosh Family, second edition. The
‘scrn' resource is described in the Graphics Devices Manager chapter of this volume.

The

'FREF',

'BNDL',

Icon

Family,

and

Signature

Resources

The 'FREF', 'BNDL', icon family, and signature resources work together to give your file a

distinctive appearance on the desktop. These resource types are described in the Finder
Interface chapter of this volume, and examples of these resources are given in Listing 10-2
later in this chapter.

The

‘'INIT'

Resource

A file that contains an extension to the Monitors control panel can contain an 'INIT' resource.
If this file is in the Control Panels folder, the Extensions folder, or the base level of the
System Folder, then the Operating System executes the 'INIT' resource when the machine is

switched on or reset. (Before system software version 7.0, all 'INIT' resource files had to be
located in the base level of the System Folder.) 'INIT' resources are discussed in the System
Resource File chapter of Volume IV and in the Start Manager chapter of Volume V. The
'INIT' resource acts independently of other resources in the file; it need not be related to the
Monitors extension in any way.

A Sample of an Extension to the Monitors Control Panel
Listing 10-1 shows code that defines an extension to the Monitors control panel. Listing 10-2
shows the resources for this extension in Rez format.

In response to the startup message, the Monitors extension shown in Listing 10-1 checks the
value of the item parameter to determine whether the user is a superuser. If the user is not a
superuser, the Monitors extension uses the default values for the 'RECT' resource shown in
Listing 10-2. This rectangle ends just before the dividing line, so that the superuser controls
are not displayed. If the user is a superuser, the SetUpData function in Listing 10-1 extends
the rectangle in the 'RECT' resource so that the rectangle includes all of the controls in the
'‘DITL' resource.
The code for the startup message allocates memory for the use of the Monitors extension
and returns a handle to this memory as the function result. For all subsequent messages,
the Monitors control panel passes the previous function result to the extension in the
monitorValue parameter. In order to preserve the handle to this memory, Listing 10-1 sets
the monitor function equal to the monitorValue parameter for all messages that the function
does not process.
The Monitors control panel extension shown in Listings 10-1 and 10-2 is illustrated in
Figures 10-2 and 10-3.

10-14

— Designing an Extension for the Monitors Control Panel

Control Panels

Listing 10-1. Sample of an extension to the Monitors control panel
{Pascal

source

code}

CONST
textItem

=

1;

{StaticText

item

lineItem

=

er

{separation

line}

downitem

=

35

{Down

user

upItem

=

ae

{Up

countItem
brightItem

=
=

i6¢
05

{frame
{radio

for count}
button
"filter"}

lessItem

=

10;

{radio

button

slotCount

=

64

{a

initMsg
okMsg
cancelMsg
hitMsg

ey Le
= 2%
= 35
= oy
=:

updateMsg

Arrow

user

cdev}
—_
—_

item}

—

( 4

item}

~_

al

-_
_—

—_

sx}
~
=

—

"aliasing" }

reasonable

Pret

pe)¥
_—
—

value}

dialog

Sy

{periodic

6;

{update

event}
event}

=

7;

{not

used}

deactivateMsg

=

8;

{not

used}

keyEvtMsg

=

Dy

{keyboard

superMsg

=

10%

{show

superuser

normalMsg
startupMsg

ai
=

aS
2

{show
{code

only normal
controls}
has been
loaded}

{resource
IDs}
MemErrAlert

=

130s

{alert

deepAlert

=

13Ls

{all

dataRes

=

-4080;

{store

ScrnRecord
RECORD
srDrvrHw:

}

box}

activateMsg

TYPE

<7)
—
17 2)

{initialization}
{user clicked OK button}
{user clicked Cancel button}
{user clicked control in Options
{

nulMsg

Arrow

in

event}

to

controls}

tell

other

user

you

ran

out

of

memory}

errors}

data}

=
Integer;

{'sern'
info
for each screen}
{spDrvrHW
from Slot Manager}

srSlot:

Integer;

{slot

number

for

the

srDCtlDevBase:

LongInt;

{base

address

of

card's

srMode:

Integer;

{sRsrcID

srFlagMask:

Integer;

{$77FE}

srFlags:

Integer;

{active,

main

srColorTable:

Integer;

{resource

ID

of

desired

‘clut'}

srGammaTable:

Integer;

{resource

ID

of

desired

'gama'}

srRect:

Rect;

srCtlCount:

Integer

{device's
rectangle,
global
{ coordinates}
{number of control
calls}

for

screen's

video

card}

memory}

desired

mode}

screen,

B/W

or

color}

}

END;

ScrnRecordPtr
= “ScrnRecord;
ScrnRecordHandle
= “ScrnRecordPtr;
ScrnRsrce
RECORD

=
{complete
{number

'scrn'

count:

Integer;

scrnRecs:

ARRAY[1..slotCount]

{config

of

for

screens
OF

resource}
configured

here}

ScrnRecord

each

one}

END;

(Continued)

Designing an Extension for the Monitors Control Panel

—_ 10-15

Inside Macintosh, Volume VI

Listing 10-1. Sample of an extension to the Monitors control panel (Continued)
ScernRsrcePtr

=

*“ScrnRsrc;

ScrnRsrcHandle

MonitorData
RECORD

=

“ScrnRsrcPtr;

=

{local

isSuperUser:

Boolean;

{is

data

the

for

user

filteringSetting:

Integer;

{new

Integer;

{previous

filter

oldSleep:

Integer

{previous

sleep

Integer;

{new

sleep

the

extension}

superuser?}

oldFiltering:

sleepTime:

filter

a

setting}
setting}

time}

time}

END;

MonitorDataPtr
= *MonitorData;
MonitorDataHandle
= “MonitorDataPtr;
RectPtr

=

*Rect;

RectHandle
IntPtr

=

=

*“RectPtr;

“Integer;

IntHandle

=

“IntPtr;

PROCEDURE

DrawMyRect

(theWindow:

WindowPtr;

itemNo:

Integer);

FORWARD;

FUNCTION

SetUpData(superUser:

Integer;

storage:

MonitorDataHandle)

:

FORWARD;

PROCEDURE

HandleHits(mDialog:

DialogPtr;

dataHand:
FORWARD;
PROCEDURE
SaveNewValues

whichItem,numItems:

Integer;

MonitorDataHandle) ;

(dataRecHand:

MonitorDataHandle) ;

FORWARD;
PROCEDURE

SetParamText

(sleep:

Integer) ;

FORWARD;
FUNCTION

MonExtend

(message,item,numItems:

Integer;

monitorValue:

mDialog:

theEvent:

LongInt;

EventRecord;

VAR

screens:

VAR

scrnChanged:

ScreenNum:

DialogPtr;
Integer;

ScrnRsrcHandle;
Boolean)

:

LongInt;

VAR

ItemType:

Integer;

ditem:
Handle;
box:
Rect;

dataRecHand:

MonitorDataHandle;

result:
OSErr;
i: Integer;
BEGIN

dataRecHand

:=

CASE message
startupMsg:

OF

10-16

MonitorDataHandle
(monitorValue) ;
{set up handle
to local
{time

to

check

for

— Designing an Extension for the Monitors Control Panel

data}

superusers}

OSErr;

Control Panels

BEGIN

{first
allocate memory
to hold your
local
data}
dataRecHand
:=
MonitorDataHandle
(NewHandle (sizeof (MonitorData) ));
IF dataRecHand
<> NIL THEN
BEGIN

result
IF

:=

SetUpData(item,

result

=

noErr

dataRecHand) ;

{initialize

all

—

fields}

—
—

THEN

(

BEGIN

ad
—

MonExtend

:=

LongInt

(dataRecHand)

{this

;

comes

_—

back

in

i)

i

monitorValue}

eet

—

a

ig?)

ELSE

pad

DM

BEGIN

MonExtend

:=

result;

{error

should

stop

any

further

action}

END
ELSE

BEGIN
{display
error message}
1 := StopAlert (MemErrAlert,NIL)
MonExtend
:= 255;

;

END;

Exit

(MonExtend) ;

END;

initMsg:

{initialize

cdev}

values

set

BEGIN

{set

{

controls

draws

user

to

their

initial

and

the

proc

that

itemType,

dItem,

box)

;

SetDItem(mDialog, numItems+lineItem, itemType, @DrawMyRect
GetDiItem(mDialog, numItems+countItem, itemType, ditem, box) ;

itemType

=

userItem

SetDItem(mDialog,

Set ParamText
IF

}

items}

GetDItem(mDialog, numItems+linelItem,
IF itemType
= userItem THEN

IF

, box) ;

THEN

numItems+countItem,

itemType,

@DrawMyRect,

box) ;

(dataRecHand**.sleepTime) ;

dataRecHand**.isSuperUser

THEN

BEGIN

IF

dataRecHand**.oldFiltering

IF

GetDItem(mDialog,numItems+lessItem,itemType,
itemType
= radCtrl
+ ctrlitem THEN

=

0

THEN
dItem,

box);

SetCtlValue(ControlHandle(dItem)
,1)
ELSE

GetDItem(mDialog,

IF

3

2
+)

END

_END

4

-_
=
—

numItems+brightItem,

itemType,

dItem,

box) ;

itemType = radCtrl + ctrlItem THEN
SetCtlValue (ControlHandle(dItem),1);

END;
END;

hitMsg:
BEGIN

HandleHits(mDialog,

item,

numItems,dataRecHand) ;

END;

(Continued)

Designing an Extension for the Monitors Control Panel

10-17

Inside Macintosh,

Volume VI

Listing 10-1. Sample of an extension to the Monitors control panel (Continued)
okMsg:

{user

wants

to

implement

changes}

BEGIN
{execute

any

SaveNewValues

hardware

changes

(dataRecHand)

here}

;

DisposeHandle(dataRecHand)

{release

memory}

does

want

END;
cancelMSG:

{user

not

to

save

changes}

BEGIN

{make

sure

no

changes

are

made

DisposeKandle(dataRecHand)

permanent}

{release

memory}

END;
END;

END;

MonExtend
:= monitorValue;
{MonExtend}

{return

handle

to

local

data}

{The following procedure is used both to frame the minutes-to-sleep
{ and to draw the line separating the superuser controls from the }
{ other controls.}
PROCEDURE DrawMyRect (theWindow: WindowPtr;
itemNo:
Integer);

box

VAR
ItemType:

Integer;

dItem: Handle;
box: Rect;
BEGIN

GetDiItem(theWindow,
FrameRect (box);

itemNo,itemType,

dItem,

box);

END;

FUNCTION

SetUpData(superUser:

Integer;

storage:

MonitorDataHandle)

OSErr;
VAR
filterType,
i:

sleepyTime:

Handle;

Integer;

result:

OSErr;

rHandle:

Handle;

BEGIN
result
:= noErr;
HLock (Handle(storage)
) ;
WITH storage**
DO
BEGIN

sleepyTime
:=
IF sleepyTime

GetResource('SLEP',dataRes) ;
<> NIL THEN

BEGIN

oldSleep
:= IntHandle(sleepyTime)
%**;
sleepTime
:= oldSleep;
ReleaseResource (sleepyTime) ;
IF

10-18

superUser

=

1

{get

old

value}

{get

rid

of

THEN

— Designing an Extension for the Monitors Control Panel

the

resource}

}

Control Panels

BEGIN

isSuperUser

:=

filterType

IF

:=

TRUE;
GetResource('INTE',dataRes);

filterType

<>

NIL

THEN

BEGIN

oldFiltering

{if

the

:=

IntHandle(filterType)%**;

{get old value}
filteringSetting
:= oldFiltering;
ReleaseResource(filterType);
{get rid of the resource}
is a superuser,
change
the RECT to display more controls}

user

rHandle
:= GetResource('RECT',-4096) ;
IF rHandle <> NIL THEN
RectHandle(rHandle)**.top
:= -160

+
=

ELSE

result

:=

255

END
ELSE

result

=

255;

END
END
ELSE

result:
result

IF

+= 255;
= 255 THEN

{flag

error}

BEGIN

DisposHandle(Handle(storage)
);
i := StopAlert (deepAlert,NIL);
{tell

the

user

there's

result

should

a

problem}

END
END;

HUnlock(Handle(storage)
) ;
SetUpData

:=

result;

{nonzero
{

further

stop

any

}

action}

END;

PROCEDURE

SaveNewValues

{save

current

the

(dataRecHand:

settings

in

MonitorDataHandle) ;

resources}

VAR

resHandle:

Handle;

BEGIN

WITH

dataRecHand**

DO

BEGIN

IF

sleepTime

<>

oldSleep

THEN

BEGIN

resHandle
:=
IF resHandle
BEGIN

GetResource('SLEP',dataRes) ;
<> NIL THEN
{set

IntHandle(resHandle)**
:=
ChangedResource (resHandle)
WriteResource (resHandle) ;

sleep

=
@
S
I

time}

sleepTime;
;

END
END;

(Continued)

Designing an Extension for the Monitors Control Panel

— 10-19

Inside Macintosh,

Volume VI

Listing 10-1. Sample of an extension to the Monitors control panel (Continued)
IF

isSuperUser
IF

THEN

{settings

filteringSetting

<>

only

oldFiltering

for

superusers}

THEN

BEGIN

resHandle
IF

:=

resHandle

GetResource('INTE',dataRes) ;
<>

NIL

THEN

BEGIN

{set

IntHandle(resHandle)**
ChangedResource

WriteResource

superuser

:=

(resHandle)

(resHandle)

controls}

filteringSetting;
;

;

END
END
END
END;

PROCEDURE

HandleHits(mDialog:
DialogPtr; whichItem,numItems:
dataHand:
MonitorDataHandle) ;

Integer;

VAR
ItemType:
Integer;
ditem:
Handle;
box:

Rect;

BEGIN

HLock (Handle (dataHand)
WITH dataHand*®*
DO

);

BEGIN

CASE

whichItem

-

numItems

OF

upitem:
BEGIN

GetDItem(mDialog,numItems+countItem,itemType,

sleepTime

:=

(sleepTime

SetParamText (sleepTime)
InvalRect (box) ;

{get

the

text

+

MOD

26;

1)

dItem,

box);

dItem,

box);

box}

;

END;
downItem:
BEGIN
GetDItem(mDialog,numItems+countItem,itemType,

sleepTime
:=
IF sleepTime
sleepTime
SetParamText
InvalRect

sleepTime
< 0 THEN
:=

-

1;

25;

(sleepTime)

;

(box) ;

END;

10-20

Designing an Extension for the Monitors Control Panel

Control Panels

brightitem:
BEGIN

GetDItem(mDialog,whichItem

dItem,

box);

SetCtlValue(ControlHandle(dItem)
,1);
GetDItem(mDialog,numItems+lessItem,itemType,
IF itemType = radCtrl + ctrliItem THEN

dItem,

IF

itemType

=

radCtrl

+

,itemType,

ctrlItem

THEN

box);

=

SetCtlValue(ControlHandle(dItem)
,0);

filteringSetting

:=

1;

-_

=

lessitem:

—

w

BEGIN

oe

GetDItem(mDialog,numItems+brightItem

IF

itemType

=

radCtrl

+

ctrlItem

,itemType,

dItem,

box);

THEN

SetCtlValue (ControlHandle(dItem) ,0);
GetDItem(mDialog,whichIitem,itemType,
dItem,

box);

IF

itemType = radCtrl + ctrlItem THEN
SetCtlValue(ControlHandle(dItem)
,1) ;
filteringSetting
:= 0;

END;

{CASE}

END;

HUnlock
(Handle (dataHand)

) ;

END;
PROCEDURE

SetParamText

(Sleep:

Integer) ;

VAR

countStr:

Str255;

BEGIN
NumToString(Sleep,

IF

(Sleep

<

10

)

countStr);

THEN

BEGIN

countStr[0]

:=

Char(Integer(countStr[0])

countStr[(2]

:=

countStr[1];

eountStril]

«=

'0"*

+

1);

END;

ParanText

€)=
S
—
“=
a
ca
fsA=
oss
+ 2
al

END;

END;

=

—

(GountStr,

'','*,*"}%

END;
END

Listing 10-2 shows, in Rez format, the resources that are used by the Monitors control panel
extension shown in Listing 10-1.

Designing an Extension for the Monitors Control Panel

—_ 10-2]

Inside Macintosh, Volume VI

Listing 10-2. Resources for a file that extends the Monitors control panel
#include

"Types.r"

#include
#include

"Pict.r"
"SysTypes.r"

type

'kcah'

as

'STR

'';

type

'card'

as

'STR

'';

type

'sysz'

{

unsigned

type

'RECT'

hex

longint;

};

{
rect;

17
/*

used

type

{

to

keep

track

of

filter

type

*/

sleep

interval

'INTE'

integer;

};
/*

used

type

{

to

maintain

setting

of

*/

'SLEP'

integer;

};
resource

'sysz'

$1000

/*

(0,

purgeable)

about

64

KB

{

needed

in

system

heap

Computer,

Inc."

*/

}3

resource

‘'vers'

0x01,

Ox00,

(1)

{

release,

0x00,

verUS,

"1,00",
"1.00,
Copyright

©

1990

Apple

3
resource

‘kcah'

"Monitors

(0,

purgeable)

Extension

{

Sample"

};
resource
'BNDL'
‘keah',

};

(128,

0,
{
SICN#';

£0;

1283;

"FREF',

{0,

128}

purgeable)

{

}

10-22

Designing an Extension for the Monitors Control Panel

Control Panels

resource

'ICN#'

(128,

{

array:

2

/*

purgeable)

elements

{

*/

y= [iL] wy
$"0000 0000
$"0A00 0050
S"OA8A 2950
$"0A82 2E50
S"O9FF FF90O
$"0800 0010
$"0800 0010
$"0400 0020
f* [2] *F

O7FF
OAO0O
OAF3
OA00
0800
0800
0800
0400

$"0000

0000

O7FF

FFEO

OFFF

FFFO

OFFF

FFFO"

S"OFFF

FFFO

OFFF

FFFO

OFFF

FFFO

OFFF

FFFO"

S"OFFF

FFFO

OFFF

FFFO

OFFF

FFFO

OFFF

FFFO"

S"OFFF

FFFO

OFFF

FFFO

OFFF

FFFO

OFFF

FFFO"

S"OFFF

FFFO

OFFF

FFFO

OFFF

FFFO

OFFF

FFFO"

S"OFFF

FFFO

OFFF

FFFO

OFFF

FFFO

OFFF

FFFO"

S"OFFF

FFFO

OFFF

FFFO

OFFF

FFFO

O7FF

FFEO"

S"O7FF

FFEO

O7FF

FFEO

O7FF

FFEO

O7FF

FFEO"

'ICON'

(-4096,

FFEO
0050
CE50
0050
0010
0010
0010
0020

0800
OAF3
0A82
OAOO
OFFF
0800
0800
0400

0010
CE50
4950
0050
FFFO
7F10
0010
0020

O9FF
OA8A
OA82
OADO
0800
0800
O7FF
O7FF

FF90"
2950"
2950"
0050"
0010"
0010"
FFEO"
FFEO",

—_
a
~
€)

=
i)

_
—>

Sc
—

—
as —
~
~
—

@

—
i 2)

3
data

$"0000
$"0A00
S"OA8A
$"0A82
S"O9FF
$"0800
$"0800
$"0400

purgeable)

{

0000
0050
2950
2E50
FF90O
0010
0010
0020

O7FF
OA0O
OAF3
OA00
0800
0800
0800
0400

FFEO
0050
CE50
0050
0010
0010
0010
0020

0800
OAF3
OA82
OAODO
OFFF
0800
0800
0400

0010
CE50
4950
0050
FFFO
7F10
0010
0020

O9FF
OA8A
OA82
OAODD
0800
0800
O7FF
O7FF

FF9O0"
2950"
2950"
0050"
0010"
0010"
FFEO"
FFEO"

$"0000

0000

O7FF

FFEO

OFFF

S"OFFF

FFFO

OFFF

FFFO

OFFF

FFFO

OFFF

FFFO"

FFFO

OFFF

S"OFFF

FFFO

OFFF

FFFO

OFFF

FFFO

OFFF

FFFO"
FFFO"

S"OFFF
S"OFFF

FFFO
FFFO

OFFF
OFFF

FFFO
FFFO

OFFF
OFFF

FFFO
FFFO

OFFF
OFFF

FFFO"
FFFO"

S"OFFF

FFFO

OFFF

FFFO

OFFF

FFFO

OFFF

FFFO"

S"OFFF

FFFO

OFFF

FFFO

OFFF

FFFO

O7FF

FFEO"

S"O7FF

FFEO

O7FF

FFEO

O7FF

FFEO

O7FF

FFEO"

};
resource
{

/*
f*

'DITL'

(-4096,

purgeable)

array DITLarray:
[1]
*¥/

{1.0,,

161,

Ta,

StaticText
{
disabled,
"Monitor

"\n©

1990

10

{

elements

*/

301},

Extension

Apple

Example

Computer,

\n

Screen

saver"

Inc."
(Continued)

Designing an Extension for the Monitors Control Panel

— 10-23

Inside Macintosh,

Volume VI

Listing 10-2. Resources for a file that extends the Monitors control panel (Continued)
y* [2] *7
{0
1, 81,
UseriItem

219},

{

enabled
ey

/*® [3] *f
{50, 79, 59:,.
UserItem

88},

{

enabled
iv

f*® [@] */
{39, 79, 49,
UseriItem

88},

{

enabled

iz
xe [oS] */
{43,
58, 58,
StaticText
{

783,

enabled,
WAY)"

Ur
/* [6] */
{41, 55, 57,

75},

UserItem
{
enabled

ey
fe (FJ Fz
{89, 128,
106, 236},
StaticText
{
enabled,
"Filter Type"
hy
{* fel #7
{Ql
25; 38,. 162),
StaticText
{
enabled,
"Minutes

before

By
f* [GJ */
£112,
102, 131,
RadioButton
{

sleep"

2495},

enabled,

"Zirconian Filtration"
J
{™ [10] */
{i32;
102; 151,. 2443,

RadioButton
enabled,

{

"Anti-Aliasing

Filter"

},

10-24

Designing an Extension for the Monitors Control Panel

Control Panels

fe [il] *¥
{40, 79, 58,
Picture

90},

{

enabled,

-4080
~
=
—

i

s
\

4

=
—

Ld

resource

'FREF'

(128,

purgeable)

a

PS :
—

{

—
=

'cdev',

—
~-

as=
=

0,

©—
ee

ay

he
resource

'RECT'

(-4096,

purgeable)

{
{-80,0,0,320}

};3
/*

The

'card'

resources

ensure

called when Options is
cards are being used:

a

Macintosh

Display

Card

Macintosh

Display

Card

resource

‘'card'

"Macintosh
—_—

{

(-4080,
Display

‘card'

"Macintosh

that

pressed

824

this

cdev

and

the

for

some

is

following

GC

purgeable)
Card"

(-4079,

purgeable)

Display

Card

8«24

resource

is

used

GC"

}3
/*

The

a

'STR#'

name

for

sResource

the
of

card

the

that

is

if

different

reason

from

the

you

one

want

in

to

the

display

board.

¥/
resource

'STR#'

(-4096,

purgeable)

{
{

"Macintosh

Display

Card";

"Macintosh

Display

Card

824";

"Macintosh

Display

Card

8°24

GC";

"Macintosh

Display

Card

8*24

GC

'The

Accelerated'"};

(Continued)

Designing an Extension for the Monitors Control Panel

— 10-25

Inside Macintosh,

Volume VI

Listing 10-2. Resources for a file that extends the Monitors control panel (Continued)
resource

'ALRT'

(130,

purgeable)

{50, 30, 190, 400},
130,
{
/* array:
4 elements
xe (2)
OK, visible,
soundl,
{® [e\ */
OK, visible,
soundl,
f* ES] *F
OK,

visible,

{=

[4]

OK,

visible,

{

*/

soundl,

*7Z
soundl

hs
resource

'ALRT'

(131,

purgeable)

{50, 30, 190, 400},
131,
{
/* array:
4 elements
oP LT
a¥
OK, visible,
soundl,
Fe [2] *7
OK, visible,
soundl,
/* [3]. #2
OK, visible,
soundl,
f® [A] FF
OK, visible,
soundl

{

*/

Pr;
resource

{

'DITL'

(130,

purgeable)

/* array DITLarray:
2
f*® [ZI] 7
{90; 267,
110; 337},
Button

{

elements

*/

{

enabled,
ROK!

be
{*® [2] *Y7
{10, 60, 70,
StaticText
{
disabled,

350},

"There

not

is

enough

memory"

3
resource

'DITL'

{

array

/*

re

{90,

10-26

Ty

Ry

267,

(131,

purgeable)

DITLarray:

110,

2

{

elements

*/

337},

Designing an Extension for the Monitors Control Panel

Control Panels

Button
{
enabled,

"OK"

},
7* [2] */
{10,
60, 70,
StaticTex t {
disabl ed,
"An
"

350},

—
_
—

er ror

the

occurred.
options.
"

\nI

cannot

\ 4
_
~
—

display"

—

a
—_ ?
=~
~~
—
—

as w
~
_
~

©—

yy

D

/*

used

resource

to

keep
'INTE'

the setting
of the
(-4080,
purgeable)

filter
{

the

time

type

controls

*/

5
};
/* used to keep
resource
'SLEP'

setting

(-4080,

of

the

purgeable)

to

sleep

*/

{

5

};
/*

PICT

display the arrows to
(-4080)
{
283},
(134,
Ate,
a 52,
VersionOne
{
2 elements
{
/* arr ay OpCodes:
{® {4)] */

resource

used

to

increase/decrease

the

sleep

time

*/

'PICT'

clipRgn

*/

{

{-30000,

-30000,

30000,

30000},

Sa

},
/*

[2]

*

bitsRect
2's
{254,
{254,
(434,

/

{
352,
352,
272,

272,
272,
152,

368},
363}.
2833,

srcCopy,

$"3F80
$"8020
$"4040

4040 8420
8020 8E20
3F80"

8E20
8E20

9F20
BFAO

BFAO
9F20

8E20
8E20

8E20"
8420"

Designing an Extension for the Monitors Control Panel

10-27

Inside Macintosh,

Volume VI

INCLUDING ANOTHER CONTROL PANEL
IN A MONITORS EXTENSION FILE

DEFINITION

A control panel file that contains an extension to the Monitors control panel can also contain a
definition for another, separate control panel. You might want to include both an extension to
the Monitors control panel and a new control panel definition in the same file, for example, if
each controlled some features of the same video card. Any control panel definition must
include a 'cdev' resource and the other resources described in the Control Panel chapter of
Volume V.
Because the control panel resources and the Monitors extension resources in the file have
different resource ID numbers, the Finder handles them separately. If the user opens a control
panel file containing both a control panel definition and an extension to the Monitors control
panel, the control panel defined in that file appears on the screen and the Finder ignores the
Monitors extension in that file. If the user opens the Monitors control panel file, then the
Monitors cdev function searches the other control panel files in the same folder for extensions
and ignores any 'cdev' resources it finds in those files. The user cannot open a control panel
file that contains only an extension to the Monitors control panel; such a file can be opened
only by the Monitors cdev function.

10-28

— Including Another Control Panel Definition in a Monitors Extension File

Control Panels

SUMMARY OF THE EXTENSION FILE
THE MONITORS CONTROL PANEL

FOR

Constants
CONST

=

initMsg
okMsg
cancelMsg

=
=
=

1;
2;
3%

{initialization}
{user clicked OK button}
{user clicked Cancel button}

hitMsg

=

4;

{user

nulMsg

=

5:

{periodic

updateMsg
activateMsg

=
=

6%
Ty

{update event}
{not used}

deactivateMsg

=

8;

{not

keyEvtMsg

=

9;

{keyboard

superMsg

=

10:

{show

superuser

normalMsg
startupMsg

w
=

Lis
12:

{show
{code

only normal
controls}
has been
loaded}

Application-Defined
FUNCTION

MyMntr

clicked

control

in

S.
Sy
Ps

Options

dialog

box}

event}

used}
event}
controls}

Routine
(message,item,numItems:

LongiInt;

mDialog:

EventRecord;

screenNum:

ScrnRsrcHandle;

Integer;

DialogPtr;
VAR

monitorValue:

theEvent:

Integer;

scrnChanged:

VAR

screens:

Boolean)

Longint;

Summary of the Extension File for the Monitors Control Panel

— 10-29

7

Inside Macintosh, Volume VI

10-30

THE

HELP

MANAGER

About This Chapter
About the Help Manager
Help Balloon Display
Default Help Balloons for Menus, Windows, and Icons
Using the Help Manager
Providing Text or Pictures for Help Balloons
Defining the Help Balloon Content
Using Clear, Concise Phrases
Using Active Constructions
Using Parallel Structure
Using Consistent Terminology
Defining the Help Balloon Position
Specifying the Format for Help Balloon Content
Specifying Options in Help Resources
Providing Help Balloons for Menus
Providing Help Balloons for Items in Dialog Boxes and Alert Boxes
Providing Help Balloons for Window Content
Help Balloons in Static Windows
Help Balloons in Dynamic Windows
Overriding Help Balloons for Application Icons
Overriding Other Default Help Balloons
Adding Your Own Menu Items to the Help Menu
Writing Your Own Balloon Definition Function
Help Manager Routines
Determining Whether Help Is Enabled
Determining Whether a Help Balloon Is Showing
Displaying and Removing Help Balloons
Displaying a Help Balloon
Using Your Own Menu Definition Procedure
Removing a Help Balloon
Using Your Own Tip Function
Adding Items to the Help Menu
Getting and Setting the Font Name and Size
Getting and Setting Information for Help Resources
Getting the Dimensions of a Help Balloon
Getting the Content of a Help Balloon
Summary of the Help Manager

—
—

a>
fe.

«|
4
=
=
>
gaa)

a|

1]-]

Inside Macintosh, Volume VI

11-2

The Help Manager

ABOUT

THIS

CHAPTER

This chapter describes how you can use the Help Manager to provide your users with

Balloon Help™ on-line assistance—information that describes the actions, behaviors, or

properties of elements of your application. When the user turns on Balloon Help assistance,
the Help Manager displays small help balloons as the user moves the cursor over areas
such as scroll bars, buttons, menus, or rectangular areas in your windows. Help balloons
are rounded-rectangle windows that contain explanatory information for the user. (With
tips pointing at the objects they annotate, help balloons look like the balloons used for dialog
in comic strips.) You provide the content for these help balloons in the form of descriptive
text or pictures. The information should be short and pertinent to the object or element that
the cursor is over.
For example, when a user moves the cursor to a menu command, a help balloon pointing to
that command explains its function. The help balloon is displayed until the user moves the
cursor away.
The user turns on Balloon Help on-line assistance for all applications by choosing the Show
Balloons command from the Help menu. All normally available features of your application
are still active when Balloon Help is enabled. The help balloons only provide information;
the actions that the user performs by pressing the mouse button still take effect as they
normally would.
The Help Manager is available only in system software version 7.0. Use the Gestalt function
to determine whether the Help Manager is present.
Read this chapter if you want to provide descriptive information for the menus, windows,
dialog boxes, or alert boxes used by your application, desk accessory, control panel,
Chooser extension, or other software that interacts with the user. If you presently offer
another help facility for your users, you should now let users gain access to your information through the Help menu. This chapter explains how you can add your own menu items
to the Help menu to provide one convenient and consistent place for the user to look for
help information.
You can provide help for the menus, dialog boxes, and alert boxes of your existing applications, desk accessories, or control panels by simply adding resources to your resource fork.
In addition, you can provide help for the content area of windows by using either resources
or Help Manager routines.
To use this chapter, you should be familiar with the Resource Manager. You provide help for
your application by storing the information regarding help balloons in resources. To provide
help for menus, windows, dialog boxes, or alert boxes, you should also be familiar with the
Menu Manager, Window Manager, Dialog Manager, and Control Manager as described in
previous volumes of /nside Macintosh.

About This Chapter

11-3

_
—

an)

oO

=

Kd
—

i)
|
ioe)
ge
i)
er

Inside Macintosh,

Volume

ABOUT

HELP

THE

VI

MANAGER

You can use the Help Manager to provide help for these elements of your application:
= menu titles and menu items
a dialog boxes and alert boxes
= windows, including any object in the frame or content area
m other application-defined areas
Providing help balloons for menus, dialog boxes, or alert boxes is quite simple: you need
only create resources containing the help information that you want to relay to the user. The
Help Manager automatically sizes, positions, and draws the help balloon and its content for
you. It is equally simple to provide help balloons for a window whose elements don’t change
location within its content area.
It takes a littke more work to provide help balloons for windows in your application that
contain objects that are dynamic or that change their position within the content area of the
window. You provide Balloon Help assistance for these objects by tracking the cursor
yourself and using Help Manager routines to display help balloons. You can let the Help
Manager remove the help balloon, or your application can determine when to remove the
help balloon.
The user turns on Balloon Help on-line assistance by choosing Show Balloons from the Help

menu. As shown in Figure | |-1, the Help menu is identified by an icon consisting of a

question mark enclosed in a small help balloon. It appears to the left of the Application menu
(and to the left of the Keyboard menu, if a non-Roman script system is installed) and to the
right of all other menus. Users can turn on Balloon Help assistance even when your
application presents a modal dialog box, because the Help menu is always enabled.

(@ File Edit View Label

Special

About Balloon Help...
Show

Balloons

Finder Shortcuts

Figure 11-1. The Help menu for the Finder
When Balloon Help assistance is turned on, the Help Manager displays any help balloons for
the current application whenever the user moves the cursor over a rectangular area that has a
help balloon associated with it.
The Help Manager provides a default help balloon for inactive windows and displays default
help balloons for the title bar and other parts of the active window. The Help Manager also
displays default help balloons for other standard elements of an application’s user interface.
A later section, “Default Help Balloons for Menus, Windows, and Icons,” describes the
default help balloons. (Though you probably won’t want or need to change the messages
11-4

About the Help Manager

The Help Manager

in these default balloons, you have the ability to do so, as described later in “Overriding
Other Default Help Balloons.”) The Help Manager displays the default help balloons for
your application whenever Balloon Help assistance is enabled, even if your application
does not explicitly use or create help balloons.
All normal features of your application are available when Balloon Help assistance is on. The
Help Manager can display a balloon when the mouse button is pressed as well as when the
mouse button is up. Help balloons do not interfere with your application. The user can still
click and double-click as normal when Balloon Help assistance is enabled.
The display of help balloons is driven mainly by the action of the user. For those balloons
defined as standard help resource types, the Help Manager automatically tracks the cursor and
generates the shape and calculates the position for the help balloon. The Help Manager displays each help balloon as the user moves the cursor to the area associated with it. The Help
Manager removes the help balloon when the cursor is no longer over the associated area.
Once the user chooses Show Balloons, help is enabled for all applications. When the user
chooses Hide Balloons from the Help menu, the Help Manager removes any visible help
balloon and stops displaying help balloons until Balloon Help assistance is turned on again.

="
bd

vale
2

ig]

<

—_
=)
=
eS)
ga
@
~

This chapter provides a brief description of how the Help Manager displays help balloons,
gives information on the default help balloons, and then discusses how to
create the text or picture content for help balloons
m create resources for help balloons for menus, dialog boxes, and alert boxes
m create resources for help balloons for windows
m add your own menu items to the Help menu
m override the default help balloons provided by system software
m

write your own balloon definition function

Help Balloon

Display

The Help Manager performs most of the work involved with rendering help balloons for your
application. This section gives an overview of the facilities that the Help Manager uses to
display balloons and how you employ them in your application.
The Help Manager uses the Window Manager to create a special type of window for the help
balloon and then draws the content of the help balloon in the port rectangle of the window.
The Help Manager is responsible for
= calculating the size of the help balloon (based on the content of the user help information
you provide)
m determining line breaks for text in a help balloon
m calculating where to display the help balloon so that it appears on screen
w drawing the help balloon and its content on screen
About the Help Manager

11-5

Inside Macintosh, Volume VI

A balloon definition function, which is an implementation of a window definition function, defines the general appearance of the help balloon. A standard balloon definition function
is provided for you, and it’s responsible for
m calculating the content region and structure region of the help balloon (based on the
rectangle calculated by the Help Manager)
w drawing the frame of the help balloon
The standard balloon definition function is the window definition function (a "'WDEF'

resource) with resource ID 126. Figure | 1-2 shows the general shape of a help balloon
drawn with this standard balloon definition function.

Figure 11-2. A help balloon drawn with the standard balloon definition function
Every help balloon is further defined by its tip, a hot rectangle, and a variation code.
A small pointer extends from a corner of every help balloon; this element indicates what
object or area is explained in the help balloon. The tip is the point at the end of that
element. Figure | 1-3 shows an example of a help balloon for a control. The balloon tip
is at coordinates (38,158) of the window.

verb Tenses

|

[==

Fl

ee

qa

AS

A

(0,0)

Click here to replace
the selected verb
with its future tense.

(65,165)

=
Figure 11-3. The tip and hot rectangle for a help balloon
The hot rectangle encloses the area for which you want to provide Balloon Help on-line
assistance. If the cursor is over a hot rectangle, the Help Manager displays its help balloon.
The Help Manager removes the help balloon when the cursor is moved away. The user must

11-6

About the Help Manager

The Help Manager

pause with the cursor at the same location for a brief amount of time (around one-tenth of a
second) before the Help Manager displays the help balloon. This prevents excessive flashing
of help balloons. The length of time that a user must pause before a help balloon appears is
set by the system software and cannot be changed.
In Figure 1 1-3, the help balloon is displayed for a hot rectangle defined by local coordinates
(0,0,65,165). The Help Manager displays and removes the help balloon as the cursor moves
in and out of the area defined by the hot rectangle.
A variation code specifies the preferred position of the help balloon relative to the hot
rectangle. The balloon definition function draws the frame of the help balloon based on
that variation code.

—
—

As shown in Figure 11-4, the standard balloon definition function provides eight different
positions, which you can specify with a variation code from 0 to 7. The figure also shows
the boundary rectangle for each shape. Note that the tip of the help balloon always aligns
with an edge of the boundary rectangle. If you write your own balloon definition function,
you should support the tip locations defined by the standard variation codes.

—
ms

‘27
coos

aenl
—_

ra

st
ae
ner
tose
—
ae
one
7<
-

ia

Position 0

cs

Position 4

—

Position 1

Position 5

Position 2

Position 6

Position 3

Position 7

Figure 11-4. Standard balloon positions and their variation codes

About the Help Manager

11-7

.

Inside Macintosh,

Volume

VI

For most of the help balloons it displays, the Finder™ uses variation code 6. A balloon with
variation code 6 has its tip in the lower-left corner and projects up slightly and to the right.

If a help balloon is on screen and not in the menu bar, the Help Manager uses the specified

variation code to display the help balloon. If a help balloon is offscreen or in the menu bar,

the Help Manager attempts to display the help balloon by using a combination of different
variation codes and different tip locations.

Usually, the Help Manager moves the tip by transposing it across the horizontal and vertical
planes of the hot rectangle. However, when you use dialog item help (‘hdlg') resources or
the HMShowBalloon and HMShowMenuBalloon functions, the Help Manager allows you to
specify alternate rectangles for transposing balloon tips. Alternate rectangles give you
additional flexibility in positioning your help balloons on screen. If you make your alternate
rectangle smaller than your hot rectangle, for example, you have greater assurance that the
Help Manager will be able to fit the help balloon on screen; if you specify an alternate rectangle that is larger than your hot rectangle, you have greater assurance that the help balloon
will not obscure some element explained by the balloon.
Figure | 1-5 shows the Help Manager making three attempts to fit a help balloon on screen by
moving the tip to three different sides of the hot rectangle and using an appropriate variation
code for each tip.
When positioning a help balloon on screen, the Help Manager first checks whether the screen
has enough horizontal space and then enough vertical space to display the balloon using the
specified variation code and tip. If the help balloon is either too wide or too long to fit on

f

—
G File

Edit

View

Special

2 SSS

>
1

CSE

y

J

[

—

eS
SS_ =

a

Figure 11-5. Alternate positions of a help balloon
11-8

About the Help Manager

The Help Manager

screen at this position, the Help Manager tries a different variation code. If the help balloon
lies within the hot rectangle (or, if appropriate, within the alternate rectangle), the Help
Manager—using the new variation code—keeps the specified tip and again tests whether
the help balloon fits. If, as in Figure 11-5, the help balloon lies outside of the hot rectangle
(or the alternate rectangle), the Help Manager—using the new variation code—moves the
tip to a different side of the rectangle and again tests whether the help balloon fits. If, after
exhausting all possible positions, the Help Manager still cannot fit the entire help balloon on
screen, the Help Manager displays a help balloon at the position that best fits on screen and
clips the content of the balloon to fit at this position.
You create help resources that describe the content, the balloon definition function, the varia-

tion code, and, when necessary, the tip and the hot rectangle or alternate rectangle for the
Help Manager to use in drawing a help balloon. These help resources are

—
—

m the menu help (‘hmnu’) resource to provide help balloons for menus and menu items

s")

w the dialog item help (‘hdlg') resource to provide help balloons for items in dialog boxes
or alert boxes
m the rectangle help (‘hrct') resource to associate a help balloon with a hot rectangle in a
static window
m the window help (‘hwin’) resource to map an ‘hrct' or ‘hdlg' resource to a hot rectangle
in a window or to a dialog item in a dialog box or alert box
m the Finder help override (‘hfdr') resource to provide a customized help balloon for your
application icon
m the default help override (‘hovr'’) resource to override the content of default help
balloons provided in system software
To put help balloons in your application, you are responsible for
m Creating any necessary help resources for your application.
m Providing the user help information that forms the content of the help balloons. Although
you can store this information in the help resources themselves or in data structures,
localizing your help content is much easier if you store it in other resources—such as
‘PICT’, 'STR#', ‘STR ', 'TEXT", and ‘styl’ resources—that are easier to edit.
m Specifying in your help resources a balloon definition function for your help balloons.
Typically, you should use the standard balloon definition function that draws shapes
similar to that shown in Figure 11-2. This helps maintain a consistent look across all
help balloons used by the Finder and other applications. However, if you feel absolutely
compelled to change the shape of help balloons in your application, you can write your
own balloon definition function as described in “Writing Your Own Balloon Definition
Function” later in this chapter. Be aware that a different help balloon shape may initially
confuse your users.
a Specifying in your help resources a variation code. The variation code positions your
balloons on screen according to the general shape described by their balloon definition
function. If you use the standard balloon definition function, you'll use variation codes
0 to 7 to display the help balloons shown in Figure 11-4. The preferred variation code
is 0. If you are unsure of which variation code to use, specify 0; the Help Manager will
use a different variant if another is more appropriate. If you write your own balloon
definition function, you must define your own variation codes.
About the Help Manager

11-9

=_

=
fg
|
py)
ge
g
—

Inside Macintosh,

Volume VI

For objects other than menu items, you are also responsible for
m Specifying in your help resources the tip location for the help balloon. For menu items,
the Help Manager automatically places the tip just inside the right edge of the menu item.
m Specifying rectangles in your help resources. The rectangles around menu items
and dialog items define their hot rectangles for you. For 'hdlg' resources, you specify
alternate rectangles for moving the help balloon. For ‘hret' resources, you specify hot
rectangles, which define the areas on screen for association of help balloons.
m Tracking the cursor in dynamic windows, and, when the cursor moves over a hot rectangle in your window, calling Help Manager routines (such as HMShowBalloon) to
display your help balloons. You can let your application or the Help Manager remove
the help balloon when the user moves the cursor off the hot rectangle.
In summary then, the Help Manager automatically displays help balloons in the following
manner. The user turns Balloon Help assistance on, then moves the cursor to an area described
by a hot rectangle. The Help Manager calculates the size of the help balloon based on its
content. For text or strings, the Help Manager uses TextEdit to determine the word and line
breaks of text in the help balloon. The Help Manager then determines the size of the help
balloon and uses the Window Manager to create a new help balloon. The Window Manager
calls the balloon definition function to determine the help balloon’s general shape and position.
(If the variation code places the help balloon offscreen or in the menu bar, the Help Manager
tries a different variation code or moves the tip of the help balloon to another side of the hot

rectangle or the alternate rectangle.) The window definition function draws the window frame,
and the Help Manager draws the content of the help balloon.

For most interface elements that you want to provide help for, you create the content of the
help balloon (preferably in a separate, easily edited resource) and, in the help resources
themselves, you specify the standard balloon definition function, one of the eight variation
codes, the tip location, and a hot rectangle.
The Help Manager does not automatically display help balloons for dynamic windows or for
menus using customized menu definitions. To provide help balloons for these elements or in
other circumstances where you want more control over help balloons, you must identify hot
rectangles, create your own data structures to store their locations, track the cursor yourself,
and call HMShowBalloon when the cursor moves to your hot rectangles. If you wish to, you
can also write your own balloon definition function and tip function.

Default

Help

Balloons

for

Menus,

Windows,

and

Icons

The Help Manager displays many default help balloons for an application when help is
enabled and the user moves the cursor to certain standard areas of the user interface. These
areas include the standard window frame and the menu titles and menu items in the Apple®
menu, Help menu, Keyboard menu, and Application menu. You don’t need to create any
resources or use any Help Manager routines to take advantage of the default help balloons.
The following list summarizes the items that have default help balloons.

11-10

About the Help Manager

The Help Manager

Interface

item

Description

Application icon in Finder

Default help also for desk accessories, system
extensions, control panels; can be customized

Document icon in Finder

Cannot be customized

Standard file dialog boxes

You add balloons for extra dialog items

Window title bar

In standard and customized WDEFs

Window close box

In standard and customized WDEFs

Window zoom box

In standard and customized WDEFs

Inactive window

Can be customized

—

oy
a7

a=)

Apple menu title

Standard menu definition procedure only

Apple menu items

Default balloons are provided for items in the
Apple Menu Items folder, but there is no default
balloon for the About command or other items
that your application adds

Help menu title

Standard menu definition procedure only

Help menu items

Default balloons are provided only for the About
Balloon Help and Hide/Show Balloons items

Application menu title
and items

Standard menu definition procedure only

Keyboard menu title

Standard menu definition procedure only

and items

—,

2vat

tt)
~
f
ge

a)
va}

System software version 7.0 uses the Help Manager to display help balloons for most dialog
boxes and alert boxes. For example, the Standard File Package provides help balloons for its
standard file dialog boxes. If your application uses a system software routine (such as the
StandardPutFile procedure) that provides help balloons, and the user has turned on Balloon
Help assistance, the Help Manager displays each help balloon as the user moves the cursor to
each hot rectangle. If you’ve added your own buttons, check boxes, or controls to such a
dialog box or alert box, you can also provide these elements with help balloons.
The Help Manager displays help balloons for the standard window frame and other standard
elements described in the 'hovr' resource. You can override any of the default help balloons
defined in the 'hovr' resource by providing your own resource of type 'hovr'. See “Overriding
Other Default Help Balloons” later in this chapter for more information.

About the Help Manager

11-11

Inside Macintosh, Volume VI

The Help Manager uses the window definition function of a window to determine whether
the cursor is in the window frame and, if so, which part of the window frame (title, close
box, or zoom box) the cursor is over. If the cursor is in any of these areas, the Help Manager
displays the associated help balloon. Figure 1 1-6 shows the default help balloons for the
active window of an application that uses the standard window definition function. If you use
a customized window definition function, the Help Manager also displays these default help
balloons for the corresponding elements in your windows.
E

“od

Close box

Bz

ats

To close this
window, click here.
J

vo
i)
EL

untitlea i

ae}

Zoom box

.

To change the size of the window
quickly , click here. Clicking the zoom
box once sizes the window so that all

of its contents are visible Gif
possible). Clicking it again returns
the window to its original size.

i—f\.

yo

U
pol]

=

Untitled
x

aE
ats

Title bar

=

This is the window’s title

bar. To move the
window, position the
pointer in the title bar
and drag the window.
\

A

-—I

v

pad)

Figure 11-6. Default help balloons for the window frame
The Finder also uses these help balloons for its window titles and its close and zoom
boxes. The Finder provides additional help for other elements of its windows—for
example, the scroll bar and size box—although this help is not provided for the
windows in your application.
The Help Manager displays default help balloons for the Apple menu, Help menu, and
Application menu. The Menu Manager uses the Help Manager to display help balloons for
these menus regardless of whether you supply help balloons for the rest of your menus.
The Help Manager also provides default help balloons for the Keyboard menu when a nonRoman script system is installed. Figure 11-7 shows the default help balloons for the Apple

menu and Help menu titles.

11-12

About the Help Manager

.

The Help Manager

Note: The Help Manager displays default help balloons only for applications that
use the standard menu definition procedure. If you use your own menu definition
procedure, your application must track the cursor and use Help Manager routines to
display and remove help balloons, as described later in “Using Your Own Menu
Definition Procedure.”

&

(2)
~
Apple menu

Help menu

Use this menu to see
information about the active
application or program, or to
open an item in the Apple
Menu Items folder.

Use this menu to get
information that helps
you use your computer,

—
—

—
=
J.)

&

<—
mS

Figure 11-7. Default help balloons for the Apple and Help menus
The Help Manager does not provide default help balloons for items you put at the top of your
application’s Apple menu or items you add to the Help menu. You typically put one item at
the top of the Apple menu: the About command for your application. If you have additional
user help facilities, list them in the Help menu—not in the Apple menu. You have control
only over those items that you add to these menus; system software handles help balloons for
the rest of the items.

The Finder provides default help balloons for your application icon and any documents
created by your application. Figure 11-8 shows the default help balloon for the SurfWriter
application and a document created by this application. You can customize the help balloon
for your application icon by providing an ‘hfdr' resource; however, you can’t customize
the default help balloon for the documents created by your application.
rc
This is an application—a

program with which you can

:

f

perform a task or create a
document. Applications
include word processors,

You can open and modify
this document using the

spreadsheets.

program.

graphics programs, and

Ci

“Surfwriter ” document

Surfwriter

:

“Surfwriter ” application

Re

Letter

:

Figure 11-8. Default help balloons for application and document icons

About the Help Manager

— 11-13

=
i)
ge
g

Inside Macintosh,

Volume VI

USING

HELP

THE

MANAGER

You can use the Help Manager to provide information to the user that describes the action,
behavior, or properties of elements of your application. For example, you can create a help
balloon for each menu command to describe what it does.
The Help Manager is available only in system software version 7.0. Use the Gestalt
function with the Gestalt selector gestaltHelpMegrAttr. Test the bit field indicated by the
gestaltHelpMgrPresent constant in the response parameter. If the bit is set, then the
Help Manager is present.
CONST

gestaltHelpMgrPresent

=

0;

{if
{

this

Help

bit

is

Manager

set,
is

then

}

present}

The Help Manager is initialized at startup time. The user controls whether help is enabled by
choosing the Show Balloons or Hide Balloons command from the Help menu.

The Help menu is specific to each application, just as the File and Edit menus are specific to
each application. The Help menu items that are defined by the Help Manager are common to
all applications, but you can add your own menu items for help-related information.

When your application calls the InsertMenu procedure, the Menu Manager automatically
appends the Help menu to your menus. The Help menu is automatically appended to the right

of all your menus and to the left of the Application menu (and to the left of the Keyboard
menu if a non-Roman script system is installed).

You can create help balloons for the menus, dialog boxes, alert boxes, or content area of

windows belonging to your application. You can also override some of the default help
balloons—such as the default help balloon for the title bar of a window.

You can specify the content of a help balloon using text strings, styled text, or pictures.
Although you should always strive for brevity in your help messages, text strings can contain
up to 255 characters. You can use up to 32 KB with styled text. The Help Manager determines

the actual size of the help balloon and, for text strings, uses TextEdit to determine the word

and line breaks of text.

The Help Manager automatically tracks the cursor and generates help balloons defined in
standard help resources. Your application can also track the cursor and use Help Manager
routines to display and remove help balloons.

Providing

Text or Pictures for Help

Balloons

Use help balloons to provide the user with information that describes or explains elements of
your application. The information you supply in help balloons should follow a few general
guidelines in order to provide the most useful information to the user. This section describes
these guidelines.

For examples of how your application should use help balloons, observe the help balloons
provided by the Finder, the TeachText application, and system software.
11-14

— Using the Help Manager

The Help Manager

Defining the Help Balloon

Content

Use help balloons to explain parts of the interface of your application that might confuse a
new user or elements that could help a user become an expert user. The information you
provide in help balloons should identify interface elements in your application or describe
how to use them. Each help balloon should answer at least one of these questions:
a What is this? For example, when the user moves the cursor to the item count in the
upper-right corner of a Finder window, the Finder displays a help balloon that reads
“This is the number of files or folders in this window.”
us What does this do? For example, when the user moves the cursor to the Find
command in the Finder’s File menu, the Finder displays a help balloon that reads “Finds
and selects files and folders with the characteristics you specify.”
= What happens when I click this? For example, when the user moves the cursor to
the close box of a window, the Window Manager displays a help balloon that first
defines the element (“Close box’’) and then explains “To close this window, click here.”
The content of help balloons should be short and easy to understand. You should not include
lengthy instructions or numbered steps in help balloons. Use help balloons to clarify the
meaning of objects in your application—for example, tool symbols in palettes.
Use simple, clear language in the information you provide. Include definitions in help
balloons when appropriate.
You can use graphics or styled text in help balloons to illustrate the effects of a command.
For example, to demonstrate the Bold command in a word-processing application, you
might use styled text to show a word in boldface.
You can provide separate help balloons for each state of a menu item or dialog item. The help
balloon that you provide for an enabled menu item should explain the effect of choosing the
item. The help balloon that you provide for a dimmed menu item should explain why it isn’t
currently available, or, if more appropriate, how to make it available.
Complicated dialog boxes can often benefit from help balloons that explain what’s essential
about the dialog box. You can use help balloons to describe groups of controls rather than
individual controls. For example, if a dialog box has several distinct regions that contain
radio buttons or check boxes, you could provide a help balloon for each set of radio buttons,
rather than providing a separate balloon for each button.
If you use a function to customize standard dialog boxes, use as many of the existing help
balloons as possible. For example, if your application uses any of the standard file dialog
boxes and provides an extra button, you can create a help balloon for the extra button, and the
Help Manager continues to use the default help balloons for other elements of the dialog box.
To make localization easier, you should store the content of your help balloons in resources
separate from the help resources. See the Worldwide Software Overview and User Interface
Guidelines chapters in this volume for extensive information about developing software for a
worldwide market.

Using the Help Manager

= 11-15

—
—_

—

——
o
=—_

a
Poa
so
=
fo=
a)

ar

Inside Macintosh,

Volume VI

Using

Concise

Clear,

Phrases

You can provide up to 255 characters of information using text strings in help balloons.
(You can use up to 32 KB if you use styled text.) However, you should include only the
most relevant information in the help balloon. To determine what to provide, decide what
information would be most useful to a user. This information doesn’t usually give the
object’s name, which normally doesn’t matter to the user, but instead tells what the object
is for and what the object does. This information does matter to the user.
You might eventually translate your help content into other languages, so try to keep the
information as short as possible. When translated, your help messages may require more
words or longer words—and therefore larger balloons and more screen space. (Translated
text is often 50 percent longer than the equivalent U.S. English text.) Also avoid language
or phrasing that might be colloquial, offensive, or likely to lose its meaning when translated
into another language.
If an item already has a commonly used name, or if it’s a special case of a larger category
of objects, name it in the balloon. The Finder, for example, displays the message “Drag
the title bar to move the window,” since title bars and windows are commonly used names.
However, you don’t need to name everything in your application just so that you can refer to
it in a help balloon. The tip of the help balloon points to the subject of the help balloon. You
can easily say “To apply the style, click here,” rather than “The Apply button activates the
Styles command. Click the button to activate the command.”
For balloons that describe menu items, you can use sentence fragments. The subject can be
omitted because it is obvious from the context. Using sentence fragments lets users assimilate
the content of the balloon more quickly because they have fewer words to read. For example,
the help balloon for the Open command could read “Opens the selected file” rather than “This
command opens the selected file.”

Using Active Constructions
Try to use short, active phrases in help balloons. Avoid passive constructions. An active
construction is more forceful because it communicates how a subject (usually the user in this
context) performs an action. In the sentence “To turn the page, click here,” the implied “you”
(that is, the user) is the subject, and “‘click” is the action that the subject performs. Passive
constructions show subjects being acted upon rather than performing the action. For
example, both “page” and “button” are acted upon in their respective clauses in the sentence
“The page will be turned when this button is clicked.”
Research suggests that in instructional materials it’s better to present the goal clause before

the action clause to help readers quickly recognize how the information meets their needs.

Users are then able to determine whether the content is relevant to what they want to do.
A goal might be “To turn the page,” “To calculate the result,” or “To apply the style.”
For example, the message “To turn the page, click here” starts with a goal statement and
then describes the action necessary to fulfill it; users find this more helpful than a purely
descriptive message like “This button turns the page.”

11-16

— Using the Help Manager

The Help Manager

Using

Parallel

Structure

Use similar syntax for help balloons that describe similar objects. For example, all help
balloons that describe buttons should have the same structure. In a style dialog box,
you might provide these messages for the buttons: “To see the style, click Apply,” “To
implement the style, click OK,” and “To do nothing to change the previous style,
click Cancel.”
Users see help balloons provided by many different applications, so a consistent approach
within your application helps them to quickly identify types of balloons and to develop
realistic expectations about their content.

Using

Consistent

Terminology

—
—

You should employ consistent terminology in all your help balloons. Use language that users
understand. Avoid introducing technical jargon or computer terminology into help balloons.
Follow the style and usage standardized by Apple Computer, Inc., in the Apple Publications
Style Guide (available through APDA®) to make the most effective use of the information and
vocabulary with which users are already familiar.

Defining the Help Balloon

Position

When you provide a help balloon, you specify its content, the tip of the help balloon, and
the variation code for its preferred position. The tip of the help balloon should point to the
object the help balloon describes. You should specify the tip location and the variation code so
that the help balloon doesn’t obscure the object you’re providing help for. In most cases, the
tip of the help balloon should point to an edge of the object you’re providing help for.
You should also consider how the Help Manager repositions the balloon if the variation code
places it offscreen. “Help Balloon Display” earlier in this chapter describes how the Help
Manager repositions the help balloon if necessary.

Specifying the Format for Help Balloon

Content

You specify the format for the content of your help balloons as text strings within
the help resource, as text strings within 'STR ' resources, as lists of text strings within
'STR#' resources, as styled text using "TEXT" and 'styl' resources, or as pictures
within 'PICT' resources.
You can easily add Balloon Help on-line assistance to your existing application without
changing its code by adding the help resources described in the following subsections of
“Using the Help Manager.” When you use help resources, the Help Manager tracks the
cursor and displays and removes help balloons for you. With the routines described later in
“Help Manager Routines,” you can also provide Balloon Help on-line assistance without
using the help resources. However, this requires that your application track the cursor and
display and remove balloons.

Using the Help Manager

11-17

is’)

vo

—

ed

a
——
mn
~~
—

—

i)

ge

a)

er

Inside Macintosh,

Volume VI

Later sections in this chapter describe all the help resources in detail. Common to all the help
resources are the following identifiers, by which you identify the format of your user help
information:
Identifier

Help

content

format

HMStringItem
HMPictltem
HMStringResItem
HMTEResItem
HMSTRReslItem
HMSkipItem

Pascal string within the help resource
'PICT' resource
'STR#' resource
'TEXT' and ‘styl’ resources
'STR ' resource
No content—skip this item

You can use the HMStringItem identifier to store Pascal strings directly in a help resource.
However, you can make it much easier to localize your product by storing your user help
content in separate resources—namely, in 'STR#', 'PICT', ‘STR ', and "TEXT" resources—
that can be modified by nonprogrammers using tools like the ResEdit™ resource editor.
To display a diagram or illustration in 'PICT' format, use the HMPictltem identifier. You
provide help content by specifying the resource ID of the 'PICT' resource that contains
the diagram or illustration, and the Help Manager displays the picture in a help balloon.
To display a string stored in a string list (‘STR#') resource, use the HMStringResItem identifier. As illustrated later in “Providing Help Balloons for Menus,” you provide help content by
specifying two items in your help resource: the resource ID of an 'STR#' resource, and the
index to the particular string that you want displayed from within that list.
To display styled text, use the HMTEResItem identifier. You provide help content by
specifying a resource ID that is common to both a style scrap (‘styl’) resource and a "TEXT"
resource, and the Help Manager employs TextEdit routines to display your text with your
prescribed styles. For example, you might create a 'TEXT’ resource with resource ID 1000
that contains the words “Displays your text in boldface print” and a 'styl' resource with
resource ID 1000 that applies boldface style to the message. (See the TextEdit chapter in
Volume V for a description of the style scrap.)
To display text from a simple text string (‘STR ') resource, use the HMSTRReslItem identifier. You provide help content by specifying the resource ID of an 'STR' resource, and the
Help Manager displays the text from that resource in a help balloon. With 'STR ' resources,
each text string must be stored in a separate resource. It is usually more convenient to group
related help messages in a single 'STR#' resource and use the HMStringResItem identifier
as previously described.
You can use the HMSkiplItem identifier for items or rectangles for which you don’t want to
provide a help balloon. For example, you specify HMSkipItem for the dashed lines that
appear in menus. (Dashed lines cannot have help balloons.)

Specifying

Options

in Help Resources

Each help resource contains a field in its header that allows you to specify certain options.
Notice the options field in the following header component for a menu help resource.

11-18

— Using the Help Manager

The Help Manager

resource
‘'hmnu'
(130,
HelpMgrVersion,

/*

"Edit",
purgeable)
{
version
of Help Manager

hmDefaultOptions,
0,

/*
/*

options
balloon

0,

/*

variation

*/
definition
code

*/

function

*/

*/

You should normally use the hmDefaultOptions constant, as shown in the preceding
example, to get the standard behavior for help balloons. However, you can also use
the constants listed here for the options field. (Note that not all options are available
for every help resource.)
CONST

hmDefaultOptions

=

Of

{use

defaults}

hmUseSubID

=

13

{use

subrange

{

hmAbsoluteCoords

=

23

=

4;

hmMatchIinTitle

=

8)

=

16;

origin
corner

——

resource

of

window

and treat
of window
create

window;

—
—
co

event}

{save

bits

behind

window

{

and

generate

{match

window

in

update
by

—

~

}

save

update

anywhere

}

upper
left
as 0,0}

no

{

bits;

IDs

resources}

coords

{don't
{

hmSaveBitsWindow

owned

{ignore
{
{

hmSaveBitsNoWindow

for

—_

as
=
~
as
as
=

To

}

(ae)
_

.

}

event}

string

title

2
—

}

}

string}

If you're providing help balloons for a desk accessory or a driver that uses owned resources,
use the hmUseSubID constant in the options field. Otherwise, the Help Manager treats the
resource IDs specified in the rest of your help resource as standard resource IDs. (See
the Resource Manager chapter in Volume I for a discussion of owned resources and their
resource IDs.)

As described later in this chapter, you often specify tip and rectangle coordinates in your help
resources. You might want to use the hmAbsoluteCoords constant when providing help for
elements in a scrolling window or whenever the window origin is offset from the origin of
the port rectangle. If you specify the hmAbsoluteCoords constant, the Help Manager ignores
the local coordinates of the port rectangle when tracking the cursor, and instead tracks the
mouse position relative to the window origin. When you specify the hmAbsoluteCoords
constant as an option in a help resource, the Help Manager subtracts the coordinates of the
window origin from the coordinates of the mouse position, and the Help Manager uses these
results for the current mouse position, as shown here:
mousepoint.h

:=

mousepoint.h

-

portRect.left;

mousepoint.v

:=

mousepoint.v

-

portRect.top;

With the hmAbsoluteCoords option specified, the Help Manager always assigns coordinates
(0,0) to the point in the upper-left corner of the window. So, for example, if the cursor is
positioned at point (4,5) in a port rectangle and the window origin is at (3,4), the Help
Manager calculates the cursor to be at (1,1). If this option is not specified, the Help Manager
uses the port rectangle’s local coordinates when tracking the cursor—for example, when
using the GetMouse procedure.
Using the Help Manager

‘11-19

Inside Macintosh,

Volume V1

The Help Manager draws and removes help balloons on screen in three different ways. For
all help resources except 'hmnu' resources, the Help Manager by default draws and removes
help balloons as if they were windows. That is, when drawing a balloon, the Help Manager
does not save bits behind the balloon and, when removing the balloon, the Help Manager
generates an update event. By specifying the hmDefaultOptions constant in your help
resources, you always get the standard behavior of help balloons. However, you can often
specify two options that change the way balloons are drawn and removed from the screen.
If you specify the hmSaveBitsNoWindow constant in the options field, the Help Manager
does not create a window for displaying the balloon. Instead, the Help Manager creates a help
balloon that is more like a menu than a window. The Help Manager saves the bits behind the
balloon when it creates the balloon. When it removes the balloon, the Help Manager restores
the bits without generating an update event. You should only use this option in a modal
environment where the bits behind the balloon cannot change from the time the balloon is
drawn to the time it is removed. For example, you might choose the hmSaveBitsNoWindow
option in a modal environment when providing help balloons that overlay complex graphics,
which might take a long time to redraw with an update event. Note that the Help Manager
always uses this behavior when drawing and removing help balloons specified in your
‘hmnu' resources. That is, when you specify the hmDefaultOptions constant in an ‘'hmnu'
resource, the Help Manager provides this sort of balloon instead of drawing a window for a
balloon. (In an 'hmnu' resource, you cannot even specify options for drawing a window for
a balloon.)

If you specify the hmSaveBitsWindow constant, the Help Manager treats the help balloon as
a hybrid having properties of both a menu and a window. That is, the Help Manager saves
the bits behind the balloon when it creates the balloon and, when it removes the balloon, it
both restores the bits and generates an update event. You'll rarely need this option. It is
necessary only in a modal environment that might immediately change to a nonmodal

environment—that is, where the bits behind the help balloon are static when the balloon is

drawn, but can possibly change before the help balloon is removed. For example, if you use
an ‘hmnu' resource to provide help balloons for menu titles and menu items, you'll notice
that the Help Manager automatically provides this sort of behavior (even when you don’t
specify the hmSaveBitsWindow option) when creating help balloons for menu titles.
In the preceding list of constants, the values for the constants represent bit positions that are
set to 1. To override more than one default, add the values of the bit positions for the desired
options and specify this sum, instead of a constant, in the options field. For example, to use
subrange IDs, ignore the window port origin coordinates, and save bits behind the help
balloon without generating an update event, you should add the values of the bit positions
of these options (1, 2, and 4) and specify their sum (7) in the options field.
If you supply the hmDefaultOptions constant, the Help Manager treats the resource IDs in
this resource as regular resource IDs and not as subrange IDs; it uses the port rectangle’s
local coordinates when tracking the cursor; it creates windows when drawing balloons and
it generates update events without saving or restoring bits when removing balloons.
The hmMatchInTitle constant is used only in window help (‘hwin’) resources to match
windows containing a specified number of characters in their titles. This constant is explained
later in more detail in “Help Balloons in Static Windows.”
The next sections describe how to create help resources that provide help balloons for the
standard user interface elements of your application.

11-20

Using the Help Manager

The Help Manager

Providing

Help

Balloons

for Menus

If your application uses the standard menu definition procedure, you'll find that it’s easier
to provide help balloons for menus than for any of your other interface elements. This section
is relatively lengthy compared to the sections describing dialog boxes, alert boxes, and
windows only because it explains in greater detail much of the work you'll also perform
while providing help balloons for those elements.
This section assumes that your application uses the standard menu definition procedure.
If your application uses its own menu definition procedure, you must use Help Manager
routines to display and remove help balloons. These are described in “Displaying and
Removing Help Balloons” later in this chapter. Even if you use these routines, you should
read this section so that your balloons emulate the behavior that the Help Manager provides
for standard menus.

oad
roe
4°)
—

To create help balloons for a menu—pull-down, pop-up, or hierarchical—that uses the
standard menu definition procedure, create a resource of type ‘hmnu'. You can provide
help balloons for the menu title and for each individual menu item.

ic

K<
—

=
~
a
$e

The Help Manager can display different help balloons for the various states of a menu item.
Each menu item can have up to four help balloons associated with it, one for each state:
mw enabled
m

disabled (that is, dimmed for the user)

w

enabled and checked

mw enabled and marked (that is, marked by a symbol other than a checkmark—
for example, a bullet or a diamond)

For example, you can define a help balloon that the Help Manager displays when the Cut
command is enabled and another help balloon for display when the Cut command is dimmed.
Remember that the help balloon that you provide for a dimmed menu item should explain
why it isn’t currently available or, if more appropriate, how to make it available.
Note: Although enabled and disabled are the commands you use in a resource file
to display or to dim menus and menu items, you shouldn’t use these terms in your
help balloons or user guides. Rather, use the terms menus, menu commands, or

menu items for those that are enabled, and use the terms not available or dimmed to

distinguish those that have been disabled.

When your application calls the MenuSelect or MenuKey function, the Menu Manager tracks
the cursor, highlights enabled menu items, and pulls down any additional hierarchical or popup menus as the user moves the mouse. As the user drags the cursor across or through a
menu, the Menu Manager uses the Help Manager to display any help balloons associated with
the current state of the menu title or menu item.
Figure 11-9 shows different help balloons for two instances of a menu, one with the Cut
command dimmed, the other with the Cut command enabled.

Using the Help Manager

—
—

11-21

@
“

Inside Macintosh,

Volume VI

Haio

%u22

£ 4s

WEEE

tepy

ee

Paste
tear
—

Hedi

fini

wz

Copy

#C

Paste
Clear

XU

Removes the selected text

and places it temporarily into
a storage area called the
Clipboard. Not available now
because nothing is selected.

Removes the

selected text and
places it temporarily
into a storage area
called the Clipboard.

Figure 11-9. Help balloons for different states of the Cut command
You don’t specify hot rectangles or tip locations for menus. The rectangles defined by the
Menu Manager for menu titles and menu items are used for the hot rectangles. The Help
Manager initially tries to draw a help balloon for a menu item using variation code 0 (shown
in Figure | 1-4) with the tip placed eight pixels inside the right edge and halfway between the

top and bottom edges of the menu item’s rectangle. If the balloon’s initial position lies wholly

or partially offscreen, the Help Manager tries to redraw the balloon by moving its tip to the
left edge of the item rectangle and using variation code 3. The Help Manager uses variation
codes | and 2 in its attempts to draw help balloons for menu titles. The Help Manager never
moves the tip for menu titles; instead, the tip is always located just below the bottom of the
menu bar at the midpoint of the menu title’s text.
The resource ID of each 'hmnu' resource should match the corresponding menu ID. For
example, to provide help balloons for a menu with ID 130, create an 'hmnu' resource with
resource ID 130.

The 'hmnu' resource contains four distinct components: the header, the help balloon content
for any menu items missing from or unspecified in the rest of the 'hmnu' resource, the help
balloon content for the menu title, and the help balloon content for a variable number of

menu items.

Here is the general format of an 'hmnu' resource.

Component
Header

Menu help
resource element
Help Manager version
Options

Balloon definition function
Variation code

11-22.

Using the Help Manager

The Help Manager

Menu help
resource element

Component
Missing items

Identifier for help balloon content
Balloon content for missing enabled items
Balloon content for missing dimmed items
Balloon content for missing enabled-and-checked items
Balloon content for missing enabled-and-marked items

Menu title

Identifier for help balloon content
Balloon content for enabled state of menu title
Balloon content for dimmed state of menu title
Balloon content when the menu title is dimmed by

presence of a modal dialog box

=

of a modal dialog box

2.

First menu item

Identifier for help balloon content

=

Next menu item

(Same as for first menu item)

Balloon content for all menu items dimmed by presence

Balloon
Balloon
Balloon
Balloon

=

content for enabled item
content for dimmed item
content for enabled-and-checked item
content for enabled-and-marked item

Listing 11-1 shows an example of part of a simplified menu help resource for an Edit menu.
Listing 11-1. A partial menu help resource
resource

'hmnu'

(130,

"Edit",

/* header
information
HelpMgrVersion,

purgeable)

{

*/

hmDefaultOptions,

/*

options

0,
0,

/*
/*

balloon definition
variation code */

/*

missing

HMSkipItem

items

information

*/

function

*/

*/

{

/* no missing items,
so skip to menu title information
da
{ /* Edit menu title's help balloon content */
HMStringItem
/*
"Use

/*
"Not

{

/*

use

following

pstrings

*/

use
this

string below when menu
is
menu
to manipulate
text.",

enabled

use

string

available

below
now

when

because

*/

menu

is

dimmed

this

file

cannot

/*
"This

use string
menu's
not

below if modal
dialog
available;
respond
to

/*
"This

use string below if modal
dialog
command's
not available;
respond

box
the

*/

*/
be

changed.",

is present
*/
dialog box.",

box is
to the

present
*/
dialog box.",
(Continued)

Using the Help Manager

11-23

Inside Macintosh,

Volume VI

Listing 11-1. A partial menu help resource (Continued)
/*

Undo

command's

help

HMStringItem
/*

use

"Undoes
/*
"Not
vu

/*

/*

{

/*

string

your

balloon

use

below

last

content

following

*/

pstrings

when

command

*/
is

enabled

use string below when menu
available
now;
only editing

/*

can't

be

checked,

/*

can't

be

marked,

so

is dimmed
*/
changes
can be

empty

string

goes

undone.",

below

*/

‘

so

empty

}e
dashed line between Undo and Cut
HMSkipItem { /* no help balloons
iy

string

goes

/*

use

string

"Cuts

the

selected

use

string

/*
"Not

available

below

when

text

to

below

when

now

because

/*

can't

be

checked,

/*

can't

be

marked,

so

below

commands */
for dashed lines

Cut command's
help balloon
content
*/
HMStringItem
{ /* use
following pstrings

on

*/

edit.",

command
the

*/

*/

*/

is

enabled

*/

Clipboard.",

command
no

text

empty

is

dimmed

is

*/

selected.",

string

goes

below

*/

‘

so

empty

string

goes

below

*/

}
/*

Copy,

Paste,

and

Clear

commands'

help

balloons

go

here

*/

}

};

The header component comprises these fields:
= Help Manager version
m= options
m balloon definition function

m variation code
In the header component, always specify the HelpMgrVersion constant in the first field.

hmDefaultOptions

I

{use

defaults}

hmUseSubID

— a

{use

subrange

{ignore

Oo

CONST

ll

In the options field, specify a constant (normally, hmDefaultOptions) or the sum of several
constants’ values from this list. (“Specifying Options in Help Resources” earlier in this
chapter describes these options.)

11-24

— Using the Help Manager

do

{
hmAbsoluteCoords

for

owned

resource

IDs

}

resources}

coords

of

{

origin

and

treat

{

corner

of

window

window

}

upper-left

as

0,0}

}

The Help Manager

Note that the Help Manager never creates a window for a help balloon specified in an ‘hmnu'
resource. The Help Manager saves the bits behind the balloon when it creates the balloon.
When it removes the balloon, the Help Manager restores the bits without generating an update
event. You cannot specify options for drawing a window for a balloon in an 'hmnu' resource.
The balloon definition function field in the header specifies the resource ID of the window
definition function that is used to draw the frame of the help balloon. To use the standard
balloon definition function, specify a 0 for this field; this is the suggested default. If you use
your own balloon definition function (as described in “Writing Your Own Balloon Definition
Function” later in this chapter), specify its resource ID in this field.
The variation code field in the header specifies the preferred position of the help balloon. For
example, the standard balloon definition function displays help balloons according to eight
different positions. If you specified the standard balloon definition in the preceding field,
supply a variation code from 0 to 7 to display the balloon according to one of the eight positions shown in Figure 11-4. The preferred variation code is 0. If you are unsure of which
variation code to use, specify 0; the Help Manager will use different variant if another is more
appropriate. If you use your own balloon definition function, you specify its variation code
in this field in the header.

_—
—

c
—e

~
a
—

as
_

~
ee)
ve
a)

Lew

After the header, you specify the format and content for help balloons for missing items, the
menu title, and menu items.
Use the missing items component of this resource to specify how the Help Manager should
handle menu items that are not described in the 'hmnu' resource. The missing field is also
used for menu items that are described in the 'hmnu' resource but which lack help content
for any states.
The missing items component of this resource is useful when you have menu items with
similar characteristics or when the number of menu items is variable. For example, if the
help information for a dimmed item applies to all dimmed menu items, you can specify
the help information in the dimmed field of the missing items component instead of in the
dimmed fields of the components for individual menu items.
For missing items (as in the rest of the items listed in an 'hmnu' resource), you store the help

balloon content in text strings within this resource, or in separate 'STR ', 'STR#', ‘PICT’, or

'TEXT' and 'styl' resources. As described earlier in “Specifying the Format for Help Balloon

Content,” you’ll use these identifiers in the resource.

Identifier

Help

content

format

HMStringltem
HMPictltem
HMStringResItem
HMTEResItem
HMSTRReslItem
HMSkipltem

Pascal string within the help resource
'PICT' resource
'STR#' resource
"TEXT' and 'styl' resources
'STR ' resource
No content—skip this item

Specify an identifier from the preceding list to describe the format of the help balloon
content. Then, depending on the identifier you specified, in the next four fields supply
either text strings for the balloon content or resource IDs of resources that contain the
help balloon content.
Using the Help Manager

— ‘11-25

{

Inside Macintosh,

Volume VI

The next four fields correspond to the following states of missing menu items:
a the balloon’s content when a menu item is enabled, and either its content is not specified
in the help resource (though the menu item is specified in the help resource) or the menu
item itself is not specified in the help resource
a the balloon’s content when a menu item is dimmed, and either it is missing from this
resource or its help content is specified with either an empty string ("") or a resource ID
of 0
m the balloon’s content when a menu item is enabled and checked, and either it is missing
from this resource or its help content is unspecified
w

the balloon’s content when a menu item is enabled and marked (with a character other

than a checkmark), and either it is missing from this resource or its help content is
unspecified

The content you supply is displayed in a help balloon for any menu item that appears at the
end of the menu but is not described in this resource, and for any menu item in this resource
whose content is specified as either "" (empty) for strings or 0 for resource IDs.
There are two additional identifiers that you can specify for menu items in 'hmnu' resources.
These are explained later in this section.
Identifier

Purpose

HMCompareltem

Provide help only when string matches current menu item

HMNamedResourceltem

Get help content from the resource that has the same
name as the current menu item

Listing | 1-2 illustrates the help resource for a menu titled Colors. Notice in the missing items
component that the field describing dimmed states for menu items has the message “Not
available; either you have not selected text to color, or your monitor does not support color.”
Because this resource doesn’t specify a message for any command’s dimmed state, this
message appears in help balloons for the Blue, Red, and Green commands whenever
they’re dimmed.
After the missing items component, you specify the help balloon content for the menu title
and the menu items, in the same order in which they appear in the 'MENU' resource.
You can use the HMSkipItem identifier for items that appear in your menu but for which you
don’t provide a help balloon. For example, you can specify HMSkipItem for dashed lines
that appear in menus. (Dashed lines cannot have help balloons.) If you specify HMSkipItem,
the Help Manager does not display help balloons for that menu item, even if the missing
items component provides help information.

11-26

Using the Help Manager

The Help Manager

Listing 11-2. The missing items component in a menu help resource
resource

'hmnu'

(132,

"Colors",

purgeable)

/* header information */
HelpMgrVersion,
hmDefaultOptions,
/* missing items information */
HMStringItem

ae

/*
/*

"Not

{

0,

{

0,

{

no missing enabled items */
balloon content for all dimmed

ae

/*

no

missing

enabled-and-checked

ar
},

/*

no

missing

enabled-and-marked

/*

Help

/*

items

available;
either you have not
selected
"or your monitor does not
support
color.",

for

Colors

menu
menu

HMStringItem
/* use
"Use this
/* use
"Not

title

and

title's

items

help

below

*/

text

color,

items

to

*/

items

*/

—
—

*/

_—_—
—

balloon

content

{ /* use following Pascal strings content
string below when menu is enabled */
menu to display text in color.",
string below when menu is dimmed */

available

because

this

monitor

a")
oes
—

*/

does

not

—_

*/

a
as
pe)
—
an
&
To
Q
‘.
—_ :

—_—

aa

support

color.",

/* use string below when modal dialog box is present */
"Use this menu to display text in color. Not available until
"you respond to the alert or dialog box.",
/* use string below when modal dialog box is present */

he
/*

"Colors your
selected
text.
“respond to the alert
or

Not available
dialog
box.",

Blue

command's

HMStringItem
/*

use

"Displays

{

/*

help

balloon

content

use

following

Pascal

string

the

below

when

selected

wea

/*

use

wing ‘
Pei

/*
/*

command
command

missing

Green

command's

items

can't
can't

be
be

in

for

is

enabled

when

menu

blue.",

content

you

"

*/
strings

command

text

until

"

content

*/

*/
is

dimmed

*/

checked,
so use empty string here */
marked,
so use empty string here */

Js

/*

HMStringitem
/*

use

"Displays

{

/*

help
use

string

the

balloon

content

following

Pascal

below

when

selected

text

*/
strings

command

in

is

for

enabled

green.",

content

ial
<a

/*
/*

use missing
items content
command can't be checked,

when menu
is
so use empty

dimmed
string

aaa

/*

command

so

string

can't

hy
/* Red command's help
HMStringItem
{ /* use
/*

use

"Displays

string

the

/*

use

al
re,

/*
/*

command
command

marked,

use

empty

balloon content */
following Pascal strings

below

selected

ede

be

missing
can't
can't

when

text

command

in

enabled

when

menu

red.",

items

content

be
be

checked,
marked,

for

is

*/

*/

content

*/
here

here

*/

*/

*/

*/
is

dimmed

*/

so use empty
string here
*/
so use empty
string here
*/

}3

Using the Help Manager

11-27

Inside Macintosh,

Volume VI

For the menu title component, as for the missing items component, you begin by specifying
the identifier that describes the format for the help content. Depending on the identifier you
specify, in the next four fields you supply either text strings for the balloon content or the
resource IDs of resources that contain the help balloon content. These four fields correspond
to these states of the menu title:
w

the balloon content when the menu title is enabled

w

the balloon content when the menu title is dimmed

m the balloon content for the dimmed title when a modal dialog box appears
a the balloon content for all dimmed menu items when a modal dialog box appears
The third and fourth fields of the menu title component specify help information for menus
that are dimmed when an alert box or modal dialog box is the frontmost window. Users
of system software version 7.0 can access selected menus in the menu bar while displaying
an alert box or a modal dialog box. For example, the Show Balloons (or Hide Balloons)
command is always available from the Help menu so that users can see your help balloons
for the modal dialog box or alert box. While some menus are accessible, others may not be.
The Compatibility Guidelines chapter in this volume describes the circumstances under which
menus are enabled or not when a modal dialog box is displayed.
With users having access to your menus whenever a modal dialog box or alert box is present,
it is important to provide help that explains to users why your menus and items are dimmed
by the dialog or alert box. Use the third field in the menu title component of an ‘hmnu'
resource to specify the help balloon content that the Help Manager displays for that menu
title when it is dimmed by the presence of a modal dialog box. For example, the Colors
menu help resource shown in Listing 11-2 displays this message to the user when a modal
dialog box is present: “Use this menu to display text in color. Not available until you respond
to the alert or dialog box.”
Use the fourth field to specify the help balloon content for all menu items that become
dimmed when a modal dialog box appears. For example, in the Colors menu example, this
message is displayed to the user who selects the Blue, Green, or Red command when a
modal dialog box is present: “Colors your selected text. Not available until you respond to
the alert or dialog box.”
After you provide the header, missing items, and menu title information, you specify the help
content for each menu item. Each item in this resource must appear in the order that it appears
in the corresponding menu. For each menu item, begin by specifying one of the previously
listed identifiers to describe the format for the item’s help balloons. Then, depending on the
identifier you specify, supply either a text string for the balloon content or the resource ID of
a resource that contains the help balloon content.
Each field for a menu item corresponds to one of the following states:
m the balloon’s content when this menu item is enabled
m the balloon’s content when this menu item is dimmed
m the balloon’s content when this menu item is enabled and checked
m

11-28

the balloon’s content when this menu item is enabled and marked with a character other
than a checkmark

Using the Help Manager

The Help Manager

Note that, for any item in the resource, you can specify only one format for the content of the
states specified in the component. For example, if you specify the HMSTRReslItem identifier
for the Undo command, you must store the help content for all the states of the command in
‘STR ' resources. (However, if you specify a resource ID of 0 or an empty string as the
content of any items in order to use the content from the missing items component of the
resource, the content will follow the format specified in the missing items component.)
You do not have to provide help balloon content for every state of the menu item. If you do
not provide help content for a particular state, the Help Manager uses the help information
defined in the missing items component. If the missing items component does not provide
help information for that menu state, then the Help Manager does not display a help balloon
for that state of the item.
Listing 11-3 shows a sample ‘'hmnu' resource for another Edit menu. (Although Listings 11-1
and | 1-2 illustrate menu help resources that contain their help balloon content in the form of
Pascal strings within their own resources, you should keep your help balloon content in separate, more easily localized resources.) The 'hmnu' resource in Listing 11-3 stores its help
balloon content in a separate 'STR#' resource (which is given a corresponding resource ID of
130 for easier maintenance).

'hmnu'

(130,

HelpMgrVersion,
HMSkipItem
{
{

/*

no

},
/*

missing

menu

title

"Edit

items,

menu

so

items

'hmnu' and 'STR#'

help",

purgeable)

resources

{

/* standard header information
items information */

*/

skip

*/

below

to

menu

title

information

*/

/* Edit menu
title's
help balloon
content
*/
HMStringResItem
{ /* use an
'STR#'
resource
for content
*/
130,,1;
/*
'STR#'
res ID,
index when menu
is enabled
*/
130.:2,
/*
‘'STR#'
res ID,
index when menu
is dimmed
*/
130,3,
/*
‘'STR#',
index
for title with modal
dialog box
*/
130,4
/*
‘'STR#',
index
for items with modal
dialog box
*/
or
/* Undo command's
help balloon
content
*/
HMStringResItem
{ /* use an
'STR#'
resource
for content
*/
130.5,
/*
'STR#'
res ID,
index when command
is enabled
*/
130.6.
/*
'STR#'
res ID,
index when command
is dimmed
*/
0,0,
/* command can't
be checked
*/
0,0
/* command can't
be marked
*/
},

/* dashed
item
*/
HMSkipItem
{
/* no balloon help
for dashed
items
*/
dy
/* Cut
command's
help balloon
content
*/
HMStringResitem
{ /* use an
'STR#'
resource
for content
*/
1304 Fo
/*
‘'STR#'
res
ID,
index when command
is enabled
*/
130,8,
/*
'STR#'
res ID,
index when command
is dimmed
*/
0, 6s
/* command
can't
be checked
*/
0,0
/* command can't
be marked
*/
/*

content

for

—

=Ld

2—
S
=
—

_

-_

©
ar

0, 0, 0,
/* missing
and

—

jan
o

ge

Listing 11-3. Corresponding
resource

—

Copy

command's

help

balloons

goes

here

*/

(Continued)

Using the Help Manager

——-‘11-29

Inside Macintosh,

Volume VI

Listing 11-3. Corresponding ‘hmnu' and 'STR#' resources (Continued)
resource

'STR#'

(130,

"Edit

menu

help

strings")

{ /* array StringArray:
17 elements */
/* [1] help text for enabled Edit menu
"Use

/*

this

menu

"select

the

"on

the

Clipboard.";

[2]

help

"Use

/*

text

for

"select

the

"on

the

Clipboard.

[3]

help

this

to

for

alert

"Undoes

box
for

is

box.

your

or

dimmed

for

cut

or

"or

typed.";

"
"

/*

"you

have

cut

"or

typed.

Not

help

text

show

*/

to

manipulate
and

with

to

text,

show

dialog

manipulate

a

document,

is

unavailable

to

"

what's

"

now.";

modal

to

and

Edit

menu

until

items

you

with

present

text,

*/

to

"
"

to

show

what's

until

you

respond

dialog

present

modal

respond

enabled

action;

use

pasted,

Undo

this

or

to

command

*/

command

remove

to

to

the

or

cleared,

or

available

now

cutting,
for

all

clearing,
other

to

replace

material

/*
[6]
help text
for dimmed
Undo command
*/
"Undoes your
last
action;
use this command
to

“involve

to

to

"

alert

or

"

material

"

*/

";

last

have

*/

box.";

unavailable

text

"you

of

menu

dialog

to

what's

unavailable

title

content

text,

and

is

action,

This

manipulate

document,

last

entire

text

a

menu

"the

help

menu

/*

*/

to

title

Edit

the

[5]

action,

your

undo

Clipboard.

“dialog

menu

last
of

help

document,

Edit

content

This

a

dimmed

the
help

your

of

Edit

title

action,

to

"on

command

dimmed

entire

menu

last

content

undo

"select

[4]

your

entire

menu

"This

/*

undo

this

"Use

/*

to

{

remove

you

replace

material

you

because

your

last

pasting,

or

typing.";

commands

goes

here

have

pasted

material
have

action

did

"

"

pasted
not

"
"

*/

ei

The ‘hmnu' resource in Listing | 1-3 specifies the standard balloon definition function and

variation code in the third and fourth fields of the header. The missing items component is
specified using the HMSkipItem identifier, meaning that this 'hmnu' resource does not
provide any help balloons for menu items that are missing from this resource or that do not
have help content specified for any states.
Following the menu title, each menu item is listed in the order in which it appears in the menu.
For items that do not specify information for a particular state, the Help Manager normally
uses the information from the missing item. However, this 'hmnu' resource does not provide
help content in the missing item component. Instead, all help content is specified with each
menu item in this resource. Because there are no enabled-and-checked or enabled-and-marked
states for the Undo and Copy commands, these states are specified with resource IDs of 0.
If you have a menu item that changes names, you can use the HMCompareltem identifier to
compare a string against the current menu item in that position. If the string specified after the
HMCompareltem identifier matches the name of the current menu item, the Help Manager
displays the help balloon content specified in the next four fields of the help menu resource.
Because of performance considerations, the HMCompareltem identifier shouldn’t be used
unless necessary.

11-30

Using the Help Manager

The Help Manager

Here is the general format for specifying help within an 'hmnu' resource for a changing
menu item.

Menu

Component

help

resource

Changing menu item

element

HMCompareltem identifier
String to compare against current menu item
Identifier for help balloon content
Balloon content for enabled item
Balloon content for dimmed item

Balloon content for enabled-and-checked item
Balloon content for enabled-and-marked item

—
—

In the 'hmnu' resource, create components that use the HMCompareltem identifier for every
name that can appear in that menu position. For example, Listing 1 1-4 shows an ‘hmnu'
resource for a menu command that toggles between Show Colors and Hide Colors.

Listing 11-4. Using HMCompareltem for a changing menu item
resource
‘hmnu'
(132,
"Colors menu
/* see Listing 11-2 for missing
/*

see

Listing

11-2

HMCompareItem

{

for

/*

"Show Colors",
HMStringResItem
T3224

ky

menu

title's

content

if

/*

enabled

O70

/*

use

missing

0.4.

(01,

/*

item

can't

05°

0

/*

no

marked

the

first

TSast

is

*/

Show

Colors

*/

*/
items

be

*/

checked

state

Be

help
{

/*

enabled

Of0);

/*

use

missing

*y/

*/

Oy,

0

/*

item

can't

0,

O

/*

no

command

is

items

*/

Hide

Colors

*/

*/

marked

be

checked

state

mY

*/

},

/* Blue command's
HMStringItem
{ /*

help balloon
content
use
following
Pascal

/* use
"Displays

when
text

wu

nu
nu

/*

example

command

he

HMStringResItem

},

help

first

see

,
‘
‘

string
below
the selected

/*

use

/*
/*

command
command

Listing

missing

11-2

ae A

strings

command
in blue.

items

content

can't
can't

be
be

checked,
marked,

for

other

is

for

enabled

content

*/

*/

"
‘

when

menu

is

dimmed

*/

so use empty
string here
*/
so use empty
string here
*/

commands'

examples

$9
=
£9
ge
o@

{

sb

HMComparelItem
{ /*
"Hide Colors",

},

Colors

help

—

Law

{

help",
purgeable)
items example */

neal
—

=
<=)
ue

*/

(Continued)

Using the Help Manager

11-31

|

Inside Macintosh,

Volume VI

Listing 11-4. Using HMCompareltem for a changing menu item (Continued)
resource

'STR#'

(132,

"Hide

&

Show

Colors

commands

help

text")

{

{
/*

[1]

help

text

for

enabled

Show

"Show text in previously selected
/* [2] help text for enabled Hide
"Show

};

text

in

black

and

white

command

*/

colors.";
command */

only.";

}

As illustrated in Figure 11-10, when the menu command is Show Colors, the Help Manager
displays the help balloon content described by the first HMCompareltem component. When
the menu command is Hide Colors, the Help Manager displays the help balloon content
described by the second HMCompareltem identifier.
Colors

1
Blue
Green

plo

Hide Colors |
Show text in
previously
lected colors
colors.
selected

Red

Blue
Green

Show text in
black and
i only.
white

Red

Figure 11-10. Help balloons for a changing menu item
You can also specify the content of a help balloon with the HMNamedResourceltem identifier,
which causes the Help Manager to use a resource whose name matches the current name and
state of the menu item. After the HMNamedResourceltem identifier, you specify the resource
type (‘STR ', 'STR#'’, 'PICT’, or, for text, 'TEXT'), and the Help Manager uses the

GetNamedResource function to find the resource with same name as the current menu item.
(If you specify 'TEXT', you also get style information for the "TEXT" resource by creating a
'styl' resource with the same name.)
If the menu item is dimmed, the Help Manager appends an exclamation mark to the menu
item string and searches for a resource by that name. If the menu item is enabled and marked
with a checkmark or other mark, the Help Manager appends the mark to the menu item string
and looks for a resource with that name.
For example, this ‘hmnu' resource specifies that the Help Manager extracts help content from a
resource named Red of type 'STR ' when displaying a help balloon for an enabled menu command named Red. If the menu item is dimmed, the Help Manager gets the 'STR ' resource
with the name Red! and uses its text string for the balloon content. If the Red command could
be marked with an asterisk (*), the Help Manager would search for the resource with the name
Red* of type 'STR'.

11-32

Using the Help Manager

The Help Manager

resource

'hmnu'

(132,

"Colors

/*

see

Listing

11-2

for

/*

title

help,

other

menu

items

/*

command's

HMNamedResourcelItem
‘STR

'/*

'STR

'

use

the

menu

{

help",

header
Red

'STR

'

purgeable)

{

info,

missing

help

*/
help

items

balloon

resource

named

"Red"

/*

text

for

enabled

text

for

dimmed

help,

menu

content

*/

*/

*/

}
}3
resource

"Displays

(333,

the

"Red")

{

selected

text

help

in

Red

command

*/

red."

re
resource
"Not

'STR

(334,

"Red!")

{

/*

available;

either

you

have

"Or

'
your

monitor

does

not

help
not

selected

support

color.",

text

Red
to

command

color,

*/

"

—
—

—
_
@
—
—
~

¥

If there is sufficient memory, the standard menu definition procedure saves the bits behind

the help balloon and restores these bits for quick updating of the screen. If there isn’t
sufficient memory to save the bits behind the help balloon, then—as with menus—the
procedure generates appropriate update events.

—

-~

Q
lon

t 1°)

—

Providing Help Balloons for Items in
Dialog Boxes and Alert Boxes
For dialog boxes and alert boxes created with a dialog item list (‘DITL'), you can provide help
balloons for individual items in the dialog box or alert box by supplying a resource of type
‘hdlg' (dialog item help). When the user moves the cursor over an item that has a help balloon
associated with it, the Help Manager automatically displays and removes the help balloon as
the cursor moves into and out of the item’s rectangle. The Help Manager can display different
help balloons for various states of a dialog item—by control value if the dialog item is a
control, and by enabled and disabled states for dialog items that are not controls.

You can also provide help balloons for other areas of a dialog box or alert box using the
‘hwin' (window help) resource as described in “Help Balloons in Static Windows” later in
this chapter.
To create help balloons for items in dialog boxes or alert boxes, create an 'hdlg' resource that
corresponds to a 'DITL' resource. You associate the help information defined in the 'hdlg'
resource in one of three ways:
m by adding an item of type helpltem to the 'DITL’ resource
a by supplying a resource of type ‘hwin'
= by calling the HMScanTemplateltems function from your application

Using the Help Manager

—

a5
—
~
a

——- 11-33

;

Inside Macintosh,

Volume V1

The 'hdlg' resource describes the tip, the alternate rectangle, and help information for dialog
items in a dialog box or alert box. The 'DITL' resource describes the dialog items, and if it

includes an item of type helpItem, it can contain the resource ID of a corresponding ‘hdlg'
resource. The Help Manager uses the item rectangles defined in the 'DITL' resource as the
hot rectangles for the items. The Help Manager uses the alternate rectangles specified in the
‘hdlg' resource for transposing help balloons’ tips when trying to fit the balloons on screen.
If the dialog or alert box has an item of type helpItem in its 'DITL', help is enabled, and your
application calls the ModalDialog procedure or the IsDialogEvent function, the Help Manager
automatically tracks the cursor and displays help balloons as the user moves the cursor over
items designated in the 'hdlg' resource.
If the cursor passes over any active windows, including dialog or alert boxes, the Help
Manager searches the current resource file for resources of type 'hwin' (described in “Help
Balloons in Static Windows” later in this chapter). The Help Manager attempts to match either
the title of the window or the windowKind value in its window record with the title or
windowKind value specified in an 'hwin' resource. The matched 'hwin' resource, in turn,
specifies the resource ID of an ‘hdlg' or ‘hret' (rectangle help) resource that contains the
relevant help balloon content. (The ‘hrct' resource is described in “Help Balloons in Static
Windows” later in this chapter.) As described later in “Providing Help Balloons for Window
Content,” the 'hwin' resource can provide help for various elements across the entire window
as well as for items in a dialog box or an alert box.
If you prefer, you can track and display help balloons for modal dialog boxes and alert boxes
yourself by using a filter function and calling the HMScanTemplateltems function. Whereas
adding a helpItem item to a 'DITL' or adding an 'hwin' requires only that you add resources,
using HMScanTemplateltems requires you to modify your code. HMScanTemplateltems is
described in “Getting and Setting Information for Help Resources” later in this chapter.
As shown here, the 'hdlg' resource contains header information, missing items information,
and the help information for individual dialog items.

Component

Header

Dialog

resource

item

help

element

Help Manager version
Index number of starting dialog item (first item is number 0)
Options
Balloon definition function
Variation code

Missing items

11-34

Tip location
Alternate rectangle
Identifier for help balloon content
Balloon content for missing highlighted controls, or for missing
enabled items that are not controls
Balloon content for missing dimmed controls, or for missing
disabled items that are not controls
Balloon content for missing active controls that are checked
Balloon content for missing multipart controls

— Using the Help Manager

The Help Manager

Component
First dialog item

Dialog item help
resource element
Tip location
Alternate rectangle
Identifier for help balloon content
Balloon content for a highlighted control, or for an enabled item

that is not a control
Balloon content for a dimmed control, or for a disabled item that
is not a control
Balloon content for an active control item that is checked

Balloon content for a multipart control

Next dialog item

—
—

(Same as for first dialog item)

ie)

=—_

Zs
Nene
AS
a

The state of a dialog item depends on whether the dialog item is a control, such as a check
box or radio button, or something else, such as a static text field or an icon.
The header specifies the Help Manager version number, the starting index, options, the
balloon definition function, and the variation code. As in the other help resources, specify the
HelpMerVersion constant in the first field of the header component of the 'hdlg' resource.
You can use the starting index field to start the help information with any dialog item and then
continue sequentially. To derive a dialog item number to start from, the Help Manager adds
the index number you specify in this field to the number of the first item in the dialog item list
(‘DITL') resource. So index number 0 starts with the item number | in the 'DITL' resource

(because 0 plus | equals |). For example, to describe help information for only the fifth
through seventh dialog items, specify 4 as the starting index in the header and, because 4
plus | equals 5, provide help content starting with the fifth and proceeding through the sixth
and seventh dialog items.
In the options field, specify a constant (normally, hmDefaultOptions) or the sum of several
constants’ values from this list. (“Specifying Options in Help Resources” earlier in this
chapter describes these options.)
m

2

{use

=

(Le

hmAbsoluteCoords

=

23

{use subrange
resource
IDs
}
{ for owned resources}
{ignore
coords
of window
}
{ origin and treat
upper-left

hmSaveBitsNoWindow

I

hmDefaultOptions
hmUseSubID

hmSaveBitsWindow

=

ra

CONST

{ corner
of window as
{don't
create window;

{
8s

defaults}

bits;

{save
{ and

no

update

0,0}
save

}

}

event}

bits behind window
}
generate
update
event}

Using the Help Manager

— 11-35

=
m
ge

<7

Inside Macintosh,

Volume V1

Specify the balloon definition function and variation code (both typically 0) in the fourth and
fifth fields of the header. (These are described in detail earlier in “Providing Help Balloons
for Menus.”)

Following the header, you can specify the help content for dialog items that are missing from
the 'hdlg' resource or that are present but have no help content defined for a particular state.
(The missing items component is explained in detail earlier in “Providing Help Balloons for
Menus.”) In the missing items component, you specify a single tip location and a single
alternate rectangle for all help balloons described in this component.
The tip location is always relative to the item’s position in the dialog window. If you specify
the point (0,0) as a default tip, then it is placed 10 pixels from the right and 10 pixels from

the bottom of the item’s rectangle (as specified in the 'DITL' resource) for all missing items.

To move the missing item’s tip relative to this default location, you can specify positive or
negative integers in place of the coordinates (0,0).

For the missing item’s alternate rectangle, you specify offsets from the dialog items’ rectangles if you want alternate rectangles that are either larger or smaller than the items’ rectangles.
(The alternate rectangle, you'll remember, is used by the Help Manager for transposing the
tip if a help balloon does not fit on screen.) The Help Manager adds the top, left, bottom, and
right offsets that you specify to the coordinates of the items’ rectangles. For example, if you
specify (0,0,0,0) as the missing item’s alternate rectangle offsets, the Help Manager uses the
items’ rectangles as alternate rectangles for all missing items. You can specify positive or
negative integers for these parameters to move alternate rectangles’ coordinates relative to the
item rectangles’ coordinates.
You also specify an identifier from the following list that describes the format of the help
balloon content, and then, for each state of a missing dialog item, either a text string for
the balloon content or the resource ID of a resource that contains the help balloon content.
Identifier

Help

content

format

HMStringItem
HMPictltem
HMStringResItem
HMTEResltem
HMSTRReslItem
HMSkiplItem

Pascal string within the help resource
'PICT" resource
'STR#' resource
'TEXT' and 'styl' resources
‘STR ' resource
No content—skip this item

When displaying help balloons for a control, the Help Manager examines the highlight state
in the contrlHilite field of the control record. An active—that is, highlighted—control has a
contrlHilite value of 1. Specify the help balloon content for a highlighted control in the first
field of the missing items component or the dialog item components of the 'hdlg' resource.
An inactive—that is, dimmed—control has a contrlHilite value of 0. Specify the help balloon
content for a dimmed control in the second field of the missing items component or the dialog
item components of the 'hdlg' resource. If, as with check boxes and radio buttons, the user
can turn on an off/on control, you provide help balloon content for a highlighted, “‘on”
control in the third fields. A multipart control, such as a dial, has a contrlHilite value greater
than 1. Specify the help balloon content for a multipart control in the fourth field of the
missing items component or the dialog item components of the 'hdlg' resource. (See the
Control Manager chapter in Volume I for information about controls.)

11-36

Using the Help Manager

The Help Manager

When displaying help for dialog items that are not controls, the Help Manager examines only
whether the item is enabled or disabled, as specified in the dialog item list (‘DITL') resource.
When an item is enabled, the Dialog Manager informs your application about events involving
this item. For an enabled item other than a control, you specify help balloon content in the first
field of its component in the 'hdlg' resource. When an item is disabled, the Dialog Manager
does not inform your application about events involving this item. You specify its help
balloon content in the second field. The third and fourth fields do not apply to items that are
not controls. Though the Help Manager never uses these states, you should supply their fields
with either empty strings or resource IDs of 0, depending on the format you specify from the
previous list of identifiers.
After the missing items component, you provide the help content for the dialog items, starting
with the dialog item number indexed in the header and continuing in the same order in which
they appear in the 'DITL' resource.
Specify the tip and an alternate rectangle for each dialog item. Use coordinates local to the
dialog item’s display rectangle (which is specified in the 'DITL' resource) to specify the tip.
You can specify (0,0) to place the tip 10 pixels from the right and 10 pixels from the bottom
of the dialog item’s rectangle.
The Help Manager uses the item rectangles specified in the 'DITL' resource as the hot
rectangles for displaying help balloons. You cannot specify different hot rectangles in
an ‘hdlg' resource. (If you must specify hot rectangles that are different from the items’
rectangles, use the ‘hret' resource as described later in “Help Balloons in Static Windows.”)
You can, however, specify alternate rectangles in 'hdlg' resources that are different from the
item rectangles defined in the 'DITL' resource. Alternate rectangles give you additional
flexibility in positioning your help balloons on screen. If you make your alternate rectangle
smaller than the item rectangle, for example, you have greater assurance that the Help
Manager will be able to fit the help balloon on screen; if you specify an
alternate rectangle that is larger than the item rectangle, you have greater assurance that the
help balloon will not obscure some important element within the item rectangle.
Specify offsets from the dialog item’s rectangle if you want an alternate rectangle that is
different from the item rectangle. The Help Manager adds the top, left, bottom, and right
offsets that you specify to the coordinates of the item rectangle. For example, if you specify
(0,0,0,0) as the alternate rectangle’s offsets, the Help Manager uses the item rectangle as its
alternate rectangle. You can specify positive or negative integers for these parameters to
move the alternate rectangle’s coordinates relative to the item rectangle’s coordinates.
Specify the format for the help content using one of the previously listed identifiers. Note
that for any dialog item in the resource, you can specify only one format for the content of
all its states.
Each dialog item in the 'hdlg' resource has four fields that can contain descriptive information. As previously described for missing dialog items, the Help Manager interprets these
states differently according to whether the dialog item is or is not a control. In each field of a
dialog item component, supply either a text string for the balloon content or the resource ID
of a resource that contains the help balloon content.
You do not have to provide help balloon content for every state of a dialog item. If you do
not provide help content for a particular state, the Help Manager uses the help information
defined in the missing items component. If the missing items component does not provide
help information for that state, then the Help Manager does not display a help balloon for
that state.
Using the Help Manager

— 11-37

—
—

c

oS

=<
=
—=

~

ES
c

ge

Inside Macintosh, Volume VI

You can use the HMSkipItem identifier for dialog items for which you do not want to provide

help. If you specify HMSkipItem, the Help Manager does not display help balloons for that
dialog item, even if the missing item provides help information.

Listing 11-5 shows a sample dialog item help resource along with its associated dialog item
list ((DITL’) and string list resources.
Listing 11-5. A dialog item list and its help resource
resource
{

'DITL'

(145,

"Spelling

144,

254},

{124,
194,
Button
{

options",

purgeable)

{

enabled,
"

i

{48,,

OK

"

23,

67,

202},

CheckBox
{
enabled,
"Ignore Words

a
Ss.
23,
CheckBox

in

All

Caps"

196},

161,
{

enabled,

},

"Ignore

£13,

23,

Valley
33,

Girl

Slang"

254},

StaticText
{
disabled,

"WipeOut

typing

correction

/* item for
L000,03>

Cancel
7 for

button goes here */
help balloon:
scan 'hdlg'

},

HelpiItem

options:"

with

res

ID

145

*/

{

disabled,
HMScanhdlg

{145}

/*

scan

/*

get

resource

the

type

resource

‘hdlg'

with

ID

*/

145

*/

h?
resource

'hdlg'

(145,

"Spell

options

help",

purgeable)

{

HelpMgrVersion,
/* version of Help Manager */
0,
/* start help with first item in 'DITL'
*/
hmDefaultOptions,
/* options
*/
0,
/* balloon definition ID */
Bis
/* variation code: hang left of items */
HMSkipItem
{
f= no missing
items help information */
hy
{
fi? help information for dialog items */
HMStringResItem

{0, 0},
{0,0,0,0},

145,

11-38

1,

{

/*

store

help

for

/*

default

tip:

/*
/*

default
enabled

alternate
OK button

Using the Help Manager

OK

middle

button
right

in

edge

rectangle:
*/

'STR#'

145

of

rect

use

item
item

rect

*/
*/
*/

The Help Manager

Oo,

0.

/*

OK

button

0;

0,

/*

no

enabled-and-checked

is

never

dimmed

state

for

button

0,

0

/*

no

other

marked

for

button

*/

/*

store

help

for

CAPS

option

in

'STR#'

in

check

use

item

rect

states

*/
*/

}y
HMStringResItem

iG,

{

Gi,

/*

place

{0,0,0,0},

/*

default

Las,
145,
145,

/*
/*
/*

highlighted state of check box
dimmed state of check box */
check box is checked */

*/

/*

not

*/

0,

2;
3;
4,
0

},
HMStringResItem
{
{6, 6},
/*
{0,0,0,0},
/*

145,

145,
1255
0,
}
/*

5,

help

alternate

applicable

box

*/

rectangle:

to

this

control

state

of

check

for

*/

not

Cancel

applicable

button

to

this

goes

here

*/

*/

s

control

*/

7

options

help

text")

checked

options.";

<
=|

he
resource
'STR#'
{
=
£14 oy

(145,

"Click

here

to

f= Ea]
"Click

My
this

option

"Spell

accept

“words--such

the

to

as

prevent

the

acronyms--that

"letters--such

£™ [3]
"Click

*F
this

"words

option

spelling

checker
entirely

x=

[F]

acronyms--during

to

considered

fe (6B) my
"Not available
"girl

as

prevent
to

until

you

the

part

install

main

spelling

of

Valley

the

tagging

"

"

dictionary.";

consist
your

from
of

entirely
next

of

capital

spelling

check.";

checker
girl

from

tagging

"

slang.";

dictionary

of

Valley

"

tag words
that
are considered
to be
during your next
spelling
check.";

"

slang.";

Ff

"Click
this option
to
"Valley girl
slang
/*

be

{

consist

"Capital letters.";
c* [SZ] #7
"Not available until you install the
{* (4), */
"Click this option to tag words that

help

strings

for

Cancel

button

go

here

=
ma
=

box

/* dimmed state of check box */
/* check box is checked */
/*

*/

/* store help for slang option in 'STR#'
145 */
place tip in check box */
default alternate rectangle:
use item rect */

/* highlighted

6,
77;

0

tip

ALL

*/

};

The ‘hdlg' resource in Listing 11-5 defines help information for the first three dialog items in
the dialog item list. Figure | 1-11 shows the Help Manager displaying a help balloon for the
second item.
Using the Help Manager

11-39

Inside Macintosh,

Volume

VI

WipeOut
Ignore
Click this option to prevent
the spelling checker from
tagging words—such as
acronyms—that consist
entirely of capital letters.

typing

correction

Words

in All Caps

options:

(J Ignore Valley Girl Slang

l
Figure 11-11. A help balloon in a modal dialog box
You may notice in Listing | 1-5 that the Dialog Manager for system software version 7.0
supports a new item type for help—called helpItem. The help item isn’t visible to the user;
it’s provided so that the Help Manager can find the corresponding help resource.
Specify an empty rectangle—that is, one with coordinates (0,0,0,0)—for the display rectangle of a helpItem item. Specify disabled for its state. Describe whether the help resource
is of type 'hdlg' or ‘hret' by specifying either HMScanhdlg or HMScanhrct in the next field
of the resource. (The ‘hrct' resource is described in “Help Balloons in Static Windows” later
in this chapter.) Then specify the ID of the resource that provides the help information for
these dialog items.
Adding an item of type helpItem to a 'DITL' is the simplest method of associating the help

balloons defined in your 'hdlg' resource with the dialog items defined in the 'DITL'. A

slightly more involved method requires you to create an 'hwin' (window help) resource.
The tradeoffs between the two methods are listed here.
The advantages of adding an item for help to the 'DITL' are that
m it’s simple (you only have to create one resource, the 'hdlg' resource)
m

it works for dialog boxes or alert boxes that have no titles and for those whose
windowKind values do not adequately differentiate them from other windows
(the windowKind field of window records is descibed in the Window Manager
chapter in Volume J)

The disadvantages of adding an item for help to the 'DITL' are that
m

it allows you to associate help balloons only with items listed in the 'DITL'

m it can’t provide help balloons for alert boxes that have no dialog items
The advantages of using 'hwin' (window help) resources are that
m you can provide help balloons for alert boxes that have no dialog items
m you can provide a single help balloon for a group of related dialog items (rather than
having separate help balloons for all the dialog items)
m you can provide help balloons for elements other than dialog items
11-40

—_ Using the Help Manager

The Help Manager

The disadvantages of using 'hwin' resources are that
w it’s slightly more complex (you must create additional resources)
m it only works for dialog boxes and alert boxes that have titles or windowKind values
that differentiate them from other windows
Using the 'hwin' resource requires treating the dialog box or alert box as a static window.
When the cursor passes over an active window, the Help Manager attempts to match either
the title of the window or the windowKind value (from its window record) with a title or

windowKind value you specify in an 'hwin' resource. The section “Help Balloons for Static
Windows” later in this chapter describes how to use 'hwin' resources for dialog boxes, alert
boxes, and other kinds of static windows you may wish to define.

—
—

|

Cet

Providing

Help Balloons for Window

7)

Content

—
~—
i

a
—

You can create help balloons for objects within the content area of your windows. How you
choose to provide help balloons for the content area of your windows depends mainly on
whether your windows are static or dynamic.
A static window doesn’t change its title or reposition any of the objects within its content
area. A dynamic window may reposition any of its objects within the content area and its
title may change.
For example, any window that scrolls past areas of interest to the user is a dynamic window,
because the objects with associated help balloons can change location as the user scrolls.
A window that only displays a picture that cannot be resized or scrolled is an example of a
static window. Figure 11-12 shows examples of static and dynamic windows. The next two
sections describe how to provide help balloons for these types of windows.

al

Hu

Uerb Tenses

Hammer

~

Pliers

(

Change au

|

we
Saw

rg

a

Figure 11-12.

Static and dynamic

windows

Using the Help Manager

11-41

so)

ne
_
As
om
85)

@

i

rt

Inside Macintosh,

Volume

VI

Help Balloons in Static Windows
To provide help balloons for the static windows of your application without modifying its
code, create a resource of type 'hwin' (window help) and additional resources of type ‘hrct'
(rectangle help) or 'hdlg' (dialog item help). If your static windows provide help balloons
with these resources, the Help Manager automatically tracks the cursor and displays and
removes help balloons as the cursor moves into and out of the hot rectangles associated with
these resources.
The 'hwin' resource allows you to associate ‘hret’ and 'hdlg' resources with your static
windows. You use the ‘hret' and 'hdlg' resources to define help balloons for the individual
elements within your windows. While the Help Manager uses the item rectangles defined
in the 'DITL' resource as the hot rectangles for 'hdlg' resources, you can specify your own
hot rectangles for dialog boxes and other static windows when using ‘hrct ' resources.
An ‘hrct' resource specifies tip locations, hot rectangles, balloon definition functions, variation codes, and help content for areas within a static window.
As explained in the earlier section “Providing Help Balloons for Items in Dialog Boxes
and Alert Boxes,” the 'hdlg' resource describes the tip, alternate rectangle, and help

information for dialog items in a dialog box. That section also describes how to associate

the 'hdlg' resource with a dialog box by adding an item of type helpItem to the dialog box’s
‘DITL' resource. This section describes how you can instead treat your dialog boxes or alert
boxes as static windows and use an ‘hwin' resource instead of helpItem items to associate
them with 'hdlg' resources.
The 'hwin' resource identifies windows by their titles or by their windowKind values. You
can list all of your windows within one ‘hwin' resource, or you can create separate ‘'hwin'
resources for your separate windows. (You'll probably find that it is easier to maintain your
window help if you create only one 'hwin' resource, but, as described later in this section,
you must create separate 'hwin' resources for windows that require different options—for
example, one window matched to its 'hwin' resource by a string anywhere in the window’s
title and another window matched to its 'hwin' resource only by the exact string of the
window’s title.) An 'hwin' resource contains the resource ID (or IDs) of one or more ‘hrct'

and 'hdlg' resources. An 'hwin' resource can use ‘hret' and 'hdlg' resources for various
parts of the same window.

To use an ‘hwin' resource, the window must have either a title or a windowKind value in

its window record that adequately distinguishes it from other windows. Within an ‘hwin'
resource, you could identify the Verb Tenses window shown in Figure | 1-12 by its title, and
you could identify the scrolling palette window in Figure 11-12 by its windowKind value.

The Window Manager chapter in Volume I describes the windowKind field of the window
record, Note that windowKind values of 0, 1, and 3 through 7 are reserved by the
Operating System and that dialog boxes or alert boxes must have a value of 2. Because
your dialog boxes and alert boxes must have a windowKind value of 2, you can use this
value to define only one ‘hwin' resource for all untitled dialog boxes and alert boxes. You
may find it difficult—using help resources alone—to provide help balloons for untitled
dialog and alert boxes. However, you can use an 'hwin' resource to associate generic help
for the common elements of all your untitled dialog boxes and alert boxes, and you can use
the HMSetDialogResID function to provide help for the unique elements among them.
“Getting and Setting Information for Help Resources” later in this chapter explains the
HMSetDialogResID function.
11-42

— Using the Help Manager

The Help Manager

You describe the tip, a rectangle, and help information for each object in static windows
using either ‘hret' or 'hdlg' resources. Shown here is the general format of an ‘hrct'
resource. (“Providing Help Balloons for Items in Dialog Boxes and Alert Boxes” earlier in
this chapter describes 'hdlg' resources.)
Rectangle

help

Component

resource

element

Header

Help Manager version
Options

Balloon definition function
Variation code

First hot rectangle

Identifier for help balloon content
Tip location
Hot rectangle coordinates
Balloon content for hot rectangle

Next hot rectangle

(Same as for first hot rectangle)

The ‘hrct' resource contains a header and information that describes the hot rectangles within
the window and the help balloons associated with each hot rectangle.
As with the other help resources, specify the HelpMgrVersion constant in the first field of the
header component of the ‘hrct' resource. In the options field, specify a constant (normally,
hmDefaultOptions) or the sum of several constants’ values from this list. (“Specifying
Options in Help Resources” earlier in this chapter describes these options.)
CONST

hmDefaultOptions

BS

iGis

{use

defaults}

hmUseSubID

=

is

{use

subrange

{

owned

hmAbsoluteCoords

hmSaveBitsNoWindow
hmSaveBitsWindow

=

=
=

2%

for

{ignore

resource

IDs

}

resources}

coords

of

{

origin

and

treat

{

corner

of

window

create

window

}

upper-left
as

0,0}

window;

save

4;

{don't

8;

{ bits;
no update
event}
{save bits behind window
}
{ and generate
update
event}

}

}

Specify the balloon definition function and variation code (both typically 0) in the third and
fourth fields of the header. (These are described in detail earlier in “Providing Help Balloons
for Menus.”’)

Following the header, you specify tip locations, hot rectangles, and associated help content
for all the areas in the window that would benefit by having help balloons.

Using the Help Manager

—_11-43

Inside Macintosh,

Volume VI

For each hot rectangle, specify the format that the help content takes. As with the other help
resources, specify the format using one of these identifiers:
Identifier

Help

content

format

HMStringltem
HMPictltem
HMStringResItem
HMTEResItem
HMSTRReslItem
HMSkipItem

Pascal string within the help resource
‘PICT resource
'STR#' resource
'TEXT' and 'styl' resources
'STR ' resource
No content—skip this item

After specifying the format of the help content, give the points of the tip locations and the hot
rectangles in local coordinates. Then provide your help content for that rectangle, as either a
text string or a resource ID.
Specify the format, tip, hot rectangle, and help content for every applicable area in the window. You'll create an ‘hwin' resource that contains the resource ID of this ‘hret' resource and
that associates this resource with a titled window. The Help Manager automatically tracks the
cursor and displays and removes help balloons as the user moves the cursor into and out of
the hot rectangles defined in this resource.
If you need to supply a help balloon for an area within another area that needs a different help
balloon, create ‘hrct' resources for both the inner and outer areas and specify their areas as hot
rectangles. In the resource fork of your file, list the 'hrct' resource for the inner area ahead of
the 'hret’ resource for the outer area. Then, with the cursor within the inner hot rectangle, the
Help Manager scans its ‘hret' resource first and displays its help balloon instead of the help
balloon for the outer hot rectangle. When the cursor moves from the inner hot rectangle to
the outer, the Help Manager removes the inner area’s help balloon and instead displays the
balloon for the outer hot rectangle.
As previously explained, you can create an ‘hdlg' resource to specify the tips, alternate rectangles, balloon definitions, variation codes, and help content for dialog items and use an
‘hwin' resource to associate that 'hdlg’ with a dialog box or alert box. When help is enabled
and your application calls ModalDialog or IsDialogEvent, the Help Manager automatically tracks
the cursor and displays and removes help balloons for items specified in the 'hdlg' resource.
To associate ‘hret' and ‘hdlg' resources with windows, create an 'hwin' resource. Shown
here is the general format of an 'hwin' resource.

Component

Window
resource

help
element

Header

Help Manager version
Options

First window

Resource ID of associated ‘hret' or 'hdlg' resource
Resource type (‘hdlg' or ‘hrct’)
Length used to compare title strings—or, if flagged by a
minus sign (—), the windowKind value of an untitled
window
Window title string—or empty string if untitled

11-44

— Using the Help Manager

The Help Manager

Window

help

Component

resource

element

Next window

(Same as for first window)

The 'hwin' resource maps windows to ‘hrct' resources and ‘hdlg' resources. Within the
‘hwin', you identify ‘hret' resources and ‘hdlg' resources by their resource IDs and by their
types. As shown in the preceding list, the first two fields of a window component contain the
resource ID and type. You identify windows in one of these two ways:
a by specifying the number of characters used for matching a window title in the third
field, and by specifying a string containing this number of sequential characters from the
window’ title in the next field
a by flagging the third field of the component with a minus sign (—) and specifying the
windowKind value from the window’s window record in this field; leave an empty
string in the next field
When an active window has a title or windowKind value that matches an 'hwin' resource, the
Help Manager provides help balloons for the hot rectangles associated with the specified
‘hret' or ‘hdlg' resources.
The 'hwin' resource specifies the Help Manager version and options in the header. Specify
the HelpMegrVersion constant in the first field of the header. In the options field, specify a
constant (normally, hmDefaultOptions) or the sum of several constants’ values from this list.
Notice that compared to the other resources related to the Help Manager, options regarding
local coordinates and bits behind the balloon are not applicable to the ‘hwin’ resource, but the
‘hwin' resource has a unique option—hmMatchInTitle.
CONST

hmDefaultOptions

x.)

{use

hmUseSubID

— ey

{use subrange
resource
{ for owned
resources}

hmMatchinTitle

=

16;

help

resource

{match window
{ anywhere
in

defaults}
IDs

}

by string
}
title
string}

If you’re providing help balloons for a desk accessory or a driver that owns other resources,
use the hmUseSubID constant in the options field. (See the Resource Manager chapter in
Volume I for a discussion of owned resources and their resource IDs.)

You can specify the hmMatchInTitle constant to match windows containing a specified
number of sequential characters starting with any character position in the window title.
If you do not specify the hmMatchInTitle constant in the options field, the Help Manager
matches characters starting with the first character of the window title.
For example, if the 'hwin' resource specifies the hmMatchInTitle constant, 4 as the number
of characters to match, and “Test” as the window title, the Help Manager uses this ‘hwin'
resource when the cursor is located in any active window that is titled Test, Window Test, or
Test Case or is given a title with any other string that contains the characters “Test.”
Using the Help Manager

11-45

me
=

&

=
—
_

=rs
=

as
_

ge

io
™

Inside Macintosh, Volume VI

If you supply the hmDefaultOptions constant, the Help Manager treats the resource [Ds in
this resource as regular resource IDs and not as subrange IDs, and it begins matching characters at the first character of the window string. As long as they all use the same options, you
can list help for all your windows in a single 'hwin' resource. You must create separate
‘hwin' resources for windows that require different options.
Following the header, multiple 'hdlg' or 'hrct' resources can be specified. You specify the
window title and the resource ID for each ‘hdlg' or ‘hret’ resource. You also specify how
many characters of the window title the Help Manager should use when matching the
window with the 'hdlg' resource.
For dialog boxes and alert boxes, you can use ‘hrct' resources to define hot rectangles in
addition to or other than those associated with the dialog items. For example, you might want
to use an ‘hwin' and an ‘hrct' resource in a dialog box to associate a single help balloon with
a group of related dialog items rather than provide separate help balloons for all the individual
dialog items. (To provide help balloons for individual dialog items by using ‘hdlg' resources
alone, see “Providing Help Balloons for Items in Dialog Boxes and Alert Boxes” earlier in
this chapter.)
Figure 11-13 shows a sample palette an application might use and the help balloon displayed
for the hammer tool.
Tools

vy

DS}

SY

To construct a simple
sentence, join a verb to a
noun, point to the space
between the adjacent words,
and click repeatedly.

Kw

a

YW

q

Hammer

Figure 11-13. A tool palette with a help balloon
Listing 11-6 shows the window help resource and the hot rectangle help resource for the
palette in Figure 11-13.
Listing 11-6. Corresponding ‘hwin' and ‘hrct' resources for a tool palette
resource
'hwin'
(128,
HelpMgrVersion,

"Window

help

resource",

purgeable)

{

hmDefaultOptions,
{
128,

/*

resource

‘hret',
Sy

/*
/*

resource
type
length
to use

ID

"Tools"

/*

window's

title

};

11-46

of

Using the Help Manager

type

specified

on

next

for defining
help
*/
when comparing
strings

string

*/

line
*/

*/

The Help Manager

resource

‘hrcet'

(128,

"Tools

palette

help")

{

HelpMgrVersion,
hmDefaultOptions,

0,
0,

{

/*

/*
/*
definition

for

saw

goes

here

*/

/*
/*®

definition
tip */

for

hammer

54,131},

/*

hot.

/*

'STR#'

147 ,2
/*

}
definitions

for

tool

function

{

HMStringResItem
{50,.
127},
{22,99,

balloon definition
variation code */

other

rectangle

go

*/

*/

resource

tools

tool

*/

ID

and

here

index

*/

*/

—
—

}

a2
estar

a

@
—
i]

—

resource

'STR#'

(147,

"Tools

palette

help

text")

{

—
as
—
—
a
-_

{
f*
/*

LL
saw tool
*/
help
text
for saw

oe

=)

tool

/* [2] hammer tool */
"Hammer \n\nTo construct
"a
/*

a

verb

to

a

noun,

goes

a

point

"and

click

repeatedly.";

help

for

tools

other

goes

here

@

—

*/

simple

sentence,

to

space

the

here

join

between

"
the

adjacent

words,

*/

}

You can also use the 'hwin' resource to associate help for dialog items in a window.
Figure 11-14 shows the Help Manager displaying a help balloon for an item in the dialog
box titled Verb Tenses.
=CJ= Verb Tenses

=

(ma

Click here to replace
the selected verb
with its future tense.

change a |
Figure 11-14. A help balloon for a dialog box with a title

Using the Help Manager

11-47

.

Inside Macintosh, Volume VI

Listing 11-7 shows how the 'hwin' resource associates an 'hdlg' resource with the dialog

box illustrated in Figure 11-14. This 'hwin' resource associates help for three different
windows: the first is the window titled Tools, the second is an untitled window with a
windowKind value of 10, and the third is the dialog box titled Verb Tenses.

Listing 11-7. Specifying help for titled and untitled windows with an ‘'hwin' resource
resource

'hwin'

(128,

"Window

help

resource",

purgeable)

{

HelpMgrVersion,
hmDefaultOptions,

{

128,

/*

help

‘hret',
5,

/*
/*

resource
type
length to use

resource

"Tools",

/*

window's

129,

/*

help

"hdlg',

/*

resource

type

-10,

/*

match

windowKind

ack

/*

matching

on

windowKind,

130,

/*

help

ID

for

res
on

res

ID

title

ID

for

Tools

window

*/

for defining
help
*/
when comparing
strings
string

for

untitled

for

window

defining

*/

help

values

Verb

*/

*/

of

so

Tenses

*/

10

empty

*/
string

window

goes

here

*/

*/

'hdlg',
/* resource type for defining help */
bis
/* length to use when comparing strings
"Verb Tenses",
/* dialog box's title string */

*/

7c
resource

'hdlg'

(130,

“Help

for

Verb

{

G,
hmDefaultOptions,
0,
0,
HMSkipItem {
Le
{

/*
/*
/*
/*
/*

start with first dialog item in 'DITL'
*/
options */
balloon definition ID */
variation code */
no missing dialog item help information */

{20;

11-48

help

information
(local

for

*/

dialog

items

*/

use

item

{

130},

/*

tip

{0,0,0,0},

/*

default

131,

Ay

/*

highlighted

L3i, 2,
0, 0,

/*
/*

dimmed control for future tense
no checked state for control */

0,

/*

no

0

}y
HMStringResItem {
{20, 130},
/*

},

Manager

purgeable)

version

/*

Help

control",

/*

HMStringResItem

of

Tense

HelpMgrVersion,

other

tip

te

item

alternate
control

states

(local

rect)

to

*/

rectangle:
for

for

item

control

rect)

tense

*/

default

131,

3,

/*

highlighted

131;
4,
O,; O,

/*
/*

dimmed
control
no enabled and

for past
tense
*/
checked control
*/

0,

/*

no

for

other

Using the Help Manager

marks

rectangle:

for

*/

*/

/*

control

rect
*/

*/

{0,0,0,0},

0

alternate

future

use

past

control

tense

*/

item

*/

rect

*/

The Help Manager

HMStringResItem
{20,

{

130},

/*

tip

{0,0,0,0},
I31;
8;

/*
/*

default
alternate
Change All button

(local

to

item

0,

O,

/*

no

dimmed

Change

OL,

Oy

/*

no

checked

state

O:,

0

/*

no

other

rect)

*/

rectangle:
*/
All

button

Change

states

for

use

rect

*/

*/

All

Change

item

button
All

*/

button

*/

by
resource

'STR#'

(131,

"Verb

tense

help

strings")

{

{
/*
[1]
"Click

highlighted
control
here
to replace
the

for
future
tense:
help
selected verb with its

text
*/
future
tense.";

/*

dimmed

future

*/

[2]

"Click

/*

here

control

replace

"Not

available

[3]

/*

for

a

verb

tense:

with

its

help

now

because

you

have

not

highlighted

control

for

past

tense:

replace

because

Change All button's
here to repeat your
"your

you

help
last

verb

help

dimmed control for past tense: help text */
here to replace a verb with its past tense.
now

selected

have

with

not

text
*/
change
for

"

selected

/* [4]
"Click

available

the

tense.

here

/*
[5]
"Click

to

text

future

"Click

"Not

};

to

its

verb.";

text
past

selected
all

a

verbs

*/
tense.";

"
a

verb.";
within

"

document.";

}

Help Balloons in Dynamic Windows
To create help balloons for objects whose location in the content area of windows may vary,
your application needs to use Help Manager routines to display and remove balloons as the
user moves the cursor.
You should display or remove help balloons for dynamic windows at the same time that you
normally check the mouse position to display or change the cursor. For example, if you
provide your own Doldle procedure, you can also check the mouse position and, if the cursor
is over a hot rectangle, you should display the associated help balloon.
To create help balloons for the content area of a dynamic window, you need to
= identify the hot rectangles for each area or object
= create data structures to store the locations of the hot rectangles
= determine how to calculate their changing locations
m track and update the hot rectangles
= when the cursor is over a hot rectangle, display its help balloon by using the
HMShowBalloon function
Using the Help Manager

11-49

Inside Macintosh,

Volume VI

After defining all the hot rectangles within your content region, create separate 'STR ',

'STR#', 'PICT', or 'TEXT' and 'styl' resources for the help balloons’ content. You don’t

have to store the content in these resources when using HMShowBalloon, but doing so
makes your application easier to localize.

When you use the HMShowBalloon function, your application is responsible for tracking
the cursor and determining when to display the help balloon. If you use the HMShowBalloon
function, you can let the Help Manager track the cursor and determine when to remove
the help balloon, or your application can remove the balloon when necessary by calling
the HMRemoveBalloon function. If you display your own help balloons using the
HMShowBalloon function, you should use the HMGetBalloons function to determine
whether help is enabled before displaying a help balloon. If help is not enabled, you don’t
need to call any Help Manager routines that display balloons, since they won’t do anything
unless HMGetBalloons returns TRUE.
The HMShowBalloon function is useful for
= windows whose content changes
= windows that can be resized
= windows that contain hot rectangles with variable locations
m situations in which your application wants more control over the display and removal of
the help balloon

For example, windows with scrolling file icons (such as Finder windows) or scrolling tool

symbols (such as those shown in Figure 11-12) require you to use HMShowBalloon to
display help balloons for the icons or symbols. Likewise, if you have tools—such as rulers
that users configure for tab stops in a word-processing document—that scroll with a document, you'll need to use HMShowBalloon to display help balloons for the scrolling tools.
The Help Manager provides default help balloons for certain areas of the window frame.
“Overriding Other Default Help Balloons” later in this chapter describes how to override
these default help balloons.
When using HMShowBalloon, you specify the help content, a tip location, a rectangle to use
if the Help Manager needs to change the tip location, an optional pointer to a function that can
modify the tip and rectangle coordinates, the balloon definition function, and the variation
code. In the final parameter to the HMShowBalloon function, you should also provide a
constant that tells the Help Manager whether it should save the bits behind the balloon.
myErr

:=

HMShowBalloon(aHelpMsg,
variant,

tip,

alternateRect,

tipProc,

theProc,

method);

Specify the help content in the aHelpMsg parameter to the HMShowBalloon function. You
can specify the help information for each hot rectangle using text strings, 'STR ' resource
types, 'STR#' resource types, styled text resources, 'PICT' resource types, handles to styled
text records, or handles to pictures.
The HMMessageRecord data type defines the help message record.

11-50

Using the Help Manager

The Help Manager

TYPE

HMMessageRecord

=

RECORD

hmmHelpType:
CASE

Integer;

Integer

{type

of

next

field}

OF

khmmString:

(hmmString:

khmmPict:

(hmmPict:

Str255);

khmmStringRes:

(hmmStringRes:

HMStringResType);

khmmTEHandle:

(hmmTEHandle:

TEHandle);

khmmPictHandle:

(hmmPictHandle:

khmmTERes

(hmmTERes:

Integer);

{Pascal

string}

{'PICT'

resource

{

:

PicHandle);

{picture

Integer) ;

(hmmSTRRes:

and

handle}

resource

{'STR'

}

handle}

{' styvi'/'TEXT"

Integer)

ID}

res

index}

{TextEdit

{
khmmSTRRes:

ID

{'STR#'

}

ID}

resource

ID}

END;

The hmmHelpType field is a constant that specifies the data type of the next field of the help
message record. The field following the hmmHelpType field can be one of a number of
different data types. You specify the content of the help balloon in this field.
You can specify the help content using a text string, a text string stored in a resource of type
‘STR ', or a text string stored as a an 'STR#' resource. You can also provide the information
using styled text resources, or you can provide a handle to a styled text record. If you want
to provide the help content as a picture, you can use a resource of type 'PICT' or provide a
handle to a picture.
You specify one of these constants for the hnmHelpType field.
CONST

khmmString

=

khmmPict

=

2B

{Pascal
{'PICT'

resource

khmmStringRes

=

33

{'STR#'

res

ID

khmmTEHandle
khmmPictHandle

=
=

we
5S;

{styled
{handle

text
to a

handle}
picture}

khmmTERes

=

5;

{'TEXT'

khmmSTRRes

a

{'STR

string}

&
'

ID}
and

index}

'styl'

res

resource

ID}

ID}

You can use the khmmString constant to specify a Pascal string. Here’s an example of how
to use the khmmString constant in the help message record. (Although you can specify a
string from within your code, storing the strings in resources and then accessing them
through the Resource Manager makes localization easier.)
VAR

aHelpMsg:

HMMessageRecord;

tip:

Point;

alternateRect:

RectPtr;

BEGIN

aHelpMsg.hmmHelpType
aHelpMsg.hmmString

{be

sure

err

:=

to

:=
:=

initialize

khmmString;
'To

turn

the

tip

and

alternateRect

page,

click

here.';

here}

HMShowBalloon(aHelpMsg,tip,alternateRect,
NIL,0,0,kHMRegularWindow) ;

END;

Using the Help Manager

11-51

—
—_

‘<)
—

ed

a
—
As
~
~
~
as
_

go

<)
_

;

Inside Macintosh, Volume VI

To use a picture you can either store the picture as a 'PICT" resource or create the 'PICT'
graphic from within your application and provide a handle to it. Because the Help Manager
uses the resource itself or the actual handle that you pass to HMShowBalloon, your 'PICT'
resource should be purgeable, or, when using a handle to a 'PICT' resource, you should

release the handle or dispose of it when you are finished with it.
Here’s an example that specifies a 'PICT' resource ID.

VAR
aHelpMsg:

HMMessageRecord;

tig:

Point;

alternateRect:

RectPtr;

BEGIN

aHelpMsg.hmmHelpType
:= khmmPict;
aHelpMsg.hmmPict
:= 128;
{resource ID of
{be sure to initialize tip and alternateRect here}
err

:=

'PICT'

resource}

HMShowBalloon(aHelpMsg,tip,alternateRect,
NIL, 0,0,kHMRegularWindow) ;

END;

Here’s an example of providing a handle to a 'PICT' resource.
VAR
pict:
aHelpMsg:

PicHandle;
HMMessageRecord;

tip:

Point;

pictFrame:

Rect;

alternateRect:

RectPtr;

BEGIN

{be

sure

pict

:=

to

initialize

pictFrame

here}

OpenPicture(pictFrame) ;

DrawString('Test

ClosePicture;

Balloon');

aHelpMsg.hmmHelpType

:=

khmmPictHandle;

aHelpMsg.hmmPictHandle

:=

pict;

{be

sure

tip

and

err

:=

to

initialize

alternateRect

here}

HMShowBalloon(aHelpMsg,tip,alternateRect,
NIL, 0,0,kHMRegularWindow) ;

KillPicture(pict) ;
END;

The HMStringResType data type defines a Help Manager string list record.
TYPE

HMStringResType

=

RECORD
hmmResID:
hmmIndex:
END;

11-52.

Using the Help Manager

Integer;
Integer

{res
ID of
'STR#'
{index of string}

resource}

The Help Manager

The hmmResID field specifies the resource ID of the 'STR#' resource, and the hmmIndex
field specifies the index of the string within that resource to use for the help information.
To use a string stored in an 'STR#' resource, use the knmmStringRes constant in the
hmmHelpType field and use a record of data type HMStringResType in the next field.
VAR

aHelpMsg:

HMMessageRecord;

tip:

Point;

alternateRect:

RectPtr;

khmmStringRes:

HMStringResType;

BEGIN

aHelpMsg.hmmHelpType
:= khmmStringRes;
Get IndString (aHelpMsg.hmmStringRes,1000,1);
{be sure to initialize tip and alternateRect
err

:=

here}

HMShowBalloon(aHelpMsg,tip,alternateRect,
NIL, 0,0,kHMRegularWindow) ;

END;

To use styled text resources, use the khmmTERes constant in the hnmHelpType field. In the
next field, supply a resource ID that is common to both a style scrap (‘styl’) resource and a
'TEXT' resource. For example, you might create a "TEXT' resource with resource ID 1000
that contains the words “Displays your text in boldface print.” You would also create an 'styl'
resource with resource ID 1000 that applies boldface style to the word “boldface.” When you
specify the HMTEResItem constant and resource ID 1000 for a help balloon, the Help
Manager employs TextEdit routines to display your text with your prescribed styles. (See the
TextEdit chapter in Volume V for a description of the style scrap.)
To use a handle to a styled text record, supply the khmmTEHandle constant in the
hmmHelpType field.
VAR
aHelpMsg:
tip:
alternateRect:

HMMessageRecord;
Point;
RectPtr;

hTE:

TEHandle;

BEGIN

hTE

:=

{be

sure

TEStyleNew(destRect,viewRect);

to

fill

in

data

in

handle

{or,

use

TENew}

here}

aHelpMsg.hmmHelpType
:= khmmTEHandle;
aHelpMsg.hmmTEHandle
:= hTE;
{be sure
to initialize
tip and alternateRect
here}
err
:= HMShowBalloon(aHelpMsg,tip,alternateRect,
NIL,0,0,kHMRegularWindow) ;
END;

You specify the tip and the rectangle pointed to by alternateRect in global coordinates. The
Help Manager calculates the location and size of the help balloon. If the help balloon fits on
screen, the Help Manager displays the help balloon using the specified tip.

Using the Help Manager

— 11-53

Inside Macintosh,

Volume VI

If you use the previously described help resources to define help balloons, the Help Manager
uses the hot rectangles you specify in the help resources for two purposes: first, to associate
areas of the screen with help balloons and, second, to move the tip if the help balloon doesn’t
fit on screen.
If you use the HMShowBalloon function to display help balloons, you must identify hot
rectangles, create your own data structures to store their locations, track the cursor yourself,
and call HMShowBalloon when the cursor moves to your hot rectangles. The Help Manager
does not know the locations of your hot rectangles, so it cannot use them for moving the tip if
the help balloon is placed offscreen. Instead, the Help Manager uses the alternate rectangle
that you point to with the alternateRect parameter. Often, you specify the same coordinates
for the alternate rectangle that you specify for your hot rectangle. However, you may choose
to make your alternate rectangle smaller or larger than your hot rectangle. If you make your
alternate rectangle smaller than your hot rectangle, you have greater assurance that the Help
Manager will be able to fit the help balloon on screen; if you specify an alternate rectangle that
is larger than your hot rectangle, you have greater assurance that the help balloon will not
obscure some element explained by the balloon.
If you specify a rectangle in the alternateRect parameter, the Help Manager automatically
calls HMRemoveBalloon to remove the balloon when the cursor leaves the area bounded
by the rectangle.
If you specify NIL for the alternateRect parameter, your application is responsible for
tracking the cursor and determining when to remove the help balloon. The Help Manager
also does not attempt to calculate a new tip position if the help balloon is offscreen.
When you call the HMShowBalloon function, the Help Manager does not display the help
balloon or attempt to modify the tip location under either of these conditions:
m the help balloon’s tip is offscreen or in the menu bar and you don’t specify an alternate
rectangle
m both the help balloon’s tip and the alternate rectangle are offscreen
The final parameter in HMShowBalloon specifies how the Help Manager should draw and
remove the balloon. Use the following constants for the parameter.
CONST

kHMRegularWindow

=

Qs

{don't

save

kHMSaveBitsNoWindow
kKHMSaveBitsWindow

=
=

1;
23

{save
{save

bits;
bits;

bits;

just

update}

don't
do update}
do update
event}

If you specify KHMRegularWindow, the Help Manager draws and removes the help balloon
as if it were a window. That is, when drawing the balloon the Help Manager does not save
bits behind the balloon, and when removing the balloon the Help Manager generates an
update event. This is the standard behavior of help balloons—and the behavior you should
normally use.
If you specify KHMSaveBitsNoWindow in the method parameter, the Help Manager does not
create a window for displaying the balloon. Instead, the Help Manager creates a help balloon
that is more like a menu than a window. The Help Manager saves the bits behind the balloon
11-54

— Using the Help Manager

The Help Manager

when it creates the balloon. When it removes the balloon, the Help Manager restores the bits
without generating an update event. You should only use this in a modal environment where
the bits behind the balloon cannot change from the time the balloon is drawn to the time it is
removed. For example, you might specify the KHMSaveBitsNoWindow constant when

providing help balloons for pop-up menus that overlay complex graphics, which might take a
long time to redraw with an update event.

If you specify kHMSaveBitsWindow, the Help Manager treats the help balloon as a hybrid
having properties of both a menu and a window. That is, the Help Manager saves the bits
behind the balloon when it creates the balloon and, when it removes the balloon, it both
restores the bits and generates an update event. You’ll rarely need this option. It is necessary
only in a modal environment that might immediately change to a nonmodal environment—
that is, where the bits behind the help balloon are static when the balloon is drawn, but can
possibly change before the help balloon is removed.
Listing 11-8 shows a sample routine that displays help balloons for hot rectangles within the
content area of a window.
Listing 11-8. Using HMShowBalloon to display help balloons
PROCEDURE

FindAndShowBalloon(window:

Integer;
Point;

savePort:

GrafPtr;

helpMsg:

HMMessageRecord;

result:
inRect:

OSErr;
Boolean;

BEGIN
IF

(window

BEGIN
Get Port

FrontWindow)

(savePort)

SetPort

(window)

GetMouse
inRect:=

IF

=

WindowPtr) ;

;

THEN
{save

;

{set

(mouse) ;
FALSE;

{only
the

the

old

port

port

to

i:=

1

TO

frontmost

for
the

10

DO

{check

all

10

wasn't

same

as

last

}

window}
in

any

Rect}

in

the

window}

THEN
}
predefined

IF PtInRect (mouse,MyPredefinedRects[i])
BEGIN
{cursor
in rect}
IF
(1 <> gLastBalloon)
THEN
{cursor

windows

later}

front

{get
the mouse
in local
coords}
{clear
flag saying mouse wasn't

PtInRect (mouse,window’.portRect)
{if the cursor is in the window
FOR

do

rects
THEN

time}

BEGIN

hotRect

:=

MyPredefinedRects[i];

LocalToGlobal
(hotRect .topLeft) ;

{converting
LocalToGlobal

rect

to

global}

(hotRect.botRight)

@

—
—

—_

a
—

=
=
eh)
i=)
ic)
ye

VAR

i:
mouse:

—
—

;

(Continued)

Using the Help Manager

——- 11-55

Inside Macintosh, Volume VI

Listing 11-8. Using HMShowBalloon to display help balloons (Continued)
WITH

hotRect

Set Pt

DO

(mouse,

{put

helpMsg.hmmHelpType
{want

'STR#'

the

tip

(right-left)

:=

in

div

:=

middle}

(bottom-top)

2);

resource}

:

OurHelpMsgsID;

:

i;

{this

index}

HMShowBalloon(helpMsg,

{use
mouse,

just-made

{pointing

to

help
this

@MyPredefinedRects[i],

IF

div

khmmStringRes;

helpMsg.hmmStringRes.hmmResID
{this resID}
helpMso.hmmStringRes.hmmIndex
result

the

2,

(result

=

{this

NIL,

{no

0, O,

{using

default

FALSE);

{don't

save

noErr)

gLastBalloon

:=

THEN

special

{then

msg}

tip}

tip

balloon}

bits

remember

rectangle}

proc}

behind}
balloon}

i;

END;

inRect

:=

TRUE;

{remember

when

the

cursor

is

in

balloon

global

for

no

any

rect}

END;

IF

not

inRect

THEN

gLastBalloon
SetPort

(savePort)

:=

-1;

;

{clear
{restore

last
the

hit}

port}

END;

END;

The FindAndShowBalloon procedure in Listing 11-8 tracks the cursor, and, if the cursor is
over a predefined hot rectangle, it displays a help balloon for that rectangle. In this example
there are 10 predefined rectangles (in the MyPredefinedRects array) and 10 corresponding
help messages in an 'STR#' resource (of ID OurHelpMsgsID)—one message for each hot
rectangle. Other supporting routines can update the coordinates of the hot rectangles as their
locations change.
You can also use the HMShowBalloon function from the filter function of a modal dialog box
or alert box. See “Displaying a Help Balloon” and “Removing a Help Balloon” later in this
chapter for more information on the HMShowBalloon and HMRemoveBalloon functions.

Overriding Help Balloons for Application

Icons

The Finder displays a default help balloon for application icons. By specifying an ‘hfdr'
resource in your application’s resource fork, you can provide your own help balloon for
the Finder to display when the user moves the cursor over your application icon.
Note: You cannot override the default help balloon that the Finder uses for
document icons.
Shown here is the general format of an 'hfdr' resource.

11-56

Using the Help Manager

The Help Manager

Component

Header

Finder icon help
resource element

Help Manager version

Options

Balloon definition function
Variation code

Icon help

Identifier for help balloon content
Balloon content for application icon

Use resource ID —5696 for your ‘hfdr' resource. If an 'hfdr' resource with that ID exists
for an application, the Help Manager uses it instead of the default help balloon provided by
the Finder.
As with the other help resources, specify the HelpMgrVersion constant in the first field of the
header component of the 'hfdr' resource. In the options field, specify a constant (normally,
hmDefaultOptions) or the sum of several constants’ values from this list. (“Specifying
Options in Help Resources” earlier in this chapter describes these options.)
CONST

hmDefaultOptions

=:

hmUseSubID

ae

03

{use

defaults}

{use

subrange

{
hmAbsoluteCoords

=

Bes

hmSaveBitsWindow

=
=

owned

{ignore
{

hmSaveBitsNoWindow

for

origin

resource

coords

of

and

treat

window

4;
8;

{ bits;
no
{save bits
and

}

update
behind

generate

}

upper-left

{ corner of window as
{don't create window;

{

IDs

resources}

0,0}
save

event}
window

update

}

}
}

event}

Specify the balloon definition function and variation code (both typically 0) in the third and
fourth fields of the header. (These are described in detail earlier in “Providing Help Balloons
for Menus.”)
In the icon help component of this resource, specify the format that the help content takes. As
with the other help resources, specify the format using one of these identifiers:
Identifier

Help

content

format

HMStringItem
HMPictltem
HMsStringResItem
HMTEResItem
HMSTRReslItem
HMSkiplItem

Pascal string within the help resource
'PICT' resource
'STR#' resource
'TEXT' and 'styl' resources
'STR ' resource
No content—skip this item

If you specify HMSkipItem, no help balloon appears.

Using the Help Manager

11-57

—
—

‘2°

—
_

a
no
as
_
—
~
as
~

tk)

@
cs |

Inside Macintosh, Volume VI

Default Balloon Help
for application icon
i

Customized Balloon Help
for application icon
is,

This is an application—a
program with which you can
perform a task or create a
document. Applications
include word processors,
graphics programs, and
spreadsheets.

SurfWriter

Use the Surfwriter word
processor to create or

;

edit the most radical

documents ever written
on your Macintosh
computer.

ee

7

Surfwriter

Figure 11-15. Default and customized help balloons for an application icon
The default help balloon for application icons is shown on the left in Figure 11-15.
A customized help balloon for the same icon appears on the right in Figure 11-15. The
customized help balloon is supplied with the resources shown in Listing 11-9.
Listing 11-9. Creating a help balloon
resource

'hfdr'

(-5696)

{

/*

help

HelpMgrVersion,

hmDefaultOptions,

{
HMSTRResitem
1001

/*

{

use

'STR

'

resource for an application icon

balloon
0,

for

0,

resource

SurfWriter

/*
1001

header

icon

*/

information

app

*/

*/

}

};
resource

'STR

"Use the
“radical

'

(1001)

{

/*

help

message

SurfWriter word processor
documents
ever written
on

for

SurfWriter

app

icon

to create or edit
the most
your Macintosh
computer."

*/
"

};

Overriding Other

Default

Help

Balloons

In addition to help balloons for application and document icons, the Help Manager provides
default help balloons for the title bar and the close and zoom boxes of an active window. It
also provides default help balloons for windows of inactive applications, inactive windows
of an active application, and the area outside of a modal dialog box.
Apple has researched and tested these help messages to ensure that they are as effective as
possible for users. Normally, you shouldn’t need to override them. However, you can
override one or more of these defaults if you feel you absolutely must by creating a resource
of type 'hovr'. Shown here is the format for the 'hovr' resource.
Using an 'hovr' resource sets the default help balloons for your application only. It does not
affect the default help balloons used by other applications.

11-58

— Using the Help Manager

The Help Manager

Default

Component

help

override

resource

element

Header

Help Manager version (use HelpMegrVersion constant)
Options
Balloon definition function
Variation code

Missing items help

Identifier for help balloon content
Balloon content for items missing from this resource
or lacking balloon content

Title bar help

Identifier for help balloon content

Reserved

Always use HMSkipItem identifier here
Reserved; skip this item

=
—

Balloon content for title bar of active window

Close box help

i!
eee

ce

oe
ae
_—

st

ae
=
_
—
a
—
~

Identifier for help balloon content

gc

CG

Balloon content for close box of active window

—

Zoom box help

Identifier for help balloon content

Help for active application’s
inactive windows

Identifier for help balloon content
Balloon content for inactive window of active
application

Help for inactive application’s
windows

Identifier for help balloon content
Balloon content for window of inactive application

Help for area outside of a
modal dialog box or alert box

Identifier for help balloon content
Balloon content for area outside of a modal dialog box

Balloon content for zoom box of active window

i}

Oo

hmUseSubID

=

i;

Il

hmSaveBitsNowWindow

A;

i

hmAbsoluteCoords

i

hmDefaultOptions

{use defaults}
{use subrange
resource
IDs
}
{ for owned
resources}
{ignore coords
of window
}
and treat
upper-left
{ origin
{ corner of window as 0,0}
{don't

hmSaveBitsWindow

i

{
oo

CONST

NO

As with the other help resources, specify the HelpMgrVersion constant in the first field of the
header component of the ‘hrct' resource. In the options field, specify a constant (normally,
hmDefaultOptions) or the sum of several constants’ values from this list. (“Specifying
Options in Help Resources” earlier in this chapter describes these options.)

bits;

create

window;

save

no

update

event}

{save

bits

behind

window

{

generate

and

update

}

}

}

event}

Using the Help Manager

= 11-59

ri

Inside Macintosh, Volume VI

Specify the balloon definition function and variation code (both typically0) in the third and
fourth fields of the header. (These are described in detail earlier in “Providing Help Balloons
for Menus.”’)

For each element, specify the format that the help content takes. As with the other help
resources, specify the format using one of these identifiers:
Identifier

Help

content

format

HMStringltem
HMPictltem
HMStringResItem
HMTEResItem
HMSTRReslItem
HMSkipItem

Pascal string within the help resource
‘PICT’ resource
'STR#' resource
"TEXT" and ‘styl’ resources
‘STR ' resource
No content—skip this item

Supply an identifier and help balloon content for the missing items component. The Help
Manager expects the components of an 'hovr' resource to be listed in the order previously
shown. To use any of the default help balloons, specify HMSkipItem in the corresponding
field of the 'hovr' resource. The Help Manager supplies help balloons with the missing
items’ balloon content for components you leave off the bottom of this list. The Help
Manager also uses the missing items’ balloon content if you provide an identifier for a
component but specify an empty string or a resource ID of 0 for that item’s balloon content.
Listing | 1-10 shows a resource of type ‘hovr' that overrides all of the default help balloons.
Listing 11-10.
resource

‘hovr'

(1000)

Overriding default help balloons

{

HelpMgrVersion,
hmDefaultOptions,
/* options
*/
0,
/* the balloon
definition

0,

/*

variation

HMStringItem

{

"Missing

{

/*

code

missing

override

ID

*/

*/
items

in

case

this

res

is

short

items

*/

message"

by

HMSkipItem
/*

{

/*

HMSkipItem

title
means

bar

help

use

default

/*

reserved;

always

/*

close

box

help

/*

empty

string

*/
help

balloon

for

this

element

Fa
HMSkipItem

{

specify

HMSkipItem

here

*/

ba
HMStringItem

{

a

*/

means

use

missing

items

help

*/

dy
HMStringItem
"Get
this

{ /* zoom box
message
if in

help
Zoom

{

active

*/
In

or

Zoom

Out

box."

}iz
HMStringItem
"Get

this

/*

help

message

for
if

in

app's

inactive

inactive

window

of

window

active

*/

application."

Hy
HMStringItem
"Get

this

{/*

help

message

for
if

yy

11-60

— Using the Help Manager

in

inactive
window

app's
of

window

inactive

*/

application."

*/

The Help Manager

HMStringItem
"Get

{

/*

outside

message

if

of

modal

outside

dialog

modal

help

dialog

*/

box."

——)

}

this

Adding

Your Own

Menu

Items to the Help Menu

The Help menu is specific to each application, just as the File and Edit menus are. The Help
menu items defined by the Help Manager should be common to all applications, but you
can add your own menu items for help-related information.
If you currently provide your users with help information when they choose the About
command from the Apple menu, you should instead append a command for your own help
to the Help menu. This gives users one consistent place to obtain help information.
When adding your own items to the Help menu, include the name of your application in the
command so that users can easily determine which application the help relates to. For
example, Figure | 1-16 shows the Help menu with two items appended to it by related
components of the same application.

About

Balloon

Hide

Balloons

Help...

SurfWriter help
WipeOut help

Figure 11-16. The Help menu with two appended menu items
You add items to the Help menu by using the HMGetHelpMenuHandle function and by
providing an ‘'hmnu' resource and specifying the KHMHelpMenulD constant as the
resource ID.

The HMGetHelpMenuHandle function returns a copy of the handle to the Help menu. Do not
use the GetMHandle function to get a handle to the Help menu, because GetMHandle returns
a handle to the global Help menu, not the Help menu that is specific to your application. Once
you have a handle to the Help menu that is specific to your application, you can add items to
it using the AppendMenu procedure or other Menu Manager routines. For example, this code
adds the two menu items displayed in Figure | 1-16.
VAR

mh:

MenuHandle;

BEGIN
err
IF

:=

HMGetHelpMenuHandle
(mh) ;

err

=

IF

mh

NoErr

<>

NIL

THEN

THEN

Using the Help Manager

11-61

—
—
oe

ne
a7)
—

am)
<2
—
as
_

=
~

to)
@
|

Inside Macintosh,

Volume VI

BEGIN

AppendMenu
(mh, 'SurfWriter

AppendMenu
(mh, 'WipeOut

help');

help');

END;

DrawMenuBar;
END;

Be sure to use an ‘hmnu' resource to provide help balloons for items you’ve added to the
Help menu. Use the KHMHelpMenulD constant (—16490) to specify the 'hmnu' resource ID.
After the header component of the 'hmnu' resource, provide a missing items component and
then the components for your appended items. You don’t provide a menu title component

here; instead, the Help Manager automatically creates the help balloons for the Help menu

title and the standard Help menu items. The Help Manager automatically adds a dashed line
between the end of the standard Help menu items and your appended items.
Listing 11-11 shows an ‘hmnu' resource for the appended menu items shown in
Figure 11-16.
Listing 11-11. A sample menu help resource for items in the Help menu
resource

‘'hmnu'

(kHMHelpMenuID,

HelpMgrVersion,
HMSkipItem {
/*

no

/*

},

{

0, 0O, 0O,
/* missing

missing

items,

information

*/

"Help",

purgeable)

{

/* header information
items information */

*/

skip

items

so

to

appended

menu

*/

/* SurfWriter
help command's
help balloon content
*/
HMStringResItem
{ /* use an
'STR#'
resource
for content

146,1,
TAG, 2 4

/*
/*

'STR#'
'STR#'

res
res

ID,
ID,

146,3,

0,0

/*

‘'STR#'

res

ID,

/*

command

WipeOut

help

can't

index
index

when
when

index

when

be

marked

*/

command's
dimmed */

enabled

*/

command's

checked

*/

*/

Pa
/*

HMStringResItem

by

}

{

command's

help

/*

'STR#'

use

an

balloon

*/

checked

*/

res

ID,

index

when

command's

146, 5,

/*

'STR#'

res

ID,

index

when

dimmed

146,6,
0,0

/*
/*

‘STR#'
res ID,
index when command's
command
can't
be marked
*/

*/

ir

[1]

enabled

[2]

[3]

"Closes

"SurfWriter

tutorial

dimmed

"Not

11-62

*/

enabled

'STR#'

"Displays

/*

content

/*

"Displays
/*

*/

for

146,4,

resource
'STR#'
(146,
"My help menu
items'
{ /* array
StringArray:
6 elements
*/
/*

content

resource

help

help"

for

"SurfWriter

command

SurfWriter

help"

help

for

SurfWriter

available

until

you

open

tutorial

"SurfWriter

help

for

Using the Help Manager

help"

a

help

word

word

text

{
*/

processor.";
text

*/

processor.

SurfWriter

command

SurfWriter

help

word

command

tutorial

checked

strings")

help

"

document.";
text

*/

processor.";

The Help Manager

/*
[4]
enabled
"WipeOut
help"
command help text
*/
"Displays
tutorial
help
for WipeOut
typing
corrector.";

/*

[5]

dimmed

"Displays

"WipeOut

help"

command

help

for

WipeOut

available

until

you

open

"Not

tutorial

a

help

text

typing

corrector.

SurfWriter

*/
"

document.";

/*
[6]
checked
"WipeOut
help"
command help
text
*/
"Closes
tutorial
help
for WipeOut
typing
corrector.";

yy

}

The menu help resource that you create allows you to specify help balloons for four states of
a menu item: enabled, dimmed, enabled and checked, and enabled and marked with a symbol
other than a check. You cannot specify a help balloon for a Help menu item when a modal
dialog box disables it, because you don’t have access to the missing items component of the
Help menu. When a modal dialog box appears, the Help Manager displays a default help
balloon for all dimmed Help menu items.

—_
—

@
—

—

ed

<i
—
re)

The Help Manager automatically processes the event when a user chooses any of the standard
menu items in the Help menu. The Help Manager automatically enables and disables help
when the user chooses Show Balloons or Hide Balloons from the Help menu. The setting of
help is global and affects all applications.
The MenuSelect and MenuKey functions return a result with the menu ID in the high word
and the menu item in the low word of the function result. Both functions return the
kHMHelpMenulID constant (—16490) in the high word when the user chooses an appended
item from the Help menu. The menu item number of the appended item is returned in the
low word of the function result. The MyMenuClick procedure shown here handles mouse
clicks for those items defined by the application to appear in the Help menu.
PROCEDURE
VAR

MyMenuClick(menuCode:

menu:

LongInt) ;

Integer;

item:

Integer;

window:

WindowPtr;

BEGIN

window := FrontWindow;
menu := HiWord(menuCode) ;
item := LoWord(menuCode) ;
CASE

menu

mApple:
mFile:

OF

{handle About box and other
FileClick (window, item) ;

MEGit:
mFonts:

EditClick
FontClick

(window,
(window,

kHMHelpMenuID:

HelpClick(window,
item) ;

items}

item) ;
item) ;

END;

HiliteMenu

(0);

END;

In the future, Apple may choose to add other items to the Help menu. To determine the
number of items in the Help menu, call the CountMItems function, which is descibed in
the Menu Manager chapter in Volume I.

Using the Help Manager

11-63

~~
—

a
go

@
x |

Inside Macintosh,

Volume VI

Writing Your Own

Balloon

Definition Function

The Help Manager takes care of positioning, sizing, and drawing your help balloons, and the
standard balloon definition function provides a consistent, attractive general shape to balloons
across all applications.
Though it takes extra work on your part and your balloons will not share the consistent
appearance of help balloons used by the Finder and by other applications, you can create your
own balloon definition function. The balloon definition function defines the appearance of the
help balloon. A help balloon is a special type of window. You implement a balloon definition
function by writing a window definition function that performs the tasks described in this
section. The standard balloon definition function is of type 'WDEF' with resource ID 126.
A balloon definition function is responsible for calculating the content region and structure
region of the help balloon window and drawing the frame of the help balloon. The content region is the area inside the balloon frame; it contains the user help information. The
structure region is the boundary region of the entire balloon, including the content area and
the pointer that extends from one of the help balloon’s corners. (Figure | 1-4 illustrates the
structure regions of the eight standard help balloons.)
The Help Manager first calculates the size of the rectangle that can enclose the help information and determines where to display the help balloon. The Help Manager uses TextEdit to
determine any word and line breaks in the help information. The Help Manager determines
where to display the help balloon based on the tip location and alternate rectangle.
The Help Manager then adds a system-defined distance to the size of the rectangle. This
distance allows for the tip of the help balloon. Note that the tip must always align with
an edge of the boundary rectangle. The Help Manager uses the resulting rectangle as the
boundary rectangle for the help balloon window.
The Help Manager uses the NewWindow function to create the help balloon. The Help
Manager specifies the calculated rectangle and the window definition ID as parameters to
the NewWindow function.
The NewWindow function calls the balloon definition function in the same manner as a
window definition function. See the Window Manager chapter in Volume I for more
information on writing a window definition function.
The Window Manager calls your balloon definition function with four parameters: the variation code that specifies the shape and relative tip position of the help balloon, a pointer to the
window, the action to perform, and a parameter that has variable contents depending on the
action to perform.
Here’s an example that shows the declaration for a balloon definition function called
MyBalloonDef.
FUNCTION

MyBalloonDef

(variant:

Integer;

Integer;

param:

theBalloon:
LongInt)

:

WindowPtr;

message:

LongInt;

The variant parameter is the variation code used to specify the shape and position of the help
balloon. You should use the same relative position for the tip of the help balloon that the
standard variation codes 0 through 7 specify (see Figure 1 1-4). This ensures that the tip of
the help balloon points to the object that the help balloon describes.
11-64

Using the Help Manager

The Help Manager

The parameter theBalloon is a pointer to the window of the help balloon.
The message parameter identifies the action your balloon definition function should perform.
Your balloon definition function can be sent the same messages as a window definition
function, but the only ones your balloon definition function needs to process are the wDraw
and wCalcRgns messages, which are described in the Window Manager chapter of Volume I.
When your balloon definition function receives the wCalcRgns message, your function
should calculate the content region and structure region of the help balloon.
When your balloon definition function receives the wDraw message, your function should
draw the frame of the help balloon.
—

If you want to process other messages in your balloon definition function (for example,
performing any additional initialization), you can also process the other standard
"WDEF' messages.

—,

@—

S

—
ro)

The value of the param parameter depends on the value of the message parameter. The
wCalcRgns and wDraw messages do not use this parameter.

=

As
—

ge

is)
~

If you want the Help Manager to use your balloon definition function, you specify its resource
ID and the desired variation code either in the HMShowBalloon function or in the appropriate
fields of the 'hmnu’, 'hdlg', or 'hret' resources. The Help Manager derives your balloon’s
window definition ID from its resource ID.

HELP

MANAGER

ROUTINES

This section describes the routines you use to display help balloons for the windows of your
application. It also describes how to determine whether help is enabled; how to get the name
and size of the text font in help balloons; how to set or override the help resources used with
a menu, dialog box, or window; how to get information about the window the help balloon
is displayed in; and how to display help balloons when using your own menu definition
procedure.
If you only want to provide help balloons for the menus, alert boxes, and dialog boxes of
your application, you only need to create the resources containing the descriptive information.
“Using the Help Manager” and its subsections earlier in this chapter give details on how to
create these resources.
If help is not enabled, most Help Manager routines do nothing and return the hmHelpDisabled
result code.

Determining

Whether

Help

Is Enabled

The user turns Balloon Help assistance on by choosing Show Balloons from the Help menu.
You can use the HMGetBalloons function to determine whether help is currently enabled. If
you display your own help balloons using the HMShowBalloon function, you should use
the HMGetBalloons function to determine whether help is enabled before displaying a help
balloon. If help is not enabled, you cannot display any help balloons.
FUNCTION

HMGetBalloons

:

Boolean;

Help Manager Routines

—11-65

Inside Macintosh, Volume VI

The HMGetBalloons function returns TRUE if help is currently enabled and FALSE if help is
currently not enabled. Because this function does not load the Help Manager package into
memory, it is a very fast way to determine whether help is enabled.
You can enable or disable help using the HMSetBalloons function. If you enable or disable
help, you do so for all applications. The setting of Balloon Help on-line assistance should be
under the user’s control. In most cases, you should not modify the setting chosen by the
user. If you must modify this setting, return it to its previous state as soon as possible.
FUNCTION

HMSetBalloons

(flag:

Boolean)

:

OSErr;

The flag parameter specifies whether help should be enabled or disabled for all applications
and the system software. If the flag parameter is TRUE, help is enabled. If the flag parameter
is FALSE, help is disabled and, if a help balloon is showing, you must first remove it using
the HMRemoveBalloon function.
When help is disabled, the Help Manager does not display help balloons for any applica-

tions. When help is disabled, the HMShowBalloon and HMShowMenuBalloon functions

do not display help balloons and return a nonzero result code.
Result codes

noErr
paramErr
memFullErr
resNotFound

0
—50
—108
-192

No error
Error in parameter list
Not enough room in heap zone
Unable to read resource

Determining Whether a Help Balloon

Is Showing

You can use the HMIsBalloon function to determine whether a help balloon is currently
displayed on the screen.
FUNCTION

HMIsBalloon

:

Boolean;

The HMIsBalloon function returns TRUE if a help balloon is currently displayed on the
screen and FALSE if a help balloon is not currently displayed. This function is useful for
checking whether a balloon is showing before you perform an action that redraws the screen.
For example, you might want to determine whether a balloon is displayed so that you can
remove it before opening or closing a window.

Displaying

and

Removing

Help

Balloons

When help is enabled, the Help Manager automatically tracks the cursor and displays and
removes help balloons as the user moves the cursor over hot rectangles specified in ‘hrct'
resources or over item rectangles associated with menu items and dialog items that are
specified in 'hmnu' and 'hdlg' resources. If you want to provide help balloons for areas not
defined in these resources, then your application is responsible for tracking the cursor and
determining when to display and remove help balloons for these application-defined areas.
11-66

Help Manager Routines

The Help Manager

Use the HMShowBalloon function to display a help balloon. You specify the descriptive help
information for the help balloon using the help message record. The help message record lets
you specify the help information in a number of formats. If your application uses your own
menu definition procedure, you can use the HMShowMenuBalloon function to display help
balloons for the menus that your menu definition procedure manages. The next sections
describe how to use Help Manager routines to display and remove help balloons.

Displaying a Help Balloon
The HMShowBalloon function lets you display a help balloon for the content area of any
window of your application. You need provide only the descriptive help information, the
location of the tip the Help Manager should use to display the help balloon, and a constant
specifying what method to use for displaying and removing the balloon. You can also
provide an alternate rectangle that the Help Manager uses for moving the help balloon’s tip
when it tries to fit the help balloon on screen. You can specify your own balloon definition
function and variation code, and you can provide a pointer to a tip function that lets your
application test and adjust the balloon before displaying it.
FUNCTION

HMShowBalloon

(aHelpMsg:

HMMessageRecord;

alternateRect:
variant:

RectPtr;

Integer;

tip:

Integer)

Ptr;
:

an
—

ce
——

—
ed

a

—

~

i
_~
AS
~

ge
@
™

Point;

tipProc:

method:

—
—

theProc,
OSErr;

If help is enabled, the HMShowBalloon function displays a help balloon with the descriptive
help information specified in the aHelpMsg parameter. You specify the help information in the
aHelpMsg parameter using the help message record. “Help Balloons in Dynamic Windows”
earlier in this chapter shows how to specify this information.
You specify the tip and the rectangle pointed to by the alternateRect parameter in global
coordinates. The Help Manager calculates the location and size of the help balloon. If it fits
on screen, the Help Manager displays the help balloon using the specified tip location.
If you use the previously described help resources to define help balloons, the Help Manager
uses the hot rectangles you specify in the help resources for two purposes: first, to associate
areas of the screen with help balloons and, second, to move the tip if the help balloon doesn’t
fit on screen.
If you use the HMShowBalloon function to display help balloons, you must identify hot
rectangles, create your own data structures to store their locations, track the cursor yourself,
and call HMShowBalloon when the cursor moves to your hot rectangles. The Help Manager
does not know the locations of your hot rectangles, so it cannot use them for moving the tip if
the help balloon is placed offscreen. Instead, the Help Manager uses the alternate rectangle
that you point to with the alternateRect parameter. Often, you specify the same coordinates
for the alternate rectangle that you specify for your hot rectangle. However, you may choose
to make your alternate rectangle smaller or larger than your hot rectangle. If you make your
alternate rectangle smaller than your hot rectangle, you have greater assurance that the Help
Manager will be able to fit the help balloon on screen; if you specify an alternate rectangle that
is larger than your hot rectangle, you have greater assurance that the help balloon will not
obscure some element explained by the balloon.
If you specify a rectangle in the alternateRect parameter, the Help Manager automatically
calls HMRemoveBalloon to remove the balloon when the cursor leaves the area bounded by
the rectangle.
Help Manager Routines

— 11-67

Inside Macintosh,

Volume

VI

If the balloon’s first position is partly offscreen or it intersects the menu bar, the Help
Manager tries a combination of different balloon variation codes and different tip positions
along the sides of the alternate rectangle to make the balloon fit. Figure 11-5 shows what
happens when the balloon’s first two positions are located offscreen. If, after exhausting
all possible positions, the Help Manager cannot fit the entire help balloon on screen, the Help
Manager displays a help balloon at the position that best fits on screen and clips the content
of the balloon to fit at this position. If the coordinates specified by both the original tip and
the alternateRect parameter are offscreen, the Help Manager does not display the help balloon
at all.
If you specify NIL for the alternateRect parameter, your application is responsible for tracking
the cursor and determining when to remove the help balloon. The Help Manager also does not
attempt to calculate a new tip location if the help balloon is offscreen.
Once the Help Manager determines the location and size of the help balloon, the Help Manager
calls the function pointed to by the tipProc parameter before displaying the balloon. Specify
NIL in the tipProc parameter to use the Help Manager’s default tip function.
You can supply your own tip function (as described later in “Using Your Own Tip Function”)
and point to it in the tipProc parameter. The Help Manager calls the tip function after calculating the location of the help balloon and before displaying it. In the parameters of your tip
function, the Help Manager returns the tip, the region boundary of the entire balloon, the
region boundary for the content area within the balloon frame, and the variation code to be
used for the help balloon. This allows you to examine and possibly adjust the balloon before
it is displayed.
The parameter theProc in the HMShowBalloon function specifies the balloon definition
function to use. To use your own balloon definition function, specify the resource ID of its
'WDEF resource in the parameter theProc. The Help Manager reads the balloon definition
function specified by the parameter theProc into memory if it isn’t already in memory. If the
balloon definition function can’t be read into memory, the help balloon is not displayed and
the HMShowBalloon function returns the resNotFound result code.
Specify 0 in the parameter theProc to use the standard balloon definition function. The variant
parameter is the variation code for the balloon definition function. Specify 0 in the variant
parameter to use the default help balloon shape, or specify a code from | to 7 to use one of
the other positions provided by the standard balloon definition function (see Figure 11-4). If
you write your own balloon definition function, you should support the tip locations defined
by the standard variation codes.

kHMSaveBitsWindow

ll

:

fF

kHMRegularWindow
kHMSaveBitsNoWindow

NO

CONST

oo

The method parameter specifies whether the Help Manager should save the bits behind the
balloon and whether to do an update event. Use the following constants for the parameter.

;

{don't
save
{save bits;
{save bits;

bits;
just
update}
don't
do update}
do update
event}

If you specify KHMRegularWindow, the Help Manager draws and removes the help balloon
as if it were a window. That is, when drawing the balloon the Help Manager does not save
bits behind the balloon, and when removing the balloon the Help Manager generates an
update event. This is the standard behavior of help balloons—and the behavior you should
normally use.
11-68

Help Manager Routines

The Help Manager

If you specify KHMSaveBitsNoWindow in the method parameter, the Help Manager does not
create a window for displaying the balloon. Instead, the Help Manager creates a help balloon
that is more like a menu than a window. The Help Manager saves the bits behind the balloon
when it creates the balloon. When it removes the balloon, the Help Manager restores the bits
without generating an update event. You should only use this in a modal environment where
the bits behind the balloon cannot change from the time the balloon is drawn to the time it is
removed. For example, you might specify the KHMSaveBitsNoWindow constant when
providing help balloons for pop-up menus that overlay complex graphics, which might take
a long time to redraw with an update event.
If you specify KHMSaveBitsWindow, the Help Manager treats the help balloon as a hybrid
having properties of both a menu and a window. That is, the Help Manager saves the bits
behind the balloon when it creates the balloon and, when it removes the balloon, it both

restores the bits and generates an update event. You'll rarely need this option. It is necessary
only in a modal environment that might immediately change to a nonmodal environment—
that is, where the bits behind the help balloon are static when the balloon is drawn, but can
possibly change before the help balloon is removed.
HMShowBalloon returns the noErr result code if the help balloon was successfully displayed.

—
_

mle
a

<—)

<vent

po)
=|
ts)
ga
@
ax

Result codes

noErr
paramErr
memFullErr
resNotFound
hmHelpDisabled
hmBalloonAborted

0
—50
—108
—192
—850
—853

hmOperationUnsupported

—861

Using Your Own

Menu

No error; the help balloon was displayed
Error in parameter list
Not enough room in heap zone
Unable to read resource ©
Help balloons are not enabled
Because of constant cursor movement, the help
balloon wasn’t displayed
Invalid value passed in the method parameter

Definition

Procedure

The Help Manager displays help balloons for applications that provide 'hmnu' resources and
use the standard menu definition procedure. If your application uses your own menu definition procedure, you can still use the Help Manager to display help balloons for the menus that
your menu definition procedure manages. The HMShowMenuBalloon function described in
this section uses the standard balloon definition function to display the help balloon. If you
want to use your own balloon definition function from within your menu definition procedure, call the HMShowBalloon function (described in the previous section) and specify the
kHMSaveBitsNoWindow constant for the method parameter. You must also use the
HMShowBalloon function if you don’t provide an 'hmnu' resource for your menu.
After your menu definition procedure determines that the cursor is over a menu item, you
can use the HMShowMenuBalloon function to display any help balloons associated with that
item. You must then use the HMRemoveBalloon function to remove the balloon when the
cursor moves away from the menu item.
FUNCTION

HMShowMenuBalloon

(itemNum:

Integer;

itemFlags:

LongInt;

itemMenuID:

Integer;

itemReserved:

tip:

Point;

alternateRect:

Ptr;

theProc:

Integer;

LongInt;

RectPtr;

variant:

tipProc:

Integer)

OSErr;

Help Manager Routines

— 11-69

Inside Macintosh,

Volume VI

The itemNum parameter is the menu item number of the item that the cursor is currently over.
Use a positive number in the itemNum parameter to specify a menu item, use —1 if the cursor
is over a dashed line, or use 0 if the cursor is over the menu title.
The itemMenulID parameter is the menu ID of the menu the cursor is currently in.
The itemFlags parameter is a long integer from the menu flags, which tells whether a menu
item is enabled or dimmed, and whether the menu itself is enabled or dimmed. The Help

Manager uses this value to determine which balloon to display from the 'hmnu' resource.
The itemReserved parameter is reserved for future use by Apple. Specify 0 in this parameter.
The tip parameter specifies the tip for the help balloon. The standard menu definition procedure places the tip eight pixels from either the right or left edge of the menu item. For menu
titles, the standard menu definition procedure centers the tip at the bottom of the menu bar.
Note that you should not specify a tip with coordinates in the menu bar for any menu titles.
The Help Manager uses the tip you specify unless it places the help balloon offscreen or in
the menu bar. If the tip is offscreen, the Help Manager uses the rectangle specified in the
alternateRect parameter to calculate a new tip location.
If you use the HMShowMenuBalloon function to display help balloons, you must identify hot
rectangles, create your own data structures to store their locations, track the cursor yourself,
and call HMShowMenuBalloon when the cursor moves to your hot rectangles. The Help
Manager does not know the locations of your hot rectangles, so it cannot use them for moving
the tip if the help balloon is placed offscreen. Instead, the Help Manager uses the alternate
rectangle that you point to with the alternateRect parameter.
The alternateRect parameter is the rectangle the Help Manager uses to calculate a new tip
location. (The standard menu definition procedure specifies the alternate rectangle as the
rectangle that encloses the menu title or menu item.) If the balloon’s first position is offscreen
or in the menu bar, the Help Manager tries a different balloon variation code or calculates a
new tip by transposing it to an opposite side of the alternate rectangle. If you specify NIL for
the alternateRect parameter, the Help Manager does not attempt to calculate a new tip position
if the help balloon is offscreen.
Note that, unlike the way the alternateRect parameter works in the HMShowBalloon function,
specifying an alternate rectangle to HMShowMenuBalloon does not cause the Help Manager
to track the cursor and remove the balloon for you. You must still track the cursor and use the
HMRemoveBalloon function to remove the balloon when the cursor moves out of the area
specified by the hot rectangle.
Specify NIL in the tipProc parameter to use the tip function values calculated by the Help
Manager. If you supply your own tip function (as described later in “Using Your Own Tip
Function’’) and specify it in the tipProc parameter, the Help Manager returns the tip, the
region boundary of the entire balloon, the region boundary for the content area within the
balloon frame, and the variation code to be used for the help balloon before displaying it.
This allows you to examine and possibly adjust the balloon before it is displayed.
The parameter theProc is reserved for use by Apple. Specify 0 in this parameter.
You can specify the variation code for the standard balloon definition function using the
variant parameter. Specify 0 to use the default balloon position or a code between | and 7 to
use one of the other standard positions shown in Figure 11-4.
11-70

Help Manager Routines

The Help Manager

The HMShowMenuBalloon function saves the bits behind the help balloon before displaying
the help balloon. When the help balloon is removed, the Help Manager restores the bits that
were previously behind the help balloon.
Result codes

noErr
memFullErr
hmHelpDisabled
hmBalloonAborted

0
—108
—850
—853

hmSameAsLastBalloon

-854

Removing

No error; the help balloon was displayed
Not enough room in heap zone
Help balloons are not enabled
Because of constant cursor movement, the help
balloon wasn’t displayed
Menu and item are same as last menu and item

a Help Balloon

The Help Manager automatically tracks the cursor and removes the help balloon (when the
user moves the cursor outside of the hot rectangle) for balloons defined in 'hmnu'’, 'hdlg',
and ‘hrct' resources. Your application does not need to remove help balloons created by
these resources.
If you use the HMShowBalloon function to display help balloons, you can either let the
Help Manager track the cursor and remove the help balloon when the cursor moves out of
the hot rectangle, or your application can track the cursor and determine when to remove
the balloon. To let the Help Manager track the cursor and remove the help balloon when
using the HMShowBalloon function, specify a rectangle in the alternateRect parameter. If
you want your application to track the cursor and remove the help balloon when using the
HMShowBalloon function, specify NIL in the alternateRect parameter. You must then use
the HMRemoveBalloon function to remove the balloon when the user moves the cursor
outside of the rectangle.
If you use the HMShowMenuBalloon function to display help balloons, you must always
track the cursor and use the HMRemoveBalloon function to remove the help balloon when
the cursor moves out of the hot rectangle.
A

Warning: The HMRemoveBalloon function removes any help balloon that is
currently visible, regardless of the application that displayed it. You should only
call HMRemoveBalloon when the cursor is in the content area of your application
window but not in a hot rectangle, and you should never call it when your
application is in the background. a

FUNCTION

HMRemoveBalloon

:

OSErr;

The HMRemoveBalloon function removes any balloon that is currently visible—unless the
user is using Close View and is pressing the Shift key. This action keeps the help balloon
on screen even while the user moves away from the hot rectangle under Close View. The
HMRemoveBalloon function returns a result code of hmClose ViewActive in this case.
If you use your own menu bar definition procedure, you should call HMRemoveBalloon
when your procedure receives the Save bits and Restore bits messages before you save or
restore any bits. (The Save and Restore bits messages are described in the Menu Manager
chapter in Volume V.)
Help Manager Routines

—_11-71

Inside Macintosh,

Volume VI

Result codes
noErr
hmHelpDisabled
hmNoBalloonUp
hmCloseViewActive

Using Your Own

0
—850
—862
-863

Noerror or the help balloon was removed
Help balloons are not enabled
No balloon showing
User using Close View won’t let you remove balloon

Tip Function

When you use the HMShowBalloon and HMShowMenuBalloon functions to display help
balloons, you pass a pointer to a tip function in the tipProc parameter. Normally, you supply
NIL in this parameter to use the Help Manager’s default tip function. However, you can also
supply your own tip function. The Help Manager calls your tip function after calculating the
size and the location of a help balloon and before displaying it. This allows you to examine
and, if necessary, adjust the balloon before it is displayed. For example, if you determine that
the help balloon would obscure an object that requires extensive redrawing, you might use a

different variation code to move the balloon.

Here’s how to declare a tip function called MyTip.
FUNCTION

MyTip

(tip:

Point;

structure:

VAR

variant:

Integer)

RgnHandle;
:

VAR

r:

Rect;

OSErr;

The Help Manager returns the balloon tip in the tip parameter, a handle to its region structure
in the structure parameter, the content region in the r parameter, and the variation code to be

used for the help balloon in the variant parameter. The content region is the area inside the

balloon frame; it contains the user help information. The structure region is the boundary
region of the entire balloon, including the content area and the pointer that extends from one
of the help balloon’s corners. (Figure 1 1-4 illustrates the structure regions of the eight
standard help balloons.)
If the help balloon that HMShowBalloon or HMShowMenuBalloon initially calculates is
not appropriate for your current screen display, you can make minor adjustments to it by
specifying a different rectangle in the r parameter (the Help Manager automatically adjusts
the structure parameter so that the entire balloon is larger or smaller as necessary) or by
specifying a different variation code in the variant parameter. (Figure | 1-4 shows the
different balloon positions assigned to the standard variation codes.)
If you need to make a major adjustment to the help balloon, return the hmBalloonAborted
result code and call HMShowBalloon or HMShowMenuBalloon with appropriate new
parameter values. To use the values returned in your tip function’s parameters, return the
noErr result code.

Here’s an example of using a tip function to refrain from displaying a balloon if it obscures
an area of the screen that requires extensive drawing.
VAR

temprect:
DontObscureRect:

Rect;
Rect;

tip:

Point;

structure:
aHelpMsg:

RgnHandle;
HMMessageRecord;

11-72.

Help Manager Routines

The Help Manager

BEGIN
{be

sure

IF

to

determine

DontObscureRect

and

fill

in

aHelpMsg}

HMShowBalloon(aHelpMsg,tip,NIL,

@MyTip,0,0,kHMRegularwindow)

{test

complex

=

noErr

THEN

IF

whether

balloon

obscures

SectRect (structure®**.rgnBBox,
show this balloon
but
{don't
MyTip

ELSE

:=

{use

MyTip

in

DontObscureRect }
THEN

hmBalloonAborted
the

:=

graphic

DontObscureRect,temprect)
call
HMShowBalloon
later}

balloon

as

calculated

by

the

Help

Manager}

noErr;

END;

Adding

—
—

Items to the Help Menu

@

The Help Manager automatically appends the Help menu when your application calls
InsertMenu and then DrawMenuBar. The Help menu is automatically appended to the right
of all your menus and to the left of the Application menu (and to the left of the Keyboard
menu if a non-Roman script system is installed).
The Help menu is specific to each application. The Help menu items defined by the Help
Manager should be common to all applications, but you can append your own menu items
for help-related information.
You can append items to the Help menu using the HMGetHelpMenuHandle function. Do not
use the GetMHandle function to get a handle to the Help menu, because GetMHandle returns
a handle to the global Help menu, not the Help menu that is specific to your application. Once
you have a handle to the Help menu that is specific to your application, you can add items to
it using the AppendMenu procedure or other Menu Manager routines.
FUNCTION

HMGetHelpMenuHandle

(VAR

mh:

MenuHandle)

:

OSErr;

The HMGetHelpMenuHandle function returns a copy of a handle to the Help menu in the
mh parameter. Once you have a handle to the Help menu that is specific to your application,
you can append items to it using the AppendMenu routine or related Menu Manager routines.
The Help Manager automatically adds the dashed line that separates your items from the rest
of the menu.
Be sure to define help balloons for your items in the Help menu by creating an ‘hmnu'
resource and specifying the KHMHelpMenulID constant as its resource ID. (See “Adding
Your Own Menu Items to the Help Menu” earlier in this chapter for more details.)

The MenuSelect and MenuKey functions return a result with the menu ID in the high word and
the menu item in the low word of the function result. Both functions return the HelpMgrID
constant in the high word when the user chooses an appended item from the Help menu.
The menu item number of the appended menu item is returned in the low word of the function
result. In the future, Apple may choose to add other items to the Help menu. To determine the
number of items in the Help menu, call the CountMItems function.

Help Manager Routines

—- 11-73

——
—
eed

rr
—

as
—
a
ae

ne
ga
‘-)
-~

Inside Macintosh,

Volume V1

Result codes

noErr
paramErr
memFullErr
resNotFound
hmHelpManagerNotInited

Q
—50
-108
-—192
-855

Noerror
Error in parameter list
Notenough room in heap zone
Unable to read resource
Help menu not set up

Getting and Setting the Font Name

and Size

You can get information about the font name and size currently used for text strings displayed
in help balloons, and you can change the font name and size.
A

Warning: If your application changes the font name or size, the change affects
all applications and software that display help balloons. a

You can use the HMGetFont function to get information about the font that is currently used
to display text (that is, Pascal strings and strings from 'STR#' and 'STR ' resources) in help

balloons. This does not apply to text in 'PICT" or styled text resources, or to text in handles
to either of these resources.
FUNCTION

HMGetFont

(VAR

font:

Integer)

:

OSErr;

The HMGetFont function returns the global font number used to display text in help balloons
in the font parameter.
Result codes
noErr
memFullErr

0
-108

No error
Not enough room in heap zone

You can use the HMGetFontSize function to get information about the font size that is
currently used to display text in help balloons.
FUNCTION

HMGetFontSize

(VAR

fontSize:

Integer)

:

OSErr;

The HMGetFontSize function returns the global font size used to display text in help balloons
in the fontSize parameter.
Result codes
noErr
memFullErr

0
-108

No error
Not enough room in heap zone

The HMSetFont function sets the font used to display text in help balloons.
FUNCTION

11-74

HMSetFont

(font:

Integer)

— Help Manager Routines

:

OSErr;

The Help Manager

The font parameter specifies the global font number for the Help Manager to use to display
text in help balloons. This sets the font for help balloons in all applications and software that
display help balloons. Use this function with extreme restraint; the default font provides a
consistent look across applications.
Result codes
noErr
memFullErr

0
—-108

No error
Not enough room in heap zone

The HMSetFontSize function sets the font used to display text in help balloons.
FUNCTION

HMSetFontSize

(fontSize:

Integer)

:

OSErr;

ome
ima

The font parameter specifies the global font size for the Help Manager to use to display text in
help balloons. This sets the font size for help balloons in all applications and software that
display help balloons. Use this function only with extreme caution; the choice of font size
should always be under the user’s control.
Result codes
noErr
memFullErr

Getting

and

0
-—108

Setting

No error
Not enough room in heap zone

Information

for Help

Resources

Using the HMSetMenuResID or HMScanTemplateltems function, you can set help resources
for menus, dialog boxes, or windows of your application that do not currently have help
resources associated with them. You can also supplement the 'hmnu' and ‘hdlg' resources
currently associated with the menus and dialog boxes of your application by using the
HMSetMenuResID or HMSetDialogResID function.
You can supplement whatever ‘hdlg' resources may be specified in 'DITL' resources by
using the HMSetDialogResID function. The resource you specify in the HMSetDialogResID
function adds to any help that already exists in the form of an 'hdlg' resource for the next
dialog box or alert box to be displayed. If you create dialog boxes or alert boxes on the fly,
you can use an ‘hdlg' resource (described earlier in “Providing Help Balloons for Items in
Dialog Boxes and Alert Boxes”’) to provide help balloons for items in a template, and you can
use the HMSetDialogResID function to provide help balloons for items that you add to your
dialog box template.
You can use the HMGetDialogResID function to get the resource ID of the 'hdlg' resource that
will be used by the next dialog box as a result of a previous call to the HMSetDialogResID
function. If the 'hdlg' resource currently in use has not been overridden by a call to
HMSetDialogResID, the HMGetDialogResID function returns a result code of resNotFound.
You can use the HMGetDialogResID and HMSetDialogResID functions when displaying
nested dialog boxes. For example, you can save the 'hdlg' resource of the current dialog box,
set a new ‘hdlg' resource, display the new dialog box, and then restore the setting of the
previous ‘hdlg' resource when you close the second dialog box.

Help Manager Routines

= 11-75

<i

—
—
~~

=<
—
~~
—
—

=
ge

ic
me

Inside Macintosh,

Volume V1

You can set the resource ID for the 'hdlg' template used to display the next dialog box using
the HMSetDialogResID function.
FUNCTION

HMSetDialogResID

(resID:

Integer)

:

OSErr;

The resID parameter specifies the resource ID of the 'hdlg' resource to use when displaying
the next dialog box or alert box. This supplements whatever ‘hdlg' resource might already be
associated with that dialog box or alert box by a helpltem item in its 'DITL'’.
Specify —1 in the resID parameter to reset or clear a previous call to the HMSetDialogResID
function.
Result codes
noErr
memFullErr

0
—108

No error
Not enough room in heap zone

You can use the HMGetDialogResID function to get the resource ID of the 'hdlg’ resource
that will be used by the next dialog box as a result of a previous call to the HMSetDialogResID
function.
FUNCTION

HMGetDialogResID

(VAR

resID:

Integer)

:

OSErr;

The HMGetDialogResID function returns in the resID parameter the resource ID of the last
‘hdlg' resource that was previously set by calling the HMSetDialogResID function. If
the 'hdlg' resource currently in use was not set by calling the HMSetDialogResID function,
the HMGetDialogResID function returns a result code of resNotFound.
Result codes
noErr

memFullErr

resNotFound

()

—108

—192

No

error

Not enough room in heap zone

Unable to read resource

You can use the HMSetMenuResID function to set the 'hmnu' resource for a menu that
did not previously have one or to supplement the existing 'hmnu' resource for a menu.
FUNCTION

HMSetMenuResID

(menuID,resID:

Integer)

:

OSErr;

The menulD parameter specifies the menu to associate with the 'hmnu' resource. The resID
parameter specifies the resource ID of the 'hmnu' resource to use for the menu specified by
the menulD parameter. The menu identified by the menulD parameter should correspond to
an existing menu in your menu list. The Help Manager maintains a list of the menus whose
‘hmnu' resources you map (set or override) using the HMSetMenuResID function.
Specify —1 in the resID parameter to unmap the pairing of a particular menu and ‘'hmnu'
resource that you previously mapped using the HMSetMenuResID function. You should
unmap any resource IDs before your application quits.

11-76

Help Manager Routines

The Help Manager

Result codes
noErr
memFullErr

0
—108

No error
Not enough room in heap zone

You can use the HMGetMenuResID function to get information about the menus you
have mapped with the HMSetMenuResID function.
FUNCTION

HMGetMenuResID

(menuID:

Integer;

VAR

resID:

Integer)

:

OSErr;

The menulD parameter specifies the menu for which you want the mapped resource ID. The
value specified in the menuID parameter must have been previously mapped using the
HMSetMenuResID function.
The HMGetMenuResID function returns in the resID parameter the resource ID of the mapped
‘hmnu' resource associated with the menu specified by the menuID parameter. If the menu
does not have an 'hmnu' resource that was previously mapped by calling HMSetMenuResID,
the HMGetMenuResID function returns —1 in the resID parameter and a nonzero result code.

—
os

&—

<)
2

—
re)

=

fee
~

tio)
@
a)

Result codes
noErr
resNotFound

0
—192

No error
Unable to read resource

You can use the HMScanTemplateltems function to search for a particular resource of type
‘hdlg' or ‘hret' and, if the resource is found, use it for the active window. (If you want
this capability without modifying your code, you can add a helpItem item to your 'DITL'
resources or add an ‘hwin' resource—as described previously in “Providing Help Balloons
for Items in Dialog Boxes and Alert Boxes” and “Providing Help Balloons for Window

Content.”’)
FUNCTION

HMScanTemplateItems

(whichID,whichResFile:
ResType)

:

Integer;

whichType:

OSErr;

The whichID parameter specifies the resource ID to search for. The whichResFile parameter
specifies the file reference number of the resource file to search. The resource file must
already be open. Specify —1 in the whichResFile parameter to search the current resource file.
The whichType parameter specifies the type of help resource to search for—either ‘hdlg' or
‘hret'. If the specified resource is found, the Help Manager applies the help information
specified in the resource to the frontmost window.
Result codes
noErr

fnOpnErr
memFullErr

resNotFound

0

—38
-108
—192

No error

File not open
Not enough room in heap zone
Unable to read resource

Help Manager Routines

— 11-77

Inside Macintosh, Volume VI

Getting the Dimensions

of a Help Balloon

The Help Manager provides three functions that allow you to get information about a help
balloon before or during display. You probably won’t need to call these functions. If your
application does extensive drawing, however, these functions could be helpful for
determining the location of your help balloons before displaying them. Then you could
ensure that your help balloons don’t obscure an area that requires an inordinate amount of
time to update.
To get information about a help balloon before the Help Manager displays it, use the
HMBalloonRect or HMBalloonPict function. To get a pointer to the window record of
the currently displayed help balloon, use the HMGetBalloonWindow function.
You can specify the help information for a help balloon and then use the HMBalloonRect
function to get the coordinates of the rectangle that the Help Manager would use to display the
help balloon.
FUNCTION

HMBalloonRect

(aHelpMsg:
:

HMMessageRecord;

VAR

coolRect:

Rect)

OSErr;

You specify the help information for a help balloon in the aHelpMsg parameter. The aHelpMsg
parameter is of data type HMMessageRecord. “Help Balloons in Dynamic Windows” earlier
in this chapter describes the fields of this record.
The HMBalloonRect function calculates the coordinates that the Help Manager will use if you
show this help balloon. The HMBalloonRect function returns the rectangle coordinates in the
coolRect parameter. The coordinates of the returned rectangle are zero-based, with (0,0) the

coordinates of the upper-left corner of the rectangle. The coolRect parameter gives the coor-

dinates of the rectangle that encloses the user help information.

You can use the HMBalloonRect function to find out the size (not the position) of the

rectangle for a help balloon message.

Note that the HMBalloonRect function does not display the help balloon; it returns the
rectangle that the Help Manager will use if you choose to display a help balloon with

the specified user help information.
Result codes
noErr
paramErr
memFullErr

0
—50
—108

No error
Error in parameter list
Not enough room in heap zone

You can specify the help information for a help balloon and then use the HMBalloonPict
function to get a handle to the picture that the Help Manager will generate if you later choose
to display the help balloon.
FUNCTION

HMBalloonPict

(aHelpMsg:

PicHandle)

HMMessageRecord;

:

VAR

coolPict:

OSErr;

The aHelpMsg parameter specifies the help information for a help balloon. The aHelpMsg
parameter is of data type HMMessageRecord. “Help Balloons in Dynamic Windows” earlier
in this chapter describes the fields of this record.
11-78

— Help Manager Routines

The Help Manager

The HMBalloonPict function calculates the picture handle the Help Manager will use if you
later choose to display this help balloon. The HMBalloonPict function returns a handle to the
picture in the coolPict parameter.
The HMBalloonPict function does not display the help balloon; it returns a handle to the
picture that the Help Manager will use if you later choose to display a help balloon with the
specified information.
The pictFrame field of the picture handle in the coolPict parameter contains the same rectangle
as the rectangle obtained from the HMBalloonRect function. The rectangle specifies the
display rectangle that surrounds the picture.
Result codes

noErr
paramErr
memFullErr

—

0
—50
—108

—

No error
Error in parameter list
Not enough room in heap zone

Lamake
@

~~

c<
—

The Help Manager displays help balloons in special windows. You can get a pointer to the
window record of the currently displayed help balloon using the HMGetBalloonWindow
function.
FUNCTION

HMGetBalloonWindow

(VAR

window:

WindowPtr)

:

OSErr;

The HMGetBalloonWindow function returns a pointer to the window record of the
currently displayed help balloon in the window parameter. If a help balloon is not currently
displayed, the HMGetBalloonWindow function returns NIL in the window parameter.

The HMGetBalloonWindow function also returns NIL for balloons created with the
HMShowMenuBalloon function because no windows are created; likewise, NIL is returned
for balloons created with the HMShowBalloon function when the kHMSaveBitsNoWindow

constant is specified as the method parameter.
Result codes
noErr
memFullErr

0
—108

No error
Not enough room in heap zone

Getting the Content of a Help Balloon
Using the HMExtractHelpMsg and HMGetIndHelpMsg functions, you can extract information from existing help resources.
You can use HMExtractHelpMsg to extract the help balloon content specified in existing help
resources. You might find this useful if you have duplicate commands and you want to store
help messages in only one resource. For example, if you have a dialog box that replicates
portions of a pull-down menu, you could specify help information in the 'hmnu' resource for
the pull-down menu, and use HMExtractHelpMsg to extract those help messages to use with
related dialog items in the dialog box’s 'hdlg’ resource.
FUNCTION

HMExtractHelpMsg

(whichType:

ResType;

whichResID,whichMsg,

whichState:
Integer;
VAR aHelpMsg:
HMMessageRecord)
: OSErr;

Help Manager Routines

—_ 11-79

=)
~
a
itj=
@
er

Inside Macintosh,

Volume VI

The whichType parameter specifies the format of the help message. Supply one of these
constants.
CONST

kHMMenuResType

=

'hmnu';

{menu

kHMDialogResType
kHMRectListResType

=
=

"Kaley" 3
“pret”:

{dialog
help resource
type}
{rect
help resource
type}

help

resource

kHMOverrideResType

=

"hovers ¢

{help

override

resource

type}

kHMFinderApplResType

=

‘hfdr';

{app

icon

resource

type}

help

type}

Note: If HMCompareltem appears as a component of an ‘'hmnu' resource that
youre examining, neither this function nor HMGetIndHelpMsg performs a
comparison against the current name of any menu item. Instead, these functions
return the messages listed in your HMComparelItem components in the order in
which they appear in the 'hmnu' resource.
Supply the whichResID parameter with the resource ID of the help resource whose content
you wish to extract. Specify the index of the component you wish to extract in the whichMsg
parameter. (Don’t count the header information as a component to index.) After the header
information, for example, the first component in a menu help resource defines help for
missing items; the second item defines help for the menu title.
For menu items and dialog items, the whichState parameter specifies the state of the
item whose message you wish to extract. Use one of the following constants for the
whichState parameter.
kHMEnabledItem

=

kHMDisableditem

ll

CONST

kHMCheckedIitem

=

kHMOtherItem

=

0;

{enabled

state

for

menu

items;

}

{ contrlHilite value of 1 for controls}
{disabled state for menu items;
}
{ contrlHilite value of 0 for controls}
2;

3;

{enabled-and-checked

state

for

menu

{

value

of

1

items;

contrlHilite

{ controls
that
are
{enabled-and-marked
{
{

items;
contrlHilite
1 for controls}

"on"}
state
value

for

}

for

menu

}
}

greater

than

For the KHMRectListResType, kHMOverrideResType, and KHMFinderAppIResType

resource types—which don’t have states—supply the KHMEnabledItem constant for the
whichState parameter.
HMExtractHelpMsg returns a help message record in the aHelpMsg parameter. The
aHelpMsg parameter is of data type HMMessageRecord. “Help Balloons in Dynamic
Windows” earlier in this chapter describes the fields of this record.
In the following example, a menu help resource has a resource ID of 128. A 2 is supplied as
the whichMsg parameter to retrieve information about the resource’s second component (the
second component after the header, that is), which is the menu title. The menu title has four
possible states; to retrieve the help message for the menu title in its dimmed state, the constant
kHMDisabledItem is used for the whichState parameter. The help message record returned in
aHelpMsg is then passed to HMShowBalloon, which displays the message in a balloon with
its tip located at the point specified in the tip parameter.
11-80

—_ Help Manager Routines

}

The Help Manager

VAR
aHelpMsg:

HMMessageRecord;

tip:

Point;

alternateRect:

Rect;

err:

OSErr;

BEGIN

err
:=
IF err

HMExtractHelpMsg
= noErr THEN

{be

sure

err

:=

to

assign

(HMMenuListResType,128,2,kDisabledItem,
aHelpMsg) ;

a

tip

and

rectangle

coordinates

here}

HMShowBalloon(aHelpMsg,tip,alternateRect,
NIL,

0,0, kKHMRegularWindow) ;

END;

—
—
es wi

To retrieve all of the help balloon messages for a given resource, set whichMsg to | and make
repeated calls to HMExtractHelpMsg, incrementing whichMsg by | on each subsequent call
until it returns the hmSkipBalloon result code.
Result codes

noErr
paramErr
memFullErr
resNotFound
hmSkipBalloon
hmWrong Version
hmUnknownHelpType

HMGetIndHelpMsg

c

2

mae
as
=
_
—
as
_

ge
@
—

0
—50
—108
-—192
—857
—858
-859

No error
Error in parameter list
Not enough room in heap zone
Unable to read resource
No balloon content to fill in
Wrong version of Help Manager resource
Help message record contained a bad type

In addition to extracting the help balloon content specified in existing help resources as
HMExtractHelpMsg does, HMGetIndHelpMsg returns additional information regarding the
help resource, such as its variation code, tip location, and so on.
FUNCTION

as

—
—
—_

(whichType:

ResType;

whichState:
VAR

tip:

Integer;

Point;

VAR

whichResID,whichMsg,
VAR

options:

altRect:

Rect;

LongInt;
VAR

theProc:

Integer;
VAR variant:
Integer;
VAR aHelpMsg:
HMMessageRecord;
VAR count:
Integer)
: OSErr;

The information you supply to the HMGetIndHelpMsg function is similar to what you supply
to the HMExtractHelpMsg function. (See the description of the HMExtractHelpMsg function
above for information about the whichType, whichResID, whichMsg, and whichState
parameters.)
HMGetIndHelpMsg returns the following information about the specified help resource: the
value of the options field in the options parameter; the coordinates of the tip location in the tip
parameter; the coordinates of the alternate rectangle in the altRect parameter; the resource ID
of its 'WDEF' resource in the theProc parameter; the balloon definition function’s variation
code in the variant parameter; the help message record in the aHelpMsg parameter; and, in
the count parameter, the number of components defined in the resource (not counting the
header information).

Help Manager Routines

—_ 11-81

;

Inside Macintosh, Volume VI

To retrieve all of the help balloon messages and related information for a given resource, set
whichMsg to | and make repeated calls to HMGetIndHelpMsg, incrementing whichMsg by 1
on each subsequent call until it returns the hmSkipBalloon result code.
Result codes
noErr
paramErr
memFullErr
resNotFound
hmSkipBalloon
hmWrong Version
hmUnknownHelpType

11-82

0
—50
—108
—192
—857
—858
-859

Help Manager Routines

No error
Error in parameter list
Not enough room in heap zone
Unable to read resource
No balloon content to fill in
Wrong version of Help Manager resource
Help message record contained a bad type

The Help Manager

SUMMARY

OF

THE

HELP

MANAGER

Constants
gestaltHelpMgrAttr

=

'help';

{Gestalt

selector}

gestaltHelpMgrPresent

=

0;

{if

bit

{

hmBalloonHelpVersion
{Help

menu

=

this

Help

is

Manager

$0002;

{Help

Manager

menu

set,
is

then

}

present}

version}

constants}

kHMHelpMenuID

=

-16490;

{Help

kHMAboutHelpItem
kHMShowBalloonsItem

=
=

1s
oy

{About Balloon Help
{Show/Hide Balloons

menu
menu

kHMHelpID

=

-5696;

{ID

Manager

kBalloonWDEFID

=

template

{option

for

bits

help

package

{

Packl4

'WDEF'

also

}

}

used

}

}

resources}
0;

{use

help

Ly

{use

subrange

{

owned

=

defaults}

resource

IDs

}

resources}

{ignore

{ origin
and treat upper-left
{ corner of window as 0,0}
{don't
create window;
save
}

=

4;

hmSaveBitsWindow

=

8;

{

bits;

{save

coords

of

{

no

update

event}

bits

behind

window

of

anywhere

in

title

khmmStringRes
khmmTEHandle

hmmHelpType
field
= 13
= 2 iy
= 3 3%
= 4 As

khmmPictHandle
khmmTERes

=
=

6 67

{picture
handle}
{'styl'
and
'TEXT'

khmmSTRRes

=

Ts

{'STR'

5;

window

}

and

{ generate
update
event}
{match window by string

(o>)

ul

for

resource

25

hmSaveBitsNoWindow

khmmPict

(in

item}
item}

type constant}
= Le
{key value in 'DITL'
template
{ that corresponds to help }
{ item}

=

for

ID}

function}

=

{constants
khmmString

Help

range);

hmUseSubID

hmMatchinTitle

menu

resources

hmDefaultOptions

hmAbsoluteCoords

and

various

{

{

{dialog item
HelpItem

of

res

{ for res ID for 'hfdr'/icon }
{ help}
{res ID of standard balloon }

126%

ay

CONST

}

}

}

string}

HMMessageRecord}
{Pascal
string}

{'PICT'

resource

{'STR#'
{styled

res
ID and index}
text
handle}

resource

ID}

res

ID}

ID}

Summary of the Help Manager

——- 11-83

Inside Macintosh,

Volume VI

{resource

types

styled

TE

kHMTEText

ResType

for

=

“TEXT”;

handles

{'TEXT'

resource

type}

kHMTEStyleResType

=

"Styl"

{'styl'

resource

type}

{generic defines for whichState
{ message records from 'hmnu' &
kHMEnabledItem
= 0;

os

ds

kHMCheckedItem

=

23

resources}

parameter when extracting help }
'hdlg'
resources}
{enabled state for menu items;
{
{

kHMDisabledItem

in

contrlHilite
controls}

{ controls}
{enabled-and-checked
{

=

33

{

help

types

message

for

1

for

controls

whichType

greater

parameter

used

when

extracting

help

resource

"hmnu';

{menu

'hdlg';
'hwin';

{Gialog
{window

kHMRectListResType

=

*hret';

{rectangle

kHMOverrideResType
kHMFinderApp]lResType

=
=

“hevr':
"hfdr’;

{help override
{app icon help

method

kHMSaveBitsWindow

'hfdr'

for

}

for

for

help

parameter

=
=

§;
ly

=

2;

types

in

resources--useful

in

}

help

controls}
}

bits;
don't

{save

do

‘hdlg',

for

2
=
m
=

Is
23
33
6;

{Pascal
{'PICT'
{'STR#'
{'TEXT'

these

kHMSTRResItem

=

7

{'STR

=

256;

{don't

display

kHMCompareItem

=

SLAs

kHMNamedResourcelItem

=

1024;

{for
{ if
{for

hmnu, use
menu item
hmnu, use

kHMTrackCntliItem

=

2048;

{reserved}

{

a

'

resource

call

to

get

event}

‘hovr',

&

}

resources}

string}
resource
resource
& 'styl'

kHMSkipItem

type}

type
type}

just update}
do update}

update

‘hrcet',

walking

kHMStringItem
kHMPictItem
kHMStringResItem
kHMTEResItem

Summary of the Help Manager

resource

{don't save
{save bits;
bits;

type}
type}

resource
resource

ID}
ID & index}
resource ID}
ID}

a

balloon}

help content
}
matches string}
menu item as }
resource}

}

"on"}

type}

resource
resource

HMShowBalloon}

‘'hmnu',

only

help
help

}

value
are

1

=
=

{

that

than

=

{constants

state

contrlHilite

kHMDialogResType
kHMWindListResType

for

}

for

content }

kHMRegularWindow
kHMSaveBitsNoWindow

11-84

of

items;

kHMMenuResType

{constants

1

{enabled-and-marked state for }
{ menu items; contrlHilite value
{

{resource

of

{disabled state for menu items;
{ contrlHilite value of 0 for }

{ menu
kHMOtherItem

value

}

The Help Manager

Data
TYPE

Types
HMMessageRecPtr

=

HMMessageRecord

=

“HMMessageRecord;

RECORD
hmmHelpType:

Integer;

CASE
Integer
OF
khmmString:
khmmPict:

(hmmString:
STR255);
(hmmPict:
Integer);

khmmStringRes:

(hmmStringRes:

{Pascal
{'PICT'

HMStringResType);
{

{'STR#'
and

(hmmTEHandle:

khmmPictHandle:

(hmmPictHandle:

khmmTERes

(hmmTERes:

Integer);

{'styl'/'TEXT'

(hmmSTRRes:

Integer)

{ resource
ID}
{'STR'
resource

khmmSTRRes:

{TextEdit

PicHandle);

{picture

ID}

res

}

index}

khmmTEHandle:
:

TEHandle);

ID

string}
resource

handle}

handle}
}
ID}

END;

HMStringResType
RECORD

=

hmmResID:

Integer;

{res

hmmiIndex:

Integer

{index

ID

of

of

'STR#'

resource}

string}

END;

Routines

Determining

Whether

Help

Is Enabled

FUNCTION

HMGetBalloons

:

FUNCTION

HMSetBalloons

(flag:

Determining
FUNCTION

and

Removing

HMShowBalloon

Boolean)

a Help Balloon

HMIsBalloon

Displaying
FUNCTION

Whether

Boolean;

:

:

OSErr;

Is Showing

Boolean;

Help Balloons
(aHelpMsg:

HMMessageRecord;

tip:

Point;

alternateRect:
RectPtr;
tipProc:
Ptr;
theProc,
variant:
Integer;
method:
Integer)
OSErr;

Summary of the Help Manager

— 11-85

Inside Macintosh,

FUNCTION

Volume VI

HMShowMenuBalloon

(itemNum:

Integer;

itemMenulID:

Integer;

itemFlags:
Longint;
itemReserved:
LongInt;
Point;
Rect Ptr;
tipProc:
tip:
alternateRect:
theProc:
Ptr >
Integer;
variant:
Integer)
OSErr;

FUNCTION

HMRemoveBalloon

Adding

Items to the Help Menu

FUNCTION

HMGetHelpMenuHandle

OSErr;

(VAR

mh:

MenuHandle)

Getting and Setting the Font Name

and Size

FUNCTION

HMGetFont

(VAR

font:

FUNCTION

HMGet Font Size

(VAR

fontSize:

FUNCTION

HMSetFont

(font:

FUNCTION

HMSetFontSize

(fontSize:

Getting and Setting

OSErr;

Integer)

OSErrY :

Integer)

Integer)

OSErr;

OSErr;

Integer)

OSErr;

Information for Help Resources

FUNCTION

HMSetDialogResID

(resID:

FUNCTION

HMGetDialogResID

(VAR

FUNCTION

HMSetMenuResID

(menulID,resID:

FUNCTION

HMGetMenuResID

(menulD:

Integer)

resID:

OSErr;

Integer)

OSErr;

Integer)

Integer;

VAR

OSErr;
resID:

Integer)

OSErr;

FUNCTION

HMScanTemplateItems

(whichID,whichResFile:
ResType)

Getting the Dimensions

Integer;

whichType:

OSErr;

of a Help Balloon

FUNCTION

HMBalloonRect

(aHelpMsg:
HMMessageRecord;
Rect)
OSErr;

VAR

coolRect:

FUNCTION

HMBalloonPict

(aHelpMsg:

VAR

coolPict:

PicHandle)
FUNCTION

11-86

HMGetBalloonWindow

(VAR

Summary of the Help Manager

window:

HMMessageRecord;
OSErr;
WindowPtr)

OSErr;

The Help Manager

Getting the Content of a Help Balloon
FUNCTION

ResType;
whichResID,whichMsg,
(whichType:
whichState:
Integer;
VAR aHelpMsg:

HMExtractHelpMsg

HMMessageRecord)
FUNCTION

HMGetIndHelpMsg

(whichType:

Application-Defined

tip:

OSErr;

ResType;

whichState:

VAR

:

whichResID,whichMsg,

Integer;

Point;

VAR

VAR

options:

altRect:

LongInt;

Rect;

theProc:
aHelpMsg:

Integer;
VAR variant:
HMMessageRecord;
VAR

Integer)

:

VAR

Integer;
count:

VAR

OSErr;
—

Routines

o
<

FUNCTION

FUNCTION

MyBalloonDef

(variant:

Integer;

theBalloon:

message:

Integer;

param:

(tip:

MyTip

Rect;

Result

Point;
VAR

structure:
variant:

WindowPtr;

LongInt)
RgnHandle;

Integer)

:

:

LongInt;

VAR

r:

OSErr;

Codes

noErr

fnOpnErr
paramErr

memFullErr
resNotFound

hmHelpDisabled

hmBalloonAborted
hmSameAsLastBalloon

hmHelpManagerNotInited
hmSkippedBalloon
hmWrong Version
hmUnknownHelpType
hmOperationUnsupported
hmNoBalloonUp
hmCloseViewActive

—108

No error
File not open
Error in parameter list
Not enough room in heap zone
Unable to read resource
Help balloons are not enabled
Because of constant cursor movement, the help
balloon wasn’t displayed
Menu and item are same as previous menu
and item
Help menu not set up
No balloon content to fill in
Wrong version of Help Manager resource
Help message record contained a bad type
Invalid value passed in the method parameter
No balloon showing
User using Close View won’t let you remove
balloon

Summary of the Help Manager

— 11-87

=

we

Inside Macintosh,

Volume VI

Assembly-Language
Trap

Macros

Information

Requiring

Routine

_Pack14
Selector

Routine

$0002
$0003
$0007
$0104
$0108
$0109

HMRemoveBalloon
HMGetBalloons
HMIsBalloon
HMSetBalloons
HMSetFont
HMSetFontSize

$020A

HMGetFont

$010C
$0200

$020B
$020D

HMSetDialogResID
HMGetHelpMenuHandle
HMGetFontSize
HMSetMenuResID

$0213

HMGetDialogResID

$0410
$0711

HMScanTemplateltems
HMExtractHelpMsg

$0215
$0314
$040E
$040F
$0B01
$0E05

$1306

11-88

HMGetBalloonWindow
HMGetMenuResID
HMBalloonRect
HMBalloonPict
HMShowBalloon
HMShowMenuBalloon

HMGetIndHelpMsg

= Summary of the Help Manager

Selectors

THE

FONT

MANAGER

About This Chapter
About the Font Manager
Font Terminology
Font Measurements
Font Scaling
How the Font Manager Renders TrueType Fonts
Using the Font Manager
Adding Font Sizes and Names to the Menu
Storing a Font Name in a Document
Using TrueType Fonts in Preference to Bitmapped Fonts
Preserving the Glyph’s Shape
Font Manager Routines
Choosing TrueType Fonts Over Bitmapped Fonts
Scaling Fonts
Erasing the Font Manager’s Memory Caches
Summary of the Font Manager

—_

Nw
cet
a
~
—_
~
_

a
—

ie)
_
=

~
ge
om
a

12-1

>

Inside Macintosh,

12-2

Volume VI

The Font Manager

ABOUT

THIS

CHAPTER

System software version 7.0 introduces Apple’s new outline fonts, called TrueType™ fonts.
This chapter describes what outline fonts are and how you can use them in your application.
You need to read this chapter if you want to know what TrueType fonts are, how they differ
from bitmapped fonts, and how to take advantage of both in your application. To test for the
availability of outline fonts, use the Gestalt function, described in the Compatibility
Guidelines chapter in this volume.
This chapter does not contain information about the format of the new 'sfnt' resource that
defines an outline font, nor does it explain how to build TrueType fonts or create font
editors. If you want to create your own TrueType fonts or font editors, consult the
TrueType Font Format Specification book, available from APDA®.
You may want to read the Font Manager chapters in Volume I, Volume IV, and Volume V.
Volume I contains definitions you may need to understand some concepts in this chapter,
and it describes the relationship between the Font Manager and QuickDraw™. Volume IV
describes the 'NFNT' and 'FOND' resources and fractional character widths. Volume V
describes how to build color bitmapped fonts and provides further information about
fractional character widths. You may also want to read the QuickDraw chapter in Volume IJ,
which describes how QuickDraw draws text.

—

nN
—
=
=
~
_—
—_
=

a

—
as
~~
=
_
as
—

IS

ce

—~

ABOUT

THE

FONT

MANAGER

The Macintosh® Operating System uses two types of fonts: TrueType (outline) and bitmapped fonts. Both types of fonts produce text; they differ in the form in which they are
stored and the flexibility with which they change size and shape.
This section explains the terms used to refer to elements of both TrueType and bitmapped
fonts and the way in which the Font Manager measures fonts of either type. This section
also describes how the Font Manager changes both types of fonts from one point size to
another through a process called scaling. Lastly, it explains how the Font Manager renders
TrueType fonts in any point size.

Font

Terminology

The smallest element in any type of font is a character, which is a symbol that represents
the concept of, for example, a lowercase “‘b”, the number “2”, or the arithmetic operator “+”.
You cannot show a generic lowercase “‘b” on a display device; no matter how you might
decide to show the character, certain features of representation distinguish your lowercase “b”
from someone else’s lowercase “‘b”. What you actually see on a display device is a glyph,
the distinct visual representation of the character. One glyph can represent one character, such
as a lowercase “b”; more than one character, such as the “fi” ligature, which is two characters

but only one glyph; or a nonprinting character, such as the space character.

About the Font Manager

12-3

;

Inside Macintosh,

Volume

VI

Because there are two types of fonts, there are two types of glyphs. A bitmapped glyph
is a bitmap designed at a fixed point size for a particular display device, such as a monitor
or a printer. A font designer, having decided that a glyph should be so many pixels tall and
so rhany pixels wide, carefully chooses the pixels that create the finished glyph image or
bitmap. (A pixel is the smallest dot the screen can display. The resolution of a screenor
printer is measured in dots per inch or dpi.) The font stores the bitmapped glyph as a picture
for the display device.
An outline glyph is a model of how a glyph should look. A font designer uses lines and
curves, not pixels, to draw the glyph. The outline, a mathematical description of an outline
glyph, has no designated point size or display device characteristic (such as the size of a
pixel) attached to it. The Font Manager uses the outline as a pattern to create bitmaps at any
size for any display device.
Remember that a glyph is a representation of a character, and every glyph has some characteristics that distinguish it from the other glyphs that represent the same character: for example,
the shape of the oval, the design of the stem, whether or not the glyph has a serif. If all the
glyphs for a particular character set share the same characteristics, they form a typeface,
which is a distinctly designed collection of glyphs. Each typeface has its own name, such as
New York, Geneva, or Symbol. The same typeface can be used with different hardware,
such as a typesetting machine, monitor, or laser printer.
Certain stylized changes can be made to the look of a glyph. Font styles (in previous
volumes of Inside Macintosh called character styles) are variations in the appearance of a
typeface. Styles available on the Macintosh computer include plain, bold, italic, underline,
outline, shadow, condensed, and extended. QuickDraw can add stylistic variations such
as bold or italic to bitmaps, or a font designer can design a font in a specific style (for
instance, Courier Bold).

In previous volumes of /nside Macintosh, font refers to a complete set of glyphs in a particular typeface, size, and style. Courier plain 10-point, Courier bold 10-point, and Courier

plain 12-point, for example, are considered three different fonts. This definition still works

well for bitmapped fonts (of resource type 'FONT' or 'NFNT'). Manufacturers of bitmapped fonts design an individual bitmap for each glyph in each size and style. If the user
requests a font that is not available in a particular size, QuickDraw can alter a bitmapped font
at a different size to create the required glyphs. However, this generated bitmap often appears
to be slightly irregular in some way.

An outline font (of resource type 'sfnt') is a collection of outline glyphs in a particular
typeface and style with no size restriction. The Font Manager can generate thousands of
point sizes from the same TrueType font: a single outline Courier font can produce Courier
10-point, Courier 12-point, and Courier 200-point. Handles to font records, found in data
structures such as the global width table or the FMOutput record, point to fonts named by
the 'sfnt' resource, as well as to fonts named by the 'FONT' and 'NFNT' resources.
When there are two or more fonts of the same typeface (whether of different styles, point
sizes, or type—bitmapped or outline), the Font Manager groups them into font families
(of resource type 'FOND'). An outline plain font for Geneva and two bitmapped fonts for
Geneva plain 12-point and Geneva italic 12-point might make up one font family, to which a
user could subsequently add other sizes or styles.

12-4

About the Font Manager

The Font Manager

When you want to print or display a particular glyph, you need to refer directly to the
character that the glyph represents. The Font Manager accesses an individual character
by a character code—a hexadecimal number from $00 through $FF—and displays
the glyph for that character in the font of the current grafPort record.
Figure 12-1 shows the standard Roman character set. Characters that are highlighted in gray
are represented by the missing character glyph or are specific to the system font Chicago

(3,~,¢, and @). (A complete list of characters, character codes, and their PostScript® names

can be found in Appendix E.) The Font Manager uses the missing character glyph if a font
manufacturer does not include a particular character in a font. It is commonly represented on
the Macintosh computer by an empty rectangle, such as 0. A font manufacturer must include
the missing character glyph for a font. The Font Manager does not use the missing character
glyph for nonprinting characters, such as the space character, that are included in the
'FONT’, 'NFNT’, or 'sfnt' resource.

0O;1/;2;3/;4/5;/6;/7/8;/;/9}/A/BIC|D/E/F

O |nucipte] sP}O0|/@/P}"°

|pl/Aléltio-|z/-|F/¢

1 |scH
8)! )1/A/Q)al/q/Al/é]e]+]
; J—
O
2isxiV|/"/2/BiIR/bilr{iclile|<}]al*],]U
3 |ETx
#13/C/Silc/|siE]iJse;/z=/vi"7},
]0
4jeol/ @/S/4/D/TI
dit INI TIS |¥I FI] 1%] U
5 lenolnak}%/5/E/Ulelu/O;i
le }[ule=t’
{Adi
6 jackisyn} &/ 6 |/FIV\fivljUlA/G
| S{Al+/E] °
7 leectlers} ' |7/GIW/gi|wial/o{/BIlS|«]oO]}Al 7
8 iesican)

(|8/H|X]/h]|x]/alol@/Tl|»|/y

Q9/uriemM)/)

/9/I11Ylily/alo/O]x

A | LF {sup}

*

SIZIF

B ieless:

|<

(LIAN

[|

Tle

zl

|a]|6

21Alali|°

I]t

]ala

21Al<|

1

D|crics|-/=|]M/[]J}]m/|}}elal4/Q]/O]}]>]

i]

,

/K/

lam

Elsolr»rs|.|/>|N/]A}ln|~]é]a
F i|sijus] /

O|_|o

7

YTET *

k1{

C Wegies

+];

Sle

|e]

”

z|CE|
fi | O

jon/e@ |} |/Dlale|
fl} Oo] ~

Figure 12-1. The standard Roman

character set

About the Font Manager

12-5

Inside Macintosh,

Font

Volume V1

Measurements

Font designers have specific terms to describe parts of a glyph and parts of a font, whether
outline or bitmapped. Figure 12-2 labels some of these measurements.
Ascent line —

Bounding box —

Glyph origin i
Base line
Left-side bearing
Descent line —

:
i

Advance width

Figure

12-2.

Terms

for font measurements

Note: Fonts for script systems around the world use some of these measurements,
but the definitions given here are based on the characteristics of the Roman script
system, which uses fonts meant to be read left to right and is associated with most
European languages. There are different definitions for most of these terms for Asian,
Arabic, or other script systems.
Some of the measurements shown in Figure 12-2 apply to a single glyph. The bounding
box is the smallest rectangle that entirely encloses the pixels of the bitmap. The glyph
origin is where QuickDraw begins drawing the glyph. You may notice that there is some
white space between the glyph origin and the recognizable start of the glyph. The white
space that precedes the glyph is the left-side bearing. The advance width is the full
horizontal measurement of the glyph as measured from the glyph origin to wherever the
glyph stops, including the white space on both sides.
Some measurements apply to many glyphs. To begin with, most glyphs in a font appear to sit
on the base line, an imaginary horizontal line. The ascent line is an imaginary horizontal
line chosen by the font’s designer that corresponds approximately with the tops of the uppercase letters in the font, because these are generally the tallest commonly used glyphs in a font.
The ascent line is the same distance from the base line for all glyphs in the font. The descent
line is an imaginary horizontal line that usually corresponds with the bottoms of descenders
(the tails on glyphs like “p” or “g’”’), and it’s the same distance from the base line in every
glyph of the font. The ascent and descent lines are part of the font designer’s recommendations about line spacing as measured from base line to base line. (All of these lines are
horizontal because Roman text is read left to right, in a straight horizontal line. In some script
systems, these lines are vertical.)
12-6

About the

Font Manager

The Font Manager

For bitmapped fonts, the ascent line marks the maximum y-value and the descent line marks
the minimum y-value. For outline fonts, a font designer can create individual glyphs that
extend above the ascent line or below the descent line. The integral in Figure 12-3, for
example, is much taller than the uppercase ““M”’. In this case, the maximum y-value is more
important than the ascent line for determining the proper line spacing for a line containing
both of these glyphs. You can have the Font Manager reduce such oversized glyphs so that
they fit between the ascent and descent lines. See “Preserving the Glyph’s Shape” later in
this chapter for details.
MeXIGAUIN V-VAIUG

er

iT

set

eta

re

eR

rs
rashes meres

ees

ee

eg

IRE HS cere

—

nN

a
=
—

Base line -

a

—

=

=

&
ge
7)

bce

Figure 12-3. The ascent line and maximum y-value
Font size indicates the size of a font’s glyphs as measured from the base line of one line of
text to the base line of the next line of single-spaced text. In the United States, font size is
traditionally measured in points, and there are 72.27 points per inch. However, QuickDraw
and the PostScript language define | point to be % of an inch, so there are exactly 72 points
per inch. Previously, the Font Manager required fonts to be less than or equal to 127 points
in size, but this restriction no longer applies to any type of font. All bitmaps must fit on the
QuickDraw coordinate plane; on a 72 dpi display device, fonts have an upper size limit of
32,767 points. Point size is one of the characteristics inherent in a bitmapped font, because
the font’s designer must create the font at a fixed point size as well as in a specific typeface.
Leading is the amount of blank vertical space between the descent line of one line of text
in a font and the ascent line of the next line of single-spaced text in the same font. The

Font Manager returns this number, which is in pixels, in the FontMetrics or GetFontInfo

procedure for both TrueType and bitmapped fonts. You’ll note that this measurement is not in
Figure 12-2, because, although the font’s manufacturer has a recommended amount of
leading for a font, you can always change the amount if you need more or less space between
lines of text in your application. The line spacing for a font can be calculated by adding the
value of the leading and the distance from the ascent line to the descent line.

About the Font Manager

12-7

Inside Macintosh, Volume V1

Font

Scaling

Font scaling is the process of changing a glyph from one size or shape to another. The
Font Manager can scale bitmapped and TrueType fonts in three ways: changing a glyph’s
point size on the same display device, modifying the glyph but keeping the point size
constant when using a different display device, and altering the shape of the glyph.
The simplest form of scaling occurs when the Font Manager changes a glyph from one point
size to another on the same display device. If the glyph is bitmapped and the requested font
size is not available, there are certain rules the Font Manager follows to create a new bitmapped
glyph from an existing one; these rules are discussed in the Font Manager chapter of Volume I.
If the glyph is an outline glyph, the Font Manager uses the original outline for that glyph to
create a new bitmap at a different size. In Figure 12-4, the Font Manager scales a TrueType
font and a bitmapped font from 9 points to 40 points for screen display. The bitmaps available
to the Font Manager to create all 32 point sizes were 9, 10, 12, 14, 18, and 24 points. A single
TrueType outline produces a smoother bitmap in all point sizes.
TrueType screen font scaled from 9 points to 40 points

waadddddddddddddddddddddddddd |
Bitmapped screen font scaled from 9 points to 40 points

weet ddddddddddddddddddddddddd

|

Figure 12-4. A comparison of scaled TrueType and bitmapped fonts
The Font Manager also scales a glyph when moving it from one device to another device with
a different resolution: for instance, from the screen to a printer. A bitmap that is 72 pixels
high on a 72 dpi screen measures one inch, but on a 144 dpi printer it measures a half inch.
In order to produce a figure the same size as the original screen bitmap, the Font Manager
needs a bitmap twice the size of the original. If there are no bitmaps available in twice the
point size of the bitmap that appears on the screen, QuickDraw scales the original bitmap to
twice its original size in order to print it on the printer.
Your application can scale a glyph by stretching or shrinking it, which changes the glyph from
a familiar point size to something a little stranger—for example, a glyph that is 12 points high
but as wide as a whole page of text. Your application tells the Font Manager how to scale a
glyph using font scaling factors, which are represented as proportions or fractions that indicate
how the Font Manager should scale the glyph in the vertical and horizontal directions. The
ratio given by the font scaling factors determines whether the glyph grows or shrinks; if the
ratio is greater than one, the glyph increases in size, and if it is less than one, the glyph
decreases in size. If the font scaling factors are 1-to-1 (1/1) for both horizontal and vertical
scaling, the glyph does not change size.

12-8

About the Font Manager

The Font Manager

In Figure 12-5, the font scaling factors are 2/1 in the horizontal direction and 1/1 in the
vertical direction. The glyph stays the same height, but grows twice as large in width.

2x

Figure 12-5. A glyph stretched horizontally
In Figure 12-6, the font scaling factors are 2/1 in the vertical direction and 1/1 in
the horizontal direction. The glyph stays the same width, but grows to twice its
original height.

—

i)
Le |

S—

vee

—

a—

pe)
—_
—

2
ti

2°)
“

Figure 12-6. A glyph stretched vertically
In Figure 12-7, the font scaling factors are 1/1 in the vertical direction and 1/2 in the
horizontal direction. The glyph stays the same height but retains only half its width.

1/2x
Figure 12-7. A glyph condensed horizontally
If the font scaling factors are 2/2 in both directions, QuickDraw draws the glyph at a point
size twice that of the original. In the case of bitmapped fonts, QuickDraw first looks for a
bitmap at twice the size of the original before redrawing the glyph at the new point size.
The Font Manager produces better results by scaling TrueType glyphs, because it changes the
font’s original outline to the new size or shape, and then makes the bitmap. Outlines give
better results than bitmaps when scaled, because the outlines are intended for use at all point
sizes, whereas the bitmaps are not.

About the Font Manager

12-9

Inside Macintosh,

How

the

Volume VI

Font

Manager

Renders

TrueType

Fonts

TrueType fonts are stored as a collection of outline points. (Don’t confuse these outline
points with the points that determine point size, or the Point data type, which specifies a place
on the QuickDraw coordinate plane.) The Font Manager draws lines and curves between the

points, sets the bits that make the bitmap, and then displays the bitmap on the screen.

There are two types of outline points: on-curve points define the endpoints of lines, and offcurve points determine the curve of the line between the on-curve points. Two consecutive
on-curve points define a straight line. If you want to draw a curve, you need a third point that
is off the curve and between the two on-curve points.
The Font Manager uses this parametric Bézier equation to draw the curves of the outline glyph:
F(t) =(1-t)2*A+2t(1-)*B+t2*C
where t ranges between 0 and | as the curve moves from point A to point C. A and C are oncurve points; B is an off-curve point.

ow

ow

Figure 12-8 shows two Bézier curves. The positions of on-curve points A and C remain
constant, while off-curve point B shifts. The curve changes in relation to the position of
point B.

@= on-curve point
O=

off-curve point

Figure 12-8. The effect of an off-curve point on two Bézier curves

12-10

About the Font Manager

The Font Manager

A font designer can use any quantity of outline points to create a TrueType outline. These
points must be numbered in a logical order, because the Font Manager draws lines and
curves sequentially. This process produces a glyph such as the lowercase “‘b” in
Figure 12-9,
17

0

—

i)
le 5)

cS
~
~
—

=
_—

x
a

—_

=
tj=)

o
Ler |

® = on-curve point

O = off-curve point

Figure 12-9. An outline with points on and off the curve
There are several groups of points in Figure 12-9 that include two consecutive off-curve
points. For instance, points 2 and 3 are both off-curve. In this case, the Font Manager places
an on-curve point midway between the two off-curve points, thereby defining two Bézier
curves, as shown in Figure 12-10. Note that this additional on-curve point is for creation of
the outline glyph only; the Font Manager does not alter the 'sfnt' resource’s list of points.

About the Font Manager

12-11

Inside Macintosh,

Volume VI

™= on-curve point
O = off-curve point

A

Figure 12-10. A curve with consecutive off-curve points
When the Font Manager has completed drawing a closed loop, it has completed one
contour of the outline. The font designer groups the points in the 'sfnt' resource into

contours. In Figure 12-9, the Font Manager draws the first contour in the outline

glyph from point 0 to point 17, and the second contour from point 18 to the end, creating
the glyph in Figure 12-11.

Contour 1
(outside)
Contour 2

(inside)

Figure

12-12

About the Font Manager

12-11.

An

outline glyph

The Font Manager

At this stage, the outline glyph does not have a fixed point size. Remember that point size is
measured as the distance from the base line of one line of text to the base line of the next line
of single-spaced text. Because the Font Manager has the measurements relative to the base
line and ascent line for the outline and the intended point size, it can correlate the two and
calculate how large the outline should be for that point size.
The Macintosh computer’s display screen is a grid made of pixels. The Font Manager fits the
outline glyph, scaled for the correct size, to this grid. If the center of one section of this
grid—comparable to a pixel or a printer dot—falls on a contour or within two contours, the
Font Manager sets this bit for the bitmap.
The Font Manager uses the contours as the boundaries for deciding which bits make up the
bitmap for this outline glyph when it is displayed. Because there are two contours for the
glyph in Figure 12-11, the Font Manager begins with pixels at the boundary marked by
contour | and stops when it gets to contour 2. Some glyphs need only one contour, such as
the uppercase “IT” in some fonts. Others have three or more contours, such as the 49 glyph

from ITC Zapf Dingbats®.

If the pixels are tiny in proportion to the outline (when resolution is high or the point size of
the glyph is large), they fill out the outline smoothly, and any pixels that jut out from the
contours are not noticeable. If the display device has a lower resolution or the point size is
small, the pixels are large in relation to the outline. You can see in Figure 12-12 that the
outline has produced an unattractive bitmap because the centers of some pixels fall on the
wrong side of the contours, producing gaps and blocky areas that would not be found in
the high-resolution versions of the same glyph.

—

nN
3]
—)
—}
_—

<$9

=
tt]
j=)

ao)
Ler |

Figure 12-12. An unmodified outline glyph at a small point size

About the

Font Manager

—-12-13

Inside Macintosh,

Volume VI

The pixels of the display device cannot change, so the outline should adapt in order to
produce a better bitmap. A font manufacturer must include instructions in the 'sfnt'
resource that indicate how to change the shape of the outline under various conditions,
such as low resolution or small point size. The lowercase “b” outline in Figure 12-13 is
the same one depicted in Figure 12-12, except that the Font Manager has applied the
instructions to the figure and produced a better bitmapped glyph. (These instructions are
to the effect of “move these points here” or “change the angle formed by these points.”
General-purpose applications do not need to use instructions; however, if you want to know
more about them, order the TrueType Font Format Specification book from APDA.)

Figure 12-13.

An instructed outline glyph

Once the Font Manager has produced the outline according to the design and instructions, it
turns on the pixels and draws the bitmap on the screen. It then saves the bitmapped glyph in
memory and uses it whenever the user requests this glyph in this font at this point size.

USING

THE

FONT

MANAGER

This section describes how you can use fonts in general and TrueType fonts specifically. There
are certain guidelines you should consider when integrating fonts into your application—for
instance, how to show which point size is currently selected and how to make sure that the font
used in a document is the same on different computer systems. If you want to take best
advantage of TrueType fonts, your application should be aware of how TrueType glyphs may
behave differently than bitmapped glyphs.
To determine whether your application can use TrueType fonts on a user’s computer system,
call the Gestalt function with the selector gestaltFontMgrAttr. If the Gestalt function returns
noErr and bit 0 of the response (gestaltOutlineFonts) is 1, outline fonts are present in the
system software. (See the Compatibility Guidelines chapter in this volume for more
information on the Gestalt function.)

12-14

— Using the Font Manager

The Font Manager

Adding

Font Sizes and Names

to the Menu

Here are some things you should do to accommodate the new font sizes:
= Support all font sizes. The 127-point size limit no longer exists for outline or bitmapped
fonts and should be removed from your application. The maximum point size on the
QuickDraw coordinate plane is 32,767 points.

m Provide a small list of the most useful point sizes. For the menu where your application
displays font sizes, you shouldn’t predefine a static list of sizes available to the user or
allow the default to be every possible font size, because outline fonts can produce
thousands of sizes.
= Provide a method of increasing or decreasing the point size by one point at a time. You
can add a Larger or Smaller command, which makes choosing slightly different sizes
for outline fonts easier for the user. Also, the user should be able to choose any possible
point size at any time in a simple manner.
m Place a check next to the active size. This is how most applications now indicate the
active size.
m Display available font sizes in outline style. With bitmapped fonts, the RealFont function returns TRUE if the font is available in that point size and FALSE if the font is not.
However, be careful with outline fonts. The font’s designer may decide that there is a
lower limit to the point sizes at which the font looks acceptable. The RealFont function
returns FALSE for an outline font if the size requested is smaller than this lower value.
Figure 12-14 shows one possible method of doing these things.

9

Font Size:

10

12
19
-

A}

.
The quick
brown fox

smaller
L

os
Figure 12-14.

A sample Size menu and font size dialog box

Use the AddResMenu procedure to create a menu that displays font names. The AddResMenu
procedure ensures that any changes to the Font Manager do not affect your application and
the menu that displays font names is not dependent on how fonts are stored in your system
software. The AddResMenu procedure is documented in the Menu Manager chapter of
Volume I.

Using the

Font Manager

—- 12-15

bom
nN
es) 4
—)
|
as

<

pe)
a
pt]
ga
a")
sae

Inside Macintosh, Volume VI

Storing a Font Name

in a Document

One problem with identifying fonts by font family ID rather than by name is the plethora of
font families for the Macintosh. Many share the same font family ID, and even though the
font the user wants is present in the System file, another font with the same ID may appear in
a font menu. Another problem is that one font family may have different IDs on different
computer systems, so that when the application opens the document using this font family on
a different computer system, it can’t find the proper font, even though it is there, and
substitutes another.
If you’ve stored the name of the font in the document, you can find its font family ID by
calling GetFNum (documented in the Font Manager chapter of Volume I). However, if the
font isn’t present in the system software where the user opens the document, GetFNum
returns 0 for the ID. Zero is also, you may remember, the system font ID. In this case you
need to double-check the name of the font from the document against the name of the system
font, as illustrated in Listing 12-1.
Listing 12-1. Checking a font family ID against the font name
FUNCTION

GetFontNumber(fontName:

{GetFontNumber
{

with

the

returns

in

font

name.

given

the

Str255;

fontNum
If

VAR

fontNum:

parameter

there’s

Integer)

the

number

such

font,

it

it

the

system

no

:

for

Boolean;

the

returns

font

FALSE. }

VAR

systemFontName:

Str255;

BEGIN

GetFNum(fontName,
fontNum);
IF fontNum
= 0 THEN
BEGIN

{Either

the

font

GetFontName(0,
GetFontNumber

was

not

found,

or

systemFontName) ;
:= EqualString(fontName,

is

font.}

systemFontName,

FALSE,

FALSE) ;
END

ELSE

{If

theNum

was

GetFontNumber

not
:=

0,

the

font

is

available.}

TRUE;

END;

Storing a font’s name rather than its font family ID is a more reliable method of finding a
font, because the name, unlike the font family ID, does not change from one computer
system to another. You may also want to store the checksum of a font with its name, to be
sure that the version of the font is the same on different computer systems.

Using

TrueType

Fonts

in Preference

to Bitmapped

Fonts

If a document uses a font that is available as both a TrueType font and a bitmapped font, the
default behavior of the Font Manager is to use the bitmapped font when your application
opens the document. This default avoids problems with documents that were created on a
computer system on which TrueType fonts were not available.
12-16

Using the Font Manager

}

The Font Manager

You can use the SetOutlinePreferred procedure to choose which type of font the Font Manager
should use in a document. If you call SetOutlinePreferred with TRUE as the value of the
outlinePreferred parameter, the Font Manager chooses TrueType fonts over bitmapped fonts.
The GetOutlinePreferred function returns the setting that indicates whether the Font Manager
prefers TrueType fonts, and you should save the setting with the current document. When the
user opens the document, call SetOutlinePreferred with this value so that your application
chooses the proper fonts.
If only one type of font is available, the Font Manager chooses that type of font to use in the

document, no matter which type of font is preferred.

Preserving

the Glyph’s

Shape

Most glyphs in an alphabetic font fit between the ascent line and the descent line, which roughly
mark (respectively) the tops of the uppercase letters and the bottoms of the descenders. One aim
of outline fonts is to provide glyphs that are more accurate renditions of the original typeface
design, and there are glyphs in some typefaces that exceed the ascent or descent line (or both).
An example of this type of glyph is an uppercase letter with an accent on it: “N” with a tilde
produces “N”’. Your application should preserve the original shape of a glyph, because many
languages use glyphs that extend beyond the ascent line or descent line.
However, these glyphs may disturb the line spacing in a line or a paragraph. The glyph that

exceeds the ascent line on one line may cross the descent line of the line above it, where it

may overwrite a glyph that has a descender. You can determine if there are outline glyphs that
exceed the ascent and descent lines by using the OutlineMetrics function. OutlineMetrics
returns the maximum and minimum y-values for whatever glyphs you choose. You can get
the values of the ascent and descent lines using the GetFontInfo function or FontMetrics
function. If a glyph’s maximum or minimum y-values are greater than, respectively, the
ascent or descent lines, you can opt for one of two paths of action: you can change the height
of the glyph, or you can change the line spacing to accommodate the glyph.
The Font Manager’s default behavior is to change the height of the glyph, so as to provide
compatibility with bitmapped fonts, which are scaled between the ascent and descent lines.
Figure 12-15 shows the difference between an “N” scaled to fit in the same amount of space
as an “N” and another, well-formed “N”. The tilde on the preserved “N” clearly exceeds the
ascent line.

ou

Preserved glyph

NN
N

N

Figure 12-15. The difference between a scaled glyph and a preserved glyph

Using the

Font Manager

——-:12-17

Inside Macintosh,

Volume

VI

You can use the SetPreserveGlyph procedure to preserve the original shape of the glyph. If
you call SetPreserveGlyph with TRUE as the value of the preserveGlyph parameter, the Font
Manager keeps the shape of the glyph intended by the font’s designer. The GetPreserveGlyph
function returns a setting that indicates whether the Font Manager maintains the form of
TrueType glyphs, and you should save the setting with the current document. When the user
opens the document, call SetPreserveGlyph with this value so that the Font Manager scales the
glyphs appropriately.

FONT

MANAGER

ROUTINES

The Font Manager has routines that deal specifically with TrueType fonts. You can use these
routines to choose TrueType fonts over bitmapped fonts, or to determine which type of font
the current grafPort record uses. You can find out the exact measurements of a TrueType
glyph. If the size of a TrueType glyph interferes with the line spacing in a document, you can
use the Font Manager to scale the glyph to the same size as other glyphs on the line. If your
application is a font editor or otherwise needs to manipulate the 'sfnt' resource, you may need
a routine to erase the Font Manager’s memory caches.

Choosing

TrueType

Fonts

Over

Bitmapped

Fonts

You can use the SetOutlinePreferred, GetOutlinePreferred, and IsOutline routines to use

‘Truel’ype fonts instead of bitmapped fonts when both are available or to determine which
type of font is being used in a document.
You can use the SetOutlinePreferred procedure to cause the Font Manager to prefer TrueType
fonts over bitmapped fonts.
PROCEDURE

SetOutlinePreferred

(outlinePreferred:

Boolean);

If a TrueType font and a bitmapped font are available for a font request, the default behavior
for the Font Manager is to choose the bitmapped font, in order to maintain compatibility with
documents that were created on computer systems on which TrueType fonts were not
available. The SetOutlinePreferred procedure sets the preference of which type of font to use
in this situation.
If you want the Font Manager to choose outline fonts over any bitmapped font counterparts,
set the outlinePreferred parameter to TRUE. If only outline fonts are available and
outlinePreferred is set to FALSE, the outline font is chosen regardless. If only bitmapped
fonts are available and outlinePreferred is set to TRUE, the bitmapped font is still chosen.
You can use the GetOutlinePreferred function to determine whether or not TrueType fonts are
preferred over bitmapped fonts.
FUNCTION

12-18

GetOutlinePreferred

— Font Manager Routines

:

Boolean;

The Font Manager

If both types of fonts are available for a particular font request, the GetOutlinePreferred
function returns a Boolean value indicating whether the Font Manager chooses TrueType
fonts over bitmapped fonts. By default, the Font Manager prefers to use bitmapped fonts,
for which the GetOutlinePreferred function returns FALSE; you can also set the behavior

of the Font Manager with the SetOutlinePreferred procedure.

You can use the IsOutline function to find out whether the current grafPort uses a
TrueType font.
FUNCTION

IsOutline

(numer:

Point;

denom:

Point)

:

Boolean;

The IsOutline function returns TRUE if the Font Manager, after applying the font scaling
factors in the numer and denom parameters to the font named by the current grafPort, would
choose an outline font for the grafPort. The current setting of whether TrueType or bitmapped
fonts are preferred may also affect what IsOutline returns. Use the GetOutlinePreferred
function to find out what the current setting is.
The numer and denom parameters are of type Point, and each contains two integers—the first
is the numerator or denominator of the ratio for vertical scaling; the second is the numerator

or denominator of the ratio for horizontal scaling. The Font Manager applies the font scaling
factors to the font used in the current grafPort in order to calculate the measurements for the
glyphs in the block of text.

meal

i)

3

i=)
~
—

Kd
—
©

Scaling

=)
ey)

Fonts

we

7)
Len

You can use the OutlineMetrics function to determine the measurements, such as heights or

advance widths, of the glyphs in any line of text you choose. On the basis of these measurements, you can decide whether to use SetPreserveGlyph to keep the original sizes of the
glyphs. The GetPreserveGlyph function tells you whether the glyphs in the current grafPort
record are scaled.
FUNCTION

OutlineMetrics

(byteCount:

Integer;

denom:
Point;
VAR
Integer;
awArray:
boundsArray:

textPtr:

Ptr;

numer:

Point;

yMax:
Integer;
VAR yMin:
FixedPtr;
lsbArray:
FixedPtr;

RectPtr)

:

OSErr;

The OutlineMetrics function takes a block of text you provide and returns the maximum
y-value, minimum y-value, advance widths, left-side bearings, and bounding boxes for this
text only in the current font, point size, and font style. (For definitions of these terms, see
‘Font Measurements” earlier in this chapter.) You can use these measurements when laying
out text. You may need to adjust line spacing to accommodate exceptionally large glyphs.
OutlineMetrics works on TrueType fonts only.
Parameter

descriptions

byteCount

The number of bytes on which you want the OutlineMetrics function
to work.

textPtr

The pointer to the block of text you are providing to OutlineMetrics.

Font Manager Routines

= 12-19

Inside Macintosh,

Volume VI

numer

The numerators of the vertical and horizontal scaling factors. The
numer parameter is of type Point, and contains two integers—the
first is the numerator of the ratio for vertical scaling; the second is
the numerator of the ratio for horizontal scaling. The Font Manager
applies the font scaling factors to the font used in the current grafPort
in order to calculate the measurements for the glyphs in the block
of text.

denom

The denominators of the vertical and horizontal scaling factors. The
denom parameter is of type Point, and contains two integers—the first
is the denominator of the ratio for vertical scaling; the second is the
denominator of the ratio for horizontal scaling. The Font Manager
applies the font scaling factors to the font used in the current grafPort
in order to calculate the measurements for the glyphs in the block:
of text.

yMax

The maximum y-value for the text. Pass NULL in this parameter if
you don’t want this value returned.

yMin

The minimum y-value for the text. Pass NULL in this parameter if you
don’t want this value returned.

awArray

A pointer to an array of the advance width measurements for the
glyphs being considered. These measurements are in pixels, based on
the point size and font scaling factors of the font used by the current
grafPort record. The number of entries in the array is given by the
byteCount parameter.
The awArray parameter is of type FixedPtr. The FixedPtr data type is
a pointer to an array, and each entry in the array is of type Fixed,
which is 4 bytes in length. Multiply byteCount by 4 to calculate the
memory you need in bytes. Allocate the memory needed for the array
and pass a pointer to the array in the awArray parameter.
If the FractEnable global variable has been set to TRUE using the
SetFractEnable procedure, the values in awArray have fractional
character widths. If FractEnable has been set to FALSE, the Font
Manager returns integers for the advance widths, with 0 in the decimal
part of the values. The SetFractEnable procedure is discussed in the
Font Manager chapter of Volume IV.
Pass a NIL in this parameter if you don’t want the advance width
values returned.

IsbArray

A pointer to an array of the left-side bearing measurements for the
glyphs being considered. The measurements are in pixels, based on
the point size of the font used by the current grafPort record. The
number of entries in the array is given by the byteCount parameter.
The IsbArray parameter is of type FixedPtr. The FixedPtr data type is
a pointer to an array, and each entry in the array is of type Fixed,
which is 4 bytes in length. Multiply byteCount by 4 to calculate the
memory you need in bytes. Allocate the memory needed for the array
and pass a pointer to the array in the IsbArray parameter. The left-side
bearing values are never rounded.
Pass a NIL in this parameter if you don’t want the left-side bearing
values returned.

12-20

Font Manager Routines

The Font Manager

boundsArray

A pointer to the array of bounding boxes for the glyphs being
considered. Bounding boxes are the smallest rectangles that fit around
the pixels of the glyph. The bounding box measurements returned by
OutlineMetrics may be slightly larger than the those for the actual
glyph. The number of entries in the array is given by the byteCount
parameter.
The boundsArray parameter is of type RectPtr. The RectPtr data type
is a pointer to QuickDraw’s Rect data type, which is 8 bytes in length.
Multiply byteCount by 8 to calculate the memory you need in bytes.
Allocate the memory needed for the array and pass a pointer to the
array in the boundsArray parameter.
Pass a NIL in this parameter if you don’t want the bounding box
values returned.

The SetPreserveGlyph procedure tells the Font Manager whether to preserve the original
shape of an outline glyph, which in some cases may exceed the ascent or descent lines.
PROCEDURE

SetPreserveGlyph

(preserveGlyph:

Boolean) ;

—

nN

The default behavior for the Font Manager is to scale a glyph so that it fits between the ascent
and descent lines; however, this alters the look of the glyph. If you set the preserveGlyph
parameter in the SetPreserveGlyph procedure to TRUE, the measurements of all glyphs are
preserved, and your application may have to alter the leading between lines in a document if
some of these glyphs extend beyond the ascent or descent lines. If you set preserveGlyph to
FALSE, all glyphs are scaled to fit between the ascent and descent lines.
Save the setting of whether glyphs are preserved or not and call SetPreserveGlyph with this
value as the parameter every time the user opens the application.
The GetPreserveGlyph function returns a Boolean value indicating whether the Font Manager
preserves the shape of TrueType glyphs, which by default is FALSE. Your application can
set the behavior of the Font Manager using the SetPreserveGlyph procedure.
FUNCTION

Erasing

GetPreserveGlyph

the Font

:

Boolean;

Manager’s

Memory

Caches

You can use the FlushFonts function to clear the Font Manager’s memory.
FUNCTION

FlushFonts

:

OSErr;

The FlushFonts function erases all of the Font Manager’s memory caches. Your application doesn’t need this function unless it directly manipulates data in the 'sfnt' resource.
Font Manager caches include the width tables, the bitmaps created from the outlines of the
'sfnt' resource, the outlines, and a small cache of 'FOND' resources that have been read
into memory.

Font Manager Routines

— 12-21

le 5)4
Fan)
=
—
a
—_

K<
—
&

=
a

ge
co
“

Inside Macintosh,

SUMMARY

Volume VI

OF

THE

FONT

MANAGER

Constants
CONST

gestaltFontMgrAttr

=

‘Pont! 3

{Gestalt

selector}

gestaltOutlineFonts

=

0;

{TRUE

outline

if

fonts

are

present}

{

Routines

Choosing
PROCEDURE

TrueType

Fonts

SetOutlinePreferred

Over

(outlinePreferred:

FUNCTION

GetOutlinePreferred

:

FUNCTION

IsOutline

(numer:

Scaling

Fonts

FUNCTION

OutlineMetrics

FUNCTION

Get PreserveGlyph

Erasing

the Font

FUNCTION

12-22

FlushFonts

Point;

(byteCount:

SetPreserveGlyph

Integer;

VAR

FixedPtr;
RectPtr)

:

denom:
yMin:

lsbArray:
OSErr;

Point)

textPtr:

Point;
Integer;
FixedPtr;

Boolean);

Boolean;

Manager’s
:

Boolean) ;

denom:

Integer;

Point;

(preserveGlyph:

:

Fonts

Boolean;

numer:

PROCEDURE

Bitmapped

OSErr:;

Summary of the Font Manager

Memory

Caches

:

Boolean;

Ptr;

VAR

yMax:

awArray:
boundsArray:

}

THE

RESOURCE

MANAGER

About This Chapter
Resources
Resource Types
Resource IDs
Definition Procedures
Font Families and Scripts
Resources in the System File
System Icons
Document and Application Icons
Folder Icons
System Folder Icons
Desktop Icons
Standard File Package Icons
User Information Resources
Packages
Function Key Resources
Using the Resource Manager
Using Partial Resources
Creating and Opening Resource Files
Storing Fonts in a Resource Fork
Resource Manager Routines
Creating Resource Files
Opening Resource Files
Reading and Writing Partial Resources
Summary of the Resource Manager

et

Ge

Leig")
eZ)

=
&
“t
©
@

<

~
=
i)
ge
oe
Lew

13-1

|

Inside Macintosh,

13-2

Volume VI

The Resource Manager

ABOUT

THIS

CHAPTER

This chapter describes changes to the Resource Manager, the resource types that are available
for your application’s use, and the new technique for reading or writing part of a resource
instead of an entire resource. This chapter also lists the standard resource types found in the
System file in system software version 7.0.
The ability to use partial resources is available only in version 7.0. To check for the existence
of the new partial resource routines, use the Gestalt function.

You need the information in this chapter if you want your application to take advantage of
partial resources or to create or open resource files. This chapter also provides resource ID
ranges for definition procedures, font families, and scripts, and it lists the system icons and
packages that are available in system software version 7.0.
The information in this chapter supplements chapters on the Resource Manager in Volumes I,
IV, and V.

RESOURCES
—

A resource consists of data or code stored in a resource file. A resource fork is the part of a
file that contains data used by an application, such as menus, fonts, and icons. An executable
file’s code is also stored in the resource fork. The Resource Manager distinguishes resources
by their resource types and resource IDs. The resource type is always a sequence of four
alphanumeric characters (including the space character). For instance, 'MENU' is the resource
type for a menu. A resource ID is a number that, together with the resource type, uniquely
identifies a particular resource. Resources can be created from textual descriptions by resource
compilers, such as the Rez compiler in the Macintosh Programmer’s Workshop (MPW®).
Note: Your application should not depend on any specific resource being in ROM or
in the System file. The resource types available in ROM vary. A resource that is
in ROM may not be available because the System file may override any resource in
ROM, making it unavailable or replacing it with a resource from the System file.

Resource

Types

A resource type can be any sequence of four alphanumeric characters, including the space
character. You can create resource types for your applications, provided the type names you
choose consist of all uppercase letters and do not conflict with the resource types already
created. Apple Computer, Inc., reserves any other combination. (The standard Roman
character set can be found in the Font Manager chapter of this volume.)

Resources

13-3

Se

~
onN
=

=

=
O
oe

<

—

£5

=

is

$a

ic)
~

-

Inside Macintosh,

Volume VI

The System file contains system resources, the standard resources for the Macintosh®
computer that are shared by all applications. Table 13-1 lists all the resource types in the
System file that your application can use. Uppercase resource types are listed first.
Table

13-1.

Resource types available for your application’s use

Resource
type

Description

'ADBS'

Apple Desktop Bus™ service routine

‘'ALRT'
'BNDL'
'CDEF'
‘CNT!
‘CODE’
'CURS'
'DITL’
‘DLOG'
‘DRVR'
'FKEY'
'"FOND'
'FONT'
"FREF'
'ICN#'
'ICON'
INIT"
'KCAP'
'KCHR'
'LDEF'
‘MBAR'
'MDEF'
'MENU'
'NFNT'
‘PACK’
‘PAT '
'"PAT#'

Alert box template
Bundle
Control definition function
Control template
Application code segment
Cursor
Item list in a dialog or alert box
Dialog box template
Desk accessory or other device driver
Command-Shift-number combination
Font family record
Bitmapped font
File reference
List of 32-by-32 pixel (large) black-and-white icons, with mask
Icon
System extension
Physical keyboard description (used by Key Caps desk accessory)
Keyboard layout (software); maps virtual keycodes to character codes
List definition procedure
Menu bar
Menu definition procedure
Menu
Bitmapped font
Package
Pattern
Pattern list

'"PREC'
'SICN'
'SIZE'
‘STR '
'STR#'
"W DEF'
"WIND'
‘actb'
‘alis’
‘card’
‘ectb'
‘cicn'
‘clut'
‘ersr'
‘detb'

Print record
16-by-16 pixel (small) icon and mask
Size of application’s partition and other information
String
String list
Window definition function
Window template
Alert box color table
Alias record
Video card name
Control color table
Color icon
Color look-up table
Color cursor
Dialog box color table

‘PICT’
'POST'

13-4

QuickDraw™ picture
PostScript® resource

Resources

The Resource Manager

Table

13-1.

Resource types available for your application’s use (Continued)

Resource
type

Description

‘ddev'
‘eadr'
‘fetb'
‘hdl g'
‘hfdr'
‘hmnu'

Database extension
Ethernet hardware address
Font color table
Help for dialog box or alert box items
Help for application icons
Help for application menus

‘hret’
‘hwin'
‘icl4'
‘icl8'

Help for areas in windows
Association of ‘hret' and 'hdlg' resources to specific windows
Large icon, 4-bit color
Large icon, 8-bit color

‘hovr'

'ics#'

‘ics4'
‘ics8'
‘ictb’
‘jU10'
"VU"
tz"
‘tl4'
‘itlk'

Help that overrides Finder™ help

List of 16-by-16 pixel (small) black-and-white icons, with mask

'kes#'

Small icon, 4-bit color
Small icon, 8-bit color
Color table dialog item
Date and time formats
Names of days and months
International Utilities Package sort hooks
Localizable tables and code
Remappings of certain key combinations before KeyTrans function is
called for the corresponding 'KCHR' resource
List of small black-and-white icons, with mask, for a corresponding

a
we
7

‘kcs4'
‘kcs8'

Small icon, 4-bit color, for a corresponding 'KCHR' resource
Small icon, 8-bit color, for a corresponding 'KCHR' resource

=
6

‘metb'
‘mntr'

‘pitt’

‘ppat’
‘qdef'
‘qrsc'
‘sect
‘sfnt’
‘snd '
‘snth'
'Sysz'
'vers'
‘wctb'
‘wstr'

"KCHR'

resource

£

Menu color information table

=

Monitors control panel

=

Color palette

Te

Pixel pattern
Query definition function
Query resource
Section record
Outline font
Sound
Synthesizer or modifier
System heap space required by a system extension
Version number of the system software
Window color table
String (uses word for length byte)

2

Table 13-2 lists resource types that are reserved for the Operating System’s use only. These
resource types consist entirely of uppercase letters or combinations of uppercase and lowercase letters and the number sign (#). Other resource types specific to the Operating System
that consist entirely of lowercase letters or other characters are not included in Table 13-2.
This list is provided for your information; you should not use these resource types in your
application.

Resources

13-5

Inside Macintosh,

Table

13-2.

Volume

VI

Resource types reserved for the Operating System’s use

Resource
type

Description

‘CACH'
'DSAT'
‘"FCMT'
‘"FMTR'
"FOBJ'
"FRSV'

RAM cache code
System startup alert table
“Get Info” comments
3.5-inch disk formatting code
Folder information for an MFS volume
IDs of system fonts

'KMAP'
‘KS WP'
'MBDF'
'MMAP'

Keyboard mapping (hardware); maps raw keycodes to virtual keycodes
Defines special key combinations for Script Manager operations
Default menu definition procedure
Mouse-tracking code

‘PDEF'
'"PTCH'
'"ROv#'
'ROvr'
'SERD'

Printing code
ROM patch code
List of ROM resources to override
Code for overriding ROM resources
RAM Serial Driver

Resource

IDs

INTL’

International resource (obsolete)

'NBPC'

AppleTalk® bundle

To prevent conflicts, the IDs for resources used by the Operating System and those used
by applications are assigned from separate ranges. If you use these ranges correctly, your
application’s resources are guaranteed not to conflict with system resources and to be
compatible with future system resources.
System resources use IDs in the range —32768 through 127, and application resource IDs
must fall between 128 and 32767. Some categories of resources, such as definition procedures and font families, have different ID ranges available or are broken down into structured
ranges. This list shows a breakdown of the ID ranges used for most resources.
Range

Description

—32768 through —16385

Reserved; do not use. Any application resource whose ID is
in this range will not work properly in current versions of
system software.

—16384 through 4065

Used for system resources owned by other system
resources.

—4064 through -4033

Reserved for use by control panels.
chapter in Volume V.)

—4032 through —|]

Used for system resources owned by other system resources.
The exception is the 'SIZE' resource, whose ID is always —1.

13-6

Resources

(See the Control Panels

The Resource Manager

Range

Description

0 through 127

Used for system resources and any definition procedures in
the system software. Applications should not use these
resource IDs.

128 through 32767

Available for your use. Your application’s definition procedures should use IDs in the range 128 through 4095,
although other resources may use these IDs as well. Font
families and scripts have additional restrictions defined in
‘Font Families and Scripts” later in this chapter.

Definition

Procedures

Definition procedures (which are usually contained in resources such as the 'WDEF' or
'CDEF' resources) have an ID range limited to 12 bits (0 through 4095). The system

software’s own definition procedures, which are located in the System file, have resource
IDs from 0 through 127. Your definition procedures should have IDs in the range 128
through 4095.

Font

Families and

Scripts

A font family is a set of fonts in one typeface design, including different font styles and
sizes in that typeface. For example, the Geneva font family may include an outline font in
plain style and bitmapped fonts in various point sizes and in italic, bold, shadow, or other
styles. (For more information about outline and bitmapped fonts, see the Font Manager

to

7)
~
is")
eZ)

chapter in this volume.)

i)
=

At present a font family is exclusively identified by the 'FOND' resource. This resource
groups fonts using a font association table, which contains a word to hold each font’s point
size, a word for its style, and a word for its associated 'FONT"', 'NFNT", or 'sfnt' resource
ID. (If the size entry in the table is 0, the resource ID is for an 'sfnt' resource. System soft-

ware version 7.0 does not recognize a 'FONT" or 'NFNT' resource with its size set to 0, and
your application should not depend on finding these resources.) For font family resources,
Apple reserves resource IDs 0 through 1023 and 16000 through 16383. (The font association
table is described in the Font Manager chapter of Volume IV.)
Note: When the Macintosh computer was first introduced, prior to the introduction
of the 'FOND' resource, fonts were grouped into font families by storing the family
ID in bits 7 through 14 of the font’s resource ID. (The font’s point size was stored in
bits 0 through 6.) The font family was named by including a 'FONT" resource with a
point size of 0. Since the font family ID had to fit into 8 bits, the range of numbers
available was only 0 through 255; 0 through 127 were reserved for Apple, and 128
through 255 were available for third-party developers. Font families identified using
this method are still recognized by the Operating System, but you should not use
these IDs or this method of identification.
Scripts are writing systems (such as Roman, Japanese, and Arabic) that are used to represent human languages. Script systems include character sets, fonts, keyboards, and resources
that determine text collation and word breaks. Scripts may differ in terms of the direction in
which their characters and lines run, the size of the character set used to represent the script,
and the context sensitivity of the script.
Resources

13-7

“

sr)
&

<—
fo
=|
~
ge

is)

Lee |

Inside Macintosh,

Volume VI

The Roman script system (used by English and many European languages) has the
largest number of font families available. It uses font family IDs between 2 and 16383.
The following list shows the defined ID ranges for the font families associated with
Roman script systems. (The other resources associated with a script, such as 'itlO'" ‘itl1',
‘"it12', '1tl4', 'KCHR’,

'itlk', 'kcs#', 'kcs4', and 'kcs8' resources, have

resource

IDs in

the same range as the 'FOND' IDs for that script. For more information on script systems,
resources such as ‘itl0' or 'KCHR', and developing software for worldwide markets, see

the Worldwide Software Overview chapter in this volume. Note that the 'INTL' resource is
obsolete and you should use the most appropriate currently valid resource, such as 'itlO',

‘itl1', or ‘itl2'.)
Range

Description

0)

System font. This is reserved in any script system. The
Operating System may map any font family from any script
system to this ID.

|

Application font. This is reserved in any script system. The
Operating System may map any font family from any script
system to this ID.

2 through 255

Font families for the Roman script system that were named using
the method described in the Font Manager chapter of Volume I.
Do not continue to use these IDs. Note that Apple’s system fonts
(Chicago, Geneva, New York, and so on) always retain their old
font family IDs.

256 through 1023

Reserved numbers. These numbers should be thought of as
reserved space that the Operating System can use to resolve
past and future font family ID conflicts. Numbers in this range
should not be used as a font family’s original resource ID.

1024 through 3071

Noncommercial and public domain font families.

3072 through 15999

Commercial font manufacturers’ font families.

16000 through 16383

_—_—- Reserved.

The next list shows the script code and the range of font family IDs assigned to each script
system on the Macintosh computer. Non-Roman scripts use font family IDs in the range
16384 through 32767 and in the range —28672 through —24577, and each non-Roman script
has a total of 512 font family IDs available. Script codes 33 through 40 are invalid and should
not be used.
Script
system

Script
code

[System reserved]
Roman
Japanese
Traditional Chinese

Any
0
l
2

13-8

Resources

Font

family

0 through
2 through
16384 through
16896 through

IDs
|
16383
16895
17407

The Resource Manager

Script
system

Script
code

Korean
Arabic
Hebrew

3
+
5

17408 through 17919
17920 through 18431
18432 through 18943

Cyrillic
Uninterpreted right-to-left symbols
Devanagari
Gurmukhi
Gujarati
Oriya
Bengali
Tamil
Telugu
Kannada
Malayalam
Sinhalese
Burmese
Cambodian
Thai
Laotian
Georgian
Armenian
Simplified Chinese
Tibetan
Mongolian
Ethiopian
Extended Roman for Slavic/Baltic

7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

19456
19968
20480
20992
21504
22016
22528
23040
23552
24064
24576
25088
25600
26112
26624
27136
27648
28160
28672
29184
29696
30208
30720

through
through
through
through
through
through
through
through
through
through
through
through
through
through
through
through
through
through
through
through
through
through
through

19967
20479
20991
21503
22015
22527
23039
23551
24063
24575
25087
25599
26111
26623
27135
27647
28159
28671
29183
29695
30207
30719
31231

Extended Arabic (for Sindhi, etc.)
Uninterpreted left-to-right symbols
Reserved
Reserved
Reserved
Reserved
Reserved
Reserved
Reserved
Reserved

31
32
4]
42
43
44
45
46
47
48

31744
32256
—28672
—28160
—27648
—27136
—26624
—26112
—25600
—25088

through
through
through
through
through
through
through
through
through
through

32255
32767
—28161
—27649
—27137
—26625
—26113
—25601
—25089
—24577

Greek

Vietnamese

6

30

Font

family

IDs

18944 through 19455

mn
we
~
S
=
6

31232 through 31743

<

=
ge
B

For every script, the Operating System always maps the correct system font to ID 0 and the
correct application font to ID 1. (In a Roman script system, Chicago is the system font and
Geneva is the application font. This is not the case in any non-Roman script system.)
Apple has created a pseudo-script at script code 32, called smUninterp, which provides a
range of IDs (32256 through 32767) that you can use to identify fonts that are used as
tools in your application. (For example, the MacPaint® drawing program uses a special
font for its palette symbols.) If the glyphs in such a font should be handled as right-to-left
glyphs instead of left-to-right glyphs, use the pseudo-script smRSymbol instead. This
pseudo-script, at script code 8, has a font family ID range of 19928 through 20479.
Resources

13-9

Inside Macintosh,

Volume VI

RESOURCES

IN THE

SYSTEM

FILE

The System file contains resources that are shared by all applications and used by the User
Interface Toolbox and Operating System as well.
A

Warning: Your application should not directly add resources to, delete
resources from, or modify resources in the System file.

If your application needs to install drivers, you should ship it with the Installer and an
Installer script for drivers. In order to distribute the Installer, you need to license the
Apple® system software, which includes the Installer.
In system software version 7.0, resources such as fonts, scripts, keyboards, and sounds
are added to the System file when the user drags their icons to the System Folder. Desk
accessories and resources such as system extensions are now stored in the subdirectories
of the System Folder, not in the System file. (See the Finder Interface chapter in this volume
for details.) These resources and others, such as the folders found in the System Folder, are
represented by system icons. You can use these system icons in your application.
The System file also contains resources that convey information specific to the current
computer on which your application is running, such as the user’s name, the computer’s
name, or the current printer. You call the Gestalt function to obtain this information.
Some routines in the system software are located in packages inside the System file. A
complete list of packages is provided. The change in behavior of a particular function key
resource is also discussed.

System

Icons

The Operating System uses system icons to represent documents, applications, folders,
disks, and other elements of the Macintosh interface. These are commonly known as “Finder
icons,” but they are stored in the System file. You can design your own icons for many of
these icons, but if you do not include a customized icon, your application can display the
appropriate system icon by calling the GetResource function. It is recommended that you
refer to the system icons by their constant names and not by resource ID. The GetResource
function is documented in the Resource Manager chapter of Volume I.
Most icons are available in at least two sizes: large (32-by-32 pixels) and small (16-by-16
pixels). They are also available in three bit depths: 8-bit color, 4-bit color, and black and
white. An icon family consists of the large and small icons for an object, each with a mask,
and each available in the three different color depths. See the User Interface Guidelines
chapter in this volume for more information on the proper design of system icons. See
the Finder Interface chapter in this volume for information on how to create your own icons
for your application.
Many of the system icons are also available in a tiny (12-by-12 pixels) size, represented by
the 'SICN' resource, used primarily by the standard file dialog boxes. Tiny icons are also
used in windows in the Finder that display the contents of disks or folders by name, date,
size, or kind. The Views control panel in version 7.0 allows the user to choose large, small,
13-10

Resources in the System File

The Resource Manager

or tiny icons for these windows. (The standard file dialog boxes use only the tiny icons.)
You cannot design customized icons in the tiny size.

Document

and Application

Icons

These icons represent documents, including special classes of documents such as stationery,
and applications and desk accessories. You can include customized versions of the icons in
this section with your documents and applications. There are icon families and 'SICN'
resources for all of these icons, unless otherwise noted.
Constant
and icon

name

Resource
ID

Description

genericQueryDocumentIconResource

-—16506

The default query document icon. This
is the document used by the Data
Access Manager for database queries.
There is no tiny size for this icon.

genericExtensionIconResource

-16415

The default extension icon. The Finder
displays this icon for any extension that
does not have a customized icon. Extension files appear in the Extensions folder,
which is located inside the System Folder.

genericDocumentIconResource

—4000

The default document icon. The Finder

ae

displays this icon if your application does
not have a customized document icon.

te
@

wm
~
=

oa

_—

genericApplicationIconResource

genericDeskAccessoryIconResource

—3996

3991

The default application icon. The Finder
displays this icon for any application that
does not have a customized icon.
The default desk accessory icon. In
version 7.0 desk accessories are

represented on the desktop like applica-

tions, each with its own icon. The Finder

displays this icon for any desk accessory
that does not have a customized icon.

genericEditionFilelconResource

—3989

The default edition file icon. This is the
intermediary file used by the Edition
Manager. (See the Edition Manager
chapter in this volume.)

genericStationerylconResource

—3985

The default stationery file icon. Applications can use this file as stationery. (See
the Finder Interface chapter in this
volume.)

genericPreferencesIconResource
®-o--

SS

—397]

The default preference file icon. Preference files appear in the Preferences folder,
which is located inside the System Folder.
There is no tiny size for this icon.
Resources in the System File

— 13-11

a
re

2
—

Ps

oa
—

a

9

ti=
@

br |

Inside Macintosh,

Folder

Volume VI

Icons

These icons represent the different types of folders found on the desktop. There are icon
families and 'SICN' resources for all of these icons, unless otherwise noted.
Constant
and icon

name

Resource
ID

Description

genericFolderlconResource

—3999

The default folder icon. This is the
folder seen on the desktop.

privateFolderlconResource

—3994

The icon for a folder to which the user
does not have access. It is dimmed
and has a distinctly marked border.
The Finder displays an alert box when
a user without privileges attempts to
open this folder.

ownedFolderIconResource

—3980

The icon for a folder that is owned by
a particular user, usually on a shared
volume like a file server. There is no
tiny size for this icon.

dropFolderIconResource

—3979

The icon for a folder in which any
user may store documents, applica-

x)

(7)

i]

tions, and so on, but from which only

a specified group of users can retrieve
the contents. There is no tiny size for
this icon.

sharedFolderlconResource

(_]

—3978

The icon for a folder that the owner
has made available for file sharing.
There is no tiny size for this icon.

—3977

The icon for a folder that a guest has
mounted on a remote volume. This
icon appears only for the guest. There
is no tiny size for this icon.

=a

mountedFolderIconResource

fea
a

System

Folder

Icons

These icons represent the different types of folders found in the System Folder. You should
not alter the appearance of these icons. There are icon families only for these icons, unless
otherwise noted.
Constant
and icon

name

systemFolderIconResource

13-12

Resources in the System File

Resource

ID

Description

—3983

The System Folder icon. This folder
contains the System file and other
system-related folders.

The Resource Manager

Constant

and

icon

name

Resource
ID

Description

appleMenuFolderIconResource

—3982

The Apple Menu Items folder icon.
This folder contains items found in
the Apple menu.

startupFolderlconResource

—3981

The Startup Items folder icon. This
folder contains documents, aliases,
applications, and other objects that
open when the computer starts up.

controlPanelFolderlconResource

—3976

The Control Panels folder icon. This
folder contains control panels.

printMonitorFolderlconResource

—3975

The PrintMonitor Documents folder
icon. This folder contains documents

(s]

that are in the queue to be printed.

preferencesFolderlconResource

—3974

The Preferences folder icon. This

folder contains preference files for the

Finder and other software that needs
to remember user preferences.

oO--

extensionsFolderlconResource

(3

—3973

The Extensions folder icon. This folder
contains extensions to the System file,
the Chooser, a network, a database,

and so on. (See “Terminology” in the
User Interface Guidelines chapter in
this volume for examples of
extensions.)

Desktop

Icons

Resource
ID

Description

floppylconResource

—3998

The default icon for a 3.5-inch disk.

trashIconResource

—3993

The default empty Trash icon. The
Standard File Package also uses this
icon to represent the Trash.

fullTrashIconResource

—3984

The default full Trash icon, with

faa
il

O

aw
@

n

~
a

o

&

sor |

°
@

—

an
oS)
o—
_
To
—

@
a |

size. There are icon families and 'SICN' resources for these icons, unless otherwise noted.
Name

ent

—

These icons appear on the desktop. The standard file dialog boxes use these icons in tiny

Constant
and icon

—

Ww

bulging midsection. This represents
the Trash when full. There is no tiny
size for this icon.
Resources in the System File

—_ 13-13

Inside Macintosh,

Standard

Volume VI

File Package

Icons

These icons are used only by the Standard File Package and appear only in the tiny icon
size, unless noted otherwise. You can’t design customized icons in the tiny size. The pop-up

menu in the standard file dialog box indicates where the list of files shown in the dialog box
is located (whether on the desktop, at the top level of a volume, or inside a series of folders

on a volume).
Constant

and

icon

name

openFolderlconResource

Resource
ID

—3997

The open folder icon, which appears
in a pop-up menu only. The standard
file dialog boxes display this icon to
indicate which folder is currently
open.

—3995

The hard disk icon, which appears in a
pop-up menu only. The same icon is
used to represent internal and external
disks. A different icon may appear on

Sy

genericHardDiskIconResource

Description

[

the desktop, because the manufacturer

of the hard disk can design a special
icon for a particular volume.
desktopIconResource

—3992

The desktop icon, which appears in a
pop-up menu only. The standard file
dialog boxes display this icon to
indicate which files and folders are
available on the desktop. In addition to
the 'SICN' resource, there is also an
icon family without an 'TCN#'
resource for this icon.

—3972

The file server volume icon. This

Es

genericFileServerlconResource

=

desktop. A different icon may appear
on the desktop, because the manufacturer can design a special icon for
a particular server.

genericSuitcaselconResource

—3970

The suitcase icon. This represents
any suitcase, such as font suitcases
or desk accessory suitcases. There
are different icons for these suitcases
in larger sizes, depending on
the contents.

—3969

The icon for any object that you
can move into the System file.
These objects include fonts, scripts,
keyboards, sounds, and so on.

oO

genericMoverObjectIconResource

‘a
13-14

represents any servers open on the

— Resources in the System File

The Resource Manager

User

Information

Resources

There are resources in the System file that detail the user’s name, the computer’s name,
the model of computer, the icon for that particular computer, and the current printer the
computer uses.
Information

Description

User name

The name of the person who “owns” the machine or is the current
user. This is stored in the System file as a 'STR ' resource with
resource ID —16096. Use the GetString function to return the user
name.

Computer name

The name of the computer, which is now distinct from the user name.
It is also distinct from any internal hard disks that may be present. The
computer name is stored in the System file as a 'STR ' resource with
resource ID —16413. The default name of the computer is “User
name’s Macintosh.” Use the GetString function to return the computer
name.

Computer model

The model of the computer, such as Macintosh SE/30 or Macintosh IIci.
The computer model is stored in the System file as a 'STR#' resource
with resource ID —16395. The Gestalt selector for the computer model is
gestaltMachineModel, and the Gestalt function returns a response value
for this selector. Use this value as an index into the 'STR#' resource,
using the GetIndString procedure. You should never use the model of
computer as an indication of what software features or hardware may
be available.

Computer icon

Printer type

The icon for the computer model, such as the Macintosh II or
Macintosh IIci. The icons for computers are stored in icon families.
The Gestalt selector for the computer icon is gestaltMachinelcon.
Use the response value for this selector as the resource ID of the
icon resource you want. (For more information about icon families,
see the Finder Interface chapter in this volume.)
The type of printer to which the computer sends documents, such as
a LaserWriter® printer. There is no method for retrieving the name of
the printer. The printer type is stored in the System file as a'STR'
resource with resource ID —8192. Use the GetString function to return
the type of printer.

The GetString function and GetIndString procedure are documented in the Toolbox Utilities
chapter of Volume I. The Gestalt function is documented in the Compatibility Guidelines
chapter of this volume.

Packages
A package is a set of routines and data types that forms a part of the Toolbox or Operating
System and is stored as a resource. On the original Macintosh computer, all packages were
disk-based and brought into memory only when needed; some packages are now in ROM.
Resources in the System File

— 13-15

—

we
3")
72)
-_
~

~

—

=
i)
a)
A
veel
SS
—

—

re)

ga
io
bene

|

Inside Macintosh,

Volume

VI

The System file contains the standard Macintosh packages and the resources they use or own.
Package

name

Resource

Function

Key

ns

—_—

'

WDNKHCOIDMNBRWNO

List Manager Package
Disk Initialization Package
Standard File Package
Floating-Point Arithmetic Package
Transcendental Functions Package
International Utilities Package
Binary-Decimal Conversion Package
Apple Event Manager
PPC Browser
Edition Manager
Color Picker Package
Data Access Manager
Help Manager
Picture Utilities Package

ID

Resources

Function key resources (of the 'FKEY' resource type) are Command-Shift-number key
combinations that are captured and processed by the WaitNextEvent function. The screen
utility resource 'FKEY' 3 now produces a screen shot, contained in a 'PICT’ file, when the
user presses Command-Shift-3. 'FKEY' resource IDs 0 through 2 and 4 through 9 are
reserved for future use by Apple. The WaitNextEvent function is described in the Event
Manager chapter of this volume.

USING

THE

RESOURCE

MANAGER

The Resource Manager in version 7.0 allows you to read a portion of a resource into
memory or write a block of data to a resource stored on disk, even if the size of the
memory you have to work in is smaller than the entire resource. You can also change
the size of a resource on disk.

Using

Partial

Resources

Some resources, such as the 'snd ' and 'sfnt' resources, can be quite large—larger, in fact,
than the memory available. The partial resource routines in version 7.0 allow you to read a
portion of the resource into memory or alter a section of the resource while it is still on disk.
You can also enlarge or reduce the size of a resource on disk. The ReadPartialResource
procedure reads a portion of a resource from disk into memory, and the WritePartialResource
procedure writes a portion of data to a resource on disk. You can also change the size of the
resource on disk to any desired size, using the SetResourceSize procedure. When you use the
partial resource routines, you specify how far into the resource you want to begin reading or
writing and how many bytes you actually want to read or write at that spot, so you must be
sure of the location of the data.
13-16

Using the Resource Manager

The Resource Manager

A

Warning: Be aware that having a copy of a resource in memory when you
are using the partial resource routines may cause problems. If you have
modified the copy in memory and then access the resource on disk using either
the ReadPartialResource or WritePartialResource procedure, you will lose
changes made to the copy in memory. a

To read or write any part of a resource, call the SetResLoad procedure specifying FALSE for
its load parameter, and then use the GetResource function to get an empty handle to the
resource. (Because of the call to the SetResLoad procedure, the GetResource function does
not load the entire resource into memory.) Use the ResError function to check for errors.
(The SetResLoad procedure, the GetResource function, and the ResError function are
described in the Resource Manager chapter in Volume I.)

To check for the existence of the new partial resource routines, use the Gestalt function with
the gestaltResourceMegrAttr selector. (See the Compatibility Guidelines chapter in this volume
for information on Gestalt.) This selector returns a range of bits, the meaning of which must
be determined by comparison with a list of constants. If the bit defined by the constant
gestaltPartialRsrcs is set, the partial resource routines are available.
Listing 13-1 illustrates one way to deal with partial resources. This procedure begins with a
call to the SetResLoad procedure. A handle to the resource from which you want to read is
put into the myResHd1l variable. If there is no error on the call to the GetResource function, a
call is made to the ReadPartialResource routine with the handle to the resource. If there are no
errors with this call, you exit the procedure. DoError is the name of your routine that handles
and processes errors.

~

Listing 13-1. Using partial resource calls
PROCEDURE

ReadAPartial(start:
VAR

LongInt;

PutiItHere:

count:

2

r=
a

LongInt;

Ptr);

=
=

VAR
myRsrcType:

ResType;

de

myRsrcID:
myResHdl:

Integer;
Handle;

5

resErr:

OSErr;

RPRErr:

OSErr;

BEGIN
SetResLoad (FALSE) ;
{don't
load resource}
{Set up myRsrcType
and myRsrcID
to your
liking. }
myResHdl
:= GetResource(myRsrcType,
myRsrcID);
resErr
:= ResError;
SetResLoad (TRUE) ;
IF

resErr

=

NoErr

{reset

RPRErr

:=

to

always

load}

THEN

BEGIN
ReadPartialResource(myResHdl,

start,

PutItHere,

count);

ResError;

{Check and report
error.}
IF RPRErr
<> noErr THEN DoError(RPRErr) ;
END
ELSE

{there's

an

error

from

GetResource}

DoError(resErr);

END;

re

{ReadAPartial}

Using the Resource Manager

——- 13-17

Inside Macintosh,

Creating

Volume VI

and

Opening

Resource

Files

Version 7.0 introduces a simple, standard format for identifying a file or directory, the file

system specification (FSSpec) record. This record contains the volume reference number of
the volume on which a file or directory resides, the directory ID of the parent directory, and
the name of the file or directory. (For a complete introduction to and description of the MFS
and HFS file systems and file system specification records, see the File Manager chapter in
this volume.)
TYPE

FSSpecPtr

=

FSSpec

=

“FSSpec;

RECORD

vRefNum:

Integer;

{volume

parID:

LongIint;

{directory

reference

name:

Str63

ID

of

number}

parent}

{directory}
{filename

or

directory

name}

END;

The FSpOpenResFile function and FSpCreateResFile procedure open and create resource
files for files or directories named by the file system specification record.
If you want to open or create resource files under the Hierarchical File System (HFS)
but are not using the file system specification record in your application, you can use
the HOpenResFile function and HCreateResFile procedure.

Storing

Fonts in a Resource

Fork

Storing a font in an application’s resource fork can create serious problems for a user who
tries to print a document in that font when background printing is on. Never store fonts in a
document’s resource fork, since this can cause heap corruption. If you feel that a document
needs to have a particular font available, you should license it for distribution and let users
install it in their System files.
If you use a font as a way to store symbols that your application uses in a palette or for some
other special purpose, use a font family ID in the range assigned for uninterpreted symbols.
(For more information about font family ID ranges, see “Font Families and Scripts” earlier
in this chapter. For more information about scripts and script systems, see the Worldwide
Software Overview chapter in this volume.)

RESOURCE

MANAGER

ROUTINES

The first group of routines described here deals with modified routines for opening or
creating resource files. These routines are compatible with new file specification conventions
for version 7.0 and the Hierarchical File System (HFS). Version 7.0 introduces a simple,
standard format for identifying a file or directory, the file system specification (FSSpec)
record. For a discussion of HFS and file system specification records, see the File Manager
chapter in this volume.
13-18

Resource Manager Routines

The Resource Manager

The other new Resource Manager routines pertain to reading and writing partial resources. If
you are working with a very large resource, you can alter a part of the resource instead of
having to read it into memory, which may be impossible. You can also change the size
of a resource on disk. Note that if you increase the size of the resource, the new portion of
the resource will be uninitialized, and if you decrease the size, you may lose valuable data
in the resource.

Creating

Resource

Files

The FSpCreateResFile and HCreateResFile procedures are alternate ways of creating
resource files in HFS. These routines are based on the CreateResFile procedure, which
is documented in the Resource Manager chapter of Volume I. HCreateResFile is a simple
function designed for HFS; FSpCreateResFile uses file system specification records.
PROCEDURE

FSpCreateResFile

(spec:

FSSpec;

scriptTag:

creator,

fileType:

OSType;

ScriptCode) ;

The FSpCreateResFile procedure opens the file named in the spec parameter. The creator
parameter contains the signature of the application that created the file, and the fileType parameter indicates what type of file it is. The value of the scriptTag parameter should be the script
code of the script system in which the Finder and the standard file dialog boxes display the
name of the file. If you specify NIL, the FSpCreateResFile function defaults to the Roman
script system. If you use Standard File Package routines, note that the StandardPutFile
procedure returns a standard file reply record that contains information about the file. Call the
ResError function to check for errors.
The file system specification record is described in the File Manager chapter in this volume.
The StandardPutFile procedure and the standard file reply record are described in the
Standard File Package chapter of this volume. The result codes for the FSpCreateResFile
procedure are the same as those for the HCreateResFile function.

—

a)
—

ew

o

1? 2)

=)
=
“

CO

@

<x
fg=
o>
gg
—

—_

@

~

PROCEDURE

HCreateResFile

(vRefNum:

Integer;

dirID:

LongInt;

fileName:

StL255) 3

The HCreateResFile procedure creates a resource file in the directory specified by the values
of vRefNum and dirID. The vRefNum parameter contains the volume reference number of
the volume on which the file is located. The dirID parameter contains the directory ID of the
directory where the file is located. The string passed in the fileName parameter is the name of
the resource file. Call the ResError function to check for errors.
Result codes

dirFulErr
dskFulErr
nsvErr
ioErr
bdNamErr
tmfoErr
wPrErr
fLekdErr

—33
—34
—35
—36
—37
—42
—t4
—45

Directory full
Disk full
No such volume
I/O error
There may be no bad names in the final system
Too many files open
Disk is write-protected
File is locked
Resource Manager Routines

—13-19

Inside Macintosh,

Volume VI

vLckdErr

+6

Volume is locked

opWrErr
extFSErr
dirNFErr

—49
—58
—120

File already open with write permission
Volume belongs to an external file system
Directory not found

dupFNErr

Opening

—48

Duplicate filename (rename)

Resource

Files

The FSpOpenResFile and HOpenResFile functions are alternate ways of opening resource
files using HFS. These functions are based on the OpenResFile function, which is documented in Volume I. HOpenResFile is a simple function designed for HFS; FSpOpenResFile
uses file system specification records.
FUNCTION

FSpOpenResFile

(spec:

FSSpec;

permission:

SignedByte)

Integer;

The FSpOpenResFile function opens the file named in the spec parameter. The FSpOpenResFile
function lets you open a resource file without creating a working directory. The permission
parameter can contain any one of the following constants:
CONST
fsCurPerm
fsRdPerm

=
=

0;
1;

{whatever
is
{request
for

currently
allowed}
read permission
only}

fsWrPerm

=

2;

{request

for

write

fsRdWrPerm
fsRdWrShPerm

=
=

3;
4;

{request
{request

for
for

exclusive read/write permission}
shared read/write permission}

permission}

More information about these constants can be found in the “Low-Level File Manager
Routines” section of the File Manager chapter of Volume IV.
Call the ResError function to check for errors. If the FSpOpenResFile function failed to
open the resource file, the reference number returned is —1. The result codes for the
FSpOpenResFile function are the same as those for the HOpenResFile function.
FUNCTION

HOpenResFile

(vRefNum:

Integer;

Str255;

permission:

dirID:

LongInt;

SignedByte)

fileName:
:

Integer;

The HOpenResFile function opens the resource file with the name given by the fileName
parameter. This function also lets you open a resource file without creating a working
directory. Call the ResError function to check for errors. If HOpenResFile failed to open
the resource file, the reference number returned is —1.
The vRefNum parameter contains the volume reference number of the volume on which the
file is located. The dirID parameter contains the directory ID of the directory where the file is

located. The constants used for the permission parameter are the same as those listed for the
FSpOpenResFile function.

13-20

Resource Manager Routines

The Resource Manager

Result codes

nsvErr
ioErr
bdNamEtrr
eofErr
tmfoErr
fnfErr
opWrErr
permErr
extFSErr
memFullErr
dirNFErr
mapReadErr

Reading

—35
—36
—37
—39
—42
43
—49
—54
—58
—108
—120
—199

and Writing

No such volume
I/O error
There may be no bad names in the final system
End of file
Too many files open
File not found
File already open with write permission
Permissions error (on file open)
Volume belongs to an external file system
Not enough room in heap zone
Directory not found
Map inconsistent with operation

Partial

Resources

You can use the ReadPartialResource and WritePartialResource procedures to manipulate
a subsection of a large, unwieldy resource that may not otherwise fit in memory. You can
use the SetResourceSize procedure to change the size of a resource on disk to a size that
you specify.
Be aware that having a copy of a resource in memory when you are using the partial resource
routines may cause problems. If you have modified the copy in memory and then access the
resource on disk using either the ReadPartialResource or WritePartialResource procedure,
you will lose changes made to the copy in memory.

——

"nd

~

3°)

”
Sc
~

=

—_

°C
©

Assembly-language note: You can invoke each of the partial resource
routines with the _ResourceDispatch macro. The routine selectors are listed
in the “Summary of the Resource Manager” at the end of this chapter.

PROCEDURE

ReadPartialResource

(theResource:

Handle;

buffer:

Ptr;

UNIV

offset:

count:

4

—

=
=
m
i=)

@
or )

LongInt;

LongInt);

The ReadPartialResource procedure reads part of a resource in from disk, which allows you
to work with small portions of large resources. This procedure reads into memory a section
of the resource, which is specified by the parameter theResource. The value of the offset
parameter marks the beginning of the subsection as measured in bytes from the start of the
resource. The length of the section is given by the value of the count parameter. The
ReadPartialResource procedure reads the partial resource into the buffer you indicate with
the buffer parameter. You are responsible for the memory management of this buffer. You
cannot use the ReleaseResource procedure (documented in the Resource Manager chapter
of Volume I) to release the memory occupied by this buffer. Call the ResError function to
check for errors.

Resource Manager Routines

— 13-21

Inside Macintosh,

Volume

VI

The ReadPartialResource procedure always tries to read resources from the disk. If
a resource is already in memory, the Resource Manager still reads it from the disk and
ResError returns the resourceInMemory result code. If you have loaded the resource into
memory and modified it, you will lose any changes to the resource once you call the
ReadPartialResource procedure. If you try to read past the end of a resource or your
offset is out of bounds, ResError returns the inputOutOfBounds error. If the handle
named by the parameter theResource is not in any open resource files, ResError returns
the resNotFound result code.
When using partial resource routines, you should call the SetResLoad procedure specifying
FALSE for its load parameter before you call the GetResource function. SetResLoad prevents
the Resource Manager from reading the entire resource into memory. Be sure to restore the
normal state of the SetResLoad procedure after you call the GetResource function. (The
SetResLoad procedure and the GetResource function are described in the Resource Manager
chapter of Volume I.)

Note: If the resource is in memory and you want part of its data, you should use
the BlockMove procedure instead of the ReadPartialResource procedure, because
BlockMove is faster. The BlockMove procedure is documented in the Memory
Manager chapter of Volume II.
Result codes

resourceInMemory
inputOutOfBounds
resNotFound

PROCEDURE

-188
-190
—192

WritePartialResource

Resource already in memory
Offset or count out of bounds
Resource not found
(theResource:

Handle;

buffer:

Ptr;

UNIV

offset:

count:

LongInt;

LongInt);

The WritePartialResource procedure writes part of a resource to disk, which allows you to

work with small portions of large resources. The resource is specified by the parameter
theResource from the offset parameter, which is in bytes, through the number of bytes given
by the value of the count parameter. The Resource Manager writes to the resource from the
buffer you indicate with the buffer parameter. You are responsible for the memory management of this buffer. Call the ResError function to check for errors.
If the disk or the file is locked, the ResError function returns the appropriate file system error.
If you try to write past the end of a resource, the Resource Manager attempts to enlarge the
resource. ResError returns the writingPastEnd result code if the attempt is successful. If it
cannot enlarge the resource, ResError returns the appropriate file system error. If you pass an
invalid value in the offset parameter, ResError returns the inputOutOfBounds result code.
If the resource is in memory when you call the WritePartialResource procedure, the Resource
Manager tries to write the resource. If the attempt is successful, ResError returns
resourceInMemory and does not update the copy in memory. You should be aware that in
this situation, the copy in memory is different from the resource on disk. If the attempt to
write the resource to disk is not successful, ResError returns the appropriate error.

13-22

Resource Manager Routines

The Resource Manager

When using partial resource routines, you should call the SetResLoad procedure specifying
FALSE for its load parameter before you call the GetResource function. The SetResLoad
procedure prevents the Resource Manager from reading the entire resource into memory. Be
sure to restore the normal state of the SetResLoad procedure after you call the GetResource
function. (The SetResLoad procedure and the GetResource function are described in the
Resource Manager chapter of Volume I.)
Result codes

dskFulErr
resourcelInMemory
writingPastEnd
inputOutOfBounds

PROCEDURE

—34
-188
—189
—-190

SetResourceSize

Disk full
Resource already in memory
Writing past end of file
Offset or count out of bounds

(theResource:

Handle;

size:

LongInt);

The SetResourceSize procedure sets the size of a resource without writing data. You can
change the size of any resource, regardless of the amount of memory you have available.
Note that if you make the resource smaller, you lose any data at the end of that resource.
The parameter theResource is a handle that specifies the resource on disk. The value of the
size parameter is the size you want the resource to occupy on disk, in bytes. If you set the
size smaller than it was, you lose any data at the end of the resource. If the size is set larger,
all data is preserved, but the enlarged area is uninitialized. Call ResError to check for errors.
If the disk is locked or full, or the file is locked, ResError returns the appropriate file system
error. If the resource is in memory, the Resource Manager tries to set the size of the resource
on disk. If the attempt is successful, ResError returns the resourceInMemory result code and
does not update the copy in memory. If it is not successful, ResError returns the appropriate
file system error.
Result codes
resourceInMemory
writingPastEnd

—

Ww
aes

te

©

2)

©

=
a)
©
=
=)
=
=)
ga
oc

Laer |

eel

ver

-—-188
—189

Resource already in memory
Writing past end of file

Resource Manager Routines

— 13-23

|

Inside Macintosh, Volume VI

SUMMARY

OF

THE

RESOURCE

icon

definition

MANAGER

Constants
CONST

{system

genericQueryDocument

IDs}

-16506;

IconResource

-3999;

openFolderIconResource

~399'7 2

query

document

}

{ icon}
{default document icon}
{default folder icon}
{default 3.5-in. disk icon}
{open folder icon}
{default application icon}
{hard disk icon}
{folder without privileges
}
{ for this user icon}
{default empty Trash icon}
{desktop icon}

-4000;

genericDocumentIconResource
genericFolderIconResource
floppyIconResource

-3998;

genericApplicationIconResource
genericHardDiskIconResource

—3996);
-3995;

privateFolderIconResource

-3994;

trashIconResource
desktopIconResource

-3993;
-3992;

genericDeskAccessoryIconResource

-3991;

{default
{ icon}

desk

genericEditionFileIconResource

-3989;
—3985;

{default

edition

{default

stationery

icon}

-3984;

+3983;
-~3982;

{default

full

Trash

icon}

{System

Folder

icon}

ownedFolderIconResource

—3981;
-3980;

dropFolderIconResource

-3979;

{Startup Items folder
{owned folder icon}
{drop folder icon}
{shared folder icon}

genericStationeryIconResource
fullTrashIconResource
systemFolderIconResource
appleMenuFolderIconResource

I

startupFolderIconResource

{Apple Menu
{ icon}

accessory

}

icon}

Items

folder

sharedFolderIconResource
mountedFolderIconResource

-3978;
-3977;

controlPanelFolderIconResource

{mounted

folder

icon}

-3976;

{Control

Panels

folder

}

icon}

}

spoolFolderIconResource

=33 75s

preferencesFolderIconResource
genericFileServerIconResource

-3974;
-3973;
-3972;

genericPreferencesIconResource

{ icon}
{PrintMonitor Documents
}
{ folder icon}
{Preferences folder icon}
{Extensions folder icon}
{file server icon}

=3971;

{default

extensionsFolderIconResource

genericSuitcaselIconResource

genericMoverObjectIconResource
{Gestalt
codes
for the
gestaltResourceMgrAttr

Resource

gestaltPartialRsrcs

13-24

{default

Summary of the Resource Manager

{

icon}

preference

-3970;

{suitcase

-3969;

{System

file

“ysre"¢

{Gestalt

selector};

0;

{partial

resources

file

icon}

object

icon}

Manager}
exist}

}

The Resource Manager

Routines

Creating
PROCEDURE

Resource

Files

FSpCreateResFile

(spec:

FSSpec;

scriptTag:
(vRefNum:

creator,

PROCEDURE

HCreateResFile

Integer;

Opening

Resource

FUNCTION

FSpOpenResFile

(spec:
FSSpec;
Integer;

FUNCTION

HOpenResFile

(vRefNum:

Str255) }

fileType:

OSType;

ScriptCode) ;
dirID:

LongInt;

fileName:

Files
permission:

Integer;

fileName:

dirID:

Str255;

SignedByte)
LongInt;

permission:

SignedByte)

Integer;

Reading

and Writing

Partial

PROCEDURE

ReadPartialResource

Resources
se

(theResource:

Handle;

buffer:

Ptr;

UNIV

offset:

count:

LongInt;

LongInt);

PROCEDURE

WritePartialResource

(theResource:
buffer:
UNIV

Handle;
offset:
LongInt;
Ptr;
count:
LongInt);

PROCEDURE

SetResourceSize

(theResource:

Handle;

size:

LongInt);

Ww
eae

nw
oO

77)
©
—

or

er)
fe)

2
A
SS
—

tone

te)

tio
@

eae

Result

Codes

dirFulErr
dskFulErr
nsvErr
ioErr
bdNamErr
eofErr
tmfoErr
fnfErr
wPrErr
fLekdErr
vLckdErr

—33
—34
—35
—36
—37
—39
—42
—43
—4
—45
—46

Directory full
Disk full
No such volume
I/O error
There may be no bad names in the final system
End of file
Too many files open
File not found
Disk is write-protected
File is locked
Volume is locked

opWrErr
permErr
extFSErr
memFullErr

—49
—54
—58
—108

File already open with write permission
Permissions error (on file open)
Volume belongs to an external file system
Not enough room in heap zone

dupFNErr

—48

Duplicate filename (rename)

Summary of the Resource Manager

|

Inside Macintosh,

dirNFErr
resourceInMemory
writingPastEnd
inputOutOfBounds
resNotFound
mapReadErr

Volume

VI

Assembly-Language
Trap

Macros

Directory not found
Resource already in memory
Writing past end of file
Offset or count out of bounds
Resource not found
Map inconsistent with operation

—120
-—-188
—189
—-—190
—192
—199

Information

Requiring

Routine

_ResourceDispatch
Selector

Routine

$0001
$0002
$0003

ReadPartialResource
WritePartialResource
SetResourceSize

13-26

Summary of the Resource Manager

Selectors

14

WORLDWIDE

SOFTWARE

OVERVIEW

5
About This Chapter
6
About Worldwide Software
7
The Graphic Representation of Languages
7
Localized Versions of the Macintosh System Software
8
Multiple Script Systems and Multiple Languages on the Macintosh Computer
8
Identifying Scripts, Languages, and Regions
10
About the Script Management System
10
About the Script Manager
12
Local and Global Variables
12
Style Runs and Higher-Level Text Organization
12
Tokens
13
Date Conversion
13
Geographic Information
13
Number Conversion
13
About the International Utilities Package
14
About the International and Keyboard Resources
15
About the Macintosh Script Systems
16
The Script Management System and Related Worldwide Components
19
Worldwide Control Panels and Desk Accessory
19
Installing and Removing Script Systems, Keyboards, and Fonts
20
Using the Keyboard Menu
21
Selecting Keyboard Layouts
21
Distinguishing Scripts
Keyboards
23
Fonts
25
25 _—_ Localization
26
Sorting
Primary or Secondary Order
26
27

rs
a

Expansion

27

Contraction

=

21

Exceptional Words

=

eH
28

28

28

28
29
29
30
30
31
32
32
35
33
33

=

Ignorable Characters

fae

Formats

L

Date and Time

=

Currency and Measurement

rs
©

Calendars
Numbers
An Introduction to Scripts
Character Representation
Text Direction
Contextual Forms
Diacritical Marks
Uppercase and Lowercase Characters
Character Reordering
Word Demarcation
Alignment and Justification of Text

14-1

Inside Macintosh,

34
34
35
35
35
36
36
36
37
37
37
39
39
AO
40
4]
43
43
44
45
45
45
46
47
47
47
48
48
48
48
48
49
49
49
49
50
50
51
55
58
59

60

Volume

VI

Representing Scripts on the Macintosh
Character Set Encoding
Character Input
Composition Rules
Text Manipulation
Text Rendering
_ Using the Script Manager
Determining the Features of the Script Manager
Initializing the Script Manager
Creating Simple Script Systems
Calling the Script Manager
Overview of the Script Manager Routines
Checking and Modifying Global and Local Variables
Accepting Implicit Script Codes
Verbs for GetScript and SetScript
Verbs for GetEnvirons and SetEnvirons
Checking and Setting System Variables
Setting the Active Keyboard Script
Obtaining Script Information
Obtaining Character Information
Manipulating Text
Drawing and Editing Text
Formatting Text
Modifying Text
Substituting Text
Truncating Text
Lexically Interpreting Different Scripts
Date and Time Utilities
Converting Worldwide Dates and Times
Converting Long Dates
Modifying and Verifying Date and Time Records
Reading and Storing Locations
Number Utilities
Converting to and From Canonical Number Formats
Working With Formatted Numbers
= Script Manager Routines
Localizing Word Selection and Line Break Tables
Defining Word Boundaries and Line Breaks
Determining Word Selection: An Example
Optimized Word Break Tables
Truncating Text

Substituting Text

61
Substituting and Truncating Text
62
Converting Case and Stripping Diacritical Marks
64
Handling Justified Text
65
Providing for Spacing Between Multiple Style Runs
68
Justifying Text on the Roman Script System
71 — Using the International Utilities Package Routines
72
Overview of the International Utilities Package Routines
Ta
Comparing Strings
73
Modifying the Standard String Comparison
73
Facilitating Interscript Sorting Order
74
Accessing the International Resources

Worldwide Software Overview

74
75
75
76
77
78
79
80
81
82
85
86
87
90
9]
92
95
96

Localizing Dates, Times, and Metric Information
International Utilities Package Routines
Script and Language Codes
Manipulating the ‘itl2' and 'itl4' Resources
Specifying Resource Handles Explicitly
Determining Interscript Sorting Order
Using the International and Keyboard Resources
Enhancements to International Resources
The ‘itlc' Resource
The ‘itln’ Resource
The ‘itlb' Resource
The ‘itl0' Resource
The ‘itll’ Resource
The ‘itl2' Resource
The ‘1tl2' Resource Header
The ‘itl4' Resource
Keyboard Types and Modifier Bits
The 'KCHR' Resource

98
99
100
100
101
102
102
102
103
104
104
104
105
107
107
107
108
109
109
109
110
110
111
133.
138

The 'KSWP' Resource
The ‘itlk' Resource
Key Caps and the 'KCAP' Resource
Dead-Key Feedback
The 'KCAP' Resource
Localizing to Other Languages and Regions
Using Resources
Text and Dialog Translation Tips
Adapting Text Operations
Using Fonts
Avoiding Special Character Codes as Delimiters
Using the Standard Roman Character Set
Adapting Keyboard Equivalents
Modifying the Representation of Dates, Times, and Numbers
Writing Software for Other Scripts
Working With Fonts
Working With Character Codes
Working With Text Direction
Synchronizing Keyboards and Fonts
Handling Numbers
Identifying Keywords and Tokens
Possible Printing Problems
Summary of the Script Manager
Summary of the International Utilities Package
Summary of the International Resources

98

The 'kces#', 'kcs4', and 'kcs8' Resources

=

de
=<

<=

=)
ef

—

jae

=

Qn

@
WN

=

=
ane

a

+N)
er}

@

14-3

Inside Macintosh,

14-4

Volume VI

Worldwide Software Overview

ABOUT

THIS

CHAPTER

Read this chapter if you wish to create applications that are adapted to regions other than your
own or that work with any non-Roman script system. The information in this chapter is
essential if you would like to plan and provide for such development in future versions of your
applications. Furthermore, you may want to take advantage of several other text-handling
capabilities described in this chapter and not available elsewhere in the Macintosh® Toolbox.
This chapter provides the essential background to developing Macintosh software for worldwide markets. It introduces you to the use of the Macintosh worldwide software, whose
specific features are provided by the Script Manager, the International Utilities Package, the
international and keyboard resources, and script systems. You can use worldwide software
to make your applications compatible in the global market.
This chapter provides an overview of the Script Manager routines and data structures that let
you represent scripts on the Macintosh. (Scripts, in this context, are writing systems such
as Roman, Japanese, and Arabic that are used to represent human languages.) The Script
Manager allows you to deal with script-related issues such as character representation, text
direction, contextual forms, diacritical marks, uppercase and lowercase characters, character
reordering, word demarcation, and text alignment.
This chapter provides an overview of the International Utilities Package routines and data
structures that permit you to sort strings and to format dates, times, currency, and numbers
according to the conventions of the script, language, or region of the software market you
address. Throughout this chapter, language refers to the whole body of written words and
of methods of combining words used by a particular group of people, and region denotes a
linguistic or cultural entity that may or may not correspond to a geographic area.
This chapter gives details on the international and keyboard resources that help you specify
information that pertains to a particular script, language, or region. Such information includes
fonts, long and short date formats, keyboard layouts, preferred sorting order, and relationships between scripts, languages, and regions. Other pertinent data is delineated in resource
tables for character type, case conversion, and word breaks. The resources also allow you to
specify tokens, character set encodings, and keyboard mapping information that includes
hardware-specific modifications to keyboard layouts.
This chapter introduces the Macintosh seript systems—collections of software facilities
that work with the Script Manager to provide for basic differences between writing systems,
such as character sets, fonts, keyboards, text collation, and word breaks. Examples of script
systems are Roman, Japanese, Arabic, Traditional Chinese, Simplified Chinese, Hebrew,
Cyrillic, Thai, and Korean.

Finally, the chapter furnishes an extensive set of guidelines for adapting your applications to
other languages and regions and for writing software for other scripts.
The information in this chapter, particularly, on the Macintosh Script Management System and
the concepts underlying the Macintosh script systems, provides you with the understanding
you need to make your applications run on Macintosh computers with multiple script systems
installed. To make your applications work in a region other than your own, you will find
especially valuable the information on the International Utilities Package, the international
resources, the keyboard resources, and the concepts underlying the localization process.
About This Chapter

14-5

—

de

<
=
=)

=

=¥
==
©

o 2)
i)

=

=

=)

Lee |

©

Inside Macintosh,

Volume VI

This chapter also supplements the information in Volumes I and V. In addition to describing
the enhancements available with system software version 7.0, the chapter provides brief
descriptions of system software that has not been previously documented in /nside Macintosh.
Included are brief descriptions of the Script Manager version 2.0 routines, two routines in the
International Utilities Package, two international resources (‘itlk' and 'itl4'), and several
enhancements to the international resources available with system software versions 6.0.4,
6.0.5, and 6.0.7.
The essential technical reference on the features in worldwide software prior to system
software version 7.0 is the beta draft of Macintosh Worldwide Development: Guide to
System Software. This manual, currently available through APDA®, supplements this
chapter. It covers in depth the Script Manager routines and data structures and the international and keyboard resources. Together with this overview chapter, Macintosh Worldwide
Development: Guide to System Software tells you what you need to know about making
your software compatible worldwide.
You should also be familiar with the User Interface Guidelines chapter in this volume and
with Human Interface Guidelines: The Apple Desktop Interface, available through AddisonWesley Publishing Company, Inc., and with the following information found in this volume
and in earlier volumes of /nside Macintosh:
m text manipulation functions in QuickDraw™
a the Font Manager’s support for QuickDraw
m the Binary-Decimal Conversion Package
The TextEdit chapter, later in this volume, provides some examples of how to use the
Script Manager.

ABOUT

WORLDWIDE

SOFTWARE

The Macintosh worldwide system software helps you address the issues you’ll encounter
when you design your applications to be compatible with regional, linguistic, and script differences around the globe. It enables you to create applications that run in other regions or work
with different scripts. Worldwide system software consists of the Macintosh Script
Management System (the Script Manager and one or more script systems) and related
components, including the International Utilities Package, international resources, keyboard
resources, and certain keyboard-handling routines.
As you enter the process of developing applications for worldwide markets, it is important to
consider variations that are specific to script, language, and region. Scripts may differ in the
direction in which their characters and lines run, the size of the character set used to represent
the script, and context sensitivity. Examples of script-specific features include text display,
text rendering, text editing, fonts, input methods, and character set encoding. Examples of
language-specific features include sorting order and word boundaries. Region-specific
features include date and time format, number format, and case conversion. All of these
possible differences are discussed later in this chapter.
Note: Read “An Introduction to Scripts” later in this chapter to acquaint yourself
with the concepts you must understand if you want to create software for writing
systems other than your own.
14-6

About Worldwide Software

Worldwide Software Overview

The

Graphic

Representation

of Languages

The worldwide system software described in this chapter—especially the Macintosh Script
Management System—deals primarily with the graphic representation of language, not with
spoken language. This has implications for the treatment of languages, including the numeric
codes assigned to represent each language. A spoken language that may be written in more
than one script is treated on the Macintosh as several languages: one for each script in which
the language is written. In some cases, this distinction is already present in the names of
spoken languages. For example, Romanian and Moldavian are essentially the same spoken
language; however, in Romania this language is written in Roman script, whereas in the
adjacent Soviet province of Moldavia, this language is written in Cyrillic script. In other
cases, this distinction is not present: the official language of Malaysia may be written in either
Roman or Arabic script, but the spoken language is called Malay in either case. The
Macintosh Script Management System distinguishes the written versions with language
codes (numbers used to indicate particular languages on the Macintosh) such as
langMalayRoman and langMalayArabic.

Localized

Versions

of the Macintosh

System

Software

Localization is the process of adapting software to a particular region and language. This
can include translating text to another language, using the region’s date, time, and number
formats, adapting icons and other graphic elements to the cultural conventions of the target
region, and so on. Although localization often requires language capability in the system
software and may require script capability, it is not synonymous with adding script or
language capability to a system. Localization is an operation that can potentially affect every
part of the system software. For example, the Japanese Script System might be localized for
France so that the text in the Japanese Script System control panels would appear in French.
The Macintosh Script Management System accommodates worldwide differences with the
concept of regions, which provide a finer and more complex level of granularity than script
and language. For example, the French language is used in France, in parts of Belgium,
Switzerland, and Canada, and in other countries such as Luxembourg, Haiti, Mali, Zaire,
Tahiti, and Vanuatu. Each of these areas may have different conventions for time, date, and
number formats. Some differences may also occur in the behavior of the written language.
For example, in France, accents on most characters are generally omitted if the character is
written in uppercase; in Quebec, the accents are usually preserved. A region code is a
number that may designate a region that is conceptually smaller or larger than a country (for
example, “French Swiss” or “Arabic”’), as long as the region shares the characteristics
described above.
Localized versions of the Macintosh system software (including the Roman Script System,
the Macintosh Operating System, the Toolbox, and so forth) combine information specific
to scripts, languages, and regions.
Note:

Currently the following localized versions of the Macintosh system software

are available: Arabic, Australian, British, Croatian, Danish, Dutch, Farsi, Finnish,

French, French Belgian and Luxembourgian, French Canadian, French Swiss,

German, German Swiss, Greek, Hebrew, Hindi (India), Icelandic, Irish, Italian,

Japanese, Korean, Maltese, Norwegian, Portuguese, Simplified Chinese, Spanish,
Swedish, Thai, Traditional Chinese, Turkish, and U.S. Codes for these appear in

“Summary of the International Utilities Package” near the end of this chapter.

About Worldwide Software

14-7

—
eS
o

ae

Qn

=

2.
@
i 2)
o

=P

<=
we

or |
@

Inside Macintosh,

Volume

VI

For more on the process of localization in worldwide software, see the beta draft of Guide to
Software Localization, currently available through APDA.

Multiple Script Systems and
on the Macintosh Computer

Multiple Languages

At least two script systems are always present when a non-Roman script system is installed.
For example, the Japanese system software is the combination of the U.S. system software
(which includes the Roman Script System, the Macintosh Operating System, the Toolbox,
and so forth) and KanjiTalk™ (the Japanese Script System), all of which are localized for
Japan. Localized versions of the Macintosh system software with more than one script
system installed—such as the Japanese system—have been adapted to particular regions,
languages, or countries. However, systems such as the French and Turkish versions are
simply localized variations of the U.S. system software, which do not include a second
script system. With system software version 7.0, script systems may be installed either as
a secondary script (also called auxiliary script), which just provides script capability, or as
the primary script (also called system script), which affects system defaults and is the
script used for dialog boxes, menus, and alerts.
The Script Manager has always supported the simultaneous use of more than one non-Roman
script. System software version 7.0 makes it easier for users to install multiple script systems,
and in version 7.0, script systems function properly even if they are not the system script.
These enhancements provide increased opportunity for your applications to take advantage of
the Script Manager’s handling of multiple scripts.
You may decide to support multiple languages in your applications. Word processors, for
example, might tag a text run with a language attribute in a manner similar to style attributes;
this language tag could then govern the behavior of spelling checkers, hyphenators, and so
on. In addition, you can let users choose a presentation language for your application, that
is, the language for menus, dialog boxes, and alerts.

Identifying

Scripts,

Languages,

and

Regions

Scripts, languages, and regions are organized into a strict hierarchy. The Macintosh Script
Management System distinguishes languages at a finer level than usual. If a language in the
traditional sense can be written in more than one script, each language and script combination
is called a separate language in this context.
Three basic principles underlie the hierarchy of script, language, and region:
mw Every different character set encoding has a different script code. (For historical
reasons, this is not strictly true for some localized versions of the Roman Script
System.)
m Languages always belong to a particular script.
a Region codes always belong to a particular language (a localized version of the system
software is for a particular language in a particular country or other region). Several
regions may be associated with a particular language.

14-8

About Worldwide Software

Worldwide Software Overview

Figure 14-1 illustrates the script, language, and region hierarchy.

United
States

yo

5

| Russian

<at>

| Azerbaijani Lo

><Azerbaijan

©)

Script

C—

Language

<>

Region

or | Persian EX> <>

—

_—
<—
a=

~
=

Law

SS

|

Arabic

Se

|

—

ne
world

lan!
—

A
=

—e

Qu

~@

*—M
-_~

J

=

fom

| Japanese =<

>

a

<

+)

var

fas)

Figure 14-1. The script, language, and region hierarchy
With system software version 7.0 several changes and additions have been made to the
script, language, and region codes used by the Script Management System. Most of the
changes are backward-compatible. See the “Summary of the Script Manager” near the
end of this chapter for a complete list of these codes, including changes to the constant
code names for scripts, languages, and versions.

About Worldwide Software

14-9

|

Inside Macintosh,

Volume VI

About the Script Management

System

The Script Management System consists of the Script Manager and one or more script
systems. Related components of worldwide system software include the International
Utilities Package, the international resources, the keyboard resources, and keyboardhandling routines.
At the center of the worldwide system software, the Script Manager allows different script
systems to be installed, maintains global data structures, supports switching keyboards
between different scripts, supplies several utility routines itself, and provides a standard
interface for programmatic access to script systems. The Script Manager routines allow you
to write your application independently of the particular script in use. Since the Roman Script
System is always installed with the Script Manager, you can use these routines with the
Roman Script System for text manipulation.
The Script Manager provides basic capability in each of the scripts and languages that it
supports. Although TextEdit provides text-handling support when rudimentary text-handling
support is adequate, you will find the Script Manager useful when your applications have no
special knowledge of the particular script or language with which they are dealing. Applications requiring a medium level of text-handling support should use the Script Manager if they
are targeted for non-Roman scripts and multiple countries. Sophisticated text-intensive
applications targeted to a particular language or script may need to go beyond the capabilities
of the Script Manager.
Currently, script systems are available for the Roman, Japanese, Arabic, Traditional Chinese,
Simplified Chinese, Hebrew, Cyrillic, Thai, and Korean scripts as well as for most scripts of
India and Bangladesh, including Devanagari, Bengali, Gurmukhi, Gujarati, and others.
These script systems supply fonts, ways to represent various keyboards, text collation, word
breaks, and the formatting of dates, times, and numbers. Some of these script systems
include special routines for handling exceedingly large character sets, which have comprehensive procedures for character input, and for handling bidirectional or contextual text. See
“Representing Scripts on the Macintosh” later in this chapter for more information.

About the Script Manager
The Script Manager provides
m standard routines for the manipulation of ordinary text
m= ameans to make your application work with many writing systems
m access to and coordination with the International Utilities Package to provide localizable
date, time, and number conversion
New Script Manager features available with system software version 7.0 allow you to
m retrieve font and style information in each script’s local variables
m determine if a double-byte script system is installed
m obtain a pointer to the current 'KCHR' resource
14-10

About Worldwide Software

Worldwide Software Overview

= determine the current region code
a obtain improved information on word boundaries for word selection and line breaking
(using information that individual script systems supply with appropriate tables in the
‘itl2' resource)

m perform more sophisticated and faster word selection and word wrap
m truncate text in a way that improves its adaptation to different scripts and languages
m substitute text in a way that improves its adaptation to different scripts and languages
m perform uppercase and lowercase conversion more easily
m strip diacritical marks
m handle fully justified text with intercharacter spacing and multiple style runs on a line,
using special scaling if desired
m create simple script systems that use the Roman Script System
m use the Keyboard menu to select keyboard layouts
m

install and remove multiple scripts, keyboards, and fonts

m

use new KeyScript verbs to select the next available keyboard within a script, to restrict
the available keyboards temporarily

The features that let you set and retrieve font and style information, determine if a double-byte
script system is installed, determine the current region code, and obtain a pointer to the current
"KCHR' resource are described in “Checking and Modifying Global and Local Variables”
later in this chapter.

—a

_
a

Descriptions of the routines that are new with system software version 7.0 are included in
“Script Manager Routines” later in this chapter.
The following sections supply some background on how the Script Manager

ee

_
-—

=

—

°°
cee

a

<
=
—

‘¢>)

NM
~
=

=
ro

m uses local and global variables to set up an environment in which users can install
multiple script systems

<A

<

)

ser

@

w allows your application to organize text into runs to accommodate more than one script
on a line and in a document
m parses text into tokens so your application can recognize meaningful symbols without
making script-specific assumptions
a lets you localize dates, locations, and times
a allows your applications to localize the display of formatted numbers

About Worldwide Software

14-11

4

Inside Macintosh,

Local

and

Volume V1

Global

Variables

The Script Manager maintains a number of global variables that your application can read with
the GetEnvirons function. These variables can be set by the corresponding SetEnvirons

function. In addition, each script system maintains variables of its own, called local variables.

You can read and set the local variables using GetScript and SetScript.

The Script Manager uses the global variables to set up and maintain the environment. For
example, the global variable smgrDoubleByte, new with system software version 7.0,
indicates if a double-byte script system is installed. Some local variables provide information
on how scripts work; others control how they operate. For example, the local variable
scriptMonoFondSize, new with system software version 7.0, specifies the default monospaced font and its size.
See the descriptions of the GetEnvirons and SetEnvirons functions in Macintosh Worldwide
Development: Guide to System Software for detailed discussions of variables available prior
to system software version 7.0.

Style Runs

and

Higher-Level

Text Organization

All Script Manager text-handling routines are based on the concept of runs (that is, consecutive text with the same attributes) including style runs, script runs, and direction runs. The
Script Manager organizes text into a hierarchy beginning with style (or format) runs. A style
run is a sequence of text all in the same font, size, style, color, and script. A seript run is a
sequence of text all in the same script. A direction run is a sequence of text with characters
having the same direction. See Figure 15-4, “Different Levels of Runs in a Line of Text,” in
the TextEdit chapter in this volume for an illustration of the ordering of style, script, and
direction runs.

Tokens
Programs that parse text (for example, compilers and assemblers) usually assign sequences of
characters to abstract categories called tokens—such as variable names, meaningful symbols,
and quoted literals. The IntITokenize function allows your application to recognize tokens
without making assumptions that depend on a particular script. For example, a single token
for less than or equal to might have two representations in the U.S. system software: the

two-character sequence <= or the single-byte character <. The latter is not available in the

Japanese system software, which instead uses a 2-byte coding for the single character <.
The IntITokenize function handles these details so your application need not be aware of the
differences. The tokenizer identifies the different elements in an arbitrary string of text by
using localized information from the ‘itl4' resource. (The ‘itl4' resource contains the localized
code and resources for the tokenizer. See “The ‘itl4' Resource” later in this chapter for details.)
Certain symbols in the standard Roman character set were not supported in earlier versions
of the system software and had no corresponding token types. With system software
version 6.0.4, the Script Manager added five new token types for some of these characters.
See “Summary of the Script Manager” near the end of this chapter for details.

14-12.

| About Worldwide Software

Worldwide Software Overview

With system software version 7.0, two new token types have been added: tokenEllipsis and
tokenCenterDot. The tokenEllipsis type is used for the character that indicates truncation. The
TruncText and TruncString functions obtain the corresponding default canonical character
from the untoken table in the 'itl4' resource. The tokenCenterDot type is used for the various
forms of the centered dot, such as the one used by AppleShare® for echoing passwords. The
corresponding default or canonical character can be obtained from the untoken table in the
‘itl4’ resource. For the values of tokenEllipsis and tokenCenterDot, see “Summary of the
Script Manager” near the end of this chapter.

Date

Conversion

The Macintosh extended date routines can handle a range of roughly 35,000 years. If your
application needs a large range of dates, you can use system routines rather than produce
your own, which may not be compatible worldwide. Date and time conversion may depend
upon geographic information. For details, see “Date and Time Utilities” later in this chapter.

Geographic

Information

You can also access the stored location (latitude and longitude) and time zone of the Macintosh
from parameter RAM. The Map control panel gives users the ability to change and reference
these values. For details, see “Worldwide Control Panels and Desk Accessory” and “Reading
and Storing Locations” later in this chapter.

Number

Conversion

The Script Manager number routines supplement the Standard Apple Numerics Environment
(SANE®) and allow applications to display formatted numbers and to read both formatted and
simple numbers. The formatting strings allow display and entry of numbers and editing of
format strings, even though the numbers and the format strings may have been entered using

different localized system software. For brief descriptions of the number routines, see “Number

Utilities” later in this chapter. For a thorough treatment of number conversion, see Macintosh
Worldwide Development: Guide to System Software.

About the International

+
—

=

at2.

=
=:
©
N
S

Utilities Package

The International Utilities Package provides sorting routines that support primary and
secondary orderings of characters and other features. The package also handles formats
for the presentation of dates, time, currency, and numbers in regions around the world.
These formats may vary from script to script, language to language, and region to region.
With system software version 7.0, the International Utilities Package includes new routines
that make it easier for an application to supply ‘itl2' or 'itl4' resources, call sorting routines
with explicit specification of an 'itl2' resource handle, provide ways to sort strings that may
be in different scripts or languages, and obtain tables from an ‘itl2' or ‘itl4' resource. See
“Using the International Utilities Package Routines” later in this chapter for details.

About Worldwide Software

—

14-13

=

=
$9
=
@

Inside Macintosh,

About

the

Volume VI

International

and

Keyboard

Resources

The international resources and several of the keyboard resources contain information specific
to language or region, such as date and time formats. You can use multiple formats for _
different languages or regions with the same script system by adding multiple versions of
international resources. Each installed script has an 'itlb' resource and one or more
‘it10', ‘itl1', 'itl2’, ‘itl4', and optional 'itl5' resources, and the resource IDs are generally
in the range used for the script’s 'FOND' resources (except for the 'itlb' resource). The
keyboard resources include some localizable information such as keyboard layouts
(‘KCHR' resources) as well as hardware-specific information (for example, the 'KMAP'

and 'KCAP' resources). The section “Using the International and Keyboard Resources” later
in this chapter includes details on the following resources and on version 7.0 enhancements.
= The ‘itlc' resource is the configuration resource that specifies the system script code, the
size of the keyboard cache, the states of the font force flags, the international keyboard
flag (used for the Macintosh Plus), the general bit flags for the Script Manager, and the
region code (new with system software version 7.0) that identifies a regional version.
ws The ‘itlm' resource (new with system software version 7.0) is the configuration
resource that specifies the preferred sorting order for script codes, language codes,
and region codes, and specifies the default language for each script, the parent
script for each language, and the parent language for each region.
= Each ‘itlb' resource functions partially as the bundle for a particular script: it specifies
the resource IDs for the script’s resources. In addition, it contains the script bit flags, the
default language code, and the number and date representation codes for the script. With
system software version 7.0, the 'itlb' resource also specifies font information, script

initialization data, valid styles for the script, and the style to use for designating aliases.

w Each 'itlO' resource contains short date and time formats and formats for currency and
numbers and the preferred unit of measurement. It also contains the region code for this
particular ‘itlO’.
m Each 'itll' resource specifies the long date format for a particular region, including the
names of days and months. Each 'itll' resource also contains the region code for this
particular ‘itll'. With system software version 7.0, 'itll' has an optional extension for
additional month and day names as well as abbreviated month and day names.
m Each 'itl2’ resource contains the International Utilities Package sorting hooks and
routines and tables for character type, case conversion, and word breaks. With
system software version 7.0, ‘itl2' includes length information for the code and
tables it contains.
m

Each ‘itl4' resource contains localizable tables and code for the IntITokenize function

and localizable number parts tables for the formatted number routines. With system

software version 7.0, 'itl4' has length information for the code and tables it contains,

and it includes a table of white space characters for the script.

m Each 'itlS' resource specifies the character set encoding and rendering behavior in a
script-specific format. This optional resource is new with system software version 7.0.

14-14

— About Worldwide Software

Worldwide Software Overview

m The 'KCHR' resource specifies a logical keyboard layout, that is, the mapping of virtual
key codes to character codes. (It is important to note that changes for different localized
versions of system software occur in the 'KCHR'—not the 'KMAP' resource.) With
system software version 7.0, the U.S. keyboard layout resource, 'KCHR' (0) has
improved consistency with changes in the Command—Caps Lock, Command-dead key,
and Command—Option—Caps Lock key combinations. Also new with version 7.0, the
Script Manager only loads the 'KCHR' resource from the System file. See “The 'KCHR'
Resource” later in this chapter for details.
m The 'kcs#', 'kcs4', and 'kcs8' resources specify keyboard icons for screens of
different bit depths. These resources are new with system software version 7.0 and
replace the 'SICN' resource associated with keyboard layouts in earlier versions of
system software. These icons are used in the new Keyboard menu and in the Keyboard
control panel. See “Using the Keyboard Menu” and “Selecting Keyboard Layouts”
later in the chapter for details. For guidelines for designing your own keyboard icons,
see the User Interface Guidelines chapter earlier in this volume.
ms The 'KCAP' resource specifies the physical arrangement of keyboards and is used by
the Key Caps desk accessory. See “Key Caps and the 'KCAP' Resource” later in this
chapter for details.
a The 'KSWP' resource specifies modifier-plus-key combinations that can be used to
change the keyboard script and the current keyboard layout. New with system software
version 7.0, the 'KSWP' resource can be used to change the keyboard layout within
a script.
a The optional 'itlk' resource provides hardware-specific modifications to keyboard layout
by indicating how to remap certain key combinations. Beginning with system software
version 7.0, the Script Manager only loads this resource from the System file.

About the Macintosh

Script Systems

—

Pay
a

In many cases, the versatility provided by script systems allows applications to be localized
for other scripts, languages, and regions with no change to their program code. (Script
systems are typically localized for a language and region that belong to the script; this affects
the formatting of dates, times, numbers, and so on.) Multiple script systems can be installed
at one time on a Macintosh computer allowing the user to switch back and forth between
different scripts. With system software version 7.0, users can change the active keyboard
script by using the Keyboard menu. The menu is present whenever multiple scripts are
installed or when a localizer sets a flag in the script’s 'itlc' resource. When the Keyboard
menu is present, an icon indicating the presence of the menu and the active keyboard (and
hence the active script) appears near the right end of the menu bar to the left of the Application
menu icon. See “Using the Keyboard Menu” later in this chapter for details.
Figure 14-2 shows the types of script systems currently available. The Roman and Cyrillic
Script Systems are relatively straightforward. These simple script systems represent
writing systems with small character sets that require only single-byte characters, have a text
direction of left to right, and are not context-dependent. Such script systems provide for basic
differences between scripts and related languages, such as character sets, fonts, keyboards,

text collation, and word breaking. The Roman Script System is standard on all Macintosh
computers, and the standard Roman character set includes characters for a number of
European languages.
About Worldwide Software

14-15

=
~
1)

“
—
fol

nse

=

eo

a
@

2)

co
—_
=
ss

=
&

Lew 4

La)

Inside Macintosh,

Volume VI

Script systems

if

it

I

|

i

i

Multibyte
script systems

Contextual
script systems

Bidirectional
script systems

Simple
script systems

Japanese
Chinese
Korean

Devanagari
Bengali

Hebrew

Roman
Greek
Cyrillic

Arabic
|

Urdu

Figure 14-2. Types of script systems
The other script systems represent some of the most complex modern writing systems and go
far beyond basic script support. Japanese, Chinese, and Korean have exceedingly large
character sets, and these script systems have comprehensive procedures for character input.
These multibyte script systems have character sets that are too large to be represented
with single bytes (the character set includes both single-byte and double-byte character codes)
and require an independent font mechanism for display and printing.
Arabic and Hebrew are bidirectional script systems, where text is generally flush right
and is written from right to left, but also includes characters that are written left to right.
Contextual script systems are scripts where the displayed form of a character depends on
the adjacent characters. Arabic and Urdu are examples of contextual script systems.
Each script system determines the components for the script: character encoding; fonts; input
methods; sorting; date, time, and number formats; and script-specific access routines. For
example, each script’s composition rules support all of the necessary features of the script:
direction, conjunct characters, accent placement, and so forth. For further details on Macintosh
script systems, see Macintosh Worldwide Development: Guide to System Software.
Many script systems also have a control panel or a desk accessory to allow the user to
configure the individual characteristics of the script system at any time. (Simple script
systems do not generally have such a control panel.)

The

Script

Management

Worldwide

Components

System

and

Related

Figure 14-3 illustrates all the related worldwide system software components, including the
Macintosh Script Management System, which consists of the Script Manager and one or
more script systems. Each script system contains its own script system routines (including
special font-mapping routines, if necessary), fonts, international resources (‘itlb’, 'itl0',
‘itl’, ‘itl2', ‘itl4', and optional

14-16

'itlS'), keyboard

About Worldwide Software

resources

('KCHR’,

'kcs#', 'kcs4', 'kcs8',

Worldwide Software Overview

Keyboard

Keyboardhandling

-

|

routines

Script
Manager

resources
ie
)

Samii

KSWP'|

Select resources
q_Use data
International
resources

International
Utilities

Package

‘itlc’

‘itlm'

= Script-system specific

i

= Unique resources (only one of each,
control overall operation of
Script Management System)

—

PS
a
atl
=
=

=“
—

2.

Figure 14-3. The components of the Macintosh Script Management System

<
<=
rs
~
—

and optional ‘itlk'), and one or more optional script-configuration control panels. In addition,
each script system may replace one or more of the unique system resources 'KSWP’, 'itlc’,

and ‘itlm'. The arrows between the components in the figure illustrate the flow of action and
information between the Script Manager and other worldwide components.

Here are some examples of the interaction of these components.
m The Script Manager frequently calls routines in the International Utilities Package, such
as the [UGetIntl function, to take advantage of information stored in the international

resources. For instance, the Script Manager’s LowerText procedure uses data in the
‘itl2' resource for case conversion.

a The International Utilities Package also uses the international resources. For example,
the [UTimeString procedure utilizes the 'itl0' resource for its time information, and the
[UCompString function applies information from the 'itl2' resource in its string
comparison.
About Worldwide Software

14-17

a>)

ZN
~
~

—_

ms

=
<=
as
~
a;
@

Inside Macintosh,

Volume

—=

VI

zal pas

Scriptconfiguration
control panel

: Arabic Interface a stem §
(ixpidy
se dheg KK)
wale]

Geel
pe HLS [X]

ow Lo (o)

$US awl OQ)
eS wha

dgdl asl 5
GW

Mark Davis
Lue Michel Six
Hesham

Map
control panel

pl
ee

Abu El-Ata

C.

yutinw

L]

sel Bx]

ay

=,l0

Jitia Sa

Lhe el) gui aL

AAs AIS, ABI- 6.0

[fae fitz] (Remove City]

¥ 7.0

Portland

contel pane!
SS

QOoO0O8o

Slow

Fast

45

Longitude

221".

b fone

L"

eee

Key Repeat Rate

Latitude

Delay Until Repeat

Oo

O@8O00

Off Long

Short

pyO

|° [33 | BAN
36c"
ho

a
1:41

PM

Bee oe esory

Keyboard Layout

@

at

Figure 14-4. Worldwide control panels and desk accessory

14-18

| About Worldwide Software

[elk
rm {_] +

Worldwide Software Overview

mw When the user changes the keyboard script, the Script Manager alters information in the
keyboard driver data structures and loads the selected 'KCHR' and possibly an ‘itlk'
resource for use by the KeyTrans function. The Script Manager also updates the
Keyboard menu data structures.

Worldwide

Control

Panels and

Desk Accessory

Figure 14-4 shows examples of worldwide control panels and the Key Caps desk accessory,
including a script-configuration control panel.
a A script-configuration control panel lets users specify different features in a script
system. The Arabic Script System control panels shown in Figure 14-4 let the user
specify alignment, the font for Roman text, and the type of calendar to be used. Another
example of a configuration control panel (not shown) is the Japanese Script System
control panel that allows users to specify input methods for Japanese characters.
m= The Keyboard control panel allows users to specify a particular keyboard layout and to
control the way keyboards operate.
= The Map control panel lets users indicate the location of their Macintosh computer.
= The Key Caps desk accessory shows the active keyboard layout in a particular script
using a specified font. See “Key Caps and the 'KCAP' Resource” later in this chapter
for details about version 7.0 enhancements, including dead-key feedback and additional
key shapes.

Installing and Removing
Keyboards, and Fonts

Script Systems,

With system software version 7.0, the user installs each non-Roman script system with an
Installer that permits users to install the script as a primary or secondary script. Also, the

Finder™ allows users to add or remove secondary script systems. The Finder permits users

to move a collection of script resources into the System file. Also, if a script system has not
been enabled, users can take the script system’s resources out of the System file. When the
Finder moves a collection of script resources, it transfers the resources specified by the
script’s 'itlb' resource: the ‘itlO', ‘itl1', 'itl2', ‘itl4', optional 'itl5', 'KCHR', 'kcs#', 'kcs4',
and 'kcs8' resources. When the System file is opened, any scripts that can be moved out of
the System file are displayed. Figure 14-5 shows the icon representations for various scripts,
keyboards, and fonts.
| @

file

Edit

Font

Style

Format

SSS]system

eI

=

|

|
Keyboard

cs)
i

Script

iS)
Z

Geeza
|

Font

Figure 14-5. Default icons for keyboards, fonts, and scripts
About Worldwide Software

14-19

—

a
—
~
=
—:
“
=
=
<
—
aos
@
—

72
~
=

=

—_

=
<
ary)
or
@

Inside Macintosh,

Volume V1

The user can also move keyboards (that are not part of a script resource collection) and fonts
into and out of the System file. When the System file is opened, any fonts and keyboards that
can be moved out are listed, also as shown in Figure 14-5. See the Finder Interface chapter
in this volume for details about the file types of fonts and about moving fonts.
Users can install a script system with the Finder and move a script resource collection, any
additional keyboards, and fonts into the System file. Some script systems may also require
a file of type 'scri’ containing 'INIT' resources; this must be put into the Extensions folder
inside the System Folder.

Using

the

Keyboard

Menu

With system software version 7.0, a new menu, the Keyboard menu, displays a list of
all the keyboard layouts available in the system. (See Figure 14-6 for an example of the
Keyboard menu.)
Note: The Keyboard menu displays the keyboard layouts that belong to any script
systems that have been installed and enabled. If you place a 'KCHR' resource in
your system that does not belong with any of the script systems you have installed,
the Keyboard menu does not display that 'KCHR’.
For example, if you install German, French, Japanese, and U.S. 'KCHR' resources
in a system that only contains the Roman Script System (that is, any generic U.S.
system) and set the appropriate bit in the 'itlc’ resource, only the German, French,
and U.S. keyboards are displayed in the menu.
The Keyboard menu groups the keyboard layouts by script. The script groups are delineated
by gray lines. In Figure 14-6, the Roman script includes two keyboard layouts (Spanish and
U.S.); the Hebrew script contains a single keyboard layout; and the Japanese script includes
two keyboard layouts (Kana and Romaji).
The Keyboard menu appears if there are multiple script systems installed in the system or if
the smfShowlIcon bit in the Script Manager flags long word is set when system menus are
initialized during system startup. The Script Manager initializes the smfShowIcon bit from the
flags byte in the 'itlc' resource earlier in the system startup process. If the menu is available at
startup, the keyboard icon for the system script’s default keyboard appears in the menu bar to
the left of the Application menu icon.
Each menu item includes a keyboard icon and the name of the keyboard layout (which may be
in anon-Roman script). In Figure 14-6, the Hebrew keyboard icon—a star of David—is to
the left of the Hebrew name of the keyboard layout and to the right of a checkmark that
indicates that this is the current default keyboard in the active keyboard script.
The list of keyboard layouts corresponds to the script ordering specified in the 'itlm' resource.
Within each script, the keyboards are listed in the script’s sorting order. The system script’s
keyboards always appear first in the list. In Figure 14-6, the system script is Roman, so the
Spanish and U.S. keyboard layouts appear first.
The keyboard icons that appear in each menu item are defined by the new keyboard color icon
family: 'kes#', 'kcs4', and 'kcs8'. If a keyboard layout does not include a keyboard icon
when it’s installed in the system, a default keyboard icon is used.
14-20

About Worldwide Software

Worldwide Software Overview

For each script there is a current default keyboard. The default keyboard for the active
keyboard script is the active keyboard and is indicated by a checkmark. In Figure 14-6,
the active keyboard layout is Hebrew.
Figure 14-6 shows the Japanese Kana keyboard layout being selected. When the mouse
button is released, the Kana keyboard icon will appear in the menu bar. When the About
Keyboards item at the top of the Keyboard menu is selected, a dialog box appears with

additional information about the menu and changing keyboards. Balloon Help™ is also
available for the Keyboard menu.

[| #

Drv

fe

—BR

Keyboard icon for active
|
keyboard script

ANSi
+ lb

a]
+

About Keyboards...

Script

seesecees

Keyboard layout for

active script (Hebrew)

Ya
OOO E ERROR E RRO

boundary

nssoy
E ORR E EERE EE TORE N ERE EE eee eRe ean

eeee

E— Espanol

@
Figure

14-6. The

US

Keyboard

menu
—

Selecting

Keyboard

Layouts

i

a
=
~
A

a
val
—
a“
<
_s
=~
—

Several ways are available to select different keyboard layouts:

tee

m Selecting the desired layout from the Keyboard menu.

a)
r

mw Using keyboard equivalents such as Command-—Space bar to switch to the next available
script and the current default keyboard for that script.
w Using the Keyboard control panel to select the keyboard for the active keyboard script.
If the Keyboard menu appears and the user selects a new keyboard layout, the Keyboard
menu data structures are updated so the Keyboard menu reflects the new selection.

Distinguishing

Scripts

Each script is distinguished by a unique script code. The script codes currently defined are in
the range 0-32, although the Script Manager can support 64 scripts at the same time. The
resource ID number for a script’s 'itlb' resource is the same as the script code. The resource
ID numbers for the other resources associated with a script are in a range specific to that

About Worldwide Software

14-21

L
=

=
a
i
<=

&

Lar

@

|

Inside Macintosh,

Volume VI

script. For Roman, this range is 0-16383. Scripts with script codes in the range 1-32 have
a range of 512 resource ID numbers beginning at 16384 + 512 * (script code — 1). Scripts
with script codes in the range 33-64 have a range of 512 resource ID numbers beginning at

—32768 + 512 * (script code —33). For example, the script code for Korean is 3, so Korean

resources have resource IDs in the range 17408-17919. Figure 14-7 illustrates the font
ranges for the Roman, Japanese, and Devanagari scripts. A full table of resource ID ranges is
provided in the Resource Manager chapter in this volume.
Note: Some script codes above 32 are not usable because they correspond to
resource ID ranges that are reserved for other purposes. Script codes 33 through 40
are invalid; furthermore, script codes above 48 are currently unavailable and may
become invalid.
Resource ID range

$0000

7

Roman script has

— Script 0 (Roman)

a range of $4000

(16384) IDs

S

4000
$003

~

—Scri
Script 1 (Japanese)

5200

~

3— Script 9 (Devanagari)

5400—

Other scripts each have
a range of $200
(512) IDs

$8000

Figure 14-7. Distinguishing scripts with resource ID ranges for script codes 0-32

14-22

About Worldwide Software

Worldwide Software Overview

The font used for text indicates the script for that text. A text string in a font with a 'FOND'
resource ID of 200 is interpreted as Roman text, while the same text string in a font whose
'FOND' ID is 18432 is interpreted as Hebrew text and displayed accordingly. The meaning of

each character code depends on the font. In an Arabic font, the code $CC represents the

character ¢ (jiim), while in a Roman font, the code $CC represents the character A. However,
character codes $00 through $7F are always interpreted the same way—except when they are
the second byte of a double-byte character (codes $00 through $1F are never the second byte
of a double-byte character). For historical reasons within the Chinese and Roman Script
Systems, even within a given script, the meaning of character codes may depend on the font:
the Symbol font is in the Roman script range, but character codes in the Symbol font have a
different meaning from the same character codes in the Geneva font. This situation now only
occurs in the Roman Script System. The Traditional Chinese and Simplified Chinese Script
Systems are different script systems and use different character set encodings, but until
recently they shared the same script code.
There is an additional consideration for 'FOND' resource IDs. The special 'FOND' resource
IDs 0 and | specify the Macintosh system font and the default application font and do not
necessarily indicate a Roman font and the Roman Script System. On Roman script systems,
the Chicago font is the system font, and it has a'FOND' ID of 0. On non-Roman script
systems, Chicago has a different 'FOND' ID (usually 16383), and 'FOND' ID 0 is mapped
to the system font for the appropriate non-Roman system. On the Japanese Script System, for
example, 'FOND' ID 0 is mapped to the Osaka font, which has a 'FOND' ID of 16384.
The script can be determined by just the 'FOND' ID. Therefore, even when an entire font
family is missing, the Font Manager can still substitute a font of the same script.
A

Warning: If anon-Roman font has a'FOND' ID with an ID in the Roman
range, it will not be handled correctly. a

Keyboards

—

=

The Macintosh keyboard routines handle the keyboard properly for script systems. Except for
purely hardware-specific characteristics, the function of the keyboard is completely determined
by keyboard character tables in the keyboard layouts. These are resources of type 'KCHR'
with an optional associated resource of type ‘itlk'. Each table specifies the character produced
by each key in combination with each modifier key (Command, Shift, Caps Lock, Control,
and Option). In addition, the 'KCHR' resource also handles dead keys by means of additional
subtables. Dead keys are the modifier-plus-key combinations that usually produce no
immediate effect but instead affect the character or characters produced by the next key—
called the completer key—that is pressed. For example, pressing Option-E produces nothing
(no event is posted), but subsequently typing E produces @.

Note that you can edit the 'KCHR' resources by using ResEdit™. For details on all the
keyboard resources, see the relevant sections under “Using the International and Keyboard
Resources” later in this chapter.

About Worldwide Software

— 14-23

<

eo
S

S
a

<

ite
—
(ao)

ZN

=)

=
_

=

+)
—

@

Inside Macintosh,

Volume V1

Figure 14-8 illustrates the process of keyboard translation. Keyboards produce raw key
codes. The hardware-dependent 'KMAP' resource is then used to map these key codes to
hardware-independent virtual key codes and to set bits indicating the state of the modifier
keys. (If you do not have access to the MPW® file SysTypes.r, which contains a Rez
type definition of the 'KMAP' resource, consult Macintosh Developer Technical Support
for details.)

The 'KCHR' resource specifies how to map a modifier state and a virtual key code to a
character code. It includes information on how to process dead keys.
The optional 'itlk' resource specifies how to remap certain key combinations on certain

keyboards before the 'KCHR' mapping is used. The 'itlk' resource transforms this

information based on which keyboard is in use and reintroduces hardware dependence
because certain scripts, languages, and regions need subtle differences in layout for
specific keyboards. Generally, the 'itlk' resource only affects a few keys.

The 'KCHR' and 'itlk' resources are used by the KeyTrans function.
Note: Do not change the 'KMAP' resource because everything you need is in the
'KCHR' and ‘itlk' resources. You only need to work with 'KMAP' if you are
making your own keyboard.

Raw keycode

Keyboard type

specifies which

'KMAP'

.

‘KMAP'

Modifier |

>
4

| Virtual key code ~

‘tlk’ (optional)

feel] ls
ter |

ew modifi

KeyTrans
Figure

14-24

14-8.

About Worldwide Software

‘

i
et
ew virtua
|| Now

‘KCHR'

function

|

|

re.

Character code

Keyboard

translation

ey code

Char code

|
Event

message

Worldwide Software Overview

The net result of the process of keyboard translation illustrated in Figure 14-8 is a virtual
keycode and a character code. See “The 'KCHR' Resource” later in this chapter for details
about the internal structure and the function of the 'KCHR' resource.
The 'KSWP' resource specifies which modifier-plus-key combinations you can use to
change scripts and keyboard layouts within scripts. For example, the standard 'KSWP'
resource specifies that pressing Command-—Space bar changes the keyboard to the default
keyboard for the next script. For details on these keyboard resources and other keyboard
issues, see “Using the International and Keyboard Resources” later in this chapter and
Macintosh Worldwide Development: Guide to System Software.

Fonts
Fonts share the following attributes across all script systems:
a Single fonts, although belonging to a single script, may contain characters from multiple
scripts (typically Roman plus the font’s native script). A script system may substitute a
Roman font for some of the character encodings, typically the 128 ASCII low-order
codes. In this case, the font routines that return information, such as the ascent or
descent, have been modified to return the proper information, usually the maximum of
the corresponding values for the two fonts.
m Fonts may have zero-width characters. These are usually overlapping diacritical marks,
which typically follow the base character in memory (also called backing-store order).
With double-byte characters, all but the first (high-order, low-address) byte are
measured as zero width (for example, with the MeasureText procedure).
m Since the script systems are built on top of the Toolbox graphics routines, all of the
normal QuickDraw font features are usually available on the screen and when printing,
including styles (bold, italic, and so on), variable sizes (12 point, 18 point, and so on),
and multiple font families. Certain styles may be disabled in some scripts.

cot

ee
<

=
o

as

=
<

<

LOCALIZATION

md

=
@

WN
S

ec)
a
a

Localization involves the adaptation of an application to a specific region or language. To
create software that is easy to localize, it is first important to understand certain concepts
regarding sorting and the formatting of dates, times, currency, measurement, and numbers,
described in the sections that follow. See “Localizing to Other Languages and Regions”
later in this chapter for specific guidelines on the use of text, fonts, sorting, and date and
time display.
The process of localization includes the specification of the system script. The system
script is the script that determines the system font used for menus and dialog boxes and
the default application font for documents, among other things. It also determines the
default line direction.

Localization

14-25

<

&

sz]
oO

Inside Macintosh,

Volume VI

Sorting
String sorting is used in a number of places in the Macintosh Operating System (for example,
in a standard file dialog box) and in applications (for instance, spreadsheets). When performing such sorting, it is important to order strings in the manner expected by the user—that is,
according to the rules of the language and region for which the system is localized. The
International Utilities Package provides several routines that compare two strings and indicate
whether the first should be sorted before, after, or at the same place as the second string. For
details, see “Using the International Utilities Package Routines” later in this chapter.
Sorting or comparing strings can be an extremely intricate operation. Subtle issues like expansion, contraction, ignorable characters, and exceptional words may be taken into account.

Sorting cannot be done properly by a simple table look-up, even for such straightforward
cases as English. Sorting depends not just on the script, but on the individual language. While
broad similarities in sorting exist between languages that share the same script, definite variations between languages must be taken into account.
The Script Manager, the International Utilities Package, and international resource 'itl2' have
long provided for many sorting issues, including primary or secondary order, expansion,
contraction, and ignorable characters. With system software version 7.0, several new sorting
capabilities provide support for systems with multiple installed scripts and language capabilities.
m You can sort strings in different scripts and languages. See “Determining Interscript
Sorting Order” later in this chapter for details.
= A new international resource, 'itlm', indicates the preferred sorting order for scripts,
languages, and region codes, and indicates how to map region codes to languages and
language codes to scripts. See “The ‘itlm' Resource” later in this chapter for details.
m You can explicitly specify the handle of the resource to be used for sorting. This is
helpful for multilingual systems. See “Specifying Resource Handles Explicitly” later
in this chapter for details.
m The ‘itl2' and ‘itl4' resource handles for all active scripts are cached by the Script
Manager. You can call a routine to clear the cache so application-supplied resources
can be used. See “Manipulating the ‘itI2' and 'itl4' Resources” later in this chapter
for details.

Primary

or Secondary

Order

Sorting order is determined by a ranking of the entire standard Roman character set. This
ranking can be thought of as a two-dimensional table. Each row is a class of characters—for
example, all of the forms of uppercase and lowercase A with and without various diacritical
marks. The characters are ordered within the row, but that ordering is secondary to the
primary ordering of the rows themselves. For example, all of the forms of A precede all of
the forms of B, as follows:

A<A«<a<a
B<b

14-26

Localization

Worldwide Software Overview

Primary sorting characteristics denote a strong ranking; if any primary differences are
present, all secondary differences are ignored. For instance, only primary sorting is needed
to determine that abc precedes bc. Secondary sorting characteristics indicate that if certain
differences are present, a second pass is made that introduces a weak ordering. Here’s
an example:
abc < abc.

Expansion
A single character may be sorted as if it were a sequence of characters. First, the single
character is expanded; then the primary sorting occurs based on this expansion. In the
secondary sorting, the characters are recombined. For instance, d in German may be
sorted as if it were the two characters ae, as in this example:
bak < baek < biks

Contraction
A sequence of characters may be sorted as a single character. For instance, ch in Spanish may
be sorted as if it were one character that sorts after c, as in this example:
czar < char< dar

Ignorable

Characters

Certain characters should be ignored unless the strings are otherwise equal. In other words,
they have no effect on primary sorting, but they do influence secondary sorting. Examples
of ignorable characters in English are hyphens, apostrophes, and spaces. Here is an example
of how a hyphen influences secondary sorting:
—

blackbird < black-bird < blackbirds

<

=

Exceptional

~

=

Words

a.

Sometimes the sorting order changes drastically for special cases. For instance, when words
are understood to be abbreviations, the strings are sorted as if they were spelled out.
McDonald < Mary
St.

{McDonald is treated as MacDonald}
{Thus, MacDonald < Mary }

James < Smith

{St. is an abbreviation for Saint}

Easy Step < Easy St.

{St. is an abbreviation for Street}
{Easy Step < Easy Street}

—

ZN
o

=
a

=

pe)
_

@

{Saint James < Smith}

Such cases require a direct dictionary look-up and are not handled by the Macintosh Script
Management System. Note that abbreviations are context-dependent; for example, St. may
denote Saint or Street, depending on the meaning of the adjacent text.

Localization

=—

ie*)

14-27

Inside Macintosh,

Volume VI

Formats
The following sections discuss the enormous differences in the forms of dates, times, and
numbers. These differences should all be considered and accounted for when using
worldwide system software, particularly the Macintosh Script Management System.

Date

and

Time

Formatting dates and times for a particular script and region requires the specification of
the elements in the date or time, the number of digits used for each numeric element (for

example, 3/01/90 or 3/1/90), the names of the months and the days of the week, and other
characteristics such as the order of the elements and the use of A.M. and P.M. instead of a
24-hour clock.

Each ‘itl0' resource contains short date and time formats. Each ‘itll' resource contains long
date formats. With system software version 7.0, the ‘itll’ resource can be optionally
extended to contain a list of extra day names for calendars with more than 7 days, a list of
extra month names for calendars with more than 12 months, a list of abbreviated day
names, a list of abbreviated month names, and a list of additional date separators. See
“The ‘itl0' Resource” and “The ‘itll’ Resource” later in this chapter for details.

Currency

and

Measurement

Currency formats include the specification of the currency indicator (for example, $, £, or
DM) and whether it precedes or follows the value. Units of measurement can be specified

as metric or imperial (inches and miles). Each 'itlO' resource contains formats for currency
and indicates the preferred measurement unit. See “The ‘itlO0' Resource” later in this chapter
for details.

Calendars
Although it is very accurate and on the whole conforms to natural phenomena, the standard
Gregorian calendar used in Europe and the Americas is not universally accepted. For
example, different calendar systems are often used in Japan and the Arabic world.
For instance, the Arabic calendar is lunar rather than solar. The months are alternately 29
and 30 days long, so the Arabic calendar year is about |1 days shorter than the Gregorian
year. The months have no fixed relation to the sun, so they slowly rotate through all of the
seasons of the year (that is, every three years the months shift forward one month). The
Arabic calendar is used extensively throughout the Middle East. Examples of other calendars
include Chinese, Coptic, Japanese, and Jewish.
The Macintosh represents dates in memory as the absolute number of seconds since January 1,
1904. For more on this topic, see the discussion “Working With Date Formats and Calendar
Conversion” in Macintosh Worldwide Development: Guide to System Software.
With system software version 7.0, the 'itl1' resource has been extended to contain an
optional calendar code. Multiple calendars may be available on some systems, and it is
necessary to identify the particular calendar for use with the ‘itll’ resource. Constants
for the various calendars are listed in “Summary of the Script Manager” near the end
of this chapter.
14-28

Localization

Worldwide Software Overview

Numbers
Scripts differ in many aspects of the representation of numbers, so you need to make allowances for different formats of numbers. The Japanese script, for instance, uses the standard
ASCII Western digits, double-byte encodings of the same Western digits, and native
Japanese number characters, which occur in both a standard and a nonforgeable form—
that is, a form that cannot be converted into another digit by the addition of strokes (used
for financial instruments and so forth). Each 'itlO' resource contains formats for numbers.

AN

INTRODUCTION

TO

SCRIPTS

A script, as used in this chapter, is a writing system for a human language. There are about
30 living scripts that are used to represent the official languages of one or more regions and
countries. Examples of writing systems are Roman, Chinese, Japanese, Hebrew, and Arabic.
They all have distinct attributes. Simple scripts, such as Roman, Greek, and Cyrillic, usually
have fewer than 256 characters; the Japanese script theoretically contains more than 40,000.
The characters of printed Roman are relatively independent of each other; Arabic characters
change shape depending on the characters that surround them.
Scripts may vary in other attributes: the direction in which their characters and lines run, the
size of the character set used to represent the script, and the context sensitivity of the script.
Some scripts, such as Japanese, actually include multiple subscripts. (A subscript is a
distinguishable subset of characters that is included within a script. Subscripts in the
Japanese script include Hiragana, Kanji, Katakana, and Romaji.) Each of these attributes
significantly affects the script’s representation on the computer, and each is discussed in
the following sections. Figure 14-9 shows notations for the names of various scripts,
languages, and regions in the appropriate script.

=

mm
=a

7

zi

nad
Rimski

<=

°
es

my

=

=

-¥
©

NM

S
>
<=
ey
a
i)

edt 1S Ae
EAAAX

Figure 14-9.

fe-ar

Scripts

An Introduction to Scripts

— 14-29

Inside Macintosh,

Character

Volume VI

Representation

Scripts differ in the kind and number of characters they require to represent words. Some
scripts are basically alphabetic: the characters in the script symbolize, more or less, the
discrete phonemic elements in the languages represented by the script. Other scripts, such
as Japanese Hiragana and Katakana, are syllabic: the characters stand for syllables in the
language. The languages that syllabic scripts represent tend to have relatively simple syllables.
Other scripts—namely, Japanese Kanji, Chinese Hanzi, and Korean Hanja—include
ideographic characters. These do not represent pronunciation alone, but are also related
to the component meanings of words. A typical character set for ideographic scripts is
quite large, ranging from 7,000 to 30,000 characters. Obviously, a standard single-byte
encoding (limited to 256 distinct values) cannot be used to represent these characters,
nor can a keyboard be used to enter so many characters directly.
Figure 14-10 shows examples of alphabetic, syllabic, and ideographic character
representations.

Rimski
Figure 14-10.

Text

(Cli A, 7

:

Alphabetic, syllabic, and ideographic representations of characters

Direction

Scripts also vary in the direction in which characters are written. In Roman scripts, characters
are inscribed from left to right, with horizontal lines of characters written from top to bottom.
However, scripts like Arabic and Hebrew have most characters written from right to left,
although the horizontal lines of text are still written from top to bottom. In Japanese and
Chinese, characters are traditionally written from top to bottom, with vertical lines (columns)

of characters written from right to left. Figure 14-11 shows three text directions. These three

script types (that is, left-right top-bottom, right-left top-bottom, and top-bottom right-left) are
the most common of the eight possible combinations of character and line directions.
Different scripts can occur in the same line on a screen. Thus a line of text containing both
Arabic and English is actually bidirectional: some characters go from left to right, and some
from right to left.
The Macintosh script systems, accessed through the Script Manager, provide the capability to
write from right to left, as required by Arabic, Hebrew, and other bidirectional scripts, to mix
right-to-left and left-to-right directional text within lines and blocks of text, and to use
ideographic text. Your application can add the capability to handle vertical text, if desired.

14-30

— An Introduction to Scripts

Worldwide Software Overview

>

<a

The Macintosh

2

jue ey

sousidd |
[pamesst]

ao |

yee

Left-right

me

carey

ark

ya

>

L

:
YX

Y

|feege teik of
Gt

h

Top-bottom

top-bottom

Figure 14-11.

G)

Cc

Right-left

top-bottom

Contextual

;

right-left

Three text directions

Forms

The displayed form, or glyph, that represents a character in printed English does not usually
depend on bordering characters. This is not the case for many scripts. Even in cursive English,
for example, when one letter is joined to the preceding letter, the connecting line varies
according to which letters are being joined. Characters may also have considerably different
shapes depending on where they occur within a word, for example, at the beginning (initial
form) or elsewhere in the word (noninitial form). Figure 14-12 illustrates two of these

variations in cursive English, which are called contextual forms.
Initial form

a

Non-initial forms

if ca

—

pe
<

=
~
-

ax |

~~
-!
es

<

<

Figure 14-12. Contextual forms in cursive English

ry
@

The ability to represent contextual forms is required for the proper display of Arabic text.
Figure 14-13 shows stand-alone and contextual forms in Arabic.

ZN
=)
=
-

=

+)

gx |
ces)

Stand-alone form

Pp
>

Figure 14-13.

Contextual forms

tA +
®

e

”

Stand-alone and contextual forms in Arabic

An Introduction to Scripts

— 14-31

Inside Macintosh,

Volume VI

Furthermore, certain character forms may be combined into a new form when they occur
together. Figure 14-14 provides an example of how characters combine to form ligatures
or conjunct characters in Roman text.

f4+i—-fi-fi
Figure 14-14.

A ligature in Roman

text

The use of ligatures can be highly developed in Arabic text, and some ligatures are required for
the proper display of Arabic text. Figure 14-15 provides examples of ligatures in Arabic text.

b+ J Ltt
Figure 14-15.

omy

Ligatures in Arabic text

In script systems, context dependence means that character forms may be modified by the
values of preceding and following characters in the input stream. In Arabic, the displayed
form of many characters changes depending on other characters nearby. Context analysis is
usually handled by the script system under the control of the Script Manager.

Diacritical

Marks

Many scripts use diacritical marks, that is, signs that modify the implicit sound or value
of the characters with which they are associated. Some diacritical marks are often referred
to as accents in Roman scripts: the acute accent in é, for instance. Others, such as certain
Vietnamese diacritical marks, may indicate pitch, while certain Arabic diacritical marks, such
as shadda, specify the doubling of consonants. See Macintosh Worldwide Development:
Guide to System Software for details on diacritical marks available in the standard Roman
character set. With system software version 7.0, routines are provided that strip diacritical
marks. See “Converting Case and Stripping Diacritical Marks” later in this chapter for details.

Uppercase

and

Lowercase

Characters

English speakers are familiar with uppercase and lowercase characters in Roman script;
however, the majority of the world’s scripts do not have separate uppercase and lowercase
forms. The implications for computer applications are primarily in the areas of searching,
sorting, and proofreading (for example, spell-checking). With system software version 7.0,
routines are provided that perform uppercase and lowercase conversion. See “Converting
Case and Stripping Diacritical Marks” later in this chapter for details.
14-32.

An Introduction to Scripts

Worldwide Software Overview

Note: In the Roman script, different languages (and even different regions or
countries that use the same language) have different conventions for the treatment
of accents and diacritical marks on uppercase characters.

Character

Reordering

Principles of text ordering differ according to the type of script under consideration. With

Roman and simple scripts (such as Greek and Cyrillic) as well as bidirectional scripts (such

as Arabic and Hebrew), phonetic and writing order are synonymous except for vowel signs
and other marks. With certain Southeast Asian scripts, there may be significant differences
between phonetic and writing order.
Figure 14-16 shows an example of the reordering of vowels for the word hindi in the
Devanagari script. The box on the left illustrates the phonetic order of the characters, whereas
the box on the right depicts their writing order. The consonants in this example take a default
vowel (a). To modify the vowel, you add a vowel marker. Some vowel markers are written
to the right of the consonant they modify; others are written to the left, above, or below.

Phonetic order

h(a)+ i

n(a)

Writing order

d(a)

+ i

i ohon

di

Figure 14-16. Character reordering in Devanagari script (for the word hindi)

—

pay
a

Word

—
i)

Demarcation

ree
~
—

Words in Roman scripts are generally delimited by spaces and punctuation marks. In
contrast, many Asian scripts (for example, Japanese and Thai) typically have no word
delimiters, so the Script Manager provides a more sophisticated method of finding word
boundaries. (For details, see Macintosh Worldwide Development: Guide to System
Software.) System software version 7.0 generalizes and speeds up the Script Manager
FindWord procedure that supplies the word demarcation mechanism. See “Localizing
Word Selection and Line Break Tables” later in this chapter for details.

Alignment and Justification of Text
Alignment is the horizontal placement of lines of text with respect to the left and right edges
of the destination rectangle. Alignment can be flush left, flush right, centered, or justified
(that is, flush on both left and right edges of the destination rectangle). TextEdit supports text
alignment that is flush left, centered, flush right, and flush according to the line direction of
the script. TextEdit does not support fully justified alignment. The Script Manager supplies
routines you can use to provide support for fully justified text in your applications.

An Introduction to Scripts

— 14-33

<
<=

2.
@

DM
o

or

=

tev)
“
o

Inside Macintosh,

Volume

VI

Justification (or fully justified alignment) is the spreading or compressing of printed text to
fit a given line width. It is usually performed in Roman text primarily by altering the size of
the interword spaces. Arabic, however, inserts extension bar characters between joined

characters and widens blank characters to fill any remaining gaps. Scripts that don’t use
interword spaces must modify the intercharacter spacing. The Script Manager provides
routines that take these justification methods into account when drawing, measuring, or
selecting text. The justification is done by the script systems themselves. See “Handling
Justified Text” later in this chapter for details.

REPRESENTING

SCRIPTS

ON

THE

MACINTOSH

Worldwide system software makes it possible to represent many scripts and languages on
the Macintosh. The Macintosh Script Management System extends the Macintosh computer’ s
text-manipulation capabilities beyond Roman scripts. Character representation and the
keyboard are the first components to be considered when attempting to represent any script
on a Macintosh computer.

Character

Set Encoding

Character set encoding refers to the numeric codes that represent the characters of a
script in memory. The character set encoding for a script determines the behavior of many
of the features of the script, including sorting and composition rules for drawing and
measuring. Therefore, the character set encoding is fixed; it cannot be changed without
significant consequences. For example, features such as sorting depend on the fact that
the coding does not change.
Most scripts fit within the limits set by the size of a byte, with up to 256 distinct characters.
Scripts with ideographic characters, such as Chinese, Japanese, and Korean, need more than
256 distinct characters.
A variety of solutions have been implemented for scripts that require 2-byte codes for
computer storage in addition to or in place of the 1-byte codes that are sufficient for Roman
scripts. Proper use of the Script Manager routines permits your application to run without
knowing whether |-byte or 2-byte codes are being used, as long as it has been written to
allow the possibility of 2-byte codes.
A

Warning: Typically, ideographic scripts use a mixture of single-byte and
double-byte encodings to represent characters; therefore, you cannot use the
terms byte and character interchangeably. a

Note: Currently, every different character set encoding does not have a different
script code. For example, the Symbol font is in the Roman range but has a different
character assignment. Before system software version 7.0, the traditional and
simplified Chinese systems used different character codings, but had the same script
code (2). With system software version 6.0.5, these systems have been assigned
separate script codes: smTradChinese (2) and smSimpChinese (25).

14-34

— Representing Scripts on the Macintosh

Worldwide Software Overview

Character

Input

Character input is often more complicated than simply providing a keyboard layout.
Ideographic scripts such as Japanese cannot simply use a larger keyboard or multiple
dead keys for effective input. The sheer number of characters demands a more complex
solution, such as providing ways to transcribe phonetic text into ideographic text. Most
ideographic script systems provide for the complex parsing of phonetic sequences and
character clusters.

Composition

Rules

Each script system contains composition rules that determine the behavior (that is, the visual
appearance) of text when it is drawn, measured, or edited. These intricate rules also provide
for other features of the script, such as determining when a sequence of characters forms a
word or whether a byte is a single character or part of a double-byte character.

Text

Manipulation

With a flexible operating system, most script features are implemented transparently. Usually,
your application does not need to know that its dialog boxes can accept Japanese text.
However, if your application depends more heavily on features of the language, you need
access to information that varies with the script.
For example, to perform word selection and word wrap (the automatic continuation of text
from the end of one line to the beginning of the next without breaking in the middle of a
word), your application may need routines to determine the boundaries of words in the script.
In Roman scripts, you can determine word boundaries fairly easily: spaces delimit words that
are not otherwise delimited (for example, by punctuation). Other scripts, such as Japanese
and Thai, do not use characters such as spaces to delimit words. Word boundaries are not
well defined, and native writers of the language may not agree on where particular word
boundaries occur.

—

de
a

<=
Sc
—
a

joe
<a
<

~

Because of differences in the treatment of uppercase and lowercase characters and diacritical
marks, your application may need routines and tables to perform case conversion and, when
sorting is to be done, to strip diacritical marks. The Macintosh Script Management System
supplies such routines; they are described briefly in “Modifying Text” and “Converting Case
and Stripping Diacritical Marks” later in this chapter and in Macintosh Worldwide
Development: Guide to System Software.
In addition, your application may require routines to determine whether a byte represents a
single character or is part of a double-byte character, or to highlight bidirectional text (for
example, Arabic mixed with English). To allow applications to function independently of
scripts, the Macintosh Script Management System provides such routines; they are described
briefly in “Drawing and Editing Text” later in this chapter and in Macintosh Worldwide
Development: Guide to System Software.

Representing Scripts on the Macintosh

= 14-35

—

@

ie 2)

=

=A
=<

Sy)
~

Le*)

Inside Macintosh,

Text

Volume VI

Rendering

The process of displaying characters that are stored in memory is called text rendering.
Backing-store order refers to the order in which character codes are stored in memory. In
general, characters for a given script are stored in writing order, that is, the order in which
someone would set the characters down on paper. This may be different from the display
order, that is, the left-to-right order in which characters are drawn on a device by QuickDraw.
The Script Manager then handles differences between backing-store order and QuickDraw
display order. For example, Hebrew characters appear on the screen so that the glyph

corresponding to the first character in the string actually appears on the right of the string (see
Figure 14-17). In another example, when diacritical marks are stored as separate overlapping
characters, they are typically stored after the base character. Writing order is very similar to
phonetic order, that is, the order in which the characters are pronounced, but the two differ
in certain circumstances. In some cases, the phonetic order is not well defined, as with
diacritical characters.

NIN
Character codes in memory

$74 $68 $65 $20 $65 $79 $65 $3A)\$20|/SE4/SCB $F2

'

t

qT

the’

t

SCC

|

eye:

‘ ‘ 5

n\

SEO

SCF

SEF

Glyphs as displayed
in a Hebrew font

aa

Figure 14-17.

USING

THE

SCRIPT

Backing-store and display order

MANAGER

This section describes how to find out the current version number of the Script Manager,
determine the number of active script systems, initialize the Script Manager, create simple
script systems, and call the Script Manager.

Determining

the

Features

of the Script

Manager

Use the Gestalt function to determine the current version of the Script Manager and the
number of active script systems. These can also be determined by calling the Script
Manager GetEnvirons function. For details on the Gestalt function, see the Compatibility
Guidelines chapter in this volume.
Use Gestalt with the gestaltScriptMgrVersion selector to obtain a result in the response
parameter that identifies the version number of the Script Manager. This is the same value
returned by GetEnvirons(smVersion).

14-36

— Using the Script Manager

Worldwide Software Overview

Use the Gestalt selector gestaltScriptCount to obtain a result in the response parameter
that gives the number of active script systems. This is the same value returned by

GetEnvirons(smEnabled).

Initializing the Script

Manager

The Script Manager is initialized at startup. After the Script Manager is initialized, each script
system present is installed. When initializing itself, the script system first checks to make sure
that there is enough memory to enable itself and then checks to see that all the appropriate
resources are present in the System file (for example, its system font and script bundle). If
these resources are not available, the script system remains disabled and the other script
systems enabled. So even though script systems can install themselves, only those with the
proper resources available in the System file are enabled (that is, available for use by the
Script Manager and applications).

Creating

Simple

Script Systems

You can create simple script systems—that is, script systems that contain small character sets
and are noncontextual and left to right (for example, Greek or Cyrillic). You are only required
to supply the appropriate fonts and the following international, keyboard, and font resources:
‘itIb' (with the smsfAutolInit bit on, as described below), ‘itlO', 'itl1', 'itl2', ‘itl4', "KCHR’',

and the keyboard color icon family (‘kcs#', 'kcs4', and 'kcs8'). You must also supply
'FOND' and 'NFNT"' or 'sfnt' resources.

Such simple script systems can use the Roman Script System routines; however, to operate
as a script system, they need their own local variables.
Note: The capability to create simple script systems is available beginning with
system software version 6.0.7.

tae

pan

If the flag word in a script’s 'itlb' resource in the System file has the smsfAutoInit bit set, the
Script Manager initializes the local variables for that script and fills in the font and style
information from fields in ‘itlb’.
To provide built-in support for all simple script systems, the Roman FindScriptRun function
has been modified to use an optional table in the 'itl2' resource that specifies the location of
Roman characters in a non-Roman font. See “The 'itl2' Resource” later in this chapter
for details.

Calling

the

Script

Manager

The Script Manager implements several routines itself, but for many other routines it acts as
a dispatcher to the appropriate script system. For example, each script system provides a
CharType function. When a program calls CharType, the Script Manager uses the current
font script (that is, the script that corresponds to the font of the current grafPort) to
dispatch the call to the correct script system. Your application does not need to know whether
a particular routine is implemented by the Script Manager or by a script system.

Using the Script Manager

— 14-37

i)

as
a.
a

<=

mie
ho

@

ZN
S

=a
=

ss)
ox}

@

Inside Macintosh,

Volume VI

Assembly-language note: All Script Manager routines except the
LowerText, UpperText, StripText, and StripUpperText procedures are
called via the _ScriptUtil trap.

A&

Warning: You should always have the grafPort and A5 world set appropriately
before you call any Script Manager or International Utilities Package routine. AS must
point to the QuickDraw global variables, and thePort’.txFont must be set correctly.

Figure 14-18 shows how the Script Manager calls a script system when an application calls a
Script Manager routine that is implemented by each script system (for example, the
Pixel2Char function). When your application calls Pixel2Char, the Script Manager uses the
font script to determine which script system to call. In the example in Figure 14-18, the
assumption is that a Japanese font is the font of the current grafPort, so the Script Manager
dispatches to the Japanese Script System. The Pixel2Char function in the Japanese Script
System is used, and it returns the result directly to the application that called Pixel2Char.

The font script to

i

determine which

script system to call

Script Manager

Result

Japanese
Script System

mal

J

Roman
Script System

Arabic
Script System

Figure 14-18. Calling the Script Manager routines implemented by a script system
When an application calls a Script Manager routine that is implemented directly by the Script
Manager itself (for example, the FontScript function), the flow of control is as shown in
Figure 14-19.

Result

Script Manager

Figure 14-19.
14-38

Calling the Script Manager routines

Using the Script Manager

Worldwide Software Overview

OVERVIEW

OF

THE

SCRIPT

MANAGER

ROUTINES

The Script Manager routines are described briefly in this section. The Script Manager 2.0
routines have not previously been documented in /nside Macintosh. They are included in this
section, and their interfaces appear in “Summary of the Script Manager” near the end of this
chapter. The new routines available with system software version 7.0 are identified by an
asterisk (*). The section “Script Manager Routines” later in this chapter describes the routines
new with version 7.0 that let you localize word selection and line break tables, truncate text,
substitute text, convert case and strip diacritical marks, and handle justified text. For comprehensive discussions of the Script Manager routines available prior to system software
version 7.0, see Macintosh Worldwide Development: Guide to System Software.
You can use the Script Manager routines to
m check and modify the Script Manager’s global and local variables
m check and set system variables
m set or restrict the current keyboard
a obtain script information
m obtain character information
m manipulate text
= interpret different scripts and languages lexically by converting text into a series of
text-independent tokens
a

=

= manipulate dates and times

=5

m manipulate formatted numbers

ra
2.

=

o.

®

Assembly-language note: You can invoke each of the Script Manager
routines that uses the _ScriptUtil trap with a macro that has the same name as
the routine preceded by an underscore. See “Summary of the Script Manager”
near the end of this chapter for a list of the routines that use the _ScriptUtl trap.

Checking

and

Modifying

Global

and

2)

S

=

es
$9
©

ar |

Local Variables

The GetScript, SetScript, GetEnvirons, and SetEnvirons functions provide ways to inspect
and change global and local variables. (Global variables are for the Script Manager, and local
variables are for the script systems.)

With system software version 7.0, the GetScript and SetScript functions now accept implicit
script codes listed in the next section, “Accepting Implicit Script Codes.”

Overview of the Script Manager Routines

— 14-39

Inside Macintosh,

Volume

VI

Version 7.0 also includes new verbs for all four functions. A verb is an integer constant that
controls the function of a multipurpose routine; in this case, the Script Manager uses verbs to
figure out which variable you want to read or set. The new verbs let you set and retrieve font
and style information, determine if a double-byte script system is installed, determine the
current region code, and obtain a pointer to the current 'KCHR' resource. The verbs are
listed in Tables 14-1 and 14-2.
GetScript

Retrieves the local variables and routine vectors maintained for the
specified script

SetScript

Sets the local variables and routine vectors maintained for the
specified script

GetEnvirons

Retrieves the global variables maintained for all scripts

SetEnvirons — Sets the global variables maintained for all scripts

Accepting

Implicit Script Codes

In addition to accepting explicit script code constants (for example, smRoman, smThai, and
so forth), the script parameter for the GetScript and SetScript functions now accepts implicit

script codes, which are special negative values as follows:
Implicit

script

code

Value

Meaning

smSystemScript

—|

System script

smCurrentScript

—2

Font script

Verbs for GetScript and

SetScript

Every Apple®-supplied Macintosh script system supports the verbs listed in Table 14-1 for
the GetScript and SetScript functions. If you provide or create a script system, you should
also support these verbs.
With version 7.0, each script system’s local variables contain fields that supply the following
information pertaining to that script: default monospaced font and its size, user-preferred font
and size, default small font and size, system font and size, application font and size, and
Balloon Help font and size. The '"FOND' ID is stored in the high word, and the size is stored
in the low word. Sizes are important; for example, a 9-point font may be too small in Chinese.
Table 14-1 lists the new GetScript and SetScript verbs for retrieving font information.
With version 7.0, each script system’s local variables contain fields that specify relevant style
information for the script. When GetScript is called with the smScriptValidStyles verb, the
low-order byte of the returned value is a style mask that includes all of the valid styles for the
script. The bit corresponding to each QuickDraw style is set if that style is valid for the
specified script. When GetScript is called with the smScriptAliasStyle verb, the low-order
byte of the returned value is the style that should be used in that script for indicating alias

names (for example, in the Roman script, alias names are indicated in italic). Table 14-1 lists
the new SetScript and GetScript verbs for retrieving style information.

14-40

Overview of the Script Manager Routines

Worldwide Software Overview

Table

14-1.

GetScript and SetScript verbs
Local
variable
size

Verb

Value

smScriptVersion
smScriptMunged
smScriptEnabled
smScriptRight
smScriptJust
smScriptRedraw
smScriptSysFond
smScriptAppFond
smScriptBundle
smScriptNumber
smScriptDate
smScriptSort
smScriptFlags
smScriptToken
smScriptEncoding
smScriptLang

0
2
4
6
8
10
12
14
16
16
18
20
a
24
26
28

2
2
|
l
l
|
Z
2

smScriptNumDate

30

2

smScriptKeys
smScriptlcon

32
34

2
2

smScriptPrint
smScriptTrap

36
38

+
+

from ‘itlb' resource
Script default 'KCHR' ID from ‘itlb'
Script default 'kcs#', 'kcs4', and 'kcs8' IDs
from ‘itlb' resource
Script printer action routine
Trap entry pointer

42
44
78

4
J
+

Script filename
Script name
Default 'FOND' and size for monospaced

smScriptCreator

smScriptFile
smScriptName
smScriptMonoFondSize*
smScriptPrefFondSize*
smScriptSmallFondSize*
smScriptSysFondSize*
smScriptAppFondSize*
smScriptHelpFondSize*
smScriptV alidStyles*
smScriptAliasStyle*

(inbytes)

Script system version number
Local variables modification count
Script-enabled flag
Right-to-left flag
Script alignment flag
Word redraw flag
Preferred system 'FOND'
Preferred application 'FOND'
Beginning of verbs for ‘itlb' section
Script 'itl0' ID from ‘itlb'
Script 'itl1' ID from ‘itlb'
Script ‘itl2' ID from ‘itlb'
Script flags from ‘itlb'
Script ‘itl4' ID from ‘itlb'
Optional script ‘itlS' ID from 'itlb' resource
Current language for script from ‘itlb'
resource

2
2
2
2
2
2
2

40

Number (high) and date (low) format bytes

4

4
4
4
4
+
]
|

80
82
84
86
88
90
92

Meaning

Script file creator

text

User’s preferred 'FOND' and size
Default 'FOND' and size for small text
Default system 'FOND' and size
Default application 'FOND' and size
Default 'FOND' and size for Balloon Help
Set of all valid styles for script
Style to use for indicating aliases

* New with system software version 7.0

Verbs

for

GetEnvirons

and

SetEnvirons

When you call GetEnvirons or SetEnvirons, you use a verb to describe the variable that
interests you. The names, values, sizes, and meanings of the GetEnvirons and SetEnvirons
verbs are listed in Table 14-2.

Overview of the Script Manager Routines

14-4]

—"
—
—

=
=

sub
2.

=

‘2
~“@

“MN
=)
=
=

a

p<)

Ler 3

@

Inside Macintosh, Volume VI

With version 7.0, the Script Manager global variables include a variable that indicates if a
double-byte script system (that is, one containing double-byte character codes) is installed.
The Boolean variable is accessible with the smDoubleByte verb. (Examples of double-byte

script systems include KanjiTalk and Zhong-WenTalk™.)

With version 7.0, the Script Manager global variables also contain a pointer to the

cache that stores the current 'KCHR' resource data. The pointer is accessible with the
smKCHRCache verb.
Finally, with version 7.0, an integer, accessible with the smRegionCode verb, has been

added to the Script Manager global variables. This integer contains the current region code
obtained from the 'itlc' resource.
Table

14-2.

Verbs for GetEnvirons and SetEnvirons

Global

Value

size
(inbytes)

smVersion
smMunged
smEnabled
smBidirect

0
2
4
6

2
2
l
l

smFontForce
smIntlForce
smForced
smDefault

8
10
12
14

l
l
|
|

smPrint
smSysScript
smLastScript
smKeyScript
smSysRef
smKeyCache
smKeySwap
smGenFlags
smOverride
smCharPortion!

16
18
20
22
24
26
28
30
32
34

4
2
2
2
2

smDoubleB yte*
smKCHRCache*

36
38

4

smRegionCode*

40

2

Verb

4
+
+
2

Meaning

Script Manager version number
Global modification count
Script count; 0 if Script Manager not enabled
Bidirectional script flag; TRUE if bidirectional
script installed
fontForce flag
intlForce flag
TRUE if current script forced to system script
TRUE if current script defaulted to Roman Script
System
Print action vector
Preferred system script
Last keyboard script
Keyboard script
System Folder (volume reference number)
Keyboard cache (obsolete)
Keyboard swapping resource handle
General flags
Script override flags
Proportion of intercharacter versus white space,
4.12 fixed-point format
Flag; TRUE if double-byte script system installed
Pointer to cache containing current 'KCHR'
resource
Integer with current region code

*“New with system software version 7.0
The variable specified by the smCharPortion verb is used for text justification. It denotes
the weight allocated to intercharacter space versus white space (10 percent by default for
Roman). The 4.12 fixed-point format specifies 4 bits of integer and 12 bits of fraction.
Note:

14-42

To identify a localized non-U.S. script system, look at the smRegionCode verb.

Overview of the Script Manager Routines

Worldwide Software Overview

Checking

and

Setting

System

Variables

The GetDefFontSize, GetSysFont, GetAppFont, GetMBarHeight, and GetSysJust routines
return the most recent values of given (low-memory) global variables. SetSysJust sets the

global variable that represents the default line direction for the system.
GetDefFontSize

Returns the size of the current default font

GetSysFont

Returns the identification number of the current system font

GetAppFont

Returns the identification number of the current application font

GetMBarHeight

_ Returns the height of the menu bar required to hold menu titles in the
current system font. This routine is useful for calculating window
size or dragLimit rect

GetSysJust

Returns the value of TESysJust, the global variable that represents
the default line direction (left to right or right to left) for text in the
system script

SetSysJust

Sets the value of TESysJust (see the description of GetSysJust
for a description of TESysJust)

Setting the Active Keyboard

Script

The main purpose of the KeyScript procedure is to update the keyboard layout (by using the
'KCHR' and ‘itlk' resources) and the keyboard script based on the verb with which it is
called. If the Keyboard menu is displayed, KeyScript also updates the Keyboard menu.
Verbs can explicitly specify a script, implicitly specify a script (for example, the next script),
or implicitly specify a keyboard (for example, the next keyboard in the active script). If the
verb specifies a script, then the active default keyboard layout for that script becomes the
active keyboard. You can call KeyScript with an argument that is either an explicit script code
or a negative verb with a special meaning. The KeyScript verbs are listed in Table 14-3.

ee

Ss
_

—

-_~

-

ee |
—

lan!

eee

<<

x
pase
2.

~

a)

L
r

Note: Beginning with system software version 7.0, KeyScript only loads 'KCHR'
and 'itlk' resources if they are present in the System file.

-

hs

--

_—

ms

bs)
pom

Ul

The smKeyNextScript, smKeySysScript, and smKeySwapScript verbs existed in system
software version 6.0, but were not documented. They all set the active keyboard script. New
with system software version 7.0, the smKeyNextKybd verb switches to the next keyboard
within the active keyboard script. (See Table 14-3.)
When the user is typing the name of an HFS object—for example, in the Finder or a standard
file dialog box—the keyboard script must be restricted to scripts that display correctly in the
Finder, dialog boxes, menus, and alerts. KeyScript is called with the smnKeyDisableKybds
verb to disable keyboard input temporarily in any script except Roman or the system script.
Keyboards in other scripts will appear disabled in the Keyboard menu. When entry of the
name has been completed, KeyScript is called with smKeyEnableKybds to reenable keyboard
input in all enabled scripts.

Overview of the Script Manager Routines

14-43

&

Inside Macintosh,

Table

14-3.

Volume

V1

Verbs for the KeyScript procedure

Verb

Value

Meaning

(any script code)
smKeyNextScript
smKeySysScript
smKeySwapScript
smKeyNextKybd |
smKeySwapKybd~

0..64
—|
—2
—3
—4
—5

smKeyDisableK ybds

—6

smKeyEnableK ybds
smKeyToggleInline’
smKeyToggleDirection’ |
smKeyNextInputMethod?,
smKeySwapInputMethod?

—7
—8
~9
—10
—1]

smKeyDisableKybdSwitch

—|2

Switch to specified script
Switch to next available script
Switch to system script
Switch to previously used script
Switch to next keyboard in active script
Switch to previously used keyboard in
active script
Disable keyboards not in script system or
Roman Script System
Enable keyboards for all enabled scripts
Toggle inline input for current script
Toggle default line direction
Switch to next input method in current script
Switch to previously used input method in
current script
Disable switching from the current keyboard

*Not implemented in system software version 7.0
TNot implemented in U.S. system software, but may be implemented by appropriate
script systems
When keyboard layouts and scripts are being moved into or out of the System file, it is imperative that no user action changes the active keyboard or active script system. To ensure the
integrity of both the current (active) script system and the other enabled script systems, a new
KeyScript verb has been provided to remove the possibility of a user corrupting the system. To
prevent all keyboard switching and to disable all the Keyboard menu items, KeyScript is called
with the verb smKeyDisableKybdSwitch. When the move has been completed, KeyScript is
called with smKeyEnableKybds to reenable keyboard switching.

Obtaining

Script

Information

The FontScript, Font2Script, and IntlScript functions give you ways to determine the script
code based on the font of the current grafPort that is subject to two control flags, FontForce
and IntlForce. These flags can be set and tested with SetEnvirons and GetEnvirons.
FontScript

Returns the script code for the font of the current grafPort, unless the
FontForce flag is on. (For details on the FontForce flag, see Macintosh
Worldwide Development: Guide to System Software.)

Font2Script

Translates a font identification number into a script code.

IntlScript

Returns the code of the script whose resources will be used by the
International Utilities Package routines [UDateString and [UTimeString
and depends on the font of the current grafPort. If the IntlForce flag is
TRUE, IntlScript returns the system script; otherwise, it returns the
font script. (For details on the IntlForce flag, see “Using the
International and Keyboard Resources” later in this chapter.)

14-44

= Overview of the Script Manager Routines

Worldwide Software Overview

Note: With system software version 7.0, if the font of the current grafPort
corresponds to a script that is not installed and enabled, these routines default to
the system script. Before system software version 7.0, the routines defaulted
to the Roman Script System.

Obtaining

Character

Information

The CharByte, CharType, and ParseTable functions allow you to get data pertaining to
specific characters.
CharByte

Identifies a specified byte in a text buffer as a single-byte character or
as the first or second byte of a double-byte character

CharType

Returns more information about the specified character

ParseTable

Returns a 256-byte table that indicates for each byte value, when it
appears as the first byte of a character, whether there is an additional

byte in the character (in the script of thePort’.tx Font)

Manipulating

Text

The Script Manager supplies a variety of routines that help you draw, edit, format, and
modify text. New routines available with system software version 7.0, identified by an
asterisk (*), allow you to justify, substitute, and truncate text, perform case conversion,
and strip diacritical marks.

Drawing

and

Editing Text

—

The Char2Pixel, DrawJust, FindWord, HiliteText, MeasureJust, and Pixel2Char routines
help you draw and edit text. With system software version 7.0, the Char2Pixel, DrawJust,
MeasureJust, and Pixel2Char routines handle intercharacter spacing in all scripts, if appropriate. In addition, there are new NChar2Pixel, NDrawJust, NMeasureJust, NPixel2Char,
and NPortionText routines that also allow you to specify additional parameters to improve the
handling of fully justified text. Also new with system version 7.0, the NFindWord procedure
is amore powerful version of FindWord that lets you specify word boundaries for more than
one script.
Char2Pixel

Finds the screen position of carets and selection points given a text
buffer, an offset, and a slop value

NChar2Pixel*

Supplies a more powerful version of Char2Pixel that works with
intercharacter spacing, lets you indicate the position of a style run
within a line for lines with multiple style runs, and accepts scaling
parameters

DrawJust

Draws the given text at the current pen location in the current font,
style, and size, taking into account the slop value

Overview of the Script Manager Routines

— 14-45

—
So

ad
.

=

=

@

2)
—

=-~

=

ro)
™

@

Inside Macintosh,

Volume VI

NDrawJust*

Supplies a more powerful version of DrawJust that works with intercharacter spacing, lets you indicate the position of a style run within a
line for lines with multiple style runs, and accepts scaling parameters

FindWord

Returns two offsets in the array defined by the OffsetTable data type
that specify the boundaries of the word defined by the offset parameter
and the leadingEdge flag (for details on the OffsetTable data type, see
“Summary of the Script Manager” near the end of this chapter)

NFindWord*

Supplies a faster and more powerful version of FindWord that
can replace script-dependent versions of FindWord so that script
systems must only supply appropriate tables (in the ‘itl2' resource)

HiliteText

Finds the characters that should be highlighted between two offsets

MeasureJust

Given a slop value, a pointer to an array of characters, an integer
indicating the number of characters in that text, and a pointer to an
array of integers, fills each element in the array of integers with the
width from the beginning of the string to the corresponding character
in the array of characters (the supplied widths take the slop value into
account—that is, they will be the widths necessary to justify the text)

NMeasureJust*

Supplies a more powerful version of MeasureJust that works with intercharacter spacing, lets you indicate the position of a style run within a
line for lines with multiple style runs, and accepts scaling parameters

Pixel2Char

Finds the nearest character offset within a text buffer corresponding
to a given pixel width, taking into account the slop value

NPixel2Char*

Supplies a more powerful version of Pixel2Char that works with intercharacter spacing, lets you indicate the position of a style run within a
line for lines with multiple style runs, and accepts scaling parameters

Formatting

Text

The FindScriptRun, PortionText, GetFormatOrder, StyledLineBreak, and VisibleLength
routines allow you to format text. The NPortionText function, available with system software version 7.0, provides a more powerful version of PortionText that lets you work with
scaling and indicate the position of a style run within a line.
FindScriptRun

Finds the next block of Roman or native text within a script run;
within scripts that contain subscripts, blocks of native text are
limited to a subscript

PortionText

Indicates the correct proportion of justification to be allocated to
given text when compared to other text; used to determine how to
distribute the slop of a line among the style runs on the line

NPortionText *

Supplies a new version of PortionText that lets you indicate the
position of a style run within a line for lines with multiple style
runs and accepts scaling parameters

GetFormatOrder

Tells in what order format runs should be drawn based on line

14-46

direction for a particular line of text

— Overview of the Script Manager Routines

Worldwide Software Overview

StyledLineBreak

Breaks a line on a word boundary

VisibleLength

Returns the length of text, excluding trailing white space and
accounting for the script of the text

Modifying

Text

The LowerText, Transliterate, and UpperText routines let you localize text into a base form
and convert text from lowercase into uppercase, providing for the localizable stripping of
diacritical marks. The StripText and StripUpperText procedures, available with system
software version 7.0, provide localizable stripping of diacritical characters and conversion
of the characters into uppercase. LowerText and UpperText, also new with version 7.0, are
faster and easier to use than Transliterate, but less powerful.
LowerText*

Provides localizable lowercasing of text up to 32 KB in length

StripText *

Provides localizable stripping of diacritical characters for text up to
32 KB in length

StripUpperText *

Provides localizable stripping of diacritical characters for text up to
32 KB in length and converts them to uppercase characters

Transliterate

Converts characters from a set of scripts or subscripts to the closest
possible approximation in a different script or subscript, and
performs localizable uppercasing and lowercasing

UpperText*

Provides localizable uppercasing for text up to 32 KB in length

(LwrText is a synonym for LowerText)

Note: UpperText is different from UprText, which provides nonlocalizable uppercasing using the _UprString trap.

Substituting

—

cx
=
=
S
as
Qu
=

Text

oe

The ReplaceText function, new with system software version 7.0, allows you to substitute
text correctly for all scripts. It provides a global way for you to do parameter text replacement
in your applications. ReplaceText searches specified text for instances of a string specified by
the key parameter and replaces each instance with the replacement text supplied.

Truncating

Text

The TruncString and TruncText functions, new with system software version 7.0, let you

truncate text at the end or in the middle in order to fit it into a specified pixel width.
TruncString*

Ensures that a string supplied as Str255 fits into the specified pixel
width by truncating the string, if necessary, in a manner dependent
on the script associated with the font of the active grafPort

TruncText*

Is similar to TruncString except that the string is defined by a pointer
and a length
Overview of the Script Manager Routines

— 14-47

®

os

ZN

S

ac)
-

=
fp
©

Ler |

Inside Macintosh,

Lexically

Volume VI

interpreting

Different Scripts

The IntlTokenize function takes arbitrary text and breaks it into tokens like the lexical analyzer
of a compiler. IntITokenize allows a program to recognize tokens such as variables, symbols,
and quoted literals without making assumptions that depend on a particular script.

Date

and

Time

Utilities

The Script Manager contains four categories of routines that help with worldwide date and time
conversion. The routines convert among various formats for dates and times, change long
dates, modify and verify date and time records, and read and store geographic locations. For
details on related time and date data structures, see “Summary of the Script Manager” near the
end of this chapter and Macintosh Worldwide Development: Guide to System Software.

Converting

Worldwide

Dates

and Times

The InitDateCache, String2Date, and String2Time functions let you convert worldwide dates
and times.

InitDateCache

Formats the date cache record (defined by the DateCacheRecord data
type) for use by the String2Date and String2Time routines

String2Date

Expects the date at beginning of text and parses text for use in the
date-time record (defined by the LongDateRec data type)

String2Time

Expects the time at beginning of text and parses text for use in the
date-time record

Converting

Long

Dates

The LongDate2Secs and LongSecs2Date procedures allow you to convert dates between the
LongDateRec format (an explicit year, month, day, and so forth) and the LongDateTime
format (an 8-byte signed value, seconds since January 1, 1904).

LongDate2Secs

Converts the time specified in a long date record to a LongDateTime
format

LongSecs2Date

Converts the date specified in a LongDateTime format to a
long date record

Modifying

and Verifying

Date and Time

Records

The ToggleDate and ValidDate functions allow you to change date and time records and check
the validity of the resulting data structures.
ToggleDate

Modifies a LongDateTime parameter by toggling one of the corresponding fields of the long date record up or down or by setting
it explicitly (for a list of error code constants for ToggleDate, see
“Summary of the Script Manager” near the end of this chapter)

ValidDate

Checks the validity of a long date record

14-48

= Overview of the Script Manager Routines

Worldwide Software Overview

Reading

and

Storing

Locations

The ReadLocation and WriteLocation procedures let you access, manipulate, and store the
geographic location of the Macintosh and related time zone information.
ReadLocation

Accesses the stored geographic location of the Macintosh and the
time zone information from the parameter RAM

WriteLocation

Stores the geographic location of the Macintosh and the time zone
information in parameter RAM

Number

Utilities

The Script Manager number utilities let you change the ways numbers are represented so they
can be displayed in various international formats. A canonical number format is a private,
internal format that specifies the number format in a way that is independent of region,
language, and other multicultural considerations.

Converting

to and

From

Canonical

Number

Formats

The Str2Format and Format2Str functions change format strings typed by users into a
private, internal format and let applications change private, internal formats into localized
format strings.
Str2Format

Converts a format string typed by users into a canonical number format

Format2Str

Allows programs to convert previously entered canonical number
formats to a format string that depends on the localized version of
the system software

—e

5oy

Working

With

Formatted

Numbers

<—
a~<.
~
=

ex |

The FormatX2Str and FormatStr2X functions change an internal floating-point representation
of a number into a localized formatted numeric string and vice versa.
FormatX2Str

—

“

ee

<A
=

tao

lan!

oe

Le)

e2
~

Converts an internal floating-point (SANE) representation of a
number into a localized formatted numeric string

=

_

—
<
=
ba)
—

Note: If you compile your application to use the 881 option, you need to convert
96-bit numbers to 80-bit numbers before they can be passed to FormatX2Str.
FormatStr2X
Note:

Converts a localized formatted numeric string into an internal
floating-point representation of a number

FormatStr2X returns an 80-bit, not a 96-bit, representation.

Overview of the Script Manager Routines

.

Lae)

14-49

Inside Macintosh,

SCRIPT

Volume V1

MANAGER

ROUTINES

This section describes new Script Manager routines available with system software
version 7.0. The routines allow you to localize word selection and line break tables,
truncate text, substitute text, perform case conversion, and strip diacritical marks.

Localizing

Word

Selection

and

Line

Break Tables

Until system software version 7.0, each script system provided its own version of the
FindWord procedure, which locates word boundaries for word selection and line breaking
by examining a block of text to determine the boundaries of the word that includes a specified
character in the block. The
NFindWord procedure is a new, state-table-driven version of
FindWord that is faster and more powerful. It can replace the script-dependent versions of
FindWord so that script systems need only supply the appropriate tables in their 'itl2' resource.
The break tables used by NFindWord are in a new format, which is documented in the next
section, “Defining Word Boundaries and Line Breaks.”
When FindWord is called, the Script Manager examines the breaks parameter to determine if
the call can be routed to the NFindWord procedure. If breaks is an explicit pointer to a break
table and the table is in the new format, the call is routed to NFindWord. Also, if breaks is 0

or —1 to specify one of the default break tables and if the script’s ‘itl2' resource contains
tables in the new format, the call is routed to NFindWord. Otherwise, the call is routed to the

script’s FindWord procedure so that old-format break tables continue to work. The Script
Manager assumes tables are in the new format if the high-order bit of the first byte is 1.
You can also call NFindWord directly, as follows:
PROCEDURE

NFindWord

(textPtr:

Ptr;

textLength:

leadingEdge:

Boolean;

VAR

OffsetTable) ;

offsets:

Integer;

nbreaks:

offset:

Integer;

NBreakTablePtr;

The NFindWord interface is identical to that of the FindWord routine except that the nbreaks
parameter must be an explicit pointer to a new-format break table; the values 0 and —1 may
not be used to indicate default break tables.
To specify the text block, you pass two parameters: the textPtr parameter, a pointer to the
beginning of the text to be examined, and the textLength parameter, the length of the text to
be examined. Since the offset parameter specifies a position between two characters, additional information is required to determine which character should be used as a basis for
finding the word boundaries. This is supplied by the leadingEdge parameter. If leadingEdge
is TRUE, the offset corresponds to the character whose leading edge borders the offset. (The
leadingEdge parameter corresponds to the left side in a left-to-right script such as Roman.) If
leadingEdge is FALSE, the offset is on the trailing edge of the specified character. To specify
word definitions, you pass the nbreaks parameter, which is a pointer to a word break table, a
table that determines where word breaks occur.
NFindWord returns information about word boundaries in the offsets array. This is an array
of three offset pairs. The first integer in the first pair contains the offset before the leading

14-50

— Script Manager Routines

Worldwide Software Overview

edge of the first character of the word; the second integer in the first pair contains the offset
after the trailing edge of the last character of the word. The remaining values in the offsets
array are set to 0.
FindWord and NFindWord are often used in conjunction with the Pixel2Char and HiliteText
routines, and the interfaces to FindWord and NFindWord have been designed for smooth
integration with these routines.

Defining Word

Boundaries

and

Line Breaks

This section describes how the NFindWord procedure uses state machines and associated
tables to determine word boundaries and line breaks. For more details on the NFindWord
procedure, see the previous section, “Localizing Word Selection and Line Break Tables.”
The NFindWord procedure examines a block of text to determine the boundaries of the word
that includes a specified character in the block. Usually, NFindWord uses different state
tables to define words for word selection and words for word wrap (line breaking).
Note:

NFindWord considers offsets within a block of text to be positions between

characters—for example, an offset of | in Roman text is between the first and second

characters (or on the trailing edge of the first and on the leading edge of the second).

NFindWord uses a state machine to determine word boundaries. The state machine must start
at a point at or before the beginning of the word that includes the specified character. This can
be accomplished in two ways. First, if the specified character is sufficiently close to the
beginning of the text buffer, the state machine simply starts from the beginning of the buffer.
This is determined by the doBackupMin parameter in the tables: if the offset parameter is less
than doBackupMin, the state machine starts from the beginning. Otherwise, NFindWord uses
a second state table, BackwardTable, for backward processing. With BackwardTable,
NFindWord starts at the specified character, moving backward as necessary until it
encounters a word break.
Once determined, this starting point is saved as an initial word break location. From this
point, the NFindWord state machine moves forward using ForwardTable until it encounters
another word break. If that word break is still before the specified character, its location is
saved as the starting point, and the state machine is restarted from that location. This process
repeats until the state machine finds a word break that is after the specified character. At that
point, NFindWord returns the last saved word break location and the current word break

location as the offset pair defining the word boundaries.

The state machine operates in a similar manner whether moving backward or forward; any
differences in behavior are determined by the tables. The machine begins in the start state

(state 1). It then cycles one character at a time until it finds a word break and exits. Each cycle

proceeds as follows: the current character is mapped to a class number. The character class
and the current state are used as indices into a two-dimensional array of byte-length action
codes. Each action code specifies the following:
s

whether to mark the current offset

w

the next state, which may be the exit state (state 0)

When the state machine exits, it has encountered a word break. The location of the word

break is the last character offset that was marked. In general, the state machine marks a
Script Manager Routines

= 14-51

—

Ae
a
a
=
S
=s
—
lal
—
<“
<
—

oa)
oe
®

2
~

-—

=
—_
<
<=
as
pe)
=
oO

Inside Macintosh,

Volume VI

character offset when it determines that the word that began at its starting point extends at
least to the marked offset.
Figure 14-20 gives two examples of the forward operation of the state machine for word

selection. In each case, the state at a given offset and the class of the character following the
offset determine (1) whether to mark that offset, (2) whether to exit at that point, and, if not

exiting, (3) what the state at the next offset will be. When the state machine exits, the first
and last marked offsets are returned as the word boundaries.

|

'
_

K

‘):)"7:

i

*

a

*

Start

ie

Word defined at exit by
marked offsets: “UH”

|
Exit

Marked
offsets

!
*

oe.

_ QO:
*

Start

*

*

‘eo!

'

Word defined at exit by

marked offsets: “UH-oh”

oS

Exit

Figure 14-20. Forward operation of the state machine for word selection
Mapping characters to classes is simple for single-byte characters, but the process gets a little
more involved for double-byte character codes. The byte value at the current character offset is
used as an offset into the ClassTable array, an array of 256 signed bytes. If the value in
ClassTable is positive, it signifies that the byte at the current character offset is a single-byte
character, and the value in ClassTable is the class number for the character. If the value in
ClassTable is negative, it signifies that the byte at the current character offset is the first byte of
a double-byte character code, and AuxClassTable must be used to determine the character class.
The AuxClassTable class table begins with a variable-length word array. The first word
contains a default class number for double-byte character codes. The following words are
offsets to RowTables, which have the same format as ClassTable, but are used by

NFindWord for mapping the second byte of a double-byte character code to a class number.
If the value in ClassTable was —| (or any odd, negative number), the double-byte character
code is assigned the default class from the first word of AuxClassTable. For other doublebyte characters, the value in ClassTable is an even negative number;

NFindWord negates

this value to provide an offset from the beginning of AuxClassTable to the appropriate
RowTable offset. The RowTable table specified by this offset in this way is used to map
the second byte of the character to a class number.
Note:

There is a maximum of 128 classes and 128 states (including the start and

exit states).

Figures 14-21 provides a description of the new break table. Note that the high bit of the first
word is set to indicate that this table is in the new format; otherwise, FindWord assumes that
the tables are in the old format. The new break table begins with an 8-word header, followed
by the class and state tables.
14-52

Script Manager Routines

Worldwide Software Overview

TableBegin
byte

(

byte

Ai a
1}

flagHigh

)
lf flagsLow = 0, you don’t check for 2-byte characters.

flagsLow

version number

ClassTable offset

These four words are the offset (in bytes) from
TableBegin to the specified table.

AuxClassTable offset
BackwardTable offset
ForwardTable offset

lf FindWord’s offset argument < doBackupMin, FindWord
skips backward processing.

doBackupMin

Total of all four tables and headers.

table length (bytes)
ClassTable

The character code byte is an offset into ClassTable.
For 1-byte characters, the corresponding value in
ClassTable is > 0 and specifies the class directly.
For 2-byte characters, the value is negative. If it is
odd, default2ByteClass is used for the character.
Otherwise, a secondary mapping is used: the negative
of the value is an offset into AuxClassTable.
The word at this location is an offset from AuxClassTable
to a secondary mapping table, which is used to
map the second byte of the character code to a class.

256-byte table maps
each (1st) byte of the
code to a class
AuxClassTable

default2ByteClass
RowTable1 offset (opt)
RowTable2 offset (opt)

RowTable1

(opt)

—

Optional (only needed for 2-byte characters)

256-byte table maps
each low byte of the

—

dee
<—

code to a class

<=

—)
—_
2.
yy

RowTable2 (opt)

or

=
=e
—

@

256-byte table maps
each low byte of the

2)
~
—_

aae-c)

oat

code to a class

=<

~
ps)

or

a)

BackwardTable
state table; see
Figure 14-22
ForwardTable
state table; see

Figure 14-22

Figure

14-21.

NFindWord

header and class tables

Script Manager Routines

— 14-53

|

Inside Macintosh,

Volume

VI

Figure 14-22 shows the NFindWord state table. It begins with a list of words containing byte
offsets from the beginning of the state table to the rows of the state table; this is followed
by a C-by-S byte array, where C is the number of classes and S is the number of states. The
bytes in this array are stored with the column index varying most rapidly; that is, the bytes for
the State | row precede the bytes for the State 2 row. Each byte in this array is an action code
whose format is defined in Figure 14-23.
Reserved (must be 0)
Offset to State 1 row
Offset to State 2 row
Offset to State 3 row
Offset to State 4 row
Offset to State 5 row

ClassO

Class1

Class2

action

action

action

State 2 row

action

action

State 3 row

action

State 4 row
State 5 row

State 1 row

Class3

Class4

|

action

action

action

|

action

action

action

action

|

action

action

action

action |

action

| action

action

action

action

| action

Figure

14-22.

NFindWord

state

|

action
action

table

Figure 14-23 shows the format of an action code.
7

Mark bit (1 => mark current offset)
Next state

Figure 14-23.

14-54

— Script Manager Routines

Next state (if 0, then exit)

Format of NFindWord

action code

Worldwide Software Overview

Determining

Word

Selection:

An

Example

This section provides an example of how a script system determines word selection.
Note:

The definition of a word in the Roman Script System may vary slightly

with localization.

Table 14-4 provides the class numbers, character classes, and explanations of the class names
for the U.S. word selection algorithm.
Table

14-4.

Class
number

U.S. word selection algo rithm
Class
name

Used

0)
l
2
3
4
5

break
nonBreak
letter
number
midLetter
midLetNum

Everything not included below
Nonbreaking spaces
Letters, ligatures, and accents
Digits
Hyphen
Apostrophe (vertical or right single quote)

8

midNum

6
t

9

10
1]

preNum
postNum

preMidNum
blank
cr

for

$£¥x
%

/

Go ¢

Space, tab, null
Return

The NFindWord table in the U.S. ‘itl2' resource defines words as any of the following
configurations of the classes listed in Table 14-4:
ae

=

w A sequence of letters, possibly separated by a hyphen, apostrophe, or period and
possibly followed by a sequence of numbers (defined next). Some examples are
ultra-cool, Bob’s, and record. field.

<

<=

CS

as

Q&

u A sequence of numbers, possibly separated by a comma, fraction sign, apostrophe, or
period; possibly preceded by a decimal point or currency sign; and possibly followed by
a percentage sign or by a sequence of letters (defined previously). Some examples are
1.234, $23.14, .70, and 12ea—b.

=

5.

@

ZN
—

jan)
=

=

&

weed

@

m A sequence of spaces, tabs, or nulls, possibly followed by a cr.
mw Characters that are words by themselves and not included as part of the above
definitions.

Note: With system software version 7.0, the treatment of a sequence of one or more
nonbreaking spaces has changed. If there is a non-whitespace character (that is, a
character that is neither blank nor cr) on either side of the sequence, the sequence
becomes part of the word that includes the non-whitespace character. Thus, if the
sequence is between non-whitespace characters, it joins the words of which they are
a part. Otherwise, the nonbreaking spaces are treated as blanks.

Script Manager Routines

— 14-55

Inside Macintosh,

Volume

VI

Table 14-5 shows where word breaks occur in various character sequences. In the table,

other denotes any character that is not blank, cr, or nonBreak.

Table

14-5.

Occurrence of word breaks in various character sequences

Character

Word
break

Character

Word
break

Character

blank
blank
blank
cr
cr
cr
other
other
other

no
no
yes
yes
yes
yes
no
no
no

nonBreak
nonBreak
nonBreak
nonBreak
nonBreak
nonBreak
nonBreak
nonBreak
nonBreak

no
no
no
no
no
no
yes
yes
no

blank
cr
other
blank
cr
other
blank
cr
other

Table 14-6 describes the meaning of each state number shown in Figure 14-24.
Table
State
number
l
2
3
4
5
6
i
8
9
10
1]

14-6.

Significance of the state numbers in the Roman word selection algorithm
Meaning
Start, or has detected initial nonBreak sequence
Has detected a letter
Has detected a number
Has detected a non-whitespace character that should stand alone; now
anything but nonBreak generates an exit
Has detected preMidNum or preNum; now anything but number or nonBreak
generates an exit
Has detected a blank
Has detected a /etter followed by midLetter, midLetNum, or preMidNum;
now anything but /efter generates an exit
Has detected a non-whitespace character followed by nonBreak (the nonBreak
should be treated as non-whitespace)
Has detected a number followed by midNum, midLetNum, or preMidNum;
now anything but number generates an exit
Marks current offset (include one more character), then exits
Has detected blank followed by nonBreak (the nonBreak should be treated
as blank)

Figure 14-24 illustrates the process of determining whether a sequence of characters is to
be selected as a word. It shows the possible paths through the states of the Roman word
selection algorithm defined in Table 14-7.

14-56

— Script Manager Routines

Worldwide Software Overview

letter

(Other)

ete

|<

State

>

JL letter

number

letter

State
7

midLetter,
midLetNum,
preMidNum

il

nonBreak

-@
>|

(Other)

number
number

a

b
/ number

9

midNum,

eo

nonBreak

State

®

~
preMidNum

preMidNum » |
=
avenue

postNum

v

v

ss

nonBreak

Lp»

blank, cr

nonBreak

<4

midLetter, MidLetNum,

break, postNum

3

“Ss

\

midNum,

P|

State

4

(Other)

ar A

=

*s

nonBreak

©

]

‘J

(Other)

cr

State

10

(Everything)

meal,

_

=
=
—)

er 3
os

Q.

=

Qn
@

a

blank

MN
—)
=

=

@

S

Exit

= Mark this offset

o

[|= State
A

Figure 14-24.

Roman

nonBreak

word selection state transitions

Script Manager Routines

— 14-57

Inside Macintosh,

Volume VI

Table 14-7 shows the U.S. word selection transition table for forward processing. Each
column shows the action codes for a current state.
Note:

Table

In this table, the first column must be all nonzero values with '*’.

14-7.

U.S. word select transition table for forward processing

Class
number

Class
name

4

State
5

number
6
7

1

2

3

8

9

10

I1

0

break

4

SS

©

BD

DD

0

O

*4

GO

0

0

l

nonBreak

*

"5

"3%

*

6

0

O

*8

0

*0

11

2

letter

)

2

2

©

0

©)

*2

0

*0

0

3

number

Ss

3

3

73:

70

O

3

*0

0

4

midLetter

ym

SF

70

GO

QO

*4

O

*0

0

5

midLetNum

*4

*7

*9

*0

*0

*0

O

*4

0

*0

0

6

preNum

S

0

=

*O

*O

70

QO

5

0

*0

0)

7

postNum

tA

*)

*4

*0

*O0

*0

QO

*4

0

*0

0

8

midNum

a

6D

UOC

0D.

COQ

*0

QO

*4

0

*0

0)

9

preMidNum

*5

*7

*9

*0

*0

*0

QO

*5

0

*0

0

10

blank

“6

80

*)

“0

“02

%

OQ

0

O

)

«6

11

cr

10

70

*}).

76

*O

FIO

0

*0

0

*O0

*10

)

3

* Means “mark the offset before this character”

Optimized

Word

Break

Tables

Listing 14-1 shows how to obtain a copy of the word selection table from the default ‘itl2’
resource. You may want to do this so that you can pass the word selection table directly to
NFindWord or FindWord in a loop. This example assumes that inside the loop you are trying
to find word boundaries. Outside the loop, you set up for this task by getting a copy of the
table needed for the word break routine. See “Manipulating the ‘itl2' and ‘itl4’ Resources”
later in this chapter for more on the [UGetItITable procedure and “Localizing Word Selection
and Line Break Tables” earlier in this chapter for details on the NFindWord procedure.

14-58

— Script Manager Routines

Worldwide Software Overview

Listing 14-1. Obtaining optimized word break tables
FUNCTION
VAR

GetWordSelect:

itlHandle:

Ptr;

Handle;

tableOffset:

LongInt;

tableLength:
wordBreakPtr:

Longint;
Ptr;

tempPtr:

PELs

BEGIN
GetWordSelect

:=

NIL;

{assume

IUGetItlTable(iuSystemScript,
tableLength);
{If script
is
{ will
return

incorrect
as NIL.}

IF

<>

(itlHandle

NIL)

or

iuWordSelectTable,

the

table

is

not

failure}

itlHandle,tableOffset,

available,

the

handle

}

THEN

BEGIN

wordBreakPtr

:=

NewPtr(tablelength) ;

IF
(wordBreakPtr
BEGIN

tempPtr

:=

BlockMove

<>

NIL)

THEN

Ptr(LongInt

(itlHandle%)+tableOffset);

(tempPtr,wordBreakPtr,tablelength) ;

GetWordSelect

:=

wordBreakPtr;

{return

a

valid

ptr}

END;
END;
END;

Truncating

Text

The TruncString and TruncText functions truncate text in a localizable way.

eS

de

The TruncString function ensures that a string supplied as Str255 fits into the specified pixel
width, by truncating the string, if necessary, in a manner dependent on the font script.
FUNCTION

TruncString

(width:

Integer;

truncWhere:

VAR

theString:

TruncCode)

:

Str255;

a

=
~
=

ex |
—

Q.

=<
a
—e
~—
Le)

2

Integer;

-_

al

—

aad
<A

The TruncText function ensures that a string defined by a pointer and a byte length fits into
the specified pixel width, by truncating the string as described above.
FUNCTION

TruncText

(width:

Integer;

truncWhere:

textPtr:

TruncCode)

Ptr;
:

VAR

length:

Integer;

Integer;

The text truncation functions ensure that a text string fits into the pixel width specified by the
width parameter and then truncates the string, when necessary. These functions use the font
script to determine how to perform truncation. If truncation occurs, they also insert a
truncation indicator (such as an ellipsis in English).

Script Manager Routines

— 14-59

<=
as
—

Lew

a)

|

Inside Macintosh,

Volume VI

The truncWhere parameter specifies whether truncation occurs at the end of the string or in
the middle (the latter is useful for pathnames, for example). Specify the constant smTruncEnd
to truncate the string at the end. Specify the constant smTruncMiddle to truncate the string in
the middle. In the TruncString function, the string is supplied as Str255. The TruncText
function defines the string by a pointer and byte length. If truncation occurs, the string length
is updated to reflect the new length. If general errors occur, the result code is smTruncErr and
the length is set to 0. In any case, the length never increases.
With system software version 7.0, a new token type, tokenEllipsis, has been defined; the
TruncString and TruncText functions obtain the corresponding character from the untoken
table in the 'itl4' resource. See “Summary of the Script Manager” near the end of this chapter
and Macintosh Worldwide Development: Guide to System Software for more information on
the 'itl4’ tables and related data structures.
The TruncString and TruncText functions are implemented by the Script Manager itself, not
by script systems. Both text truncation functions may move memory.
Result codes
smNotTruncated
smTruncated
smTruncErr

resNotFound

0)
l
—|

-192

No truncation necessary
Truncation performed
General error (At present, this only occurs if
truncation is necessary, but the truncation
indicator alone is wider than the specified
width. If this error occurs, the length is set
to 0.)

Cannot get the correct ‘itl4' resource or
resource is not in current format

See Listing 14-2 in “Substituting and Truncating Text” for an example of how to use the
TruncText function.

Substituting

Text

The ReplaceText function, new with system software version 7.0, allows you to substitute text.
FUNCTION

ReplaceText

(baseText:
key:

Str15)

Handle;
:

substitutionText:

Handle;

Integer;

ReplaceText searches the text specified by the baseText parameter for instances of the key
string and replaces each instance with the text indicated by the substitutionText parameter.
The key parameter contains a string to be used as the substitution marker. Although the
substitution text may contain the key string, the text is inserted verbatim into the base text,
and no recursive substitution occurs.
ReplaceText returns a positive value indicating the number of substitutions performed or a
negative value indicating an error. The constant noErr is returned if there is no error or no
substitutions performed.

14-60

— Script Manager Routines

Worldwide Software Overview

The following are general Memory Manager errors. When ReplaceText returns these errors
by using the following constants, they have these specific meanings:
Result codes
(special meanings of Memory Manager errors returned by ReplaceText)
memFullErr
nilHandleErr
memWZErr

Note:

108
109
—111

SetHandleSize fails on baseText
GetHandleSize fails on baseText or substitutionText
GetHandleSize fails on baseText or substitutionText

ReplaceText may move memory.

See the next section, “Substituting and Truncating Text,” for an example of how to use the
ReplaceText function.

Substituting

and Truncating

Text

Listing 14-2 uses the ReplaceText and TruncText functions and assumes that you have
Str255 strings containing base text and substitution text and that you want the result to
fit in a specified number of pixels.
Listing 14-2. Substituting and truncating text
CONST

maxiInt

=

32767:

VAR

baseString:

Str255;

subsString:

Str255;

baseHandle:

Handle;

subsHandle:

Handle;

keyStr:

Str1i5;

sizeL:

Longint;

myWidth:

Integer;

length:

Integer;

result:

Integer;

myErr:

—

BSS

<
<
=
~

=

oe

<a
<=

Q.
es)

L
r

=

=
nel

OSErr;

<

BEGIN

baseString
subsString
keyStr

:=

myWidth

IF

myEr

sizeL
myErr

:=
:=
now

sizeL
myErr

:=

:=

'abcdefghijklmnopaqrstuvwxyzabcdefghijklmnopqrstuvwxyz';

:=

'KILROY

{insert

into

'mnop';

{...-in

place

500;

{...and

WAS

HERE';

ord(baseString[0]);
PtrToHand(@baseString[1],
baseHandle,
<> noErr THEN DoError (myErr) ;
ord(subsString[0]);
PtrToHand(@subsString[1],

subsHandle,

baseString...}
of

truncate

this

with

sequence}

this

width}

sizeL);

sizeL);

(Continued)

Script Manager Routines

14-61

=
ps)
sr |
@

Inside Macintosh,

Volume VI

Listing 14-2. Substituting and truncating text (Continued)
IF myErr
<> noErr THEN DoError (myErr) ;
result
:= ReplaceText (baseHandle,
subsHandle,
IF

result

SizeL
IF

:=

<

0

THEN

GetHandleSize(baseHandle) ;

MemError

noErr

THEN

DoError(MemError) ;

HLock (baseHandle) ;
IF MemError
<> noErr

''HEN

DokError(MemError);

length

result
IF

:=

:=

DrawText

IF

<>

sizeL;

result

HUnlock

keyStr);

DoError(result);

TruncText

(myWidth,

<

DoError(result) ;

0

THEN

(baseHandle*,
(baseHandle)

MemError

<>

baseHandle*,

0,

length);

THEN

DoError

{oops,

length,

a

Mem

Mgr

error}

smTruncEnd) ;

;

noErr

(myErr)

;

{oops,

a

Mem

Mgr

error}

END;

Converting Case

and Stripping

Diacritical

Marks

The LwrText procedure was available with Script Manager 2.0 as a high-level interface to the
_LwrString trap. Beginning with system software version 6.0.4, LwrText was localizable by
using tables in the 'itI2' resource. The UprText procedure was also available in Script
Manager 2.0 as a high-level interface to the _UprString trap but was generally not localized.
In system software version 7.0, a new set of routines is available from both assembly and highlevel languages to provide localizable lowercasing, uppercasing, and stripping of diacritical
marks. All of these routines—LowerText, UpperText, StripText, and StripUpperText—use
trap $A056 (formerly called LwrString), but they set the operating-system trap flags to indicate
which function is desired. UpperText provides a localizable version of UprText. The name
LwrString can still be used; however, you are encouraged to use the new names that have been
defined for the various functions of the LwrString trap.
Note: The LowerText, UpperText, StripText, and StripUpperText procedures may
move memory.
PROCEDURE

LowerText

Trap macro
On entry
On exit

(textPtr:

Ptr;

len:

Integer);

_LowerText
AO: pointer to first character of string
DO: length of string in bytes (word); must be less
than 32 KB
DO: result code

The LowerText procedure provides localizable lowercase conversion of text up to 32 KB
in length.
14-62

Script Manager Routines

Worldwide Software Overview

Note:

The LwrText interface is still available and is identical to LowerText.

PROCEDURE

UpperText

Trap macro

On entry
On exit

(textPtr:

Ptr;

len:

Integer);

_UpperText

AO: pointer to first character of string

DO: length of string in bytes (word); must be less
than 32 KB

DO: result code

The UpperText procedure provides localizable uppercase conversion of text up to 32 KB
in length.
PROCEDURE

StripText

Trap macro
On entry
On exit

(textPtr:

Ptr;

len:

Integer);

_StripText
AO: pointer to first character of string

DO: length of string in bytes (word); must be less
than 32 KB
DO: result code

The StripText procedure provides localizable stripping of diacritical characters for text up to
32 KB in length.
PROCEDURE

StripUpperText

(textPtr:

Ptr;

len:

Integer) ;

—

—
a

=
~

=

Trap macro
On entry
On exit

ar
o—|
lan!

_StripUpperText
AO: pointer to first character of string

—

<A

=<
=A
—
fa)
re
—

DO: length of string in bytes (word); must be less

'é

than 32 KB
DO: result code

—

>

a

=
pS)
gr

La")

The StripUpperText procedure provides localizable stripping of diacritical characters for text
up to 32 KB in length and converts them to uppercase characters.
The following result codes apply to all four text truncation trap macros:
Result codes
noErr
resNotFound

0
-192

No error
Can’t get correct 'itl2' resource or resource is not in current
format (the string will not be modified)

Script Manager Routines

14-63

)

Inside Macintosh,

Handling

Volume

VI

Justified Text

With system software version 7.0, the Script Manager provides several changes that are needed
for handling fully justified text in the following list of Script Manager routines. These routines
assume that a slop value for the line—the difference between the desired width and the actual
width before justification—is to be distributed among the style runs on a line and among the
words and characters within a style run. The actual width before justification is the sum of
values returned by the TextWidth function for each style run on the line.
Here is a summary of how the justification routines available prior to system software
version 7.0 work. (For details on these routines, see Macintosh Worldwide Development:
Guide to System Software.)
a PortionText lets you determine how to distribute the slop value for the line among the
style runs on the line.
w DrawJust allows you to draw a style run on a line and to provide a slop value for the
style run.
»

MeasureJust fills an array that specifies, for each character in a style run, the width from
the beginning of the style run through that character.

mw Char2Pixel converts a character offset in a style run to a pixel width in the style run.
m Pixel2Char converts a pixel width in a style run to a character offset in the style run.
The Roman Script System versions of the original justification routines did not handle
intercharacter spacing and did not provide enough information for these routines to supply
proper intercharacter spacing between style runs when there are multiple style runs (that is,
more than one font, size, or QuickDraw style) on a line.
In system software version 7.0, all of these routines handle intercharacter spacing properly in
all scripts and on all ports. When relevant, the amount of intercharacter spacing can be
controlled using the Script Manager’s smgrCharPortion global variable, which can be set
with the SetEnvirons function.
Version 7.0 also provides a second interface for each of the existing routines. Each new interface name begins with N (for example, NPortionText), and each interface contains additional
parameters that specify the visual position of the style run in the line and the desired scaling
factors. The scaling factors are supplied as numerator and denominator parameters in a manner
identical to the QuickDraw StdText procedure. The slop argument in these routines is a signed
value that specifies the number of screen pixels by which the style run should be extended (or
shrunk, if the value is negative) after the numerator-denominator scaling has been applied.
Other improvements in the new routines for handling justified text include the following:
= For future use, parameters that specify a character position or length change from
integer to long integer; parameters that specify a pixel width change from integer
to fixed. However, some routines currently only use the integer part of a LongInt
parameter.
a NPixel2Char includes a VAR parameter (widthRemaining: Fixed). If the pixelWidth
parameter that is passed into NPixel2Char is greater than the width of the text specified
14-64

— Script Manager Routines

Worldwide Software Overview

by the textBuf and textLen parameters, the amount of excess width is returned in the
widthRemaining parameter; otherwise, widthRemaining is set to —1.
a A new picture opcode saves the line layout information needed for these routines. See
the Color QuickDraw chapter in this volume for a discussion of the new picture opcode.

Providing for Spacing

Between

Multiple Style Runs

To handle the spacing between multiple style runs on a line correctly, the new justification
routines take a styleRunPosition parameter that specifies the position of the style run on
a line.
The values for styleRunPosition are as follows:
Constant

Value

smOnlyStyleRun
smLeftStyleRun

0
l

smRightStyleRun

=

smMiddleStyleRun

3

Meaning
This style run is the only one on the line.
Multiple style runs are on the line, and this
is the leftmost.
Multiple style runs are on the line, and this
is the rightmost.
Multiple style runs are on the line, and this
is neither the leftmost nor the rightmost.

If styleRunPosition has the value smOnlyStyleRun, the justification routines behave exactly
like their earlier versions. For other values of styleRunPosition, the behavior may depend on
the script. The behavior for the Roman script is described in “Justifying Text on the Roman
Script System” later in this chapter.
FUNCTION

NPortionText

(textPtr:

Ptr;

textLen:

LongInt;

styleRunPosition:
JustStyleCode;
denom:
Point)
: Fixed;

—

numer:

Point;

i

=
—
~
an
—
—

The NPortionText function allows you to find out how to distribute the slop value for a
line among the style runs on the line. The textPtr parameter is a pointer to the text while
textLength is a long integer that indicates the length of the text. The function returns a
fixed “magic number” that is based on the number of spaces, number of characters,
font, size, style, styleRunPosition value, and the scaling parameters.
You should call NPortionText for all of the style runs on a line, and the slop value for the line
should be allocated among the style runs in the same ratio as their NPortionText return values.
To allocate spacing among multiple style runs, you can specify the position of a style run
within the line by using the styleRunPosition parameter of type JustStyleCode. See the
beginning of this section for a list of the values and meanings for these constants.
For example, suppose that there are three style runs on a line: A, B, and C. The line needs to
be widened by 11 pixels for justification. Calling PortionText on these format runs yields the
first row in Table 14-8.

Script Manager Routines

= 14-65

Q.
<<

<=

me

Qa.
@

2
-_
=

=

—

=
oS
“
@

Inside Macintosh, Volume VI

Table

14-8.

Proportions of slop value to be distributed

PortionText
Normalized
Pixels (p)
Rounded (r)

A

B

C

Total

5.4
258
2.84
3

%3
349
3.84
4

8.2
remainder
remainder
remainder

20.9
1.00
11.0
1]

You can use these values to compute weighted spacing. The proportion of the justification to
be allotted to A is 25.8 percent, so it receives 3 pixels out of 11. In general, to prevent
rounding errors, r, = round(>),.» p) — X7..n-7 r (which can be computed iteratively); for

example, rg is round(3.84+2.84) — 3, and rc is round(11.0) — 7.

Listing 14-3 provides a code sample that illustrates the action of the NPortionText function.

The CalcJustAmount routine in Listing 14-3 expects an array of the following type of records.
RunRecord

=

RECORD

ePEr:
tLength:

Ptr;
Longint;

{ptr to
{length

the text}
of run}

tFace:

style;

{txFace

of

tFont:
tSize:

Integer;
Integer;

{font
family
{pt size}

tPlaceOnLine:
tnumer, tdenom:
tJustAmount:

JustStyleCode;
Point;
{scaling factors}
Fixed
{this value calculated

run}
number

for

run's

font}

here}

END;

RunArray

=

ARRAY[1..MaxRuns]

OF

RunRecord;

The CalcJustAmount routine also takes as a parameter a count of the total number of records
that the array contains. Finally, the extra pixel width to be distributed is passed in as the
TotalPixelSlop parameter. The routine calculates the amount of slop that should be allocated
to each run, and assigns that value to the field tJustAmount.
Listing 14-3. Distributing slop value among style runs
PROCEDURE

CalcJustAmount

(rArray:

RunArray;

TotalPixelSlop:

VAR
Eis

Integer;

TotalSlopProportion:

Fixed;

NRuns:
Integer;
Integer) ;

BEGIN

{First
{
{

find the proportion
the tJustAmount
field

for each run,
temporarily
remembering
of the record,
and summing
the
}
returned
values
in TotalSlopProportion. }
TotalSlopProportion
:= 0;
in

FOR

I

:=

1

TO

NRuns

DO

WITH
{set

rArray[I]
DO BEGIN
the grafPort's
font
TextFace(tFace) ;

TextFont

(tFont)

;

TextSize(tSize);

14-66

— Script Manager Routines

settings

to

correspond

to

this

run}

it

}

Worldwide Software Overview

tJustAmount

:=

NPortionText

TotalSlopProportion

:=

(tPtr,tLength,

tPlaceOnLine,

tnumer,

;

tdenom)

TotalSlopProportion

+

tJustAmount;

END;

{Having
{

found

the

portion

(

runportion

of

slop

normalize

it

{

that

to

{

UnRounded
Pixels
( (runportion
FOR I := 1 TO NRuns
DO
WITH
rArray[I]
DO

value

{Note

you

{

FixRound

the

can

tJustAmount
FixMul

/

to

be

allocated

totalportion),

and

to

each

then

run,

convert

}
}

}

round

the

value

/

totalportion)

calculated

here

*

by

TotalPixelSlop

using

).}

}

routine. }
:=

(FixDiv(tJustAmount,

TotalSlopProportion)

,TotalPixelSlop)

;

END;

You can draw text at the current pen location with
PROCEDURE

NDrawJust

(textPtr:

Ptr;

textLen:

styleRunPosition:
denom:

NDrawJust.
LongInt;

slop:

JustStyleCode;

Fixed;

numer:

Point;

Point);

The NDrawJust procedure draws the given text at the current pen location in the current font,
style, and size. The slop parameter indicates how many extra pixels are to be added to the
width of the text after it has been scaled according to the numer and denom parameters. This
routine is useful for justifying text. For correct spacing between multiple style runs, you can
specify the position of a style run within the line by using the styleRunPosition parameter of
type JustStyleCode. See the beginning of this section for a list of the values and meanings for
these constants.
Note:

—"
ae

In the NMeasureJust, NChar2Pixel, and NPixel2Char routines, described in

<

=

the following sections, the text length should equal the entire visible part of the style

S

run on a line and should include trailing spaces if and only if they are displayed.
(They may not be displayed for the last style run in the line, for example.) Otherwise,
the results for the last character on the line may be invalid.

mt

——
lm!

ee
<<

<

ome

a
@

2)
o

PROCEDURE

NMeasureJust

(textPtr:

Ptr;

charLocs:

numer:

Ptr;

Point;

textLen:

LongInt;

styleRunPosition:

denom:

slop:

=r
poe”

Fixed;

=

JustStyleCode;

Point);

The NMeasureJust procedure measures text that may be justified. The charLocs parameter
points to an array of textLen+1 integers where textLen is the number of bytes. The slop
parameter indicates how many extra pixels are to be added to the width of the text after it has
been scaled according to the numer and denom parameters. NMeasureJust computes the
width from the beginning of the string to the trailing edge of each character, taking into
account slop, scaling, and style run position. On return, the first charLocs entry contains 0;
remaining entries contain the widths to the corresponding offsets in the string. For correct
spacing between multiple style runs, you can specify the position of a style run within the line
by using the styleRunPosition parameter of type JustStyleCode. See the beginning of this
section for a list of the values and meanings for these constants.
Script Manager Routines

14-67

9

es
®

Inside Macintosh,

FUNCTION

Volume VI

NChar2Pixel

(textBuf:

Ptr;

textLen:

LongInt;

slop:

Fixed;

offset:
LongInt;
styleRunPosition:

direction:
Integer;
JustStyleCode;
numer:

denom:

Integer;

Point)

:

Point;

The NChar2Pixel function finds the screen position of carets and selection points, given the
text buffer and an offset. NChar2Pixel is the inverse of NPixel2Char. For left-to-right scripts
(including Kanji), this function works the same way as the QuickDraw TextWidth function.
For correct spacing between multiple style runs, you can specify the position of a style run
within the line by using the styleRunPosition parameter of type JustStyleCode. See the beginning of this section for a list of the values and meanings for these constants.
FUNCTION

NPixel2Char

(textBuf:

Ptr;

pixelWidth:
VAR

textLen:
Fixed;

VAR

widthRemaining:

JustStyleCode;

numer:

LongInt;

slop:

leadingEdge:

Fixed;

Fixed;
Boolean;

styleRunPosition:

Point;

denom:

Point)

Integer;

The NPixel2Char function helps you find the nearest character offset within a text buffer
corresponding to a given pixel width. It returns an integer that is the offset of the character
closest to pixelWidth. It is the inverse of the NChar2Pixel function. The most common
application of NPixel2Char is identifying the character where a mouse-down event occurs
in text and whether it is on the leading or trailing edge of the character. For correct spacing
between multiple style runs, you can specify the position of a style run within the line by
using the styleRunPosition parameter of type JustStyleCode. See the beginning of this
section for a list of the values and meanings for these constants.

Justifying Text on the Roman

Script System

This section describes several important points about the way text is justified in the Roman
Script System:
a The weight for allocating extra space to each nonspace character is in the form of a
percentage. This percentage is given by the Script Manager’s smgrCharPortion global

variable as a 4.12 fixed-point number, which can be read with GetEnvirons and set

with SetEnvirons by using the smCharPortion verb. There is no threshold for initiating
intercharacter spacing, so this is not a highly sophisticated model.
m Every space in a style run is allocated the same amount of extra width and thus is the
same size, whether or not it is at the beginning or end of the line or the style run.
m For characters that are neither at the beginning nor at the end of the line, half of the
charExtra width is allocated on each side of the character. Characters that are at the
beginning or end of the line are only allocated half of the charExtra width, which
appears on the side of the character toward the center of the line.
m The Script Manager text justification routines do not automatically strip trailing spaces.
To strip trailing spaces in the last style run on the line, call the VisibleLength function
for the last style run and pass its return value to these routines as the length of the
last run.

14-68

— Script Manager Routines

Worldwide Software Overview

Figure 14-25 illustrates this model for the justification of text.
Style |<«—
runs
Cursor

locations :
tre

width

Beginning

Style run 1

;

|

‘aes Sai ie

: (space)

Tes

End of line —>

of line

i

+

pe

A

;

ee

B

Style run 2

pee
;

pe

Lath at one

A

;

B

pris pa ay

Style run 3

|

ooo ae weit2, Seay) il.ts

:

iy

(Space)

Figure 14-25. Justification in Roman

re

a

‘ (space) '

|

l

rey

ry

S

B:

text

Here’s how the Script Manager computes the spacing factors for Roman text.
At the beginning of the line layout process, the Script Manager bases its values on information
obtained by examining the text and a global variable that contains the ratio used to allocate
space among intercharacter spacing and interword spacing.
Note: The elements in the equations used subsequently in this discussion are
defined here.
Value

Meaning

NumChars

The number of nonspace characters in the style run.

NumSpaces

The number of space characters in the style run.

CharPortion

The weight for allocating slop to intercharacter spacing versus
interword spacing.

Ciel

SpacePortion

BON

<

<~

—)
ser |
os

1.0 — CharPortion; the weight for allocating slop to interword spacing.

a

Soot

<

<

ms

-!

—

@

The number of intercharacter spaces in a given style run is not necessarily the same as
NumChars because characters at the beginning or end of the line are only allocated half
an intercharacter space. The styleRunPosition parameter for the style run must be used
to determine NumInterCharSpaces for the style run.

ZN
-_~
—

esc)

-

x

pe)

Lor

ce

NumiInterCharSpaces equals
we NumChars — 1.0, if styleRunPosition

= smOnlyStyleRun

a NumChars — 0.5, if styleRunPosition = smLeftStyleRun
a NumChars — 0.5, if styleRunPosition = smRightStyleRun
a NumChars, if styleRunPosition = smMiddleStyleRun

Script Manager Routines

—_ 14-69

4

Inside Macintosh,

Volume VI

A total weighted spacing for the style run can then be computed, as follows:
TotWeightedSpace = (NumInterCharSpaces * CharPortion) + (NumSpaces * SpacePortion)
For Roman text, the NPortionText function returns a value based on TotWeightedSpace,
the font size, and the scaling factors. It is also adjusted by a factor of 32 for backward
compatibility with PortionText results.
NPortionText = TotWeightedSpace * fontSize * (numer.h/denom.h) / 32.0

By calling NPortionText for each style run on a line, the slop value for the line can be
allocated among each of the style runs on the line to obtain StyleRunSlop for each style run.
StyleRunSlop equals the amount of slop value allocated to this style run—that is, the number
of pixels by which the style run should be increased or decreased in width after numeratordenominator scaling has been applied.
Finally, using TotWeightedSpace and StyleRunSlop, the values MoreSpaceExtra and
MoreCharExtra for the style run can be determined—that is, the extra width for each space
character and nonspace character after numerator-denominator scaling has been applied.
MoreSpaceExtra = (SpacePortion * StyleRunSlop / TotWeightedSpace)
MoreCharExtra = (CharPortion * StyleRunSlop / TotWeightedSpace)
Figure 14-26 demonstrates the capabilities of the Roman justification routines, DrawJust and
NDrawJust, compared to the QuickDraw routines, DrawText and StdText.
numer.h

|

2

numer

denom.h

|

1

denomy

5
|

sip

|

60

4

on | Scale AND justify!
Pixel

width

Drawtext [Scale AND justify!
StdText

|Scale

DrawJust

lscate

NDrawJust

[Scale

AND
AND

118

justify!
justify!

AND

178

justify!

Figure 14-26. The effects of the Roman justification routines

14-70

Script Manager Routines

236

296

Worldwide Software Overview

USING THE
ROUTINES

INTERNATIONAL

UTILITIES

PACKAGE

The International Utilities Package is part of the System file. It has the resource type 'PACK'
and resource ID 6. This package contains code that uses the information in the international
resources to handle string comparison and the presentation of time, currency, and numbers
around the world. These vary from script to script, language to language, and region to
region, and your application should take advantage of the Macintosh Operating System’s
ability to present this information in the correct format.
The International Utilities Package works in conjunction with the Script Manager.
Formatting options provide flexibility in specifying exactly how dates and times are
to be displayed. The string comparison capabilities handle non-Roman writing
systems, such as Arabic and Japanese.
For more information about packages in general, see the Package Manager chapters in
Volumes I and V.
You need to use the International Utilities Package to enable your application to run in regions
other than your own. For details on the International Utilities Package routines and data
structures available prior to system software version 7.0, see Volumes I and V.
The following enhancements are available in the International Utilities Package with system
software version 7.0. You can now
ws obtain tables from the ‘itl2' and ‘i1tl4' resources

use application-supplied 'itl2' and ‘itl4' resources more easily
deme

—

specify resource handles explicitly for additional routines

<

=
a!
~
—

w determine the interscript sorting order

—

2.
=
=

m use special script and language codes with the new routines
Brief descriptions of the routines and features appear in the next section, “Overview of the
International Utilities Package Routines.”
With system software version 7.0, the new [UScriptOrder, [ULangOrder, [UStringOrder,
IUTextOrder, and [UGetItITable routines (described in “Facilitating Interscript Sorting
Order” and “Manipulating the ‘itl2' and ‘itl4' Resources” later in this chapter) accept special
script or language codes. These script and language codes facilitate the process of sorting text
between scripts and languages. For these routines, system software version 7.0 has defined
these new types: ScriptCode and LangCode. A valid ScriptCode type can be an integer in the
range 0—64 that explicitly indicates a particular script, or it can be a negative value with a
special meaning. A valid LangCode type can be a nonnegative integer that explicitly indicates
a particular language, or it can be a negative value with a special meaning. See “Summary of
the International Utilities Package” near the end of this chapter for the list of these codes.

Using the International Utilities Package Routines

— 14-71

2.
&
r
PY
nl

=
—_

=

oN)
on
@

Inside Macintosh,

Volume

VI

OVERVIEW OF THE INTERNATIONAL
PACKAGE ROUTINES

UTILITIES

All the International Utilities Package routines are described briefly in this section. The
routines [ULDateString and [ULTimeString, previously undocumented in /nside Macintosh,
are also summarized, and their interfaces appear in “Summary of the International Utilities
Package” near the end of this chapter. The new routines available with system software
version 7.0 are identified by an asterisk (*).

Comparing

Strings

The International Utilities Package includes a number of routines to compare strings and give
their exact sorting relationship or determine whether or not they are equal. System software
version 7.0 includes parallel forms for the sorting functions [UCompString, [UMagString,
TUEqualString, and [UMagIDString to permit explicit specification of an ‘itl2' resource
handle. These parallel forms, whose names end with PString, are in the following list. If this
handle is NIL, the routines behave just like the previous routines that don’t permit explicit
specification of the handle.
IUCompString

| Compares two Pascal strings for primary and secondary ordering and
determines whether one is greater than, less than, or equal to another

[UCompPString*

Compares two Pascal strings for primary and secondary ordering and
determines whether one is greater than, less than, or equal to another
and permits explicit specification of the 'itl2' resource to be used for
string comparison

[UMagString

Compares two strings defined by a pointer and character length for
primary and secondary ordering and determines whether one is greater
than, less than, or equal to another

IUMagPString*

Compares two strings defined by a pointer and character length for
primary and secondary ordering and determines whether one is greater
than, less than, or equal to another and permits explicit specification of
the 'itl2' resource to be used for string comparison

[UEqualString

Compares two Pascal strings for equality in primary ordering only

[UEqualPString*

Compares two Pascal strings for equality in primary ordering only and
permits explicit specification of the 'itl2' resource to be used for string
comparison

IUMagIDString

Compares two strings defined by a pointer and character length for
equality in primary ordering only

[UMagIDPString*

Compares two strings defined by a pointer and character length for
equality in primary ordering only and permits explicit specification of
the 'itl2' resource to be used for string comparison

14-72

Overview of the International Utilities Package Routines

Worldwide Software Overview

Modifying

the Standard

String Comparison

To modify the standard string comparison, you need to construct your own ‘itl2’ resource.
You may want to modify the standard string comparison if the one provided by the International Utilities Package doesn’t meet your needs or if the string comparison for the language
that concerns you is not available. If you supply an ‘itl2' resource in an application, you
will need to call the [UClearCache procedure or call one of the new PString comparison
routines that allow you to pass in a handle to an 'itl2' resource. (See “Accessing the International Resources,” “Manipulating the 'itl2' and 'itl4' Resources,” and “Specifying
Resource Handles Explicitly” later in this chapter.)
For details on modifying the standard string comparison, consult Macintosh Developer
Technical Support.

Assembly-language note: See “Summary of the International Utilities
Package” near the end of this chapter for a corrected version of the stack
frame, I[USortFrame, used for the 'itl2' sorting routines before system
software version 7.0 and for the stack frame, IUNSortFrame, used beginning
with version 7.0. Consult Macintosh Developer Technical Support for more
information on using these sorting frames and for the source code for the
U.S. 'itl2' resource, which you may use as a basis for creating your own
‘itl2' resource.

Facilitating

Interscript Sorting

Order

With system software version 7.0, the [UScriptOrder, [ULangOrder, [UStringOrder, and
[UTextOrder functions make it easier to sort text between different scripts. The functions
use the special script and language codes described in “Script and Language Codes” later
in this chapter.
IUScriptOrder*
[ULangOrder*

— Given a pair of script codes, indicates in what order the text in the two
scripts should be sorted
Given a pair of language codes, indicates in what order the text in the
two languages should be sorted

—
AN

<—

—
~
=

ar |

=Y
<a
<

me
Q.

“@

L

lg

-—

=
ss

=

pe)

Ler

[UStringOrder*
IUTextOrder*

@

— Given a pair of strings with a script and language code for each,
indicates the proper sorting order of the strings
Given a pair of strings defined by a pointer and character length (with a
script and language code for each), indicates the proper sorting order of
the strings

The ordering of script and language codes is based on information in the ‘itlm' resource.
However, the system script is always sorted first, and scripts that are not enabled and
installed are sorted last.

Overview of the International Utilities Package Routines

— 14-73

|

Inside Macintosh,

Accessing

Volume

the

VI

International

Resources

With system software version 7.0, three improvements have been made to the caching of
handles for the ‘itl2' and ‘itl4' resources.

a System and application caches are separate. The application cache is part of the context
that is handled by the Process Manager. The system cache is initialized during system
startup with handles to the 'itl2' and 'itl4' resources in the System file. When an
application is launched, the application cache is initialized from the system cache.
a Although any application can call the SetScript function to change the default ID for a
particular script’s ‘itl2' or 'itl4' resource, this alone no longer affects any cached
handles. An application must call the [UClearCache procedure in order for its cache to
be reloaded. When the cache is reloaded, the current default IDs for each script are used.
Consequently, applications that provide their own ‘itl2' and 'itl4' resources do not affect
the use of these resources in other applications, nor do they affect system behavior that
depends on these resources.
mw To provide increased efficiency in a multiscript environment, each cache has an entry for
the ‘itl2' and ‘itl4' handles for every installed script.
New with system software version 7.0, the [UGetItITable and [UClearCache procedures
allow you to obtain specific tables from the ‘itl2' and 'itl4' resources and make it easier for
you to supply your own ‘itl2' and 'itl4' resources. The supported table codes for the
[UGetIt!Table procedure appear in “Manipulating the ‘itl2' and 'itl4' Resources” and
“Summary of the International Utilities Package” later in this chapter.
[1UGetIntl

Given the type of international resource (‘itl0', ‘itl1', '1tl2', or ‘itl4'),
returns a handle to the correct resource based on the current font script,
the system script, and the IntlForce flag

TUSetIntl

Only sets fields in the obsolete 'INTL' 0 and 'INTL' | resources,

which have been superseded by the ‘itlO' and ‘itll’ resources (It has

been retained for backward compatibility.)

IUClearCache*

— Clears the application cache containing the ‘itl2' and ‘itl4' handles,
which is useful if applications want to supply an ‘itl2' or 'itl4' resource

[UGetItITable*

| Given a script code and a table code, returns a handle to the ‘itl2' or
‘1tl4' resource that contains the table, the offset of the specified table
from the beginning of the resource, and the length of the resource

Localizing

Dates,

Times,

and

Metric

Information

You can obtain a string corresponding to a date or time by passing the long integer you get
from the operating-system GetDateTime procedure to the [UDateString or [UTimeString
procedure. These procedures get the localized information to format the data from the 'itlO'
resource or ‘itll’ resource. The [ULDateString and IULTimeString routines take a date
specified as a LongDateTime type and return formatted strings. These two routines have
not been previously documented in /nside Macintosh. For interfaces to [ULDateString and
IULTimeString, see “Summary of the International Utilities Package” near the end of this
chapter. See Macintosh Worldwide Development: Guide to System Software for comprehensive details on the [ULDateString and [ULTimeString routines.
14-74

Overview of the International Utilities Package Routines

Worldwide Software Overview

With the [UDatePString, [UTimePString, [ULDateString, and [ULTimeString routines, you
explicitly specify the handle of an international resource that contains the format information.
The [UMetric function lets you find out whether the metric system is to be used.
[UDateString

Fills out a string representing a short, abbreviated, or long form of the
date corresponding to the long integer date returned by GetDateTime

[UDatePString

Fills out a string representing a date corresponding to the long integer
date returned by GetDateTime by using format information from the
specified resource

[ULDateString

Takes a date specified in a LongDateTime format and returns a short
date, abbreviated date, or long date as a string formatted according to
the specified international resource

1UTimeString

Takes a long integer time returned by GetDateTime and returns a
formatted string

[UTimePString

Takes a long integer time returned by GetDateTime and returns a string
formatted according to the specified international resource

[ULTimeString

Takes a time specified in a LongDateTime format and returns a string
formatted according to the specified international resource

TUMetric

Indicates whether or not the metric system is to be used

INTERNATIONAL

UTILITIES

PACKAGE

ROUTINES

With system software version 7.0, the International Utilities Package supplies a number of
routines and data types that make it easier for you to use multiple scripts and languages in
your applications.

—

pS
_

4

~
=

3

—

a

Script and

Language

Codes

<<

<=

mm

-!

es

‘a°)

The International Utilities Package provides the [UScriptOrder, [ULangOrder,
[UStringOrder, [UTextOrder, and [UGetItlTable routines that accept script or language
codes. For these routines, the data types ScriptCode and LangCode are defined as follows:
TYPE

ScriptCode

=

Integer;

LangCode

=

Integer;

Valid values for a parameter of type ScriptCode are integers in the range 0-64 that explicitly
indicate a particular script, or one of the following negative values:
Constant

iuSystemScript
iuCurrentScript

Value

Meaning

—|
—2

System script
Current script (as returned by FontScript)
International Utilities Package Routines

= 14-75

ZN
~
=

=
uw
<

-—
as
aS
—

u

Les)

Inside Macintosh, Volume VI

A valid value for a parameter of type LangCode is a nonnegative integer that explicitly
indicates a particular language, or is one of the following negative values:
Constant

Value

Meaning

iuSystemCurLang

—2

iuSystemDefLang

—3

Current language for system script
(from script global variables)
Default language for system script

iuCurrentCurLang

—+

iuCurrentDefLang

—5

iuScriptCurLang*

—6

iuScriptDefLang

—7

(from ‘ithm' resource)

Current language for current script
(from script global variables)
Default language for current script
(from ‘itlm' resource)

Current language for specified script
(from script global variables)
Default language for specified script
(from ‘ithm' resource)

*If the script system is not installed, the International Utilities Package can’t determine the
current language, so it uses the default language.
Not all of the routines that have ScriptCode or LangCode parameters support all of the special
negative values; the exceptions are noted in relevant routine descriptions in “Manipulating the
‘it12' and ‘itl4' Resources” and “Determining Interscript Sorting Order” later in this chapter.

Manipulating

the ‘itl2' and

‘itl4' Resources

With system software version 7.0, the [UGetItITable and [UClearCache procedures let you
get specific tables from the ‘itl2' and 'itl4' resources and facilitate the process of supplying
your own ‘itl2' and ‘itl4' resources.
PROCEDURE

IUClearCache;

The I[UClearCache procedure clears the application cache containing the 'itl2' and ‘itl4'
resource handles for the current script. Applications that provide their own ‘itl2' or ‘itl4'
resource and want them to be used as the default for the corresponding script should call
IUClearCache at entry to ensure that the supplied ‘itl2' or 'itl4' resource is used instead
of the system’s 'itl2' and 'itl4' resources.
Note: The current default ID numbers for the script’s 'itl2' and 'itl4' resources
are stored in the script’s local variables. These values may be read with the GetScript
and SetScript functions using the verbs smScriptSort (for the 'itl2’ resource) and
smScriptToken (for the ‘itl4' resource). Before calling [UClearCache, you should set
the script’s default ID number to the ID of the resource that you are supplying.
If the IntlForce flag is TRUE, the ID must be in the system script range. Otherwise, the ID
must be in the appropriate range of the font script. See the discussion of the IntlForce flag in
“Using the International and Keyboard Resources” later in this chapter for details.

14-76

— International Utilities Package Routines

Worldwide Software Overview

A

Warning: If you use the SetScript function to change the value of the ‘itl2'
resource ID, you should restore the original resource ID before your application
quits. This minimizes the effects on other applications. a

PROCEDURE

IUGetItlTable

(script:
VAR
VAR

ScriptCode;

tableCode:

itlHandle:
Handle;
length:
LongInt);

VAR

Integer;

offset:

LongInt;

Given a script code and a table code, [UGetItlTable returns a handle to the ‘it!2' or ‘itl4'
resource containing the table, the offset of the specified table from the beginning of the
resource, and the length of the resource. At present, the supported table codes are as follows:
Table

code

symbol

Value

Retrieves

iuWordSelectTable

0

Word selection break table (‘itI2')

iuNumberPartsTable
iuUnTokenTable
iuWhiteSpaceList

2
3
4

Default number parts table (‘itl4')
Untoken table (‘itl4')
White space list table (‘itl4')

iuWordWrapTable

|

Word wrap break table (‘itl2')

[UGetItlTable only checks the default 'itl2' or ‘itl4' resource for the script—that is, the ‘itl2'
or 'itl4' resource whose ID is specified in the script’s local variables. The itlHandle parameter
is set to O for any of the following error conditions: the script or the table code is invalid; the
script is not installed or not enabled; or the required resource can’t be found or is not in the
current format. For details on the word selection break table and word wrap break table, see
“Localizing Word Selection and Line Break Tables” earlier in this chapter. For details on the
white space list table, see “The 'itl4' Resource” later in this chapter. For details on the default
number parts table and the untoken table, consult Macintosh Developer Technical Support.
—

rs

Specifying

Resource

Handles

Explicitly

<
a
o

Currently, the [UDateString and IUTimeString procedures have the parallel forms
I1UDatePString and [UTimePString, which permit the caller to specify a resource handle
explicitly. System software version 7.0 includes similar parallel forms for the sorting
functions—IUComppPString, [UMagPString, [UEqualPString, and [UMagIDPString—
that permit explicit specification of an 'itl2' resource handle in the itl2Handle parameter.
If this handle is NIL, the routines behave just like the forms that don’t permit explicit
specification of the handle. See the International Utilities Package chapter in Volume I
for more information on the [UCompString, [UMagString, [UEqualString, and
1UMagIDString functions.
FUNCTION

IUCompPString

(aStr,bStr:

Str255;

itl2Handle:

Handle)

Integer;

FUNCTION

IUMagPString

(aPtr,bPtr:
itl2Handle:

Ptr;

aLen,bLen:

Handle)

:

Integer;

Integer;

International Utilities Package Routines

— 14-77

&
<

<

ay
o
a
=)
=
=
oS

ign

®

Inside Macintosh, Volume VI

FUNCTION

IUEqualPString

(aStr,bStr:

Str255;

itl2Handle:

Handle)

Integer;

FUNCTION

IUMagIDPString

(aPtr,bPtr:

Ptr;

itl2Handle:

aLen,bLen:

Handle)

:

Integer;

Integer;

Note: The [UCompPString and [UEqualPString functions are available for
high-level languages only.

Determining

Interscript Sorting

Order

The IUScriptOrder, [ULangOrder, [UStringOrder, and [UTextOrder functions provide for
interscript and interlanguage sorting.
FUNCTION

IUScriptOrder

(scriptl,script2:

ScriptCode)

:

Integer;

The [UScriptOrder function takes a pair of script codes and returns —1, 1, or 0, depending on

whether text in the first script should be sorted before, after, or in the same place as text in the
second script. The system script is always sorted first.
FUNCTION

IULangOrder

(languagel,language2:

LangCode)

:

Integer;

The [ULangOrder function takes a pair of language codes and returns —1, 1, or 0, depending
on whether text in the first language should be sorted before, after, or in the same place as
text in the second language. The language codes iuScriptCurLang and iuScriptDefLang are
not valid for [ULangOrder because no script is specified. Languages that belong to different
scripts are sorted in the same order as the scripts to which they belong.
FUNCTION

IUStringOrder

(aStr,bStr:

Str255;

bScript:

ScriptCode;

aLang,bLang:

FUNCTION

IUTextOrder

(aPtr,bPtr:

LangCode)

Ptr;

:

aLen,bLen:

aScript,bScript:
aLang,bLang:

aScript,
Integer;

Integer;

ScriptCode;

LangCode)

:

Integer;

The [UStringOrder and [UTextOrder functions are similar to the [UCompString and
IUMagString functions, except that they take a script and language code for each string.
[UStringOrder and [UTextOrder use IUScriptOrder, [ULangOrder, and [UMagPString
to return —1, 0, or 1, indicating the proper ordering of strings that may be in different
scripts or languages. If the result of [UScriptOrder(aScript,bScript) is not 0, then it is
returned as the result of [UStringOrder or [UTextOrder. If the result is 0, aLang and bLang
are checked; if these are different, then they determine the function result. If they are not

different, the strings are in the same script and language and are compared using the
sorting for that script and language. If that script is not installed and enabled, the sorting is
performed using the script specified by IntlScript.

14-78

— International Utilities Package Routines

Worldwide Software Overview

The IUStringOrder and [UTextOrder functions are primarily used to insert strings in a
sorted list; for sorting, it may be faster to sort first by script and language by using the
TUScriptOrder and [ULangOrder functions, and then to call [UCompPString to sort strings
within a script or language group.
Note:

The [UStringOrder function is for high-level languages only.

For all of these sorting functions, invalid script or language codes are sorted after valid ones.
Note that these functions can move memory.

USING

THE

INTERNATIONAL

AND

KEYBOARD

RESOURCES

This section gives an overview of the international resources, including the keyboard resources.
The ‘itIm', optional 'itl5', 'kcs#', 'kcs4', and 'kcs8' resources described here are new with

system software version 7.0. The ‘itl4' and the optional 'itlk' resources described here are not
new with system software version 7.0; however, they have not been previously documented in
Inside Macintosh.
The international resources are stored in the System file as types ‘itlO', ‘itl1', 'itl2', ‘itl4’,
‘it15', ‘itlb’, ‘itle’, 'itlk', and 'itlm'. The 'itlO' and ‘itll' resources contain date, time, and

number formats, and basically correspond to the obsolete 'INTL' (0) and (1) resources. The
formats are similar, but the Script Manager allows multiple 'itl0' and ‘itll’ resources (not

possible with the old 'INTL' (0) and (1) designations). With system software version 7.0,

the ‘itll’ resource permits additional date format information.

The ‘itl2' resource contains procedures for sorting and, beginning with system software
version 6.0.4, contains tables used by the LwrText procedure and by the Roman Script
System’s CharType, Transliterate, and FindWord routines. In version 7.0, these tables
are also used by the LowerText, UpperText, StripText, and StripUpperText procedures.
The ‘'itl4' resource contains localizable tables, code for the tokenizer, and number parts for
use by the Script Manager’s number parsing and formatting routines. The optional ‘itl5'
resource provides information on character set encoding and text rendering behavior. The
‘itIb' resource contains bundle and configuration information for each script. The 'itlc'
resource contains international configuration information for the system as a whole. The
‘itIm' resource specifies preferred sorting order of script codes, language codes, and region
codes and specifies the hierarchical arrangement of these codes.
Each installed script has an associated list of international resource numbers, generally in the
range used for its fonts. For example, the Arabic script has the resources 'itl0', ‘itl1’, '1tl2',
and 'itl4' with numbers in the range $4600 to $47FF; the Roman script has the resources
‘1tl0'" ‘itl1', ‘itl2', and 'itl4' with numbers in the range $0 to $3FFF. The only international
resources without an ID in the font range are the 'itlb' resource, whose ID is its script
number, and the ‘itlc' and ‘itlm' resources, whose IDs are always 0.
If the IntlForce flag is TRUE, the resources used by the International Utilities Package
are determined by the system script. However, you can force them to be determined by
the font script by clearing the IntlForce flag. You can set and clear the IntlForce flag by

Using the International and Keyboard Resources

— 14-79

—

rs
<

=
=

=
=

a.

©

i? 2)
o

=

=

$9
=
©

Inside Macintosh,

Volume V1

using the SetEnvirons function, described in detail in Macintosh Worldwide Development:
Guide to System Software. The selected resources are then used internally by the International Utilities Package.
Table 14-9 shows which international and keyboard resources are included in the U.S. system
software and whether script systems or localized versions of the system software add them to
or replace them in the System file.
Versions of the ‘itlO', 'itl1', ‘itl2', 'itl4', 'KCHR',

'kcs#', 'kcs4', and 'kcs8' resources are

available for all localized versions of the system software. Some localized versions also
provide the ‘itlk' resource. Some non-Roman systems may use an 'itl5' resource.
Table

14-9.

The international and keyboard resources

type

U.S. system software
including Roman Script

System

Localized versions of
system software or other

‘itle'
‘ithm'*
‘jtlb’
‘7tl0'
"itll
"stI2'
‘"itl4'
"1t15'*

Roman ‘itlc'
Default ‘ithm'
Roman ‘itlb'
U.S. '1tl0'
U.S. ell"
U.S; ‘1el2'
U.S. 'itl4'
None

May replace '‘itlc'
May replace ‘itlm'
May add non-Roman ‘itlb'
Adds non-U.S. 'itl0'
Adds non-U.S. ‘itll’
Adds non-U.S. ‘itl2'
Adds non-U.S. ‘itl4'
May add non-Roman ‘itl5'

'KCHR'
"KS WP'
'KMAP'
'kces#'*
'kes4'*
‘kes8'*

U.S. 'KCHR'
Standard 'KSWP'
Includes all necessary 'KMAP's
U.S. 'kcs#'
U.S. 'kes4'
U.S. 'kes8'

Adds non-U.S. 'KCHR'
May replace 'KS WP’
None
7
Adds non-U.S. ‘kcs#'!
Adds non-U.S. 'kcs4"!
Adds non-U.S. 'kcs8't

Resource

‘tlk’

None

script

systems

May add an ‘itlk'?

*New with system software version 7.0
TID corresponds to 'KCHR'

Enhancements

to

International

Resources

System software version 7.0 provides several enhancements to the international resources,
including the following:
m The ‘itlc' resource specifies a region code that identifies a particular localized version of
the Macintosh system software.
u The ‘itlm' resource (new with system software version 7.0) specifies the ordering of
script codes, language codes, and region codes and the hierarchical arrangement of
these codes.

a The ‘itlb' resource specifies font and style information for the script as well as other
script initialization data.

14-80

Using the International and Keyboard Resources

Worldwide Software Overview

a The ‘itll’ resource can be optionally extended to include additional day and month
names, abbreviated day and month names, additional date separators, and a
calendar code.
a The ‘itl2' resource includes length information so that tables (specifically the FindWord
tables a the optional FindScriptRun table) and code blocks now have a length as well
as an offset.
a The optional 'itl5' resource (new with system software version 7.0) supplies character
set encoding data and information on text rendering behavior.
With the exception of the optional 'itl5' resource, these enhancements are described in the
sections that follow.

The

‘itlc'

Resource

The ‘itlc' resource is a configuration resource. Only one ‘itlc' is provided per system. The
‘itlc' resource specifies
system script code
keyboard cache size
w font force flags
m

international keyboard flag (for the Macintosh Plus)

w general bit flags for the Script Manager that indicate
© a Boolean that indicates whether to always show a keyboard icon (before
version 7.0) or Keyboard menu (beginning with version 7.0)

—
i

a
—
=

© a Boolean that indicates whether to use a dual caret for a bidirectional script

=

“|

rl
—
<=
—

a keyboard icon location (beginning with system software version 6.0.4; not used in

—.

fu
om

system software version 7.0)

DN
4
—)
=
-

m preferred region code (beginning with system software version 7.0)

a

I
ra)

The preferred region code is located in a new field replacing part of the reserved space at the
end of ‘itlc'. The field is an integer that contains the system’s preferred region code. The
available values are given by constants whose names begin with the prefix ver (for example,
verFrance). At startup, this integer is copied into a Script Manager global variable that can be
accessed with the GetEnvirons function using the verb smRegionCode. The 'itlc' type
definition has been updated, and a corresponding itlcRegionCode field has been added to the
ItlcRecord data structure. There is no change in the size of the ‘itlc' resource or the ItlcRecord
data structure. See “Summary of the International Utilities Package” at the end of this chapter
for a list of these region code values.

Using the International and Keyboard Resources

14-81

yr |
@

Inside Macintosh, Volume VI

TYPE

ItlcRecord
RECORD

=

script}

system

Integer;

{default

itlcReserved:

Integer;

{reserved}

itlcFontForce:

SignedByte;

{default

font

force

flag}

itlcIntlForce:

SignedByte;

{default

intl

force

flag}

SignedByte;

{old

itlcFlags:
itlcIconOffset:

SignedByte;
Integer;

{general
flags}
{keyboard
icon offset;

itlcSystem:

itlcOldKybd:

keyboard}

{

beginning

{

7.0,

not

itlcIconSide:

SignedByte;

{icon

side}

itlcIconRsvd:

SignedByte;

{rsvd

for

itlcRegionCode:

Integer;

{preferred

itlcReserved3:

ARRAY[0..33]

OF

with

version

}

}

used}

other
verXxx

icon

info}

code}

SignedByte
{for

future

use}

END;

If you do not have access to the MPW file SysTypes.r, which contains the Rez type
definition of the 'itlc' resource, consult with Macintosh Developer Technical Support
for details.

The

‘itlm'

Resource

New with system software version 7.0, the 'itlm' resource specifies the preferred sorting
order for script codes, language codes, and region codes. It also indicates the default
language for each script, the parent script for each language, and the parent language for
each region.
The resource contains a header and three tables. The header includes the version number,
format code, and offsets to the three tables.

a The first table, scriptData, contains a list of script codes in their preferred sorting order.
Each script is paired with the default language code for that script. The max script code
specifies the highest script code that will be handled by the internal Script Manager
structures derived from this table. For example, a max script code of smUninterp(32)
would cover the scripts with codes 0 through 32.
mw The second table, langData, consists of a list of language codes in their preferred sorting
order. Each language code is paired with the code for its parent script. The max language
code specifies the highest language code that will be handled by the internal Script
Manager structures derived from this table. For example, a max language code of
langRussian(32) would cover the languages with codes 0 through 32.
m The third table, regionData, is a list of region codes in their preferred sorting order,
Each region code is paired with the code for its parent language. The max region code
specifies the highest region code that will be handled by the internal Script Manager
structures derived from this table. For example, a max region code of verPakistan(34)
would cover the regions with codes 0 through 34.
Listing 14-4 shows the Rez format for the ‘itlm' resource.

14-82

Using the International and Keyboard Resources

Worldwide Software Overview

Listing 14-4. Multiscript mapping and sorting
type 'itlm'
unsigned
unsigned
unsigned
unsigned
unsigned

{
hex integer;
hex integer;
integer = 3;
longint = scriptData >> 3;
longint = (endScriptData -

/*length of it*/
/*offset
to langData
langData)
>> 3;

unsigned
unsigned

longint
longint

=
=

langData
>> 3;
(endLangData
-

unsigned
unsigned

longint
longint

=
=

regionData >> 3;
(endRegionData -

scriptData:
integer Script;
integer

/*max

Language;
=

/*offset to
regionData)

of

regionData
>> 3;

/*length

of

it*/

code

for

script

lang

Language;

it*/

code

table*/

script->lang

for

scripts

mapping*/

not

*/

sort

order*/

table*/

$$CountOf(scriptArray);/*number

array scriptArray {
integer Script;
integer

in

table*/

/*length

/*default

/*
integer

/*version number* /
/*format code* /
/*number of offset/length pairs*/
/*offset to scriptData table*/
scriptData)
>> 3;

of

entries

in

/*entries are ordered
/*script code*/
/*default

lang

code

by

table*/

script

for

script*/

};
endScriptData:
lancgData:

integer
integer

Language;
Script;

integer

=

/*max lang code for lang->script mapping*/
/*default script code for langs not */
/*

array

in

table*/

$$CountOf(langArray);/*number

langArray

{

/*entries

integer

Language;

/*language

integer

Script;

/*parent

3
endLangData:

of

entries

are

in

table*/

by

lang

ordered

+
sort

order*/

code*/
script

code

for

language*/

=

5.
ws

regionData:

=

integer
integer

Region;
Language;

integer

=

array

=
=

/* in table*/
$$CountOf (regionArray);/*number of

regionArray

integer
integer

/*max region
code
for region->lang mapping*/
/*default
lang code
for regions
not
*/

{

Region;
Language;

/*entries
/*region
/*parent

are

entries
ordered

code*/
language

code

in
by

table*/
region

for

sort

order*/

region*/

3

endRegionData:

}3

Using the International and Keyboard Resources

14-83

o

Inside Macintosh,

Volume VI

Table 14-10 lists a sample hierarchy of script, language, and region codes reflected in the 'itlm'
resource. Region codes do not currently exist for all language codes. See “Summary of the
Script Manager” and “Summary of the International Utilities Package” near the end of this
chapter for details.
Table 14-10.
Script

Script, language, and region codes

code

smRoman

Language

code

langEnglish
langFrench
langGerman

smEastEurRoman
smGreek
smCyrillic
smArabic
smHebrew
smDevanagari
smThai
smJapanese
smTradChinese
smSimpChinese
smKorean

14-84

langltalian
langDutch
langSwedish
langSpanish
langDanish
langPortuguese
langNorwegian
langFinnish
langIcelandic
langMaltese
langTurkish
langLithuanian
langEstonian
langLettish
langLappish
langFaeroese
langCroatian
langPolish
langHungarian
langGreek
langRussia
langArabic
langUrdu
langFarsi
langHebrew
langHindi
langThai
langJapanese
langTradChinese
langSimpChinese
langKorea

— Using the International and Keyboard Resources

Region

code

verUS
verBritain
verAustralia
verFrance
verFrCanada
verFrSwiss
verGermany
verGrSwiss
verltaly
verNetherlands
verSweden
verSpain
verDenmark
verPortugal
verNorway
verFinland
verlceland
verMalta
verTurkey
verLithuania
verEstonia
verLatvia
verLapland
verFaeroels]
verY ugoCroatian
verPoland
verHungary
verGreece
verRussia
verArabic
verPakistan
verlran
verlsrael
verIndiaHindi
verThailand
verJapan
verTaiwan
verChina
verKorea

Worldwide Software Overview

The

‘itlb'

Resource

An ‘itlb' resource functions as a bundle for the corresponding script. Each installed script has
one ‘itlb' resource. The resource ID number for each 'itlb' resource is its corresponding
script code. The 'itlb' resource specifies
m resource IDs for the script’s default resources: 'itlO', ‘itl1', 'itl2', 'itl4', optional 'itl5',
'KCHR’, 'kcs#', 'kcs4', and 'kes8' (or 'SICN' in system software version 6.0)
= script bit flags (Beginning with system software version 7.0, the bit flags include a new
flag that instructs the Script Manager to initialize a script automatically.)
m language code
m number and date representation codes
m

font information (beginning with system software version 7.0)

a style information (beginning with system software version 7.0)
script system initialization data (beginning with system software version 7.0)
The 'itlb' type has been updated in version 7.0. A formerly reserved field in the ‘itlb'
resource is now used to store the ID of the optional 'itlS' resource. This field, itIbEncoding,
is O if the resource is not present. (The 'itI5' resource is not used in the standard U.S.
system.) However, the size of the ItlbRecord data type has not changed because other
structures depend on it remaining a fixed size. Instead, a new data structure, the extended
‘itIlb' record, defined by the data type ItIbExtRecord, includes the ItlbRecord data type and
adds extensions.
Several new fields in the extended ‘itlb' record specify the default 'FOND' ID and font size
for the following: system and application fonts, small font (such as Geneva 9), monospaced
font, user’s preferred font, and the font for Balloon Help. Additional fields specify the set of
valid styles for the script and the set of styles to mark aliases.

—

4
—_

=

So

ad

The updated data structures defined by the ItIbRecord and ItIbExtRecord data types are
as follows:
TYPE

ItlbRecord

Y
—
<a
=

Qo.
@

=

DN
=

RECORD

amc)
-

=

itlbNumber:

Integer;

{'itl0O'

ID

number}

itlbDate:

Integer;

{'itli'

ID

number}

itlbSort:
itlbFlags:
itlbToken:
itlbEncoding:

Integer;
Integer;
Integer;
Integer;

{'itl2'
{script
{'itl4'
{'itl5'

ID number}
flags}
ID number}
ID number

itlbLang:

Integer;

{ character
encoding) }
{current
language
for script}

itlbNumRep:

SignedByte;

{number

itlbDateRep:
itlbKeys:
itlbIcon:

SignedByte;
Integer;
Integer

{date
representation
code}
{'KCHR'
ID number}
{ID number
of
'SICN'
or
'kcs#',
{ 'kes4',
'kes8'
family}

i

Lard

\¢°)

(optional

representation

}

code}

END;

Using the International and Keyboard Resources

— 14-85

}

Inside Macintosh,

Volume VI

ItlbExtRecord

=

RECORD

base:
itlbLocalSize:

ItlbRecord;
Longint;

{unextended
ItlbRecord}
{size of script's
local

itlbMonoFond:

Integer;

{default

monospaced

'FOND'

itlbMonoSize:

Integer;

{default

monospaced

font

itlbPrefFond:

Integer;

{preferred

'FOND'

itlbPrefSize:

Integer;

{preferred

font

itlbSmallFond:

Integer;

{default

small

'FOND'

itlbSmallSize:

Integer;

{default

small

font

record}

ID}
size}

ID}
size}

ID}
size}

itlbSysFond:

Integer;

{default

system

itlbSysSize:
it lbAppFond:

Integer;
Integer;

{default
{default

system
font
application

'FOND'

size}
'FOND'

ID}

itlbAppSize:

Integer;

{default

application

font

itlbHelpFond:
itlbHelpSize:

Integer;
Integer;

{default
{default

Help
Help

Mgr
Mgr

itlbValidStyles:

Style;

{set

of

valid

styles

itlbAliasStyle:

Style

{set

of

styles

to

ID}
size}

'FOND'
ID}
font
size}

for

mark

script}

aliases}

END;

The new bit flag, defined for the script flags word, is located in the itlbFlags field in the ‘itlb'
record data structure. Set the smsfAutolInit bit in a script’s ‘itlb' to instruct the Script Manager
to initialize the script system automatically. (See “Creating Simple Script Systems” earlier in
this chapter for details.)
If you do not have access to the MPW file SysTypes.r, which contains the Rez type for the
‘itIb' resource, consult Macintosh Developer Technical Support for details.

The

‘itl0'

Resource

Documented in the International Utilities Package chapter in Volume V as a replacement for

the 'INTL' (0) resource, the 'itl0' resource contains short date, time, number, and currency

formats as well as the region code for this particular 'itlO' resource. Each installed script has
one or more 'itlO' resources. The resource ID for each ‘itlO0' resource is in the script’s
resource number range. The default 'itlO' resource for a script is specified by the script’s
‘itlb' resource. Each 'itl0' resource specifies
= number format (decimal separator, thousands separator, and list separator)
currency format (including currency symbol and position, leading or trailing zeros, and
how to show negatives)
short date format

time format

region code for this particular 'itlO' resource
If you do not have access to the MPW file SysTypes.r, which contains a Rez definition of
type '1tl0', consult Macintosh Developer Technical Support for details.
Note: The 'INTL' (0) resource is obsolete and will not be supported in future
versions of the system software.
14-86

— Using the International and Keyboard Resources

Worldwide Software Overview

The

‘itli'

Resource

Documented in the International Utilities Package in Volume V as a replacement for the
'INTL' (1) resource, the basic ‘itl1' resource provides information on long date formats:
the order of the date elements, which elements to include, the names of days and months,
and how to abbreviate the names. Each installed script has one or more ‘itll’ resources.
The resource ID for each ‘itll’ resource is in the script’s resource number range. The
default ‘itll’ resource for a script is specified by the script’s ‘itlb' resource. The basic ‘itl1'
resource specifies
a long date format (including month and day names)
m region code for this particular 'itl1' resource
However, this basic format presents several limitations. First, it assumes that 7 day names
and 12 month names are sufficient,which is not true for some calendars. For example, the
traditional Jewish calendar can have 13 months. Second, it assumes that day and month
names can be abbreviated by simply truncating them to a fixed length, but this not true in
many languages.
With system software version 7.0, the ‘itll’ resource may be optionally extended to provide
additional information that solves these problems. As indicated in the discussion in Volume V
about future extensions to this resource, the fields present in the old format have not been
moved. The International Utilities Package routines that generate date strings use information
in the ‘itll’ extension if it is present.
Note:

The 'INTL' (1) resource is obsolete and will not be supported in future

versions of the system software.

The old ‘itl1' format was identical to the 'INTL' (1) format, which ended with a variable-length

field intended to be used for code that altered the standard sorting behavior. This “local routine”
field has been ignored since the introduction of the ‘itl0', 'itl1', and ‘itl2' resources because the
code for changing the sorting behavior was moved to the ‘itl2' resource. Consequently, in most
existing ‘itll’ resources, the local routine field merely contains a single RTS instruction (hexadecimal $4E75). The extended format is now indicated by the presence of the hexadecimal
value $A89F as the first word in the local routine field; this is the unimplemented trap instruction, which could not have been the first word of any valid local routine. The new Rez template
for the 'itll' type can be used to perform a DeRez operation on old-format 'itl1' resources with
$4E75 in this field as well as extended-format 'itl1' resources in which the extended data

begins with the value $A89F.

—

os
=<
—
—)

ae

Q.

c

S
@

ZN
=)
=
~-

=

2

re)

The extended data provides the following additional information, which you can see as part

of the Rez type definition for the 'itl1' resource in Listing 14-5, which follows this list:

= A version number. The byte-length version number in the old part of the 'itl1' resource
has been used for various special purposes over the years, so this field provides a real
version number.
u A separate format code. This code is distinct from the version number. The current
extended format has a format code of 0.
mw A calendar code. Multiple calendars may be available on some systems, and it is necessary
to identify the particular calendar for use with this ‘itll’ resource. Constants for the various
calendars are provided in the “Summary of the Script Manager” near the end of this chapter.
Using the International and Keyboard Resources

— 14-87

Inside Macintosh,

Volume VI

a A

list of extra day names (extraDays). This format is for those calendars with more
than 7 days.

a A

list of extra month names (extraMonths). This format is for those calendars with more
than 12 months.

a A list of abbreviated day names (abbrevDays).
w A

a A

list of abbreviated month names (abbrevMonths).

list of additional date separators (extraSeparators). When parsing date strings, the
String2Date function permits the separators in this list to be used in addition to the
date separators specified elsewhere in the ‘itl0' and ‘itl1' resources.

Listing 14-5 shows the new Rez type for the ‘itll' resource.
Listing 14-5. International date and time information
type

'itll'

{
/*day

array

[7]

names*/

{

/*Sunday,

pstring[i5];

Monday...*/

+?
/*month
array

[12]

names*/

{

/*January,

pstring[15];

ty

February...*/

byte

dayName,

none=255;

/*suppressDay* /

byte
byte

dayMonYear,
monDayYear
=
noDayLeadZero,
dayLeadZero

/*dayLeading0O* /

/*longDate

format*/

byte;

/*abbrLen* /

string[4];

/*st0*/

string[4];

fests)

{/*st2*/
/*st3*/
J/*st4*/

string[4];
string[4];
string[4];
byte
byte;

Region;

switch

/*region

{

case

code*/

/*version*/

oldFormat:

key

hex

integer

extFormat:
key hex integer
hex integer;
hex integer;

S4E75;

/*old-format

SA89F;

/*extended-format
/*version*/

key*/

case

=

/*format*/
/*calendar

integer;

14-88

/*offset
unsigned

to & length
of extraDays
table*/
longint
= extraDays
>> 3;

unsigned

longint

=

(endExtraDays

-

extraDays)

— Using the International and Keyboard Resources

code*/

>>

3;

key*/

Worldwide Software Overview

/*offset
unsigned

to & length of extraMonths
table*/
longint
= extraMonths
>> 3;

unsigned

longint

/*offset
unsigned
unsigned

to & length of abbrevDays table*/
longint = abbrevDays >> 3;
longint = (endAbbrevDays - abbrevDays)

/*offset

to

longint

=

abbrevMonths

unsigned

longint

=

(endAbbrevMonths

unsigned

&

&

=

(endExtraMonths

length

of

length

-

abbrevMonths

-

to

longint

=

extraSeparators

unsigned

longint

=

(endExtraSeparators

-

/*count
(extraDaysArray)

list

array

=

$$CountOf

extraDaysArray

>>

abbrevMonths)

/*offset

integer

>>

3;

3;

table*/

3;

unsigned

extraDays:

of

>>

extraMonths)

extraSeparators
>>

>>

3;

table*/
3;

and
;

extraSeparators)

>>

of

extra

day

extra

month

names*/

3;

names*/

{

pstring;

}7
endExtraDays:
extraMonths:

/*count

integer
array

=

and

list

of

$$CountOf(extraMonthArray) ;

extraMonthArray

{

pstring;

};

endExtraMonths:
abbrevDays:

/*count

integer
array

y}

=

S$$CountOf

and

(abbrevDaysArray)

abbrevDaysArray

list

of

abbreviated

day

names*/

;

{

pstring;

-

=

endAbbrevDays:
abbrevMonths:
integer
array

5
=

$$CountOf

/*count
and list of
(abbrevMonthArray) ;

abbrevMonthArray

abbreviated

month

names*/

{

rf
=

pstring;

+3

=

endAbbrevMonths:
extraSeparators:
integer

©

=

/*count
and list of extra
$$CountOf (extraSeparatorsArray)

array
extraSeparatorsArray
pstring;

date
;

separator

names*/

{

};

endExtraSeparators:

};

=
o

};

Using the International and Keyboard Resources

— 14-89

Inside Macintosh,

The

‘itl2'

Volume VI

Resource

The 'itl2' resource contains the International Utilities Package’s sorting hooks and tables for

character type, case conversion, and word breaks. Each installed script has one or more 'it]2'

resources. The resource ID for each ‘itl2' resource is in the script’s resource number range.
The default 'itl2' resource for a script is specified by the script’s 'itlb' resource. Each ‘itl2'
resource contains
m aheader with offsets and lengths (beginning with system software version 7.0) of all
the code blocks and tables in the 'itl2' resource
m routines and tables for modifying standard string comparison

= optional character type tables for use by a script system’s CharType function (beginning
with system software version 6.0.4)
= optional tables for case conversion and stripping diacritical marks, for use by a script
system’s Transliterate function, by the LwrText procedure (beginning with system
software version 6.0.4), and by the LowerText, UpperText, StripText, and
StripUpperText procedures (beginning with system software version 7.0)
These tables only need to be present for single-byte script systems.
m word break tables for the FindWord procedure
Beginning with system software version 6.0.4, the word break tables used by the
Roman FindWord procedure are included in the 'itl2' resource. Beginning with system
software version 7.0, the word break tables for all scripts are located in each script’s
'itl2' resource.
m an optional new table that provides information on the location of Roman characters in a
non-Roman font to be used by the Roman version of the FindScriptRun function
(beginning with system software version 7.0)
Note: In addition to these changes, the U.S. ‘itl2' resource available with system
software version 7.0 includes word break tables that use the new state table format for
the NFindWord procedure and that support cedilla, double-acute accent, ogonek, and
hacek as letter characters.
If you do not have access to the MPW file SysTypes.r, which contains the new ‘itl2'
template, consult Macintosh Developer Technical Support for details.
The Script Manager’s CharType, Transliterate, and (before system software version 7.0)
FindWord routines are implemented by each script system, and the implementation details may
be different in each case. Before system software version 6.0.4, the Roman versions of
CharType, Transliterate, and FindWord used tables that were built into the code; consequently,
these tables could not be localized to reflect language-specific or region-specific differences in
uppercase conventions and word boundaries. The old LwrText and LwrString routines used
the case conversion tables from the Roman version of Transliterate.

14-90

Using the International and Keyboard Resources

Worldwide Software Overview

With system software version 6.0.4, the tables used by LwrText and LwrString and by the
Roman Script System versions of CharType, Transliterate, and FindWord were removed
from the code and added to the 'itl2'’ resource, and the Roman versions of these routines have
been modified to get their tables from the 'itl2' resource (using the [UGetIntl function).
The advantages of the relocation of these tables include increased localizability of character
type assignments, word break definitions, and case conversion (primarily for accented
Roman characters). For example, the handling of accents when lowercase characters are
converted to uppercase characters depends on language and region, but these tables were not
previously localizable on a region-by-region basis.
A

Warning: Since system software version 6.0.4, LwrString and some script
versions of CharType, Transliterate, and FindWord have gained access to the
‘itl2' resource by using the [UGetIntl function. The relocation of the tables used
by these routines may cause the following problems:
a If [UGetIntl needs to load ‘itl2', it may cause memory to move. As a result,
some of these routines that previously had no effect on memory may now
cause memory to move. (The CharType function is the only one of these
that was specified as a routine that would not move memory.)
w To get the correct tables, the Script Manager examines the current font of the
current grafPort. As a result, LwrString now depends on the A5 register
specifying the current grafPort and the font being set correctly, whereas
previously it never depended on AS. a

Note: Before system software version 7.0, LwrText was the high-level
interface to the LwrString trap. Although this name is still available in version 7.0,
the recommended name is now LowerText for both high-level and assemblylanguage users.

The

‘itl2'

Resource

_

Header

SS
2)

=<

The ‘itl2' resource header allows you to index localized character type and conversion tables
in the Roman Script System. Figure 14-27 shows the structure of the 'itl2' resource header.
All fields in this header are 16-bit words. Each field designated as an offset is the signed
offset, in bytes, from the beginning of the 'itl2' resource to the specified code block or table.
The header is followed by the actual code chunks and tables, which may be in any order. The
position of each is specified by the corresponding offset in the header.

=

With system software version 7.0, the 'itl2' header has been extended to include two new
sections: section 3, containing fields for the lengths of all of the code blocks and tables for
which there are offsets in sections | and 2 in the ‘itl2' resource header, and section 4,
containing offset and length pairs for tables that are new with system software version 6.0.7
and for future tables.

®

Section | of the header contains a format flag and five offsets to code chunks that can be used
to modify the default sorting behavior. Before system software version 6.0.4, the rsvdHook
offset was an unused sorting hook offset. It now is a format flag: a value of—1 indicates that
the 'itl2' resource is in the system software version 6.0.4 (or newer) format.

Using the International and Keyboard Resources

14-91

_

=
<

<

—

=
@

PN
=~
A

=
oe
<A
<

i)

=

Inside Macintosh,

Volume

VI

Section 2 contains offsets to tables for character type (typeList offset, classArray offset),
character conversion (upperList offset, lowerList offset, upperNoMarkList offset, and
noMarkList offset), and word break (wordTable offset and wrapTable offset). These offsets
to tables are used by the LowerText, UpperText, StripText, and StripUpperText procedures
and by the Script Manager’s CharType, Transliterate, and FindWord routines. They are only
used in system software version 6.0.4 and later, and may not be present on earlier systems. It
also contains a version number and a format code that are used by DeRez.
The wordTable offset and wrapTable offset are also offsets to tables used by the Roman
FindWord routines in system software version 6.0.4 and by the general FindWord routine
in system software version 7.0.
The remainder of the fields in the resource header, in Section 3 and Section 4, are only required
in system software version 7.0 and later, and may not be present in earlier versions.
Section 3 contains fields for the lengths of all of the code blocks and tables for which there
are offsets in sections | and 2 of the 'itl2' resource header. Lengths in this section need only

be supplied for tables that may be returned by the GetItITable procedure.

Section 4 contains offset and length pairs for tables to be added in the future. The first
offset/length pair in this section is reserved for the FindScriptTable data type, which
defines an optional table that associates every character code in a single-byte script’s
character set with either the Roman or native script. If this table is not present, the
offset and length should be 0.
The data structure defined by the FindScriptTable type consists of a series of byte pairs with
the format <character code, script code>. The character code is the last character code in a

range of characters that belongs to the script specified by the script code. The first character
code in the range is assumed to be the last character code in the previous range plus |, or 0
for the first range. The last pair must have character code $FF. For example, if the character

set encoding for script smSample were defined such that $00-7F and $A0 were Roman

characters and the remaining characters were native characters in smSample, the table would
appear as follows:
dc.b
dc.b

$7F,smRoman
S$9F,smSample

de.b

$A0,smRoman

dc.b

S$FF,smSample

Figure 14-27 describes the new ‘itl2' header format.

The

'‘itl4'

Resource

Each installed script has one or more 'itl4' resources. The resource ID for each 'itl4' resource
is in the script’s resource number range. The default 'itl4' resource for a script is specified by
the script’s ‘itlb' resource. Each '‘itl4' resource contains
m a header containing offsets to all of the code blocks and tables in the ‘itl4' resource and
(beginning with system software version 7.0) the size of each code block and table
w

14-92

localizable tables and code for the IntITokenize function

Using the International and Keyboard Resources

Worldwide Software Overview

0

initHook offset

2

fetchHook offset

4

vernierHook offset

6

projectHook offset

Section 1: offsets to

,;
sorting hooks

8 | rsvdHook offset/fmt flag
10

exitHook offset

42

typeList offset

14

classArray offset

character type,
conversion, and

16

upperList offset

word break tables

18

lowerList offset

Section 2: offsets to

20 | upperNoMarkList offset

22

wordTable offset

24

wrap Table offset

26

noMarkList offset

28

versionNumber

30

format code

32

initHook length

34

fetchHook length

36

vernierHook length

38

projectHook length

40

reserved

42

exitHook length

44

typeList length

46

classArray length

48

upperList length

50

lowerList length

Section 3: sizes of the

code blocks and tables

—

don
<

=
=)

"3
rae

=
<A
<

wee

a
®

52 | upperNoMarkList length

54

wordTable length

56

wrapTable length

58

noMarkList length

60
62

FindScriptTable offset
FindScriptTable length

Figure

14-27.

2
=

=
ree
~~
<=

+)
bez |
@

{f Section 4: offset and
length pairs for
additional tables

The ‘itl2' resource header

Using the International and Keyboard Resources

14-93

Inside Macintosh,

Volume VI

m localizable number parts tables used by the Str2Format, Format2Str, FormatX2Str, and
FormatStr2X functions

m a table of all the white space characters in the script (new with system software
version 7.0)

As with the ‘itl2' resource, lengths need only be supplied for tables that may be returned
by the GetItITable procedure. A new ‘itl4' record defined by the NItl4Rec data type reflects
these changes.
TYPE

NIitl4Handle
NItl4Rec

=

“NIt1l4Ptr;

=

RECORD

{The
{

flags:

Integer;

resourceType:

Longint;

{contains

'it14'}

resourceNum:

Integer;

{resource

ID}

version:

Integer;

{version

number}

format:
resHeader:

Integer;
Integer;

{format
code}
{reserved}

resHeader2:

LongInt;

{reserved}

numvTables:

Integer;

{number

following

tables

&

code

are

offsets

from

{reserved}

the

of

beginning

of

tables,
the

one-based}

resource

to

}

chunks. }

mapOffset:

Longint;

{offset
to table
{ byte to token}

strOffset:

Longint;

{offset

{
fetchOffset:

LongIint;

{offset
{

to

copies

that

routine

that

canonical
to

byte

{offset

to

untoken

{

token

to

canonical

Longint;

{offset

to

default

whtSpListOffset:

LongIint;

{ parts
{offset

table}
to white

resOffset7:

Longint;

{reserved}

resOffset8:
resLengthl1:

Longint;
Integer;

{reserved}
{reserved}

resLength2:
resLength3:

Integer;
Integer;

{reserved}
{reserved}

unTokenLength:
defPartsLength:

Integer;
Integer;

{length
{length
{ parts

of untoken
of default
table}

whtSpListLength:

Integer;

{length

of

resLength7:
resLength8:

Integer;
Integer

{reserved}
{reserved}

defPartsOffset:

Longint;

}

that

next

unTokenOffset:

}

string}

routine
of

maps

gets

white

table,

maps

number
space

code

table}
number

space

}
list}

}

code

A new section of the 'itl4' resource contains a table of white space characters in the script. A
formerly reserved field in the header specifies the offset to this whiteSpaceList table, and a

Using the International and Keyboard Resources

}

string}

END;

14-94

}

character}

list}

Worldwide Software Overview

new field specifies its length. The format of the table defined by whiteSpaceList is similar to
the format of the untoken table:
dc.w
dec.w

(length
(number

of
of

whiteSpaceList
entries)

in

bytes)

dc.w

(offset

from

beginning

of

whiteSpaceList

to

first

ac.w

(offset

from

beginning

of

whiteSpaceList

to

second

entry)
entry)

Each entry is a Pascal string specifying a single white space character (which may be | or
2 bytes). (If you do not have access to the MPW file SysTypes.r, which contains the Rez
type definition for the 'itl4' resource, consult Macintosh Developer Technical Support.)

Keyboard

Types

and

Modifier Bits

Table 14-11 furnishes a list of the keyboard types. These are used in some of the keyboard
resources: 'KCAP', 'KSWP’, and 'itlk'. The 'KCHR', 'KSWP’, and ‘itlk' resources are
described in the following sections. The 'KCAP' resource is discussed in “Key Caps and
the 'KCAP' Resource” later in this chapter.
Table 14-11.

The keyboard types

Keyboard
type*

Keyboard

OMmANNMNBWN—

Apple Keyboard (Domestic layout)
Apple Extended Keyboard and Apple Extended Keyboard II (Domestic layout)
Macintosh 512K Keyboard (Domestic layout)
Apple Keyboard (ISO layout)
Apple Extended Keyboard II (ISO layout)
Apple Macintosh Portable Keyboard (Domestic layout)
Apple Macintosh Portable Keyboard (ISO layout)
Apple Macintosh Keyboard II (Domestic layout)
Apple Macintosh Keyboard II (ISO layout)
Macintosh 512K Keyboard (ISO layout)

259

7
6
5
4
3
2
l
0

(Right Control if used)
(Right Option if used)
(Right Shift if used)
Control (Left Control if different from Right Control)
Option (Left Option if different from Right Option)
Caps Lock
Shift (Left Shift if different from Right Shift)
Command
Using the International and Keyboard Resources

~~i
=)

as
=!

—

=

La)

r
DN

The keyboard modifier bits

Key

aA

2.

Table 14-12 supplies meanings of the keyboard modifier bits in the high byte of the modifiers
field of an event record (defined by the EventRecord data type). The byte consisting of these
bits is used to control the selection of tables in the 'KCHR' resource.

Bit

—

<A

*This is also the resource ID of the corresponding 'KCAP' resource. The KbdType lowmemory global variable contains the low byte of this value for the last keyboard used.

Table 14-12.

os

14-95

=
—

~
<

=

pet)
or
o

Inside Macintosh,

Volume

The

Resource

'KCHR'

VI]

The 'KCHR' resource specifies the mapping of virtual key codes to character codes (for
example, ASCII). Each installed script system has one or more 'KCHR' resources; there
may be one or more for each language or region to suit the preference of the user. The
resource ID for each 'KCHR' resource is in the script’s resource number range. The default
'KCHR' resource for a script is specified by the script’s ‘itlb' resource. For more on virtual
key codes, see the Toolbox Event Manager chapter in Volume V. If you do not have access to
the MPW file SysTypes.r, which contains the Rez type definition for the 'KCHR' resource,
consult Macintosh Developer Technical Support.

Note: Prior to system software version 7.0, an application could force a script
system to load a 'KCHR' resource that only existed inside its resource fork. Since
'KCHR' resources are used across the system (that is, are not application-specific),
this was an extremely undesirable situation. If an application failed to restore the
appropriate script system variables properly when it terminated or was switched
into the background, the Script Manager attempted to find a'KCHR' resource
that was no longer available.
With version 7.0, the Script Manager has been revised to load only 'KCHR'
resources that are installed in the System file. However, if your application needs
to modify the keyboard layout temporarily without forcing users to install a new
keyboard, you should load a 'KCHR' resource from your resource fork and pass
a pointer to that 'KCHR' resource directly to the _KeyTrans trap.
Figure 14-28 shows the parts of the 'KCHR' resource and how they are used. First, the
modifier state information—8 bits, each indicating the state of one modifier key—is treated as
a byte that is mapped through a 256-byte table-selection table to a table code. The table code
specifies which of several 128-byte mapping tables is used to map the virtual key code to a
character-code byte. If the mapping table has a nonzero entry for a particular virtual key code,
that entry is the desired character code. If the entry is 0, the dead-key tables are searched for a
match with the virtual key code. If there is a match, dead-key state information is set that

affects how the next virtual key code is processed, but no event is posted.
Modifier

Virtual

state

key code

Table selection | _:

table

|
:

i

Table code: ----selects virtual
key code
mapping table

__|—> Zero? —>
|

|

}

N

tables

Virtual key code
mapping tables

|

Character
code

Figure
14-96

14-28.

Inside the 'KCHR'

— Using the International and Keyboard Resources

Dead-key

resource

Worldwide Software Overview

With system software version 7.0, the following changes in the U.S. 'KCHR' resource (0)
have been introduced for greater consistency:
e Since the Shift key is ignored if the Command key is pressed, the 'KCHR' resource has
been changed so the Caps Lock key is also ignored if the Command key is pressed.
w Table 14-13 lists the changes in the handling of Option-Shift-key and Option—Caps
Lock—key combinations. These changes are based on the following principles:
© If either the Option-key or the Option-Shift-key combination produces a letter, then
the Option—Caps Lock—key combination should produce the same character as the
Option-key, not the Option-Shift-key, combination.
o If the Option-key combination is a dead key for a particular accent, then the
Option-Shift-key combination produces the accent directly.
m System software version 7.0 also includes some changes in default dead-key completers,
so that the completer is a “real” accent character instead of a low-ASCI approximation.
The default completer is used when a dead key is entered, but the following key is either
a space or a key for a character that cannot take the accent corresponding to the dead key.
Table 14-14 summarizes these changes.
Table 14-13.

Changes in handling 'KCHR' (0) key combinations

Key
combination
Option—Caps
Option—Caps
Option—Caps
Option—Caps
Option—Caps
Option—Caps

Lock—E
Lock—G
Lock-I
Lock—K
Lock—M
Lock—N

Option—Caps Lock-R
Option—Caps Lock-T

Option—Caps Lock—U

Old
character

New
character

%o
]
E
@ ($FO)
7
°

:
©
7
.
A
~

Acute accent for dead-key Option-E
Be like Option-G, not Option-Shift-G
Circumflex accent for dead-key Option-I
Be like Option-K, not Option-Shift-K
Tilde accent for dead-key Option-N

rs
<

+

Be like Option-T, not Option-Shift-T

>

A
E

®

E

7

,, ($E3)
U
U
%o ($E4)

SS
=
Q
‘

Option-Shift-I
Option-Shift-M

E
~ ($F7)

* ($F6)
A

Option-Shift-R
Option-Shift-T
Option-Shift-U

A
E
E

%oo
’ (SFF)
7

Option—Caps Lock—-V

0)

Option-Shift-G

]

Option—Caps Lock—W
Option—Caps Lock—X
Option—Caps Lock—Z
Option-Shift-E

Option-Shift-N

Option-Shift-X
Option-Shift-Z

Option-Shift-

* ($F6)

U
U

Y

Vv

“ ($FD)

Reason

Be like Option-R, not Option-Shift-R
Umlaut for dead-key Option-U

Be like Option-V, not Option-Shift-V

Be like Option-W, not Option-Shift-W
Be like Option-X, not Option-Shift-X
Be like Option-Z, not Option-Shift-Z
Acute accent for dead-key Option-E
Make ~ (double-acute accent) available

for keyboard
Circumflex accent for dead-key Option-I

~ ($F7)

Tilde accent for dead-key Option-N

. (SFE)
, (SFC)

Make , (ogonek) available for keyboard
Make , (cedilla) available for keyboard

.

Moved %c from Option-Shift-E
Make ~ (hacek) available from keyboard
Umlaut for dead-key Option-U
Grave accent for dead key Option->

Using the International and Keyboard Resources

14-97

S

=

ys
S
=
ni

Inside Macintosh,

Table 14-14.
Dead

Volume

Changes in 'KCHR' dead-key completers

key

Old default
completer

New default
completer

~ ($7E)
4 ($5E)

~ ($F7)
* ($F6)

Option-N
Option-U

The

V1

'kcs#',

'kcs4',

and

'kcs8'

Resources

With system software version 7.0, a keyboard color icon family is available to specify the
small icon that corresponds to each 'KCHR' resource. This color icon family replaces the
'SICN' resource associated with each 'KCHR' resource. See the User Interface Guidelines
chapter earlier in this volume for details on color icon families.
Note: If the 4-bit and 8-bit icons in your application are the same (resources 'kces4'
and 'kcs8'), then you only need to provide a 4-bit icon.
Some differences exist between the color icon family for keyboards and the color icon
families used elsewhere in the Macintosh Operating System. First, only small icons
(16-by-16 pixels) are supplied; there are no large keyboard icons (32-by-32 pixels).
Second, the resource type for keyboard small color icons is different from the resource
type used elsewhere for small color icons. This is to avoid resource ID conflicts because
the keyboard color icons—like the 'KCHR' resources—may have IDs anywhere in

the range $0-$BFFF (that is, 0 to 32767 and —32768 to —16385). The keyboard color
icon types and the equivalent standard color icon types are shown in Table 14-15.

Table

14-15. Keyboard color icon types and standard icon equivalents

- Keyboard
icon type

Standard icon
equivalent

‘kes#'

'1cs#'

'kes4'
‘kes8'

‘ics4'
‘ics8'

Bit
depth
l

4
8

These keyboard icons are used in the Keyboard control panel and in the Keyboard menu
when it is displayed on some localized versions of the system software. For details on the

Keyboard menu, see “Using the Keyboard Menu” earlier in this chapter. The resource ID

for each 'kcs#', 'kcs4', or 'kcs8' resource is the same as that of the 'KCHR' resource to

which it corresponds.

The

'KSWP'

Resource

The 'KSWP' resource consists of a series of entries, each of which specifies modifier-pluskey combinations that can be used to change keyboards and scripts—for example, the
Command-Space bar combination that users press to rotate to the next keyboard script on
most script systems.
Figure 14-29 shows the format of each entry. For the meanings of the special negative codes,
see Table 14-3, “Verbs for the KeyScript Procedure,” earlier in this chapter.
14-98

Using the International and Keyboard Resources

Worldwide Software Overview

Script code or special
negative code

(byte)

(integer)

Figure 14-29.

Virtual
key code

Modifier
state

(byte)

Format of entries in the 'KSWP' resource

If you do not have access to the MPW file SysTypes.r, which contains the Rez type
definition of the 'KSWP' resource, consult Macintosh Developer Technical Support
for details.

The

‘itlk'

Resource

The ‘itlk' resource is used to make the various international keyboard layouts work on all
of the keyboard models. It specifies how to remap certain key combinations before the
KeyTrans function is called.
Note: Starting with system software version 7.0, the Script Manager only loads the
‘itlk' resource from the System file.
Figure 14-30 shows the 'itlk' resource. It consists of an integer count of entries succeeded by
a set of 8-byte entries.
Current keyboard

type

(integer)

Current
modifiers

(byte)

Current
key code

(byte)

Character
modifiers

(byte)

Character
code

(byte)

New
modifiers

(byte)

New
key code

(byte)

—

+

Figure

14-30.

_

=<

The 'itlk' resource entries

S

a!

—

Before KeyTrans begins processing with the 'KCHR' resource, the current keyboard type,
key code, and modifiers are compared against each entry. If there is a match, it substitutes the
new modifiers and key code before calling KeyTrans. Each pair of character modifiers and
character codes is defined to produce a number of new modifiers and new key codes. Here is
how the ‘itlk' resource can produce multiple modifiers:
1. An AND operation is performed on the new modifiers and key code with the character
modifiers and character code from the entry.
2. An AND operation is performed on the current modifiers and key code with the
complement of the character modifiers and character code from the entry.
3. The logical OR of these two products is the final result. This allows for a more compact
table when several characters on one key are mapped together to a different key.
If you do not have access to the MPW file SysTypes.r, which contains the Rez type definition
for the 'itlk' resource, consult Macintosh Developer Technical Support for details.

Using the International and Keyboard Resources

14-99

jou

=

wee

Q.
@

2)
S
=
=<
~

os)

pn |
La*)

Inside Macintosh,

KEY

CAPS

Volume

AND

VI

THE

'KCAP'

RESOURCE

This section discusses some enhancements to the Key Caps desk accessory and describes its
related resource, 'KCAP", which specifies the physical layout of keyboards. With system
software version 7.0, Key Caps supplies additional feedback on using dead keys to produce
accented characters. The 'KCAP' resource is used by the Key Caps desk accessory.
Note: The Keyboard Layout file formerly associated with Key Caps no longer
exists. The 'KCAP’ resources that were formerly located in this file now reside
in the System file.

Dead-Key

Feedback

The Key Caps desk accessory provides feedback on using dead keys to produce accented
characters. It indicates dead keys with dotted borders, as shown in the Key Caps window in
Figure 14-31, which shows the U.S. keyboard layout with the Option key pressed.

|

Option

Figure 14-31.

[«|«]

= Dead keys

Key Caps display of dead keys with Option key pressed

If a dead key is entered, such as the circumflex dead-key combination (Option-I), the display
changes to highlight the completer keys for this dead key that users can press to generate
valid accented character combinations, as shown in the Key Caps window in Figure 14-32.
If your application displays keyboards, you should use a similar method of indicating dead
keys and completers.

14-100

Key Caps and the 'KCAP' Resource

Worldwide Software Overview

Figure 14-32.

The

'KCAP'

Key Caps display of completer keys after circumflex
dead key has been pressed

Resource

The 'KCAP' resource specifies the physical layout of keyboards and is used by the Key Caps
desk accessory. Prior to system software version 7.0, 'KCAP' was located in the Key Layout
file. With version 7.0, it is located in the System file.
See Table 14-11 earlier in this chapter for a list of the current 'KCAP' identification numbers
(which are also their resource IDs) and the keyboards they represent.
Listing 14-6 shows the Rez format for the 'KCAP' resource.
Listing 14-6.

Physical layout of keyboards
—

type

'KCAP'

+

{

rect;

/*boundsRect* /

rect;
integer

=

$$CountOf

array MainArray
{
integer
= $S$CountOf(ShapeArray)
wide

array

S
a

/*textRect*/
(MainArray) ;

ShapeArray

a

-

=
9
@

1;

2)

=)

{

point;

=

=
£5
©

/*shapePoint*/

sew 4

integer
wide

=

array

$$CountOf(KeyArray)
KeyArray

-

1;

{

byte;
boolean
or,
and;
bitstring[7];

/*mask*/

integer;

{*dw*/

integer;

/*ah*/

/*keyCode* /

Key Caps and the 'KCAP' Resource

14-101

Inside Macintosh, Volume VI

LOCALIZING

TO

OTHER

LANGUAGES

AND

REGIONS

You can use existing resources or create new ones to localize your applications to other
languages or regions. The sections that follow contain guidelines and tips for localizing
your applications successfully. See Guide to Software Localization for details on the
localization process.

Using

Resources

Be certain that you place the following information in an appropriate resource:
m all user-visible text
m lengths of string and text
m dialog box formats
m= menus and command keys
character, word, phrase, and text translation tables
m

font family numbers, names, sizes, styles, and widths of numeric fields

m special characters and delimiters
Note: Other information may vary from locale to locale such as address formats,
including zip codes and telephone numbers.

Text and

Dialog Translation Tips

Follow these guidelines for translating visible text in your applications to other languages:
m Do not place in the program code any text that the user will see.
= Do not assume that all languages or regions have the same rules or conventions for
punctuation, word order, and alphabetizing.
a Be aware that grammar problems may arise from error messages, natural programming
language structures, and so forth.
w Text needs room to grow—up, down, and sideways! (This is especially true for

numbers.) For example, translated text data can be 50 percent larger than the U.S.

English text data; therefore, do not rely on strings having a particular length.
w Text location within a window should be easy to change.

14-102

Localizing to Other Languages and Regions

Worldwide Software Overview

Note that the arrangement of dialog-box items may vary with localization. The lowmemory global variable TESysJust indicates the system line direction. On Arabic and
Hebrew systems, the line direction usually defaults to right to left, so text in dialog
boxes should generally be right to left. When creating a column of check boxes or
radio buttons, make sure the text boxes are the same sizes. Then when the line
direction is reversed, the check boxes or radio buttons align correctly.
Note: Natural programming language structures refer to programming languages
that attempt to use human-like command structures. For example, it is unreasonable
to write a command in one language and expect it to survive the process of translation
without making accommodations for word order at the very least. An English command like “Put It Into Field 7” could translate into Japanese word order as “It (as-for)
Field 7 Into Put.”

Adapting

Text

Operations

Follow these recommendations for adapting text operations to other languages and regions:
Use the Script Manager routines for displaying and measuring text and testing for
mouse-down events in text, or use TextEdit, which now uses the Script Manager
for these operations.
Use language-specific string comparison and sorting. For example, be sure that names
are sorted using the correct sorting order for the system on which your application is
running. To do this, use [UCompString or a similar function.
Use language-specific word-break and word-wrap routines. Consider word boundaries
and their impact on word wrap, selection, search, and cut and paste. Use the FindWord
or NFindWord procedure to specify word breaks.
Use language-specific character type information. Consider character boundaries and
their impact on search, replace, sort, word wrap, backspace, delete, and cut and paste.
Use the CharType function and its associated constants to obtain more information
about character type. See “Summary of the Script Manager” near the end of this chapter
for details on the CharType constants.
Use language-specific case conversion. Use the UpperText and LowerText procedures
for localizable uppercase and lowercase conversion of characters.
Keep in mind that the length of text may vary from language to language.
Avoid assumptions about the number of letters in the alphabet. For example, if your
program relies on properties of the ASCII code table or uses data compression codes,
remember that not all alphabets have the same number of characters.
Don’t break text into arbitrary blocks for drawing, measuring, and so forth. As
a minimum, always group text on the same line into style runs for drawing and
measuring.

Localizing to Other Languages and Regions

14-103

—

>
<

=<
S
“

2.
—

“

<=

2.

—e

om

DN
=)
=
<
ey
“

sa°)

Inside Macintosh,

Using

Volume VI

Fonts

Here are some hints for planning for font-related issues in your applications:
a Diacritical marks, used in many languages, extend up to the ascent line.
a Some system fonts contain characters that extend to both the ascent and descent lines.

Avoiding

Special

Character

Codes

as Delimiters

Your application may need to use a character code or range of codes to represent noncharacter
data (such as field delimiters). Character codes below $20 are never affected by the script
system. Some of these can be used safely for special purposes. Note, however, that most
characters in this range are already assigned special meanings by parts of the Macintosh
Toolbox, such as TextEdit, or certain programming languages like C.
The low ASCII characters (with hexadecimal representations) that you should avoid as
delimiters are as follows:
Character
or key

Code

Character
or key

Code

Null

$00

Page Up

$0B

End
Help

$04
$05

Fl through F15
System characters

$10
$11, $12, $13, $14

Home
Enter
Backspace

Tab
Line feed
Using

the

$01
$03

Page Down
Carriage return

$08

Clear

$09
$0A
Standard

$0C
$0D
$1B

Arrow keys

Roman

Character

$1C, $1D, $1E, $1F

Set

Be aware that the “traditional” Macintosh character set (that is, the original set described in
Volume I as the Macintosh character set) stops at code $D8 and contains a limited set of
European accented forms. The standard Roman character set now includes the remaining

character codes ($D9-$FF); it supplies uppercase versions of all of the lowercase accented

forms in the traditional set, new symbols, and other forms. These characters are available in

most LaserWriter® and TrueType™ fonts, but not in the Apple bitmap versions of Chicago,

Geneva, or Monaco. See the Font Manager chapter in this volume for an illustration of the
standard Roman character set. See Macintosh Worldwide Development: Guide to System
Software for further information on the standard Roman character set (there referred to as the
extended Roman character set).

Since system software version 6.0.4, there has been full support for the standard Roman
character set. This version has supplied more completeness and consistency in the handling
of accented forms in the fonts that contain these forms.

14-104

Localizing to Other Languages and Regions

Worldwide Software Overview

Also with system software version 6.0.4, the U.S. keyboard resource 'KCHR' (0) has been
modified to make it possible to enter the accented forms with dead keys. Users can enter all
the accented forms in the original Macintosh character set with dead keys.
Note: With system software version 7.0, the keyboard entry of the following four
characters is now possible using the U.S. 'KCHR' resources: cedilla (, ), doubleacute accent (~), ogonek (, ), and hacek (~ ). These characters are represented by

codes $FC-—FF.

The tables used by the Script Manager’s CharType, Transliterate, and FindWord routines (in
'1t12'), by the IntlTokenize function (in ‘itl4'), and by the International Utilities Package (in
Pack6) have been modified in the U.S. system for proper treatment of the character-set
extensions as well as the traditional characters 8, g, and @.

Adapting

Keyboard

Equivalents

Applications that make extensive use of keyboard equivalents face numerous challenges on
the worldwide market. When multiple script systems are installed on a system, the challenges
increase. When the Command key is pressed, some characters, such as the period (.), cannot
be produced on certain keyboard layouts. This is mainly a problem if symbols are used as
keyboard equivalents. To make Command-key handling work in these cases, it may be
necessary to determine which character would have been produced if the Command key were
not pressed. The code in Listing 14-7 illustrates one approach.
Listing 14-7. Making keyboard equivalents work with multiple scripts
CONST
menuldMask

=

SFFFF0000;

{mask

for

menu

ID

in

MenuKey

result}
oeane

newModifierMask

=

S$SFCOO;

{high byte of
{ cmdKey bit}

modifiers,

without

AsciilMask

=

SOOFF0000;

{ASCII

1

in

Key

Trans

result}

Ascii2Mask

=

SOOQOQOOOFF;

{ASCII

2

in

Key

Trans

result}

Bat

}

a

=

i)

ar}

=
<a

=

hate

Q

VAR
myEvent:

EventRecord;

myChar:

Char;

menuResult:

Longint;

myNewModifiers:

Integer;

myVirtualCode:
myKeyCode:
myKCHRPtr:
myDeadState:

Integer;
Integer;
PEr;
Longint;

myNewChars:

LongInt;

myNewChar:

Char;

as)

TN
i—)

ao]
a
=
o

=

@

(Continued)

Localizing to Other Languages and Regions

14-105

Inside Macintosh,

Volume VI

Listing 14-7. Making keyboard equivalents work with multiple scripts (Continued)
BEGIN

event. }
is a key-down or auto-key
that here
{Assume
);
charCodeMask)
:= CHAR(BAnd(myEvent.message,
myChar
IF BAnd(myEvent.modifiers,
cmdKey)
<> 0 THEN
{Command key is
IF myEvent.what

down. }
= keyDown

THEN

MenuKey

(myChar)

BEGIN

menuResult

IF

:=

BAnd(menuResult,

;

menuIdMask)

=

0

THEN

is

a

BEGIN

{Didn't

match,

{

the

{

Command

so

character

{First,

if

that

were

make

see

not

there

would

have

match

been

with

}

produced

if

}

down.}

keyCode

parameter

for

KeyTrans,

{ but turn off
myNewModifiers

the Command key bit.}
:= BAnd(myEvent.modifiers,

myVirtualCode

:=

}

newModifierMask) ;

BSR(BAnd(myEvent.message,

keyCodeMask),

myKeyCode
:= BOr(myNewModifiers,
myVirtualCode) ;
{Now, get current
'KCHR' pointer.
This requires version
myKCHRPtr
:= Ptr(GetEnvirons (smKCHRCache) ) ;
{Now set dead state to 0 and call KeyTrans. }
myDeadState
myNewChars
{If

there

:= 0;
:= KeyTrans(myKCHRPtr,
is

a

nonzero

result

myKeyCode,

in

the

high

{ else if there is a nonzero result in
{ try 26.)
myNewChar
:= CHAR(BSR(BAnd(myNewChars,
IF
IF

myNewChar

=

CHAR(0)

:=

CHAR(BAnd(myNewChars,

myNewChar

<>

CHAR(0)

menuResult
that

the

:=

myDeadState) ;

word,

try

it;

low

word,

}

AsciilMask),

}

16));

Ascii2Mask)
);

THEN

MenuKey

menu

7.0.}

THEN

myNewChar

{Note

the

8);

(myNewChar)

ID

field

based

on

of

;

menuResult

may

still

be

0.}

END;

{Now

do

menu

handling

menuResult.}

END
ELSE

BEGIN

{Not

a

Command

key;

do

other

handling. }

END;
END;

Many applications extend the set of standard Macintosh interface modifier-plus-key combinations for specific purposes. Be sure to supply alternative methods of gaining access to

functions. Avoid keyboard equivalents that use the Space bar in combination with the

Command key and other modifier keys. The Script Manager and various script systems
reserve and may use these combinations.

14-106

Localizing to Other Languages and Regions

Worldwide Software Overview

Note: The Script Manager removes from the event queue any Command key
combinations involving the Space bar if that Command key combination indicates a
useful function on the current system. For example, if multiple script systems are
installed, the Script Manager strips the Command-—Space bar combination (which
indicates changing scripts) from the event queue. If multiple script systems are not
installed, this event is not removed, so users can use it in Command key macros.

Applications, however, should never depend on Command key combinations
involving the Space bar.

Modifying

the Representation

of Dates, Times,

and

Numbers

Be sure to allow for variations in the representation of dates, times, and numbers in all the
localized versions of your application.
m Dates, times, and numbers should be displayed in local format as specified by the
system script’s '1tlO' and ‘itll’ resources.
a

Parsing of dates, times, and numbers should work for local formats (the Script Manager

provides routines to do this). See “Date and Time Utilities” and “Number Utilities”
earlier in this chapter for details.

w Units of measure should be localized. For example, lines per inch is meaningless in the
metric world. The International Utilities Package provides routines for determining the
appropriate units of measurement.

WRITING

SOFTWARE

FOR

OTHER

SCRIPTS
cS
<
—

To ensure that your applications are compatible with other scripts, particularly non-Roman
scripts, follow the guidelines presented here as well as those provided in the previous section.

Working

With

<=
=Y
=
a
@

Fonts

N

S

=

a Don’t hard-code font IDs or sizes. System and application fonts have different font IDs
and sizes on various script systems. If you must, use a font size of 0; otherwise, let the
user choose. 'FOND' IDs 0 and | always map to system and application fonts for the
system script. Font size 0 always maps to the default system font size. If the user cannot
select fonts and sizes, use the default values listed above.
a Onnon-Roman systems, the Chicago font does not have ID 0.
= Don’t make assumptions about font sizes. System or application fonts may be
12 or 18 point, or other sizes.
= Don’t make assumptions about menu bar height; call GetMBarHeight to get the
correct value.

Writing Software for Other Scripts

14-107

=
yy
©

Lee

4

Inside Macintosh,

Volume VI

a Special script codes (smUninterp and smRSymbol) are defined for fonts that contain
characters that should not be treated as normal text, such as menu and palette symbols.
These script codes have their own ranges for defining 'FOND' IDs.
a The non-Roman fonts have always included Roman characters for compatibility.
However, in word processors, you’ll find that your text-processing operations
are greatly simplified if you extract the Roman characters and reassign them to a
Roman font.
The Script Manager’s FindScriptRun function allows you to extract blocks of
Roman text in a non-Roman font to deal with them properly in higher-level runs.
Word processors should call FindScriptRun to decompose text so that it fits in the
format run framework. For an example of extracting blocks of Roman text, see
Figure 14-33.
Tel Aviv 14

mM

aL

Kyoto 18

Hebrew

m4

Tel Aviv 14

mL
Figure
w

Nihongo

| ANE

Fo

Helvetica 14

Times 18

Kyoto 18

Hebrew

Nihongo

H AS ac

14-33.

Extracting blocks of Roman

text

Display font names in the proper script and proper font. In the Fonts menu in word
processors, for example, font names should appear in their own font (and script).
First, this lets users know the appearance of the font. Second, some fonts—like Arabic,
Hebrew, and Japanese fonts—have non-ASCII names that only display correctly in
their own script.

Working

With

Character

Codes

In addition to remembering that the meaning of a character code depends on the font, keep the
following principles in mind:
The character codes may be | or 2 bytes.
The caret (insertion point) should sit between characters, not bytes (that is, it should
not be inserted between bytes of a 2-byte character).

The Delete key should delete entire characters, not bytes.
Two-byte characters may affect data transmission and reception.

14-108

Writing Software
for Other Scripts

Worldwide Software Overview

mw The arrow keys should move over characters, not bytes.
mw A character code should ideally have a unique meaning in a particular script, although
this is not always the case. For example, the Symbol font is in the Roman range but
uses a different character assignment from the standard Roman character set.

Working

With Text Direction

When working with scripts that display mixed-directional text, remember the following
guidelines:
= Convert mouse-down events to text offsets correctly, regardless of text direction. See
the description of Pixel2Char in Macintosh Worldwide Development: Guide to System
Software for comprehensive details.
w Right or left alignment of dialog box text and menu items should depend on TESysJust,
a low-memory global variable set by the script system. Word processors should allow
users to set the default line direction on a paragraph-by-paragraph basis.
a The caret (insertion point) should be displayed where the next entered character will
appear. If the position occurs at a direction-run boundary, use a dual caret. The high
caret, called the primary caret, should indicate where the next character in the primary
line direction will appear, and the low caret, called the secondary caret, should
indicate where the next character in the opposing line direction will appear. See the
TextEdit chapter in this volume for more information on dual carets.
a Highlighting should apply to a contiguous set of characters in memory, which may not
be visually contiguous. See the TextEdit chapter in this volume for more information on
highlighting with mixed-directional text.
a The arrow keys should move the caret in the direction the arrow points, regardless of
the text direction, even across direction-run boundaries.

mee

de
a

ey
S

«sd
o

Synchronizing

Keyboards

and

a
<=

Fonts

=
@

=
DN

Three rules govern the synchronization of keyboards and fonts in non-Roman scripts:

=
—s
a
<=

+N)

a Clicking in text should set the keyboard script to the script of the text.

ber |

@

a Typing acharacter from the current keyboard should select an appropriate font.
a Selecting a font should set the keyboard to the script of the font.

Handling

Numbers

Some scripts include multiple sets of digits. Applications that handle numbers should accept
these as valid digits (the Script Manager number utilities routines help you do this). For
details, see “Number Utilities” earlier in this chapter for brief descriptions, and see Macintosh
Worldwide Development: Guide to System Software for details on the routines.

Writing Software for Other Scripts

14-109

Inside Macintosh,

Volume VI

Identifying

Keywords

and Tokens

Keyword and token identification should work correctly in all scripts. For details, see
Macintosh Worldwide Development: Guide to System Software.

Possible

Printing

Problems

If you use the wrong LaserWriter driver for a script system, characters map incorrectly
because the drivers are localized and have different encodings. For instance, a Turkish
system with a U.S. LaserWriter driver might print unexpected forms instead of the
substituted characters in the Turkish font.
State information you need may not be saved in picture comments—for example, modified
width tables are not saved. With system software version 7.0, parameters for justified text
are now saved.
Scripts such as Japanese or Arabic modify the normal QuickDraw text handling in order to
represent text properly. On the screen, this is done by trapping StdText and StdTxtMeasure
and by transforming the text before printing. Hebrew or Arabic text might be reversed
because text normally goes from right to left in those scripts.
Printer drivers require slightly different handling, for two reasons:
m A printer driver might not call the standard QuickDraw procedures. For example, the
LaserWriter writes directly in PostScript®.
a A printer driver might need to format the text for accurate line layout. In this case, the
text needs to be transformed before the driver performs line layout. If the driver is
spooling the text and will replay the text a second time, the text cannot be transformed
a second time because that would ruin the appearance.
For example, the ImageWriter® driver calls QuickDraw procedures twice, once to spool and
once to unwind the spool. The text must be transformed when spooling so that line layout
can be done, but during unwinding, the transformation must be turned off completely.
Note that some drivers, such as the LaserWriter, use QuickDraw reentrantly. The application
program calls a QuickDraw routine, which is directed to the driver’s grafProcs, which in turn
call QuickDraw internally to put up status messages on the screen. (The PrintAction procedure allows the script system to install the proper QuickDraw hooks, which then handle
printing properly.)
The Script Manager PrintAction procedure allows the printer driver to be independent of the
particular scripts being used. The printer driver should call this routine whenever it changes
the grafProcs in the printing grafPort. The PrintAction routine then substitutes grafProcs of
its own in the grafProcs record and saves the original routine addresses.
The PrintAction procedure actually calls a PrintAction routine for each script system that is
currently enabled. Each PrintAction procedure does the tasks appropriate for its script
system. For more information, see “Working With Print Drivers” in Macintosh Worldwide
Development: Guide to System Software.

14-110

Writing Software for Other Scripts

Worldwide Software Overview

SUMMARY

OF

THE

SCRIPT

MANAGER

Constants
{script

codes}

smSystemScript

=

-1;

{system

script}

smCurrentScript

=

=2s

{current

font

smRoman

=:

Us

smJapanese

=

1s

smTradChinese

=

By

smKorean

=

Si

smArabic

=

a;

smHebrew

=:

Sy

smGreek

=.

63

smCyrillic

=

7;

smRSymbol

=

8;

smDevanagari

=

93

smGurmukhi
smGujarati
smOriya

=
=
=

aoe
21%
tas

smBengali

=:

13%

smTamil

=

14;

smTelugu
smKannada

=
=

oe
16;

smMalayalam

=

17:

smSinhalese

=

18;

smBurmese

=

13;

=

smKhmer

=

20%

a

smLaotian
smGeorgian
smArmenian

=
=
=

22;
235
24;

4

smTibetan
smMongolian

smThai

script}

{Traditional

Chinese}

{right-left

symbols}

{Kannada/Kanarese}

= 2i3

smSimpChinese

=

= 25;
a
=

26%
27%

{Simplified

smGeez

=

283

{Geez/Ethiopic}

{synonym

for

smEastEurRoman

=>

Zo

{extended

Roman

smVietnamese

=

30;

{extended

smExtArabic

=

31%

{extended Arabic
{ and so forth}

smUninterp

=

323

{uninterpreted

smEthiopic

= 28;

{

{obsolete

smChinese
smRussian
smMaldivian

script

system

=

names

2;

nou
N ~]
ul

CONST

and

S
="

Chinese}

Baltic

o

S.
=
5

smGeez}
for

Slavic

}

languages}

Roman

for

Vietnamese}

for

Sindhi

}

symbols}

(kept

for

{use

smTradChinese

backward

compatibility) }

or

}

{ smSimpChinese}
{old name
for smCyrililic}

{with
{

version

7.0,

no

more

}

smMaldivian}

Summary of the Script Manager

14-111

z

Inside Macintosh,

Volume VI

smAmharic

=

28;

{old
{

smSlavic
smSindhi
{language

=
=
codes

29;
31

{old
{old

to

Language.p) }

(moved

for

smGeez,

kept

for

}

name
name

for
for

smEastEurRoman}
smExtArabic}

langEnglish

=

Oy

{smRoman

script}

langFrench

=

1;

{smRoman

script}

langGerman

Ss:

2

{smRoman

script}

langItalian

=

By

{smRoman

script}

langDutch
langSwedish
langSpanish
langDanish
langPortuguese
langNorwegian

= A;
= Sy
=: 65
= 7;
8;
a

{smRoman
{smRoman
{smRoman
{smRoman
{smRoman
{smRoman

script}
script}
script}
script}
script}
script}

langHebrew

=

{smHebrew

langJapanese
langArabic
langFinnish
langGreek

14%
= 12%
= 13%
= 14;

{smJapanese script}
{smArabic script}
{smRoman script}
{smGreek script}

langIcelandic

=

LS:

{smRoman

langMaltese
langTurkish
langCroatian
langTradChinese
langUrdu
langHindi
langThai

=
=
=
=
=
=
=

L.6%
173
18%
19;
20;
21%
ay

{smRoman script}
{Turkish in smRoman script}
{Serbo-Croatian in smRoman script}
{Chinese in traditional characters}
{smArabic script}
{smDevanagari script}
{smThai script}

langKorean

=

23>;

{smKorean

langLithuanian
langPolish
langHungarian
langEstonian
langLettish

=
=
=
=
=

24;
25%
26;
273
28;

{smEastEurRoman
{smEastEurRoman
{smEastEurRoman
{smEastEurRoman
{smEastEurRoman

langLatvian

=

28;

{synonym

for

langLettish}

langLapponian

=

29;

{synonym

for

langLapppish}

langLappish
langFaeroese

=
=:

29%
30%

{synonym
{smRoman

for langLapponian}
script}

langFarsi

=

34%

{smArabic

script}

langPersian

=

314

{synonym

for

langRussian

=

32;

{smCyrillic

script}

langSimpChinese

=

33;

{Chinese

{smRoman

script}

simplified

langFlemish

14-112

name

compatibility}

=

10%

34a;

script}

script}

script}

in

script}
script}
script}
script}
script}

langFarsi}

langIrish

=

357

{smRoman

script}

langAlbanian

=

36

{smRoman

script}

langRomanian

=

S7e

{smEastEurRoman

script}

langCzech
langSlovak

=
=

38;
39

{smEastEurRoman
{smEastEurRoman

script}
script}

langSlovenian
langYiddish
langSerbian

=
=
=!

40;
41;
425

{smEastEurRoman script}
{smHebrew script}
{smCyrillic script}

langMacedonian

=

43;

{smCyrillic

Summary of the Script Manager

script}

characters}

Worldwide Software Overview

langBulgarian

44;
45;

langUkrainian

langByelorussian

=

46;

{smCyrillic

script}

{smCyrillic script}
{smCyrillic script}
{smCyrillic script}
{smCyrillic script}
{Azerbaijani in smCyrillic
{ script
(USSR)}

langUzbek

47;

langKazakh

langAzerbaijani

48;
49;

langAzerbaijanAr

50;

{Azerbaijani
{ (Iran) }

Sis

script}
script}
script}
script}
script}
script}

in

smArabic

langGeorgian
langMoldavian
langKirghiz
langTajiki

52);

55;

{smArmenian
{smGeorgian
{smCyrillic
{smCyrillic
{smCyrillic

langTurkmen

56;

{smCyrillic

i

67;

{smMongolian script}
{smCyrillic script}
{smArabic script}
{smArabic script}
{smArabic script}
{smExtArabic script}
{smTibetan script}
{smDevanagari script}
{smDevanagari script}
{smDevanagari script}
{smBengali script}

68;

{smBengali

69;

langArmenian

langMongolian
langMongolianCyr
langPashto
langKurdish
langKashmiri

langSindhi
langTibetan
langNepali
langSanskrit
langMarathi
langBengali
langAssamese

535i?
54;

58;
59;
60;
61;
62;
63;
64;

65;
66;

}
script

}

script}

langGujarati
langPunjabi

70;

langOriya

wyeI

langMalayalam

Ta:

{smGujarati script}
{smGurmukhi script}
{smOriya script}
{smMalayalam script}

langKannada

73}

{smKannada

langTamil

74;

langTelugu

75;

a
a
~
So
=:
—
lal
<
<
ve
~
ia")

langBurmese
langKhmer

i

{smTamil script}
{smTelugu script}
{smSinhalese script}
{smBurmese script}

78;

{smKhmer

langLao

T+

langVietnamese
langIndonesian

{smLaotian

80;

{smVietnamese

81;

{smRoman

script}

langTagalog
langMalayRoman

82;
83;

{smRoman

script}

langMalayArabic

84;
85;

langSinhalese

langAmharic
langTigrinya

76

—

script}

ws

—

script}

2
<2

script}

a

=r

[ mal

script}

<
=
as
pe)
Led

@

{smRoman script}
{smArabic script}
{smEthiopic script}

86;
87;
87;

{smEthiopic

script}

langGalla
langOromo

{smEthiopic

script}

{synonym

for

langSomali
langSwahili

88;
89;

{smRoman
{smRoman

script}
script}

langRuanda

90;
91;
92;

{smRoman
{smRoman

script}

langRundi
langChewa
langMalagasy

933

langEsperanto

94;

script}
{smRoman
{modified Roman
script}

{smRoman

langGalla}

script}
script}

Summary of the Script Manager

14-113

:

Inside Macintosh,

Volume VI

langWelsh
langBasque

=
=

128°
129;

{smRoman
{smRoman

script}
script}

langCatalan

=

130%

{smRoman

script}

langLatin

=

134%

{smRoman

script}

langQuechua

=

132:

{smRoman

script}

langGuarani

=

133);

{smRoman

script}

langAymara

=

134;

{smRoman

script}

langTatar
langUighur
langDzongkha

=
=
=

135%
136;
T37;

{smCyrillic script}
{smArabic script}
{language of Bhutan,

langJavaneseRom

=

138;

{smRoman

script}

langSundaneseRom

=z

139}

{smRoman

script}

{obsolete

language

script}

names}

langPortugese

=

8;

langMalta

=

.L6s

langYugoslavian

=

28%

{old misspelled version,
kept }
{ for compatibility}
{old misspelled version,
kept }
{ for compatibility}
{use langCroatian,
langSerbian,
{

langChinese

smTibetan

=

19;

and

so

}

forth}

{use langTradChinese
{ langSimpChinese}

or

}

{calendar
(date representation codes} used in the }
{ date representation fields of the 'itlb'
resource}
{returned in the low byte when you call Get Script }
{ with smScriptNumDate verb}
calGregorian

=

0;

{Gregorian

calArabicCivil
calArabicLunar

=
=

1;
2;

{Arabic
{Arabic

calendar}

calJapanese

=

3?

{Japanese

calJewish
calCoptic
calPersian

=
=
=

4;
§5
6;

{Jewish calendar}
{Coptic calendar}
{Persian calendar}

civil
lunar

calendar}
calendar}

calendar}

{integer format
(number representation)
codes used in the
{ number representation fields of the ‘itlb' resource}
{returned in the high byte when you call Get Script
}
{ with smScriptNumDate verb}
intWestern
= O+
intArabic

=

intRoman
=
=

S¢
#4

intOutputMask

=

$8000;

smLastByte

smMiddleByte

14-114

1;

2;

intJapanese
int European

{CharByte function
smSingleByte
smFirstByte

}

byte types}
= 0;
{single byte character}
= -1;
{high (most significant)

=

=

{

the

lower

address

{

in

memory) }

Ls

{low

byte

with

2}

{ address
{reserved

(in
for

Summary of the Script Manager

the

byte

(comes
higher

with

first
}

memory) }
future extensions}

}
}

Worldwide Software Overview

{CharType

function

field

masks}

smcTypeMask

SOOOF;

smcReserved

SOOFO;

smcClassMask

SOFOO;

smcOrientationMask

$1000;

smcRightMask
smcDoubleMask
{basic CharType
smCharPunct

character

smCharEuro

smCharExtAscii
CharType

character
$0002;
$0003;
$0004;

smCharKatakana
smCharHiragana
smCharIdeographic
eGreek

$0006;

smCharBidirect

$0008;
$000C;
$000D;

smCharHangul
smCharJamo
Jamo

classes

smJamoBogJaeum

smJamoMoeum
smJamoBogMoeum
classes

{ASCII

systems

}

{old
types

for

for

character

type}

letter}

name

for

{extended
for

smCharExtAscii}

ASCII

script

letter}

systems}

{Japanese

Katakana}

{Japanese

Hiragana}

{Hanzi,
Kanji,
Hanja}
{2-byte Greek in Far }
{ Eastern script systems}
{2-byte Cyrillic in Far }
{ Eastern script systems}
{Arabic/Hebrew}
{Korean
{Korean

Korean

$0000;
$0100;
$0200;
$0300;

smJamoJaeum

{CharType

{punctuation

$0005;

smCharTwoByteRussian

{CharType

script

orientation}

types}

$0000;
$0001;
$0007;
$0007;

smCharAscii

smCharTwoByt

Eastern

glyph

$2000;
$4000;
$8000;

smcUpperMask

{additional

{Far

{

Hangul}
Jamo}

systems}
{simple

consonant

{complex

consonant

{simple

vowel

{complex

punctuation

char}
char}

char}

vowel

—

char}

»

—

~
ni
i
>
_—

(smCharPunct) }

smPunctNormal

$0000;

on)

smPunctNumber
smPunctSymbol

$0100;
$0200;

—*
rot
—

smPunctBlank

$0300;

~
ww
—
_

—
<a

>

@

ZN
“

<

{additional

CharType

classes

{ script
systems}
smPunctRepeat
smPunctGraphic
{CharType

ideographic

for

punctuation

in

$0400;

{repeat

$0500;

{line

graphics}

2-byte

script

{level

1

char}

smIdeographicLevel2

{level

2

char}

smIdeographicUser

$0200;

{user

char}

{CharType

Katakana

smKanaSmall
smKanaHardOK

smKanaSoftOK

&

classes

for

}

@

marker}

$0000;
$0100;

smideographicLevell

2-byte

aa
=
a>

systems}

Hiragana

classes
for 2-byte
script
systems}
{small
kana character}
{can have dakuten}
{can have dakuten or }
$0300;
{ han-dakuten}
$0100;
$0200;

Summary of the Script Manager

14-115

Inside Macintosh, Volume VI

{Transliterate
smTransAscii
smTransNative

function

=
a

target
0:

types

for Roman script}
{convert to ASCII}
{convert to native script
{ (that is, the script of
{

the

font) }

smTransCase

SFE;

{convert

case

for

smTransSystem

SFF;

{convert

to

system

{Transliterate

{
target

types

for

not

2-byte

available

script

all

text}

script;

in

MPW

systems}

=

23

{l-byte

smTransAscii2

=

3}

{2-byte

Roman}

smTransKanal

=

4;

{i-byte

Japanese

Katakana}

smTransKana2

=

5;

{2-byte

Japanese

Katakana}

smTransGana2

a

“Vy

{2-byte

Japanese

Hiragana

(no

Roman}

1-byte

=

BF

{2-byte

Korean

smTransJamo2
smTransBopomofo2

=
=

9;
10;

{2-byte
{2-byte

Korean Jamo}
Chinese Bopomofo}

target

modifiers

(not

available

}

Hiragana) }

smTransHangul2

{Transliterate

in

Hangul}

MPW

3.0)}

smTransLower

=

$4000;

{target

becomes

lowercase}

smTransUpper

=

$8000;

{target

becomes

uppercase}

{Transliterate

source

smMaskAll
{Transliterate

mask

=
source

general}

S$FFFFFFFF;

masks

smMaskAscii
smMaskNative
{Transliterate

-

for

{convert

Roman

Script

all

text}

System}

$00000001;
$00000002;
source

masks

for

2-byte

script

systems}

smMaskAsciil

=

$00000004;

{2“smTransAsciil}

smMaskAscii2

=

$00000008;

{2*smTransAscii2}

smMaskKanal

=

$00000010;

{2°smTransKanal }

smMaskKana2
smMaskGana2

=
=

$00000020;
$00000080;

{2*smTransKana2 }
{2*smTransGana2}

smMaskHangul2

=

$00000100;

{2“smTransHangul2}

smMaskJamo2

=

$00000200;

{2“smTransJamo2 }

smMaskBopomofo2

=

$00000400;

{2“smTransBopomofo2 }

{results returned by GetEnvirons,
{ SetScript functions}

SetEnvirons,

GetScript,

&

}

smNotInstalled
smBadVerb

=
=

-1;

{routine
{invalid

not available
in
verb passed
to a

smBadScript

=

-2;

{invalid

script

{

{byte
{ how

}

3.0}

smTransAsciil

{

values for script redraw
much of a line should be

code

smRedrawChar

=:

'O3

{redraw

character

smRedrawWord

=

1;

{redraw

entire

Summary of the Script Manager

passed

script}
routine}

to

a

}

routine}

flag
(smScriptRedraw)
that
redrawn when text is being

{

14-116

current

}
}

(2-byte

describes
entered}

only}

word

systems) }

}

}

Worldwide Software Overview

smRedrawLine

=

=<

{redraw

{
{bits
in the script
7 are
{ (bits above

entire

line

(bidirectional

flags word
(smScriptFlags)
nonstatic) }

}

smsfIntellcP

=

03

{script

has

intelligent

cut

smsfSingByte

=:

24

{script

has

only

bytes}

smsfNatCase

a

Bs

{mative

characters

smsfContext

=

3%

{contextual

smsfNoForceFont

=

4;

smsfBODigits

=

5

{has

smsfAutoInit

=

6%

{initialize

single

paste}

uppercase

and

for

example,

based

System}
characters}

alternate

digits

script

at

on

}

BO-B9}

smsfForms

=

13%

{uses

contextual

forms

=

14;

{uses

contextual

ligatures}

smsfReverse

=:

5s

{reverses

native

lowercase}

automatically}

smsfLigatures

{TokenType

and

have

script,

{ Arabic Script
{will not force

}

systems)}

text

for

letters}

right

to

left}

values}

tokenIntl

=:

@;

{designates

which

{

resource

{

tokenizer}

international

could

be

used

as

an

tokenEmpty

=

Ls

{used

internally

tokenUnknown

=:

Bis

{used

for

characters

{

correspond

{

token

to

any

empty

that
of

13
Be

tokenRightLit

=

33

tokenAlpha

=:

As

flag}
not

}
}

{white space}
{literal begin
("left }
{ literal marker") }
{literal end ("right }
{alphabetic}

tokenNewLine

=

67

{new

line}

tokenLeftComment

=

7%

{open

comment

tokenRightComment

tokenLiteral

=

8

= 9;

{close

tokenEscape

=

LD

{character

tokenAltNum

=

11;

{alternate number }
{ (for example,
$BO-B9) }

tokenRealNum
tokenAltReal
tokenReservel

=
=:
=:

123
13+
14;

{real
number}
{alternate
real
{reserved]1 }

tokenReserve2
tokenLeftParen

=:
=

15%
16;

tokenRightParen

=

Ly

{reserved2 }
{open parenthesis
}
{ ("left parenthesis") }
{close parenthesis
}

tokenLeftBracket

=

18;

{open
square bracket
{ ("left
bracket") }

tokenRightBracket

=

19%

{close
square bracket
{ ("right
bracket") }

{

5;

}

types}

=
=

=

do

}

the

existing

tokenWhite
tokenLeftLit

tokenNumeric

for

literal

marker") }
x

{numeric}

=

ast

comment

{literal}

{ in “\a",

{

("right

("left

comment") }

("right

escape

*\t")}

=

comment") }

(for

example,

=

a.
'\'

2

=
PS
a

number}

parenthesis") }
}
}

Summary of the Script Manager

}

14-117

Inside Macintosh,

Volume VI

tokenLeftCurly

20

{open
{

tokenRightCurly

bracket

curly

}

bracket") }

21%

{close

tokenLeftEnclose

22:

{ ("right curly
{open guillemet

double

quote") }

tokenRightEnclose

233

{close guillemet
{ European
double

("right
}
quote") }

tokenPlus
tokenMinus

24;
253

{plus}

tokenAsterisk
tokenDivide
tokenPlusMinus

26;

{

27%

curly

European

tokenSlash
tokenBackSlash

30;

{backslash}

tokenLess

cli

{less

tokenGreat

aa

{greater

tokenEqual

33%
34;

{equal }

353

tokenGreatEquall

36;

than}

{less
{less

than}

than
than

(single

{greater
{

(2

or
or

equal
equal

to
to

(2
}

symbols) }

or

equal

to

}

or

equal

to

}

symbol) }
than

symbols) }

A

{greater

token2Equal

38;

{ (single
symbol) }
{double equal}

tokenColonEqual

39;

{colon

tokenNotEqual

40;
41;

{not

tokenLessGreat

than

equal}

equal}

{less/greater

{

in

(not

equal

}

(not

equal

Pascal) }

tokenExclamEqual

42;

{exclamation

equal

tokenExclam

43;

{exclamation

point}

tokenTilde

44;

{centered

{

real

45;
46;

{comma }
{period}

tokenLeft2Quote

47;

{open

tokenRight2Quote

48;

{

tokenRight1Quote
token2Quote
tokenlQuote

tokenSemicolon
tokenPercent

tokenCaret
tokenUnderline
tokenAmpersand

49;

51's
52
53%
54;

553
56;
57;

("left

}

quote") }

{single quote}
{semicolon}
{percent }
{caret}

{underline}
{ampersand}
{at sign}

53
59;

{vertical

bar}

tokenQuestion

60;

{question

mark}

}

quote")}

quote

{ ("right
single
{double quote}

}

quote") }

quote

tokenAtSign
tokenBar

Summary of the Script Manager

opposed

quote

single

single

(as

$F7)}

quote

double

single

("left

{close

at

double
double

("right

{open
{

50;

double

{close
{

tilde

tilde

tokenComma
tokenPeriod

tokenLeft1lQuote

}

bracket") }
("left }

{slash}

{
tokenGreatEqual2

bracket

{minus}
{times/multiply}
{divide}
{plus/minus}

20%
29:4

tokenLessEqual2
tokenLessEquall

14-118

curly

("left

}

quote") }

in
to

}

C)}

Worldwide Software Overview

tokenPi

=

61;

{pi}

tokenRoot

=

62;

{square

tokenSigma
tokenIntegral
tokenMicro

=
=
=

625
64;
6535

{capital sigma}
{integral}
{micro}

tokenCapPi

=

66;

{capital

tokenInfinity
tokenColon

=
=

67%
68;

{infinity}
{colon}

tokenHash
tokenDollar

=
=

69%
703

{pound sign
(U.S.)}
{dollar
sign}

tokenNoBreakSpace

=~

Tihs

{nonbreaking

tokenFraction

Sn

LOG

{fraction}

tokenIntlCurrency

=

FS

{intl

74;

{open single guillemet
}
{ ("left single guillemet") }
{close single guillemet
}

tokenLeftSingGuillemet

75;

root}

pi}

currency}

tokenRightSingGuillemet

=

tokenPerThousand

=76%

tokenEllipsis

=

Pls

{ellipsis}

tokenCenterDot

=

iss

{center

tokenNil
delimPad

=
=

i272
=-2;

irl}
{delimiter

{

{the

number

parts

record

("right

{per

space}

single

guillemet") }

thousands}
dot}

pad}

indexes}

tokLeftQuote

=

1;

tokRightQuote

=

2;

tokLeadPlacer

=

23:3

tokLeader

=

a8

tokNonLeader

=:

5s

tokZeroLead

=

6%

tokPercent

=

Ty

-

tokPlusSign

=:

BF

_

tokMinusSign

=

Se

tokSeparator

=

12;

=

tokEscape

=

13;

Ss

tokEMinus

= 16;

=

tokThousands
{11 is a reserved

field}

tokDecPoint
tokEPlus

curNumberPartsVersion
fVNumber

=.

343

=

i¢

=
for

GetEnvirons

smGenFlags
smOverride
smCharPortion
smDoubleByte

=

10;

S
.

= 14;
= 15;

tokMaxSymbols

{verbs

=

and
=
=
=

Qs

S
=

{current

version

{

record}

parts

{first

version

of

of

number

number

}
format

string}

SetEnvirons}
30%
323
34;

{general
flags}
{script
override
flags}
{intercharacter
space versus
{ space proportion}

36;

{indicates
{

script

if

a

system

double-byte
is

white

}

}

installed}

Summary of the Script Manager

14-119

Inside Macintosh, Volume VI

smKCHRCache

=

38;

{pointer
{

smRegionCode

=

40;

the

{integer

cache

containing

region

the

}

code}

{verbs for GetScript
{ script systems are

and SetScript
(note that verbs private
negative,
while those general across }

{

non-negative) }

script

systems

are

smScriptEncoding

=

26;

smScriptLang

=

2B

smScriptNumDate

=

30;

smScriptKeys

=

32;

smScripticon

=

34;

smScriptPrint
smScriptTrap
smScriptCreator
smScriptFile
smScriptName
smScriptMonoFondSize

=
=
=
=
=
=

36;
38;
40;
42;
44;
FS;

smScriptPrefFondSize

=

80;

smScriptSmallFondSize

=

82;

smScriptSysFondSize

=

64:

smScriptAppFondSize

=

86;

smScriptHelpFondSize

=

88:

smScriptValidStyles

=

90;

smScriptAliasStyle

=

92;

{verbs
{any

for
script

}

'KCHR'}

containing

current

{

to

}

{optional script
'it15'
ID }
{ from 'itlb' resource}
{current language for script }
{ from ‘itlb' resource}
{number and date format bytes }
{ from 'itlb' resource}
{script default
'KCHR' ID }
{ from 'itlb' resource}
{script default
'kcs#',
‘kces4', & }
ID from 'itlb' resource}
{ 'kes8'
{script printer action routine}
{trap entry pointer}
{script file creator}
{script filename}
{script name}
{default
'FOND'
(high word)
}
{ & size for monospaced text }
{ (low word) }
{user's preferred
'FOND'
(high word)
{ & size (low word) }
{default
'FOND'
(high word)
& size }
{ for small text
(low word) }
{default

system

'FOND'

(high

word)

KeyScript}
code

=

0..64;

switch

to

specified

smKeyNextScript
smKeySysScript

=
=

-l1;
-2;

{switch
{switch

to
to

next available script}
the system script}

smKeySwapScript
smKeyNextKybd

a
=

-4;

{switch
{switch

to
to

previously
used
next keyboard
}

smKey SwapkKybd

=

-5;

smKeyDisableKybds

=

-6;

{ in current script}
{switch to previously used }
{ keyboard in current script}
{disable keyboards not in }

smKeyEnableKybds

=:

yy

{ system or Roman
{enable keyboards

Summary of the Script Manager

}

{ & size (low word) }
{default application
'FOND'
(high }
{ word)
& size (low word) }
{default
'FOND'
(high word)
& }
{ size
(low word)
for Balloon Help}
{set of all valid styles for }
{ script}
{style to use for indicating aliases}

{

14-120

to

current

enabled

scripts}

script}

script}
for all

script}

}

}

Worldwide Software Overview

smKeyToggleInline

=

=—§5

{toggle

inline

input

smKeyToggleDirection

=

—9

script}
{ current
{toggle default
line

smKeyNext

=

-10;

{switch

InputMethod

{
smKeySwapInputMethod

=

smKeyDisableKybdSwitch

=

in

to

next

current

}

direction}

input

method

{switch

-12;

{ input method in current
{disable switching from }
the

}

script}

-11;

{

to

for

previously

current

used

}

script}

keyboard}

{bits in the smScriptFlags word; bits above 7 are nonstatic;
resource}
{ scripts flag word is initialized from 'itlb'
smsfIntellcP

=

Q%

{script

has

intelligent

cut

smsfSingByte

=

1;

{script

has

only

single

bytes}

sms fNatCase

=:

By

{native

characters

have

upper-

smsfContext
sms fNoForceFont
smsfBODigits

=
=
=

3;
4s
5;

{script
{script
{script

is contextual}
will not force characters}
has alternate digits at $B0-S$B9}

smsfAutoInit

=

6;

{automatically

smsfForms

=

133

{script

uses

contextual

forms

smsfLigatures

=:

2a

{script

uses

contextual

ligatures}

smsfReverse

=

153

{script

reverses

{bits

in

Script

{ (high-order)
smfNameTagEnab

Manager

{Script

Manager

text,

(smGenFlags)

long

=

from
‘itlc'
flags byte}
{reserved
for internal
use}

=
=

30;
34%

{use dual caret
{show icon even

is

font

smFondStart
smFondEnd

flags

native

paste}
and

the

set
23

byte

smfDualCaret
smfShowIcon

general

initialize

and

}

lowercase}

script}
for

letters}

right
word;

to

left}

first

}

for mixed-directional
if only one script}

text}

equates}

=
=

$4000;
$C000;

{start from 16 KB}
{past end of range

at

48

—

KB}

—

{miscellaneous

font

smUprHalfCharSet

=

equates }

$80%

=<

{first
{

of

character
standard

code

Roman

top

half

character

in

set}

}

~
—
|;
—
~
_—
<
<
mm:
o

—

o

{character

set

diaeresisUpry
fraction
intlCurrency

leftSingGuillemet
rightSingGuillemet
fiLigature
flLigature
dblDagger
centeredDot
baseSingQuote
baseDblQuote
perThousand

circumflexUprA
circumflexUprE
acuteUprA

diaeresisUprE

ZO 4
~
~
—
oa
-

extensions}

$D9;
SDA;
$DB;
$DC;

<

as
~
—

4°)

$DD;

SDE;
SDF;
SEO;
SE1;
SE2;
SE3+
SE4;
SE5;
SE6;
SE7;
SE8;

Summary of the Script Manager

14-121

:

Inside Macintosh,

Volume VI

graveUprE

=

SEQ;

acuteUprI

=

SEA;

circumflexUprI
diaeresisUprI
graveUprI

=
=
=

SER;
SEC?
SED;

acuteUpro

=

SEE;

circumflexUpro

=

SEF;

appleLogo

=

SFO;

graveUproO

=

SEL:

acuteUpru

=

Sr2;

circumflexUprU
graveUprU
dotlessLwrI
circumflex

=
=
=
=

$F3>
SF4;
SFS;
SFG;

tilde

=

SF7;

macron

=

SFS8;

breveMark

=

$F9;

overDot

=

SFA;

ringMark
cedilla

=
=

SFB;
SFC;

doubleAcute

=

SFD:

ogonek

=

SFE;

hachek

=

SEF;

{String2Date
{

status

values

String2DateStatus

word

(masks

for

returned

by

bits

in

}

String2Time) }

fatalDateTime

=

$8000;

{a

=

13

{long

leftOverChars

=

23

{leftover

sepNotInt1lSep

=

ds

{nonstandard

fieldOrderNotIntl

=

Oy

{nonstandard

field

order}

extraneousStrings

=

16;

{unparsable

strings

in

tooManySeps

=

32

{too

sepNotConsistent

=

64;

{inconsistent

separators}

tokenErr

=

$8100;

{IntlTokenize

error}

cantReadUtilities

=

$8200;

{can't

dateTimeNot Found
dateTimeInvalid

=
=

$8400;
$8800;

{date
{date

+l;
10%
27%

{restrict

28;

{ general
control
{If toggling
hour

29

{ to 12-hour range
(A.M./P.M.).}
{modifies
togCharil2HourBit
to use

30%

{ 0-11 hour range}
{If toggling
hour by

{date

fatal

the

and

longDateFound

error}

date

found}

characters}

many

text}

separators}

load

or
or

separators}

intl

time
time

resources}

not found}
invalid}

equates}

validDateFields
maxDateField
genCdevRangeBit
togDeltal2HourBit
togCharZCycleBit
togCharl2HourBit

=
=
=
=
=
=

{
smallDateBit

14-122

result

String2Date

=

31;

Summary of the Script Manager

field

date/time

is

to

range

panel}
up and

modified

used

down,

character,

as

by

}

restrict
}

hour

if

displayed

{ 12-hour
time
(1-12 hour
{restrict
valid date/time
{ Time global}

range).}
to range

}

}

in
of

}
}

Worldwide Software Overview

{long

date

{The

following

{

check

to

record

field

masks

(that

masks}

specify

is,

for

the

{ TogglePB.togFlags
eraMask

value).}
= ‘SO0OL:

yearMask
monthMask

=
=

$0002;
$0004;

dayMask

=

$0008;

hourMask
minuteMask

=
=

$0010;
$0020;

secondMask

=

$0040;

dayOfWeekMask
dayOfYearMask

=
=

$0080;
SOLOOs

weekOfYearMask

=

$0200;

pmMask
dateStdMask

=
=

$0400;
S$OO7F;

that

ToggleDate

and

function

toggleUndefined

=

toggleOK

=

iL:

toggleBadField

=

23

date

flags

{default
{

{results

long

ValidDate

record

fields

parameter,

and

value

for

for

the

ValidDate

ValidDate

}

ToggleDate

}

flags

}

TogglePB.togFlags}
can

return}

‘Oy

toggleBadDelta

=

33

toggleBadChar

=

4;

toggleUnknown
toggleBadNum

=
=!

3%
16%

toggleOutOfRange

=

7%

toggleErr3

=

7's

toggleErr4

=

8}

toggleErr5

=

9s

{synonym

for

toggleErr3}

cS
{codes

{

for

styleRunPosition

argument

NMeasureJust,

NChar2Pixel,

NDrawJust,

in

smOnlyStyleRun

=

O%

{only

smLeftStyleRun

=

13

{multiple

{

line;

ZF

{multiple

smMiddleStyleRun

=

3s

‘multiple

{ line;

{constants

for

truncWhere
0;

smTruncMiddle
{constants

for

TruncText

style

is

on

the

runs

and

>

style

runs

on

}

5

this

in

=

Qs

{no

=

i

{truncation

smTruncErr

=

<=;

{general

=

us
}

rightmost}

smTruncated

}

on

line;

smNotTruncated

on

S.

runs

is

nor

TruncString

line}

=

style

this

{truncate

=

routines}

leftmost}

is

rightmost}
neither

argument
in TruncString
{truncate
at end}

$4000;

}

NPixel2Char

run

this

=

smTruncEnd

and

style

smRightStyleRun

{

NPortionText,

and

z

leftmost

}

TruncText}

middle}
results}

truncation

was

necessary}

performed}

error}

Summary of the Script Manager

14-123

Inside Macintosh, Volume VI

Data

Types

TYPE

TruncCode

=

Integer;

JustStyleCode

{new

type

for

system

software

version

7.0}

Integer;

{new

type

for

system

software

version

7.0}

(tokenOK,

tokenOverflow,stringOverflow,

=

TokenResults

=

badEnding,

LongDateField

=

crash)

badDelim,

;

(eraField,
yearField, monthField,
dayField,
hourField,
minuteField,
secondField,
dayOfWeekField,
dayOfYearField,
weekOfYearField,
pmField,
reslField,
res2Field,
res3Field);

CharByteTable
PACKED

ARRAY[0..255]

FormatOrderPtr

=

OF

“FormatOrder;

FormatOrder

=

ARRAY[0..0]

OF

Integer;

FormatClass

=

(fPositive,

FormatStatus

WideChar

=

SignedByte;

fNegative, fZero)

;

Integer;

=

RECORD

CASE

Boolean

OF

TRUE:

(a:

PACKED

ARRAY[0..1]

OF

CHAR);

{0

Integer;
PACKED ARRAY[0..9]

OF

WideChar

OF

SignedByte

is

the

high-order

character}

FALSE:

(b:

Integer)

END;

WideCharArr

=

RECORD

Size:
data:
END;

NumFormatString
PACKED

fLlength:
fVersion:

data:

=

RECORD

Byte;
Byte;

PACKED

ARRAY[0..253]

END;

14-124

Summary of the Script Manager

{private

data}

Worldwide Software Overview

FormatResultType

=

(fFormatOK,

fBestGuess,

fSpuriousChars,
fExtraDecimal,
fFormatOverflow,

fOutOfSynch,

fMissingDelimiter,
fMissingLiteral,
fExtraExp,
fFormStrIsNAN,

fBadPartsTable,

fExtraPercent,
fExtraSeparator,
fEmptyFormatString) ;

ScriptRunStatus

=

RECORD

script:

SignedByte;

variant:

SignedByte

END;

ToggleResults

=

LongDateTime
=
LongDateCvt
=

Integer;

Comp;

RECORD
CASE

Integer

OF

0:
(c:

Comp);

1:
(lHigh:

LongInt;

lLow:

LongInt)

END;

LongDateRec

=

RECORD

CASE

Integer

OF

rs

0:2

<
(era:
year:

Integer;
Integer;

So
>.

month:

Integer;

=

day:

Integer;

>

minute:

Integer;

hour:

second:

Integer;

a

Integer;

S

>

dayOfWeek:
dayOfYear:
weekOfYear:

Integer;
Integer;
Integer;

e

pm:

Integer;

resl:
res2:

Integer;
Integer;

res3:

Integer) ;

1%
(list:

ARRAY[0..13]

OF

Integer);

‘index

by

LongDateField}

2:3
(eraAlt:

Integer;

oldDate:

DateTimeRec)

END;

Summary of the Script Manager

14-125

Inside Macintosh,

Volume VI

DateDelta

=

SignedByte;

MachineLocation=
RECORD

latitude:
longitude:
CASE

Fract;
Fract;

Integer

OF

0:
(dlsDelta:

SignedByte)

(gmtDelta:

LongIint)

;

{signed

byte;

daylight

savings

5Ue
{must

mask—-see

{ Worldwide
{

Guide

to

System

END;

String2DateStatus
DateCachePtr

=

Integer;

“DateCacheRecord;

DateCacheRecord
PACKED

=

=

RECORD

hidden:

ARRAY[0..255]
{only

for

OF

Integer

temporary

use}

END;
BreakTablePtr
BreakTable
RECORD

=

“BreakTable;

=

charTypes:

ARRAY[0..255]

tripleLength:
Integer;
triples:
ARRAY[(0..0]
OF

OF

SignedByte;

Integer

END;

{new for system software version
NBreakTablePtr = “NBreakTable;
NBreakTable

=

RECORD
flags1:

SignedByte;

flags2:

SignedByte;

version:

Integer;

classTableOff:

Integer;

auxCTableOff:

Integer;

backwdTableOff:

Integer;

forwdTableOff:
doBackup:

Integer;
Integer;

reserved:
charTypes:

Integer;
ARRAY[0..255]

tables:

ARRAY[0..0]

END;

OffPair

=

RECORD

14-126

7.0}

Summary of the Script Manager

OF
OF

SignedByte;

Integer

"Macintosh

Development:

}

}

Software"}

delta}

Worldwide Software Overview

offFirst:
offSecond:

Integer;
Integer

END;

OffsetTable

=

ARRAY[0..2]

NumberPartsPtr
NumberParts
RECORD

=

OF

OffPair;

“NumberParts;

=

version:

Integer;

data:

ARRAY[1..31]

{index

OF

WideChar;

by[tokLeftQuote..tokMaxSymbols] }

pePlus:

WideCharArr;

peMinus:
peMinusPlus:
altNumTable:

WideCharArr;
WideCharArr;
WideCharArr;

reserved:

PACKED

ARRAY[0..19]

OF

Char

{must

be

zeroed}

END;

FVector

=

RECORD
SEALE:

Integer;

length:

Integer

END;

TripleInt

=

ARRAY[0..2]

OF

FVector;

StyledLineBreakCode
TogglePB

RECORD

=

{index

by

[fPositive..fZero] }

(smBreakWord,

smBreakChar,

smBreakOverflow)

;

rs

=

oy

=

togFlags:

LongIint;

{caller

amChars:

ResType;

{from

pmChars:

ResType;

{from

reserved:

ARRAY[0..3]

{ to
OF

normally

dateStdMask

sets

= $7F}

low

word

}

=

=

'itl0O'

resource}

oa

'itl0'

resource}

a

LongInt

=

END;

PS

a

TokenBlockPtr

TokenBlock
RECORD

=

“TokenBlock;

=

source:

PLY?

{pointer

sourceLength:
tokenList:

Longint;
Ptr;

{length of source
{pointer
to array

to

tokenLength:
tokenCount:

Longint;
LongInt;

{maximum
length of TokenList}
{number
of tokens generated
}

stringList:

Ptr;

{ by tokenizer}
{pointer
to stream

stringLength:
stringCount:

LongIint;
LongIint ;

{length
{number

of
of

stream

of

characters}

stream}
of tokens}

of

identifiers}

string
list}
bytes
currently

Summary of the Script Manager

used}

14-127

Inside Macintosh,

Volume VI

doString:

Boolean;

{make strings and put
{ into StringList}

}

doAppend:

Boolean;

{append
to TokenList
{ than replace}

doAlphanumeric:
doNest:
leftDelims:
rightDelims:

Boolean;
Boolean;
ARRAY[0..1]
ARRAY[0..1]

{identifiers may include
{do comments nest?}
OF TokenType;
OF TokenType;

leftComment:
rightComment :

ARRAY[0..3]
ARRAY[0..3]

OF
OF

escapeCode:

TokenType;

{escape

symbol

code}

decimalCode:

TokenType;

to

'itl4'

rather

}

numeric}

TokenType;
TokenType;

itlResource:

Handle;

{handle

reserved:

ARRAY[0..7]

OF LongInt
{must be zero}

an

resource}

END;

TokenType

=

Integer;

DelimType

=

ARRAY[0..1]

{see

OF

CommentType

= ARRAY[0..3]

TokenRecPtr

=

TokenRec
RECORD

TokenType

values

in

this

TokenType;

OF

TokenType;

*“TokenRec;

=

theToken:
position:
length:
stringPosition:

TokenType;
Ptr;
LongInt;
StringPtr

{ptr into original source}
{length of text in original
{Pascal/C string copy of }
{ identifier}

END;

UntokenTablePtr
= *“UntokenTable;
UntokenTableHandle
= “UntokenTablePtr;
UntokenTable

=

RECORD
len:

Integer;

lastToken:
index:

Integer;
ARRAY[0..255]
{index table;

END;

14-128

summary}

Summary of the Script Manager

OF Integer
last
= lastToken}

source}

Worldwide Software Overview

Routines

Localizing Word
PROCEDURE

NFindWord

Truncating
FUNCTION

Selection

and

Line Break Tables

(textPtr:

Ptr;

offset:

Integer;

offsets:

(width:

VAR

theString:

nbreaks:

OffsetTable) ;

Text

TruncString

TruncText

Integer;

(width:

TruncCode)

Integer;

length:

Substituting

:

textPtr:

Str255;

Integer;
Ptr;

Integer;

truncWhere:

TruncCode)

:

Integer;

Text

ReplaceText

(baseText:
key:

Converting

Boolean;

VAR

VAR

FUNCTION

Integer;

leadingEdge:

NBreakTablePtr;

truncWhere:
FUNCTION

textLength:

Case

Handle;

Stri5)

and Stripping

:

substitutionText:

Handle;

Integer;

Diacritical

Marks

PROCEDURE

UprText

(textPtr:

Ptr;

len:

Integer);

PROCEDURE

LwrText

(textPtr:

Ptr;

len:

Integer);

as

pan
_

a
a
ell

a}

{new

with

system

PROCEDURE

software

LowerText

version

&
<
=

7.0}

(textPtr:

i

om)
a

Ptr;

len:

PROCEDURE

UpperText

(textPtr:

Ptr;

len:

Integer);

PROCEDURE

StripText

(textPtr:

Ptr;

len:

Integer);

PROCEDURE

StripUpperText

(textPtr:

Ptr;

len:

Integer);

Providing
{new

with

FUNCTION

for Spacing
system

software

NPortionText

Between
version

Multiple

La)

Integer);

Style

2
-)

=
—
<A

<

+s)
"
a)

Runs

7.0}

(textPtr:
Ptr;
textLen:
LongInt;
styleRunPosition:
JustStyleCode;
numer:

Point;

denom:

Point)

:

Fixed;

Summary of the Script Manager

14-129

Inside Macintosh,

PROCEDURE

Volume VI

NDrawJust

(textPtr:

slop:

Ptr;

Fixed;

textLen:

JustStyleCode;
PROCEDURE

NMeasureJust

(textPtr:
slop:

LongInt;

styleRunPosition:
numer:

Ptr;

Fixed;

Point;

denom:

textLen:

LongInt;

charLocs:

Ptr;

Point);

styleRunPosition:
JustStyleCode;
numer:
Point; denom:
Point);
FUNCTION

NChar2Pixel

FUNCTION

NPixel2Char

(textBuf:

Ptr;

textLen:

numer:

Point;

denom:

LongInt;

slop: Fixed; offset:
LongInt;
direction:
Integer;
styleRunPosition:
JustStyleCode;

(textBuf:

slop:
VAR

Ptr;

Fixed;

Point)

textLen:

Integer;

LongInt;

pixelWidth:

leadingEdge:

:

Fixed;

Boolean;

VAR widthRemaining:
Fixed;
styleRunPosition:
JustStyleCode;
numer:

Obtaining
FUNCTION

Character

ParseTable

Drawing

and

PROCEDURE

HiliteText

Formatting
FUNCTION

Point;

denom:

Point)

:

Integer;

Information
(VAR

table:

CharByteTable)

:

Boolean;

Editing Text
(textPtr:

Ptr;

textLength:

Integer;

firstOffset:

Integer;

VAR

OffsetTable);

offsets:

secondOffset:

Integer;

Text

FindScriptRun

(textPtr:
VAR

Ptr;

lenUsed:

textLen:
LongInt)

Ptr;

LongInt;
:

FUNCTION

PortionText

(textPtr:

PROCEDURE

GetFormatOrder

(ordering:
FormatOrderPtr;
firstFormat:
Integer;
lastFormat:
Integer;
lineRight:
Boolean;
rlDirProc:
Ptr;

dirParam:
FUNCTION

StyledLineBreak

textLen:

ScriptRunStatus;

:

Fixed;

Ptr);

(textPtr:
Ptr;
textLen:
LongInt;
textStart:
LongInt;
textEnd:
LongInt;

flags:
VAR

LongInt;

textOffset:

VAR

Summary of the Script Manager

textWidth:

LongInt)

StyledLineBreakCode;

14-130

LongInt)

Fixed;

Worldwide Software Overview

FUNCTION

VisibleLength

Lexically
FUNCTION

Date

(textPtr:

Interpreting

Time

textLen:

LongInt)

:

LongInt;

Different Scripts

IntlTokenize

and

Ptr;

(tokenParam:

TokenBlockPtr)

:

TokenResults;

Utilities

FUNCTION

InitDateCache

(theCache:

DateCachePtr)

FUNCTION

String2Date

(textPtr:

Ptr;

:

textLen:

LongInt;

DateCachePtr;

VAR

VAR

LongDateRec)

dateTime:

OSErr;

lengthUsed:

theCache:
LongInt;

String2DateStatus;
FUNCTION

String2Time

(textPtr:

Ptr;

theCache:

textLen:

LongInt;

DateCachePtr;

VAR

lengthUsed:

VAR

dateTime:

LongInt;

LongDateRec)

String2DateStatus;
PROCEDURE

LongDate2Secs

(lDate:

PROCEDURE

LongSecs2Date

(VAR

LongDateRec;

1Secs:

VAR

lSecs:

LongDateTime;

VAR

LongDateTime) ;
1Date:

LongDateRec) ;
FUNCTION

ToggleDate

(VAR

1Secs:

field:
ch:

LongDateTime;

LongDateField;

Integer;

params:

delta:

DateDelta;

TogglePB)

—
hoe

ToggleResults;
FUNCTION

ValidDate

(VAR
VAR

~

=<
ant

vDate:
LongDateRec;
flags:
LongInt;
newSecs:
LongDateTime)
: Integer;

=

ar |
a—
—

a
i

—e

Reading

and

Storing

2.

Locations

Y,

o
-

=
—_

lms
<
~~

xe

=
i
@

PROCEDURE

ReadLocation

(VAR

loc:

PROCEDURE

WriteLocation

(loc:

MachineLocation) ;

Number

Utilities

FUNCTION

Str2Format

(inString:
Str255;
partsTable:
NumberParts;
VAR outString:
NumFormatString)
: FormatStatus;

FUNCTION

Format2Str

(myCanonical:

NumFormatString;

partsTable:

NumberParts;

VAR
VAR

MachineLocation);

outString:
positions:

Str255;
TripleInt)

:

FormatStatus;

Summary of the Script Manager

14-131

Inside Macintosh,

FUNCTION

Volume VI

FormatX2Str

(x:

Extended;

myCanonical:

NumFormatString;

partsTable:

NumberParts;

VAR

outString:

FormatStatus;
FUNCTION

FormatStr2xX

(source:

Str255;

myCanonical:
partsTable:
VAR

Assembly-Language
Trap

Macros

Extended)

:

FormatStatus;

Information

Requiring

_ScriptUtil

$A8B5

Selector

Routine

$8008FFFO
$8008FFF2
$800E001C
$8012FFE2
$8012FFFC
$80 160032
$801A0034
$8202002A
$82040022
$8204FFF8
$8204FFFA
$8208FFE0
$820C0026
$820CFFDC
$820CFFDE
$820CFFE4
$820CFFEC
$820EFFEE
$82 10FFE6
$82 10FFE8
$82 1OFFEA
$8214 FFF4
$82 14FFF6
$8216002C
$821C0030
$82 1 CFFFE
$8222002E
$84080024
$84080028
$84 120036

LongSecs2Date
LongDate2Secs

14-132

x:

NumFormatString;
NumberParts;

Routine

Selectors

HiliteText
NFindWord
GetFormatOrder
NDrawJust
NMeasureJust

IsSpecialFont

ParseTable
InitDateCache
IntITokenize

; 2-byte script systems only

TruncString
FindScriptRun
ReplaceText
TruncText
ValidDate
Str2Format

ToggleDate

FormatStr2X
FormatX2Str
Format2Str

String2Time
String2Date

RawPrinterValues
NChar2Pixel

StyledLineBreak
NPixel2Char
PortionText

VisibleLength

NPortionText

Summary of the Script Manager

; 2-byte script systems only

Str255)

Worldwide Software Overview

SUMMARY

OF

THE

INTERNATIONAL

UTILITIES

PACKAGE

Constants
{special script
iuSystemScript
iuCurrentScript

code

values

for

International

{special

language

code

{system

=

=2

{current
script
for font of
}
{ grafPort
(as returned by }

values

=

1uSystemDefLang

International

('itlb')

{

script

system

{

juCurrentDefLang

-4;

=

script

iy

iuScriptDefLang

=

Ty

{table

selectors

for

iuWordSelectTable

language
(from

script

}

{

globals) }
for

current

}

(from

'‘itlm'

('itlb')

specified

{

(from

script

}

resource) }
for

}

}

globals) }

language

{

(from

script

for

language

script

{default

for

'itlm'

specified

}

resource) }

GetItl1Table}
=

{word

0;

=
I

select

from

{word

'itl12'

wrap

break

from

{untoken

=
I

from

{white

&

break

the

{ (irom
{default

{

from

table
table

'itl4'

table
the
space
the

heme

resource}

"2612 "2
number
parts

the

tos

}

<—

=
°_

}

—

table

=
<a
<

}

a

resource}

@

>
N

}

'itl4'
list
'1tl14'

ec)
-

resource}
table

=

~
gr)
@

}

resource}

versions}

verFrBelgiumLux
verSweden
verSpain

=
a
=

verDenmark
verPortugal

=
=

ee
a

=
=

.o™e

=

verlItaly
verNetherlands

{French

at]

=

verGermany

for

Belgium

&

Luxembourg}

al

=

verBritain

ee

ea

verFrance

©
EF
PWN
mOaAanaUW

{regional
verUS

language

script

{

{
iuWhiteSpaceList

}

script

{
iuUnTokenTable

system

resource) }

('itlb')

{current

ine)

juNumberPartsTable

}
}

current

{

iuWordWrapTable

for

'itlm'

for

script

{current

{

=

(from

(from

Package}

language

{

{default

<5;

iuScriptCurLang

Utilities

{current

{ globals) }
{default
language

Bis

=

script}

FontScript) }

for

<2

=:

iuCurrentCurLang

Package}

-—l>;

{

iuSystemCurLang

Utilities

=

Pwo
On

CONST

.
‘

Summary of the International Utilities Package

14-133

Inside Macintosh, Volume VI

verFrCanada

=

Lis

verNorway
verIsrael

=
=

LZ
133

verJapan

=

Ld

verAustralia
verArabic
verFinland
verFrSwiss
verGrSwiss

=
=
=
=
=

15;
16;
17;
18;
19;

verGreece
verIceland

=
=

20%
zis

verMalta

=

223

verCyprus
verTurkey

=
=

23ay
24+

verYugoCroatian

=

253

{verArabia
{French
{German

verIndiaHindi

=

33%

verPakistan
verLithuania
verPoland
verHungary
verEstonia
verLatvia

=
=
=
=
=
=

34;
41;
42;
43;
44;
25%

verFaeroeIsl

verLapland

version

{

new

synonym}

{Urdu

version}

=

A7;

=

48;

verRussia
verlIreland

=
=

49;
SO

verKorea

=

51;

verChina
verTaiwan
verThailand
minCountry
maxCountry

=
=
=
=
=

527
53;
54;
verUS;
verThailand;

version names}
= 6%
=
=

IG;
255

{English

veriIndia

=

14-134

for

India;

}

33;

language

version

for

}

Ireland}

}

{use

instead,

}

verYugoCroatian

less

{use

Integer;
Integer;

Summary of the International Utilities Package

ambiguous}

verIndiaHindi

less

Types
=

Yugoslavia;

instead,

{

ScriptCode

for

{use verFrBelgiumLux
{ less ambiguous}

{

LangCode

version

synonym}

{Hindi

verlIran

verArabia
verYugoslavia

TYPE

new

= 46;

{obsolete regional
verBelgiumLux

Data

Switzerland}
Switzerland}

{Croatian
{

synonym}

ambiguous}

instead,

}

Worldwide Software Overview

Routines

Manipulating

the ‘itl2' and

PROCEDURE

IUClearCache;

PROCEDURE

IUGetItl1Table

'itl4' Resources

(script:
VAR
VAR

Specifying
FUNCTION

Resource

IUCompPString

ScriptCode;

Handles

(aStr,bStr:

IUMagPString

Handle)

(aPtr,bPtr:

IUEqualPString

Integer;

offset:

LongInt;

Str255;
Ptr;

itl2Handle:
FUNCTION

VAR

Explicitly

itl2Handle:
FUNCTION

tableCode:

itlHandle:
Handle;
length:
LongInt);

Integer;

aLen,bLen:

Handle)

(aStr,bStr:

:

Str255;

:

Integer;

Integer;

itl2Handle:

Handle)

Integer;
FUNCTION

IUMagIDPString

(aPtr,bPtr:

Ptr;

itl2Handle:

Determining
FUNCTION

Interscript Sorting

IUScriptOrder

aLen,bLen:

Handle)

:

Integer;

Integer;

Order

(scriptl,script2:

ScriptCode)

:

Integer;
tome.

FUNCTION

IULangOrder

(languagel,

language2:

FUNCTION

IUStringOrder

(aStr,

Str25S;

bstrs

aScript,bScript:
aLang,bLang:

FUNCTION

IUTextOrder

LangCode)

:

Integer;

*

=

=
ScriptCode;

LangCode)

:

2.

Integer;

5:
fa)

(aPtr,bPtr: Ptr; aLen,bLen: Integer;
aScript,bScript: ScriptCode; aLang,bLang:
LangCode)

:

Z
>

Integer;

S
ia)

Localizing
PROCEDURE

PROCEDURE

Dates,

Times,

IULDateString

IULTimeString

and

Metric

(VAR

dateTime:

VAR

Result:

Information
LongDateTime;

Str255;

longFlag:

intlParam:

DateForm;

Handle) ;

(VAR dateTime:
LongDateTime;
wantSeconds:
Boolean;
VAR Result:
intlParam:
Handle) ;

Str255;

Summary of the International Utilities Package

14-135

Inside Macintosh,

Volume VI

Assembly-Language
Trap

Macro

Information

Requiring

Routine

_Pack6

$A9ED

Selector

Routine

$0014
$0016
$0018

[ULDateString
IULTimeString
[UClearCache

$001C
$OO1E
$0020
$0022
$0024

[UMagIDPString
[UScriptOrder
[ULangOrder
[UTextOrder
[UGetItlTable

$O01A

;stack

Selectors

[UMagPString

frame

IUSortFrame
result

for

'itl2'

record

sorting

{oldA6},decrement
il.

bStrText
aStrLen

ds. 1
ds. 1
ds. Ww

i)
i
1

bStrLen

ds.

1

return

ds.

o1ldA6
aInfo

ds.
ds

binfo

ds

IUStrData

wantMag

ds.

weakEq

ds.

1
u
Z
1

ds.
ds.
ds.

weakBPtr

lkSize
paramBytes

oS
Ooo

ds.

supStorage
weakAPtr

IUStrData
;0 to use primary differences
only;
;Signals
at most weak equality
; (obsolete,
not used)
;-1 to
;extra

force magnitude
storage

oO

ds.

1
1

18

=H

msLock
weakMag

Hrs

ds. Ww

aStrText

routines

1

;sup.

pointer

1

;sup.

pointer

equ

x

;frame

size

equ

aStrText-return

endr

14-136

Summary of the International Utilities Package

result

(-1,

else

0,

1);

1

else

0

Worldwide Software Overview

stack

;adds

frame

itl2Handle

IUNSortFrame

for
'i1t12'
field.

ds.

bStrLen

ds.

et

return
oldA6

ds.
ds.

alInfo

ds

IUStrData

bInfo

IUStrData

wantMag

ds
ds.

weakEq

ds.

msLock

ds.

weakMag

ds.

supStorage
weakAPtr

ds.
ds.
ds.

1kSize

equ
equ

paramBytes

ds.

ail

weakBPtr
itl2Handle

© a @ TE @ Sa © 2

ds.

aStrLen

rPrE

ds.

bStrText

© a

aStrText

routines

in

version

7.0

1
i
1
ut
1
1
ui

lll cee

ds.

sorting

{oldA6},decrement

record

result

egerere

;New

L

;0

1

;signals

to

use

primary

1
1

; (obsolete,
not used)
;-1 to force magnitude

at

most

18

;extra

A,

;sup.

pointer

1

;sup.

pointer

1

;itl2

handle,

*

;frame

size

differences
weak

only;

else

(-1,

0,

1

equality
result

1);

else

0

storage

if

supplied

aStrText-return

endr

_
_
<
=
=
=)
—

—

e

=e
<
=

Ny

_lool
joe
fae]

A

=
——

-

<
<=

+e)

var }
ae)

Summary of the International Utilities Package

14-137

Inside Macintosh, Volume VI

SUMMARY

Data
TYPE

OF

THE

INTERNATIONAL

RESOURCES

Types
Itl4Ptr

=

*“Itl4Rec;

Itl4Handle
Itl4Rec
=

=

*Itl4Ptr;

RECORD
flags:

Integer;

{reserved}

resourceType:
resourceNum:

LongInt;
Integer;

{contains
{resource

version:

Integer;

{version

resHeaderl:

LongInt;

resHeader2:

LongInt;

numTables:
mapOffset:

'itl4'}
ID}

number}

Integer;

{one-based}
{offsets

strOffset:

LongInt;
LongIint;

fFetchOffset:
unTokenOffset:

LongInt;
LongInt;

defPartsOffset:

LongIint;

resOffseté6:
resOffset7:

LongInt;
Longint ;

resOffsets:

Longint

are

from

record

start}

END;

{new for
NItl4Ptr

system software
= *NItl4Rec;

Nitl4Handle
NItl4Rec
=

=

version

7.0}

*NItl4Ptr;

RECORD

flags:

Integer;

resourceType:

{reserved}

Longint;

resourceNum:
version:

{contains

Integer;
Integer;

format:

Integer;

resHeader:

Integer;

resHeader2:
numTables:

'itl14'}
{contains
resource
{version number}
{format
code}
{reserved}

LongInt;
Integer;

{reserved}
{number
of
{

{The

14-138

following

are
mapOffset:

offsets

from

beginning
LongInt;

strOffset:

LongiInt;

fetchOffset:

Longint;

Summary of the International Resources

of

tables,

ID}

}

one-based}

resource
{offset

to
to

tables &
table that

code

chunks. }

maps

byte

{ to token}
{offset
to routine
that
string}
{ canonical
{offset
to routine
that
{ byte of character}

copies
gets

}
}

next

}

Worldwide Software Overview

unTokenOffset:

Longint;

defPartsOffset:

Longint;

whtSpListOffset:
resOffset7:

Longint;
Longint;

resOffsets8:

LongInt;

{reserved}

resLengthl:

Integer;

{reserved}

{offset
to untoken
table,
}
{ maps
token to canonical
string}
{offset
to default
number parts
}
{ table}
{offset
to white
space code
list}
{reserved}

resLength2:

Integer;

{reserved}

resLength3:

Integer;

{reserved}

unTokenLength:
defPartsLength:

Integer;

{length

of

untoken

table}

Integer;

{length

of

default

}

whtSpListLength:
resLength7:

Integer;
Integer;

{ number parts
table}
{length of white
space
{reserved}

resLength8:

Integer

{reserved}

code

list}

END;

ItlbRecord
RECORD

=

itlbNumber:

Integer;

{'itlO'

ID

number}

itlbDate:

Integer;

{'itl1l'

ID

number}
number}

itl bsort;:

Integer;

{'itl2'

ID

itlbFlags:
itlbToken:
itlbEncoding:

Integer;
Integer;
Integer;

{script
{'itl4'
{'itl5'

flags}
ID number}
ID number

{

itlbLang:
itlbNumRep:

Integer;
SignedByte;

character

itlbDateRep:

SignedByte;

{date

Integer;

{'KCHR'

itlbIcon:

Integer

{ID

ItlbExtRecord

RECORD

}

{current language for script}
{number representation code}

itlbKeys:

END;

(optional

encoding) }

representation

ID

number

{

or

{

'kces8'

code}

number}

of

‘kes#',

oS

'SICN'

}

=

'kes4',

}

o

family}

=

S.

L

=

=n

=

base:

ItlbRecord;

{unextended

itlbLocalSize:
itlbMonoFond:
itlbMonoSize:
itlbPrefFond:
itlbPrefSize:
itlbSmallFond:

Longint;
Integer;

{size of
{default

Integer;
Integer;
Integer;
Integer;

{default
monospaced
font
size}
{preferred
'FOND'
ID}
{preferred
font
size}
{default
small
'FOND'
ID}

ItlbRecord}

a

script's
local
record}
monospaced
'FOND'
ID}

itlbSmallSize:

Integer;

{default

small

itlbSysFond:

Integer;

{default

system

'FOND'

itlbSysSize:

Integer;

{default

itlbAppFond:
itlbAppSize:

system

font

Integer;
Integer;

{default
{default

application
application

itlbHelpFond:

Integer;

{default

Help

Mgr

'FOND'

itlbHelpSize:

Integer;

{default

Help

Mgr

font

font

size}
ID}
size}

'FOND'
ID}
font size}

Summary of the International Resources

ID}
size}

14-139

Inside Macintosh, Volume VI

itlbValidStyles:
itlbAliasStyle:

Style;
Style

{set of valid styles
{style
(set)
to mark

itlcSystem:

Integer;

{default

itlcReseryed:

Integer;

{reserved}

for script}
aliases}

END;

ItlcRecord

=

RECORD

script}

itlcFontForce:

SignedByte;

{default

font

force

flag}

itlcIntlForce:

SignedByte;

{default

intl

force

flag}

itlcOldKyhd:

SignedByte;

{old

itlcFlags:

SignedByte;

{general

itlcIconOffset:

Integer;

{keyboard

keyboard}
flags}
icon

{ with

version
side}

offset;

7.0,

not

beginning

used}

itlcIconSide:

SignedByte;

{icon

itlcIconRsvd:
itlcRegionCode:

SignedByte;
Integer;

{rsvd for other icon info}
{preferred verXxx code}

itlcReserved3:

ARRAY[0..33]

OF

SignedByte
{for

END;

14-140

system

Summary of the International Resources

future

use}

}

TEXTEDIT
About This Chapter
About TextEdit
Mixed-Directional Text
Highlighting
Mouse-Down Regions
Dual Carets
Caret Movement Across Direction Boundaries
Font and Keyboard Synchronization
Double-Byte Characters
Vertical Movement of the Caret
Arrow Key Actions for Selected Text
Caret Position at Line Ends
Word Selection and Line Breaks
Accurate Line Measurement
TextEdit and TrueType Fonts
Using TextEdit
Determining the Version of TextEdit
Customizing TextEdit’s Features
Measuring the Width of Components of a Line
Defining Word Boundaries
Controlling Outline Highlighting, Text Buffering, and Inline Input
Setting Left Alignment for Right-to-Left Directional Scripts
Using WordRedraw for Line Calculations
Using the lineStarts Array to Determine Line Length
Using TextEdit’s Default Click Procedure
TextEdit Routines
Outline Highlighting, Text Buffering, and Inline Input

Outline Highlighting

Text Buffering
Inline Input
Customizing TextEdit
Replacing the End-of-Line Routine
Replacing the Measuring Routines
Replacing the Drawing Routine
Replacing the Hit Test Routine
Replacing the Word Breaking Routine
Backspacing to the Beginning of a Style
Determining the Position of an Ambiguous Offset
Toggling a Style
Determining Styles Across a Selection
Setting Styles in TextEdit’s Scrap Record
Determining the Number of Styles
TextEdit Data Structures
Summary of TextEdit

—

77)
ae]
a")
BS=
2.

—N

15-1]

Inside Macintosh, Volume VI

15-2

TextEdit

ABOUT

THIS

CHAPTER

This chapter describes the features that TextEdit provides for working with different scripts.
You can use TextEdit to provide the basic text-editing and formatting capabilities needed in
your application. TextEdit uses the Script Manager routines just as any application would to
work across all scripts. This chapter describes some routines, not previously documented in
Inside Macintosh, that are not specific to working with script systems. It also clarifies several
previously documented routines and includes an overview of all TextEdit data structures.
Read this chapter if you are interested in using TextEdit to write applications that exhibit the
correct behavior for editing and displaying text in multiple styles and different scripts. Most
new features of TextEdit are only apparent for non-Roman script systems.
To use this chapter, you should be familiar with the basic concepts and structures behind

QuickDraw™, the Toolbox Event Manager, the Window Manager, the Font Manager, the
Script Manager, and the Gestalt function.

For more information on QuickDraw, the Toolbox, the Window Manager, and the Font
Manager, see the corresponding chapters in this volume and in Volumes I, IV, and V. For
information on the Gestalt function, see the Compatibility Guidelines chapter in this volume.
The information in this chapter supplements the material in the TextEdit chapters in Volumes

I, IV, and V. See these volumes for details on TextEdit routines and data structures provided

prior to system software version 7.0.

For an introduction to the Macintosh® Script Management System, see the Worldwide
Software Overview chapter earlier in this volume.
In this chapter, the version of TextEdit referred to is included with system software
version 6.0.5 and later unless otherwise stated.

ABOUT

TEXTEDIT

In addition to all the text-handling features of earlier versions, TextEdit now allows you to
take advantage of the Script Manager’s treatment of system software with more than one
script system installed. TextEdit uses the Script Manager to support such systems. TextEdit
exhibits the correct behavior for editing and displaying text in multiple styles and different
scripts. Multiple scripts can even exist on a single line due to styled TextEdit’s use of the
Script Manager.
This chapter describes the situations in which TextEdit uses the Script Manager and the visual
results. It describes how TextEdit
mw

handles mixed-directional text

m synchronizes fonts and keyboards

About TextEdit

15-3

Inside Macintosh,

Volume VI

m handles double-byte characters
= determines word boundaries and line breaks
This chapter also tells how you can use TextEdit in your applications to
= provide outline highlighting for inactive text
m buffer text for performance improvements
s allow inline input in a double-byte script system
= permit left alignment in right-to-left directional scripts
m customize word breaking
m customize measuring
Throughout this chapter, script is used to mean a writing system such as Roman, Japanese,
or Arabic. Script system is used to denote a specific collection of software components for
handling text in a particular script. Examples of script systems are the Roman Script System,

the Japanese Script System (KanjiTalk™), as well as the Traditional Chinese Script System
and the Simplified Chinese Script System (both referred to as Zhong-WenTalk™).

At least two script systems are always present when a non-Roman script system is installed.
For example, Japanese system software is the combination of the U.S. system software
(which includes the Roman Script System, the Macintosh Operating System, the Toolbox,
and so forth) and the Japanese Script System, all of which are localized for Japan.
Localized system software—such as the Japanese system software—has been adapted
to a particular region or language. The French and Turkish versions of the Macintosh system
software are simply examples of localized variations of the U.S. system software that do not
include a second script system.

MIXED-DIRECTIONAL

TEXT

TextEdit now handles text with more than one script and direction. The following sections
explore how TextEdit treats mixed-directional text—the combination of scripts with leftto-right and right-to-left directional text—within a single line.
Figure 15-1 shows a line of Arabic text that contains some English text. In this case, the
primary line direction is right to left. The primary line direction is the dominant line
direction of the current script system and is specified by the value of the system alignment
global variable, TESysJust. (TESysJust was referred to in previous volumes as the system
justification global variable.) The value of TESysJust is —1 for a right-to-left primary line

direction and 0 for a left-to-right line direction. The default value of this global variable is

normally based on the system script. Your application can use the SetSysJust procedure to
change this value while drawing, but should restore it afterward. See Macintosh Worldwide
Development: Guide to System Software for details.
15-4

Mixed-Directional Text

TextEdit

Primary line direction
= right to left (TESysJust = —1)

ai (ArabicJ)jb
Figure 15-1. A right-to-left primary line direction
TextEdit organizes text logically into a hierarchy of runs (consecutive characters in memory
with the same attributes) including style runs, script runs, and direction runs. A style run is
a sequence of text all in the same font, style, size, and script. A script run is a sequence of
text all in the same script. A direction run is a sequence of text all in the same direction.
Figure 15-1 also shows three direction runs in the line.
Style runs (also called format runs) are displayed in display order rather than backing-store
order for a right-to-left directional script. Display order refers to the directional order in
which the glyphs are displayed on the device, which may be different from the way in which
the characters they represent are stored in the text buffer. Backing-store order is the
sequence in which characters are stored in memory.
Do not assume that display and backing-store orders are the same in any script. For example,
in left-to-right scripts, display and backing-store orders are usually the same for most
characters, whereas when right-to-left scripts are present, the orders are often different. So
for the characters that appear in Figure 15-1, the display order is as shown in Figure 15-2.

ats (Arabic)J lL
Figure

15-2. The display order

The backing-store order of the characters in Figure 15-1 is as shown in Figure 15-3.

S$ I

Note: The visual appearance of some of the Arabic characters in Figures 15-2 and
15-3 is different. To show characters correctly in backing-store order, the independent forms of the characters are used, but the display order of these same characters in
Figure 15-2 shows the normal Arabic contextual forms. See the Worldwide Software
Overview chapter in this volume for more about contextual forms in scripts.

eae
©
Pe
=
-_-

» 15d (Arabic)
sg Gy

Q

~

0

Figure 15-3. The backing-store order

Mixed-Directional Text

15-5

Inside Macintosh,

Volume VI

If the first character in backing-store order is Arabic and the line direction is right to left, then

this character is displayed on screen as the rightmost character on the line. The converse is
also true: if the first character in backing-store order is Roman and the line direction is left to
right, then this character is displayed on screen as the leftmost character on the line.

Figure 15-4 shows that style runs on a line are grouped into script runs, and the order of both
style runs and script runs is determined by the direction run of the script. Therefore, whenever
your application calls any TextEdit routine that requires line adjustment or redrawing, testing for
mouse-down events, or measuring of mixed-directional text (for example, TEDelete, TEInsert,

or TEDoText), TextEdit arranges the style runs so that they can be displayed in display order—
not in backing-store order. It uses the Script Manager procedure GetFormatOrder to order the
style runs for a line.
Direction

—_p

run

Script
u

Style
run

Roman

|<

Japanese

Arabic

Hebrew

Times|Helvetica| Times}

Kyoto | Osaka

|Osaka|

Baghdad |

Kufi

Tel Aviv | Haifa

10

10

12

10

12

10

Italic
12

Italic
10

Figure 15-4.

10

Bold

Bold

14

Different levels of runs in a line of text

Read the following sections to find out how TextEdit
m highlights characters in mixed-directional text
= defines mouse-down event regions in mixed-directional text
= displays dual carets to mark insertion points at direction boundaries
m provides cursor movement across direction boundaries

Highlighting
TextEdit highlights a group of characters that is contiguous in memory (backing-store order).
However, the highlighted text may appear discontinuous on the display line if the selection
contains mixed-directional text, as shown in Figure 15-5. This is because TextEdit draws
characters in display order, which may be different from backing-store order. The caret
positions are also determined similarly. The display order is determined by the ordering of the
characters within a direction run and the ordering of direction runs in the primary line direction.
Character offsets are byte offsets of the characters in the text buffer, and the values of
character offsets correspond to the backing-store order of characters. A caret position is a

15-6

Mixed-Directional Text

TextEdit

=<

Primary line direction = right to left (TESysJust = —1)

16

15

1413

16

15 1413

12

6

7

8

9

10

6

7

8

910

11

0 — Primary caret position

11 12

0—

Secondary
caret position

Figure 15-5. Discontinuous highlighting display
location on the screen corresponding to a leading or trailing edge of a displayed character. In
mixed-directional text, one character offset may correspond to two caret positions, and one
caret position may correspond to two character offsets.
These ambiguous cases occur at direction boundaries because the character offset is
associated with two different characters—the one before and the one after the offset. When
these characters are not adjacent in the display, two caret positions result. The primary
caret position is the screen location associated with the character that has the same
direction as the primary line direction. The secondary caret position is the screen
location associated with the character that has a different direction from the primary line
direction. TextEdit uses only the primary caret positions in determining which characters
are highlighted.
In Figures 15-5 and 15-6, you can see how the primary and secondary caret positions differ
at direction boundaries 4 and 12. In Figure 15-6, you can see the relationship between the
character offsets and the primary and secondary caret positions. Figure 15-6 illustrates how
TextEdit uses primary caret positions to define highlighting boundaries for the highlighting of
characters 2, 3, 4, and 5. The shaded regions indicate the highlighted characters. To highlight
characters 2 and 3, TextEdit inverts the entire area between primary caret positions 2 and 4.
To highlight characters 4 and 5, it inverts the entire area between primary caret positions 12
and 6.
Primary line direction = right to left

~<

18
pepo

15 1419
15.»

is

125

ef

114.48)12 4fw Sim
|

a

ot

\

4\_

|

it

;

6 (27), 8919 (40 111

Me

ee

|

Direction

|

8
ae

—

boundary

eee
‘

|

I

—35

2_1

!

P

0 __ Primary caret

110
|

—____!

|

Character offset
boundaries for
highlighting

position

— Secondary caret
position

= highlighting of characters from

caret position 2 to 6, which are characters 2,3,4, and 5.

Figure 15-6.

Highlighting mixed-directional text

Mixed-Directional Text

15-7

Inside Macintosh,

Volume VI

When a non-Roman script system is installed, TextEdit calls the Script Manager’s HiliteText

procedure and the Char2Pixel function (with a direction value of smHilite) to ascertain which

characters should be highlighted.

TextEdit routines that specifically need highlighting of a selection or that produce highlighting
as a result of their functions include TEActivate, TEClick, TECut, TEDeactivate, TEDelete,

TEDoText, TEInsert, TEPaste, TEReplaceStyle, TESetSelect, TESetStyle, and TEStylInsert.

Mouse-Down

Regions

As noted in the preceding section, a single caret position can correspond to two character
offsets. However, a mouse-down event occurs either to the left or the right of a caret

position. (Consistent with QuickDraw, a screen position is an infinitely thin line; hence, a

mouse-down event cannot occur exactly on a caret position.) The region between the caret
position and the middle of an adjacent character maps unambiguously to a single character
offset. This region is called a mouse-down region.
Figure 15-7 shows how TextEdit determines mouse-down regions and in so doing decides
which character offset the mouse-down event belongs to. In the figure, direction boundaries
(that is, the borders between left-to-right and right-to-left text) are denoted by solid vertical

lines and occur at primary caret positions 12 and 4. (These caret positions are also secondary
caret positions 4 and 12, respectively.)
In the figure, character offset boundaries (the boundaries of mouse-down regions) are shown
by dotted lines. The shaded regions indicate where a mouse-down region does not span a
primary caret position. For example, if a mouse click occurs to the left of the direction
boundary at primary caret position 12, the mouse-down region is defined as within the
leading edge of character 12. However, if a mouse click occurs to the right of primary caret
position 12, the mouse-down region is defined as within the leading edge of character 4.
Primary line direction = right to left

<4

16

151413

~as

a4

|

Shania
offsets

16,

|

Sg

12

se

|

{

'

!

i

iNAI3

5
=

1

esaatiena4d
t
heh
ae
f
1

16

gr

1

6

7

—

8

a

x

|

i

sche
'

2,

egGi

PB
2

I

1

i

i

\

6

7

8

Direction
boundary

positions

15-8

Mixed-Directional Text

91011

|

Caret

Figure 15-7.

..

1

1

4

i

Mouse-down

a

oe

mae

|

|

if

4

|

3
=

|

i

10/11

1

!

12

2

|

gaee nodaP | 3
!

s

ek

*

'

|

fas
1

Thea 12

1

'

3

2

Character offset
boundaries for

mouse down

region specifics

1

!

0—Primary caret
sas

position

!

1

O—Secondary caret
P

osition

TextEdit

Dual

Carets

As noted in “Highlighting” earlier in this chapter, a single character offset can correspond
to two caret positions. In this case, TextEdit draws dual carets, a high caret and a low
caret, each measuring half the line’s height. The high caret is displayed at the primary caret
position for the character offset. The low caret is displayed at the secondary caret position.
When the caret position is unambiguous (for example, not on a direction boundary), the
primary (high) and secondary (low) carets are at the same position, so the user sees one
caret. (The appearance of dual carets may change in the future.)
Figure 15-8 shows the dual caret bordering the Arabic text where the overall line direction
is left to right but the Arabic script run is right to left. In this case, the primary caret is
associated with the English text and the secondary caret is associated with the Arabic text.
Roman keyboard icon
File

Edit

Font

Style

Format

QS
Avant Garde

@

Styled Text

(ai)!

Secondary caret

Figure 15-8.

2)

New York

Garamond

Palatino

Times

[Sela

@

Primary caret

Dual carets in mixed-directional text

When TextEdit pastes multiple styles and script runs into a record, the caret is positioned
after the newly pasted text, and the keyboard script reflects the font of the last character of
the newly pasted text. In Figure 15-9, the keyboard script (that is, the script for keyboard
input) is Roman to reflect the font of the last character of the newly pasted text.
Roman keyboard icon
Edit

Font

Style

Format
Styled

Avant Garde
Garamond

(35>)

Palatino

Bookman

Times

(5+)

Bookman|

Newly pasted text

Figure

15-9.

Pasting

New York

lo} [S [4

File

Caret

styled text

Mixed-Directional Text

15-9

Inside Macintosh, Volume VI

In Figure 15-10, drawing A illustrates that when a mouse click occurs to the left of primary
caret position 12, TextEdit places a primary caret at primary caret position 12 and a secondary caret at secondary caret position 4. However, when a mouse click occurs to the right of
primary caret position 12, TextEdit places a primary caret in primary caret position 4 and a
secondary caret in secondary caret position 12, as shown in drawing B in Figure 15-10.
Note: There is a relationship between the keyboard icon and the dual caret. The
setting of the keyboard script is reflected by the keyboard icon. In this case, the primary line direction is right to left, so if the Roman keyboard icon is displayed, text
is entered at the secondary caret position. If an Arabic keyboard icon is displayed,
text is entered at the primary caret position.
Primary line direction = right to left

<4

16

151413

a

125

6

7 8

91011 4

3

21

0

tr

:;

— Primary caret

Character
etigghit®
Position
thats | 1.
16 15,1413
12/4, 5 5|h 6 gor |oh
|lt A\r tanialal
tt2}4, 8g tata
271, |
oto

pnt

16

wr

daeenll

13

fo

ho

—

'

a

,

eo

o

'

8 7 8
Direction

Caret

e

1

ere we

\

9 vo\"

Saree

I

\

rn

a

a

oe

12
3 2 1 0
Character offset

—

Secondary

ap
position

caret

mouse down

y
42

|

Drawing A.

Primary caret
125

r

ish4's
/

4

7

4 >
7

11

a3

45
125

T

4

+

1112
114

3

+

3
8
Primary caret

Drawing B.
f

RN

45

'

1112

tf

3

Secondary caret

Figure 15-10.

15-10

Secondary caret

| Mixed-Directional Text

Dual carets at a direction boundary

TextEdit

Caret

Movement

Across

Direction

Boundaries

When a user presses the arrow keys to move the caret left or right across characters on a line,
TextEdit moves the caret uniformly in the direction of the arrow. This sequence is unambiguous when a user moves the caret in the middle of a style run. However, on direction
boundaries, only the primary caret moves uniformly in the direction of the arrows.
Figure 15-11 shows a sequence of two Right Arrow key presses and their impact on caret
display and movement in a mixed-directional line. If the original caret position is 13 and the
Right Arrow key is pressed, TextEdit displays a dual caret at primary caret position 12 and
secondary caret position 4, with the primary caret moving to the next position in the direction
of the arrow. If the Right Arrow key is pressed again, the new caret position is at primary
caret position 5.
Note: TextEdit currently deviates from this model for caret movement in unstyled
left-to-right text (displayed in a non-Roman font) on any right-to-left script system.
On the Arabic Script System, for example, it is possible to display Roman characters
from an Arabic font. If a user presses the arrow keys to move through these characters, the caret moves in the opposite direction of the arrow. Because of keyboard and
font synchronization, this situation is not common.
Primary line direction = right to left

<q

16

15 1413
'

|

|

!

!

!

I

i

|

1

|

!

|

i

<—

12 5
qT

Es

AND

T

<j

3.

16

15 14138
qT

|

T

|

|

|

1

|

|

i

1

!

|

i

|

ot

i

|

|

I

|

i

\

4

Original caret
position

Figure 15-11.

1144

I

D |

FONT

>

13125

{
42

>]

'
z

12 5

—

7

Dual caret
positions

New caret
position

Caret movement across a direction boundary

KEYBOARD

SYNCHRONIZATION

It is important to distinguish between two kinds of scripts: the font script and the keyboard
script. The font script is the script that corresponds to the font of the active grafPort (also,
the font used for displaying characters). The keyboard script is the script for keyboard input.
It determines the character input method and the keyboard mapping—that is, what character

Font and Keyboard Synchronization

— 15-11

Inside Macintosh,

Volume VI

codes are produced when a sequence of keys is pressed. The upper half of Figure 15-12
shows an example of font and keyboard synchronization with the user entering the characters
for keisanki when the font script corresponds to the keyboard script, which is Japanese. The
lower half of Figure 15-12 provides an example of the characters that are displayed when the
user enters the same characters when the font script does not map to the keyboard script.
Keyboard script
(Japanese)

eae

aes

tl

Ld led

| ipa

a

Resulting character codes
$8C $76 $8E $5A $8B $40

Font script
Japanese

>

or |—>
;

==
_

a

Keyboard script
(Japanese)
= mt i fh

ea

EE

——

Input
Resulting character codes
$8C $76 $8E $5A $8B $40

Font script (Roman)

that does not correspond
to input keyboard script

>

Display

—

|——® {véZa@

Figure 15-12. Font and keyboard script synchronization
TextEdit incorporates the following concepts for styled text:
a If your application calls TEClick, TESetSelect, or TESetStyle to change the font style
or to process a mouse-down event in text as either an insertion point or a selection,
TextEdit alters the keyboard script to correspond to the font script. This means, for
example, that if users type Arabic text followed by Roman text and click in the Arabic
text, the keyboard changes to Arabic without their changing the keyboard manually.
Similarly, if users click in the Roman text, the keyboard changes to Roman without
their altering the keyboard.

15-12.

Font and Keyboard Synchronization

TextEdit

a

If the selection point is not empty (that is, the value of the selStart field of the edit
record, defined by the TERec data type, does not equal the value of the selEnd field),
then TextEdit uses the font corresponding to the selStart field to alter the keyboard
script. When a selection point falls on a script boundary, the keyboard is synchronized
to the font of the character preceding the boundary (in backing-store order).

w

If your application calls TEKey to input a character and if the keyboard script is different
from the font script at the selection point, the font script changes to correspond to the
keyboard script. If a font was selected and never used, thus remaining in TextEdit’s
style scrap record (defined by the StScrpRec data type), and if the font script coincides
with the keyboard script, then this font is used. Otherwise, TextEdit searches through
the preceding fonts in the style run table until it locates a font that corresponds to the
keyboard. If one does not exist, then it uses the application font.

w

If the font script at the selection point is the same as the keyboard script, then this
font is used.

Note: There is one exception to this behavior: when the insertion point has been
placed in Roman characters from a non-Roman font, the keyboard script is Roman,
and the font and the keyboard remain unsynchronized to allow the user to enter more
Roman characters in the non-Roman font.
If your application uses styled TextEdit and allows users to select fonts, TextEdit displays
text correctly in all scripts. Otherwise, your application should use the application font as
the best default for TextEdit.

DOUBLE-BYTE

CHARACTERS

The internal buffer used for a double-byte character is unique to each edit record. Therefore,
if TextEdit buffers the first byte of a double-byte character in a record and then the TEKey
procedure is called on another record, the byte remains in the original buffer until TEKey
processes another byte for that edit record.
When the TEKey procedure is called by a Right Arrow, Left Arrow, or Backspace keyboard
event at a double-byte character, then the selection range is updated beyond the second byte in
order for the caret to move once over the entire character. TextEdit also depends on the Script
Manager routines to handle double-byte characters correctly with mouse-down events, caret
display, highlighting, and other text-processing functions.

Double-Byte Characters

— 15-13

ST

TextEdit takes advantage of the Script Manager’s handling of double-byte characters so that
they can be displayed with improved accuracy and consistency. If a double-byte character,
such as a Kanji character, is typed, the first byte is buffered by TextEdit until the second byte
is processed, at which time the character is displayed.

ne

a")
ms
_

o.

—e

mal

Inside Macintosh,

VERTICAL

Volume VI

MOVEMENT

OF

THE

CARET

When TEKey is called for an Up Arrow keyboard event, the caret moves up by one line each
time the user presses the Up Arrow key, even in lines of text containing fonts of different
sizes. Prior to this version of TextEdit, the caret occasionally skipped a line because it moved
up by the height of the largest font on the current line.
If the line height of the current line is greater than the line height of the succeeding line and
if the caret is positioned at the end of the line, a Down Arrow event places the caret on the
next line. In system software earlier than this version of TextEdit, the caret remained on the
current line.
If the current line corresponds to the first line in the edit record and if TEKey processes an
Up Arrow event, the new caret position is at the beginning of the text on the first line, at
primary caret position 0. This position corresponds to the visible right end of a line when the
primary line direction is right to left and to the left end of a line when the primary line
direction is left to right.

ARROW

KEY

ACTIONS

FOR

SELECTED

TEXT

If a region of text is selected (that is, the selStart field of the edit record does not equal the
selEnd field) and a user presses either the Up Arrow or Down Arrow key, the caret moves
from the beginning of the selected region (or the selStart position). If the user presses the
Right Arrow key, the caret appears one character to the right from the end of the highlighted
region, and if the user presses the Left Arrow key, the caret appears one character to the left
from the beginning of the selected text.

CARET

POSITION

AT

LINE

ENDS

Prior to this version of TextEdit, if spaces at the end of a line extended beyond the edge of the
view rectangle, TextEdit drew the caret outside the view rectangle. This effect depended on
the combination of line direction (TESysJust) and line alignment (teJust).

TextEdit no longer draws the caret outside the view rectangle. The caret is always drawn at
the line end (that is, at the edge of the view rectangle) even when spaces extend beyond the
edge of the view rectangle.
When TextEdit determines that a new position for the caret is at the start or end of a line,
the line where the caret is displayed depends on the current caret position and the value in
the clikStuff field in the edit record. TextEdit sets this field to reflect whether the most recent

15-14

Caret Position at Line Ends

TextEdit

mouse-down event occurred on the leading or trailing edge of a character. If the last mousedown event was on the leading edge of a character, the new caret position is at the line
end that corresponds to the leading edge of the new character offset. For example, in
Figure 15-13, if the new caret position is at character offset 3, then the caret appears at the
end of the first line if the last mouse-down event was on the trailing edge of a character.
This corresponds to a leading edge (clikStuff) value of FALSE. Otherwise, the caret appears
at the beginning of the second line.
Primary line direction = left to right
Direction run

0 o:1

>

1 : 2)\2 {3 —Character offsets

FIT‘ FIT‘ F | T ' E\|—clikStuff value = leading edge value

34/4 :5|5:5 6|—Character offsets

T: F| T:F|T:F| —clikStuff value = leading edge value

Figure 15-13. The caret position at line end

WORD

SELECTION

AND

LINE

BREAKS

Because TextEdit depends on the Script Manager’s FindWord procedure, TextEdit’s definition of a word has been extended. Prior to this version, TextEdit used its own FindWord
procedure to determine word selection and line breaks. It now relies on the Script Manager’s FindWord procedure for word selection on all systems and also relies on the Script
Manager’s FindWord and StyledLineBreak routines for line breaking on systems with more
than one script system installed.
The way TextEdit uses FindWord to calculate word breaks has a significant impact on word
selection. For example, on a Roman-only system that is localized for the United States,
parentheses and other punctuation marks are no longer included as part of a word selection.
However, this behavior may vary on other localized versions of a Roman system due to the
localizability of the Script Manager’s FindWord procedure. Furthermore, when a user
double-clicks a series of spaces, that series of spaces is selected as a word. (Prior to this
version of TextEdit, single spaces were selected as a word.)

Using TextEdit

15-15

Inside Macintosh,

Volume V1

Figure 15-14 illustrates how double-clicking the word Apple selects only the word Apple,
and not the enclosing parentheses. In the figure, the arrows point to the word breaks.

cat

(Apple)

lene
Figure 15-14.

dog

Word breaks for word selection

For backward compatibility, system software with only the Roman Script System installed
still breaks lines at spaces. On systems with another script system installed, TextEdit calls the
Script Manager’s FindWord and StyledLineBreak routines for line breaking. Lines then break
correctly when a hyphenated word is at the end of a line, as shown in Figure 15-15. This
change is noticeable if you compare a line break on a computer using system software with
only the Roman Script System installed to the same line on a computer with more than one
script system installed.

TextEdit handles line breaks with hyphenated words, such as reiterate.

|
S

Figure 15-15. A line break with multiple scripts installed

ACCURATE

LINE

MEASUREMENT

TextEdit measures a line accurately by removing any trailing white space from the end of the
line and taking the line direction into account. It uses the Script Manager’s VisibleLength
function to exclude trailing white space that occurs on the right side of the display line for a
script system with a left-to-right line direction (TESysJust = 0) and with flush-right alignment
(teJust = teJustRight or teFlushRight). It also uses VisibleLength if the text alignment is flush
left (teJust

= teForceLeft or teFlushLeft ) regardless of the line direction.

Note: An anomaly exists in the way TextEdit draws at line ends. When the primary
line direction of a script system is right to left (for instance, on an Arabic system),
when the alignment is teFlushLeft or teCenter, and when spaces are being entered in a
right-to-left font, TextEdit measures spaces at the end of the line and thus may draw
the text beyond the right edge of the view rectangle. The caret, however, remains in
view and is pinned to the left edge of the view rectangle.
This anomaly also exists when the primary line direction of a script system is left to
right and the alignment is teCenter. In this instance, TextEdit measures spaces at the
end of the line. As more spaces are added (and, thus measured), the visible text in the
line is drawn out of view beyond the left edge of the view rectangle. The caret,
however, remains in view and is pinned to the right edge of the view rectangle.
15-16

Accurate Line Measurement

TextEdit

TEXTEDIT

AND

TRUETYPE

FONTS

If your application is using a TrueType™ font, the default behavior of the Font Manager is to
ensure that glyphs fit within the font’s ascent and descent. Glyphs that extend beyond the
ascent or descent, such as certain accented fonts, are scaled down to fit. If your application has
set the preserveGlyph parameter of the SetPreserveGlyph procedure to TRUE to preserve the
original unscaled shape of the glyph, TextEdit sets it to FALSE before it calls DRAWHook to
perform any drawing. This is to guarantee that the glyphs whose bounding boxes exceed the
font’s ascent or descent are scaled down to prevent them from colliding with other glyphs on
the lines above or below. TextEdit then restores the preserveGlyph parameter to its previous
value before proceeding. See “Preserving the Glyph’s Shape” in the Font Manager chapter for
further discussion of glyph preservation. See “Replacing the Drawing Routine” later in this
chapter for details on DRAWHook.

USING

TEXTEDIT

This section provides a variety of information on using this version of TextEdit. It discusses
how to determine the version of TextEdit that you are using and describes three new hooks
that provide a way to replace TextEdit’s dependency on the Script Manager for word breaking
and measuring. This section also discusses several additional TextEdit features available
through a new function, TEFeatureFlag. Finally, it updates and clarifies the use of several
previously documented TextEdit routines and their effects.

Determining

the Version

of TextEdit

{constants
gestaltTE1

I}

CONST

bh

You can determine the version of TextEdit using the Gestalt selector gestaltTextEditVersion.
When you call Gestalt with this selector, the result returned in the response parameter identifies
the current version of TextEdit. If the Gestalt function returns the gestaltUndefSelectorErr
result code, an earlier version of TextEdit without Script Manager compatibility is installed.
for Gestalt
1%
{U.S.

{
gestaltTE2

=

2;

=

3;

TextEdit

on

a

version

Macintosh

6.0.4

containing

}

IIci}

a

{version
6.0.4
non-Roman
script
system containing
{ a Script
Manager-compatible
version
of
}

{
{
gestaltTE3

function}
system
software

TextEdit including
nWIDTHHook for the

{version

6.0.4

the new measuring
Macintosh
IIci}

non-Roman

script

system

{
{

a Script
TextEdit

{
{

nWIDTHHook
for Macintosh
Plus,
Macintosh
SE,
Macintosh
SE/30,

{

Macintosh

II,

1

Macintosh

IIx,

hook

or

—

=

2.

ae

}

}

Portable,

Macintosh

id
ae
@
ms

}

containing

Manager-compatible
version
of
}
including
the new measuring
hook

Macintosh

}

}

IIcx}

Using TextEdit

15-17

}

_

Inside Macintosh,

Volume VI

gestaltTE4

=

4;

5;

{system

software

{

which

contain

{

version

{

hook

{

text-buffering

of

versions
a

TextEdit

nWIDTHHook

6.0.5

Script
&

including
the

features,

Manager-compatible

&

two

version

on

{

including

new

TextWidthHook,

buffering,

new

capability

to

7.0,

outline
features

the
any

}

new

}

measuring
&

}

a

}

version
hooks,

contains
of

TextEdit

highlighting,
for

inline

inline

input}

text

input,

&

or greater.

The outline-highlighting and text-buffering features of TextEdit, included with the new
function TEFeatureFlag, are available if the returned value is gestaltTE4 or greater. Outline
highlighting, text buffering, new features for inline input, and the capability to disable inline
input, included with the new function TEFeatureFlag, are available if the returned value is
gestaltTES or greater.
The new measuring hook TextWidthHook is available if the returned value is gestaltTES

or greater.

For more on the TEFeatureFlag function, see “Outline Highlighting, Text Buffering, and
Inline Input” later in this chapter. For more on TextEdit’s width measuring hooks, see

“Replacing the Measuring Routines” later in this chapter.

Features

To customize TextEdit’s capabilities to the specifications of your own application, you can
replace some of TextEdit’s routines with routines of your own that accomplish the same
function. To allow you to do this, TextEdit supplies hooks, fields in which you can store
the address to a routine if you require different behavior from that provided by TextEdit.
Normally, you use TextEdit’s standard or default routines whose addresses are contained
in these fields in the edit record. To override these routines, you can place the address of

your hook routine in the appropriate field by using the TECustomHook procedure. See
“Customizing TextEdit” later in this chapter for details.
A

Warning: If you use any of the TextEdit hooks to override default TextEdit
behavior, the results may no longer be Script Manager—compatible. You must
determine whether more than one script system is installed before replacing
TextEdit’s routines with an alternate routine.
Also, before placing the address of your routine in the TextEdit dispatch record
(defined by the TEDispatchRec data type), you should strip the addresses using
the Operating System Utilities StripAddress function to guarantee that your
application is 32-bit clean. a

15-18

Using TextEdit

}
}

TextEdit contains the new measuring hook nWIDTHHook if the returned value is gestal(TE2

TextEdit’s

}

nWIDTHHook

TextEdit is Script Manager—compatible if the returned value is gestaltTE2 or greater.

Customizing

}

Macintosh}

which

measuring

disable

later,

outline-highlighting

software

Script

and

Manager-compatible

{system
SD Oe
SPAN

gestaltTE5

=

}

TextEdit

Measuring the Width of Components

of a Line

Earlier versions of TextEdit used the hook WIDTHHook any time the width of various
components of a line was measured. TextEdit now uses three hooks—nWIDTHHook,
TextWidthHook, and WIDTHHook—to measure the width of various components of a
line. The hook nWIDTHHook lets you replace TextEdit’s new measuring routine for nonRoman script systems. TextWidthHook allows you to replace all the new calls to the
QuickDraw TextWidth function in TextEdit with your own measuring routine. WIDTHHook
retains its original measuring function to provide backward compatibility for your applications. See “Replacing the Measuring Routines” later in this chapter for details.

Defining

Word

Boundaries

TextEdit provides a higher-level hook, TEFindWord, that allows you to customize word
breaking. TextEdit now disregards the wordBreak hook on non-Roman script systems and
only uses it on system software with only the Roman Script System installed if an application
has supplied an alternate routine in the hook. See “Replacing the Word Breaking Routine”
later in this chapter for details.

Controlling

Outline

and

Input

Inline

Highlighting, Text

Buffering,

TextEdit provides outline highlighting for inactive text. This highlighting is similar to the
behavior of MPW® selections. TextEdit also supplies text buffering for performance
improve-ments. Finally, support for inline input for double-byte script systems is provided
with TextEdit. This support includes several new features for inline input and the capability to
disable inline input. All these features are controlled with the TEFeatureFlag function. See
“Outline Highlighting, Text Buffering, and Inline Input” later in this chapter for details.

Left Alignment for Right-to-Left

Directional

Scripts

Prior to this version of TextEdit, the TESetJust procedure provided three possible choices for
alignment in its just parameter: the constants teJustLeft (0), teJustCenter (1), and teJustRight
(—1). These choices are appropriate for script systems that are read from left to right. However, in script systems that are read from right to left, text is incorrectly displayed as left
aligned in dialog boxes and in other areas of applications where users cannot explicitly set
the alignment.
An additional constant for the just parameter to the TESetJust procedure allows you to specify
left alignment if the primary line direction is right to left (that is, TESysJust = —1). This value
for the just parameter is teForceLeft (—2).
The behavior of the constant teJustLeft makes alignment occur in the primary line direction
specified by TESysJust. Therefore, if you use teJustLeft when the line direction is right to
left, right alignment takes place as it does when you use the value teJustRight.
If your application does not allow the user to change the alignment, then it should use
teJustLeft; if it does allow the user to change the alignment, then it should use teForceLeft
for left alignment.
Using TextEdit

15-19

ST

Setting

oe

@
~*~
—

co)

eS

en

eel

a

Inside Macintosh,

Volume VI

Note: TextEdit does not support fully justified alignment. The Script Manager
supplies routines you can use to provide support for justified text in your
applications. See the Worldwide Software Overview chapter earlier in this volume
for details.
Because of the conflict between the names of the just parameter’s constants and their effects

within TextEdit, new names have been provided as shown in Table 15-1.

Table

15-1.

New

constant

teFlushRight
teFlushLeft
teCenter
teFlushDefault

Using

Constants for the just parameter of TESetJust
Old

constant

Value

teJustRight
teForceLeft
teJustCenter
teJustLeft

WordRedraw

—|
—2

|
0

Description
Flush right for all scripts
Flush left for all scripts
Centered for all scripts
Flush according to line direction

for Line Calculations

WordRedraw is a low-memory global variable used in TextEdit for line calculations after the
user types in a character. TextEdit sets the correct value for WordRedraw in TEInit based
upon the installed script systems. If a double-byte script is installed, TEInit performs an OR
operation on WordRedraw with a 1; if a right-to-left script is installed, TEInit performs an
OR operation on WordRedraw with an $FF. The size of this global is | byte.
TextEdit interprets the final value of WordRedraw as follows:
Value

Description

0

Redraws the character before the entered character.

l

Redraws the word before the entered character.

$FF

Redraws the whole line.

Using the lineStarts Array to Determine

Line Length

The lineStarts array is a field in the edit record that contains the offset position of the first
character of each line. This array has the following boundary conditions:
m The first entry has index 0 and value 0.
m The last entry in the array has index nLines and value teLength (hence, there are
nLines + | entries).

15-20

Using TextEdit

TextEdit

a The beginning of the first line is given by lineStarts[0], and the beginning of the
second line is given by lineStarts[1]; hence, the length of the first line is given by
lineStarts[ 1] — lineStarts[0].

a The maximum number of entries is 16,000.
To determine the length of a line, you can use the information contained in the lineStarts array
and the nLines field. For example, if you want to determine the length of the line n (where
n=O
for the first line), subtract its start location (contained in the array entry with index n)
from its end location (contained in the array with index n + 1):
lengthOfLineN

:=

myTE**.lineStarts[n+1]

-

myTE**.lineStarts[n];

The terminating condition for this measurement is when 7 is equal to nLines plus 1.
It is important not to change the information contained in the lineStarts array.

Using

TextEdit’s

Default

Click

Procedure

TextEdit’s default click procedure for automatic scrolling (which can be replaced using
the clikLoop hook) depends on the value in the clickTime field in the edit record. When
TextEdit’s click procedure, TEClick, is called, clickTime contains the time when the
TEClick procedure was last called. TextEdit now adjusts the value in clickTime within
its default click procedure to allow slower scrolling to occur.
If you modify this value inside your own click procedure, be aware that TextEdit resets it to
the current tick count upon exit from the TEClick procedure and uses the new value at reentry
when TEClick is subsequently called.

ROUTINES

This section describes in detail the new function TEFeatureFlag and four other routines
new with system software version 6.0: TECustomHook, TEContinuousStyle, SetStylScrap,
and TENumStyles. Three new hooks are described: nWIDTHHook and TextWidthHook,
accessed through the TECustomHook procedure, and the low-memory TEFindWord hook.
Finally, this section includes updated information on several existing TextEdit routines,
including TEKey, TEGetPoint, and TESetStyle.

SI

TEXTEDIT

=
Ps,
ai
Ga)
o.

=

Assembly-language note: The TextEdit routines TEContinuousStyle,
TESetStylScrap, TENumStyles, TECustomHook, and the new TextEdit
function TEFeatureFlag, which are described in this section, are called by
using the TEDispatch trap macro. See “Summary of TextEdit” at the end
of this chapter for a list of the decimal selectors for these routines.

TextEdit Routines

15-2]

Inside Macintosh,

Outline

Volume VI

Highlighting, Text Buffering,

and

Inline Input

The TEFeatureFlag function allows you to enable outline highlighting and text buffering in
your application. You can also use this function to disable inline input in a particular edit
record and to enable several new features that have been provided so that inline input works
correctly with TextEdit.
Note: To test for the availability of these features, you can call the Gestalt function
with the gestaltTextEditVersion selector. A result of gestaltTE4 or greater returned in
the response parameter indicates that outline highlighting and text buffering are available. A result of gestaltTES or greater returned in the response parameter indicates that
the two inline input features are available. (For details, see “Determining the Version
of TextEdit” earlier in this chapter.)

The inline input features are also available on version 6.0.7 systems with nonRoman script systems installed. However, there is no Gestalt constant that indicates
this availability.
FUNCTION

TEFeatureFlag

(feature:
hTE:

Integer;

TEHandle)

:

action:

Integer;

Integer;

The feature parameter allows you to disable inline input in a particular edit record or to
specify the features you want to enable—outline highlighting, text buffering, and features
provided for inline input in TextEdit. The action parameter lets you enable and disable these
features by using the TEBitSet and TEBitClear constants and lets you test the settings of
these feature bits by using the TEBitTest constant. The hTE parameter is a handle to the
edit record.

The TEFeatureFlag function returns the previous setting of the feature’s bit, either TEBitSet
or TEBitClear.
CONST

{constants

for

parameter

values}

=

de

teFOutlineHilite

=

2 .

{outline

highlighting}

teFInlineInput

s

33

{inline

input

teFUseTextServices

=

&;

{use

{constants

for

TEBitClear
TEBitSet
TEBitTest

15-22

feature

teFText Buffering

TextEdit Routines

action

{text
‘

parameter
se
=
=

he
<4;
=15

buffering}

inline

features}
input

service}

values}
{clear TEFeatureFlag
features}
{set
TEFeatureFlag
features}
{test
TEFeatureFlag
features}

TextEdit

Outline

Highlighting

Use the teFOutlineHilite constant in the feature parameter of TEFeatureFlag to enable outline
highlighting. If a highlighted region exists in an edit record in an inactive window, then the
highlighted region is outlined (or framed) when the window is in the background, a behavior
similar to MPW selections. If the caret is in the window and the window is no longer active,
the caret is then drawn in a gray pattern so that it appears dimmed. To do the framing and caret
dimming, TextEdit temporarily replaces the current address in the highHook and caretHook
fields of the edit record, redraws the caret or highlighted region, and then immediately restores
the hooks to their previous addresses.

Text

Buffering

Use the teFTextBuffering constant in the feature parameter of TEFeatureFlag to perform text
buffering. Text buffering can be enabled for performance improvements, especially with
double-byte scripts. TextEdit buffers each TEKey input of a graphic character. The entire
buffer will then be inserted at one time if any TextEdit routine is called other than TEKey for
another graphic character. This includes any routines that handle a mouse-down event, a style
change, font and keyboard synchronization, the input of a nongraphic character, or a call to
the TEIdle procedure. The buffer is dumped before this routine is handled.
A

Warning: This buffer is a global buffer (and differs from TEKey’s internal
double-byte buffer) and is used across all active edit records. These records may
be in a single application or in multiple applications. Exercise care when you
enable TEFeatureFlag’s text-buffering capability in more than one active record;
otherwise, the bytes that are buffered from one edit record may appear in another
edit record. You also need to be sure that buffering is not turned off in the middle
of processing a double-byte character.
To guarantee the integrity of your record, it is important that you wait for an idle
event before you disable buffering or enable buffering in a second edit record. a

If text buffering is enabled on a non-Roman script system and the keyboard has changed,
TextEdit flushes the text of the current script from the buffer before buffering characters in
the new script.

ST

Note: If the text-buffering feature teFTextBuffering is enabled, your application
must ensure that TEIdle is called before any pause of more than a few ticks—for
example, before WaitNextEvent. A possibility of a long delay before characters
appear on the screen exists—especially in non-Roman systems. If you do not call
TEldle, the characters may end up in the edit record of another application.

—

<>)
—_

tj
Qu

tel

a

TextEdit Routines

15-23

,

3

A

Inside Macintosh,

Volume VI

Inline Input
If your application follows the guidelines for inline input available from Macintosh Developer
Technical Support, then you should set the new flag useTextEditServices in the 'SIZE'
resource in your application. (For details on the 'SIZE' resource, see the Event Manager
chapter in this volume.) This allows inline input to work with your application. Inline input
is a keyboard input method (often used for double-byte script systems) in which conversion
from a phonetic to an ideographic representation of a character takes place at the current line
position where the text is intended to appear. This allows the user to type text directly in the
line as opposed to a special conversion window. If inline input is installed and the
useTextEditServices flag in the 'SIZE' resource is set, inline input sets TextEdit’s
teFUseTextServices feature bit whenever an edit record is created. This bit is not used by
TextEdit.
Inline input checks the teFUseTextServices bit during text editing to determine if an inline
session should begin. If you want to disable inline input for a particular edit record, your
application can clear this bit after the edit record is created. You can also clear this bit to
disable inline input temporarily and then restore it, but the edit record should always be
deactivated before the state of the bit is changed.
In the future, other text services may use this same mechanism. If you follow the guidelines
specified here, your application should also work with future text services.
Note: You must deactivate an edit record before changing the state of the feature bits
or any fields in the edit record.
When an inline edit session begins, inline input also sets the teFInlineInput bit to provide the
following features so that inline input will work correctly with TextEdit:
m disabling font and keyboard synchronization
= forcing a multiple-line selection to be highlighted line by line using a separate rectangle
for each line rather than using a minimum number of rectangles for optimization
a highlighting a line only to the edge of the text rather than beyond the text to the edge of
the view rectangle
The teFInlineInput bit is cleared by inline input when an inline session ends. Use the
teFInlineInput constant in the feature parameter of TEFeatureFlag to include these features
in your application even when inline input is not installed. Be careful about changing the
state of this bit if the teFUseTextServices bit is set. Again, the edit record should always be
deactivated before the state of the teFInlineInput bit is changed.
A

15-24

Warning: If you clear the teFUseTextServices bit and you set the
teFInlineInput bit, inline input is disabled, but your application retains
the features listed above. a

TextEdit Routines

TextEdit

Customizing

TextEdit

The TECustomHook procedure lets your application customize the features of TextEdit by
setting the TextEdit hooks.
PROCEDURE

TECustomHook

(which:
hTE:

TEIntHook;

VAR

addr:

ProcPtr;

TEHandle) ;

The which parameter specifies which hook to replace. The values for the which parameter are
CONST

intZOLHook

=O

{end-of-line

intDrawHook

S

ay

{drawing

intWidthHook
intHitTestHook

=
=

2
34

{width measurement
{hit test hook}

intNWidthHook

=,

ag

{new
{

intTextWidthHook

=

width

hook}

measurement

hook

}

hook

}

nWIDTHHook}

{new
{

hook}

hook}

width

measurement

TextWidthHook}

You specify your customized hook in the addr parameter. When TECustomHook returns, the
addr parameter contains the address of the previous hook specified by the which parameter.
This address is returned so that hooks can be daisy-chained. The two new hooks,
nWIDTHHook and TextWidthHook, specified by the intNWidthHook and intTextWidthHook
constants, are described in “Replacing the Measuring Routines” later in this chapter.
Two integer fields of the edit record, not used for their original purposes but still named
recalBack and recalLines, combine to hold a handle to the TextEdit dispatch record, which
contains a list of TextEdit hooks. (See Figure 15-20 for an illustration of the edit record, the
dispatch record, and all the TextEdit data structures.) Each edit record has its own set of such
routines to provide for maximum flexibility. You should always use the TECustomHook
procedure to change these hooks instead of modifying the edit record directly.
A

Warning: Do not simply copy the recalBack and recalLines fields to another edit
record. If you do, a duplicate handle to the initial TextEdit dispatch record is
stored in recalBack and recalLines in your copy of the record. When one of the
edit records is disposed, the handle stored in the copy becomes invalid, and
TextEdit can crash if the copy is used. a

EOLHook, WIDTHHook, nWIDTHHook,

TextWidthHook, DRAWHook,

and

HITTESTHook are fields into the TextEdit dispatch record and are described in the
next sections.
Note: When you replace these hooks, note that all registers except those specified as
containing return values must be preserved. Registers A3 and A4 contain a pointer
and a handle, respectively, to the edit record. You can obtain line start positions from
the lineStarts array in the edit record. A5 is always valid.

TextEdit Routines

15-25

Inside Macintosh,

Volume VI

Note: The TextBox procedure only uses these hooks when it needs to allocate an
edit record.

Replacing

the End-of-Line

Routine

The EOLHook field contains the address of a routine that tests a given character to determine
whether it is an end-of-line character and returns with the appropriate status flags set in the
status register. The default action is to merely compare the character with $0D (a carriage
return) and return.

Assembly-language note: For EOLHook, the registers are set at entry as
specified, and TextEdit depends on the registers being set at exit as specified:
On entry

DO:

On exit

Z flag in the status register clear if
end-of-line character; set otherwise

Replacing

A3:
Ad:

the

— character to compare (byte)

pointer to the edit record (long)
locked handle to the edit record (long)

Measuring

Routines

TextEdit’s width hooks are called each the time the width of various components of a line is
calculated. This section describes two new hooks, nWIDTHHook and TextWidthHook, and
their relationships with the original WIDTHHook hook. The new hook nWIDTHHook
allows you access to TextEdit’s measuring routine for non-Roman script systems and
provides a way for you to replace this routine with your own script-compatible measuring
routine. TextWidthHook provides a way for you to replace the new calls to the TextWidth

function in TextEdit with your own measuring routine.

Note: To test for the availability of the new width-measuring hooks, you can call

the Gestalt function with the gestaltTextEditVersion selector. A result of gestaltTE2

or greater returned in the response parameter indicates that the new width measurement hook nWIDTHHook is available. A result of gestaltTE5 or greater returned
in the response parameter indicates that the new text width measurement hook
TextWidthHook is available. (For details, see “Determining the Version of TextEdit”
earlier in this chapter.)
TextWidthHook is available for version 6.0.7 systems with non-Roman script
systems installed. However, there is no Gestalt constant that indicates this
availability.
The original WIDTHHook hook is available to provide backward compatibility for your
applications. TextEdit still uses WIDTHHook; however, it now performs additional checks to
determine whether to use WIDTHHook or nWIDTHHook. TextEdit first determines whether
a non-Roman script system is installed. If it is, TextEdit uses the new nWIDTHHook routine
even if an application has overridden WIDTHHook with a different measuring routine. If
15-26

TextEdit Routines

TextEdit

TextEdit finds that only the Roman Script System is installed, it checks to see if

WIDTHHook contains the address of TextEdit’s default routine for measuring. If it does,

TextEdit uses the nWIDTHHook routine. Otherwise, an application has provided a different
measuring routine to be used for system software with only the Roman Script System
installed, so TextEdit uses this routine instead of its own default routine.

It is possible for you to provide alternate routines for both of these hooks to guarantee that
your routine is always used. However, unless the routine measures correctly for non-Roman
scripts, you should only replace WIDTHHook and TextWidthHook.
The appropriate font, face, and size characteristics have already been set into the current port
by the time any of these routines is called.
The default action for WIDTHHook is to call the QuickDraw TextWidth function and return.

Assembly-language note: For WIDTHHook, the registers are set at entry
as specified, and TextEdit depends on the registers being set as specified:
Onentry

D0:
D1:

AO:

length (in bytes) of text to measure (word)
first byte of text to measure (word)

pointer to text buffer (long)

A3:
pointer to the edit record (long)
A4: — locked handle to the edit record (long)
On exit

D1:

pixel width of measured text (word)

The default action for nWIDTHHook is to call the Script Manager’s Char2Pixel function
or TextWidth to measure accurately for non-Roman scripts. For more information on
Char2Pixel, see the Worldwide Software Overview chapter in this volume. For comprehensive details, refer to Macintosh Worldwide Development: Guide to System Software.

Assembly-language note: For nWIDTHHook, the registers are set at
entry as specified, and TextEdit depends on the registers being set at exit
as specified:
Onentry

D0:
D1:

overall style run length, bounded by the line end (word)
offset position within style run on the current line (word)

AO:
A2:
A3:

pointer to text buffer (long)
pointer to current line start (from TextEdit’s lineStarts
array) (long)
pointer to the edit record (long)

D1:

pixel width of measured text (word)

D2:

A4:
On exit

—

wn

ae |

slop (low word); direction flag (high word) (long)

i)
SA

_
-

oF

ak:

locked handle to the edit record (long)

For a discussion of the slop value, see the Worldwide Software Overview chapter in
this volume.
TextEdit Routines

15-27

Inside Macintosh,

Volume V1

TextEdit also includes the new TextWidthHook routine that provides a way for you to replace
the new TextWidth calls in TextEdit with your own measuring routine. You must use
TextWidthHook in addition to WIDTHHook and nWIDTHHook to replace TextEdit’s
measuring routines completely.
Note: There is a TextWidth call in the TextBox procedure that does not use this
hook because no edit record is allocated.
The default action for TextWidthHook is to always call the QuickDraw TextWidth function
(the same default action as for the original WIDTHHook

routine).

Assembly-language note: For TextWidthHook, the registers are set at
entry as specified. TextEdit depends on the registers being set at exit as
specified:
Onentry

D0:

offset in text of first byte to measure (word)
pointer to text to measure (long)

A4:

locked handle to the edit record (long)

A3:
On exit

Replacing

length (in bytes) of text to be measured (word)

D1:
AO:

D1:

pointer to the edit record (long)

pixel width of measured text (word)

the Drawing

Routine

TextEdit calls DRAWHook any time the various components of a line are drawn. The
appropriate font, face, and size characteristics have already been set into the current port by
the time this routine is called. If your application is using TrueType fonts, TextEdit has also
set the preserveGlyph parameter of the Font Manager’s SetPreserveGlyph procedure to
FALSE, so your hook may need to reset this parameter if your application depends on it. The
default action of this hook is to call the QuickDraw DrawText procedure and return.

Assembly-language note: For DRAWHook,
as specified:
Onentry

D0:
D1:

offset into text (word)
length of text to draw (word)

the registers are set at entry

AO:
pointer to text to draw (long)
A3:
pointer to the edit record (long)
A4: — locked handle to the edit record (long)

15-28

TextEdit Routines

TextEdit

Replacing

the

Hit Test

Routine

TextEdit calls HITTESTHook to determine the character position in a line, given the pixel
width from the left edge of the view rectangle. The default action is to call the TextWidth
function to determine if the pixel width of the measured text is greater than the input width. If
it is, then HITTESTHook calls the Script Manager’s Pixel2Char function and returns. For
more information on Pixel2Char, refer to the Worldwide Software Overview chapter in this

volume. For comprehensive details, see Macintosh Worldwide Development: Guide to
System Software.

Assembly-language note: For HITTESTHook, the registers are set at
entry as specified, and TextEdit depends on the registers being set at exit
as specified:
Onentry

D0:

length of text block (style run) to measure (word)

Di:

pixel width from start of text block (word)

AO:

pointer to start of text block (long)

DO:

pixel width to character offset in text block (low word);
Boolean = TRUE if a character offset corresponding to the
given pixel width was found (high word)

D2”:

slop (should equal 0) (word)

A3:
pointer to the edit record (long)
A4: — locked handle to the edit record (long)

On exit

D1:

D2:

character offset (word)

Boolean = TRUE if the pixel width falls within the leading

edge of the character (word)

“In earlier versions of TextEdit, the value in this register was not always
used. If you daisy-chain in a routine and then call HITTESTHook, D2
must be 0.

Replacing

the Word

Breaking

Routine

The wordBreak hook (the wordBreak field in the edit record) exists to replace TextEdit’s
word breaking routine. However, unless you include explicit tests for scripts, the algorithms
you provide may be incorrect for non-Roman scripts. To provide better compatibility for your
application, TextEdit

ee!

as)
~

m disregards the wordBreak hook on non-Roman script systems

mc

I

Q

m supplies a higher-level hook, TEFindWord, which allows you to customize TextEdit’s
word breaking

TextEdit Routines

—

9 1

15-29

=

Inside Macintosh,

Volume VI

The TEFindWord hook is at a higher level than the wordBreak hook and replaces TextEdit’s
word breaking routine. This gives your application more control over the breaking process
and allows you to write more efficient routines. However, unless your routine correctly
determines breaks for all scripts, you must be sure to check for non-Roman scripts before
replacing TextEdit’s routine, which calls the Script Manager’s FindWord procedure.
Here’s how the default TEFindWord routine works:

a TextEdit initially determines whether a non-Roman script system is installed. If one is
installed, TextEdit always uses the Script Manager’s FindWord procedure for line
breaking and word selection.
m If TextEdit determines that only the Roman Script System is installed and TEFindWord
is being called for line breaking, it calls the wordBreak hook.
a If TEFindWord is called for word selection for system software with only the Roman
Script System installed, TextEdit checks to see if your application has placed the address
of a different word breaking routine in the wordBreak field of the edit record. If so,

TextEdit calls your word breaking routine. Otherwise, if the wordBreak field contains
the address of TextEdit’s internal word breaking routine, TextEdit uses the Script
Manager’s FindWord procedure to determine word breaks.
The hook TEFindWord is global and supersedes this default behavior. If you prefer to
customize TextEdit, remember to check for non-Roman scripts if you desire to replace the
word breaking code only on the Roman Script System with no other scripts installed. To
check if non-Roman scripts are enabled, use the GetEnvirons function with the smEnabled
verb. See the Worldwide Software Overview chapter for details on GetEnvirons.
If you replace TEFindWord, be careful to set the correct values in the appropriate registers
on exit.

Assembly-language note: For TEFindWord, the registers are set at
entry as specified, and TextEdit depends on the registers being set at exit
as specified:
Onentry

D0:
D2:

A3:

A4:
On exit

15-30

DO:
Dl:

current position (the value of selStart field in edit record)
(word)
identifier of routine that called FindWord (word)

teWordSelect
teWordDrag

EQU
EQU_

4
8

teFromFind

EQU

12

teFromRecal

EQU

16

pointer to the edit record (long)

called for word selection
called for extending word
selection
called for determining new
line breaks
called for word breaking in
line recalculation

— locked handle to the edit record (long)
word start (word)
word end (word)

TextEdit Routines

TextEdit

When TextEdit calls the Script Manager’s FindWord procedure, it uses information in the edit
record to provide the necessary parameters. TextEdit determines the current script boundaries
for the Script Manager’s FindWord routine by using the font-run information in the style
record (defined by the TEStyleRec data type). TextEdit also determines the length of the
script run and the offset within the script run from which to begin searching for a word
boundary. TextEdit uses the value in the clikStuff field of the edit record to determine the
leadingEdge flag for the Script Manager’s FindWord procedure. You must use similar
information to replace TEFindWord correctly for non-Roman scripts. For more information,
see the Worldwide Software Overview chapter in this volume and Macintosh Worldwide
Development: Guide to System Software.

Backspacing to the Beginning of a Style
The TEKey procedure replaces the selection range in the specified text with a given character
and leaves an insertion point just past the inserted character.
The TEKey procedure was modified in system software version 6.0 so that it no longer
deletes a style if the user backspaces to the beginning of a style. Instead, TEKey saves the
style in the nullScrap field of the null style record (defined by the NullStRec data type) to be
applied to subsequent typed characters. As soon as the user backspaces past the beginning
of the style or clicks in another area of the text, TEKey removes the style.
PROCEDURE

TEKey

(key:

Char;

hTE:

TEHandle) ;

The hTE parameter is a handle to the edit record. The key parameter indicates the character
with which you wish to replace the selection range specified by hTE. For complete details
on the TEKey procedure, see the TextEdit chapter in Volume I.

Determining the Position of an Ambiguous

Offset

The TEGetPoint function returns the point corresponding to the given offset into the specified
text. This point indicates the bottom left of the character at the specified offset.
TEGetPoint

(offset:

Integer;

hTE:

TEHandle)

:

Point;

The hTE parameter is a handle to the edit record. The offset parameter indicates a position in
the text that is specified by hTE.

SI

FUNCTION

—

@

With this version of TextEdit, the TEGetPoint function returns a valid result even when no
text is in the edit record. The point returned is based on the values in the record’s destination
rectangle. The line height, taken either from the lineHeight field for an unstyled edit record
or from the line-height element array for a styled edit record, is also used to determine the
vertical component. Both the line and system alignments (teJust and TESysJust) are used to
determine the horizontal component.

TextEdit Routines

15-31

5
3

=

—

io)

lanl

—
ee

oe

Inside Macintosh,

Volume VI

In the case of the offset equal to a line end (which is also the line start of the next line),
TEGetPoint returns a point corresponding to the line start of the next line. For example, as
shown in Figure 15-16, if the offset 3 is passed to TEGetPoint, the point returned corresponds to the offset 3 before the character d on the second line. In the case of a mixeddirectional line, the primary caret position (the one corresponding to the line direction) is
returned. See “Mixed-Directional Text” earlier in this chapter for details on primary caret
positions in a line containing mixed-directional text.

—@
0

bc

14:2
84

Characters

—de
3

-

5

f

Offsets

So

Figure 15-16. A character offset at a line break

Toggling

a Style

The TESetStyle procedure lets you set a new style for the current selection specified by the
edit record. For details on TESetStyle, see the TextEdit chapter in Volume V.
PROCEDURE

TESetStyle

(mode:
redraw:

Integer;
Boolean;

newStyle:
HTE:

TextStyle;

TEHandle);

You specify the new style with the newStyle parameter. The hTE parameter is a handle to
a styled edit record.
The mode parameter allows you to control which style attributes to set.
The style attributes may be any additive combination of the TESetStyle mode constants.
(See the “Summary of TextEdit” at the end of this chapter for a list of the TESetStyle mode
constants.) The redraw parameter indicates whether to redraw the current selection
in its new style.
The TESetStyle procedure was enhanced in system software version 6.0 to accept an addi-

tional mode, doToggle (= 32). If doToggle is specified along with doFace and if a style

specified in the given newStyle parameter exists across the entire selected range, then
TESetStyle removes (turns off) that style. Otherwise, if the style doesn’t exist across the
entire selection range, all of the selected text is set to include that style. When a particular
style is set for an entire selection range, that style is said to be continuous over the selection.

15-32

TextEdit Routines

TextEdit

For example, in the selected text in Figure 15-17, the bold style is continuous over the
selection range and the italic style is not.
Bold
italic

Bold
Ve

Bold
VE

1

Now is the time for allgood men
Figure 15-17.

Y

An initial selection before TESetStyle is called

If you call TESetStyle with a mode of doFace + doToggle and a newStyle parameter with
a tsFace field of bold, the resulting selection is as shown in Figure 15-18. (The text style
record is defined by the TextStyle data type.)
Plain
f

Italic
oh

i

Plain
NE

1

Now is the time for all good men

\

Figure 15-18. The result of calling TESetStyle to toggle with a bold style
On the other hand, if you call TESetStyle with a mode of doFace + doToggle and a newStyle
parameter with a tsFace field of italic, the resulting selection is shown in Figure 15-19.
Bold
italic

Now is the time for allgood men
Figure 15-19. The result of calling TESetStyle to toggle with an italic style
If the redraw parameter is set to TRUE, TextEdit redraws the current selection in the new
style, recalculating line breaks, line heights, and line ascents. If the redraw parameter is
FALSE, TextEdit does not recalculate line breaks, line heights, and line ascents. Therefore,
returns a total height between two specified lines), it does not reflect the new style information set with TESetStyle. Instead, the routine uses the information set before TESetStyle was
called. To update this information, you must call the TECalText procedure. A simpler way to
be certain that current information is always reflected when drawing is to call the TESetStyle
procedure with the redraw parameter set to TRUE.
Note: TEReplaceStyle also has a redraw parameter with the same behavior
specified above.

TextEdit Routines

15-33

SI

when a routine is called that uses any of this information, such as TEGetHeight (which

=

®

“~

—
—
“
YY
ws
—
~-

Inside Macintosh,

Volume VI

Determining

Styles Across

a Selection

The TEContinuousStyle function, new with system software version 6.0, gives you information about the attributes of the current selection.
FUNCTION

TEContinuousStyle

(VAR

mode:

hTE:

Integer;

TEHandle)

:

VAR

aStyle:

TextStyle;

Boolean;

The mode parameter, which takes the same values as in TESetStyle, specifies which attributes should be checked. When TEContinuousStyle returns, the mode parameter indicates
which of the checked attributes is continuous over the selection range, and the aStyle
parameter reflects the continuous attributes. For details on TESetStyle, refer to the TextEdit
chapter in Volume V.
TEContinuousStyle returns TRUE if all of the attributes to be checked are continuous and
returns FALSE if they are not. In other words, if the mode parameter is the same before
and after the call, then TEContinuousStyle returns TRUE.

Listing 15-1 illustrates how TEContinuousStyle is useful for marking the Style menu items
so they correspond to the current selection.
Listing 15-1. Marking the Style menu items so they correspond to the current selection
VAR
mode:

Integer;

aStyle:

TextStyle;

myTE:
styleMenu:

TEHandle;
MenuHandle;

BEGIN
mode
:= doFace;
IF TEContinuousStyle(mode,

aStyle,

myTE)

THEN

BEGIN
{There

is

{

the

{

actually

at

least

selection.
the

one

face

that

Note

that

it

absence

of

all

CheckItem(styleMenu,

plainItem,

CheckItem(styleMenu,

boldItem,

is

might

continuous

be

plain,

over

}

which

is

aStyle.tsFace
bold

IN

=

IN

aStyle.tsFace) ;

END

ELSE
BEGIN

text

face

is

common

to

the

entire

CheckItem(styleMenu,

plainItem,

FALSE);

CheckItem(styleMenu,

boldItem,

FALSE);

selection. }

CheckItem(styleMenu,
italicItem,
FALSE);
{Set other menu
items appropriately. }
END;
END;

15-34

TextEdit Routines

[]);

aStyle.tsFace) ;

CheckItem(styleMenu,
italicItem,
italic
{Set other menu
items
appropriately. }

{No

}

styles.}

TextEdit

You can also use TEContinuousStyle to determine the actual values for those attributes that
are continuous for the selection. Note that a field in the text style record is only valid if the
corresponding bit is set in the mode variable; otherwise, the field contains invalid information. Listing 15-2 illustrates how you might use TEContinuousStyle to determine the font,
face, size, and color of the current selection.
Listing 15-2. Determining the font, face, size, and color of the current selection
VAR
mode:

Integer;

continuous:

Boolean;

aStyle:
myTE:

TextStyle;
TEHandle;

BEGIN
mode

:=

doFont

+

doFace

+

doSize

+

doColor;

continuous
:= TEContinuousStyle(mode,
IF BitAnd(mode,
doFont)
<> 0 THEN

aStyle,

{font

for

selection

=

aStyle.tsFont}

{more

than

one

in

selection};

myTE);

ELSE

IF

BitAnd(mode,

font

doFace)

{aStyle.tsFace

{

are

common

<>

0

contains

to

the

THEN

the

text

faces

(or

plain)

that

}

selection. }

ELSE

{No

IF

text

face

BitAnd(mode,

is

common

doSize)

<>

to

the

0

THEN

entire

{size

for

selection

=

aStyle.tsSize}

{more

than

one

in

selection};

selection.};

ELSE

IF

BitAnd(mode,
{color

for

{more

than

size

doColor)

<>

selection

=

one

in

0

THEN

aStyle.tsColor}

ELSE
color

selection};

END;

When TEContinuousStyle returns a mode that contains doFace and returns an aStyle parameter
with a tsFace field of [bold, italic], it means that the selected text is all bold and all italic, but

may contain other text faces as well. None of the other faces applies to all of the selected text,
or it would have been included in the tsFace field. But if the tsFace field is the empty set, then
all of the selected text is plain.
If the current selection range is an insertion point, TEContinuousStyle returns the style
information for the next character to be typed. TEContinuousStyle always returns TRUE in
this case, and each field of the text style record is set if the corresponding bit in the mode
parameter was set. If hTE is a handle to an unstyled edit record, TEContinuousStyle returns
the simple style information of the entire record.

TextEdit Routines

15-35

Inside Macintosh,

Volume VI

Setting Styles in TextEdit’s Scrap

Record

The SetStylScrap procedure, new with system software version 6.0, performs the opposite
function of the GetStylScrap function.
PROCEDURE

SetStylScrap

(rangeStart:

LongiInt;

newStyles:

StScrpHandle;

hTE:

rangeEnd:

LongInt;

redraw:

Boolean;

TEHand1le) ;

The SetStylScrap procedure uses the newStyles parameter (a handle to a style scrap record)
and sets its style information into the style scrap record for a range of text specified by
rangeStart and rangeEnd. If newStyles is NIL or hTE is a handle to an unstyled edit record,
SetStylScrap does nothing.
If the redraw parameter is TRUE, the text is redrawn to reflect this new style information; and
line breaks, line heights, and line ascents are recalculated. Otherwise, this new information is
not reflected in the view rectangle until the TEUpdate procedure is called. Regardless of
whether the text is redrawn, the current selection range is not changed. So if characters are
highlighted before SetStylScrap is called, they remain highlighted after it is called. They also
reflect the new style information if redraw was TRUE and if they were within the range of the
specified text.
Each element in the style scrap record contains a scrpStartChar field that is the offset to the
start of the element’s style. As with the style run array, the scrpStartChar field defines the
boundaries for the scrap’s style runs. SetStylScrap applies the first element’s style to the

characters from rangeStart up to the scrpStartChar field of the next element.

SetStylScrap terminates without error if it prematurely reaches the end of the range or if there
are not enough scrap style elements to cover the whole range. In the latter case, SetStylScrap
applies the last style in the style scrap record to the remainder of the range.

Determining

the Number

of Styles

The TENumStyles function returns the number of style changes contained in the given range,
counting one for the start of the range. Note that this number does not necessarily represent
the number of unique styles for the range because some styles may be repeated. For unstyled
edit records, TENumStyles always returns 1.
FUNCTION

TENumStyles

(rangeStart:
hTE:

LongInt;

TEHandle)

:

rangeEnd:

LongInt;

LongInt;

The rangeStart and rangeEnd parameters indicate the range. The text containing the range is
specified by the hTE parameter, a handle to the edit record.
You can use TENumStyles to calculate the amount of memory that would be required if
TECut or TECopy were called. Since the style scrap record is linear in nature, with one
element for each style change, you can multiply the result that TENumStyles returns by
SizeOf(ScrpSTElement) and add 2 to get the amount of memory needed.

15-36

TextEdit Routines

TextEdit

TEXTEDIT

DATA

STRUCTURES

This section supplies a brief overview of the contents of the various TextEdit data structures
and their relationships. Figure 15-20 shows how the TextEdit data structures create an
environment for the editing of unstyled or styled text through the use of an edit record and a
style record. It also portrays a number of supporting data structures, including a style run
table, a line-height table, a null style record, a style scrap record, and a dispatch record.
Note: Use the information in this diagram and in the explanations that follow only
for debugging so you understand the organization of the TextEdit data structures. For
reading or writing of these data structures, use the TextEdit routines. This practice
will ensure future compatibility.
Refer to the TextEdit chapters in Volumes I and V for more in-depth discussions of the
TextEdit data structures.
Here is a list of the functions and relationships of the TextEdit data structures:
The edit record, defined by the TERec data type, stores the display and editing
information for TextEdit.
The style record, defined by the TEStyleRec data type, stores the style information for
the text of the edit record. If an edit record has associated style information, its txFont
and txFace fields combine to hold a style handle, TEStyleHandle, to its style record.
The style run table, defined by the StyleRun data type, is an array that contains
the boundaries of each style run and an index to its style information in the style
element array.

The line-height table, defined by the LHTable data type, provides an array of line
heights to hold the vertical spacing information for a given edit record. It also contains
line ascent information. TextEdit uses this table only if the lineHeight field in the edit
record is negative. The lhTab field of the style record contains a handle to this lineheight table. A line number is a direct index into this array.
The null style record, defined by the NullStRec data type, contains the style information
for a null selection. The nullStyle field of the style record contains a handle to this null
style record.
The style scrap record, defined by the StScrpRec data type, is a place to store style
information in the desk scrap. The scrap style table array within this record, defined by
the ScrpStyleTab data type, contains a separate data structure for style records in the
scrap. The nullScrap field of the null style record contains a handle, STScrpHandle, to
the scrap style table.
TextEdit Data Structures

15-37

SI

The style element array, defined by the TEStyleTable data type, contains one entry
for each distinct style used in the text of the edit record. Each style entry is defined
by the STElement data type. The styleTab field of the style record contains a handle,
STHandle, to this style element array. The styleIndex field in the style run array is an
index into this data structure.

—
4
is)

~*~
-

tj

~
—
—
a

Inside Macintosh,

Volume VI

TERec

0

ae
+——— destRect ———
8

LHHandle

nStyles

4

styleTab

4 8

ihTab

P
+——— viewRect ———
}———
——

Cc

10

10

18

_lineHeight

10
=
22

clickLoc
just

hText

—

recalBack

:

recalLines

7

46

_ clikStuff

4A
4C

_txFont
_txFace
mee

46

4E
50

crOnly _

__txMode
txSize

52

|

0

*

(if txSize
= -1)

) TEStyleHandle
i
=

‘

inPort

56

|

serpStyleTab + C (arrayof
ScrpSTElement)

WIDTHHook

C

HITTESTHook

=

__nLines

60 ___ array of
Integer

|

Reserved

Reserved

( 0..-nLines) _ =

0
>

= handle

a
6

|= 16 bits

15-20.

TextEdit Data Structures

Ss

=

tsFont
isFace
tsSi

—

tsColor

The TextEdit

i

ScrpSTElement- | 8
A

—

hia

scrpHeight
scrpAscent
scrpFont
serpFace

C _ scrpSize

Ee
L

a

scrpColor
}_—__SiP
a

One each per sequential
style change in associated text

TextWidthHook

TextStyle

0

4
6

nWIDTHHook

Reserved

FlineStarts

Figure
g

TEDispatchRec

8

5E

15-38

er

-

P

78

word

a

DRAWHook

cugiltleaie

L_ 1

StScrpRec

af

4

5A

—>——»

nullScrap

| 16(0...scrpNStyles —1) J

18

nL

| 4

EOLHook

highHook

To...

teReserved

(only if lineHeight = —1).

3C__—iteLength
3E
Z

44

STScrpHandle

NullStRec

=
>

2__thAscent

One each per line in record.
Line number is a direct index
into this array

_caretState

12 (0..nStyles)_

_thHeight

4 _(0...nLines)

caretTime

a)

: into this ony

LHTable

THElomert| 0
LHElement

=|

Pr

One each per unique style in
record. stylelndex (in StyleRun
array elements) is an index

(sorted by startChar).

clickTime

l42

stFont
siFace
stSize

4 __ stAscent

ns) pats

" nRuns)
4
Me SAC
One each per style change.
Kept in ascending order of
offsets into record

clikLoop

3234

lai

stylelndex

ri

wordBreak

OE

38

—
StyleRun
StartChar

0

selEnd
active

OA

3A

—

selPoint
Saar

6
STElement 118
A
Cc

Roth de
tyleRun

(0 en

stCount

stHeight

je

18

TEStyleTable

2

_nullSTHandle

nei

—

ea:

1A__fontAscent

‘lO

[

»_STHandle

teRefCon

selRect

Sm

24
26

nRuns

2

aoe

—_

TEStyleRec

>l0

constants
doFont

=

doColor

=

doFace
doSize

=
=

1; | teJustLeft

=:

0;

8; | teCenter

=

1;

2; | teFlushDefault =
4; | teJustCenter
=

doAll
=15: | teJustRight
addSize = 16: | teFlushRight
doToggle = 32; | teForceLeft
teFlushLeft

data structures

0;
1;

= -1:
= -1;

= -2;
= -2;

TextEdit

m The scrap style table, defined by the ScrpStyleTab data type, is contained in the style
scrap record. The elements of this table are style records defined by the scrap style
element record.
a The scrap style element record, defined by the ScrpSTElement data type, contains the
style information for an element in the scrap style table and is similar to the style element
array. One scrap style element record exists for each sequential style change in the scrap
style table.
a The TextEdit dispatch record, defined by the TEDispatchRec data type, contains the
internal addresses of the TextEdit routines for EOLHook, DRAWHook, WIDTHHook,
HITTESTHook, nWIDTHHook, and TextWidthHook unless you replace them with the
addresses of your own customized versions of these routines. TextEdit combines the
recalBack and recalLines fields of the edit record to store a handle to the TextEdit
dispatch record.
m The text style record, defined by the TextStyle data type, furnishes a record of text
styles for communicating information between your application and the TextEdit
routines.
Warning: The space beyond the hooks in the TextEdit dispatch record is
reserved for internal use. If you attempt to use this private area, you will corrupt
TextEdit data. a

S I

A

—

@
—

—
\~J
~
—
—
no

TextEdit Data Structures

15-39

+

Inside Macintosh,

Volume V1

SUMMARY

OF

TEXTEDIT

Constants
CONST

{constants

for

gestaltTE1

=

Gestalt

1;

{
gestaltTE2

=

2;

{version
a

{

a

TextEdit

oe
ee

gestaltTE5

=

=

4;

5;

names

script

system
version

the

new

Macintosh

software

versions

hook

6.0.5

}

containing
of

measuring

Plus,

}

}

}

}

hook

}

}

}

and

later,

}

which contain a Script Manager-compatible
}
version of TextEdit,
including the new measuring}
hook nWIDTHHook & the outline-highlighting & }

{

text-buffering

features,

software

version

on

any

7.0,

Macintosh}

which

contains

a

}

Script
Manager-compatible
version of TextEdit
including
the new measuring
hooks,
nWIDTHHook

TextWidthHook,

outline

buffering,

features

capability

to

the

just

for

disable

parameter

of

-2;

teCenter

=

a3

teFlushDefault

oO

{ — corresponds
{flush
left
for

I

{flush

=

=

1;

teFOutlineHilite

=

NO

TEFeatureFlag

teFInlineInput
teFUseTextServices

=

3%
4;

2;

for

corresponds

text

input,

&

input}

TESetJust
all

procedure}

scripts

}

to teJustRight}
all
scripts
}
to

{flush
—

according

corresponds

feature

parameter

{text

buffering}

{outline

to
to

teForceLeft}

line

direction

teJustLeft}

values}

highlighting}

{inline input features}
{use inline input service}

}
}

}

}

{centered
for all scripts
}
{ — corresponds
to teJustCenter}
{

teFTextBuffering

—

right

highlighting,
inline

inline

=i;

teFlushLeft

Summary of TextEdit

for

}

containing
of

version

SE, Macintosh SE/30,
}
II, Macintosh Portable,
IIx, or Macintosh IIcx}

{

15-40

containing

{
{
{

for
=

for

non-Roman

including

nWIDTHHook

{system

teFlushRight

{constants

6.0.4

IIci}

Manager-compatible

Macintosh
Macintosh
Macintosh

&

constant

version

Macintosh

Manager-compatible

Script

{system

{

{new

a

6.0.4

Script

et

3;

een

gestaltTE4

software

on

{ TextEdit including the new measuring
{ nWIDTHHook for the Macintosh IIci}
{version 6.0.4 non-Roman script system

ee

=

system

TextEdit

{

gestaltTE3

function}

{U.S.

}

TextEdit

for

TEFeatureFlag

action

parameter

=

0;

{clear

TEBitSet

=

1;

{set

TEBitTest

=

-l;

{test

{selectors

for

values}

TEFeatureFlag

TEFeatureFlag
TEFeatureFlag

=
a

Os
Ls

intWidthHook

=

Ds

intHitTestHook

=:

3s

{width measurement
{hit text hook}

intNWidthHook

=

65

{new

{end-of-line
{drawing

{

intTextWidthHook

=

7}

identifying

width

hook}

measurement

hook

}

width

measurement

hook

}

TextWidthHook}

=

fy

routine that called FindWord
{called for determining new }
{ line breaks}

teWordDrag

=:

83

{called

teFromFind

=

I2;

teFromRecal

=

16%

{called for word
{called for word
{ recalculation}

teWordSelect

{values

for

the

hook}

hook}

nWIDTHHook}

{new
{

for

features}

TECustomHook}

int EOLHook
intDrawHook

{constants

features}
features}

for

TESetStyle/TEContinuousStyle

extending

=

1;

{set

font

am

me

{set
{set

character
style}
type size}

{set
{set

color}
all attributes}

ih

doColor

=

Bly

doAll
addSize

=
+

Udy
16%

doTocgle

=

32

{offsets

into

(family)

{adjust

type

size}

{toggle

mode

for

{

and

line

}

modes}

doFace

=

selection}

selection}
breaking in

doFont
doSize

word

}

number}

TESetStyle

}

TEContinuousStyle}

TEDispatchRec}

EOLHook

=

Dis

{[ProcPtr]

TEEOLHook}

DRAWHoOok

=

ds

{{ProcPtr]

TEWidthHook}

WIDTHHook
HITTESTHOok
nWIDTHHook
TextWidthHook

=
a
=
=

§;
12
24;
28%

{[ProcPtr]

TEDrawHook}

{[ProcPtr]

TEHitTestHook}

{[ProcPtr]
{[ProcPtr]

nTEWidthHook}
TETextWidthHook}

Ss I

{constants
TEBitClear

—
io)
”

—_

Data

Type

TYPE

TEIntHook

prove
“
lan)
_—
a
_

Integer;

Summary of TextEdit

15-41

Inside Macintosh,

Volume VI

Routines

Outline

Highlighting, Text Buffering, and

FUNCTION

TEFeatureFlag

(feature:
hTE:

Customizing
PROCEDURE

Integer;

TEHandle)

Inline Input

action:

:

Integer;

Integer;

TextEdit

TECustomHook

(which:

hTE:

TEIntHook;

VAR

addr:

ProcPtr;

TEHandle);

Backspacing to the Beginning of a Style
PROCEDURE

TEKey

(key:

Char;

hTE:

TEHandle);

Determining the Position of an Ambiguous

Offset

FUNCTION

TEHandle)

TEGet Point

Toggling

a Style

PROCEDURE

TESetStyle

(offset:

(mode:

Integer;

Integer;

redraw:

Determining
FUNCTION

Styles Across

TEContinuousStyle

(VAR

FUNCTION

TENumStyles

mode:

Integer;
:

Summary of TextEdit

TextStyle;

VAR

aStyle:

TextStyle;

Boolean;

Record
LongInt;

newStyles:

StScrpHandle;

rangeEnd:
redraw:

Longint;
Boolean;

TEHandle) ;

of Styles
(rangeStart:
hTE:

15-42

Point;

TEHandle) ;

(rangeStart:
hTE:

Determining the Number

hTE:

:

a Selection

Setting Styles in TextEdit’s Scrap
SetStylScrap

newStyle:

Boolean;

TEHandle)

PROCEDURE

hTE:

LongInt;

TEHandle)

:

rangeEnd:

LongInt;

LongInt;

hTE:

TextEdit

Global

Variables

WordRedraw

$BA5

TEFindWord

$7F8

TESysJust

$BAC

Assembly-Language
Trap

Macros

Used for line calculations to determine how much of a
line must be redrawn after a character is entered.
The low-memory address for TextEdit’s word
breaking routine.
The system alignment whose default value is set by
the last installed script.

Information

Requiring

Routine

Selectors

_TEDispatch
Selector

$0001

$0008

$000A
$000B
$000C
$000D
$000E

Routine

TESetStyle

TEGetPoint

TEContinuousStyle
SetStylScrap
TECustomHook
TeNumStyles
TEFeatureFlag

—

uw

—

a?)
SA
—

—

5

a

Summary of TextEdit

15-43

Inside Macintosh,

15-44

Volume VI

GRAPHICS

OVERVIEW

About This Chapter
About Macintosh Graphics
The Components of Macintosh Graphics
QuickDraw

The Interface
The Video Card and Screen
The Major Data Structures
The RGB Color Record
Color Collections
The Pixel Map Record
Port Characteristics: The Color GrafPort Record
Device Characteristics: The Graphics Device Record
Graphics Initialization
The Graphics Path
How Indexed Pixels Work
How Direct Pixels Work
Determining the QuickDraw Version
What Else to Read
Summary of Graphics Data Types

a

a)

@

Ler |

Sy)

ee

=e
O°
~D

©os
®

“|
<

eae

=

16-1

Graphics Overview

ABOUT

THIS

CHAPTER

This chapter presents an overview of Macintosh® graphics. It surveys the components and
processes of Color QuickDraw™, the other graphics managers with which it interacts, and
how colors flow from your application to the screen.
Read the information in this chapter if your application uses color or gray scales. To use this
chapter, you should have a basic understanding of the original QuickDraw described in
Volume I, but need not have read any other graphics chapters in this or other volumes of
Inside Macintosh. Figure 16-1 charts your path into the world of Macintosh graphics.

ABOUT

MACINTOSH

GRAPHICS

Macintosh graphics begin with QuickDraw and end with glowing phosphor. The early
Macintosh systems, with their built-in screens and integral graphics hardware, made
well-defined and comparatively limited demands on your understanding of graphics: if
you learned QuickDraw, you were set.
The Macintosh II computer introduced two features that greatly increased graphics capabilities: slots and color. Slots allow the addition of specialized hardware to the system. (In the

original Macintosh II, the graphics hardware was always added in NuBus™ standard slots.

Current systems allow a number of hardware expansion modes in addition to NuBus slots.)
With slots, the characteristics of the output device can vary from machine to machine. With
color, the extent of variation can be very great: screens not only can vary in horizontal and
vertical dimensions, but they can also vary in depth. To the single-bit-per-pixel depth of the
original Macintosh systems, the Macintosh II added pixel depths of 2, 4, and 8 bits. Output
devices range from black-and-white systems to cards and screens capable of presenting
hundreds of colors from palettes of millions. Furthermore, users can combine screens: a
user may move your application’s window so that it overlaps screens of very different
characteristics.
To remove the burden of worrying about output devices (for most applications), Color
QuickDraw is device-independent. Applications using color can work in an abstract color
space defined by three axes of red, green, and blue (RGB). Your application can specify a
color as an RGB value, in which each component is defined as a 16-bit integer. Color
QuickDraw compares such a 48-bit value with the colors actually available on the hardware
at execution time and chooses the closest match. Precolor applications and those not
concerned with color or gray-scale graphics need not change, and those concerned only
with straightforward color usage can ignore the problems of output devices.
When the Macintosh II was introduced, the maximum pixel value was limited to a single
byte. Each pixel’s byte can specify one of 256 (28) different values, and, rather than simply
truncating the least significant bits of each component to get a color, Color QuickDraw treats
such pixel values as indexes into a color table. If your application asks for a 48-bit RGB
color, the Color Manager examines the colors available in the card. If the video device

—

2)

?)“
=

c=)—

a
ie

°

i? 2]
‘an
=

<
@
=
<

—*

is”
<

<

About Macintosh Graphics

16-3

Inside Macintosh,

Volume VI

Covers the mathematical foundation,

bitmaps, copy modes, regions,
grafPorts, clipping, coordinates,
cursors, icons, text, QuickDraw
routines, and much more

QuickDraw

J

e

im

Introduces RGB colors,

pixel maps, palettes, color

tables, color grafPorts,
graphics devices, and the other
managers: Color Picker Package,
Picture Utilities Package, Graphics
Devices Manager, Color Manager

Graphics

Overview

ao

Color

Covers RGB colors, pixel maps,
color tables, color grafPorts, color
cursors, color icons, version2 pictures,
Color QuickDraw routines

Color
QuickDraw

J

\

Covers direct pixels,
routines for compatibility,
luminance mapping,
bitmap-to-region conversions,
new Color QuickDraw routines

Palette
Manager

Picker

Package

on

Color
QuickDraw

5

Fs

Picture
Utilities

Package

Graphics
Devices
Manager

Color

Manager

Figure 16-1.
16-4

About Macintosh Graphics

Macintosh

graphics chapters

Graphics Overview

supports 8 bits per pixel, the card contains a color look-up table (CLUT) with 256 entries,
each entry an RGB value. The Color Manager determines which RGB value is closest to
the requested color and tells Color QuickDraw what the index for that color is.
Storage and movement of such indexed color values require a maximum of 8 bits, rather
than 48, saving space and time. (The RAM needed to hold a 640-by-480 pixel screen at
8 bits per pixel is about 300,000 bytes.) And because the table is variable—it can be loaded
with different colors—applications can display up to 16 million colors, although only 256
different colors can appear at once.
With the addition of direct pixel values, first made available with system software

version 6.0.5, the 256 simultaneous color limit has been removed. Color QuickDraw can

now also process direct pixel values, which use 16 or 32 bits to directly represent a color.
Using direct color not only removes much of the complexity of the color table mechanism,
but it also allows the display of thousands or millions of colors simultaneously, resulting in
near-photographic realism.
The device-independence of Color QuickDraw is such that on a three-screen system—for
example, with displays for gray-scale indexed pixels, color indexed pixels, and direct
pixels—the user can move your window to span all three devices and each will show its best
representation of your image.
This overview introduces Color QuickDraw and the related graphics managers with which
it works.
= Color QuickDraw calls upon the Color Manager to map color requests to the actual
colors available. Most applications never need to call the Color Manager directly.
a The Palette Manager allows your application to specify the set of colors that it needs
on a window-by-window basis, and makes the colors available (within applicationdetermined ranges) in a graceful manner.
w The Color Picker Package allows your application to solicit a color choice from the user
in a standard way.
a The Picture Utilities Package provides routines with which your application can extract
information, such as pixel depth and colors used, from pixel maps and pictures.
mw The Graphics Devices Manager offers routines for preparing images offscreen, and it
manages the data structures that track the characteristics of the graphics hardware of a
particular system.
m The Slot Manager controls communication with expansion boards of all types, including
video cards.
The rest of this chapter

ate

Nn

m introduces the basic graphics components and further defines the differences between
indexed and direct pixel images

OQ

4G |
mn

m presents overviews of the important color graphics data structures: the color tables and
palettes that hold colors, the pixel maps that hold information about images, the color
erafPorts that hold information about windows, and the graphics device records that
describe the capabilities of a particular screen

mw
ad
—
_

iT)
2)

<
@
~

<oe
is”)
<<
<

About Macintosh Graphics

16-5

Inside Macintosh,

Volume VI

= describes the startup process as it applies to graphics, to show how the data structures
are created and initialized
m traces the path of a user’s request for a color through the graphics system and onto a
screen, in both the indexed and direct pixel systems
w tells you how to determine which version of QuickDraw is actually running

THE

COMPONENTS

OF

MACINTOSH

GRAPHICS

Broadly speaking, a Macintosh graphics system has three parts: QuickDraw, the video card
and screen that constitute the display device, and the interface between them.

QuickDraw
QuickDraw comes in three varieties: the original version offered with systems equipped
with a 68000 microprocessor; the original Color QuickDraw, which appeared with the
Macintosh II; and the current Color QuickDraw, which was introduced as 32-Bit QuickDraw
and is now part of system software version 7.0.
In general, applications that use the original QuickDraw routines are compatible with all
Macintosh systems. Applications using the original Color QuickDraw work even better under
the new Color QuickDraw. But applications that use Color QuickDraw routines cannot
execute under the original QuickDraw, nor can applications using direct pixel images run on
the original Color QuickDraw.

Note that the original QuickDraw contains a simple eight-color system that is compatible with
all machines (although the colors cannot be displayed on early black-and-white systems), so
if your application needs eight colors or fewer, you can maximize compatibility by using that
system, which is described in the QuickDraw chapter of Volume I.

Whenever possible, earlier versions of QuickDraw have been upgraded with later features.
For example, later versions of the original QuickDraw can process pictures that include color
information. Although such QuickDraw versions cannot display color, they display the best
black-and-white approximation possible.

The

Interface

Figure 16-2 shows how QuickDraw, the other graphics managers, and the graphics hardware interrelate.
The Monitors control panel lets users arrange their screens in relation to each other in space
(above or below, side by side) and select how many colors, if any, a device is to display.

16-6

The Components of Macintosh Graphics

Graphics Overview

Monitors

@»

=

Color

[=
;

,

Video card

Meanie

Picker

42)

>

Palette
Manager

|>

Color
Manager

—

le>

if
QuickDraw

Graphics
Devices

i

a

l=

1]

[==

Figure 16-2. QuickDraw and the graphics managers
The Color Picker Package offers you a standard way to present the user with a color-selection
dialog box. The Color Picker’s wheel and slide controls let the user preview and select any
color the hardware can produce. (The Color control panel, for example, uses the Color Picker
to let the user choose a highlight color to be used on the desktop.)
The Monitors control panel and the Color Picker are user interface modules that demonstrate
an important axiom: the user is in charge. The user can select any one of trillions of colors
through the Color Picker, and that same user may set the color device to show only black and
white pixels.
The Palette Manager provides a set of routines with which you can create and control the set
of colors needed by your application window. Palettes are especially important with indexed
screen devices, which support only displays that show a maximum of 256 colors at once.
Since all or parts of several applications and the desktop may be visible on the screen, and
they may all have different color schemes, contention can arise for those 256 table places.
The Palette Manager can arbitrate among the contenders and automatically see that the color
requirements of the frontmost, or active, window are met first.

And no matter how wild a neon-blacklit-backlit effect you create, the Palette Manager restores
graphics order when your application terminates.
The Palette Manager and Color QuickDraw both use the low-level graphics abilities of the
Color Manager to find the best color available when all color table indexes are taken and
another color is needed on the screen. The Color Manager examines the available colors and
determines which of them is closest to the requested color. If your application needs to paint a
race car British racing green, for example, you can ask for it by using a Color QuickDraw
routine, and hope that whatever the Color Manager finds available is a close enough match to
look good. Or you can ask the Palette Manager for the color and specify how close the match
has to be. If no color comes as close as you like, the Palette Manager loads the exact color
you requested into the color table for the device.

i

N

om
i!
rm
)

a=]
—

—s

oO
~

<
oO
=
<
=
ce

<=

The Components of Macintosh Graphics

16-7

Inside Macintosh,

Volume

VI

The Graphics Devices Manager and the Slot Manager are the final links to the video driver
and its card. The Slot Manager examines every installed card when the system starts up,
and from the information the cards supply, the Slot Manager supplies QuickDraw and the
graphics interface managers with the information they need to operate. The Graphics Devices
Manager manages the record that describes the capabilities of the graphics card.

The

Video

Card

and

Screen

Your application can declare colors in RGB space, but what the user finally sees depends on
the characteristics of the actual video card and screen. Screens may display color or black and
white, and have indexed pixels of 2-bit, 4-bit, or 8-bit bit depths, or direct pixels of 16-bit or
32-bit depths.
Preparing an image for display in the original QuickDraw means preparing a bitmap, which
specifies the memory arrangement of the bits that describe whether each pixel on a screen is
to be on or off. Specifying on or off takes just 1 bit. You can describe the state of 8 pixels in
a single byte. Entire black-and-white screen images can be stored in what is now considered
a modest amount of memory.
Preparing a color or gray-scale image requires a pixel map, where more than one bit may be
assigned to determine the color of each screen pixel. Two bits per pixel provide indexes into a
table of four colors, but if two colors are black and white, only two other hues can be shown.
A four-index color table might contain the following entries.
Index

Color

00

White (turn all three RGB phosphors full on)

01

Gray (turn all three on halfway)

10

Pale blue for highlighting (turn all three on, but use more blue)

1]

Black (turn all of them off)

If a 2-bit memory space representing a pixel had a value of 00, the resulting screen pixel
would be white. The sequence 10 10 10 10 would use the third entry in the table to generate
a series of pale blue pixels on the screen.
Four bits can provide indexes into a table of 16 colors, a number sufficient for many straightforward graphics purposes, such as charts, presentations, or displaying flags of the nations.
Using a byte (8 bits) for each pixel, 256 colors can be displayed, which for many images is
enough to produce near-photographic quality. The problem is that the colors good for one
near-photographic image may not be good for another. Rembrandt’s browns and umbers
don’t do much for a still from The Wizard of Oz. To solve this problem, the Macintosh II
video card uses a variable color table (rather than a fixed one). You can display Rembrandt
with one set of 256 colors, then reload the table for another image.

16-8

The Components of Macintosh Graphics

Graphics Overview

The main reason for using variable color tables is that a relatively small index value is sufficient to specify any one color out of a palette of millions. You need less RAM to store an
image and less time to move it around than if you use large RGB values directly. An extra
benefit is color table animation, by which your application can change colors on the screen
without actually reassigning pixel values. (By changing the colors of the 256 entries of an
8-bit table, you change all the screen’s colors—without any changes in screen memory.)
Drawbacks are that since only 256 colors can appear on the screen at once, windows must
compete for colors, and pairing an RGB request to the closest actual color in the table
requires the complex inverse-table matching scheme implemented by the Color Manager.
Video boards that implement direct pixels, in which the pixel value specifies an RGB color
rather than an index into a table of colors, eliminate the competition for limited table spaces
and remove the need for color table matching. The direct pixel system is simpler. The cost is
larger amounts of RAM needed to hold the larger pixel values; the benefit—thousands and
even millions of colors on the screen at once—is worth the cost for many applications, some
of which would not exist without such a capability.

THE

MAJOR

DATA

STRUCTURES

Understanding Macintosh graphics is easier with some knowledge of the data structures that
hold the information and define the graphics environment. QuickDraw supplies routines for
querying and altering the fields of these data structures; you should not alter them directly. (If
you have existing programs that change fields directly, see the Color QuickDraw chapter in this
volume for a description of routines that you can use to notify QuickDraw of such changes.)
The smallest place to begin is the RGB color record, which holds a single color.

The

RGB

Color

Record

The RGB color record consists of three 16-bit values, one each for red, green, and blue.
Red

Green

Blue

Your application can specify RGB colors, and the graphics system will find the closest
matching color on the target hardware. To draw a yellow line, for example, you might set
the foreground pen to an RGB color in which the red and green values are high and the
blue value is low, such as (to take the brightest example) $FFFF FFFF 0000.

on

N

If the red, green, and blue values are equal, the resulting color is black (if they are 0), white
(if they are at or close to $FFFF), or gray (if they are in between).

7?’
a

X.
a)
ic)
=

ve

iv)

wn
<

@
or

<
me
=<

=

The Major Data Structures

16-9

Inside Macintosh,

Color

Volume

VI

Collections

RGB color records are included in two forms of collective color sets: the color table and the

palette. Each associates additional information with the RGB color record.

A color table consists of a header containing flags and information such as the size of the
table, and a number of RGB color records, each record preceded by a value. The RGB color
plus a value is defined as a color specification record. (See “Summary of Graphics Data
Types” at the end of this chapter for Pascal definitions of these data structures.) The value
has one of two uses, depending on a header flag. If the color table belongs to a pixel map,
the value is the color’s index.
There are five RGB colors in this table
Value

Red

Green

Blue

Value

Red

Green

Blue

Value

Red

Green

Blue

Value

Red

Green

Blue

Value

Red

Green

Blue

The other form in which colors are usefully gathered is the palette, a color collection
of colors that can be used by a window. A palette comprises a header and a collection of
color information records, which contain RGB colors with information about how the colors
are to be used and how closely the graphics system must match them.

There are four entries in this palette
Red

Green

Blue

Usage

Tolerance

Red

Green

Blue

Usage

Tolerance

Red

Green

Blue

Usage

Tolerance

Red

Green

Blue

Usage

Tolerance

The Palette Manager manipulates both color tables and palettes, and it has routines for converting one into the other. By using the Palette Manager, your application can exercise
exquisite control of color allocation. For example, you can specify the usage information in
a palette such that a selected set of colors appears if the window is displayed on an 8-bit-deep
screen, and another set of colors appears if the window is displayed on a 4-bit-deep screen.
The Palette Manager has sets of default colors for different pixel depths, so that a screen will
return to a well-balanced state after gaudy applications terminate. See the Palette Manager
chapter in this volume for more information on creating and manipulating palettes.

16-10

The Major Data Structures

Graphics Overview

The

Pixel

Map

Record

The pixel map is the modern successor to the bitmap: to that original image-mapping record,
the pixel map record adds information about the depth of the pixels that make up an image. In
black-and-white systems, such as the original Macintosh computers, only | bit was needed
per pixel, since black and white can be indicated by 0 and 1. Color QuickDraw now recognizes
pixel depths of 1, 2, 4, 8, 16, and 32 bits. The pixel map not only describes the pixel depth; it
also specifies how each pixel’s information is organized: either as indexes to color tables or as
direct color specifications.
The pixel map record is defined in the Color QuickDraw chapter of Volume V. The Color
QuickDraw chapter in this volume explains how some fields can have additional values,
although the format of the pixel map record is unchanged.
baseAddr
rowBytes

Pointer to the image data
Flags, and bytes in a row

bounds

Boundary rectangle

pmVersion

Pixel map version number

packType

Packing format

packSize

Size of data in packed state

hRes
vRes

Horizontal resolution in dots per inch
Vertical resolution in dots per inch

pixelType

Format of pixel image

pixelSize

Physical bits per pixel

cmpCount

Number of components in each pixel

cmpSize

Number of bits in each component

planeBytes

Offset to next plane

pmTable

Handle to a color table for this image

Ibaticonast

As in a bitmap record, the baseAddr, rowBytes, and bounds fields describe where in memory
the image information begins, how many bytes are used for each row of the image, and its
boundary rectangle.
The hRes and vRes fields describe the horizontal and vertical resolution of the image. For
example, images destined for display on a screen might be set to 72 dots per inch (dpi) in
each direction; those prepared for printing on a LaserWriter® might be set to 300 dpi.
The pixelType field indicates whether the pixel values for the image are to be treated as
indexes to a color table or taken as the real color.

—

ON
=
&

—
—_
—
—
ate

iz)
2)

<
7)

=

<
me
Aa

<=

The Major Data Structures

—_ 16-11

Inside Macintosh,

Volume V1

The pixelSize field shows the size of each pixel value in memory:
indexed pixel values, and 16 or 32 bits for direct pixel values.

|, 2, 4, or 8 bits for

Indexed pixels have one component, the index value. Direct pixels have three components,
one each for red, green, and blue. The cmpCount field contains either | or 3, accordingly.
The cmpSize field lists the component sizes: |, 2, 4, or 8 bits for the single component of an
indexed pixel, and 5 or 8 bits for each component in a direct pixel. (The three direct pixel
components are the same size, either 5-5-5 or 8-8-8 for the red, green, and blue values.)
The pmTable field contains a handle to the color table for this image. Since indexed pixel
values are just that, indexes, a color table needs to be bundled with each pixel map to show
what color each index value indicates. (Pixel map records for direct pixel values don’t need
tables, since the image memory contains the actual colors, but the pmTable field references a
dummy table for compatibility.)
Pixel map records are key elements of the last two data structures discussed in this chapter:
color grafPort records, which describes graphics ports, such as windows, and the graphics
device records, which describe output devices, such as screens.

Port

Characteristics:

The

Color

GrafPort

Record

The color grafPort contains the information Color QuickDraw needs to maintain a color
drawing environment for a window. Most or all of the color grafPort records you need are
created for you by the Window Manager.
The color grafPort record is fully described in the Color QuickDraw chapter of Volume V.
A color grafPort contains much more information than its immediate ancestor, the grafPort, but
for compatibility it has maintained the same size by using pointers to other information. Like
the grafPort, it contains such essential information as where the pen is currently positioned and
how big it is, what font to draw with, and what parts of a window are currently visible.
The portPixMap field, located in the same relative position as the grafPort’s portBits field,
contains a handle to the pixel map record that defines the image for the port. Since a pixel map
record contains a reference to a color table, a color grafPort has its own set of colors.
The last field in the color grafPort record is a pointer to the low-level Color QuickDraw
drawing routines, which some graphics applications intercept, usually to add a preprocessing
or postprocessing flourish. Some applications intercept the routines while examining a
version 2 picture file (the format used to store pictures) so that they can watch the picture’s
drawing commands and intercept those of special interest.
Although most color grafPort records are created and maintained by the Window Manager,
which includes a color grafPort record within a color window record, you can also create
grafPorts that aren’t attached to any window. By using an offscreen grafPort you can prepare
an image offscreen and then pop it into view when it’s complete. This tactic may make updates

16-12.

The Major Data Structures

Graphics Overview

Device |D for font selection
Handle to port’s pixel map
Flags

device

portPixMap
portVersion

grafVars

Handle to additional color fields
Extra width added to nonspace characters
Port's rectangle
Visible region
Clipping region
Background pattern

chExtra

portRect
visRgn
clipRgn
bkPixPat

rgbFgColor
rgbBkColor

Requested foreground color
Requested background color
Pen location
Pen size

pnLoc

pnSize
pnMode

Pen transfer mode

pnPixPat

Pen pattern

fillPixPat
pnvVis

Fill pattern
Pen visibility
Font number for text
Text character style
Text transfer mode
Font size for text
Extra width added to space characters
Actual foreground color
Actual background color
Plane being drawn

txFont
txFace
txMode
txSize

spExtra
fgColor
bkColor
colrBit

4

grafProcs

/

Pointer to low-level drawing routines

faster in situations where recreating the contents of the screen is time consuming. The process
is greatly simplified with the offscreen graphics routines, described in the Graphics Devices
Manager chapter of this volume.

Device

Characteristics:

The

Graphics

Device

Record
—

The color grafPort record contains information about a window, but there can be many
windows on a screen, and even many screens. The graphics device record is the data
structure that holds information about the physical characteristics of a drawing environment.

“A

OQ
“

&

—

—_

=

me

Like the grafPort, the graphics device record is created automatically for you: the Graphics
Devices Manager uses information supplied by the Slot Manager to create a graphics device
record for each device found in a slot card during startup.

The Major Data Structures

16-13

'T)

72)
~
i
<
@

|
<

ete

te)
=
<=

Inside Macintosh, Volume VI

Color QuickDraw needs ready access to a number of characteristics of the display devices. It
collects this vital information in the graphics device record, whose contents can be manipulated
by a set of routines described in the Graphics Devices Manager chapter in this volume. These
routines issue standard device control calls to the card’s device-specific driver, which set and
query characteristics such as pixel depth. The Graphics Devices Manager routines are also
responsible for updating the graphics device records.
Much of the information in a graphics device record is too esoteric for an overview, and the
new offscreen graphics routines (described in the Graphics Devices Manager chapter in this

volume) provide a procedural interface to its fields. But a look at this last link is important in
the conceptual chain.

gdRefNum

Reference number of driver

gd|ID

Client ID for search procedure

gdType

Type of device (indexed, direct)

gdlTable

Handle to inverse table for Color Manager

gdResPref

Preferred resolution

gdSearchProc

Handle to list of search functions

gdCompProc
gdFlags

Handle to list of complement functions
Graphics device flags

gdPMap

Handle to pixel map for displayed image

gdRefCon

Reference value

gdNextGD

Handle to next graphics device record

gdRect

Device’s global bounds

gdMode

Device’s current mode

ee

The gdITable field points to an inverse table, which the Color Manager creates and maintains,
and uses to quickly find the nearest match for a requested color. (The technique is described
in the Color Manager chapter of Volume V.) The process is very fast once the table is built,
but if a color is changed in the device’s CLUT, the Color Manager must rebuild the inverse
table the next time it has to find a color. Using high tolerance values in the palettes associated
with your windows, rather than always demanding exact matches to your colors, lessens the
recalculations required. (For an explanation of tolerance values, see the Palette Manager
chapter in this volume.)
The gdPMap field contains a handle to the pixel map that reflects the imaging capabilities of
the device. The pixel map’s type, size, and component fields indicate whether the device is
direct or indexed and what pixel depth it displays. The pixel map’s color table is synchronized with the CLUT on the device.
The gdRect field describes the device’s bounds in global coordinates.
If you want to work with offscreen graphics that have characteristics different from those of
the actual devices on the system, you can use the offscreen graphics world routines to create
and maintain offscreen port and device records. (See the Graphics Devices Manager chapter
in this volume.)

16-14

= The Major Data Structures

Graphics Overview

GRAPHICS

INITIALIZATION

In the initialization process, illustrated in Figure 16-3, the firmware in a video card’s ROM

supplies information about what sort of graphics device it is (indexed or direct), how much
card RAM is available, and so on. Some of this information is stored in the graphics device
record for that card, where it is available to the entire graphics system.

Video card

ioe

er

vr;

TrO

portPixMa

| Graphics Devices | “i

Slot

|

t
dec

Saha! mt

baseAddr

|

pixelSize
cmpCount

cmpCount

cmpSize

cmpSize

Figure 16-3. Initializing Macintosh graphics
When you open a window, the color grafPort record contains a handle to a pixel map record
that was cloned from the pixel map record in the main screen’s graphics device record. The
pixel map record for your window thereby contains the correct pixel specifications for the
screen on which it is displayed.
The situation is more complex when a window is displayed in a multiscreen environment,
but QuickDraw does the housekeeping for you. When a multiscreen system starts up, one of
the screens is determined to be the startup screen, the screen on which the “happy Macintosh”
appears. (If the user has specified a startup screen in the Monitors control panel, then that
screen is used.) By default, the menu bar appears on the startup screen. The screen with the
menu bar is called the main screen. Global coordinates are anchored to the main screen,

whose upper-left corner is at (0,0).

—

>.
~

.

~:
as
—
Sd
—
a
—P
'¢
_—

/

-~

—_
<
@
~;
<
—e
co

“

<=

Graphics Initialization

16-15

Inside Macintosh,

Volume VI

Each screen has its own graphics device record created from information in the video card’s
ROM. Thus, there is a graphics destination for each screen, but QuickDraw lets you draw to
the window’s grafPort as if it were all on one screen. Color QuickDraw internally calculates
the changes required for drawing to the other screens.
During the startup of a multiscreen environment, the InitWindows procedure is called to create
a region that is the union of all the active screen devices (minus the menu bar and the rounded

corners on the outermost screens). It saves this region as the global variable GrayRgn. The
gray region describes and defines the desktop, the area on which windows can be dragged.
Windows can be dragged anywhere within the gray region, from one screen to another or
spanning screen boundaries. QuickDraw calculates the global coordinates of the rectangle into
which it must draw and issues the drawing command to each device the rectangle intersects.

THE

GRAPHICS

PATH

Tracing the path from data in memory to a dot on a screen traverses the major parts of the
Macintosh graphics system and recapitulates much of the discussion in this chapter.
Color QuickDraw considers colors as ideals: an RGB color record consists of three 16-bit
values, one each for red, green, and blue. The resulting 48-bit record is sufficient to specify
far more colors than the human eye can discern. Color QuickDraw and the graphics environment determine how this ideal becomes real.
The largest pixel value usable with system software version 7.0 is a 32-bit direct pixel, of

which the red, green, and blue components have 8 bits each, and 8 bits are currently unused.

RGB values of 24 bits can specify 16 million colors, which the human eye can just barely
distinguish.

Advances in technology don’t always mean increases in complexity. The color table system
devised for Color QuickDraw was an expedient, to allow a smaller amount of RAM to
display nearly full-color images. Direct pixel specification is inherently simpler—at the cost
of additional RAM to hold the greater information needed to specify an image, and additional
machine cycles to move it around.
The following two sections trace the steps from a user selecting a color to sending signals
to a video screen. Of necessity, these explanations are simplified to provide an overview of
the process.

How

Indexed

Pixels

Work

Indexed devices expect that the pixel maps pointed to by color grafPort and graphics device
records are based on an indexed pixel system, in which the stored image values are indexes to
a table, not the RGB values themselves.

16-16

|The Graphics Path

Graphics Overview

Video card

Video
aid
=
|

CLUT

ROMP
11
P=aee>|

—

_—
—

|

PE

:
|

>|

(GF

12

B

* XN

T

v
Graphics Devices

Hg

Manager

:
Color

R

>|

‘ll y

|

QuickDraw |

=

pai

Color

——

Manager

Color Picker

Figure 16-4. The indexed pixel path
As illustrated in Figure 16-4, the user tells the application to choose a color for some object

(1). The application calls the Color Picker (2), which offers its color wheel dialog box to the

user (3), who selects a color. The Color Picker returns that color to the application as a full
48-bit RGB value (4). The application tells Color QuickDraw to draw the object in that color
(5). Color QuickDraw asks the Color Manager to determine what color in the card’s color
table comes closest to the color requested (6).

At startup, the video card’s declaration ROM supplied information for the creation of a graphics
device record for the card, describing its characteristics. The resulting graphics device record
contains a color table that is kept synchronized with the card’s CLUT. The Color Manager need
only look into the current graphics device record’s inverse table to find what RGB colors are
currently available (7) and decide which comes closest in RGB space to the color requested by
the application. (The inverse table is described in the Color Manager chapter of Volume V.)
The Color Manager gets the index value for the best match in the table and returns that value to
Color QuickDraw (8), which puts the index value into those places in video RAM that store
the object (9).

The card continuously displays video RAM by taking the index values, converting them to
RGB colors according to the CLUT entry at that index (10), and sending them to digitalto-analog converters (11) that produce a signal for the screen (12).

—

Nn
ve

i

S—
i

ig)
2)
~~
ww
<
@
“%

<

—e

@

=

The Graphics Path

16-17

Inside Macintosh,

Volume VI

How

Pixels

Direct

Work

When pixels are directly specified, the Color Manager’s inverse table look-up isn’t needed.
The color value is derived from the most significant 5 or 8 bits of each component. The first
few steps are the same as the steps for indexed devices.
Video card
Video
RAM
—
[

]

—
L

ROM}

8
|:
|

T

_

ul

c

r

17

wr

yi

t

"4

aS.

R

G

9

»|_B

]

By
Color
QuickDraw F< -

6
y
[=>)| Graphics Devices
Manager

Color Picker

Figure 16-5. The direct pixel path
As illustrated in Figure 16-5, the user tells the application to choose a color for some object (1).
The application calls the Color Picker (2), which offers its color wheel dialog box to the user
(3), who selects a color. The Color Picker returns that color to the application as a full 48-bit
RGB value (4). The application tells Color QuickDraw to draw the object in that color (5).
Color QuickDraw knows from the graphics device record (6) that the screen is a direct device

in which pixels are 32 bits deep, which means that 8 bits are used for each of the red, green,

and blue components (8 are unused). Color QuickDraw passes the high 8 bits from each 16-bit
component of its 48-bit RGB value to the card (7), which stores that 24-bit value in video RAM
for each location of the object. The card continuously displays video RAM by sending the three
8-bit red, green, and blue values to digital-to-analog converters (8) that produce a signal for
the screen (9).

DETERMINING

THE

QUICKDRAW

VERSION

Remember that the three varieties of QuickDraw are upwardly compatible: programs you
write for the original QuickDraw run on all varieties of QuickDraw, and indexed-pixel Color
QuickDraw programs run under direct-pixel systems (although colors may look different—
they’ll be closer to what you request). The reverse is not true; Color QuickDraw uses hard-

16-18

Determining the QuickDraw Version

W WwW
D&B

COLOR

QUICKDRAW

About This Chapter
About Color QuickDraw
Direct Pixels
Pixel Map Record Extensions
Direct Pixel Values
Writing Compatible Graphics Applications
Using Color QuickDraw
Manipulating Pixel Map Images
Copying With Masks
Colorizing
Transfer Modes
Dithering
Resizing Images
Luminance Mapping
Image Resolution
Displaying Variable-Resolution Pixel Maps and Pictures
Exporting Pixel Map Records
Converting a Bitmap to a Region
Determining Whether Drawing Is Complete
Extensions to the Version 2 Picture Format
Font Name
Line Justification
Direct Pixel Images
Sample Extended Version 2 Picture
Color QuickDraw Routines
Creating an Extended Version 2 Picture
Creating Regions From Bitmaps
Copying Pixel Map Images
Determining Whether QuickDraw Has Finished Drawing
Reporting Data Structure Changes
Obtaining Intermediate Colors
Interpreting New QDError Result Codes
Using a Custom Color Search Function
Summary of Color QuickDraw

—

|

)
2.So
“

©7
=

~

17-1

Y

E

Color QuickDraw

ABOUT

THIS

CHAPTER

This chapter describes extensions to the color facilities of Color QuickDraw™. It discusses

other new features, notably luminance mapping techniques, new routines for copying pixel
maps, extensions to the version 2 picture format, and routines by which existing applications
can signal QuickDraw that a data structure has been modified directly.

To use this chapter, you should be familiar with the Graphics Overview chapter in this
volume and with the Color QuickDraw chapter in Volume V. If you develop graphics cards
and drivers, you should also be familiar with the Slot Manager, Graphics Devices Manager,
and Control Panels chapters in this volume, and with the description of the Slot Manager in
Designing Cards and Drivers for the Macintosh Family, second edition.
If you use offscreen graphics to prepare images before copying them to the screen, read the
Graphics Devices Manager chapter in this volume for a description of new routines that
considerably reduce the complexity of that task.

ABOUT

COLOR

QUICKDRAW

Color QuickDraw in system software version 7.0 supports images that use direct, as well as
indexed, specification of pixels.
Although an application specifies a color in terms of RGB space, the actual value Color
QuickDraw sends to the graphics card frame buffer (video RAM) is an index value, which
is used as input to the color look-up table (CLUT). An 8-bit index can specify 256 different
entries (28 = 256). On CLUT devices, the relationship between the index value and the
color generated depends on the colors and their current locations in the table.
At the cost of larger RAM requirements and, in some situations, slower performance, direct
pixel specification eliminates the need for color table look-ups and inverse tables, and it lets
your application directly specify over 16 million colors. (For a comparison of the differences
between indexed and direct pixels, see the Graphics Overview chapter in this volume.)
In addition to direct pixel specification, Color QuickDraw now provides
w new facilities for copying pixel map records
= support for a true gray-scale display, providing better image fidelity on grayscale devices
= aroutine that converts a bitmap record to a region, allowing you, in effect, to use
region-manipulating routines on bitmap or 1-bit pixel map records
= aroutine that creates pictures with variable dots-per-inch (dpi) resolution

pee

~~]

w four routines that allow you to signal Color QuickDraw when your application directly
modifies a device’s color table, pixel pattern, grafPort, or graphics device record (direct
modification is still discouraged)

O

5
=

©5.
na

About Color QuickDraw

17-3

Y

Inside Macintosh,

Volume VI

The rest of this chapter
m describes the changes to the pixel map record that support direct pixel values, and
presents examples of converting between various pixel depths
= explains the compatibility implications of manipulating QuickDraw data structures
directly, rather than using the routines provided for that purpose, and describes
routines that warn QuickDraw when such a direct change has taken place
m describes new techniques for copying and displaying pixel maps
m describes new routines for converting a bitmap to a region and determining when
drawing to a port has completed
m presents extensions to the version 2 picture format that support direct pixels and store
font and line justification information

DIRECT

PIXELS

Color QuickDraw now supports pixel maps with direct pixel specification as well as the
indexed method supported by the original release of Color QuickDraw. Since QuickDraw has
always striven to be device-independent, many applications need make no changes. If your
application specifies RGB colors, the system determines the best matching colors for indexed
devices and passes your RGB colors to direct devices.
Changes to the Color QuickDraw interface to implement direct pixels affect only these two
color-specification data structures:
m the pixel map record that describes an image
m the version 2 picture format in which images and graphics drawing operations are stored
The new version 2 picture opcodes are described in “Extensions to the Version 2 Picture
Format” later in this chapter; extensions to the pixel map record are described next.

Pixel Map

Record

Extensions

Color QuickDraw supports two new pixel formats corresponding to 16-bit and 32-bit pixel
depths. In both cases, the pixel’s displayed color is directly specified by the pixel value; the
pixel value is not an index into a color table.
Note that the format of a pixel map record is not changed from that introduced with the
Macintosh® II computer, but six pixel map fields can have new values. This chapter
describes only those fields. For a complete description of the pixel map record, see the
Color QuickDraw chapter in Volume V.

17-4

Direct Pixels

Color QuickDraw

TYPE

PixMap

=

RECORD
baseAddr:

Ptr;

{pointer

to

image

data}

rowBytes:

Integer;

{flags,

and

bytes

in

bounds:
pmVersion:

Rect;
Integer;

{boundary
rectangle}
{pixel
map version number}

packType:

Integer;

{packing

format}

packSize:

LongIint;

{size

data

hRes:

Fixed;

{horizontal

vRes:

Fixed;

{vertical

pixelType:

Integer;

{format

pixelSize:

Integer;

{physical

bits

cmpCount:

Integer;

{logical

components

cmpSize:
planeBytes:

Integer;
LongInt;

{logical
bits per component}
{offset
to next
plane}

omTable:

CTabHandle;

{pointer

Longint

{ this
image}
{reserved
for

pmReserved:

of

in

a

row}

packed

state}

resolution}
resolution}

of

pixel

to

image}
per

color

pixel}
per

table

future

pixel}

for

}

expansion}

END;

Field

descriptions

rowBytes

The restriction that the value of rowBytes be less than $2000 has been relaxed:
rowBytes must be less than $4000. The value must be even, and for best
performance it should be a multiple of 4.

pmVersion

The value of pmVersion is normally 0. If pmVersion is 4, Color QuickDraw
treats the pixel map’s baseAddr field as being 32-bit clean. (All other flags are
private.) Most applications never need to set pmVersion.

pixelType

Direct pixel values are specified by a pixelType field value of RGBDirect,
or 16. In a pixel map of the graphics device record for a direct device, the
pixelType field is set to the constant RGBDirect when the screen depth is set.

pixelSize

Pixel sizes must be powers of 2. The original Color QuickDraw supported
pixel sizes of 1, 2, 4, and 8 bits; with direct pixels, pixel sizes may also be 16
and 32 bits.

cmpCount

With indexed pixels, each pixel is a single value representing an index in a
color table, and therefore the cmpCount field of a pixel map record is 1—the
index is the single component. With direct pixels, each pixel contains three
components, one integer each for the intensities of red, green, and blue, so
cmpCount is 3. Other values are undefined.

cmpSize

For an indexed pixel value, which has only one component, the value of
cmpSize is the same as the value of pixelSize: 1, 2, 4, or 8. A 32-bit pixel
consists of three components (red, green, and blue values) of 8 bits each.
Since cmpCount * cmpSize (3 * 8 = 24) is less than the value of pixelSize,
8 bits in the pixel are not part of any component. These bits are unused: Color
QuickDraw sets them to 0 in any image it creates. If presented with a 32-bit
image—for example, in the CopyBits procedure—it passes whatever bits are
there. (Generally, therefore, your application should clear image memory to 0
before creating a 32-bit image.)

—
©)

°
o

©
=E.
re

Direct Pixels

17-5

Y

Inside Macintosh,

Volume V1

A 16-bit pixel consists of three components of 5 bits each. This leaves an
unused high-order bit, which Color QuickDraw sets to 0.
Color QuickDraw expects that the sizes of all components are the same, and
that cmpCount * cmpSize is less than or equal to pixelSize.
In each direct pixel, the pixel value is the concatenation of the red, green, and blue components, where red is in the most significant bits and blue is in the least significant bits. The
entire direct pixel is right aligned; unused bits occupy the highest-order bits.

Direct

Pixel

Values

This section presents some examples of direct pixel values and the results of converting

between direct and indexed pixels. Figure 17-1 shows a 32-bit direct pixel value in which

the pixel and component fields have been set up as
pixelType

=

pixelSize

=

cmpCount

=

cmpSize

=

L&s
32s

{RGBDirect }
{must

be

33
8;

{red,

green,

{8

bits

a

for

power
and

each

of

2}

blue

values}

component }

31

EEREEREEREIEEE
2
| ULE
6
ee
Unused
bits

Red

Green

Figure 17-1.

Blue

A 32-bit direct pixel

In this example, the pixel value (hexadecimal) is $00178609, which deconstructs into

component values of $17 red, $86 green, and $09 blue, resulting in a medium green.
Figure 17-2 approximates the same color as the one in Figure 17-1 using a 16-bit pixel
specified as follows:
pixelType
pixelSize

—
=

16;
16;

{RGBDirect }
{must
be a power

of

cmpCount
cmpSize

=
=

3;
5;

{red,
green,
and
{5 bits
for each

blue values}
component }

15

2}

LILTT
Mt) MTT)
Red

Figure

17-6

Direct Pixels

Green

LLL

17-2. A 16-bit direct pixel

Blue

0

0)

Color QuickDraw

Here the pixel value is $0A01, with component values of $02, $10, and $01 for red, green,
and blue.
When converting a 32-bit pixel value to 16 bits, the 3 least significant bits are dropped for
each component. When converting a 16-bit pixel value to 32 bits, the most significant 3 bits
of each component are replicated and added to constitute the least significant 3 bits of each
8-bit component, as illustrated in Figure 17-3.
15

ONOTe]

Oto
<

Oe

7

.

-

0

.
1

31

!

ERR

ey

BE)

Unused
bits

|

|

a:

Green

Blue

Ue

Red

6s

ee

Figure 17-3. Converting a 16-bit direct pixel to a 32-bit direct pixel
In this way, white remains white, black remains black, and other values are spread evenly.
Figures 17-4 to 17-9 show first how Color QuickDraw converts a full 48-bit RGB color to
32-bit, 16-bit, and 8-bit values (the latter indexed) and then the reverse process of converting
those values back to 48 bits.

A 32-bit direct pixel uses the most significant 8 bits of each component, with 8 unused bits in
the high byte, as shown in Figure 17-4.
16-bit
Red component
$3206
BE)

16-bit
Green component
$9038

OR

i,

Oe

mT

CCCCCCCOICO

Se

eee

G
ees

$32

16-bit
Blue component
$013D

$90

ee

rs
LI

B

eee

hm

i

Coe
$01

Figure 17-4. Converting a 48-bit RGB color to a 32-bit direct pixel

=,

~]

Q

=
o

|

©
=

=
~

Direct Pixels

17-7

Y
c=

Inside Macintosh,

Volume VI

A 16-bit direct pixel uses the most significant 5 bits of each component and has an unused
high bit, as shown in Figure

ae

16-bit
Red component
$3206
69 BEE

SR
Oo ee
$06

17-5.

6m]

16-bit
Green component
$9038
hve Bee

| oe
CC Oe)

16-bit
Blue component
$013D
6s
a

we
ae
foo

$12

$00

Figure 17-5. Converting a 48-bit RGB color to a 16-bit direct pixel
To obtain an 8-bit indexed pixel value from a 48-bit RGB color, the Color Manager determines
the closest RGB value in the CLUT; its index value is stored in the 8-bit pixel. In the standard
8-bit color table, the 'CLUT' resource whose ID is 8, the nearest value to the original RGB
value of Figure 17-4 is in table entry 161, as shown in Figure 17-6. Note that with indexed
pixels, the pixel value has no direct relation to the original RGB value.

_a SEEe

|
!
|
yseiscarmsuneconsanes 161| $3333 $9999 $0000 |
of

{

Figure 17-6. Converting a 48-bit RGB color to an 8-bit indexed pixel

17-8

Direct Pixels

Color QuickDraw

Figure 17-7 shows how Color QuickDraw expands a 32-bit pixel to a 48-bit value by
dropping the unused high byte and doubling each 8-bit component. Note that the resulting
48-bit value differs (in the least significant 8 bits of each component) from the original value
in Figure 17-4.
G

B

$90

CITT

TTT

T ICT

a

1 mT

a

aa

EE

BEE

$01

Tt)

CLL)

=

8

8]

BE

ii

Be

$3232

Be

me

Bees

$9090

|

Be

CN

$0101

Figure 17-7. Converting a 32-bit pixel to a 48-bit RGB color
Color QuickDraw expands a 16-bit pixel to a 48-bit RGB color by dropping the unused high
bit and inserting three copies of each 5-bit component and a copy of the most significant bit
into each 16-bit component of the destination value. Note that the result differs (in the least
significant 11 bits of each component) from the original value.

G
$12

Je
ae

ee
6S.

Eee,
ee
6)

$318C

ee

2

et 628)
$9495

B
$00
HA

2

.
5
| eee

:

$0000

Figure 17-8. Converting a 16-bit pixel to a 48-bit RGB color

—

I
OQ
ct
i)

Lew

Direct Pixels

17-9

{

(>)
zh
a
ea
o
ne

=

Inside Macintosh,

Volume VI

Color QuickDraw expands an 8-bit indexed pixel to a 48-bit RGB color by taking the 48-bit
value pointed to in the CLUT, as shown in Figure 17-9. The difference between this value
and the original 48-bit value varies, depending on the CLUT values.

Lammers coms « 161|_

$3333 $9999 $0000

_|——> $3333 $9999 $0000

Figure 17-9. Converting an 8-bit indexed pixel to a 48-bit RGB color

WRITING

COMPATIBLE

GRAPHICS

APPLICATIONS

Over the years, some developers have written applications that modify the QuickDraw data
structures directly, rather than using the routines provided for that purpose. Then, when
engineers at Apple Computer, Inc., improve QuickDraw, the applications break. As
QuickDraw, graphics applications, and cards such as graphics accelerators grow more
complex, the problem becomes acute. This section points to new routines you can use to
signal QuickDraw when your application modifies certain data structures directly so that
QuickDraw can take note and act accordingly.
Applications should not directly change fields in graphics data structures, but should use the
following routines instead:
AddComp
AddSearch
BackColor
BackPat
BackPixPat
CharExtra
ClipRect
17-10

ColorBit
CopyPixPat
DelComp
DelSearch
ForeColor
GrafDevice
HideCursor

Writing Compatible Graphics Applications

HidePen
HiliteColor
MakeRGBPat
Move
MovePortTo
MoveTo
ObscureCursor

Color QuickDraw

OpColor

SetCCursor

SetPortBits

PenNormal

SetClip

ShowCursor

PenMode
PenPat

PenPixPat
PenSize

PortSize

RGBBackColor
RGBForeColor

SetClientID
SetCursor

SetDeviceAttribute

SetPortPix
ShowPen

SpaceExtra

SetGDevice

TextFace

SetPenState
SetPort

TextMode
TextSize

SetOrigin

TextFont

Using these routines rather than directly modifying the data structures ensures that your application will fully benefit from any future improvements to QuickDraw. In particular, the offscreen graphics world routines described in the Graphics Devices Manager chapter of this
volume remove much of the need for directly modifying graphics data structures.
Apple Computer, Inc., strongly recommends that new applications follow these guidelines;
asynchronously operating graphics cards especially need close cooperation with QuickDraw.
It is possible to make existing applications more compatible by calling one of the following
procedures after directly changing a QuickDraw data structure and before calling any other
QuickDraw routine:
CTabChanged
PixPatChanged
PortChanged
GDeviceChanged
These procedures inform QuickDraw that a direct modification has occurred so it can update
its tracking of the graphics environment. They are described in “Reporting Data Structure
Changes” later in this chapter.

USING

COLOR

QUICKDRAW

If your application uses color in straightforward ways, it will probably execute without
change in a direct pixel environment.
For most other applications, the main concern is in the creation and use of special-purpose
pixel map and graphics device records. By using the offscreen graphics world routines
described in the Graphics Devices Manager chapter in this volume, you will find such tasks
far easier than before.
If you must work with color grafPort, pixel map, and graphics device records in ways
beyond the scope of the offscreen graphics world routines, the following guidelines may
aid you in adapting to Color QuickDraw’s direct pixel environment:
= Don’t draw directly to the screen. Create your own offscreen graphics world, as
described in the Graphics Devices Manager chapter in this volume, and use the
CopyBits, CopyMask, or CopyDeepMask routine.

—

~]

Q

—}
yy

ll
Lea |

©Q
==
a

Using Color QuickDraw

17-11

~)
aS
an

=

Inside Macintosh,

Volume

VI

a Don’t directly change the fgColor or bkColor field of a grafPort and expect them to be
used as the pixel values. Color QuickDraw recalculates these values for each device. If
you really want to draw in an index instead of a color, use a palette with explicit colors,
as described in the Palette Manager chapter in this volume. For device-independent
colors, use the RGBForeColor and RGBBackColor procedures.
m Fill out all the fields in a new pixel map record. The NewPixMap function returns a
pixel map record that is cloned from the pixel map record pointed to by theGDevice. If
you don’t want a copy of the main screen’s pixel map record—for example, you want
one that is a different depth—then you must fill out more fields than just pixelSize: you
must fill out the pixelType, cmpCount, and cmpSize fields. Set pmVersion to 0 when
initializing your own pixel map record. For future compatibility you should also set
packType, packSize, planeBytes, and pmReserved to 0.
m

Don’t clone a graphics device record’s pixel map record. Instead, use the NewPixMap
function or the CopyPixMap procedure. If you must create or manually clone a pixel
map record, make sure to set the pmVersion field and other unused fields to 0 for future
compatibility.

= Fill out all the fields of a new graphics device record. When creating an offscreen
graphics device record by calling NewGDevice with the mode parameter set to —1, you
must fill out the fields of the graphics device record (for instance, gdType) yourself. If
you want a copy of an existing graphics device record, then copy the gdType field from
it. If you explicitly want an indexed device, then set gdType to 0.
m

Don’t assume a pixel map record has a color table. A direct pixel map record need
not have a color table. For compatibility, a direct pixel map record should have a
dummy pmTable handle that points to a color table header with a seed value equal to
cmpSize * cmpCount, and the color table’s ctSize field should be set to 0.

Again, all these problems are simplified if you use the offscreen graphics world routines.

Manipulating

Pixel

Map

Images

QuickDraw’s facilities for copying pixel maps continues to evolve. With system software
version 7.0, the CopyMask procedure has been expanded, and a new routine, CopyDeepMask,
combines the functions of CopyBits and CopyMask. In addition, colorizing (copying a blackand-white image with the foreground or background set to a color) now is done in RGB space,
and the classic transfer modes OR, BIC, and XOR work correctly with colored images.

Copying

With

Masks

One step in the evolution of QuickDraw’s copying facilities came with the introduction of
Color QuickDraw, when the original CopyBits procedure, which copied a bitmap using a
transfer mode and a region mask, was modified so that a pixel map could be copied by the
same method, as shown in Figure 17-10.

17-12

Using Color QuickDraw

Color QuickDraw

| Pixel depth i
4

Rectangle

‘ail

Convert

—

aad

1|

Sat

{ Pixel depth

rgbFgColor and

|

Rectangle

——

rgbBkColor

from current

grafPort (thePort)

=

<—|

parameter

J

Transfer
mode

1

gdiTable and
gdSearchProc from
current graphics
device (theGDevice)

Device
color
{|

Resulting
K

1

visRgn and

clipRgn from

current grafPort
(thePort)

a

©

_

=

), Pixel map’

|)

g Image data J

f)

Region

i“

Figure 17-10.

Copying pixel maps with CopyBits

The CopyMask procedure, introduced with the Macintosh Plus computer, allowed a
bitmap to act as a mask when copying bitmaps. With system software version 7.0, the
ae

a |

o

~
—
—
=

“|
=

ar

©

an

Using Color QuickDraw

— 17-13

mel

Ne!
-y

~

a

<

Inside Macintosh,

Volume VI]

Copy Mask procedure has been expanded to allow a pixel map to be the mask, as shown
in Figure 17-11 and Color Plate XXIII, “Copying With a Pixel Map as a Mask”.

io.
{

| Pixel depth

Rectangle

|

|

+ Pixel depth |
| Rectangle |
oe

rgbFgColor and
rgbBkColor
from current

[peers
[Image data |

grafPort (thePort)

| Image data
bes

s

_

at

a eee ail

gdiTable and
gdSearchProc from
current graphics
device (theGDevice)

Figure 17-11.

17-14

— Using Color QuickDraw

visRgn and
clipRgn from
current grafPort
(thePort)

Device
color
1}

Copying pixel maps with CopyMask

Color QuickDraw

A new procedure, CopyDeepMask, combines the functions of CopyBits and CopyMask.
With CopyDeepMask you can supply a pixel map mask as well as copy modes and a mask
region, as shown in Figure 17-12.

jource pixel map
r
—

[ Pixel depth
_ Rectangle

rgbFgColor and
rgbBkColor
from current

grafPort (thePort)

t]

visRgn and
clipRgn from
current grafPort
(thePort)

'
Region
parameter

Transfer
mode

gdiTable and

gdSearchProc from
current graphics
device (theGDevice)

Device
iF

4

Figure 17-12.

Resulting _
pixel map —

=

~I

Q
S
)
=
©

Copying pixel maps with CopyDeepMask
Using Color QuickDraw

=o

— 17-15

Be
o
=
$9
2

Inside Macintosh,

Volume

V1

Note: Pixel map records are always copied using the color table of the source pixel
map for source information, and the color table of the current graphics device record
for destination color information. (The color table attached to the destination pixel
map is ignored.) If you need to copy to an offscreen pixel map with characteristics
differing from those of the current graphics device (usually the main screen), you
should create an appropriate offscreen graphics device record and set it as the current
graphics device before the copy operation. (See the Graphics Devices Manager
chapter in this volume for information about offscreen graphics.)
When the pixel map mask is | bit deep, it has the same effect as a bitmap mask: a black mask
bit means that the pixel is to take the source value; a white mask bit means that the pixel is to
take the destination value. Intermediate values in deeper pixel map masks specify that a
weighted average is to be taken between the source and destination pixel maps. Within each
pixel, the calculation is done in RGB space, on a color component basis. A gray pixel map
mask, for example, works like blend mode in a CopyBits procedure. A red mask (high values
for the red component in all pixels) filters out red values coming from the source pixel map.

Colorizing
Setting either the foreground or background (or both) to colors other than black and white

before executing a CopyBits procedure results in colorizing effects. Before system software version 7.0, the colorizing was done by indexes, yielding arbitrary results unless the
color table had been arranged carefully. Now your application can colorize pixels in RGB
space (where $FFFF represents the full intensity of a component), so that setting the foreground to blue and the background to red, for example, turns a gray-scale image into
appropriate shades of blue and red. See Color Plate XXIV, “Colorizing.”
You can decide what to do with source pixels on a color component basis. Your application can
m pass a pixel’s component, unchanged, by setting the foreground for that component to

$0000 and the background to $FFFF

m invert them by setting the foreground for that component to $FFFF and the background

to $0000

m zero them by setting both foreground and background for that component to $0000
a force them to | by setting both the foreground and background for that component

to $FFFF

Note that arithmetic transfer modes have no colorizing effect.

Transfer

Modes

The classic transfer modes OR, BIC, and XOR, which previously were problematic with
color images, now work as you would expect:
m Using the OR mode when you copy an image you are transferring to a white
background always results in the source image, regardless of the destination depth.
=

17-16

Using the BIC mode when you copy an image causes black in the source image to
erase, resulting in white in the destination image.
Using Color QuickDraw

Color QuickDraw

= The XOR mode inverts black in the source image but not white, at all destination
depths, including 16-bit and 32-bit direct pixels.
When you work with color pixels, transfer modes produce different results on indexed and
direct devices.
You can use a new text drawing mode, grayishTextOr, to draw dimmed text on the screen. If
the destination device is color, it draws with a blend of the foreground and background colors.
If the destination device is black and white, the grayishTextOr mode dithers black and white.
Note that grayishTextOr is not a standard transfer mode in that currently it is not stored in
pictures and printing with it is undefined. (It does pass through the bottleneck procedures.)
The primary use for grayishTextOr is to display disabled user interface items.

Dithering
The CopyBits and CopyDeepMask procedures can now use dithering, a technique of
mixing existing colors to create the effect of additional colors.
CONST

ditherCopy

=

64;

{dithering

flag

for

CopyBits}

If you copy using dithering, then the CopyBits and CopyDeepMask procedures do their best
to provide error diffusion during the copy operation. As with arithmetic transfer modes,
dithering ignores hidden colors. Therefore, when you copy to an indexed device, color
matching is limited by the resolution of the inverse table for the destination graphics device.
(See the section “Inverse Tables” in the Color Manager chapter of Volume V.) Dithering
provides good results for most images—for example, it allows you to shrink images more
efficiently. However, dithering does have drawbacks: it is slower, and because of error
diffusion, a clipped dithering operation does not provide pixel-for-pixel equivalence to the
same unclipped dithering operation. Clipped XOR dithered copies, for example, do not
perform as erase operations.
Currently, if a color search procedure is present, CopyBits and CopyDeepMask use plain
copy mode instead of dithering. (This may change in future versions.)
Using plain copy mode (without dithering), your application does color mapping on a pixelby-pixel basis—no errors are accumulated, and hidden colors are ignored. If the source
pixel map is indexed and a color search procedure is present, Color QuickDraw calls the
procedure once for each color in the color table. If the source is a direct pixel map and a
search procedure is present, the procedure is called once for each color in the source pixel
map. (With a source pixel map of many colors, this can take a long time.)
Color QuickDraw never uses dithering if you copy to a direct pixel map, but you can always
use dithering when copying to an indexed pixel map.

Resizing

Images

—_"
|

When copying from direct pixel maps, if the destination rectangle is smaller than the source
rectangle, Color QuickDraw uses an averaging technique to produce the destination pixels,
maintaining high-quality images when shrinking them.

©)

=

=
©

a.
OQ
=

Using Color QuickDraw

— 17-17

S|
=<

Inside Macintosh,

Volume

V1

Color QuickDraw also averages pixels when shrinking indexed images using dithering.
Shrinking |-bit images using dithering can produce much better representations of the
original images than without using dithering.

Luminance

Mapping

When Color QuickDraw displays a color on a gray-scale device, it computes the luminance,
or intensity of light, of the desired color and uses that value to determine the appropriate gray
value to draw. A gray-scale device can be a color device that the user sets to gray-scale mode;
for such a device, Color QuickDraw places an evenly spaced set of grays, forming a linear
ramp from white to black, in the device’s CLUT. A gray-scale device can also be a device
whose color table consists only of grays if the animated entries are not counted.
To facilitate the creation of gray-scale devices, the GetCTable function has been enhanced to
recognize additional standard color table IDs. As described in the Color QuickDraw chapter
of Volume V, the GetCTable function looks like this:
FUNCTION

GetCTable

(ctID:

Integer)

:

CTabHandle;

You can obtain the default gray-scale color table for a given pixel depth by calling GetCTable
with a ctID value of pixelSize + 32 (decimal), as shown in Table 17-1.
Table 17-1.

The default color tables for gray-scale devices

pixelSize

ctID

Color table
composition

l
2
4
8

33
34
36
40

Black,
Black,
Black,
Black,

white
33% gray, 66% gray, white
14 shades of gray, white
254 shades of gray, white

You can obtain the equivalent default color tables by adding 64 to the pixel depth, as shown
in Table 17-2. (For more information, see the Palette Manager chapter in this volume.)
Table 17-2.

The default color tables for color devices

pixelSize

ctID

Color table
composition

66
68
ae

Black, 50% gray, highlight color, white
Black, 14 colors including a highlight color, white
Black, 254 colors including a highlight color, white

2
+
8

Image

Resolution

Color QuickDraw supports pixel maps of resolutions other than 72 dpi. In the past, applications have accepted pixel maps of a certain number of rows and columns and assumed that
they were generated on a 72-dpi device. Such pixel maps were usually copied and printed at
a 72-dpi resolution, lending the impression that QuickDraw could not handle pixel maps of
higher density.
17-18

Using Color QuickDraw

Color QuickDraw

With the advent of frame grabbers and scanners, many pixel maps have dpi resolutions of
150, 200, 300, or greater. A user expects pixel maps to display an approximation of the
information on a 72-dpi display but to print on a higher resolution device to the best of the
device’s ability.

Displaying

Variable-Resolution

Pixel

Maps

and

Pictures

The resolution of a pixel map record, measured in dpi, is contained in its hRes and vRes
fields. These values are expressed as fixed-point integers.
When importing a picture, your application should check the picture type to see if it was
created with the OpenCPicture function, which stores the hRes and vRes values in the

picture header. See the Picture Utilities Package chapter in this volume for information on
determining a picture’s characteristics.
An alternative is to replace the StdBits bottleneck procedure (from the grafProcs field in the
color grafPort record) during playback. When QuickDraw calls your StdBits procedure,
you should
1. make sure the source is a pixel map record by checking that the high bit of the rowBytes
field is set
2. read the hRes and vRes information from the source pixel map record (At this point, the
source rectangle field indicates the size of the source in pixels at the resolution specified
by the hRes and vRes fields.)

To display a picture at another resolution, your application should compute the destination
rectangle field value appropriately. For example, if the source resolution is 300 dpi and you
want to display it at 75 dpi, then your application should compute the destination rectangle
width and height as !/4 of that of the source rectangle.

Exporting

Pixel Map

Records

When exporting pixel map records, your application should ensure that the hRes and vRes
fields accurately reflect'the image data. During picture recording, the destination rectangle of
the CopyBits procedure should be appropriate for display at 72 dpi. If you want an entire
picture to be a different resolution, use the OpenCPicture function.

Converting

a Bitmap

to a Region

A new function, BitMapToRegion, converts a bitmap to a region, allowing your application to use Color QuickDraw’s region manipulation routines on the converted bitmap. If
you use the PaintRgn procedure on the converted region, the resulting region is the same
as the bitmap.
The BitMapToRegion procedure may be useful if you want to test for mouse clicks on the
black pixels in a bitmap, or drag the outline of a bitmap using DragGrayRegion, described in
the Window Manager chapter of Volume V.

—

~I

2
=
=

©

E.
a
o
%,
<
=

Using Color QuickDraw

— 17-19

Inside Macintosh,

Volume VI

Determining

Whether

Drawing

Is Complete

A new function, QDDone, checks to see whether QuickDraw drawing operations have

finished in a grafPort. This function is useful if your application is executing in an
environment with a graphics accelerator, where drawing operations may proceed
asynchronously.

EXTENSIONS

TO

THE

VERSION

2 PICTURE

FORMAT

The version 2 picture format presented in the Color QuickDraw chapter of Volume V has
been extended: four opcodes previously listed as reserved have been defined, and one defined
opcode has been redefined.
= Opcode $002C signals font name information.
a Opcode $002D signals line justification spacing information.
= Opcodes $009A and $009B now define direct pixel pictures, with pixel maps containing
three components that directly specify RGB values.
ma Opcode $0C00 still signifies a header record, and it is still 24 bytes in size, but its
contents have changed.
This section describes the new version 2 picture opcodes and presents a sample version 2
picture file. The five changed opcodes are shown in Table 17-3.
Table 17-3.

The new version 2 picture opcodes

Opcode

Name

Description

$002C

fontName

Data length (word), old font ID
(word), name length (byte), font

5 + name length

Opcode + operand data length
(word), intercharacter spacing

10

Data size
(in bytes)

name

$002D

lineJustify

(fixed), total extra space for
justification (fixed)

$009A

DirectBitsRect

pixMap, srcRect, dstRect, mode
(word), pixData

[variable]

$009B

DirectBitsRgn

pixMap, srcRect, dstRect, mode
(word), maskRgn, pixData

[variable]

$0CO00

HeaderOp

Version (word), reserved (word),
hRes, vRes (Fixed), srcRect
(Rect), reserved (long)

24

17-20

Extensions to the Version 2 Picture Format

Color QuickDraw

Font

Name

The font name information begins with a word containing the field’s data length, followed by
a word containing the old font ID, a byte containing the length of the font name, and then the
font name itself.
You can extract font names, IDs, and other information from a picture by using the Picture
Utilities Package, described in this volume.

Line

Justification

The line justification information contains the line-layout state of the Script Manager so that it
can be restored when the picture is played back. It begins with a word containing the field’s
data length, which should always be 8 bytes. The operands are two fixed-point values,
describing the Script Manager’s extra character width value and the total extra width that was
added to the style run (each StdText call) to perform justification.
For example, if the intercharacter spacing were | pixel and the total extra width added were
10 pixels, the following hexadecimal bytes would be generated for the picture:
2D

00

08

00

01

00

00

00

OA

OD

0D

In this example, the $002D opcode is followed by the length word, 00 08, and then the integer part of the intercharacter spacing, 00 01, its fractional part, 00 00, and then the integer
part of the total extra spacing, 00 OA, and its fractional part, 00 00.

Direct

Pixel

Images

The version 2 picture format defined for the original Color QuickDraw only supports images
consisting of color table indexes. In system software version 7.0, the version 2 picture
format can also record images with pixels that directly specify a given color. To the current
imaging opcodes BitsRect, BitsRgn, PackBitsRect, and PackBitsRgn, Color QuickDraw
adds DirectBitsRect and DirectBitsRgn. These opcodes allow your application to cut, paste,
and store images with up to 32 bits of color information per pixel.
Unlike previous opcodes, DirectBitsRect and DirectBitsRgn store the baseAddr field of the
pixel map structure in a version 2 picture. For compatibility with existing systems, the
baseAddr field is set to $OOOOOOFF. Monochrome machines can display pixel maps that are
in pictures. On systems without direct pixel support, opcodes $009A and $009B read a word
from the picture and then skip a word of data. The next opcode retrieved from the picture is
$00FF, which terminates picture playback. (Note that if you play back a picture on a machine
without direct pixel support, it terminates picture parsing.)
The DirectBitsRect opcode is followed by this structure:
pixMap:

{described

later}

srcRect:

Rect;

{source

dstRect:

Rect;

{destination

mode:
pixData:

fode;

{transfer
mode}
{described
later}

—

~]

rectangle}

©

rectangle}

©

==
a

Extensions to the Version 2 Picture Format

17-21

S

85
<

<

Inside Macintosh,

Volume V1

The DirectBitsRgn opcode is followed by this structure:
pixMap:

{described

later}

srcRect:
dstRect:

Rect;
Rect;

{source
rectangle}
{destination
rectangle}

mode:

Mode;

{transfer

maskRgn:

Region;

{region

pixData:

mode}

for

masking}

{described

later}

In a picture, the packType field of a pixel map specifies the manner in which the pixel data
was compressed. To facilitate banding of images when memory is short, all data compression
is done on a scan-line basis. The following pseudocode describes the pixel data.
pixData:
If

packType
data

If

packType

=

=

32-bit
data
If

packType

1

size
2

(unpacked)

or

rowbytes

=

*

(bounds.bottom

rowBytes

(drop

direct
size
>

2

=

pad

byte)

pixel
(3/4)

(packed)

is
*

then

then
-

data

is

unpacked,

and

bounds.top);

high-order

pad

byte

of

a

(bounds.bottom

-

bounds.top);

then

contains

(bounds.bottom

Each

scan

line

consists

rowBytes

>

250

8

and

*

Image

If

the

dropped,

rowBytes

<

then

of

-

bounds.top)

[byteCount]

byteCount

is

a

packed

scan

lines

[data].

word,

else

it

is

a

byte.

Here are the currently defined packing types.
Packing
type

Meaning

0

Use default packing

l

Use no packing

2

Remove pad byte—supported only for 32-bit pixels (24-bit data)

3

Run length encoding by pixelSize chunks, one scan line at a time—
supported only for 16-bit pixels

4

Run length encoding one component at a time, one scan line at a
time, red component first—supported only for 32-bit pixels (24-bit data)

For future compatibility, other packType values skip scan-line data and draw nothing. Since
Color QuickDraw assumes that pixel map data in memory is unpacked regardless of the
packType field value, you can use packType to tell the picture-recording mechanism what
packing technique to use on that data. A packType value of 0 in memory indicates that the

17-22

Extensions to the Version 2 Picture Format

Color QuickDraw

default packing scheme should be used. (Using the default packing scheme is recommended.)
Currently, the default packType value for a pixelSize value of 16 is type 3; for a pixelSize
of 32, it is type 4. Regardless of the setting of packType at the time of picture recording, the
packType value actually used to save the image is recorded in the picture.
Since each scan line of packed data is preceded by a byte count, packSize is not used and
must be 0 for future compatibility.
When the pixel type is direct chunky, cmpCount * cmpSize is less than or equal to
pixelSize. For storing 24-bit data in a 32-bit pixel, set cmpSize to 8 and cmpCount to 3.
If you set cmpCount to 4, then the high byte is compressed by packing scheme 4 and
stored in the picture.
A new routine, the OpenCPicture function, lets your application create a version 2 format
picture and include rectangle and resolution information, which is stored in the version 2
picture header. This provides a simple mechanism for creating images with spatial resolution other than 72 dpi. The OpenCPicture function is described in “Creating an Extended
Version 2 Picture” later in this chapter.
The HeaderOp information is passed to the OpenCPicture function as an OpenCPicParams
record, which has this structure:
TYPE

OpenCPicParams

=

RECORD
srcRect:

Rect;

{source
{

at

rectangle

hRes,

vRes

for

best

display

}

resolution}

hRes:

Fixed;

{best

horizontal

vRes:

Fixed;

{best

vertical

resolution}

version:

Integer;

{set

to

reservedl:

Integer;

{reserved

for

future

use}

reserved2:

LongiInt

{reserved

for

future

use}

resolution}

-2}

END;

Note that in the header to a version 2 picture the information is reordered, and appears in
this format:
TYPE

PictureHeader

=

RECORD

version:
reservedl:
hRes:

Integer;
Integer;
Fixed;

{set
to -2}
{reserved
for future use}
{best
horizontal
resolution}

vRes:

Fixed;

{pest

srcRect:

Rect;

{source
rectangle
{ display
at hRes,

reserved2:

LongiInt

{reserved

vertical

for

resolution}
for best
}
vRes
resolution}

future

use}

END;
—
~]

QO—

=
©
=
‘=
>

Extensions to the Version 2 Picture Format

1-23

~)

ae |

+S)

=

Inside Macintosh,

Sample

Volume VI

Extended

Version

2 Picture

An example of an extended version 2 picture that can display a single direct pixel image is
shown in Table 17-4.
Table 17-4.
Opcode size
(in bytes)
2
8

Version 2 picture example
Name

Description

picSize
picFrame

Low word of picture size
Rectangular bounding box of picture, at
72 dpi

FNAWHANNNMNNY

Picture Definition Data:
versionOp

Bitmap opcode = $009A for direct pixels

baseAddr

LY

de

HANNON

rowBytes
bounds
pmVersion
packT ype
packSize
hRes

N

17-24

opBitsRect

version
reserved
hRes
vRes
srcRect
reserved

MN

NeCOABGNnNA
Nl

8 *

HeaderOp

Version opcode = $001 1
Version number = $02FF
Header opcode = $0C00

version

(ctSize+ 1)

Set to —2 for extended version 2 picture file
Reserved for future Apple use
Native horizontal resolution
Native vertical resolution
Native source rectangle
Reserved for future Apple use
For direct pixels must be $000000FF (see “Direct Pixels”
earlier in this chapter)
Integer, must have high bit set to signal pixel map
Rectangle, boundary rectangle at source resolution
Integer, pixel map version number = 0
Integer, defines packing format
Long integer, length of pixel data = 0
Fixed, horizontal resolution (dpi) of source data,
normally $00480000 (72 dpi)

vRes

Fixed, vertical resolution (dpi) of source data,

pixelType
pixelSize
cmpCount
cmpSize
planeBytes
pmTable
pmReserved
ctSeed
ctFlags
ctSize
ctTable
srcRect
dstRect
mode
pixData
endPICTop

Integer, defines pixel type; 16 for direct pixels
Integer, number of bits in pixel; 16 or 32 for direct pixels
Integer, number of components in pixel; 3 for direct pixels
Integer, number of bits per component; 5 or 8 for direct pixels
Long integer, offset to next plane = 0
Color table = 0
Reserved = 0
Long integer, color table seed
Integer, flags for color table
Integer, number of entries in ctTable — |
Color table data
Rectangle, source rectangle at source resolution
Rectangle, destination rectangle at 72-dpi resolution
Integer, transfer mode
Pixel data (see “Direct Pixels” earlier in this chapter)
End-of-picture opcode = $00FF

normally $00480000 (72 dpi)

Extensions to the Version 2 Picture Format

Color QuickDraw

COLOR

QUICKDRAW

ROUTINES

Since recognizing direct pixel values only requires internal Color QuickDraw changes, no
new routines are defined for direct pixel specification.

Creating

an Extended

Version

2 Picture

OpenCPicture performs the same functions as OpenPicture, except that it creates an extended
version 2 format picture, with pixel resolution and the best imaging rectangle stored in
the header. OpenCPicture works on all Macintosh computers running system software
version 7.0, including machines without Color QuickDraw.
FUNCTION

OpenCPicture

(newHeader:

OpenCPicParams)

:

PicHandle;

Use the newHeader parameter to describe the rectangle that encloses the drawing information you supply for the picture and to describe the best horizontal and vertical resolutions for
displaying the picture in the rectangle. See “Direct Pixel Images” earlier in this chapter for a
description of the OpenCPicParams data type.
As with OpenPicture, you close the picture using ClosePicture, and draw it using DrawPicture.

Creating

Regions

From

Bitmaps

You can convert bitmaps or pixel maps to regions using the BitMapToRegion function.
FUNCTION

BitMapToRegion

(region:

RgnHandle;

bMap:

BitMap)

:

OSErr;

The region parameter must be a valid region handle created with a NewRgn function. The old
region contents are lost.
The bMap parameter may either be a bitmap or pixel map record. If you pass a pixel map
record, its pixel size (bits per pixel) must be 1.
Result codes

pixmapTooDeepErr
renTooBigErr

Copying

Pixel

Map

—148
—500

Pixel map record is deeper than | bit per pixel
Bitmap would convert to a region greater
than 64 KB

Images

The CopyDeepMask procedure combines the effects of the CopyBits and CopyMask
procedures.
PROCEDURE

CopyDeepMask

(srcBits:
BitMap;
BitMap;
srcRect:
Rect;

mode:

som

~—I

maskBits:
BitMap;
dstBits:
Rect;
maskRect:
Rect;
dstRect:

Integer;

maskRgn:

RgnHandle) ;

s

So

Lee

©

=iy
~_

Color QuickDraw Routines

— 17-25

>$5
=

Inside Macintosh,

Volume VI

The CopyDeepMask procedure copies the source bitmap or pixel map to a destination bitmap
or pixel map, using a bitmap or pixel map as a mask. The transfer can be performed in any of
the copy modes described in the QuickDraw chapters of Volume I and Volume V of Inside

Macintosh, with or without ditherCopy set, as described earlier in this chapter.

The result is clipped to the mask region and the boundary rectangle of the destination. The
source and mask rectangles should be the same size. The mask rectangle selects the portion
of the mask pixel map to use as the mask. If you don’t want to clip to a mask region, pass

NIL for the maskRgn parameter. The dstRect and maskRgn coordinates are in the destination

coordinate system; the srcRect coordinates are in the source coordinate system; the maskRect

coordinates are in the mask coordinate system.

All three pixel maps may range from | to 32 in pixel depth. The pixel values of the mask
pixel map are applied as a filter between the source and destination pixel maps. A black mask
pixel value means that the copy operation is to take the source pixel; a white value means that
the copy operation is to take the destination pixel. Intermediate values specify a weighted
average, which is calculated on a color component basis. For each pixel’s color component
the calculation is
(1 — mask) * source + (mask) * destination

Thus high mask values for a pixel’s color component reduce that component's contribution
from the source pixel map.
As with the CopyMask procedure, CopyDeepMask calls are not recorded in pictures, and do
not print. The mask pixel map cannot come from the screen.

Determining

Whether

QuickDraw

Has

Finished

Drawing

You can use the QDDone function to ensure that all drawing is done and avoid the possibility
that new drawing operations might be overlaid by previously issued but unexecuted operations. This function is especially useful if a graphics accelerator is present and operating
asynchronously.
FUNCTION

QDDone

(port:

GrafPtr)

:

Boolean;

The QDDone function returns TRUE if drawing operations have finished in the designated
graphics port, FALSE if any remain to be executed. If you pass NIL as the port parameter,
then QDDone returns TRUE only if drawing operations have completed in all ports. (If a port
has a clock or other continuously operating process, QDDone may never return TRUE.)

Reporting

Data

Structure

Changes

You can use the following routines to mitigate possible side effects of directly changing a
color table, pixel pattern, grafPort, or graphics device record.
PROCEDURE

CTabChanged

(ctab:

CTabHandle) ;

Call CTabChanged after modifying the content of the color table specified by the ctab
parameter. CTabChanged calls GetCTSeed to get a new seed (a unique identifier) for the
color table and notifies QuickDraw of the change.
17-26

Color QuickDraw Routines

Color QuickDraw

PROCEDURE

PixPatChanged

(ppat:

PixPatHandle) ;

Call PixPatChanged after modifying either the pixel pattern record specified by the ppat
parameter or any of its substructures (pattern map or pattern data records). PixPatChanged
sets the patX Valid flag to —1 and notifies QuickDraw of the change.
If your application changes the pmTable fie/d of the pattern map’s pixel pattern, it should call
PixPatChanged. However, if your application changes the content of the color table referenced by the pixel map’s pmTable field, it should call CTabChanged as well.
PROCEDURE

PortChanged

(port:

GrafPtr);

Call PortChanged after modifying the content of a grafPort or any of its substructures.
PortChanged notifies QuickDraw of the change.
You should not directly change any of the pixel pattern records pointed to by a color grafPort
record. Instead, use the PenPixPat and BackPixPat procedures. However, if your application
changes the content of one of the pixel pattern records, it should call PixPatChanged.
If your application changes the pmTable field of the port’s pixel map, it should call
PortChanged. However, if your application changes the content of the color table referenced by pmTable, it should call CTabChanged as well.
PROCEDURE

GDeviceChanged

(gdh:

GDHandle);

Call GDeviceChanged after modifying the graphics device record specified by the gdh
parameter or any of its substructures. GDeviceChanged notifies QuickDraw of the change.
If your application changes the pmTable field of the graphics device’s pixel map, it should
call GDeviceChanged. However, if your application changes the content of the color table
referenced by gdPMap, it should call CTabChanged as well.

Obtaining

Intermediate

Colors

The GetGray function provides your application with the best intermediate color in RGB
space that is available for a given device.
FUNCTION

GetGray

(device:
GDHandle;
backGround:
RGBColor;
VAR
foreGround:
RGBColor)
: Boolean;

In the device parameter you supply a handle to the device; in the backGround and foreGround
parameters you supply the two colors for which you want the best intermediate RGB color.
One use for GetGray is to return the best gray, as when dimming a menu item: supply black
and white as the two colors, and GetGray returns the best available gray that lies between them.
—

i |

If no gray is available (or, if you supplied two colors, no distinguishable third color is

available), the foreGround parameter is unchanged, and the function returns FALSE. If at

least one gray or intermediate color is available, it or the best one is stored in the foreGround
parameter, and the function returns TRUE.

-Q
—
o
=
(2)

=
Oo

x

Color QuickDraw Routines

— 17-27

-)
=
PS)
=

Inside Macintosh,

Volume VI

Interpreting New

QDError

Result

Codes

The QDError function, introduced with Color QuickDraw in Volume V, returns the error
result from the last Color QuickDraw or Color Manager call. It has a number of new result
codes, and it has also been modified so that it does not fail on a black-and-white system
(where it always returns FALSE). Its format is the same:
FUNCTION

QDError

:

Integer;

QuickDraw uses stack space for work buffers. For complex operations such as depth

conversion, dithering, and image resizing, stack space may not be sufficient. Color

QuickDraw now attempts to get temporary memory from other parts of the system. If
that is still not enough, QDError returns this code:
mfStackErr

—149

Insufficient stack

If your application receives this result code, divide the operation—for example, divide the
image into left and right halves—and try again.
When you record drawing operations in an open region, the resulting region description may
overflow the 64 KB limit. Should this happen, QDError returns —147.
regionTooBigError

—-147

Region too big or complex

Since the resulting region is potentially corrupt, the closeRgn procedure returns an empty
region if it detects QDError has been set to —147. A similar error can occur during conversion
of a bitmap to a region.
rgnTooBigErr

—500

Bitmap would convert to a region greater than 64 KB

The BitMapToRegion function can also generate an error if a pixel map is supplied that is
greater than | bit per pixel.
pixmapTooDeepErr

—-148

Pixel map record is deeper than | bit per pixel

You may be able to recover from this problem by imaging your too-deep pixel map into a
|-bit pixel map and calling BitMapToRegion again.

Using a Custom

Color Search

Function

The interface to the custom color search mechanism, described in the Color Manager chapter
of Volume V, omitted a VAR tag for the rgb parameter. The Color Manager’s SearchProc
function description looks like this:
FUNCTION

SearchProc

(VAR

rgb:

RGBColor;

VAR

position:

LongInt)

:

Boolean;

This means that your custom search procedure can manipulate a color in some way, darkening
it, for example, then return it. Setting the function result to FALSE causes the Color Manager
to ignore the position parameter and perform its standard look-up on the altered color.

17-28

— Color QuickDraw Routines

Color QuickDraw

SUMMARY

OF

COLOR

QUICKDRAW

Constants
CONST

Data
TYPE

{new constants
ditherCopy

for Color QuickDraw}
= 64;
{dither mode

RGBDirect

=

16;

{16

grayishTextOr

=

49;

{draw

&

32

for

CopyBits}

bits/pixel

with

grayed

pixelType

value}

text}

Types
PixMapHandle

=

*PixMapPtr;

PixMapPtr

=

*“PixMap;

PixMap

=

RECORD

baseAddr:
rowBytes:

PEE?
Integer;

{pointer
to
{flags,
and

bounds:

Rect;

{boundary

pmVersion:

Integer;

{pixel

packType:

Integer;

{packing

format}

packSize:

Longint;

{size

data

hRes:
vRes:

Fixed;
Fixed;

{horizontal resolution}
{vertical resolution}

pixelType:
pixelSize:

Integer;
Integer;

{format
of pixel
image}
{physical
bits per pixel}

cmpCount:
cmpSize:

Integer;
Integer;

{logical
{logical

components
per pixel}
bits per component}

planeBytes:

LongInt;

{offset

to

pmTable:

CTabHandle;

{pointer
{

pmReserved:

data}
in a row}

rectangle}

map
of

this

image
bytes

version
in

next

to

number}

packed

state}

plane}

color

table

for

}

image}

LongInt

{reserved

srcRect:

Rect;

{source

for

future

expansion}

END;

OpenCPicParams

=

RECORD

{

at

rectangle

hRes,

vRes

hRes:

Fixed;

{best

horizontal

vRes:

Fixed;

{best

vertical

version:
reservedl1:
reserved2:

Integer;
Integer;
Longint

{set
to -2}
{reserved
for
{reserved
for

for

best

resolution}

display

}

resolution}
resolution}

—,

~I

future
future

a
S

use}
use}

END;

©
=p
‘<)

a

Summary of Color QuickDraw

— 17-29

=aS
Z
-~

Inside Macintosh,

Volume V1

PictureHeader

=

RECORD
version:

Integer;

{set

reservedl:

Integer;

{reserved

to

-2}

hRes:
vRes:

Fixed;
Fixed;

{best
{best

srcRect:

Rect;

{source
rectangle
at hRes,
{ display

reserved? :

Longint

{reserved

an Extended

Version

for

future

use}

horizontal resolution}
vertical resolution}

for

for best
}
vRes
resolution}

future

use}

END;

Routines

Creating
FUNCTION

OpenCPicture

Creating

Regions

FUNCTION

BitMapToRegion

Copying

Pixel Map

PROCEDURE

CopyDeepMask

(nmewHeader:

From

FUNCTION

(region:

Whether

Data

RgnHandle;

bMap:

(srcBits:

BitMap;

maskBits:

BitMap;

srcRect:

Rect;

mode:

QuickDraw
(port:

Structure

Integer;

Has

GrafPtr)

:

CTabHandle) ;

PROCEDURE

PixPatChanged

(ppat:

PixPatHandle) ;

PROCEDURE

PortChanged

(port:

GrafPtr);

PROCEDURE

GDeviceChanged

(gdh:

GDHandle) ;

Intermediate

maskRgn:

dstBits:
Rect;

dstRect:

RgnHandle);

Drawing

Colors
(device:

GDHandle;

foreGround:

17-30

BitMap;

maskRect:

Changes

(ctab:

GetGray

: OSErr;

Boolean;

CTabChanged

FUNCTION

PicHandle;

BitMap)

Finished

PROCEDURE

Obtaining

:

Images

QDDone

Reporting

OpenCPicParams)

Bitmaps

Rect;

Determining

2 Picture

Summary of Color QuickDraw

backGround:

RGBColor)

:

RGBColor;

Boolean;

VAR

Color QuickDraw

Interpreting
FUNCTION

New

QODError

:

Using a Custom
FUNCTION

SearchProc

Result

Codes

regionTooBigError
pixmapTooDeepErr
mfStackErr
renTooBigErr

QDError

Result

Codes

Integer;

Color Search
(VAR rgb:
Boolean;

—147
—148
—149
—500

Function
RGBColor;

VAR

position:

LongInt)

Region too big or complex
Pixel map record is deeper than | bit per pixel
Insufficient stack
Bitmap would convert to a region greater
than 64 KB

—

~I

OQ
~

=
—
~
=

ar}
oo
=
ir
°
-

Summary of Color QuickDraw

— 17-31

—

Nee

2:
“

-

Inside Macintosh,

17-32

Volume VI

—

io)
—
4

ome

if)
_

=

~*~

La)
f=

—
a’
MNnOOO
NN
&
WH
W

W

THE

PICTURE

UTILITIES

-

PACKAGE

ate
—
te

-

mee

@
nn

About This Chapter
About the Picture Utilities Package
Using the Picture Utilities Package
Getting Color Information
Collecting Information From Multiple Pixel Maps or Pictures
Storing Information: The Picture Information Record
Picture Utilities Package Routines
Collecting Information From a Single Image
Collecting Information From Multiple Images
Creating Custom Color-Sampling Methods
Summary of the Picture Utilities Package

18-1

Inside Macintosh, Volume VI

18-2

—

aH

The Picture Utilities Package

—
w

—

C

-

=

=

c

Los:

ABOUT

THIS

Ss.

CHAPTER

be
-

ime

i$"
”M

This chapter describes the Picture Utilities Package, a set of routines with which you can
obtain qualitative and quantitative information about pictures and pixel maps. You might
want to find out about the text in a picture, for example, to see if the fonts it uses are available in the system. You can determine the number of colors a picture uses and obtain an
optimal color table or palette for displaying it.
To use this chapter, you should have read the Graphics Overview and Color QuickDraw™

chapters of this volume and the Color QuickDraw chapter in Volume V.

The Picture Utilities Package is available with system software versions 7.0 and later. With
system 7.0, the picture utilities work using the original QuickDraw, but with the limitation
that any palette handles returned are NIL.

ABOUT

THE

PICTURE

UTILITIES

PACKAGE

The two most common forms of storing image information are pixel maps and pictures. The
Picture Utilities Package consists of a number of routines for extracting information from a
picture, or from a pixel map record and its associated image.
Unless they contain specialized code for parsing pictures, many applications deal with pictures
as black boxes, perhaps imaging them into a pixel map and then dealing with the picture as
pixel map data. The Picture Utilities Package provides a way to open that black box and deal
with its contents intelligently.
The OpenCPicture routine described in the Color QuickDraw chapter of this volume stores
resolution information in the picture header. The Picture Utilities Package returns this information for pictures created with OpenCPicture, and returns the standard screen resolution
(72 dots per inch) for all other pictures.

USING

THE

PICTURE

UTILITIES

PACKAGE

You can use Picture Utilities Package routines and data structures to gather information about
a single pixel map or picture, or you can survey a number of them. To get information
about a single picture or pixel map, use either the GetPictInfo or GetPixMapInfo function,
and all the information will be returned in a picture information record.
To collect information about a number of pictures and pixel maps, you need to make at least
four calls: the NewPictInfo function creates an identifier for the collection. RecordPictInfo
and RecordPixMapInfo collect information from pictures and pixel maps, respectively.
RetrievePictInfo returns the collected information, and DisposPictInfo disposes of the data
structures private to the collection. Information about the collection of pictures and pixel
maps is returned in a picture information record.
Using the Picture Utilities Package

18-3

Inside Macintosh,

Volume VI

An entire picture need not be read into memory; pictures can be spooled to the GetPictInfo or
RecordPictInfo function, following the spooling procedure described in the Color QuickDraw
chapter of Volume V.

Getting

Color

Information

If you want information about the colors of a picture or pixel map, you indicate how many
colors you want to know about, what sort of color sampling you want done, and whether
you want colors returned in a palette or color table.
Currently the Picture Utilities Package has two color-sampling methods: one that gives you
the most frequently used colors and one that gives you the widest range of colors. Each has
advantages in different situations. For example, suppose a forest image has 400 colors, of
which 300 are greens, 80 are browns, and the rest are a scattering of gold sunlight effects. If
you ask for the 250 most popular colors, you might, in early summer, get all greens. If you
ask for a range of 250 colors, you will receive an assortment stretching from the greens and
golds at one locus of RGB space to the browns at the other, including colors in between that
might not actually appear in the image. If you need to use less than the image’s full color set,
you now have some information that may help you make the selection.
You can specify that the Picture Utilities Package chooses which color-sampling method to
use (with the constant systemMethod), or you can specify one of the two color-sampling
methods. By letting the Picture Utilities Package decide, you assure that when new methods
are made available they will be chosen when appropriate.
CONST

systemMethod

=

0;

{method

popularMethod

=

1;

{most

frequently

chosen

medianMethod

—

2's

{range

of

by

picture
used

utilites}

colors}

colors}

You can also supply a color-sampling algorithm of your own, as described in “Creating
Custom Color-Sampling Methods” later in this chapter. In that case, you pass the resource ID
of your color-sampling method.
A

Warning: When you ask for color information about a picture, the Picture
Utilities Package only takes into account the version 2 picture opcodes
RGBFgCol, RGBBkCol, BkPixPat, PnPixPat, FillPixPat, and HiliteColor
(as well as pixel map or bitmap data). Each occurrence of these opcodes is
treated as | pixel, regardless of the number and sizes of the objects drawn
with that color. If you need an accurate set of colors from a complex picture,
create an image of the picture in an offscreen pixel map, and then call
GetPixMapInfo to obtain color information about that pixel map. a

You can request that colors be returned in a color table, a palette, or both, and that black and
white not be returned in palettes or color tables. You can also ask for information about
comments and fonts encountered in the picture.

18-4

Using the Picture Utilities Package

—

o 2

The Picture Utilities Package

—
ww
—_e

q°

-_-

om
=

gn
©

CONST

returnColorTable
returnPalette

=
=

da;
23

{returns
{returns

colors
colors

in
in

a
a

recordComments

=

{creates

a

handle

to

comments}

recordFontInfo

=

8;

{creates

a

handle

to

fonts}

suppressBlackAndWhite

=

16;

{suppresses

black

and

white

{

color

tables

and

-

from

-

wae

ie)
+ 2)

}

palettes}

When you use the returnColorTable, returnPalette, recordComments, and recordFontInfo
values, you create handles to the additional information they provide. It is your responsibility to dispose of these handles. If you run version 7.0 with the original QuickDraw, the
Picture Utilities Package always returns NIL for the palette.

Collecting

Information

From

Multiple Pixel Maps

or Pictures

You can survey a number of pixel maps or pictures and accumulate information about them in
the picture information record. You can perform a number of such surveys simultaneously;
they are identified by a unique identifier created when you call the NewPictInfo function to
begin a survey.
You indicate which pixel maps or pictures to survey by making repeated calls to the
RecordPixMapInfo or RecordPictInfo function. When you want to check the accumulated statistics, use the RetrievePictInfo function, and the picture information record will
be filled with the latest information.
When you have finished a survey, call the DisposPictInfo function to dispose of the data
structures associated with the identifier for that survey. Note that DisposPictInfo does not
dispose of the handles returned in the picture information record.

Storing

Information:

The

Picture

Information

Record

The PictInfo data type defines the record that stores pixel map and picture information, as
gathered from a single image or from surveying a number of them. When you collect pixel
map information, the first seven fields of the picture information record are of primary
interest; the count fields contain 0, except for bitMapCount and pixMapCount, which contain
the number of bitmaps and pixel maps encountered.
TYPE

PictInfo

=

RECORD

version:
uniqueColors:

Integer;
Longint;

{Picture Utilities
version}
{total
colors
in pixel map

thePalette:
theColorTable:

PaletteHandle;
CTabHandle;

{ or picture}
{handle
to returned
{handle
to returned

hRes:

Fixed;

{ table}
{horizontal

vRes:

Fixed;

{vertical

}

palette}
color
}

resolution

~<

—s
—_
—:

color
table}
palette}

(dpi) }

resolution

(dpi) }

Using the Picture Utilities Package

18-5

Inside Macintosh,

Volume VI

depth:

Integer;

{pixel

sourceRect:
textCount:

Rect;
Longint ;

{best
rectangle
{number of text

depth

lineCount :

Longint;

{number

of

lines}

rectCount:

Longint;

{number

of

rectangles}

rRectCount:
ovalCount:

Longint;
Longint;

{number
{number

of
of

ovals}

of
of
of

arcs}
polygons}
regions}

bitmaps}
pixel maps}

arcCount:

Longint;

polyCount:
regionCount:

Longint;
Longint;

{number
{number
{number

bitMapCount:
pixMapCount:

Longint;

{number

of

Longint;

{number

of

of

pixel

map}

for

imaging}

objects}

round

rectangles}

commentCount:

Longint;

{total

number

of

comments}

uniqueComments:

Longint;

{number

of

unique

comments

commentHandle:

Comment

{ (by ID) }
{handle
to

comment

data}

uniqueFonts:
fontHandle:

Longint;

{number

of

FontSpecHandle;
Handle;

{handle

to

fonts}
font data}

{handle

to

list

fontNamesHandle:

SpecHandle;

{
reservedl:

Longint;

reserved?2:

LongIint

of

font

}

names}

END;

Field

descriptions

version

The version number of the Picture Utilities Package, currently set to 0.

uniqueColors

The number of colors in the collected pictures or pixel maps.

thePalette

A handle to the resulting palette if you requested that colors be
returned in a palette. That palette contains either the number of colors
you requested to see, or, if there aren’t that many, the number found.
On systems running the original QuickDraw, this field is always
returned as NIL.

theColorTable

A handle to the resulting color table if you requested that colors be
returned in a color table. If there are fewer colors found than you
requested, the remaining places in your color table are filled with black.
If a picture has more than 256 colors or has direct pixel maps (16- or
32-bit pixel values), then the colors returned in the color table are
truncated internally to 16-bit direct RGB values. In such a case the
returned colors have a slight loss of resolution, and the uniqueColors
field reflects the number of colors distinguishable at that resolution.

hRes

The horizontal resolution of the last pixel map or picture encountered.
See the description of the sourceRect field.

vRes

The vertical resolution of the last pixel map or picture encountered.
See the description of the sourceRect field. Note that, although hRes
and vRes are usually the same, they don’t have to be.

depth

The deepest pixel depth of all pixel map records encountered.

18-6

Using the Picture Utilities Package

}

te

io)

The Picture Utilities Package

=if)

mh

=

sor}
La)

sourceRect

e

=.

The sourceRect value from the version 2 picture header for the last
picture encountered. It contains the picture’s rectangle size at the
resolution indicated by hRes and vRes. The top-left corner of the

st.@
2)

rectangle is always (0,0).

Pictures created with the OpenCPicture function have the hRes, vRes,
and sourceRect fields built into their headers. Since pictures following
the older version 2 picture format created by OpenPicture don’t have
this information, the hRes and vRes fields are set to 72 pixels per
inch, and the source rectangle is calculated using the picture’s
picFrame field.
textCount

The total number of text objects in all the pictures.

lineCount

The total number of lines in all the pictures.

rectCount

The total number of rectangles in all the pictures.

rRectCount

The total number of round rectangles in all the pictures.

ovalCount

The total number of ovals in all the pictures.

arcCount

The total number of arcs in all the pictures.

polyCount

The total number of polygons in all the pictures.

regionCount

The total number of regions in all the pictures.

bitMapCount

The total number of bitmaps in all the pictures.

pixMapCount

The total number of pixel maps in all the pictures.

commentCount

The total number of comments in all the pictures.

uniqueComments

The number of comments (both long and short form) encountered that

have different IDs. This field is valid only if you requested comment
information.

commentHandle

A handle to a list of comment specification records if you asked for
comment information.

uniqueFonts

The number of different fonts encountered in the picture. This field is
valid only if you requested font information.

fontHandle

A handle to a list of font specification records if you requested font
information.

fontNamesHandle

A handle to a list of the names of the fonts in the picture. The offset
to a particular name is stored in the nameOffset field of the font specification record for that font. This field is valid only if you requested
font information.

When you have examined multiple pixel maps, the hRes and vRes fields of the picture information record contain the last resolution encountered, the depth field contains the deepest
pixel depth encountered, the uniqueColors field contains the total number of different colors
encountered (up to the accuracy of the Picture Utility Package’s storage bank for colors), and
the color table or palette contains the most popular or widest range of colors across all the
pixel map records and object colors examined.
Using the Picture Utilities Package

18-7

Inside Macintosh,

Volume VI

If you requested a count of the comments in your GetPictInfo function, the picture information
record contains a handle to an array of comment specification records. The uniqueComments
field value indicates the number of comment specification records listed.
TYPE

CommentSpec

=

RECORD
count:

Integer;

{number

ID:

Integer

{ID

of

times

assigned

to

this
this

comment

occurs}

comment}

END;

If you requested that font information be collected in your GetPictInfo function, the picture
information record contains a handle to an array of font specification records.
TYPE

FontSpec

RECORD

=

pictFontID:

Integer;

{ID

of

the

font

as

stored

sysFontID:

Integer;

{ID

of

the

font

as

found

size:

ARRAY[0..3]

style:

Integer;

nameOffset:

Longint

{offset

of

LongInt;

{font

sizes

{font

styles
to

in
in

the

picture}

this

system}

used}
used}
font

name

in

fontNamesHandle}

END;

Field

descriptions

pictFontID

The pictFontID field contains the ID number of the font as it is stored
in the picture.

sysFontID

The sysFontID field contains the ID number of the font as it is stored
in the current System file.

size

The size field contains 128 bits, in which a bit is set for each point size
encountered, from | to 127 points. Bit 0 is set if a size larger than 127
is found.

style

The style field indicates the text styles (such as bold or italic) that were

nameOffset

The nameOffset field contains the offset into the list of font names

encountered for this font at any of its sizes. The style field is defined
by the StyleItem data type, described in the QuickDraw chapter of
Volume I.
(pointed to by the fontNamesHandle field of the picture information
record) at which this font name is stored.

You must dispose of the handles that the picture information record gives you (thePalette,
theColorTable, commentHandle, fontHandle, and fontNamesHandle) when you are through
with them.

18-8

Using the Picture Utilities Package

—

H

The Picture Utilities Package

Lenl

A
ame

i)
ee

me
a
od *

ha)

PICTURE

UTILITIES

PACKAGE

=
—s
—
me
_
meee

ROUTINES

oe

i 2)

This section describes Picture Utilities Package routines, which examine pixel maps and
pictures. All of these routines can potentially move and purge memory.

Assembly-language note: The trap macro for the Picture Utilities
Package is _Pack15. You can call a specific routine by placing a 4-byte value

(which includes the routine selector) in the register DO. These values are listed

in “Assembly Language Information” at the end of this chapter.

Collecting

Information

From

a Single Image

The GetPixMapInfo function examines a single pixel map, returning information in the picture
information record. You must supply a handle to the pixel map record to be examined and a
pointer to the picture information record that will hold the information.
FUNCTION

GetPixMapInfo

(thePixMapHandle:

PixMapHandle;

PictiInfo;

verb:

Integer;

Integer;

colorPickMethod:

Integer)

:

VAR

thePictInfo:

colorsRequested:

Integer;

version:

OSErr;

In the verb parameter you indicate whether you want colors from the image returned as a
palette or a color table by setting the returnPalette or returnColorTable bit of the verb. You
may set both bits, in which case you will get both a color table and a palette. You can also
specify suppressBlackAndWhite in the verb parameter to request that black and white not
be counted when surveying colors. (Since the Palette Manager adds black and white when
creating a palette, this technique can be useful when you are sampling colors destined for
a palette or the screen: ask for the number of colors you want minus 2, and suppress black
and white.)

In the colorsRequested parameter you specify the number of colors you want returned in the
palette or color table; it may be from | to 256.
Use the colorPickMethod parameter to indicate what colors to return. If you specify
popularMethod, GetPixMapInfo returns the colors used most frequently. If you
specify medianMethod, GetPixMapInfo returns a weighted distribution of colors. If
you specify systemMethod, the Picture Utilities Package chooses the more appropriate.
You can also create your own color-sampling method, as described in “Creating Custom
Color-Sampling Methods” later in this chapter. To use your own method, specify its
resource ID in the colorPickMethod parameter. The ID must be in the range from 128 to
32768. The resource type is 'cpmt'.

Picture Utilities Package Routines

18-9

Inside Macintosh,

Volume

VI

Set the version parameter to 0.
Result codes

pictInfoVersionErr
pictInfo VerbErr
cantLoadPickMethodErr
colorsRequestedErr

FUNCTION

GetPictInfo

—11000
—11002
-11003
—11004

Version number not 0
Invalid verb combination specified
Custom pick method not in resource chain
Number out of range or greater than passed
to NewPictInfo

(thePictHandle:
PictInfo;

PicHandle;

verb:

Integer;

VAR

thePictInfo:

colorsRequested:

Integer;

colorPickMethod:

Integer)

:

Integer;

version:

OSErr;

The GetPictInfo function examines a single picture, returning information in the picture
information record. You must supply a handle to the picture to be examined in the
thePictHandle parameter, and a pointer to the picture information record that will hold
the information in the parameter thePictInfo.
As explained in the description of the GetPixMapInfo function, the verb parameter indicates
whether colors are to be returned in a color table or palette, or both, and whether to suppress
black and white. With the GetPictInfo function, you can also use the verb parameter to request
comment or font information, which you specify by recordComments or recordFontInfo.
The colorsRequested parameter must contain the number of colors you want returned in the
palette or color table.
Use the colorPickMethod parameter to indicate the color-sampling method. Its value can be
systemMethod, popularMethod, medianMethod, or the resource ID of your own method.
Set the version parameter to 0.
Result codes

pictInfoVersionErr
pictInfo VerbErr
cantLoadPickMethodErr
colorsRequestedErr

—11000
—11002
-11003
—11004

pictureDataErr

—11005

Version number not 0
Invalid verb combination specified
Custom pick method not in resource chain
Number out of range or greater than passed to
NewPictInfo
Invalid picture data

From

Multiple

Collecting

Information

Images

To survey a number of pixel maps or pictures, you first create an identifier, called the picture
information ID, which associates a series of requests and allocates data structures to contain
the gathered information.

18-10

Picture Utilities Package Routines

—

CO

The Picture Utilities Package

~

ne

Q

-_-

=

ior)

ie")

FUNCTION

NewPictInfo

(VAR

thePictInfoID:

colorsRequested:
version:

PictInfoID;
Integer;

Integer)

:

verb:

s=f

Integer;

colorPickMethod:

—

OSErr;

The NewPictInfo function sets the parameter thePictInfoID to a unique value. The verb
parameter selects what information (palettes or color tables, comments or fonts) is to be
returned by subsequent calls to RetrievePictInfo. For surveying pixel map records, valid
choices are returnPalette, returnColorTable, and suppressBlackAndWhite, which are
explained in the description of the GetPixMapInfo function earlier in this chapter.
For pictures, you can also use the verb parameter to request the collection of comment and
font information by specifying recordComments and recordFontInfo.
The colorsRequested parameter must contain the number of colors you want returned in the
palette or color table.
In the colorPickMethod parameter you specify whether you want to retrieve colors using the
sampling method systemMethod, popularMethod, medianMethod, or the resource ID of your
own method.
Set the version parameter to 0.
Result codes

pictInfoVersionErr
pictInfo VerbErr
cantLoadPickMethodErr
colorsRequestedErr

FUNCTION

RecordPixMapInfo

—11000
—11002
-—11003
—11004

Version number not 0
Invalid verb combination specified
Custom pick method not in resource chain
Number out of range or greater than passed to
NewPictInfo

(thePictInfoID:
PixMapHandle)

FUNCTION

RecordPictInfo

PictInfoID;
:

thePixMapHandle:

OSErr;

(thePictInfoID:
PictInfoID;
PicHandle)
: OSErr;

thePictHandle:

These routines have parallel functions, one surveying pixel maps, the other pictures. In the
parameter thePictInfoID you must pass the value returned from the NewPictInfo function, in
thePixMapHandle you pass a handle to a pixel map record, and in thePictHandle you pass a
handle to a picture. You can call these routines repeatedly to accumulate information about a
number of pixel maps or pictures.
Result codes
pictInfoIDErr
pictureDataErr

—11001
—11005

Invalid picture information ID
Invalid picture data

Picture Utilities Package Routines

_

ate

Integer;

18-11

—te

4°)
i? 2]

Inside Macintosh,

FUNCTION

Volume VI

RetrievePictInfo

(thePictInfoID:
PictInfo;

PictInfoID;

VAR

colorsRequested:

thePictInfo:

Integer)

:

OSErr;

The RetrievePictInfo function returns the information requested by the verb parameter passed
to the associated NewPictInfo function specified by thePictInfoID. You supply a pointer to
the picture information record in thePictInfo. If you requested a palette or color table, specify
the number of colors you want in the colorsRequested parameter.
You can call this function repeatedly, gathering new information after additional calls to
RecordPixMapInfo or RecordPictInfo. Remember to dispose of the handles returned to
you (thePalette, theColorTable, commentHandle, fontHandle, and fontNamesHandle)

when you finish with them.
Result codes
pictInfoIDErr
colorsRequestedErr

FUNCTION

—11001 — Invalid picture information ID
-—11004
Number out of range or greater than passed
to NewPictInfo

DisposPictInfo

(thePictInfoID:

PictInfoID)

:

OSErr;

The DisposPictInfo function disposes of all data structures private to the parameter

thePictInfoID. It does not dispose of any of the handles returned to you by a call to

RetrievePictInfo.

Result code
pictInfoIDErr

-11001

— Invalid picture information ID

You can dispose of palettes by using the DisposePalette procedure, dispose of color tables by
using the DisposeCTable procedure, and dispose of other allocations with the DisposHandle
procedure.

Creating

Custom

Color-Sampling

Methods

Assembly-language programmers can create a custom method for sampling colors. You
specify its use by placing the resource ID of your function in the colorPickMethod parameters

of the GetPixMapInfo, GetPictInfo, and NewPictInfo functions. Your custom function

should be in a resource of type 'cpmt’.

Your function is called with a routine selector in register DO.

DO

value

DO =0
DO = |
DO =2
DO=3
18-12

Subroutine
to call

MylInitPickMethod
MyRecordColors
MyCalcColorTable
MyDisposeColorPickMethod
Picture Utilities Package Routines

ome

aK

The Picture Utilities Package

al

_e

‘<=
ao
~
—_—

sz |
Ls)
a=

The MyInitPickMethod function is called first; it should allocate storage or perform any other
initialization required by your function. The MyRecordColors function is called to record
colors if you create your own custom color bank. The MyCalcColorTable function is called if
there are more colors in the picture being examined than your application requested to see or
if you are recording your own colors. The MyDisposeColorPickMethod function is called
when the application is done with the color sampling method. It should release memory
requested by the MyInitPickMethod function.
If your routines return an error, that error is passed back to the application.
FUNCTION

MyInitPickMethod

(colorsRequested:
VAR

Integer;

colorBankType:

Integer)

VAR

dataRef:
:

LongInt;

OSErr;

Your MyInitPickMethod function must allocate whatever data you need and store a handle to
your data in the location pointed to by the dataRef parameter. It should also return the type of
color bank your function uses for color storage in colorBankType.
There are three valid color bank types:
CONST

colorBankIsCustom

=

«LF

{records

colors

you

colorBankIsExactAnd555

=

0;

{records

exact

colors}

colorBankIs555

=

‘Ls

{records

colors

ina

{

specify}
5-5-5

}

histogram}

Return colorBankIsCustom if you want to record your own colors; this is the only case in
which your RecordColors routine is called. Your CalcColorTable function will also be called.
Return colorBankIs555 if you want the colors stored in a 5-5-5 histogram. The Picture
Utilities Package calls the CalcColorTable routine with a pointer to the color bank (the 5-5-5
histogram) when the application retrieves color information. The Picture Utilities Package
does not call your MyRecordColors function.
ColorBankIsExactAnd555 tells the Picture Utilities Package to return exact colors. The
MyCalcColorTable function should only be called if there are more colors in the picture or
pixel map than the application requests. (This is the same as ColorBankIs555 except that the
Picture Utilities Package returns the exact colors whenever possible.)
The format of the 5-5-5 histogram is like a reversed color table. It is an array of 32,768
integers, where the index into the array is the color: 5 bits of red, followed by 5 bits of
green, followed by 5 bits of blue. Each entry in the array is the number of colors in the
picture that are approximated by the color that indexes this entry.
For example, suppose there were three instances of the following color in the pixel map:
red
green
blue

=
=
=

@Z%IIOLIOIOIOIOIIIO
%0111101010110001
%OIO110O1101101010

This color would be represented by index % 0 11011 0111101011 (in hex $6DEB) and
the value in the histogram at this index would be 3 (because there were three instances of
this color).

Picture Utilities Package Routines

= 18-13

—
—e

-

—

—

_~

es

@
M

Inside Macintosh,

FUNCTION

Volume

VI

MyRecordColors

(dataRef:

LongInt;

colorCount:
:

colorsArray:

LongInt;

VAR

RGBColorArray;

uniqueColors:

LongInt)

OSErr,;

The Picture Utilities Package calls your MyRecordColors function only if your InitPickMethod
function returned colorBankIsCustom. MyRecordColors is called repeatedly for all the colors
in the picture or pixel map. MyRecordColors should store the color information for the array
of 48-bit colors that it was passed. The RGB color array is defined as
TYPE

RGBColorArray

=

ARRAY[0..0]

of

RGBColor;

The colorCount parameter indicates how many colors there are in the array colorsArray.
Your function must also calculate the number of unique colors (to the resolution of the color
bank) that were added by this call to your MyCalcColorTable function. It should add this
delta amount to the uniqueColors parameter that is passed to it.
FUNCTION

MyCalcColorTable

(dataRef:

LongInt;

colorBankPtr:
:

Ptr;

colorsRequested:
VAR

resultPtr:

Integer;
CSpecArray)

OSErr;

Your MyCalcColorTable function should look either at your own internal color bank or at the
5-5-5 histogram passed in the colorBankPtr parameter, and it should fill the array of color
specification records pointed to by resultPtr with as many colors as were requested. If more
colors are requested than you can return, fill the remaining entries with black (0000 0000
0000). If your MyInitPickMethod function returned colorBankIsCustom, the colorBankPtr
value will not be valid, since your color-sampling method is responsible for keeping a record
of the colors.
The colorBankPtr parameter is of type Ptr because the data stored in the color bank is of the
type specified by the MyInitPickMethod function. Thus, if you specified colorBankIs555
in the colorBankType parameter, the color bank would be an array of integers (see the
description of MyInitPickMethod). However, if the Picture Utilities Package supports other
data types in the future, the colorBankPtr parameter could point to completely different objects.
For now, you should always coerce colorBankPtr to a pointer to an integer. In the future you
may need to coerce colorBankPtr to a pointer of the type you specify in MyInitPickMethod.
FUNCTION

MyDisposeColorPickMethod

(dataRef:

LongInt)

:

OSErr;

Your MyDisposeColorPickMethod function should release any memory that you allocated
in your MyInitColorMethod function.

18-14

Picture Utilities Package Routines

—

io)

The Picture Utilities Package

a”)

pete

oO
i

—

ver

|

ia)

(=m

SUMMARY

OF

THE

PICTURE

UTILITIES

_

eure

PACKAGE

—

—s

fone

Lamia

@

i? 2)

Constants
CONST

{color-sampling
systemMethod

methods}
=.

03

{method

popularMethod

=:

iy

{most

frequently

chosen

by

medianMethod

=

oe

{range

of

picture
used

utilites}

colors}

colors}

picture

information}

returnColorTable

=

ave

{returns

colors

in

a

color

returnPalette

=

2

{returns

colors

in

a

palette}

recordComments

=

4;

{creates

a

handle

to

comments}

recordFontInfo

=

83

{creates

a

handle

to

fonts}

{suppresses

black

and

white

{form

and

content

of

suppressBlackAndwhite

a6»

{

color

tables

palettes}

you

specify}

=-1;

{records

colors

colorBankIsExactAnd555

=

0;

colorBankIs555

=

1;

{records
{records

exact
colors}
colors
in a 5-5-5

of

RGBColor;

Data

Types

TYPE

PictInfoID

=

ARRAY[0..0]

PictInfoHandle
Pict info:

}

}

histogram}

LongInt;

RGBColorArray

PictInfoPtr

from

and

{color bank
types}
colorBankIsCustom

{

table}

=

=

“PictInfoPtr;

*PictiInfo;

=

RECORD

version:
uniqueColors:

Integer;
LongInt;

{Pict
Utilities
version}
{total
colors
in pixel map
{ or picture}

thePalette:

PaletteHandle;

{handle

to

returned

palette}

theColorTable:

CTabHandle;

{handle
to
{ table}

returned

color

hRes:

Fixed;

{horizontal

vRes:

Fixed;

{vertical

depth:

Integer;

{pixel

sourceRect:
textCount:
lineCount:

Rect;
LongInt;
Longint;

{best
rectangle
for imaging}
{number of text objects}
{number
of lines}

resolution
resolution

depth

of

pixel

}

}

(dpi) }
(dpi) }

map}

Summary of the Picture Utilities Package

18-15

Inside Macintosh, Volume VI

rectCount:

LongInt;

{number

of

rectangles}

rRectCount:

LongInt;

{number

of

round

ovalCount:

Longint;

{number

of

ovals}

arcCount:
polyCount:

LongIint;
Longint;

{number
{number

of
of

arcs}
polygons}

of

regions}

rectangles}

regionCount:

LongIint;

{number

bitMapCount ;:
pixMapCount:
commentCount :

LongInt;
Longint;
LongInt;

{number of bitmaps}
{number of pixel maps}
{total number of comments}

uniqueComments:

LongInt;

{number

{

SpecHandle;

of

(by

ID) }

unique

comments

comment
fonts}

data}

commentHandle:

Comment

uniqueFonts:

Longint;

{handle
{number

to
of

fontHandle:

FontSpecHandle;

{handle

to

font

data}

fontNamesHandle:

Handle;

{handle

to

list

of

reservedl:

LongiInt;

reserved2:

Longint

of

times

font

}

names}

END;
CommentSpecHandle
CommentSpecPtr
CommentSpec
RECORD

=

=

“CommentSpecPtr;

“CommentSpec;

=

count:

Integer;

{number

ID:

Integer

{ID

assigned

to

this

this

comment

occurs}

comment}

END;
FontSpecHandle
FontSpecPtr
FontSpec
RECORD

=

=

“FontSpecPtr;

“FontSpec;

=

pictFontID:

Integer;

{ID of the
{ picture}

font

as

stored

sysFontID:

Integer;

font

as

found

size:

ARRAY[0..3]

{ID of the
{ system}
LongInt;

style:

Integer;

{font
{font

nameOffset:

LongInt

{offset

o=

{
END;

18-16

Summary of the Picture Utilities Package

in
in

sizes used}
styles used}
to

font

name

fontNamesHandle}

in

}

the

}

this

}

—

RH

The Picture Utilities Package

ww
a *

OQ
—_
—

Lew

|

@

C

=.

Routines

=

=.
&

~n

Collecting
FUNCTION

Information

Get PixMapInfo

From

a Single

(thePixMapHandle:

PixMapHandle;

PictInfo;

verb:

Integer;

Integer;

colorPickMethod:

Integer}

FUNCTION

Collecting
FUNCTION

Information

NewPictInfo

PicHandle;

verb:

Integer;

colorPickMethod:

Integer;

Multiple

RecordPixMapInfo

version:

thePictInfo:

colorsRequested:

Integer;

version:

Images

(VAR

thePictInfoID:

colorsRequested:

FUNCTION

thePictInfo:

OSErr;

From

Integer;

Integer;

VAR

PictInfo;
Integer)

VAR

colorsRequested:

OSErr;

(thePictHandle:

GetPictInfo

Image

PictInfoID;
Integer;

version:

(thePictInfoID:
PixMapHandle)

Integer)

PictInfoID;

verb:

Integer;

colorPickMethod:
OSErr;
thePixMapHandle:

OSErr;

FUNCTION

RecordPictiInfo

(thePictinfoID:
PictInfoID;
PicHandle)
OSErr;

thePictHandle:

FUNCTION

RetrievePictiInfo

(thePictInfoID:
PictInfolID;
PictInfo;
colorsRequested:

VAR

FUNCTION

DisposPictiInfo

Application-Defined
FUNCTION

(thePictInfoID:

thePictInfo:

Integer)

PictInfolID)

OSErr;

OSErr;

Routines

MyInitPickMethod

(colorsRequested:
Longint;

VAR

VAR

Integer;

colorBankType:

dataRef:
Integer)

OSErr;
FUNCTION

FUNCTION

MyRecordColors

MyCalcColorTable

LongInt;
colorsArray:
(dataRef:
colorCount:
LongInt;
RGBColorArray;
Longint)
OSELY:
uniqueColors:
(dataRef:
Integer;

resultPtr:

FUNCTION

MyDisposeColorPickMethod

(dataRef:

VAR

colorsRequested:
Ptr;
VAR
colorBankPtr:

LongiInt;

CSpecArray )
LongInt)

OSErr;

OSErr;

Summary of the Picture Utilities Package

18-17

Inside Macintosh,

Result

Volume VI

Codes

pictInfo VersionErr
pictInfoIDErr
pictInfoVerbErr
cantLoadPickMethodErr
colorsRequestedErr

—11000
—11001
—11002
—-11003
—11004

pictureDataErr

—11005

Assembly-Language
Trap

Macro

Requiring

Version number not 0
Invalid picture information ID
Invalid verb combination specified
Custom pick method not in resource chain
Number out of range or greater than passed
to NewPictInfo
Invalid picture data

Information
Routine

Selectors

_Pack15
Selector

$0206

Routine

DisposPictInfo

$0403

RecordPictInfo

$0505
$0602
$0800

RetrievePictInfo
NewPictInfo
GetPictInfo

$0404

RecordPixMapInfo

$0801

GetPixMapInfo

18-18

= Summary of the Picture Utilities Package

—
co

THE

COLOR

PICKER

—

PACKAGE

‘©

5
—
~

~~)

—
—

SO

OC

RWW
MM OAKRA

~

About This Chapter
About the Color Picker Package
Color Models
The RGB Model
The CMYK Model
The HLS and HSV Models
Color Models in the Dialog Box
Using the Color Picker Package
Presenting the Color Picker Dialog Box
Using Conversion Facilities
Color Picker Package Routines
Displaying the Color Picker Dialog Box
Converting Between Color Models
Converting Between SmallFract and Fixed Values
Summary of the Color Picker Package

nore
ate

OQ

~~
@Law}

19-]

Inside Macintosh, Volume VI

19-2

The Color Picker Package

ABOUT

THIS

CHAPTER

This chapter describes how you can use the Color Picker Package to offer users a standard
dialog box for choosing a color. The Color Picker Package also provides routines for
converting color specifications from one color model to another.
You should be familiar with the material in the Graphics Overview chapter in this volume,
especially the discussion of direct and indexed screen devices. Effective use of the Color

Picker also requires familiarity with Color QuickDraw™, described in Volume V of Inside

Macintosh and in this volume.

This chapter supersedes the description of the Color Picker in Volume V. The Color Picker
Package is available in system software versions 4.1 and later. With system software
version 7.0 the Color Picker’s dialog box can be displayed on black-and-white devices.
You need to read this chapter if your application uses the color system introduced with Color
QuickDraw (rather than the eight-color system available with the original QuickDraw) and
you need to solicit color choices from users. If your application limits user selection to a
specific list of colors, you may need to construct your own dialog box for color selection
using Palette Manager routines, because the Color Picker allows users to choose colors from
the entire range of 48-bit RGB values available with Color QuickDraw.

ABOUT

THE

COLOR

PICKER

PACKAGE

The Color Picker Package provides you with a standard way of soliciting a color choice from
the user. When your application calls the Color Picker’s GetColor function, the Color Picker
presents its dialog box to the user, as shown in Figure 19-1.When the user is satisfied with a
chosen color and clicks the OK button, GetColor returns that color to your application as an
RGB value.
The Color Picker Package also has utility routines for converting between RGB values and
several other color models, and for converting between the fixed integers Color QuickDraw
uses for RGB colors and the SmallFract values the Color Picker Package uses with alternate
color models.
This chapter begins by describing the color models the Color Picker Package works with. It
then explains how to set up and present the Color Picker dialog box to users and how to use

the Color Picker’s conversion facilities.

About the Color Picker Package

19-3

Volume

a color...

Hue
Saturation

|561?4

Brightness

|5?7344

Red

|57344

Green

| 40960

Blue

|}8192

EDEDED)

Select

VI

EDEDED)

Inside Macintosh,

Figure 19-1. The Color Picker dialog box

COLOR

MODELS

Both Color QuickDraw and standard screen devices work with an RGB

(red, green, blue)

color model, but graphic arts and design use other color models, such as HLS (hue, lightness,
saturation) or HSV (hue, saturation, value), and in printing, the CMYK (cyan, magenta,
yellow, black) model predominates. Great books have been written about color; this section
presents a quick survey of the models with which the Color Picker Package works.

The

RGB

Model

In the RGB model, the three colors are additive. The more of each color you add, the closer
the resulting color is to white. This is the way light-produced colors work; turning on the red,
green, and blue phosphors of a television screen produces white, as does shining lights of
red, green, and blue upon a stage.
The RGB color record is the Color QuickDraw data structure for the RGB color model.
TYPE

RGBColor

=

RECORD

red:

Integer;

{red

green:
blue:

Integer;
Integer

{green
component }
{blue
component

END;

19-4

Color Models

component }

The Color Picker Package

The frontispiece of Volume V of /nside Macintosh shows a color cube that represents
the values possible in an RGB system. Figure 19-2 is a black-and-white representation
of that cube.

reese,

se
©

=
=)

Lear |

oya

65535,0,0

—

Red

>
©
=

65535,65535,65535

_-—~

| White

=.

0,0,0

Black
0,0,65535

Blue

0,65535,0
Green

Figure

19-2. The RGB

color cube

Starting at one corner, with 0 values for each color, is black. Increasing any one of the values
produces shades of that color, increasing its saturation. Increasing all three values equally
generates a diagonal line across the cube toward full value (65,535) for each, which is white.
Values on that diagonal are shades of gray; values off the line in any direction are colors. For
example, pink in the RGB model would be full red with some equal amount of green and blue,
in effect moving from the black corner of the color cube up along the edge to full red, then
traversing a diagonal across the top face from red toward white, as illustrated in Figure 19-3.

~

>

Getting

to pink

65535,0,0
Red

65535,65535,65535
White

0,0,0
Black
0,0,65535

Blue

0,65535,0
Green

Figure

19-3.

Color Models

19-5

Inside Macintosh, Volume VI

The

CMYK

Model

In the CMYK model, which is used by printers, the three colors and black are subtractive:
Increasing values moves the result closer to black. This model is intuitive for printing, which
is usually done on white paper—to get white, don’t print anything. In theory, black could be
achieved by mixing full values of cyan, magenta, and yellow, but purity in chemicals is more
problematic than purity in light, and four-color print processes use black as well. The Color
Picker’s CMYColor data type defines only the three colors. It uses SmallFract values, which
are the fractional parts of fixed values, as described in the section “Using Conversion
Facilities” later in this chapter.
TYPE

CMYColor

=

RECORD

{CMY
{cyan

and

cyan:

SmallFract;

magenta:

SmallFract;

{magenta

yellow:

SmallFract

{yellow

RGB

are

complements}

component }
component }
component }

END;

Note in Figure 19-4 that cyan, magenta, and yellow are complements of red, green, and blue.
Yellow

Red

White

Magenta

Black

Cyan
Blue
Green

Figure 19-4. Cyan, magenta, and yellow on the color cube

The

HLS

and

HSV

Models

The components of the HLS and HSV models are not three diverse colors, as in the RGB
and CMYK models. The HLS and HSV models separate color, or hue, from brightness
and saturation.

Brightness is a measure of the amount of black in a color (the less black, the brighter the

color); saturation is a measure of how much white it contains (the less white, the more

saturated the color). Hue is indicated by an arbitrary assignment of numbers to colors.
The amount of that hue is indicated by a saturation value, and the brightness of the color is

19-6

Color Models

The Color Picker Package

a third value. The best representation for such a system is an inverted cone, as shown in

=

Figure 19-5, in which hues vary around the perimeter, where they are most highly saturated,
and brightness increases from the tip of the cone to the disk. The gray line from black to
white begins at the tip and runs up through the cone to the center of the disk.

\o
‘2
=
Ss
~
-_

“

—
pate

QO

Red

x
@

Increasing

“

saturation

Hues

Black

Figure 19-5. The HLS/HSV

color cone

This is the model portrayed in the Color Picker’s dialog box. The disk is shown full face, the
hues are at their most saturated around the rim, and the brightness line down the cone is
controlled by the scroll bar at the right of the dialog box.
In the Color Picker’s color wheel the value for pure red is 0, pure green is 21,845, and pure
blue is 43,690. The amount of black is set by the value for brightness (corresponding to
lightness in HLS, value in HSV), and the amount of color in the mix is set by saturation.
Pink in the HLS or HSV system would be obtained by setting hue to red, saturation to some
amount less than full, and brightness to full.
The HLS and HSV systems are sufficiently similar that the Color Picker can treat them as one
by a simple expedient: the Color Picker treats the HLS model as if its components were
ordered HSL; this puts hue and saturation in the same relative positions in the data structures
of both models.
TYPE

HSLColor

=

RECORD
hue:
saturation:
lightness:

SmallFract;
SmallFract;

{fraction of circle,
red at 0}
{0-1,
0 is gray,
1 is pure color}

SmallFract

{0-1,

0

is

black,

1

is

white}

END;

Color Models

19-7

Inside Macintosh,

TYPE

Volume

HSVColor

VI

=

RECORD

{fraction

SmallFract;

hue:

of

circle,

saturation:

SmallFract;

{0-1,

0

is

gray,

value:

SmallFract

{0-1,

0

is

black,

1
1

red

is
is

at

pure
max

0}

color}
intensity}

END;

Color Models in the Dialog Box
The controls in the dialog box are designed for use in the HLS and HSV models: the user
chooses hue by moving the cursor around the color wheel, saturation by moving the cursor
into or out from the center, and brightness (value or lightness) by using the scroll bar at the
right. The way the RGB values vary in response to the dialog controls is not intuitive, but
their responses help to show how the models relate.
The dialog box cannot exactly match printing’s subtractive effect, and it does not offer
CMYK controls, but the Color Picker Package does include routines for converting between
RGB and CMY (cyan, magenta, yellow, without a black component).

USING

THE

COLOR

PICKER

PACKAGE

Most applications only use the Color Picker Package to display the Color Picker’s dialog box.
A few applications may need to use the color model and SmallFract conversion routines.

Presenting the Color Picker Dialog Box
Your application can present a user with the Color Picker dialog box, shown in Figure 19-1,
by using the Color Picker’s GetColor function.
When called by your application, GetColor displays the dialog box, including prompt text,
which appears in the upper-left corner, and the starting color, which appears in the lower
of the two rectangles below the prompt. The color that the user is selecting, displayed in
the upper rectangle, ranges over the entire color space in response to the controls in the rest
of the dialog box. Your application can supply the prompt text, the starting color, and the
location of the upper-left corner of the dialog box, and it can specify whether the dialog
box should appear on the main screen (the screen with the menu bar) or the screen with the
greatest pixel depth.
The two groups of numeric fields (Hue, Saturation, Brightness; Red, Green, Blue) show the
parameters of the color being picked in the two color models. The user can increase or decrease
the values using the arrow controls or can enter values directly into any of the six fields.

19-8

Using the Color Picker Package

The Color Picker Package

The range for each of the component values is 0 to 65,535. Larger values are truncated to
65,535 after the user exits the field. The hue value for pure red is 0; pure green is 21,845:
pure blue is 43,690. Hue values wrap around from 0 to 65,535, so the user can circumnavigate the wheel with arrow controls just as with the cursor. The user can select a single
RGB value from Color QuickDraw’s entire range of 248 color values.

—

—

‘2
=
>
=
~
Ld

—

ne

On black-and-white hardware (or in less than 4-bit mode), the display appears in black and
white; the Color Picker returns the RGB value selected, but it does not call any color routines
in the course of responding to user actions.
On a device with a variable color look-up table (CLUT), the Color Picker temporarily borrows
a CLUT entry to display the exact color in the rectangle that shows the color currently being
picked. (If you let the Color Manager approximate the user’s value when your application
subsequently displays the chosen color, the result will probably differ somewhat from the one
picked.) The Color Picker restores the color environment when it is done.

Using Conversion

Facilities

In addition to the GetColor function that displays the Color Picker dialog box, the Color
Picker Package provides six procedures for converting between an RGB color record and
a CMY, HLS, or HSV color record, and it provides two functions that convert between
SmallFract and fixed numbers. Most applications are likely to use only the GetColor function.
The Color Picker Package defines the CMY color, HSL color, and HSV color records with
SmallFract values rather than integer values (as used in the RGB color record).

A SmallFract

TYPE

1}

value is the fractional part—that is, the low-order word—of a fixed number.
SmallFract

=

Integer;

{unsigned

fraction

between

0

and

The integer values in the RGB color record are actually used as unsigned integer-sized values;
by using SmallFract values, the Color Picker Package avoids sign extension problems in the
conversion math.
The Color Picker Package provides two functions for converting between SmallFract and
fixed numbers. Most applications do not need to use these facilities.

COLOR

PICKER

PACKAGE

ROUTINES

The Color Picker Package comprises nine routines: the GetColor function that displays the
Color Picker’s dialog box, six procedures for converting between color record types, and
two functions for converting between SmallFract and fixed values. Most applications are
likely to use only the GetColor function.

Assembly-language note: To gain access to the Color Picker Package
routines, use the trap macro _Pack12.

Color Picker Package Routines

19-9

C
~~
©
=

Inside Macintosh,

Displaying

Volume VI

the Color

Picker

Dialog

Box

The GetColor function displays the Color Picker dialog box on a screen.
FUNCTION

GetColor

(where:

Point;

outColor:

prompt:

RGBColor)

Str255;
:

inColor:

RGBColor;

VAR

Boolean;

The dialog box appears with its upper-left corner located at the point you designate with the
where parameter. The GetColor function can display the dialog box and accept color selection
on any screen, not just the main screen. If you set where to (0,0), the dialog box is positioned neatly on the main screen—centered horizontally, with one-third of the empty space
above the box and two-thirds below, regardless of the screen size. If you set the where
parameter to (—1,—1), the GetColor function displays the dialog box on what the Color Picker

determines to be the best screen, optimizing depth and color.

The prompt string is displayed in the upper-left corner of the dialog box. The inColor
parameter is the starting color, which the user may want for comparison; it is displayed
immediately below the current output color (the one the user is picking). The outColor
parameter is set to the last color value the user picks before clicking OK. On entry, the
outColor parameter is treated as undefined, so the output color sample initially matches the
input. Although the color being picked may vary widely, the input color sample remains
fixed, and clicking the input sample resets the output color sample to match it.
GetColor returns TRUE if the user exits by clicking the OK button, FALSE if the user exits

by clicking the Cancel button.

Converting

Between

Color

Models

These six procedures offer conversions between the RGB color model and each of the CMY,
HLS, and HSV models.
PROCEDURE

CMY2RGB

(cColor:

CMYColor;

VAR

rColor:

RGBColor) ;

The CMY2RGB procedure converts a CMY color record to its equivalent RGB color record.
PROCEDURE

HSL2RGB

(hColor:

HSLColor;

VAR

rColor:

RGBColor);

The HSL2RGB procedure converts an HSL color record to its equivalent RGB color record.
PROCEDURE

HSV2RGB

(hColor:

HSVColor;

VAR

rColor:

RGBColor) ;

The HSV2RGB procedure converts an HSV color record to its equivalent RGB color record.
PROCEDURE

RGB2CMY

(rColor:

RGBColor;

VAR

cColor:

CMYColor);

The RGB2CMY procedure converts an RGB color record to its equivalent CMY color record.
PROCEDURE

RGB2HSL

(rColor:

RGBColor;

VAR

hColor:

HSLColor) ;

The RGB2HSL procedure converts an RGB color record to its equivalent HSL color record.

19-10

Color Picker Package Routines

The Color Picker Package

PROCEDURE

RGB2HSV

(rColor:

RGBColor;

VAR

hColor:

—

\o

HSVColor);

The RGB2HSV procedure converts an RGB color record to its equivalent HSV color record.

Converting

Between

SmallFract

and

Fixed

SmallFract2Fix

(s:

SmallFract)

:

ar

Values

=

co

sr |

Fixed;

The SmallFract2Fix function converts a SmallFract value to a fixed integer.
FUNCTION

Fix2SmallFract

(f:

Fixed)

:

SmallFract;

The Fix2SmallFract function converts a fixed integer to a SmallFract value.

Color Picker Package Routines

=
<

CO

A SmallFract value can represent a value between 0 and 65,535. The Color Picker Package
uses SmallFract values in its CMY color, HSL color, and HSV color records. You can use
these functions if you need to convert SmallFract values to or from fixed values. (They can
be assigned directly to and from integers.)
FUNCTION

Q

19-11

Inside Macintosh,

SUMMARY

Volume VI

OF THE

COLOR

PICKER

PACKAGE

Constants
CONST
MaxSmallFract

Data
TYPE

=

SOQOOOFFFF;

{maximum

SmallFract

value,

as

LongInt}

Types
CMYColor

=

RECORD

{CMY

cyan:

SmallFract;

magenta:

SmallFract;

yellow:

and RGB are complements}
{cyan component}
{magenta
component}

SmallFract

{yellow

component}

END;

HSLColor

=

RECORD

hue:

SmallFract;

Saturation:

{fraction

SmallFract;

lightness:

{O-1,

0

is

SmallFract

{O-1,

0

is

END;

HSVColor

of

circle,
red at 0}
gray,
1 is pure color}
black,
1 is white}

=

RECORD

hue:

SmallFract;

Saturation:

{fraction

SmallFract;

value:

{O-1,

0

is

SmallFract

gray,

{0O-1,

0

is

black,

END;

SmallFract

=

Integer;

of

{unsigned

circle,
1

fraction

red
is

1

is

at

pure
max

between

0}
color}
intensity}

0

and

Routines

Displaying
FUNCTION

19-12

the Color

GetColor

Picker

Dialog

(where:

Point;
RGBColor;
VAR

Summary of the Color Picker Package

Box
prompt:
outColor:

Str255;

inColor:
RGBColor)
: Boolean;

1}

The Color Picker Package

Converting

Between

Color

Models

—

\o

OQ
)
i)

ae

PROCEDURE

CMY2RGB

(cColor:

CMYColor;

VAR

rColor:

PROCEDURE

HSL2RGB

(hColor:

HSLColor;

VAR

rColor:

RGBColor) ;

PROCEDURE

HSV2RGB

(hColor:

HSVColor;

VAR

rColor:

RGBColor) ;

PROCEDURE

RGB2CMY

(rColor:

RGBColor;

VAR

eColors

CMYColor) ;

PROCEDURE

RGB2HSL

(rColor:

RGBColor;

VAR

hColor:

HSLColor) ;

PROCEDURE

RGB2HSV

(rColor:

RGBColor;

VAR

hColor:

HSVColor);

SmallFract

and

Fixed

Converting

Between

FUNCTION

SmallFract2Fix

(s:

SmallFract)

FUNCTION

Fix2SmallFract

(f:

Fixed)

Assembly-Language
Trap

Macro

Requiring

:

:

3

RGBColor);

—

=e

O
pet
o
"3

Values

Fixed;

SmallFract;

Information
Routine

Selectors

_Pack12
Selector

Routine

$0001
$0002
$0003
$0004

Fix2SmallFract
SmallFract2Fix
CMY2RGB
RGB2CMY

$0006
$0007
$0008

RGB2HSL
HSV2RGB
RGB2HSV

$0005

$0009

HSL2RGB

GetColor

Summary of the Color Picker Package

19-13

NO
©
OMWOAUANMHHWWwW

THE

PALETTE

MANAGER

About This Chapter
About the Palette Manager
Palettes
Color Usage Categories
Changing the Color Environment
Restoring the Color Environment
Using the Palette Manager
Working With Color Usage Categories
Courteous Colors
Tolerant Colors
Animated Colors
Displaying Animated Colors on Direct Devices
Explicit Colors
Inhibited Colors
Combined Usage Categories
Creating Palettes
Assigning Colors to a Palette
Creating a Palette in a Resource File
Assigning a Default Palette to an Application
Linking a Color Table to a Palette
Associating One Palette With Many Ports
Palette Manager Routines
Initializing the Palette Manager
Initializing and Allocating Palettes
Interacting With the Window Manager
Drawing With Color Palettes
Animating Color Tables
Manipulating Palettes and Color Tables
Manipulating Palette Entries
Summary of the Palette Manager

nN
=

S

=
@

—

on
@

<<eS)

~
2
ge
@

Lew |

20-1

Inside Macintosh,

20-2

Volume VI

The Palette Manager

ABOUT

THIS

CHAPTER

The Palette Manager monitors the color needs of the graphics environment. The Palette
Manager can track the combined color and gray-scale requirements of the Operating System,
your application, and other applications, and it can do so across multiple screens. This
chapter describes how you can use the Palette Manager to ensure that a set of colors is
available whenever one of your application’s windows is active.

You should be familiar with the Graphics Overview and Color QuickDraw chapters in this
volume, and with the original Color QuickDraw chapter in Volume V.

MANAGER

Your application should use Palette Manager routines if it needs to
= set up and maintain collections of colors or grays
=™ manage shared color resources
= provide exact colors for displaying images
™

initiate color table animation

Your application can specify a color as an RGB value, and Color QuickDraw and the Color
Manager determine the closest match available on the hardware at the time the color is needed.
On direct hardware, the match is virtually exact; on indexed hardware, the match depends
both on the capabilities of the video device and on the color needs of the Operating System
and other applications. By creating a palette of colors for your application, you ensure that
appropriate colors are available when its window becomes frontmost.
The Palette Manager acts as intermediary between the palettes you create for your application’s windows and the color look-up tables (CLUTs) that contain the colors an indexed
device can display. When your window is opened or brought to the front, the Palette
Manager checks your palette’s colors against those in the color tables of all devices the
window touches. The Palette Manager then loads colors into the color tables as needed,
taking into account the sizes of the color tables and the importance you have placed on
various colors in your palette.

About the Palette Manager

os

—

You need to read this chapter if your application uses Color QuickDraw’s color system,
rather than the eight-color system supplied with the original QuickDraw, or no color at all.

PALETTE

oO
as
o

extension, incorporate the revised and expanded Palette Manager. This chapter presents a
complete description of the new Palette Manager. It replaces the Palette Manager chapter in
Volume V.

THE

Comal

ro)ww

a)

System software versions 6.0.5 and later, or those using the 32-Bit QuickDraw™ system

ABOUT

nN
7]

20-3

&
=
=
ge
@
“

Inside Macintosh, Volume VI

You create palettes as resources of type 'pltt’. In the palette resource you specify the RGB
colors your application needs. You can also indicate whether each color needs to be matched
exactly and, if not, how close a match is required. You can tailor your palettes to different
possible video devices—indicating, for example, that certain colors in the palette should
be used with 4-bit pixel depths, that a different set should be used with 8-bit pixel depths,
and that neither set should be used with gray-scale devices. Palettes can also be created from
color tables.
The Palette Manager can handle different screen depths across multiple devices. If the user moves your application window so that it overlaps one gray-scale, one indexed-pixel,
and one direct-pixel screen, the Palette Manager chooses appropriate grays and colors for
all three.
The Palette Manager has access to all palettes used by all windows throughout the system.
A set of default color tables for devices of various depths ensures that the Palette Manager
always returns to a known set of colors when an application terminates, and, when your
application begins executing, it executes in an environment equipped with as broad a range
of colors or grays as the hardware allows.
The rest of this chapter describes
= palettes, and the usage categories to which colors in palettes are assigned
= how the Palette Manager changes the environment by allocating new colors when,
for example, a window is brought to the front
= how the Palette Manager restores the environment when your application
finishes executing
w how you can use the Palette Manager’s color categories
= how to create palettes from resources from within your application, and from
color tables

PALETTES
A palette is a data structure that contains a header and a collection of color records, one for
each color in the palette. The header contains the number of color records in the palette and
the private fields used by the Palette Manager.
TYPE

PaletteHandle

=

“PalettePtr;

PalettePtr

=

“Palette;

Palette

=

RECORD

pmEntries:
pmDataeFields:

Integer;
ARRAY[0..6]

OF

{entries
Integer;

pminfo:

ARRAY[0..0]

OF

{private
fields}
ColoriInfo

{color
END;

20-4

Palettes

in

pminfo}

information}

The Palette Manager

Each color is listed as a color information record, which comprises an RGB color value,
information describing how the color is to be used, a tolerance value for colors that need
only be approximated, and private fields. You should not create and modify the public
fields directly; instead, use the Palette Manager routines.
TYPE

ColoriInfo

tN

=

_

=—

RECORD

—
ww

CiRGB:

RGBColor;

{absolute

ciUsage:

Integer;

{color

ciTolerance:
ciDataFields:

Integer;
ARRAY[0..2]

{tolerance
Integer

OF

{private

RGB

usage

an
—
7.

values}

~~

[ meal
om

information}

rae)
A
—
oan
$9
—
—
nn
ye~
a)
ar

value}
fields}

-_

END;

You can create palettes as resources of type 'pltt’, or by using Palette Manager routines from
within your application.
Your application can create a default palette for the Palette Manager to use when one of your
application’s windows doesn’t have a palette specified. (This may be especially useful to
color applications that use old-style, black-and-white dialog and alert boxes.)

Color

Usage

Categories

When the user activates a window, the Palette Manager examines the window’s palette, if it
has one, to determine whether colors need to be loaded into the current device’s color look-up
tables. If your window requires 180 shades of green, for example, chances are the current
CLUTs lack the necessary colors. Whether the Palette Manager must change a color table
depends on what colors are in it already, what colors you ask for, and the categories into
which your colors fall.
The Palette Manager tracks colors in six usage categories, which you specify to control
the way the Palette Manager allocates colors. You assign usage categories to colors when you
create your palette, and you can change the categories using Palette Manager routines.
= A courteous color accepts whatever value the Color Manager determines to be the
closest match currently available in the color table. On indexed devices, the Palette
Manager lets the Color Manager select appropriate pixel values from those already in
the CLUT. On direct devices, courteous colors always display as specified. Courteous
colors have no special properties, but their use offers you a convenient holding place
for collecting colors.
= A tolerant color also accepts the Color Manager’s choices on an indexed device, but,
unlike a courteous color, a tolerant color specifies an acceptable range for color matching.
If no color in the device’s color table falls within that range, the Palette Manager loads the
color required. On direct devices, the Palette Manager matches tolerant colors as closely
as the hardware allows.

= An animated color is used for special color animation effects, as described in
‘Animated Colors” later in this chapter. Animated colors are reserved by a palette until
its window is closed, and until then their spaces are unavailable to (and can’t be used to
match) any other request for color. The effects of color animation depend on the
Palettes

20-5

Inside Macintosh,

Volume VI

existence of a device color table, and, since a direct device doesn’t have one, color
animation has no effect on a direct device’s display. If your window spans two devices,
one indexed and one direct, the Palette Manager is dexterous enough to animate the
portion on the indexed device’s screen.

= An explicit color specifies an index value, and always generates the corresponding
entry from the device’s color table. Explicit colors are useful if you wish to display the
contents of a color table—for example, to display to a user some or all of the colors
actually available.
= An inhibited color is prevented from appearing on color and gray-scale devices of
specified pixel depths. Inhibited colors are always combined with other usage
categories. You can create a large palette—for example, with two different sets of color
ranges, one optimized for a 4-bit device, the other optimized for an 8-bit device—and
then inhibit colors on the devices for which they are not intended.
= PmWhite and pmBlack colors are assigned to white or black on I-bit devices. If
your application is working with red and dark blue, for example, both might get mapped
to black on a 1-bit device. By assigning pmWhite to one and pmBlack to the other, you
assure that they will be distinct. These categories may be combined with other usage
categories, but combining them with each other is undefined.
Several color usage categories can be combined. You can specify that a color is both tolerant
and explicit, for example, which means that your RGB color, or a tolerably close match, is
placed in the color table at the index corresponding to that palette entry (as opposed to merely
being available somewhere in the table), on all devices that touch the window.
When you specify colors for a palette within a 'pltt' resource, you usually assign the same
usage value to each color in the palette. However, if you must use a particular color differently than the others, you can assign it a different usage value, either when creating the
resource file, or within the application by means of the SetEntryUsage procedure.

CHANGING

THE

COLOR

ENVIRONMENT

The colors available in any particular hardware environment depend on the color or blackand-white settings and the pixel depths that the attached cards and screens can support, and
on what they are set to by the system or by the user.
Since your palette may define more colors than the available hardware can display, the Palette
Manager allocates your requests according to their priority. To make the best use of the
Palette Manager, you should understand the allocation process. Prioritization is important
only when the ActivatePalette procedure is called, which occurs automatically when your
window becomes the frontmost window. (You may also call ActivatePalette yourself after
changing one or more of the palette’s colors or usage categories.)
The Palette Manager first allocates animated colors that are also marked for explicit usage.
Colors that are marked as tolerant and explicit are allocated next.

20-6

Changing the Color Environment

The Palette Manager

The Palette Manager allocates animated colors next. Starting with the first entry in your
window’s palette (entry 0), the Palette Manager checks to see if it is an animated entry. It
checks each animated entry to see that the entry has a reserved index for each appro-priate
device, selecting and reserving an index if it doesn’t. This process continues until all
animated colors have been satisfied or until the available indexes are exhausted.
The Palette Manager handles tolerant colors next. It assigns each tolerant color an index until
all tolerant colors have been satisfied. The Palette Manager then calculates for each entry the
difference between the desired color and the color associated with the selected index. If
the difference exceeds the tolerance you have specified, the Palette Manager marks the selected
device entry to be changed to the desired color.
Since explicit colors designate index values, not the colors at those index locations, and since
courteous colors are amenable to being assigned any RGB value, neither is considered during
prioritization.
When the Palette Manager has matched as many animated and tolerant entries as possible,
it checks to see if the current CLUT is adequate. If modifications are needed, the Palette
Manager overrides any calls made to the Color Manager outside the Palette Manager and
then calls the Color Manager to change the device’s color environment accordingly (with
the SetEntries procedure).
Finally, if the color environment on a given device has changed, the Palette Manager checks
to see if this change has affected any other window in the system. If another window is
affected, the Palette Manager checks that window to see if it specifies an update in the case
of such changes. Applications can use the SetPalette, NSetPalette, or SetPaletteUpdates
procedure to specify whether a window should be updated when its environment has been
changed because of actions by another window. (If so, the InvalRect procedure, described in
the Window Manager chapter of Volume I, updates the window, using the boundary
rectangle of the device that has been changed.)

RESTORING

THE

COLOR

ENVIRONMENT

When a window closes, the Palette Manager resets each display device to its default color
table, except for those indexes still reserved by another application. Eventually, the application that owns those indexes will terminate or voluntarily release the indexes. You can run a
long sequence of color-stealing, wildly animated programs, quit them all, return to the
Finder™, and find every screen in the system fully restocked with default system color tables.
(But if an application calls the Color Manager procedure ProtectEntries to lock a device index,
the Palette Manager cannot restore the default color tables.)
The Palette Manager restores an animated entry to a default color state when the index is no
longer needed.
The Palette Manager provides default color tables for differing screen devices.

Restoring the Color Environment

20-7

nN
—
—

w

a

@
om
=

La)

2
_—

po)
=
pe)
Fe
a)

Ler 3

Inside Macintosh,

Volume VI

Screen device

Default color table

Any device in black-and-white
mode or | bit deep

A gray-scale ramp, that is, an evenly spaced range
from white in index 0 to black in the last index.

A color device in 2-bit mode

Indexes 0 to 3 contain white, 50 percent gray, the
highlight color, and black, respectively.

A color device in 4-bit mode

The resource 'clut' with a resource ID of 4. If the
color closest to the highlight color differs from it by
more than $3000 in any component, the color is
averaged with the highlight color.

A color device in 8-bit mode

The resource ‘clut' with resource ID 8.

The 'clut’ resource IDs 1, 2, 4, and 8 are the standard color tables for those bit depths; they
are shown in Color Plate XXV, “Default Color Tables.” The 'clut' resource IDs 34, 36, and
40—the bit depth plus 32—are gray-scale ramps for those bit depths. The default color tables
with the highlight color added are 'clut' resource IDs 66, 68, and 72—that is, the bit depth
plus 64. To get these color tables, use the GetCTable function (not GetResource), as

described in the Color QuickDraw chapter in this volume.

USING

THE

PALETTE

MANAGER

The Palette Manager is extremely versatile, and your application can use it to obtain an additional level of color control. The Palette Manager can selectively apply QuickDraw, Color
Manager, and Graphics Devices Manager routines, thereby giving you color control across
windows and devices.

Working

With

Color Usage

Categories

You define the usage category for each color in a palette, using these constants:
CONST

20-8

pmCourteous

=

$0000;

{courteous

pmTolerant

=

$0002»

{tolerant

color}

pmAnimated

=

$0004;

{animated

color}

pmExplicit

=

$0008;

{explicit

color}

pmwhite
pmBlack
pmiInhibitG2
pminhibitc2

=
=
=
=

$0010;
$0020;
$0100;
$0200;

{use on 1-bit
device}
{use on 1-bit
device}
{inhibit
on 2-bit
gray-scale
device}
{inhibit
on 2-bit
color device}

pminhibitG4
pmInhibitc4

=
=

$0400;
$0800;

{inhibit
{inhibit

on
on

pmInhibitGs

=

$1000;

{inhibit

pmInhibitcs8

=

$2000;

{inhibit

Using the Palette Manager

color}

4-bit
4-bit

gray-scale
device}
color device}

on

8-bit

gray-scale

on

8-bit

color

device}

device}

The Palette Manager

Effective use of the Palette Manager requires a considered assignment of usage categories for
the colors of your palette.

Courteous

Colors

Courteous colors may seem so polite as to be useless, but they can serve as convenient
placeholders. If your application uses a small number of colors, you can place them in a
palette, ordered according to your preference and designated as courteous.
Suppose you have an open window named myColorWindow that has a palette resource

consisting of a set of eight colors: white, black, red, orange, yellow, green, blue, and violet,

in that order, each with a usage category specified as courteous, as shown in Figure 20-1.

NY

Red

WO

Orange
Yellow
Green

NO

Blue
Violet

Figure 20-1.

Tolerance

Cc

"

A courteous

!

+

Black

Usage

N919NOTaATaATO;O;]O

CO

White

fF

RGB value

palette

The following example paints the rectangle myRect in yellow (palette entry 4, where white is 0).
SetPort

(myColorWindow) ;

PmForeColor
(4);
PaintRect
(myRect);

This is exactly analogous to the following sequence of Color QuickDraw routines, where
yellowRGB is of type ColorSpec:
yellowRGB.red

:=

yellowRGB.green
yellowRGB.blue
SetPort

:=

$FFFF;
$0000;

(myColorWindow) ;

RGBForeColor
PaintRect

SFFFF;
:=

(yellowRGB) ;

(myRect);

Colors with specified usage categories that can’t be satisfied by the Palette Manager default to
courteous colors. This occurs, for example, when drawing to a direct device or one with a
fixed CLUT.

Using the Palette Manager

20-9

Inside Macintosh,

Tolerant

Volume

VI

Colors

Tolerant colors allow you to change the current color environment if the available colors
are not sufficiently close to those your application needs. When your window becomes
the frontmost window on a device, its palette’s colors are given preference. Each tolerant

color is compared to the best match available in the current color environment. (In a multi-

screen environment this comparison is done for each device on which the window is drawn.)
When the difference between your color and the best available match is greater than the
tolerance you specify, the Palette Manager loads an exact match into the CLUT.

The Palette Manager compares the tolerance value associated with each palette entry to a
measure of the difference between two RGB color values. This difference is an approximation of the distance between the two points as measured in a Cartesian coordinate system
where the axes are the unsigned red, green, and blue values. The distance formula used is
A RGB = maximum of (abs(Red1 — Red2), abs(Green! — Green2), abs(Blue!l — Blue2))

A tolerance value of $0000 means that only an exact match is acceptable. (Any value of
$0xxx other than $0000 is reserved and should not be used in applications.) A value of
$5000 is generally sufficient to allow matching without updates in well-balanced color
environments, such as those provided by the default palettes.
If your palette requires more colors than the number of unreserved table indexes, the Palette
Manager checks to see if some other palette has reserved indexes for animation. If so, it
cancels their reservation and makes their indexes available for your palette.
If you ask for more colors than are available on a device, the Palette Manager cannot honor
your request. Color requests that can’t be met default to courteous colors, and the Color
Manager selects the best color available. (That selection will of necessity match one of the
colors elsewhere in your palette, since the Palette Manager runs out of colors only after it has
given your palette all that are available. This procedure works as well as possible for a given
device, but, of course, works better if your window is moved to a deeper device where the
request can be met.)
Note that two tolerant entries may match to the same index even if space isn’t the problem.
For instance, when all indexes are initially assigned to black, activating a palette with
256 shades of gray with tolerance $2000 uses up four indexes, that being sufficient to
match all 256 shades within a tolerance of $2000. If the tolerance were decreased to $1000,
then eight indexes would be altered.
On direct devices, tolerant entries always match exactly.

Animated

Colors

Animated colors allow you to reserve device indexes for color table animation.
One way to change the color of an object on the screen is to change the pixel values in the
object’s part of the pixel map—you draw it again in a different color. In certain situations,
you can get the same effect at less cost in processing and memory by changing the colors in
the video device’s color table instead. All pixel values corresponding to the altered indexes
suddenly appear on the display device in a new color. By careful selection of index values
and the corresponding colors, you can achieve a number of special animation effects.
20-10

—_ Using the Palette Manager

The Palette Manager

To use an animated color, you must first draw with it using the PmForeColor or PmBackColor
procedure. To create color table animation, you then change that entry’s RGB color by using
the AnimateEntry procedure. You can animate a contiguous set of colors by supplying RGB
colors from a color table, using the AnimatePalette procedure.
The way the Palette Manager reserves indexes for animated colors creates some side effects.
The Palette Manager first checks each animated color to see if it already has a reserved index for
the target device. If it does not, the Palette Manager checks all windows and reserves the least
frequently used indexes for your palette. (This reservation process is analogous to that used by
the Color Manager procedure ReserveEntry.) The device’s index and its corresponding color
value are removed from the matching scheme used by Color QuickDraw; you cannot draw
with the color by calling RGBForeColor. (However, when you call PmForeColor, the Palette
Manager locates the reserved index and configures your window’s port to draw with it.) On a
multiscreen system the index reserved is likely to be different for each device, but this process
is invisible to your application.
After reserving one or more device indexes for each animated color it detects, the Palette
Manager changes the color environment to match the RGB values specified in the palette.
The Palette Manager returns the indexes used by your animated entries to each screen
device in any of these situations:
m a window owning those animated entries moves off of that screen
m your application changes the usage of an animated color
w your application disposes of the palette owning those entries (merely hiding a window
does not release its entries)

The Palette Manager replaces previously animated indexes with the corresponding colors
from the default color table for that device.
The Palette Manager receives notice when the screen depth changes, so that it can take
appropriate action at that time, such as setting color tables to their defaults.

Displaying

Animated

Colors on Direct Devices

Color table animation doesn’t work on a direct device—it has no color table. To present the
best appearance, for example, on a window that spans an indexed device and a direct device,
the Palette Manager records two colors in the ciRGB field of the color information record: the
last color the entry was set to by SetEntryColor, and the last color the entry was set to by
AnimateEntry or AnimatePalette. In the palette record, the high bytes of the components
in the ciRGB field reflect the animated color, and the low bytes contain the color set by
SetEntryColor. (GetEntryColor returns the last color the entry was animated to.) When you
draw with an animated color on a direct device (or on any device on which the animated color
was not allocated and reserved), then the color set by SetEntryColor is used. This allows
successive updates of an animated image on a direct device to match correctly. A side effect is
that GetEntryColor does not necessarily return an exact match of the color originally set (only
the top 8 bits are an exact match).
A

Warning: This internal usage of the color information fields may change.
For maximum safety, use the procedures SetEntryColor, SetEntry Usage,
GetEntryColor, and GetEntryUsage. a
Using the Palette Manager

= 20-11

bX

=

x
=

sa)

~a

@

<2
~_
=
=
he
Te
@=

Inside Macintosh,

Volume VI

Explicit Colors
Use explicit entries when your primary concern is the index value rather than the color stored
at that index.
Explicit colors cause no change in the color environment. For indexed devices, the Palette

Manager ignores the RGB value in a palette if a color is an explicit color. When you draw

with an explicit color, you get the color that is currently at the CLUT entry whose index
corresponds to the explicit color’s position in the palette. When you call PmForeColor with a
parameter of 12, it places a value of 12 into the foreground color field of your window’s
color grafPort. (Since the value wraps around the table, the value placed into the foreground
field would be
12 modulo (maxIndex + 1)
where max/ndex is the maximum available index for each device under consideration.)

On direct devices an explicit entry produces the color for that entry in the palette.
You can use explicit colors to monitor the color environment on an indexed screen device.
For example, you could draw a 16-by-16 grid of 256 explicit colors in a small window.
Whatever colors appear are exactly those in the device’s color table. If color table animation
is taking place simultaneously, the corresponding colors in the small window animate as
well. If you display such a window on a 4-bit device, the first 16 colors match the 16 colors
available in the device, and each row thereafter is a copy of the first row.

Inhibited

Colors

The Palette Manager recognizes six inhibited usage categories that give you control of which
palette entries can and cannot appear on depths of 2, 4, and 8 bits per pixel, on color or grayscale devices. The categories are specified using these constants:
CONST

pmiInhibitG2

=

$0100;

{inhibit

on

2-bit

gray-scale

pmInhibitC2

=

$0200;

{inhibit

on

2-bit

color

pminhibitG4

=

$0400;

{inhibit

on

4-bit

gray-scale

pminhibitc4

=

$0800;

{inhibit

on

4-bit

color

pminhibitG8

=

$1000;

{inhibit

on

8-bit

gray-scale

pmiInhibitcs

=

$2000;

{inhibit

on

8-bit

color

device}

device}
device}

device}

device}

device}

Here is an example of how these categories can be combined.
myColor8Usage

:=

SetEntryUsage

20-12.

(myPalHandle,

300,pmAnimated+pmExplicit+pmInhibitG2+

pmInhibitC2

+pminhibitG4+pmInhibitC4+pmInhibitG8,0);

Using the Palette Manager

The Palette Manager

This sets the usage of entry 300 of the palette specified by myPalHandle to the combined
usages of animated and explicit, to be allocated only on color 8-bit devices. (Since 300 is
greater than 255, the highest index on an 8-bit device, the index associated with that entry
wraps around to 44.)
You should always inhibit tolerant colors on gray-scale devices. Color QuickDraw now
allows luminance mapping on gray-scale devices. The default CLUT on a gray-scale device
is an evenly spaced gray ramp from black to white. Since this is usually the best possible
spread on a gray-scale device, you could specify all three inhibited gray-scale categories.
As another example, on a 4-bit device you might want to allocate 14 tolerant colors, while on
an 8-bit device there are sufficient indexes that you can also use a number of animated colors.
By inhibiting the animated entries on 4-bit devices, you ensure that your 14 tolerant colors are
allocated. Merely sequencing the palette doesn’t solve this problem, because the animated
colors always take precedence over the tolerant colors. (For more information about
sequencing, see “Assigning Colors to a Palette” later in this chapter.)

Combined

Usage

Categories

The inhibited usage category is always combined with some other usage category. In addition, the explicit usage category can be combined with the tolerant and animated categories.
The main purpose for using explicit colors is to provide a convenient interface to color table
indexes. You can select any of these colors for drawing by setting your window’s palette to
contain as many explicit colors as are in the target device with the greatest number of indexes.
PmForeColor configures the color grafPort to draw with the index of your choice. So that
you can easily create effective explicit palettes, two color usage categories can be combined:
pmTolerant + pmExplicit and pnAnimated + pmExplicit.
The pmTolerant + pmExplicit combined usage means that you get the color you want at the
index you want, across all devices that the window touches. As with pmTolerant, other
windows may use those colors in their displays.
The pmAnimated + pmExplicit combined usage means that you get the color you want at the
index you want, across all devices that intersect the window, but windows that don’t share
the palette can’t use that index. The entry can be animated by a call to the AnimateEntry
procedure.
Since the value of an explicit entry is treated as the entry modulo the bit depth, index
collisions can occur between entries of the same usage within a palette. In this case, the
lower-numbered entry gets the index. For example, if palette entries | and 17 were both
pmAnimated + pmExplicit, then on a 4-bit screen, entry | would get index 1, and entry 17,
although it wraps around to 1, would get nothing.
Unallocated pmTolerant + pmExplicit colors revert to pmTolerant. Unallocated pmAnimated +
pmExplicit colors revert to pmCourteous.

Using the Palette Manager

— 20-13

i

—_
oe
=e

~
pe)
aw

©
ws
=
re)

2
—

pe)

~
a

ve

a")

Lew

|

Inside Macintosh,

Creating

Volume VI

Palettes

Typically, you create a palette from the colors in a resource of type 'pltt' using the
GetNewPalette function. You can also create a palette from the colors in a color table
by using the NewPalette function.

Assigning

Colors to a Palette

The inhibited usage categories are the best way to be sure that the right colors are available for

screens of different depths, but in many situations you can achieve the same effect with a

single set of colors if you sequence the colors in the palette, or arrange them according to the
screen depth of the device that uses them, from least to greatest depth.
Color QuickDraw, to support standard QuickDraw features, puts white and black at the
beginning and end, respectively, of each device’s color table, and the Palette Manager never
changes them. Thus the maximum number of indexes available for animated or tolerant colors
is really the maximum number of indexes minus 2.

After white and black, you should assign the next two colors to the two you wish to have if

the device is a 2-bit device. Likewise, the first 16 colors should be the optimal palette entries
for a 4-bit device, and the first 256 colors should be the optimal palette entries for an 8-bit
device. You should inhibit colors for gray-scale devices.

Creating

a Palette in a Resource

File

The format of a palette resource (type 'pltt') is an image of the palette structure itself. The
private fields in both the header and in each color information record are reserved for future
use. Listing 20-1 shows a palette resource with 16 entries as it would appear within a resource
file. Each entry has a tolerance value of 0, meaning that the color should be matched exactly.
Listing 20-1.
#define

zeroTolerance

resource

{

/*

[1]

'pltt'

/*

(128,

65535,

/*

black

[2]

"Simple

65535,

Palette")

16

{

elements

pmTolerant,

*/

zeroTolerance,

*/

0,
/*
[3]
64512,
/*
[4]
65535,

QO,
<Q,
yellow,
62333,
orange
25738,

/*

blue-green

[5]

(‘pltt') resource

0

array ColorInfo:
white */

65535,

A palette

pmTolerant,
for bit depths
>=
1327,
pmTolerant,
*/
652,
pmTolerant,
used

in

bit

2

zeroTolerance,
*/
zeroTolerance,
zeroTolerance,

depths

>=

4

*/

881,
/*
[6]

50943,
40649,
green
*/

pmTolerant,

zeroTolerance,

Dy
/*
[7]
22015,

22015,
blue
*/
O,
VQ;

pmTolerant,

zeroTolerance,

pmTolerant,

zeroTolerance

/*

red

pmTolerant,

zeroTolerance,

[8]

56683,

20-14

2242,

0,

*/
1698,

— Using the Palette Manager

The Palette Manager

/*
[9]
49152,

light
gray
*/
49152,
49152,

/*

medium

pmTolerant,

zeroTolerance,

32768,

pmTolerant,

zeroTolerance,

65535;
/*
[12]

50140,
33120,
brown
*/

pmTolerant,

zeroTolerance,

37887,

10266,

pmTolerant,

/*
[13]
25892,

olive green
49919,
Q,

/*

bright

green

65535,

1265,

[10]

32768,

32768,

/*

beige

(11]

[14]

0,
/*

[15]

Q,

/*

[16]

blue

0,

$5535;

ho

_
—

4812,

sky

@;

*/

*/

violet

32/68;

}%

gray

—

zeroTolerance,

w

Si

*/
pmTolerant,

zeroTolerance,

pmTolerant,

zeroTolerance,

pmTolerant,

zeroTolerance,

pmTolerant,

zeroTolerance

@
ne

-,

@&

2

*/

no

oS)

—

=)

SS
ge

*/

@

ne

*/

65535,

}

Use GetNewPalette to obtain a 'pltt' resource; it initializes private fields in the palette data

structure. (Don’t use GetResource.)

Listing 20-2 shows a palette with a variety of usage categories. The first two entries, for
white and black, are the same as in the palette in Listing 20-1. The next three entries are
animated and explicit, and inhibited on gray-scale devices. Entries 6 through 14 are tolerant
with zero tolerance and inhibited on gray-scale devices. The last two entries in the palette are
inhibited on color devices as well if they can only display 16 colors.
Listing 20-2.
#define

zeroTolerance

#define

pmInhibitG2

0x0100

#define

pmInhibitC2

0x0200

#define
#define

pmInhibitG4
pmInhibitC4

0x0400
0x0800

#define

pmInhibitG8

0x1000

#tdefine

pmInhibitc8s

0x2000

A multi-use palette

0

/* inhibit in all gray-scale devices
#define grayDevinhibit
(pmInhibitG2

#define

pmTolerant

2

#define

pmAnimated

4

#define

pmExplicit

8

#define

pmAnimDeviInhibit

/*

QD

does

so

it

is

*/
+

(pmAnimated

pmInhibitG4

+

the

best

job

at

displaying

a

good

idea

to

inhibit

pmInhibitG8)

grayDeviInhibit)

colors

colors

+

in

in
all

gray-scale
gray-scale

devices
devices.

*/

(Continued)

Using the Palette Manager

—20-15

|

Inside Macintosh,

Volume V1

Listing 20-2.
resource

{

/*

array

fe

[5]

ColorInfo:

Fy

Os

0,

pmTolerant,

/*

request
™?

f= [4]
65535,
f* [5]

*/

*/

pmTolerant,

[2]

f*
[3]
64512,

elements

65535,

fe

animated

entries

to

zeroTolerance,
zeroTolerance,

go

in

known

'clut'

slots

*/

62333,

1327,

(pmAnimDevInhibit

+

pmExplicit),

zeroTolerance,

25738,

652,

(omAnimDevinhibit

+

pmExplicit),

zeroTolerance,

+

pmExplicit),

zeroTolerance,

*/
50943,

/*

now

let

/*®

[6]

*/

40649,

(pmAnimDevInhibit

the

Palette

%

22015,

(pmTolerant

+

grayDeviInhibit),

zeroTolerance,

O,

0,

(pmTolerant

+

grayDevInhibit),

zeroTolerance,

2242,

1698,

(pmTolerant

+

grayDeviInhibit),

zeroTolerance,

49152,

49152,

49152,

(pmTolerant

+

grayDeviInhibit),

zeroTolerance,

/*

*/
32768,

(pmTolerant

+

grayDeviInkibit),

zeroTolerance,

33120,

(pmTolerant

+

grayDevinhibit),

zeroTolerance,

4812,

(pmTolerant

+

grayDevInhibit),

zeroTolerance,

OQ,

(pmTolerant

+

grayDeviInhibit),

zeroTolerance,

(omTolerant

+

grayDevInhibit),

zeroTolerance,

entries

4-bit

0,
/*

22015
[7]

fe

TR)
(3)

the

next

colors

where

it

wants

*/

*y

[10]

32768,

32768,

{*®

¥/

[11]

65535,

50140,

f*®

*/

[12]

37887,

10266,

/*®

*/

[13]

25892,

49919,

f®

*7

[1a]

0,

65535,

/*

inhibit

{*

[15]

*7

[16]

*/

0,

f=

put

By

56683,

ce

Manager

* /

22015,

77

16

{

Palette")

65535,

881,

}

"Inhibiting

Px

65535,
0,

(129,

'pltt'

A multi-use palette (Continued)

32768,

Assigning

1265,

the

last

65535,

OO,

0,

65535,

a Default

two

in

deep

devices

*/

(pmTolerant

+

grayDeviInhibit

+

pmInhibitC4),

zeroTolerance,

(omTolerant

+

grayDevinhibit

+

pmInhibitc4),

zeroTolerance

Palette to an Application

Your application can define a palette for the Operating System to use when it needs to define
the color environment. Defining a default palette for your color application is useful if all your
windows use the same palette, or if you use old-style dialog and alert boxes: without an
application palette, the system uses its own default palette to define the color environment.
You set a palette as the application default by assigning it a resource ID of 0. If the system
needs a palette to define a color environment, it looks in the resource fork of the application
for the 'pltt' resource with an ID equal to 0 and uses the palette that it contains. If the system
20-16

— Using the Palette Manager

The Palette Manager

cannot find this resource in the application’s resource fork, it uses its own default palette
(resource ‘pltt' ID = 0 in the System file). If the system has no default palette, it uses the
Palette Manager’s built-in palette.
Once your application has set its color environment (by calling InitMenus, or InitPalettes in
unusual instances when there are no menus), you can find the default palette for your
application by using the GetPalette function.
myPaletteHndl

:=

GetPalette

(WindowPtr

ne
ao
——

~

a

(-1));

@

os

@

4

You can change the default palette by specifying a palette in the SetPalette procedure.
SetPalette

(WindowPtr

—_

to)
=
ne
ge

(-1),newDefPlttHndl,
TRUE) ;

@
ar |

Linking a Color Table to a Palette
Suppose your application displays an image drawn with 64 gray levels in a window and uses
a control to adjust the brightness or contrast. If you draw your image with animated palette
entries, you can then use AnimatePalette to change the particular shades rapidly. But you
have to call PmForeColor with the index of the upper-left pixel, paint a 1-by-1 rectangle, call
PmForeColor for the next pixel, paint a rectangle, and so on.
Color QuickDraw now supports a method by which a color table can refer to palette indexes
instead of RGB values. Setting bit 14 (using OR with $4000) in the ctFlags field of the color
table record causes the fields in a source pixel map’s color table to be interpreted as follows:
Field

descriptions

ctSeed

A unique value.

ctFlags

Flags, with bit 14 set, as described in the previous paragraph.

ctSize

The size of the color table, less 1.

ctTable

An array [0..ctSize] of colorSpec values (each an index value and an

ctTable[x].value

The palette entry to use when drawing pixels with value x.
(Note that this is different from previous uses, where the value field
specified which pixel number the entry applied to.)

ctTable[x].rgb

The color used if there is no available palette or if the palette is too
small to contain the specified entry.

RGB

value).

For example, to draw a 64-level image in animated colors (as described in “Animated Colors”
earlier in this chapter), you put the palette entry number you want for pixel value 0 into the
first value field of the source color table’s color specification record, the palette entry corresponding to pixel value | in the next value field, and so on. If your palette is arranged in the
same order as the pixel values, the value fields simply count from 0 to 63. By calling the
AnimatePalette procedure for each of those entries, you can produce color table animation on
all screens that have reserved an animated entry, are crossed by the window, and are able to
display such an image.
Using the Palette Manager

—_ 20-17

Inside Macintosh,

Volume

VI

Since 16-bit and 32-bit direct devices do not have CLUTs, you may wish to post an update to
display an image of those areas that intersect a direct device.
In the case of an animated picture adjustment, like a contrast or brightness control, it is better
to animate while the user is moving the indicator and update when the user releases it.

Associating

One

Palette With

Many

Ports

The SetPalette and NSetPalette procedures allow you to associate one palette with many color
grafPort and color window records, thus simplifying the use of a single palette with multiple
ports and windows.
One important implication of this feature is that the DisposeWindow procedure does not dispose
of the associated palette automatically, since it may be allocated to other ports or windows. The
only exception to this behavior is when an application has used GetNewC Window
to create the
window, there is a 'pltt' resource with the same ID as the window, and the application has not
called GetPalette for the window.

PALETTE

MANAGER

ROUTINES

The Palette Manager has a number of routines for establishing and maintaining palettes and
for interacting with the Window Manager. It also has two procedures for actual drawing,
PmForeColor and PmBackColor. In Palette Manager usage, those procedures replace Color
QuickDraw’s RGBForeColor and RGBBackColor procedures.
The procedures SaveFore, RestoreFore, SaveBack, RestoreBack, ResizePalette, and
RestoreDeviceClut are available only with system software versions 6.0.5 and later, and
with the 32-Bit QuickDraw system extension.

Initializing the

Palette

Manager

The Palette Manager is initialized during the first InitWindows call after system startup, and it
continues to run as needed whenever windows are moved. The InitWindows procedure calls
InitPalettes, which initializes the Palette Manager, if necessary, and searches the device list to
find all active CLUT devices.
PROCEDURE

InitPalettes;

InitPalettes initializes the Palette Manager. It searches for devices that support a CLUT and
initializes an internal data structure for each one. This procedure is called by InitWindows and
does not have to be called by your application.
FUNCTION

PMgrVersion

:

Integer;

The PMgrVersion function returns an integer specifying the version number of the currently
executing Palette Manager. Returned values may be as follows.
20-18

— Palette Manager Routines

The Palette Manager

Value

Description

$0202

System software version 7.0

$0201

System software version 6.0.5

$0200

Original 32-Bit QuickDraw system extension
nN

Initializing and

Allocating

=

Palettes

AY
=

is")

Normally, you create a new palette from a 'pltt' resource using the GetNewPalette function.
To create a palette from within your application, use the NewPalette function. Regardless of
how you create the palette, you can then use the SetPalette procedure to render the palette on
the screen. The DisposePalette procedure disposes of the entire palette.
FUNCTION

GetNewPalette

(paletteID:

Integer)

:

PaletteHandle;

GetNewPalette creates a palette from information supplied by the palette specified in the
paletteID parameter; it then initializes the new palette and attaches it to the current window.
If you open a new color window with GetNewCWindow, the Window Manager calls
GetNewPalette automatically with paletteID equal to the window’s resource ID. A palette
resource is identified by type 'pltt'. A palette ID of 0 is reserved for the application’s palette
resource, which is used as the default palette for a window (either color or black and white)
without an assigned palette. If there is no assigned palette or application default palette,
GetNewPalette uses the system palette whose resource ID is 0, if present.
FUNCTION

NewPalette

(entries:

Integer;

srcTolerance:

srcColors:

Integer)

:

CTabHandle;

srcUsage,

PaletteHandle;

NewPalette allocates a new palette from colors in the color table specified by srcColors,
with enough room for the number of colors specified by the entries parameter. NewPalette
fills the palette with as many RGB values from the color table as it has or as it can fit.
NewPalette sets the usage field of each color to the value in the srcUsage parameter and the
tolerance value of each color to the value in the srcTolerance parameter. If no color table is
provided (srcColors = NIL), then all colors in the palette are set to black (red, green, and
blue equal to $0000).
PROCEDURE

DisposePalette

(srcPalette:

PaletteHandle) ;

DisposePalette disposes of the palette specified in the srcPalette parameter. If the palette has
any entries allocated for animation on any screen device, these entries are relinquished before
the palette’s memory is released.

Interacting

With

the

Window

Manager

The ActivatePalette procedure adjusts the color environment whenever your window's
status changes. Your application can also use ActivatePalette after making changes to a
palette. You can use GetPalette to return a handle to the palette currently associated with
a specified window.
Palette Manager Routines

— 20-19

oa
=

is)

<2
—

=

=
fe

ve
@
=

Inside Macintosh,

PROCEDURE

Volume VI

ActivatePalette

(srcWindow:

WindowPtr);

The Window Manager calls ActivatePalette when your window’s status changes—for
example, when your window opens, closes, moves, or becomes frontmost. Call
ActivatePalette after making changes to a palette with Palette Manager routines such as
SetEntryColor. Such changes do not take effect until the next call to ActivatePalette,
thereby allowing you to make a series of palette changes without any immediate change
in the color environment.
If the window specified in the srcWindow parameter is frontmost, ActivatePalette examines
the information stored in the window’s palette and attempts to provide the color environment
described therein. It determines a list of devices on which to render the palette by intersecting

the port rectangle of the window with each device. If the intersection is not empty, and if the

device has a CLUT, then ActivatePalette checks to see if the color environment is sufficient.
If a change is required, ActivatePalette calls the Color Manager to reserve or modify the
device’s color entries as needed. It then generates update events for all windows that need
color updates.
Calling ActivatePalette with an offscreen port has no effect.
FUNCTION

GetPalette

(srcWindow:

WindowPtr)

:

PaletteHandle;

GetPalette returns a handle to the palette associated with the window specified in the
src Window parameter. If the window has no associated palette, or if the window is
not a color window, GetPalette returns NIL.
PROCEDURE

SetPalette

(dstWindow:

WindowPtr;

cUpdates:

Boolean);

srcPalette:

PaletteHandle;

SetPalette changes the palette associated with the window specified in the dstWindow
parameter to the palette specified in the srcPalette parameter. It also records whether the
window is to receive updates as a result of changes to its color environment. If you want
the window to be updated whenever its color environment changes, set the cUpdates
parameter to TRUE.
PROCEDURE

NSetPalette

(dstWindow:

WindowPtr;

nCUpdates:

Integer) ;

srcPalette:

PaletteHandle;

NSetPalette is identical to SetPalette, except that the nCUpdates parameter is an integer rather
than a Boolean value. NSetPalette changes the palette associated with the window specified
in the dstWindow parameter to the palette specified by srcPalette. NSetPalette also records
whether the window is to receive updates as a result of changes to its color environment. If
you want the window to be updated whenever its color environment changes, set nCUpdates
to the constant pmAll Updates. If you are interested in updates only when the window is the
active window, set nCUpdates to the constant pmFg Updates. If you are interested in updates
only when the window is not the active window, set nCUpdates to the constant pnBkUpdates.

20-20

Palette Manager Routines

The Palette Manager

CONST

pmNoUpdates

=

$8000;

{no

pmBkUpdates

=

$SA000;

{background

updates}
updates

only}

pmFgUpdates

=

$eoo0;

{foreground

updates

only}

pmAllUpdates

=

$E000;

{all

updates}
=

NSetPalette is available in system software versions 6.0.2 and later.

~~

y)
©
=
o

—

PROCEDURE

SetPalettcUpdates

(p:

PaletteHandle;

updates:

Integer);

2
=

The SetPaletteUpdates procedure sets the update attribute of a palette. In the p parameter you
supply a handle to the palette, and in the updates parameter you supply one of the update
attributes described for the NSetPalette procedure.
FUNCTION

GetPaletteUpdates

(p:

PaletteHandle)

:

Integer;

The GetPaletteUpdates function returns the update attribute of a palette. In the p parameter
you supply a handle to the palette, and the function returns one of the update attributes
described for the NSetPalette procedure.

Drawing

With

Color

Palettes

The PmForeColor and PmBackColor procedures allow applications to specify foreground
and background drawing colors with the assistance of the Palette Manager. Substitute these
procedures for the Color QuickDraw procedures RGBForeColor and RGBBackColor when
you wish to use a color from a palette. You can still use RGBForeColor and RGBBackColor
whenever you wish to specify drawing colors—for example, when you wish to use a color
that is not contained in your palette.
You can save and restore the current foreground and background colors by using the
SaveFore, RestoreFore, SaveBack, and RestoreBack procedures.
PROCEDURE

PmForeColor

(dstEntry:

Integer);

PmForeColor sets the current color grafPort’s RGB and index foreground color fields to
match the palette entry of the window record’s current color grafPort corresponding to the
value in the dstEntry parameter.
For courteous and tolerant entries, PmForeColor calls the RGBForeColor procedure using
the RGB color of the palette entry. For animated colors, PmForeColor selects the recorded
device index previously reserved for animation (if still present) and installs it in the color
grafPort. The RGB foreground color field is set to the value from the palette entry. For
explicit colors, PmForeColor places the value
dstEntry modulo (max/ndex +1)

into the color grafPort, where max/ndex is the largest index available in a device’s CLUT.
When multiple devices with different depths are present, the value of maxIndex varies
appropriately for each device.
Palette Manager Routines

20-21

4
=}

fg
o

ge

Ler |

Inside Macintosh,

PROCEDURE

Volume V1

PmBackColor

(dstEntry:

Integer);

PmBackColor sets the current color grafPort’s RGB and index background color fields to
match the palette entry of the window record’s current color grafPort corresponding to the
value in the dstEntry parameter.
For courteous and tolerant entries, PmBackColor calls the RGBBackColor procedure using
the RGB color of the palette entry. For animated colors, PmBackColor selects the recorded
device index previously reserved for animation (if still present) and installs it in the color
grafPort. The rgbBgColor field is set to the value from the palette entry. For explicit colors,
PmBackColor places the value
dstEntry modulo (maxIndex +1)

into the color grafPort, where max/ndex is the largest index available in a device’s CLUT.
When multiple devices with different depths are present, max/ndex varies appropriately for
each device.
PROCEDURE

SaveFore

(VAR

c:

ColorSpec);

The SaveFore procedure returns the current foreground color in the c parameter. A value
of 0 in the value field of the color specification record specifies an RGB color (obtained

from the rgbFgColor field of the color grafPort record); a value of | in the value field
specifies a palette entry (obtained from the pmFgColor field of the GrafVars record).
PROCEDURE

RestoreFore

(c:

ColorSpec) ;

The RestoreFore procedure stores the RGB color of the color specification record specified
by the c parameter as the current foreground color. If you specify 0 in the value field of the
color specification record, the RestoreFore procedure stores the RGB value in the rgbFgColor
field of the current color grafPort record. If you specify | in the value field of the color
specification record, the RestoreFore procedure stores the RGB value in the pmFgColor field
of the GrafVars record.
PROCEDURE

SaveBack

(VAR

c:

ColorSpec) ;

The SaveBack procedure returns the current background color in the c parameter. A value of
0 in the value field of the color specification record specifies an RGB color (obtained from the
rgbBkColor field of the color grafPort record); a value of | in the value field specifies a
palette entry (obtained from the pmBkColor field of the GrafVars record).
PROCEDURE

RestoreBack

(c:

ColorSpec);
¢

The RestoreBack procedure stores the RGB color of the color specification record specified
by the c parameter as the current foreground color. If you specify 0 in the value field of the
color specification record, the RestoreBack procedure stores the RGB value in the rgbFgColor
field of the current color grafPort record. If you specify | in the value field of the color specification record, the RestoreBack procedure stores the RGB value in the pmBkColor field of
the GrafVars record.
20-22.

Palette Manager Routines

The Palette Manager

Animating

Color

Tables

To use color table animation, you can change the colors in a palette and on corresponding
devices with the AnimateEntry and AnimatePalette procedures.
PROCEDURE

AnimateEntry

(dstWindow:

WindowPtr;

dstEntry:

Integer;

srcRGB:

RGBColor) ;

w

=

If the palette entry is not an animated color, or if the associated indexes are no longer
reserved, no animation occurs.
If you have blocked color updates in a window by using SetPalette with cUpdates set to
FALSE, you may observe unintentional animation. This occurs when ActivatePalette reserves
for animation device indexes that are already used in the window. Redrawing the window,
which normally is the result of a color update event, removes any animated colors that do not
belong to the window.
AnimatePalette

(dstWindow:

WindowPtr;

srcCTab:

srcindex,dstEntry,dstLength:

CTabHandle;
Integer) ;

AnimatePalette is similar to AnimateEntry, but it acts upon a range of palette entries. Beginning
at the index specified by the srcIndex parameter (which has a minimum value of 0), the number
of entries specified in dstLength are copied from the source color table to the destination window’s palette, beginning at the entry specified in the dstEntry parameter. If the source color
table specified in srcCTab is not sufficiently large to accommodate the request, AnimatePalette
modifies as many entries as possible and leaves the remaining entries unchanged.

Manipulating

Palettes

and

Color Tables

You can use the CopyPalette procedure to copy palettes from other palettes and from color
tables, and you can use the ResizePalette procedure to resize palettes. The RestoreDeviceClut
procedure restores the CLUT of a device to its default set of colors. CTab2Palette copies the
specified color table into a palette, and its opposite, Palette2CTab, copies a palette into a color
table. Each procedure resizes the target object as needed.
PROCEDURE

CopyPalette

S
a

AnimateEntry changes the RGB value of a window’s palette entry. The window is specified
in the dstWindow parameter; the palette entry is specified in the dstEntry parameter; the new
RGB value is specified in the srcRGB parameter. Each device for which an index has been
reserved is immediately modified to contain the new value. This is not considered to be a
change to the device’s color environment, because no other windows should be using the
animated entry.

PROCEDURE

ho

(srcPalette,dstPalette:

PaletteHandle;

srcEntry,dstEntry,dstLength:

Integer) ;

CopyPalette copies entries from the source palette into the destination palette. The copy
operation begins at the values specified by the srcEntry and dstEntry parameters, copying
into as many entries as are specified by the dstLength parameter. CopyPalette resizes the
destination palette when the number of entries after the copy operation is greater than it was
before the copy operation.

Palette Manager Routines

— 20-23

@

-

@

tt]
~
pe)
Fe
@
or

Inside Macintosh, Volume VI

CopyPalette does not call ActivatePalette, so your application is free to change the palette a

number of times without causing a series of intermediate changes to the color environment.
Your application should call ActivatePalette after completing all palette changes.
If either of the palette handles is NIL, CopyPalette does nothing.
PROCEDURE

ResizePalette

(srcPalette:

PaletteHandle;

size:

Integer);

ResizePalette sets the palette specified in srcPalette to the number of entries indicated in
the size parameter. If ResizePalette adds entries at the end of the palette, it sets them to
pmCourteous, with the RGB values set to (0,0,0)—that is, black. If ResizePalette deletes
entries from the end of the palette, it safely disposes of them.
PROCEDURE

RestoreDeviceClut

(gdh:

GDHandle) ;

RestoreDeviceClut changes the CLUT of the device specified by the gdh parameter to its
default state. If this process changes any entries, color updates are posted to windows
intersecting the device. Passing NIL in gdh causes all screens to be restored. Do not call
this procedure frivolously, but you can use it to update screens after the highlight color
has changed.
PROCEDURE

CTab2Palette

(srcCTab:

CTabHandle;

srcUsage,srcTolerance:

dstPalette:

PaletteHandle;

Integer) ;

CTab2Palette is a convenience procedure that copies the fields from an existing color table
record into an existing palette record. If the records are not the same size, then CTab2Palette
resizes the palette record to match the number of entries in the color table record. If the palette
in dstPalette has any entries allocated for animation on any screen device, they are relinquished
before the new colors are copied. The srcUsage and srcTolerance parameters are the value that
you assign to the new colors.
If you want to use color table animation, you can use AnimateEntry and AnimatePalette to
change the colors in a palette and on corresponding devices. Changes made to a palette by
CTab2Palette don’t take effect until the next ActivatePalette procedure is performed. If either
the color table handle or the palette handle is NIL, CTab2Palette does nothing.
PROCEDURE

Palette2CTab

(srcPalette:

PaletteHandle;

dstCTab:

CTabHandle);

Palette2CTab is a convenience procedure that copies all of the colors from an existing palette
record into an existing color table record. If the records are not the same size, then Palette2CTab
resizes the color table record to match the number of entries in the palette record. If either the
palette handle or the color table handle is NIL, Palette2CTab does nothing.

Manipulating

Palette

Entries

GetEntryColor, GetEntryUsage, SetEntryColor, and SetEntryUsage allow your application
to retrieve and modify the fields of a palette. Entry2Index returns an index for a palette entry.

20-24

Palette Manager Routines

The Palette Manager

PROCEDURE

GetEntryColor

(srcPalette:

PaletteHandle;

VAR

RGBColor);

dstRGB:

srcEntry:

Integer;

GetEntryColor gives your application access to the color of a palette entry. It takes the
RGB color of the entry specified by the srcEntry parameter and stores it in the destination RGB color record. You can modify the color using the SetEntryColor procedure.
PROCEDURE

GetEntryUsage

(srcPalette:
PaletteHandle;
VAR dstUsage,dstTolerance:

srcEntry:
Integer);

nN

—)

a”)

Integer;

SetEntryColor

(dstPalette:
SrcRGB:

PaletteHandle;

dstEntry:

<<=

Integer;

RGBColor) ;

SetEntryColor provides a convenient way for your application to modify the color of a single
palette entry. It stores the RGB color of the srcRGB parameter in the palette entry specified
by the dstEntry parameter. SetEntryColor marks the entry as having changed, but it does not
change the color environment. The change occurs upon the next call to ActivatePalette.
SetEntryColor marks modified entries such that the palette is updated, even though no update
is required by a change in the color environment.
PROCEDURE

SetEntryUsage

(dstPalette:

PaletteHandle;

srcUsage,srcTolerance:

dstEntry:

Integer;

Integer);

SetEntry Usage provides a convenient way for your application to modify the usage category
of a single palette entry. The usage and tolerance values specified by the srcUsage and
srcTolerance parameters are stored in the palette entry specified by the dstEntry parameter.
SetEntryUsage marks the entry as having changed, but it does not change the color environment. The change occurs upon the next call to ActivatePalette. Modified entries are
marked such that the palette is updated even though no update is required by a change in
the color environment. If either srcUsage or srcTolerance is set to $FFFF (—1), the entries

are not changed.

This procedure allows you to easily modify a palette created with NewPalette or modified by
CTab2Palette. For such palettes the ciUsage and ciTolerance fields of the color information
record are the same, because you can designate only one value for each. You typically call
SetEntry Usage after NewPalette or CTab2Palette to adjust and customize your palette.
FUNCTION

Entry2Index

(entry:

Integer)

:

—s

@

GetEntry Usage gives your application access to the usage and tolerance fields of a palette
entry. It takes the usage and tolerance values of the entry specified by the srcEntry parameter
and stores them in the dstUsage and dstTolerance parameters. You can modify these values
by using the SetEntryUsage procedure.
PROCEDURE

2@

-—-

LongInt;

Given an entry number, this function returns the index for that entry in the current grafPort’s
palette on the current device.

Palette Manager Routines

— 20-25

=
ee)
it5)

so

Inside Macintosh,

SUMMARY

Volume VI

OF

THE

PALETTE

MANAGER

Constants
CONST

{usage

constants}

pmCourteous

$0000;

{courteous

pmTolerant

$0002;

{tolerant

color}

{animated

color}

{explicit
{use

on

1-bit

on

1-bit

pmAnimated
pmExplicit
pmWhite

=

$0004;
$0008;
$0010;

pmBlack

=

$0020;

{use

pmIinhibitG2

=

$0100;

pmInhibitc2

=

pminhibitG4
pminhibitc4

=
=

$0200;
$0400;

pmInhibitG8
pminhibitcs

=
=

{inhibit
{inhibit
{inhibit
{inhibit
{inhibit
{inhibit

TYPE

$1000;
$2000;

color}

on
on
on
on
on
on

{NSetPalette

update

constants}

pmNoUpdates

a
=

$8000;

{no

pmBkUpdates
pmFgUpdates

SA000;
$c000;

{background
{foreground

SE000;

{all

pmAllUpdates

Data

$0800;

color}

device}
device}

2-bit
2-bit
4-bit
4-bit
8-bit
8-bit

gray-scale device}
color device}
gray-scale

device}

color device}
gray-scale device}
color device}

updates}
updates
updates

only}
only}

updates}

Types
PaletteHandle

“PalettePtr;

PalettePtr

“Palette;

Palette

=

RECORD

{entries

pmEntries:

Integer;

pmDataFields:

ARRAY[0..6]

OF

pminfo:

ARRAY[0..0]

OF

in

pminfo}

Integer;
{private

fields}

ColorInfo

{color

information}

END;

Colorinfo

=

RECORD

CiRGB:
ciUsage:

ciTolerance:
ciDataFields:

RGBColor;
Integer;
Integer;
ARRAY[0..2]

OF

{absolute
RGB values}
{color usage
information}
{tolerance value}
Integer

{private
END;

Summary of the Palette Manager

fields}

The Palette Manager

Routines

Initializing the

Palette

Manager

PROCEDURE InitPalettes;
FUNCTION

S

PMgrVersion

:

a)
=

Integer;

_

Initializing and
BS,

.

Allocating

.

s

oO

Palettes

FUNCTION

GetNewPalette

(paletteID:

FUNCTION

NewPalette

(entries:

e

2a

Integer)
Integer;

:

rs

PaletteHandle;

srcColors:

srcUsage,srcTolerance:

z

CTabHandle;

Integer)

PaletteHandle;
PROCEDURE

DisposePalette

Interacting
PROCEDURE
FUNCTION
PROCEDURE

(srcPalette:

With the Window

ActivatePalette
GetPalette
SetPalette

PaletteHandle);

Manager

(srcWindow:

WindowPtr);

(srcWindow:

WindowPtr)

:

(dstWindow:

WindowPtr;

srcPalette:

PaletteHandle;

PROCEDURE

NSetPalette

(dstWindow:

PROCEDURE
FUNCTION

SetPaletteUpdates
GetPaletteUpdates

Color

cUpdates:

WindowPtr;

PaletteHandle;

PaletteHandle;

srcPalette:

nCUpdates:

(po:

PaletteHandle;

updates:

(p:

PaletteHandle)

:

Drawing

With

PROCEDURE

PmForeColor

(dstEntry:

Integer) ;

PROCEDURE

PmBackColor

(dstEntry:

Integer) ;

PROCEDURE

SaveFore

(VAR

PROCEDURE

RestoreFore

(c:

PROCEDURE

SaveBack

(VAR

PROCEDURE

RestoreBack

(c:

Boolean);

Integer);
Integer) ;

Integer;

Palettes

c:

ColorSpec) ;

ColorSpec) ;
c:

ColorSpec) ;

ColorSpec) ;

Summary of the Palette Manager

20-27

Inside Macintosh, Volume VI

Animating
PROCEDURE

Color Tables

AnimateEntry

(dstWindow:
SrCcRGB:

PROCEDURE

AnimatePalette

WindowPtr;

dstEntry:

Integer;

srcCTab:

CTabHandle;

RGBColor) ;

(dstWindow:

WindowPtr;

srcindex,dstEntry,dstLength:

Manipulating
PROCEDURE

Palettes and

CopyPalette

Integer) ;

Color Tables
(srcPalette,dstPalette:

PaletteHandle;

srcEntry,dstEntry,dstLength:

PROCEDURE

ResizePalette

(srcPalette:

PROCEDURE

RestoreDeviceClut

(gdh:

PROCEDURE

CTab2Palette

(srcCTab:

PaletteHandle;

Integer) ;

size:

Integer);

GDHandle) ;
CTabHandle;

PaletteHandle;

dstPalette:

srcUsage,srcTolerance:

Integer) ;
PROCEDURE

Palette2CTab

(srcPalette:

PaletteHandle;

dstCTab:

(srcPalette:

PaletteHandle;

srcEntry:

VAR

RGBColor) ;

CTabHandle) ;

Manipulating
PROCEDURE

PROCEDURE

Palette

GetEntryColor

GetEntryUsage

Entries
dstRGB:

(srcPalette:
Integer;
VAR
Integer);

PROCEDURE

SetEntryColor

(dstPalette:
Integer;

PROCEDURE

SetEntryUsage

FUNCTION

20-28

Entry2Index

(entry:

Summary of the Palette Manager

srcEntry:

dstUsage,dstTolerance:

PaletteHandle;

srcRGB:

(dstPalette:
Integer;

PaletteHandle;

Integer;

dstEntry:

RGBColor) ;

PaletteHandle;

dstEntry:

srcUsage,srcTolerance:
Integer)

:

LongInt;

Integer) ;

NO
anh
W
BW
SAAN

THE

GRAPHICS

DEVICES

MANAGER

About This Chapter
About the Graphics Devices Manager
Offscreen Graphics
Using the Graphics Devices Manager
Offscreen Graphics World Flags
Example of Offscreen Graphics Code
Advanced Features of the Graphics Devices Manager
The Graphics Device Record
The 'scrn' Resource
Setting a Device’s Pixel Depth
Graphics Devices Manager Routines
High-Level Routines
Creating a Graphics World
Working With a Graphics World’s Pixel Map
Updating the Graphics World
Setting and Retrieving the Graphics World
Disposing of a Graphics World
Low-Level Routines
Supporting the Offscreen Graphics World
Managing the Graphics Device Record
Summary of the Graphics Devices Manager

‘)
—

?)~
£5

—

sd

=

e

+ 2)

~)
©
<
o
©
if 2)

21-1

Inside Macintosh,

21-2

Volume VI

The Graphics Devices Manager

ABOUT

THIS

CHAPTER

B+ )

The Graphics Devices Manager also contains routines and data structures used by QuickDraw™,
the Palette Manager, and the Color Manager to communicate with the graphics devices attached
to a particular system. Such devices may include printers as well as screens. Most of these
routines are used only by the Operating System; some may be used by graphics-intensive
applications.

I

This chapter describes how you can use the Graphics Devices Manager to manage offscreen
graphics. You can use offscreen graphics to prepare images offscreen and then move them
quickly into view with a single routine. This technique prevents the choppiness that can
occur when you build object-oriented graphics directly on the screen. By building a picture
in an environment you create and control, you can be sure that no other application or desk
accessory changes the characteristics of the picture’s environment.

—
ad
—_—
—_
—-

'¢)

Before reading this chapter, you should read the Graphics Overview and Color QuickDraw
chapters in this volume and the Color QuickDraw chapter in Volume V. If your application
uses color, you should also be familiar with the Palette Manager, as described in this volume.
This chapter replaces the Graphics Devices chapter in Volume V.

ABOUT

THE

GRAPHICS

DEVICES

MANAGER

The Graphics Devices Manager works with an application’s graphics environment. The
graphics environment is defined by grafPorts, which contain information about
windows, and graphics device records, which contain information about graphics devices
such as screens that are attached to the system. Since these records are created automatically
by the Operating System, many applications won’t have to work directly with the Graphics
Devices Manager.
If you are developing a graphics-intensive application, you may need to create additional
color grafPort and graphics device records, in which case the Graphics Devices Manager’s
high-level routines probably provide all the features you need. With these routines you can
create an offscreen graphics world: a graphics environment in which you control
specifications such as pixel depth and whether the pixel values are indexed or direct. Using
these routines minimizes the possibility of compatibility problems, because these routines
and data structures, collectively called the offscreen graphics world interface, will be main-

tained as Macintosh® graphics systems evolve. With system software version 7.0, the
offscreen graphics world routines are available on black-and-white machines (lacking Color
QuickDraw), but they create an extended grafPort record, not a true color grafPort record.
A few applications may need exacting control of the graphics environment. Routines that
work directly with the graphics device record are described in “Low-Level Routines” later
in this chapter.

About the Graphics Devices Manager

21-3

7)

@

<te
'<)
is")
~D

Inside Macintosh,

Volume

V1

The rest of this chapter
m describes offscreen graphics, which is the most common use of the Graphics
Devices Manager
= introduces the offscreen graphics world routines
w delineates the graphics world flags, by which you set and obtain offscreen
graphics attributes
m covers several advanced topics that most developers do not need to study: the graphics
device record, the 'scrn' resource, and the proper way to set the screen depth from
within an application

OFFSCREEN

GRAPHICS

The most common reasons for drawing offscreen are speed and visual smoothness. For
example, suppose your application draws individual graphics objects, and it needs to redraw
part of a window that has been covered by another window or a menu. Your application
may be able to put an offscreen bitmap onto the screen faster than it could re-create the
drawing steps, and at the same time avoid the choppy effect that can arise from drawing a
large number of separate objects.
In a multitasking situation you may want to create an image offscreen to avoid having some
other application or desk accessory change the graphics environment in the midst of your
processing. An offscreen graphics environment that you create cannot be modified by any
other application.
Most important, today’s Macintosh computer systems may have several screens, of different
sizes, pixel depths, and color capabilities, and the user may decide to put your application’s
window on (or even across) any of them. By preparing the image offscreen in a graphics
world that you create, you can control the image’s characteristics. When the image is ready
for display, you can check the graphics environment and react accordingly, such as by calling
CopyBits if everything is as you expect, or by adjusting the image to match the pixel depth of
the deepest screen your window touches. If the environment is not suitable—for example, if
the user has moved the window for your multicolor display of the Bayeux tapestry to a 9-inch
black-and-white monitor—you can display the best image possible and issue a gentle
remonstrance.
An offscreen graphics world is an extension of the color grafPort record described in the
Color QuickDraw chapter of Volume V. It contains a color grafPort describing the offscreen
port, a reference to the offscreen device associated with the offscreen graphics world, and
other state information. The actual data structure is kept private to allow for future extensions.
The pointer type of the offscreen graphics world is defined as follows:
TYPE

GWorldPtr

=

CGrafPtr;

On black-and-white machines lacking Color QuickDraw, the graphics world pointer points to
an extension of the original QuickDraw grafPort record.
21-4

Offscreen Graphics

The Graphics Devices Manager

USING

THE

GRAPHICS

DEVICES

MANAGER

Your use of the Graphics Devices Manager routines depends on the degree to which you need
to control the characteristics of your images. If your only concern is to avoid flicker by
presenting a completed image, you can choose to create an offscreen color grafPort record but
not a new graphics device record. Your offscreen grafPort is then linked to the current
graphics device, from which it takes characteristics such as pixel depth. If you need to control
the pixel depth or create a new color table, you must create a new graphics device record.
You create an offscreen graphics world with the NewGWorld function. You can specify that
a new graphics device record is to be created, or you can specify that an existing graphics
device record be used, such as the graphics device record of the main screen (the screen with
the menu bar) or of the deepest screen touched. In either case, the Graphics Devices Manager
uses that graphics device record’s characteristics to create the pixel map for your image. If
you use a screen’s graphics device record, then before doing any drawing you should check
to be sure that the device’s depth or color/black-and-white settings haven’t been changed by
the user. If they have, call the UpdateGWorld function.

nN
—

?)
~
as

=-_

—
~~

ao)

4)

o

.s°)
<

i

@

4)

To address the pixel map record created for an offscreen graphics world, use the
GetGWorldPixMap function. (Don’t dereference the graphics world pointer to get to
the pixel map.)
Before actually drawing to or from the offscreen graphics world, call LockPixels to lock the
offscreen buffer in memory. As soon as the drawing is completed, always call UnlockPixels.
When the user resizes or moves a window, changes the pixel depth of screens a window
intersects, or modifies a color table, you should call the UpdateGWorld function; your
application may be able to reflect those changes in the offscreen graphics world without
having to re-create it and redraw its content. Calling UpdateGWorld when the window
moves can ensure a maximum refresh speed when using CopyBits to move the offscreen
image on screen.
When you no longer need your offscreen graphics world, dispose of it by calling
DisposeGWorld.

Offscreen

Graphics

World

Flags

The GWorldFlags type is used by various routines to retrieve and set the characteristics of
offscreen graphics worlds.
TYPE

GWorldFlags
SET

OF

=

(

pixPurge,
noNewDevice,

{used by NewGWorld
{ purgeable}
{used by NewGWorld
{ device}

to

make

to

not

offscreen
create

an

buffer

}

offscreen

Using the Graphics Devices Manager

21-5

}

Inside Macintosh,

Volume VI

useTempMem,

{used by NewGWorld
{ temporary
memory}

to

structures

keepLocal,

{used

gWorldFlag4,

{reserved}

gworldFlag5,

{reserved}

pixelsPurgeable,

{used
{

to

keep

by

data

allocate

pixels

in

in

memory}

main

Get/SetPixelsState

for

purgeable

Get/SetPixelsState

for

locked

}

}

pixels}

pixelsLocked,

{used

gWworldFlag8,
gworldFlag9,

{reserved}
{reserved}

gWorldFlagl10,

{reserved}

gWorldFlagll,

{reserved}

gWorldFlagl12,

{reserved}

gWorldFlag13,
gworldFlag14,

{reserved}

gworldFlag1i5,

{reserved}

mapPix,

{set

by

UpdateGWorld

if

color

mapping

newDepth,

{set

by

UpdateGWorld

if

pixels

were

scaled

pixels}

to

}

if

pixels

were

realigned

}

if

pixel

map

{reserved}

{
alignPix,

by

a

different

{set

by

{

screen

to

depth}

UpdateGWorld
alignment}

newRowBytes,

{set

reallocPix,

{ reconfigured
in a new
{set by UpdateGworld
if
{

to

by

UpdateGWorld

be

occurred}

was

}

rowBytes}
offscreen

buffer

had

gworldFlag21,

{reserved}

gworldFlag22,
gworldFlag23,

{reserved}
{reserved}

gworldFlag24,

{reserved}

gWorldFlag25,
gWorldFlag26,
gworldFlag27,

{reserved}
{reserved}

clipPix,

{used

by

UpdateGWorld

to

clip

stretchPix,

{used

by

UpdateGWorld

to

stretch

{reserved}

{

pixels}
or

shrink

pixels}

ditherPix,

{used

gwFlagErr,

{set

by
by

UpdateGWorld
UpdateGWorld

to
if

dither
it

pixels}

failed}

i

Example

of Offscreen

Graphics

Code

The code sample in Listing 21-1 creates an offscreen graphics world. The GetGWorld
procedure saves the settings of the graphics port and device so that the current environment
can be restored. The NewGWorld function returns a pointer (in the variable parameter
fDrawingPort) to the newly created offscreen graphics world, which is initialized to a pixel
depth of 8, a boundary rectangle specified by sizeOfDoc, and a color table specified by
gOurColors. The SetGWorld procedure sets the offscreen world to be the current graphics
environment. The LockPixels function locks the image memory before any drawing
operations, in this case an EraseRect procedure, after which memory is unlocked and the
original environment restored.

21-6

}

reallocated}

Using the Graphics Devices Manager

}

The Graphics Devices Manager

Listing 21-1.

Sample offscreen graphics world

PROCEDURE
BuildOffWorld
(sizeOfDoc:
VAR
oldPerm:
Boolean;

fi:

FailliInfo;

currDevice:

GDHandle;

currPort:

GrafPtr;

erry:

OSErr;

PROCEDURE

BadBuildOff

(error:

Rect);

OSErr;

message:

LongInt);

BEGIN
oldPerm

:=

PermAllocation

SetGDevice

(currDevice) ;

(oldPerm) ;

{Set

memory

back

to

previous. }

{Set

device

back

to

main,

{
SetPort

just

in

}

case.}

=y

eS)

oe

END;

ad

—

=

—e

GetGWorld

i)
~n
—

(currPort,currDev) ;

CatchFailures
(fi,BadBuildOff);
erry
:= NewGWorld
(fDrawingPort,8,sizeOfDoc,
FailOSErr
SetGWorld
(NOT

ww

oO

gOurColors,NIL,GWorldFlags

(0) );

(fDrawingPort,NIL) ;
LockPixels

SetGWorld

(fDrawingPort®.portPixMap))

THEN

FailOSErr

(QDError) ;

(currPort,currDev)

{BuildoOffWorld}

ADVANCED FEATURES
DEVICES MANAGER

OF

THE

GRAPHICS

The offscreen graphics world routines provide facilities for the needs of most graphics
applications. Some graphics-intensive applications may need to work more directly with
the graphics device record, which is described next. The 'scrn' resource, used at startup
to determine initial screen settings, is likely to concern only applications involved in device
management, such as drivers.

The

Graphics

<

me
@

7

(erry);

EraseRect
(fDrawingPort’.portRect) ;
UnlockPixels
(fDrawingPort”.portPixMap) ;
END;

—_

7

(currPort)

BEGIN

IF

nN

Device

Record

All information that is needed to communicate with a graphics device is stored in a graphics
device record. This information may describe many types of devices, including screens,
printers, and offscreen drawing environments. Most applications will not need to work
directly with a graphics device record.

Advanced Features of the Graphics Devices Manager

21-7

Inside Macintosh,

Volume VI

When the system starts up, one handle to a graphics device record is allocated and initialized
for each video card the system finds. These graphics device records are linked together in a
list, called the device list. (A handle to the first element in the device list is kept in the global
variable DeviceList.) By default, the graphics device record corresponding to the first video
card found is marked as an active device (a device your program can use for drawing); all
other devices in the list are initially marked as inactive.
When your application draws on a device, that device becomes the active device, which the
Graphics Devices Manager stores in the global variable TheGDevice.
Graphics device records that correspond to screens have drivers associated with them. These
drivers can be used to change the mode of the device from black and white to color, or to
change the pixel depth. The set of routines supported by a video driver is defined and described
in Designing Cards and Drivers for the Macintosh Family, second edition. Graphics device
records that your application creates usually won’t require drivers.
TYPE

GDHandle

=

“GDPtr;

GDPtr

=

“GDevice;

GDevice

=

RECORD

gdadRefNum:
gdID:

Integer;

{reference

Integer;

gdType:

Integer;

gdIiTable:

TTabHandle;

{client
ID for search procedure}
{type of device
(indexed,
direct) }
{inverse
table
for Color Manager}

number

gdResPref:

Integer;
SProcHndl;

{preferred

gdSearchProc:

{list

of

search

gdCompProc:

CProcHndl;

{list

of

complement

gdFlags:

Integer;

{graphics

gdPMap:

PixMapHandle;

{pixel

gdRefCon:

Longint;

{reference

gdNextGD:
gdRect:

GDHandle;

{handle

next

graphics

Rect;

{device's

global

bounds}

gdMode:

Longint;
Integer;
Integer;

{device's

current

mode}

gdCCBytes:
gdaCCDepth:

{width

of

expanded

cursor

data}

{depth

of

expanded

cursor

data}

gdacCxXData:

Handle;

{handle

to

cursor's

expanded

data}

gaCCXMask:

Handle;

{handle

to

cursor's

expanded

mask}

gdReserved:

Longint

functions}

device

map
to

for

functions}

flags}

displayed

image}

value}

{reserved

for
0}

be

driver}

resolution}

{

must

of

future

use;

device}

}

END;

Field descriptions

gdRefNum

The gdRefNum field contains the reference number of the driver for the
screen associated with the card. For most screen devices, this information
is set at system startup time.

gdID

The gdID field contains an ID number your application can set to identify
the current client of the port. It is also used for search and complement
procedures.

21-8

Advanced Features of the Graphics Devices Manager

The Graphics Devices Manager

gdType

The gdType field specifies the general type of device. Values include
0 = CLUT device (mapped colors with look-up table)
| = fixed colors (no color look-up table)

2 = direct RGB

These device types are described in the Color Manager chapter
of Volume V.
gdITable

The gdITable field contains a handle to the inverse table for
color mapping.

gdResPref

The gdResPref field contains the preferred resolution for inverse tables.

gdSearchProc

The gdSearchProc field is a pointer to the list of search functions; its value
is NIL for a default procedure.

gdCompProc

The gdCompProc field is a pointer to a list of complement functions; its
value is NIL for a default procedure.

gdFlags

The gdFlags field contains the graphics device record’s attributes. Do
not set these flags directly; always use the procedures described in
this chapter.

gdPMap

a

m4
“i
as
~
~
~
—
oO
7)
—
—_
is”
<
wee
©

—

—

(¢")
~

The gdPMap field is a handle to a pixel map giving the dimension of the
image buffer, along with the characteristics of the device (resolution, storage
format, color depth, color table). For graphics device records, the high bit
of the global variable TheGDevice™.gdPMap™.pmTable™.ctFlags is
always set.

gdRefCon

The gdRefCon field is used to pass device-related parameters. Since a
device is shared, you shouldn’t store data here.

gdNextGD

The gdNextGD field contains a handle to the next device in the device list.
If this is the last device in the device list, this is set to 0.

gdRect

The gdRect field contains the boundary rectangle of the graphics device
record. The main screen has the top-left corner of the rectangle set to
(0,0). All other devices are relative to it.

gdMode

The gdMode field specifies the current setting for the device mode. This is
the value passed to the driver to set its pixel depth and to specify color or
black and white.

gdCCBytes

The gdCCBytes field contains the rowBytes value of the expanded cursor.
Applications should not change this field.

gdCCDepth

The gdCCDepth field contains the depth of the expanded cursor.
Applications should not change this field.

gdCCxXData

The gdCCXData field contains a handle to the cursor’s expanded data.
Applications should not change this field.

gdCCX Mask

The gdCCXMask field contains a handle to the cursor’s expanded mask.
Applications should not change this field.

gdReserved

The gdReserved field is reserved for future expansion; it must be set to 0
for future compatibility.
Advanced Features of the Graphics Devices Manager

nN

—

21-9

Inside Macintosh,

Volume V1

To set the attribute bits in the gdFlags field, use the SetDeviceAttribute procedure. You can
set the following attributes:
CONST

{bit
assignments
for
gdDevType
=. Os

gdFlags}
{set
if

device

supports

color}

burstDevice

=

7;

{set

if

device

supports

block

ext32Device

=

8;

{set

if

device

must

accessed

{

transfer}
in

32-bit

}

initialized

from

RAM}

mode}

ramiInit

=:

LO

{set

if

device

has

mainScreen

=

1413

{set

if

device

is

alliInit

=

I25

{set

if

devices

were

{

The

be

'sern'

been
main

screen}

initialized

screenDevice
noDriver

=
=

13;
14;

{set
{set

if
if

device
device

is a screen device}
has no driver}

screenActive

=

15;

{set

if

device

is

‘scrn'

from

}

resource}

active}

Resource

The user can use the Monitors control panel to set the desired depth of each screen, whether
it displays color or black and white, and its position relative to the main screen. All of this
information is stored in a resource of type 'scrn’ in the System file.

The 'scrn’ resource contains all the screen configuration information for a multiscreen system.
Only the 'scrn' resource whose ID is 0 is used by the system. Normally your application
won’t have to alter or examine this resource. It’s created by the Monitors control panel and
used by InitGraf. When InitGraf initializes QuickDraw, it checks the System file for the 'scrn'
resource. If the 'scrn' resource is found and it matches the hardware, InitGraf organizes the
screens according to the contents of this resource; if not, then only the startup screen is used.
The 'scrn' resource consists of a sequence of records, each describing one screen device. The
first word in an 'sern' resource is the number of devices in the resource. Following that is
information about each screen device. For each screen device, the resource contains the

following fields:
Name

Size

Description

spDrvrHw
slot

word
word

Slot Manager hardware ID
Slot number

mode

word

dCtIDevBase

flagMask
flags

21-10

long

dCtlDevBase from Device Control Entry (DCE)

word

Has the value $77FE

word

Slot Manager ID for screen’s mode
Indicates device state

bit0 =O if black and white; | if color
bit 11 = 1 if device is main screen
bit 15 = 1 if device is active

Advanced Features of the Graphics Devices Manager

The Graphics Devices Manager

Name

Size

Description

colorTable
gammaTable
globalRect
ctlCount

word
word
rect
word

Resource ID of desired ‘clut'
Resource ID of desired 'gama'
Device’s global rectangle
Number of control calls

For each control call of the screen device, the resource contains the following fields:
Name

Size

Description

csCode
length
param blk

word
word
[variable]

Control code for this call
Number of bytes in parameter block
Data to be passed in control call

WN
as

~~
ei 4
eg
as |
—
—

)
~
Pr)
oO
—

The records in the 'scrn' resource must be in the same order as the video cards in the
slots (starting with the lowest slot). InitGraf scans through the video cards in the slots and
compares them with the descriptors in the 'scrn' resource. If the spDrvrHw, slot, and
dCtlDevBase fields all match for every screen device in the system, InitGraf uses the 'scrn'
resource to initialize the screens. Otherwise it ignores the 'scrn' resource. Thus if you move,
add, or remove a video card, the 'scrn' resource becomes invalid until the next time the
system starts up.
The spDrvrHw field is a Slot Manager field that identifies the type of hardware on the card.
(The spDrvrSw field on the card must identify it as an Apple®-compatible video driver.) The
slot field is the number of the slot containing the card. The dCtlDevBase field is the beginning
of the device’s address space, taken from the device’s DCE structure.
If all screen devices match, the rest of the information in the 'scrn' resource is used to con-

figure the screens. The mode field is actually the Slot Manager ID designating the descriptor
for that mode. This same mode number is passed to the video driver to tell it which mode
to use.

The flags bits in the 'scrn' resource determine whether the device is active (that-is, whether it
will be used), whether it’s color or black and white, and whether it’s the main screen. The

flagMask field tells which bits in the flags word are used.

To use the default color table for a device, set the colorTable field to —1. To use the default
gamma table for a device, set the gammaTable field to —1. (Gamma correction is a technique
used to select the appropriate intensities of the colors sent to a screen device.)
The globalRect field specifies the coordinates of the device relative to other devices. The main
device must have the top-left corner of the rectangle set to (0,0). The coordinates of all other
devices are specified relative to this device. Devices may not overlap, and must share at least
part of an edge with another device.
The union of all active screens (minus the menu bar and the rounded corners of the outermost

screens) is a region that is stored in the global variable GrayRgn. It defines the area on which
windows can be dragged.

Advanced Features of the Graphics Devices Manager

— 21-11

if 2)

om
<

vee

i)
is?)

i 2)

Inside Macintosh,

Volume

VI

Setting a Device’s

Pixel Depth

The Monitors control panel is the user interface for changing the depth, color capabilities, and
positions of graphic devices. Since the user can control the device’s capabilities, applications
are always encouraged to be flexible: although your application may have a preferred screen
depth, it should do its best to accommodate less-than-ideal conditions.
Use the new Graphics Devices Manager function SetDepth, with which your application can
change the pixel depth of a graphics device, only in consultation with the user. With it you
can offer a convenience: if your application must have a specific pixel depth, display a dialog
box that offers the user a choice between going to that depth or quitting your application. This
saves the user from having to go to the Monitors control panel and return to your application.
(You can use a companion function, HasDepth, before offering the dialog box, to be sure that
the available hardware can support the depth you require.)

GRAPHICS

DEVICES

MANAGER

ROUTINES

Graphics Devices Manager routines fall into two classes: high-level routines, which are
used for creating and maintaining offscreen graphics worlds, and low-level routines, which
are used by the Operating System and specialized applications to directly manage graphics
device records.

High-Level

Routines

The Graphics Devices Manager’s high-level routines allow you to create an offscreen
graphics world, establish it as the current port and device, manage its pixel map, update
it when necessary, and dispose of it all when done.

Creating

a Graphics

World

The NewGWorld function creates a graphics world: it allocates an offscreen port and pixel
map and its associated offscreen memory. It also allocates a new offscreen graphics device
record unless you specify that an existing graphics device record be used—either one you
supply or the one having the deepest pixel depth in the rectangle defined by the boundsRect
parameter.
FUNCTION

NewGWorld

(VAR

offscreenGWorld:

Integer;
boundsRect:
aGDevice:
GDHandle;

GWorldPtr;
Rect;
flags:

pixelDepth:

cTable:
CTabHandle;
GWorldFlags)
: QDErr;

NewGWorld sets the pixel depth, boundary rectangle, color table, and graphics world flags.
It returns a pointer to the offscreen graphics world in the offscreenGWorld parameter.
Applications typically use the NewGWorld function to create an offscreen world optimized
for an image’s characteristics—for example, its best pixel depth.

21-12.

Graphics Devices Manager Routines

The Graphics Devices Manager

However, NewGWorld has an alternate use: it can create an offscreen graphics world
optimized for speed in copying onto the attached graphics devices. To use NewGWorld in
this way, set the pixelDepth parameter to 0. This setting requests that the deepest device
intersecting your boundsRect value in screen space be used for the offscreen graphics device
record. Set the port’s portRect field to the same size as boundsRect with the top-left coordinates set to (0,0). The pixel map’s bounds and the device’s gdRect value are computed so
that CopyBits operations between the offscreen pixel map and the screen are optimized.
(Typically, the pixel map’s bounds are a few pixels wider than those indicated by portRect.)
Parameter implications of this alternate use of the NewGWorld function are noted in
each parameter description.
N

Parameter descriptions

—

~

wt 4
~

pixelDepth

The pixelDepth parameter determines the pixel resolution of the offscreen
world. Possible depths are 0, 1, 2, 4, 8, 16, and 32 bits per pixel.
If you set pixelDepth to 0, the NewGWorld function uses the deepest
device intersecting the rectangle specified by your boundsRect parameter
to create the offscreen graphics device record.

boundsRect

The boundsRect parameter determines the offscreen pixel map’s size and
coordinate system, and it becomes the offscreen port’s portRect value, the
offscreen pixel map’s bounds, and the offscreen device’s gdRect value. It
is used to determine the pixel map’s rowBytes value and the size
necessary for allocating the offscreen buffer.
If you set pixelDepth to 0, NewGWorld takes the boundsRect parameter
in global coordinates to find the deepest device that intersects the
boundsRect rectangle.

cTable

The cTable parameter is a handle to the color table to be used. NewGWorld
makes a copy of that color table and puts its reference in the offscreen pixel
map. It is your application’s responsibility to make sure that cTable specifies
a valid color table for the pixel depth. If cTable is NIL, the default color
table for the pixel depth is used.
If you set pixelDepth to 0, the color table of the deepest device intersecting
the boundsRect rectangle is used, and the cTable parameter is ignored.

aGDevice

NewGWorld uses the graphics device record specified in the aGDevice
parameter to create the offscreen graphics world when the noNewDevice
flag is set.
If you set pixelDepth to 0 (or if you do not set noNewDevice), the
aGDevice parameter is ignored, so you should set it to NIL.

flags

The flags parameter provides some options to the application. It can be
a combination of the flags pixPurge, noNewDevice, keepLocal, and
useTempMem, all members of the GWorldFlags set.
If you set the pixPurge flag, NewGWorld makes the offscreen buffer a
purgeable block. Before drawing to or from the offscreen graphics world,
your application should call the LockPixels function and ensure that it
returns TRUE. If LockPixels returns FALSE, the offscreen buffer has
Graphics Devices Manager Routines

— 21-13

=

a)—
dl

¢)
/

—

dl

is°)
<

a

ig")
~

Inside Macintosh,

Volume VI

been purged, and your application should either call UpdateGWorld to
reallocate it or draw directly in the window it represents. Never draw to a
purged offscreen buffer.
If you set noNewDevice, NewGWorld does not create a new offscreen
device, and the depth and color table of the aGDevice parameter are used
to create the offscreen graphics world. (If you set pixelDepth to 0, the
deepest device intersecting the boundsRect rectangle is used.)
NewGWorld keeps a reference to whichever device it uses in the offscreen
graphics world data structure, and the SetGWorld procedure uses that
device to set the current device.
Note that, to use a custom color table in an offscreen graphics world, you
need to create the associated offscreen device, because Color QuickDraw
needs the device’s inverse table to draw.
If you set the keepLocal flag, your offscreen graphics environment is kept
in Macintosh main memory and is not cached to a graphics accelerator
card. Use this flag carefully, as it gives up the advantages of a graphics
acceleration card, if present.
If you set the useTempMem flag, NewGWorld allocates pixels in temporary memory. You should use temporary memory only for fleeting
purposes, and only in conjunction with the AllowPurgePixels procedure
so that other applications can launch.
NewGWorld initializes the offscreen port by calling OpenCPort (described in the QuickDraw
chapter of Volume V). It sets the port’s visRgn field to a rectangular region coincident with
its port rectangle. NewGWorld initializes the offscreen device according to pixelDepth,
boundsRect, cTable, and default values. NewGWorld generates an inverse table with the
Color Manager procedure MakelTable, unless one of the screen devices has the same color
table as the offscreen device, in which case it copies the inverse table from that device.
You can compute the size of the offscreen memory buffer using this formula:
rowBytes * (boundsRect.bottom — boundsRect.top)
The actual address of the offscreen buffer is not directly accessible from the pixel map. If you
need access to the pixels without going through QuickDraw, call GetPixBaseAddr to get a
pointer to the pixels.
Result codes

noErr
paramErr
cDepthErr

Working

0
—50
-157

No error
Illegal parameter
Invalid pixel resolution

With a Graphics World’s

Pixel Map

The Graphics Devices Manager routines that work with pixel maps use handles of type
PixMapHandle, which you can obtain with the GetGWorldPixMap function. The routines
assume that the pixel maps were created by offscreen graphics world routines. You can use
21-14

— Graphics Devices Manager Routines

The Graphics Devices Manager

the GetPixBaseAddr and PixMap32Bit functions on pixel map records that are not part of
your offscreen graphics world; the other routines won’t fail, but they don’t return useful
information.
FUNCTION

LockPixels

(pm:

PixMapHandle)

:

Boolean;

or

x
x

If the offscreen buffer is purgeable and has indeed been purged, LockPixels returns FALSE
to signal that no drawing can be made to the buffer memory. At that point, the application
should either call UpdateGWorld to reallocate the buffer or draw directly in the window
it represents.

II (4

You must call LockPixels before drawing to or from an offscreen graphics world. In the pm
parameter pass the pixel map handle returned from a GetGWorldPixMap function. LockPixels
locks the offscreen buffer in memory for the duration of the drawing.

ey)

=

If the offscreen buffer hasn’t been purged or is not purgeable, LockPixels returns TRUE.
As soon as the drawing is completed, you should call UnlockPixels.
PROCEDURE

UnlockPixels

(pm:

AllowPurgePixels

PixMapHand1le) ;

AllowPurgePixels marks the pixel map’s offscreen buffer as purgeable.
PROCEDURE

NoPurgePixels

(pm:

PixMapHand1le) ;

NoPurgePixels marks the pixel map’s offscreen buffer as unpurgeable.
FUNCTION

GetPixelsState

(pm:

PixMapHandlie)

:

GWorldFlags;

GetPixelsState returns the state of the pixel map’s offscreen buffer. The state can be a combination of the flags pixelsPurgeable, pixelsLocked, and keepLocal, which are members of the
GWorldFlags set. Use GetPixelsState in conjunction with SetPixelsState to save and restore
the state of these flags. You can save the flags, change any of them using one of the preceding routines, and then restore their original state by passing the result of GetPixelsState back
to the SetPixelsState procedure.
PROCEDURE

SetPixelsState

(pm:

PixMapHandle;

—

~~

PixMapHandle) ;

(pm:

—

ry
©
i? 2)
om
<
hee
©
@

UnlockPixels unlocks the offscreen buffer. Call UnlockPixels as soon as the application
finishes drawing to or from the offscreen pixel map. You don’t need to call UnlockPixels
if LockPixels returned FALSE, because LockPixels doesn’t lock purged pixels. (However,
calling UnlockPixels on purged pixels does no harm.)
PROCEDURE

_

state:

GWorldFlags) ;

The SetPixelsState procedure sets the lock and purge states of the pixel map’s offscreen
buffer to the given flags by calling LockPixels or UnlockPixels and AllowPurgePixels or
NoPurgePixels. Pass the pixel map handle returned from a GetGWorldPixMap function, and
a setting of 0 or | for the GWorldFlags pixelsPurgeable and pixelsLocked.
Graphics Devices Manager Routines

— 21-15

Inside Macintosh,

Volume VI

You can also use SetPixelsState to set the keepLocal flag: pass keepLocal as a state parameter
to specify that the offscreen graphics world stays in main memory rather than being cached
on an accelerator card. A graphics world that has already been cached will be brought back to
main memory. Clearing the flag will again allow caching. Use this setting carefully, as
keeping a graphics world local surrenders the benefits of graphics accelerators.
FUNCTION

GetPixBaseAddr

(pm:

PixMapHandle)

:

Ptr;

GetPixBaseAddr returns a 32-bit pointer to the beginning of the pixel map’s pixels. Your
application should always call GetPixBaseAddr before accessing the pixels of an offscreen
pixel map directly. Then your application should switch to 32-bit mode, access the pixels,
and switch back to 24-bit mode (if that’s the mode you want to use). Your application should
never access the baseAddr field of the pixel map directly.
If the offscreen buffer has been purged, GetPixBaseAddr returns NIL.
If QuickDraw is called after GetPixBaseAddr, the contents of the offscreen buffer are not
guaranteed to be accurate.
FUNCTION

PixMap32Bit

(pmHandle:

PixMapHandle)

:

Boolean;

PixMap32Bit returns TRUE if the specified pixel map requires 32-bit addressing mode for
access to its pixels.

Updating

the Graphics

World

The UpdateGWorld function is similar in form to the NewGWorld function; your application
can use it to change one or more of the offscreen world’s attributes.
FUNCTION

UpdateGWorld

(VAR

offscreenGWorld:

Integer;
boundsRect:
aGDevice:
GDHandle;
GWorldFlags;

GWorldPtr;
Rect;
flags:

pixelDepth:

cTable:
CTabHandle;
GWorldFlags)

UpdateGW orld updates the offscreen graphics world described by offscreenGWorld to the
new pixelDepth, boundsRect, and cTable values. The pixelDepth, boundsRect, and cTable
parameters have the same meaning and work generally in the same way as in NewGWorld.
If pixelDepth is set to 0, the device list is rescanned to find the new deepest device intersecting with the new boundary rectangle in global screen space.
If the offscreen buffer has been purged, UpdateGWorld reallocates it.

If aGDevice is not NIL, the depth and color table of the graphics device record specified by
aGDevice are used instead of those specified by pixelDepth and cTable.

21-16

~~ Graphics Devices Manager Routines

The Graphics Devices Manager

With the flags parameter you can set the keepLocal flag, which keeps the graphics world data
structures in Macintosh main memory (or returns them if they were previously cached), or
you can clear it if it was previously set, allowing the graphics world to be cached on a
graphics accelerator card, if present. The flags can also include a combination of the flags
clipPix, ditherPix, and stretchPix. Some combinations are illegal; the legal uses of these flags
are as follows:
[ |

clipPix

(no flags)

stretchPix

clipPix, ditherPix

stretchPix, ditherPix
i)
—

If none of the flags is set, the pixels are not updated.

?)
zs

If clipPix is set, the pixels are updated, and they are clipped if the boundsRect value
has changed.

——
—

~

—
C
7)

If stretchPix is set, the pixels are updated, with stretching or shrinking if the boundsRect
value has changed. If boundsRect hasn’t changed, stretchPix is equivalent to clipPix.
If ditherPix is set, the pixels are first updated according to the state of clipPix or stretchPix.
Then they are dithered if necessary.
UpdateGWorld returns a pointer to the new offscreen graphics world in the offscreenGWorld
parameter. If offscreenGWorld was the current graphics world and UpdateGWorld changed
it, the current graphics world is set to the updated offscreen graphics world.
The result of UpdateGWorld is a combination of the flags mapPix, newDepth, alignPix,
newRowByftes, reallocPix, clipPix, stretchPix, ditherPix, and gwFlagErr, which are
members of the GWorldFlags set. If gwFlagErr is set, UpdateGWorld was unsuccessful and
offscreenGWorld is left unchanged. The result of UpdateGWorld must be coerced to a long
integer and contain one of the following result codes:
Result codes
paramErr
cDepthErr

—50
—-157

Illegal parameter
Invalid pixel resolution

If UpdateGWorld is successful, the other flags must be interpreted as follows:
Flag

Meaning

mapPix
newDepth
alignPix
newRowBytes
reallocPix
clipPix
stretchPix
ditherPix

Color table mapping eccurred.
Pixels were scaled to a different depth.
Pixels were realigned to the screen alignment.
The pixel map was reconfigured with a new rowBytes value.
The offscreen buffer had to be reallocated; your image was discarded.
Pixels were clipped.
Pixels were stretched or shrunk.
Pixels were dithered.

Graphics Devices Manager Routines

— 21-17

—
=

oC
OQ
@
~~

Inside Macintosh,

Volume VI

UpdateGWorld uses the following algorithm for pixel preservation.
1. If cTable is new, the pixels are mapped to the new color table.
2. If pixelDepth is new, the pixels are scaled to the new pixel depth.
3. If boundsRect is new but has the same size, the pixel map is just realigned for optimum
CopyBits performance.

DW

If boundsRect is smaller and stretchPix is set, the pixel map is reduced to the new size.

Nn

. If boundsRect is bigger and clipPix is set, the bottom and right edges are undefined.

. If boundsRect is bigger and stretchPix is set, the pixel map is stretched to the new size.

on

NN

4. If boundsRect is smaller and clipPix is set, the pixels in the bottom and right edges
are clipped.

. If the offscreen buffer was purged, it is reallocated, but the pixels are lost.

Setting and

Retrieving the Graphics

World

With these routines you can set and retrieve the current port and graphics device records,
which can be useful for saving and restoring an environment. You can also retrieve the
graphics device and pixel map of a graphics world.
PROCEDURE

SetGWorld

(port:

CGrafPtr;

gdh:

GDHandle) ;

SetGWorld sets the current graphics world. SetGWorld can be used with a port parameter of
type GrafPtr, CGrafPtr, or GWorldPtr (with proper type coercion).
If the port parameter is of type GrafPtr or CGrafPtr, the current port is set to the port specified by the port parameter, and the current device is set to the device specified by the
gdh parameter.
If the port parameter is of type GWorldPtr, the current port is set to the port specified by the
port parameter, and the current device is set to the device attached to the given graphics
world. The gdh parameter is ignored.
PROCEDURE

GetGWorld

(VAR

port:

CGrafPtr;

VAR

gdh:

GDHandle);

GetGWorld returns the current graphics world in the port and gdh parameters. The port
parameter is set to the current port, which can be of type GrafPtr, CGrafPtr, or GWorldPtr.
The gdh parameter is set to the current device.
FUNCTION

GetGWorldDevice

(offscreenGWorld:

GWorldPtr)

:

GDHandle;

GetGWorldDevice returns a handle to the device attached to the offscreen world specified by
the offscreenGWorld parameter. This device is generally the offscreen device created by

21-18

— Graphics Devices Manager Routines

The Graphics Devices Manager

NewGWorld.

If offscreenGWorld was created with the noNewDevice flag set, the attached

device is one of the screen devices or the device passed to NewGWorld or UpdateGWorld.

If offscreenGWorld points to a regular grafPort or color GrafPort, GetGWorldDevice returns
the current device.
FUNCTION

GetGWorldPixMap

(offscreenGWorld:

GWorldPtr)

:

PixMapHandle;

GetGWorldPixMap returns a handle to the pixel map record created for an offscreen graphics
world. Use GetGWorldPixMap whenever you need to address the pixel map record created
for an offscreen graphics world, rather than dereferencing the GWorld pointer, to ensure
compatibility on systems that have the offscreen graphics world routines but are running the
original QuickDraw (not Color QuickDraw).
For example, you should use this function before calling CopyBits when copying from the
pixel map of an offscreen graphics world:

nN
me

=
$9

a=)

—

ONM

o
o
=}
re
©if)
—

pixBase
CopyBits

:=

GetGWorldPixMap
(myWorld);
(pixBase*,myWindow’.portBits,aRect,otherR,srcCopy,NIL) ;

Use the GetGWorldPixMap function with offscreen graphics world routines, such as
LockPixels, AllowPurgePixels, and GetPixelsState, that use a handle to a pixel map.
UnlockPixels

(GetGWorldPixMap

(myGWorld)
) ;

GetGWorldPixMap is not available prior to system software version 7.0.

Disposing of a Graphics World
DisposeGWorld disposes of all the memory allocated for the offscreen port data structure and
substructures, offscreen pixel map and color table, and offscreen buffer.
PROCEDURE

DisposeGWorld

(offscreenGWorld:

GWorldPtr);

If an offscreen graphics device was created, DisposeGWorld disposes of its GDevice
structure and substructures.
Call DisposeGWorld only when the application no longer needs the offscreen buffer. If the
current device was the offscreen device attached to offscreenGWor ld, the current device is

reset to the device stored in the global variable MainDevice.

Low-Level

Routines

A few low-level routines are called by the higher-level offscreen graphics world routines; the
majority are called by the graphics system to manage the graphics device record and the
device list. Normally you won’t need to call any of them yourself.

Graphics Devices Manager Routines

— 21-19

Inside Macintosh,

Volume

VI

Supporting

the Offscreen

World

Graphics

The Graphics Devices Manager calls these routines as it manages the offscreen graphics worlds.
FUNCTION

NewScreenBuffer

(globalRect:

GDHandle;

Boolean;

purgeable:

Rect;

VAR

offscreenPixMap:

VAR

gdh:

PixMapHandle)

QODErr;

NewScreenBuffer allocates an offscreen pixel map and an offscreen buffer, using the depth
and color table of the deepest device intersecting with the global rectangle in screen space. A
handle to that device is returned in gdh, and a handle to the offscreen pixel map is returned
in offscreenPixMap. If purgeable is TRUE, the offscreen buffer is made purgeable.
Result codes

noErr
paramErr
cNoMemErr

0
—50
-152

No error
Illegal parameter
Failed to allocate memory for structures

The routines LockPixels, UnlockPixels, AllowPurgePixels, NoPurgePixels, GetPixelsState,
SetPixelsState, and GetPixBaseAddr can all be called with offscreenPixMap as a parameter.
FUNCTION

NewTempScreenBuffer

(globalRect:
gdh:

Rect;

GDHandle;

PixMapHandle)

purgeable:

VAR
:

Boolean;

VAR

offscreenPixMap:

QDErr;

NewTempScreenBuffer performs the same functions as NewScreenBuffer except that it
allocates pixels in temporary memory.
PROCEDURE

DisposeScreenBuffer

(offscreenPixMap:

PixMapHandle) ;

DisposeScreenBuffer is called by DisposeGWorld. It disposes of the memory allocated for
the offscreen buffer, the offscreen pixel map, and the color table.

Managing

the Graphics

Device

Record

These routines enable your application to create, initialize, and dispose of graphics device
records, and to obtain handles to particular graphics device records, such as those for the
main and deepest devices. A new procedure, DeviceLoop, simplifies the steps your application must take in order to check screen characteristics before drawing.
FUNCTION

NewGDevice

(refNum:

Integer;

mode:

LongInt)

:

GDHandle;

The NewGDevice function allocates a new graphics device data structure and all of its
handles, then calls InitGDevice to initialize it for the device specified by the refNum
parameter in the specified mode. If the request is unsuccessful, NewGDevice returns a NIL
handle. The new graphics device record and all of its handles are allocated in the system
heap. All attributes in the gdFlags field are set to FALSE.
21-20

Graphics Devices Manager Routines

The Graphics Devices Manager

If your application creates a graphics device record without a driver, it should set the mode
parameterto —1. In this case, InitGDevice is not called to initialize the graphics device record.
Your application must perform all initialization.
A graphics device’s default mode is defined as 128, as described in Designing Cards and
Drivers for the Macintosh Family, second edition; this is assumed to be a black-and-white
mode. If the mode parameter is not the default mode, the device’s gdDevType attribute bit is
set to TRUE, to indicate that the device is capable of displaying color (see the description of
the SetDeviceAttribute procedure later in this chapter).
NewGDevice doesn’t automatically insert the graphics device record into the device list. In
general, your application shouldn’t add devices that it creates to the device list.

nN

pee

PROCEDURE

InitGDevice

(gdRefNum:

Integer;

mode:

LongInt;

gdh:

GDHandle);

‘am
4
_

i)

_—
a

The InitGDevice procedure sets the screen device whose driver has the reference number
specified in gdRefNum to the specified mode. It then fills out the graphics device record
structure specified by the gdh parameter to contain all information describing that mode.
The graphics device handle should have been allocated by a call to NewGDevice.
The mode parameter determines the configuration of the device; possible modes for a device
can be determined by interrogating the video card’s ROM via calls to the Slot Manager
(refer to the Slot Manager chapter in this volume and Designing Cards and Drivers for the
Macintosh Family, second edition). See the Device Manager chapter in Volume V for more

details about the interaction of devices and their drivers.

The information describing the new mode is primarily contained in the video card’s ROM. If
the device has a fixed color table, then that table is read directly from the ROM. If the device
has a variable color table, then the default color table for that depth is used (the 'clut' resource
with ID equal to the depth).
In general, your application should never need to call InitGDevice. All screens are initialized
at start time and users change their modes through the Monitors control panel. If your program initializes a device without a driver, this procedure will do nothing; your application
must initialize all fields of the graphics device record. After your program initializes the color
table for the device, it needs to call MakeITable to build the inverse table for the device.
FUNCTION

GetGDevice

:

GDHandle;

The GetGDevice function returns a handle to the current graphics device record. This is
useful for determining the characteristics of the current output device (for instance, its pixel
size or color table). Note that since a window can span screen boundaries, this function does
not return the device that describes a port.
A handle to the currently active device is kept in the global variable TheGDevice.
FUNCTION

GetDeviceList

:

GDHandle;

The GetDeviceList function returns a handle to the first device in the global variable DeviceList.

Graphics Devices Manager Routines

— 21-21

——
ed

—

v)

i? 4]

@
<

—e

er)
9°)
M

Inside Macintosh,

FUNCTION

Volume V1

GetMainDevice

:

GDHandle;

The GetMainDevice function returns a handle to the graphics device record that corresponds
to the main screen. Your application can examine this graphics device record to determine the
size or depth of the main screen.
A handle to the current main device is kept in the global variable MainDevice.
FUNCTION

GetMaxDevice

(globalRect:

Rect)

:

GDHandle;

The GetMaxDevice function returns a handle to the deepest device that intersects the specified
global rectangle. Your application might use this function to allocate offscreen pixel maps.
FUNCTION

GetNextDevice

(curDevice:

GDHandle)

:

GDHandle;

The GetNextDevice function returns a handle to the next graphics device record in the device
list. If there are no more devices in the list, it returns NIL.
PROCEDURE

SetGDevice

(gdh:

GDHandle) ;

The SetGDevice procedure sets the specified graphics device record as the current device.
Your application won’t generally need to use this procedure except to draw to offscreen
graphics devices.
PROCEDURE

SetDeviceAttribute

(gdh:

GDHandle;

attribute:

Integer;

value:

Boolean) ;

The SetDeviceAttribute procedure can be used to set a device’s attribute bits. SetDeviceAttribute
allows you to indicate whether the device is a screen device, is the main screen, supports color,
and so forth. For more information on the attributes you can set, see “The Graphics Device
Record”
earlier in this chapter.
FUNCTION

TestDeviceAttribute

(gdh:

GDHandle;

attribute:

Integer)

Boolean;

The TestDeviceAttribute function tests a single attribute to see if its value is TRUE. If your
application is scanning through the device list, it typically uses this function to determine
whether a device is a screen device, and, if so, to determine whether it’s active. Then your
application can draw to any active screen devices.
PROCEDURE

DisposGDevice

(gdh:

GDHandle) ;

The DisposGDevice procedure disposes of the current graphics device record, releases the
space allocated for it, and disposes of all data structures allocated by NewGDevice.

21-22.

Graphics Devices Manager Routines

The Graphics Devices Manager

FUNCTION

HasDepth

(aDevice:

GDHandle;

Integer;

flags:

depth:

Integer)

:

Integer;
whichFlags:
Integer;

The HasDepth function checks to see whether the device you specify in the aDevice parameter
supports the pixel depth you specify in the depth parameter. In the whichFlags parameter you
specify which of the gdFlags set to check; in the flags parameter you specify the value to
check for. The function returns 0 if the device does not support the mode you inquire after; if
the device does support the mode, the function returns the mode ID. (See the Slot Manager
chapter in this volume and Designing Cards and Drivers for the Macintosh Family, second
edition, for information about device modes.)
You should always test a device for a particular depth before setting the device’s depth.
FUNCTION

SetDepth

(aDevice:
Integer;

GDHandle;
flags:

depth:

Integer)

Integer;
:

i)
—

?P)
~

whichFlags:

&
ao)
=
it

OSErr;

or)
M

The SetDepth function sets the mode of the specified device to the pixel depth you specify in
the depth parameter. It does not change the 'scrn' resource; when the system is rebooted, the
original depth is restored.
Note: This function is a convenience for applications that need to run on devices of a
particular depth and are unable to adapt to any other depth. Your application should
use it only after asking the user’s permission.
In the whichFlags parameter you specify which of the gdFlags set to modify; in the flags
parameter you specify the value. (Currently, the first flag, gdDevType, is the only one that
can be set with a SetDepth call.) For example, if you wanted to switch a device to black and
white, you would specify a whichFlags value of 0001 and a flags value of 0000.
Call the HasDepth function before calling SetDepth to verify that the device in question can be
set to the depth desired.
PROCEDURE

DeviceLoop

(drawingRgn:

RgnHandle;

drawingProc:

DeviceLoopDrawingProcPtr;
flags:

userData:

LongInt;

DeviceLoopFlags) ;

The DeviceLoop procedure searches all active screen devices, calling your drawing procedure
whenever it encounters a screen that intersects your drawing region. You supply a handle to
the region in which you wish to draw and a pointer to your drawing procedure. The drawing
region is in local coordinates, and is the same as a window port’s visRgn value, for example,
after a BeginUpdate call. In the userData parameter, you pass a long integer of data that is
forwarded to your drawing procedure.
If the DeviceLoop procedure encounters similar devices—having the same pixel depth,
black-and-white/color setting, and matching color table seeds—it makes only one call to
your drawing procedure, pointing to the first such device encountered. You can modify
this behavior by supplying a flags parameter with one of the following values.

Graphics Devices Manager Routines

— 21-23

|
a

\¢°)
<
mee
O°
@
~”

Inside Macintosh,

Volume

VI

Flag

Meaning

singleDevices

If you set the singleDevices flag, then similar devices are not grouped
together when the drawing procedure is called. If this flag is not set,
DeviceLoop only calls your drawing procedure once for each set of
similar devices, and the first one found is passed as the target device.
(It is assumed to be representative of all the similar devices.)

dontMatchSeeds

__ If you set the dontMatchSeeds flag, then DeviceLoop doesn’t consider
color table seeds when comparing devices for similarity. DeviceLoop
ignores this flag if the singleDevices flag is set.

allDevices

If you set the allDevices flag, the drawingRgn parameter is ignored,
and DeviceLoop calls your drawing procedure for all active screens.
The current port’s visRgn value is not affected when this flag is set.

Each time your drawing procedure is called, the current port’s visRgn field will have been set
to the intersection of the original port’s visRgn and the intersecting portion of the target device.
Your drawing procedure should be declared as follows:
PROCEDURE

MyDrawingProc

(depth:

Integer;

targetDevice:

deviceFlags:

GDHandle;

Integer;

userData:

LongInt) ;

The depth parameter contains the pixel size of the target device, the deviceFlags parameter
contains the gdFlags values from the target device’s graphics device record, and the
targetDevice parameter is a handle to the target device.
The long integer of user data passed to DeviceLoop is passed on to your drawing procedure.
When called from a computer without Color QuickDraw, the targetDevice parameter is set
to NIL.

21-24

— Graphics Devices Manager Routines

The Graphics Devices Manager

SUMMARY

OF

THE

GRAPHICS

for

gdType}

DEVICES

MANAGER

Constants
CONST

{values

clutType
fixedType

=
=

QO;
Je

directType

=

2;

{0

if

look-up

{1
{2

if
if

fixed table}
direct pixel

table}

values}

nN

oom

{bit

assignments

for

gdFlags}

gdDevType
burstDevice

=
=

0;
7;

{set

if

device

{set

if

ext32Device

=

8;

raminit

=

I0;

{set
{set

if
if

mainScreen

=

ts

{set

allInit

=

42;

{set

screenDevice

=

13;

noDriver

=

14;

screenActive

=

15;

{

Data

Types

TYPE

GWorldPtr

=

OF

color}

device

supports

block

device
device

must be accessed in 32-bit mode}
has been initialized from RAM}

if

device

is

if

devices

were

main

=<
dd

transfer}

—

~

owm
=—
<
o
oA

Sell

screen}

me

initialized

from

'scrn'

}

offscreen

buffer

}

resource}

{set
{set
{set

if
if
if

device
device
device

is a screen device}
has no driver}
is active}

CGrafPtr;

GWorldFlags
SET

?)
=
£9

supports

=

(

pixPurge,

{used

NewGWorld

to

make

noNewDevice,

{ purgeable}
{used by NewGWorld

to

not

to

allocate

{
useTempMem,
keepLocal,
gWorldFlag4,
gWorldFlag5,
pixelsPurgeable,
pixelsLocked,
gWorldFlag8,
gwWorldFlag9,
gWorldFlagl0,
gWorldFlagl1l,
gWorldFlagil2,
gWorldFlag13,

by

create

an

offscreen

device}

{used

by

NewGWorld

{ temporary
memory}
{used
to keep data
structures

pixels

in

in

memory}

main

}

{reserved}
{reserved}
{used by Get/SetPixelsState

for

purgeable

{ pixels}
{used by Get/SetPixelsState

for

locked

pixels}

Summary of the Graphics Devices Manager

— 21-25

}

{reserved}
{reserved}
{reserved}
{reserved}
{reserved}
{reserved}

}

Inside Macintosh,

Volume VI

gWorldFlagl4,

gWorldFlag15,
mapPix,
newDepth,

{reserved}
{reserved}
{set

by

UpdateGWorld

if

color

mapping

{set
{ to

by

UpdateGWorld

if

pixels

were

scaled

{set
{ to

by UpdateGWorld if
screen alignment}

pixels

were

realigned

newRowBytes,

{set

by

pixel

reallocPix,

{ reconfigured
in a new
{set by UpdateGWorld
if

gworldFlag21,

{ to be reallocated}
{reserved}

gworldFlag22,

{reserved}

gworldFlag23,
gWorldFlag24,

{reserved}

alignPix,

a

different

occurred}
}

depth}

UpdateGWorld

if

map

was

}

}

rowBytes}
offscreen

buffer

had

}

{reserved}

gWorldFlag25,

{reserved}

gworldFlag26,

{reserved}

gworldFlag27,

{reserved}

clipPix,
stretchPix,

{used
{used

ditherPix,

{used

gwFlagErr,

{set

{

by
by

UpdateGWorld
UpdateGWorld

to
to

clip pixels}
stretch or shrink

}

pixels}
by

by

UpdateGWorld

to

UpdateGWorld

if

dither

it

pixels}

failed}

) ¥
GDHandle

=

“GDPtr;

GDPtr

=

“GDevice;

GDevice

=

RECORD
gdRefNum:

Intecer;

{reference

number

gdID:

Intecer;

{client

for

gdType:

Integer;

{type

ITabHandle;

{inverse

gdResPref:

Integer;

{preferred

gdSearchProc:
gdaCompProc:

SProcHndl;
CProcHndl;

{list
{list

gdiTable:

gdFlags:

of

device

driver}
procedure}

(indexed,

table

of
of

of

search
for

Color

direct) }
Manager}

resolution}

search functions}
complement functions}

Integer;

{graphics

gdaPMap:

PixMapHandle;

{pixel

gaRefCon:

LongIint;

{reference

gdNextGD:

GDHandle;

{handle

gdRect:
gdMode:

Rect;
Longint;

{device's
{device's

global
bounds}
current
mode}

gacCBytes:
gdCCDepth:

Integer;
Integer;

{width
{depth

expanded
expanded

gdCCXData:
gdCCXMask:
gdReserved:

Handle;
Handle;
LongInt

{handle
to cursor's
expanded
{handle
to cursor's
expanded
{reserved
for future use;
}
{

END;

21-26

ID

Summary of the Graphics Devices Manager

must

device

map

to

of
of

be

for

flags}

displayed

image}

value}

next

0}

graphics

cursor
cursor

device}

data}
data}
data}
mask}

The Graphics Devices Manager

Routines

Creating
FUNCTION

a Graphics

World

NewGWorld

(VAR

offscreenGWorld:

Integer;

boundsRect:

CTabHandle;

Rect;

aGDevice:

GWorldFlags)

Working

GWorldPtr;

:

pixelDepth:

cTable:

GDHandle;

flags:

QDErr;

with a Graphics World’s Pixel Map
nN

FUNCTION

LockPixels

(pm:

PixMapHandle)

:

UnlockPixels

(pm:

PixMapHandle) ;

PROCEDURE

AllowPurgePixels

(pm:

PixMapHandle) ;

PROCEDURE

NoPurgePixels

(pm:

PixMapHandle) ;

FUNCTION

GetPixelsState

(pm:

PixMapHandle)

:

(pm:

PixMapHandle;

state:

PixMapHandle)

:

SetPixelsState

FUNCTION

GetPixBaseAddr

(pm:

FUNCTION

PixMap32Bit

(pmHandle:

Updating
FUNCTION

the Graphics

UpdateGWorld

=F

aie

oO
ie)

o
@

<
hie
er]
is")
~N

GWorldFlags;
GWorldFlags) ;

Ptr;

PixMapHandle)

:

Boolean;

World
(VAR

offscreenGWorld:

Integer;

boundsRect:

CTabHandle;

aGDevice:

GWorldFlags)

Retrieving

Q=

=
S

PROCEDURE

PROCEDURE

—

Boolean;

Setting

and

the Graphics

PROCEDURE

SetGWorld

(port:

PROCEDURE

GetGWorld

(VAR

:

Rect;

pixelDepth:

cTable:

GDHandle;

flags:

GWorldFlags;

World

CGrafPtr;
port:

GWorldPtr;

gdh:

CGrafPtr;

GDHandle);
VAR

gdh:

GDHandle);

FUNCTION

GetGWorldDevice

(offscreenGWorld:

GWorldPtr)

:

GDHandle;

FUNCTION

GetGWorldPixMap

(offscreenGWorld:

GWorldPtr)

:

PixMapHandle;

Disposing of a Graphics World
PROCEDURE

DisposeGWorld

(offscreenGWorld:

GWorldPtr);

Summary of the Graphics Devices Manager

— 21-27

Inside Macintosh,

Volume VI

Supporting

the Offscreen

FUNCTION

NewScreenBuffer

Graphics

World

(globalRect:

Rect;

gch:

GDHandle;

PixMapHandle)
FUNCTION

NewTempScreenBuffer

(globalRect:

:

DisposeScreenBuffer

Managing
FUNCTION

the Graphics

NewGDevice

PROCEDURE

purgeable:

Boolean;

VAR

PixMapHandle) ;

Record

(refNum:

InitGDevice

VAR

VAR offscreenPixMap:
: QDErr;

(offscreenPixMap:

Device

Boolean;

offscreenPixMap:

QDErr;

Rect;

gdh:
GDHandle;
PixMapHandle)

PROCEDURE

purgeable:

VAR

Integer;

(gdRefNum:

mode:

Integer;

LongInt)

mode:

:

LongInt;

GDHandle;
gdh:

GDHandle) ;
FUNCTION

GetGDevice

:

GDHandle;

FUNCTION

GetDeviceList

:

GDHandle;

FUNCTION

GetMainDevice

:

GDHandle;

FUNCTION

GetMaxDevice

(globalRect:

FUNCTION

GetNextDevice

(curDevice:

PROCEDURE

SetGDevice

(gdh:

GDHandle);

PROCEDURE

SetDeviceAttribute

(gdh:

GDHandle;

Rect)

:

GDHandle;

GDHandle)

:

GDHandle;

attribute:

Integer;

attribute:

Integer)

value:

Boolean) ;
FUNCTION

TestDeviceAttribute

(gdh:

GDHandle;

Boolean;

PROCEDURE

DisposGDevice

(gdh:

GDHandle) ;

FUNCTION

HasDepth

(gd:

GDHandle;

Integer:
FUNCTION

SetDepth

(gd:

GDHandle;

Integer;
PROCEDURE

DeviceLoop

depth:

flags:

depth:

flags:

(drawingRgn:

Integer;

Integer)

RgnHandle;

Application-Defined
PROCEDURE

MyDrawingProc

:

whichFlags:

OSErr;

drawingProc:
userData:

LongInt;

DeviceLoopFlags) ;

Routine
(depth:

Integer;

targetDevice:

21-28

whichFlags:

Integer;

Integer;

Integer)

DeviceLoopDrawingProcPtr;
flags:

:

Summary of the Graphics Devices Manager

deviceFlags:
GDHandle;

Integer;

userData:

LongInt);

The Graphics Devices Manager

Global

Variables

DeviceList

A handle to the first element in the device list.

TheGDevice
MainDevice

A handle to the current active device.
A handle to the current main device.

Contains the size and shape of current desktop.

GrayRgn

Result

Codes

noErr

paramErr

—50
—152
—157

cNoMemErr

cDepthErr

i)

No error
Illegal parameter
Failed to allocate memory for structures
Invalid pixel resolution

or

=
re
Ss
=
ts
iF)
~”n

Assembly-Language
GDevice
gdRefNum
gdID

gdType

gdITable
gdResPref
gdSearchProc
gdCompProc
gdFlags
gdPMap
gdRefCon
gdNextGD
edRect
gdMode
gdCCBytes
gdCCDepth
gdCCxData
gdCCX Mask
gdReserved
gdRec

Data

@
<_—e
QO
©
77)

Information

Structure
word
word
word
long
word
long
long
word
long
long
long
2 longs
long
word
word
long
long
long

[variable]

reference number of driver
client ID for search procedure
type of device (indexed, direct)
inverse table for Color Manager
preferred resolution
list of search functions
list of complement functions
graphics device flags
pixel map for displayed image
reference value
handle to next graphics device
device’s global bounds
device’s current mode
width of expanded cursor data
depth of expanded cursor data
handle to cursor’s expanded data
handle to cursor’s expanded mask
reserved for future use; must be 0
size of graphics device record

Summary of the Graphics Devices Manager

21-29

Inside Macintosh,

21-30

Volume VI

THE

28
29
3]
32
34
38

SOUND

MANAGER

About This Chapter
About the Sound Manager
Introduction to Sound
Sound Synthesizers
The Square-Wave Synthesizer
The Wave-Table Synthesizer
The Sampled Sound Synthesizer
Sound Commands
Sound Channels
Multiple Channels of Sound
Sound Compression and Expansion
Continuous Play From Disk
Sound Recording
Sound Storage Formats
Sound Resources
The Format | 'snd ' Resource
The Format 2 'snd ' Resource
Sound Files
Chunk Organization and Data Types
The Form Chunk
The Format Version Chunk
The Common Chunk
The Sound Data Chunk
Reading and Writing Sound Files
Using the Sound Manager
Playing ‘snd ' Resources
Allocating Sound Channels
Initializing Sound Channels
Releasing Sound Channels
Determining Features of Synthesizers
Playing Frequencies
Playing Sampled Sounds
Installing Voices Into Channels
Manipulating a Sound That Is Playing
Flushing Sound Channels
Pausing and Restarting Sound Channels
Synchronizing Sound Channels
Managing the CPU Load
Producing an Alert Sound
Compressing and Expanding Sounds
Playing Sampled Sounds From Files
Playing an 'snd ' Resource From Disk
Playing a File From Disk
Playing Selections
Recording Sounds Through the Sound Input Dialog Box
Recording Sounds Directly From a Device
Defining a Sound Input Completion Routine
Defining an Interrupt Routine
Getting and Setting Sound Input Device Information

S

nN

v2
=
a.
<

_—

&

=
&
ge<
Lee

22-1

|

Inside Macintosh,

Volume VI

Obtaining Information About Sound Features
Obtaining Information About Available Sound Features
Obtaining Version Information
Obtaining Information About a Single Sound Channel
Obtaining Information About All Sound Channels
Using Double Buffers
Setting Up Double Buffers
Writing a Doubleback Procedure
Specifying Callback Routines
Sound Manager Routines
Playing Sound Resources
Allocating and Releasing Sound Channels
Linking Synthesizers to Sound Channels
Sending Commands to a Sound Channel
Obtaining Information
Playing From Disk
Managing Double Buffers
Compressing and Expanding Audio Data
Recording Sounds
Manipulating Sound Input Devices
Opening and Closing Sound Input Devices
Recording Sounds Directly From Sound Input Devices
Manipulating Device Settings
Constructing Sound Resource and File Headers
Registering Sound Input Devices
Converting Between Milliseconds and Bytes
Summary of the Sound Manager

22-2

The Sound Manager

ABOUT

THIS

CHAPTER

The Sound Manager was first released for all Macintosh® computers as part of system software
version 6.0 and has been significantly enhanced in later system software versions. System
software versions 6.0.7 and later include an enhanced Sound Manager that provides routines
for sound input, continuous play from disk, sound-channel mixing, and audio compression
and expansion. There are no specific hardware requirements for running this enhanced version
of the Sound Manager, except that the continuous play-from-disk routines and the ability to
produce concurrent multiple channels of sampled sound are currently available only on
machines equipped with the Apple® Sound Chip (ASC). Also, you can use the sound input
routines to record sounds only on machines equipped with a sound input device. Use the
Gestalt function (described in the Compatibility Guidelines chapter in this volume) to determine
whether the capabilities you need are present before attempting to use them.

(KE

This chapter describes how your application can use the Sound Manager to create, modify,
and play sounds. The information in this chapter supersedes the information in the Sound
Manager chapter of /nside Macintosh, Volume V. The Sound Manager is a replacement for
the older Sound Driver, which is documented in /nside Macintosh, Volume I. The Sound
Driver is obsolete, and you should use the Sound Manager for all sound-related activity.

2)
~~

i]
p=
h—
~
—

You should read this chapter if you want your application to create or manipulate sounds. For
example, your application might be specifically concerned with creating and storing sounds.
Such applications include those that synthesize sound or speech, record and play back sampled
sounds, and synchronize multimedia presentations. Other applications that use sound include
those that provide voice mail and voice annotation capabilities for documents. For compatibility reasons, you should use the services provided by the Sound Manager rather than access
the available audio hardware directly. This increases the likelihood that your application will
run unmodified on future hardware or on alternate operating systems (such as A/UX®).
Moreover, by using the Sound Manager, your application can monitor and control the amount
of processing time consumed by its sound-related activity, and hence coexist cooperatively
with other open applications.
Even if your application is not specifically concerned with creating or playing sounds, you can
often improve your application at very littke programming expense by using the Sound Manager
to integrate sound into its user interface. For example, you can play appropriate sounds to signal
that some operation has completed or to alert the user that something exceptional (perhaps unexpected) has happened. If you use sound in this way, you should be aware that there may be
cultural biases or preferences associated with certain sounds. Unless they are very large, therefore, you should store all application-specific sounds as resources, which can be easily
modified for local regions. You should also make this sort of sound optional because there
might be users who object to it or environments where it is inappropriate.
You should note in particular that the SysBeep procedure, documented in /nside Macintosh,
Volume II, as one of the Operating System Utilities, is now a Sound Manager routine. Hence,
even if you are developing an application that does not employ any sound other than an occasional system alert sound, you need to be aware of certain situations that may prevent the
sound from being heard by the user. If your applications use the SysBeep procedure, you
should look at the discussion in “Producing an Alert Sound”; some sections of the “Introduction to Sound” may be helpful to you as well.

About This Chapter

22-3

a.
2

vent

as

—_

_
as
—

-~

ge

0"
"

Inside Macintosh,

Volume VI

If you wish to create files containing sampled sounds (such as recorded speech or special
effects), you may need to refer to the information on the Audio Interchange File Format

(AIFF) and the Audio Interchange File Format extension for Compression (AIFF-C). You

can find a partial specification of both of these file formats in “Sound Files” later in this
chapter. A more complete description of the AIFF file format is available from APDA®.

ABOUT

THE

SOUND

MANAGER

The Sound Manager is a collection of routines that your application can use to create sounds
without a knowledge of or dependence on the actual sound-producing hardware available on
any particular Macintosh computer. You can use the Sound Manager to
m play simple sequences of frequencies
m play sounds described by complex waveforms
a play digitally recorded or computed sampled sounds
w record sampled sounds
m mix and synchronize multiple channels of sound
a play a sound continuously from disk while other processing continues
m produce a sound to alert the user
m compress sound data to maximize the available disk storage space
m expand compressed sound data for playback in real time
w obtain information about existing sound channels
= monitor and limit the amount of CPU time consumed by sound-related activity
If you use the Sound Manager for all sound-related activity instead of accessing the soundproducing hardware directly, you can maximize the likelihood that your applications will run
without modification on all current and future hardware configurations.
This chapter provides a brief introduction to sound on Macintosh computers and then

discusses

= sound synthesizers
m= sound commands
a

sound channels

A thorough understanding of these topics is essential to efficient use of the Sound Manager
in your applications. Thereafter, this chapter provides a preliminary discussion of the major
22-4

About the Sound Manager

The Sound Manager

features that are new to the enhanced Sound Manager provided with system software
versions 6.0.7 and later, including
m= mixing multiple channels of sampled sound
= compressing and expanding sound data
a playing sounds stored on disk while other applications execute
m recording sounds on Macintosh computers having appropriate sound input hardware
w obtaining status information about sound channels
This chapter also describes sound resources and sound files, the two sound storage formats
supported by the Sound Manager. Most applications do not need to know the details of these
storage formats because the Sound Manager provides routines that allow you to read and
create both sound resources and sound files. In most cases, your application should use those
routines rather than create or parse sound resources or files directly.
Nm
nN

Most applications are likely to need only a few of the many capabilities of the enhanced
Sound Manager. If your application’s use of sound falls into one or more of the following
categories, you can proceed right to the indicated sections in this chapter to find the
information you need.

y
=
=
a
4
—

=» Controlling the system alert sound. Your application can use the Sound Manager
to play, disable, or enable the system alert sound selected by the user in the Sound
control panel. The system alert sound is played whenever an application issues the
SysBeep procedure. For more information about controlling the system alert sound,
see “Producing an Alert Sound” later in this chapter.
= Playing prerecorded sounds. Your application can play back prerecorded sampled
sounds by calling the SndPlay function. The sampled sound can contain speech, sound
effects, or other sounds needed by your application. For more information on playing
back prerecorded sounds, see “Playing 'snd' Resources” later in this chapter. If the
sound you want to play back is too large to fit into RAM, you can play it by calling
SndStartFilePlay. This routine should be used only with very large sounds because it
consumes more processing time than SndPlay. For more information on playing
sampled sounds from disk, see “Continuous Play From Disk” later in this chapter.
= Compressing and expanding sounds. If your application uses lots of sounds, you
might want to compress those sounds to reduce the size of the data shipped with your
application. The Sound Manager provides several routines to handle this compression of
audio data. The real-time expansion and playback are handled automatically by the

Sound Manager when you issue a request to play the sampled sound data. For more
information on compressing and expanding sounds, see “Sound Compression and
Expansion” later in this chapter.
= Recording sounds. Any Macintosh computer equipped with sound input hardware
and an associated driver is able to record sounds (several Macintosh computers
include these items as standard features). By using one of several recording routines,
your application can record sounds to provide capabilities such as voice mail, voice
annotation, speech recognition, and even overdubbing. For more information on sound
input, see “Sound Recording” later in this chapter.
About the Sound Manager

22-5

pew

=
>
ge
0

Inside Macintosh,

Volume VI

a Mixing multiple channels of sound. On Macintosh computers with sufficient
processing capability, multiple channels of sampled sound can be played simultaneously.
This means that your application can play several sampled sounds simultaneously, or
that your application can play sampled sounds while other applications do so also. For
more information on mixing multiple channels of sampled sound, see “Multiple Channels
of Sound” later in this chapter. Mixing can also include more than just simultaneous
playback of sampled sounds. Certain audio characteristics can be altered in real time
while a sound is playing. See “Manipulating a Sound That Is Playing” later in this chapter
for more details.
= Designing sound. The Sound Manager has facilities for designing and controlling
complex sounds. Your application can play a series of frequencies at specified durations in a manner that will be familiar to users. You can use custom waveforms to
change the timbre of these sounds, and you can play them on multiple channels
concurrently. Sounds can be speeded up or slowed down, made louder or less loud,
or panned left, right, or center in real time. To understand the full power of the Sound
Manager, start by reading “Sound Synthesizers” later in this chapter and then look over
the table of contents for specific areas of interest.

INTRODUCTION

TO

SOUND

Sound is created on a Macintosh computer when the Sound Manager (or an application) sends
data to whatever audio hardware is available on the machine. The audio hardware is a digitalto-analog converter (DAC) that translates digital audio data into analog audio signals; those
signals are then sent to the internal speaker or to a sound output connector (to which the user

can connect headphones, external speakers, or sound amplification equipment). The DAC in
all current Macintosh computers is a Sony sound chip. The Macintosh II family of computers
and more recent models (such as the Macintosh SE/30 and Macintosh Portable) contain two

Sony sound chips (to provide stereo output capability) as well as an Apple Sound Chip, a
customized chip that provides enhanced audio output characteristics as well as emulation
capabilities for the earlier sound hardware. There are also NuBus™ expansion boards available from third-party developers that provide other audio DAC hardware.
To maximize compatibility across the entire family of Macintosh computers, your application
should never address any built-in audio hardware directly. Instead, you should always create
sound by sending the appropriate instructions to the Sound Manager. The Sound Manager is
responsible for managing all communication between your application and the available audio
hardware, as illustrated in Figure 22-1.
Your application creates sound by sending sound commands to the Sound Manager, which
interprets those commands and places them into a sound channel. A sound channel is a firstin, first-out (FIFO) queue. Queued commands are sent to the sound hardware through a
sound synthesizer, which is like a device driver insofar as it is responsible for managing
the last stage of communication with the audio hardware. Every sound channel is linked to
one of three available synthesizers, depending on the type of sound to be produced.

22-6

Introduction to Sound

The Sound Manager

Sound
hardware

Figure 22-1. The position of the Sound Manager

nN

nN
2

Sometimes it is necessary to bypass the queue of sound commands altogether. If you want
to stop all sound production on a particular channel immediately, for example, it would be
counterproductive to send a command to the sound channel because that command remains
queued until it becomes the next command processed by the synthesizer. Instead, you can
send commands directly to the synthesizer, as illustrated in Figure 22-2.

Commande

|

Sound Manager

Figure 22-2.

Bypassing the command

queue

When you bypass the sound channel in this way, any commands that are already queued but
not yet sent to the synthesizer remain queued. You can, however, flush the channel at any
time by sending the Sound Manager the appropriate command.

Introduction to Sound

22-7

—

=

i)

=
2
—
oS)
=
i

ge
©
“

Inside Macintosh,

Volume VI

With the enhanced Sound Manager, you can have multiple channels of sampled sound open
and multiple commands sent to the sampled sound synthesizer concurrently. For example,
two different applications can each open a sound channel and send commands to it.
Figure 22-3 illustrates such a situation.

Synthesizer
Sound
channels

:

Q

Sound
hardware

Figure 22-3. Mixing multiple channels of sampled sound
In this illustration, two applications are sending sound commands to the sampled sound
synthesizer. The Sound Manager maintains a separate queue of commands for each application but mixes the audio data before sending it to the sampled sound synthesizer. The result
is a single audio signal that is sent to the available audio hardware.

Sound

Synthesizers

A synthesizer is the code responsible for interpreting sound commands and using the available hardware to produce sounds. The Sound Manager insulates an application from the
underlying hardware primarily by selecting the sound hardware drivers (or synthesizers) that
are best suited to the available audio hardware.
Synthesizers that drive the built-in audio hardware on Macintosh computers are provided by
Apple Computer, Inc. and are stored in the System file as resources of type 'snth’. Depending
on the type of sound you wish to produce, the Sound Manager uses either the square-wave
synthesizer, the wave-table synthesizer, or the sampled sound synthesizer to interpret commands and data sent to it by your application. Sometimes you do not need to specify which
synthesizer you wish to use because some sound commands can be interpreted by all three.

The

Square-Wave

Synthesizer

The square-wave synthesizer is the simplest of the playback synthesizers supplied
with the Sound Manager. You can use it to generate a sound based on a square wave, and
it is functionally equivalent to the square-wave synthesizer contained in the old Sound Driver.
Your application can use the square-wave synthesizer to play a simple sequence of sounds
in which each sound is described completely by three factors: its frequency or pitch, its
amplitude (or volume), and its duration.
22-8

Introduction to Sound

The Sound Manager

The square-wave synthesizer can play only one frequency at a time through a sound channel,
and it cannot play back a waveform sound description or a recorded sound. The square-wave
synthesizer requires very little CPU time, however, and it is very easy for your application
to use.

The

Wave-Table

Synthesizer

To produce more complex sounds than are possible using the square-wave synthesizer, your
applications can use the wave-table synthesizer. As the name indicates, the wave-table
synthesizer can produce sounds that are based on a description of a single wave cycle. This
cycle is called a wave table and is represented as an array of bytes that describe the timbre
(or tone) of a sound at any point in the cycle.
Your application can use any number of bytes to represent the wave, but 512 is the recommended number because the Sound Manager resizes a wave table to 512 bytes if the table is
not exactly that long. Your application can compute the wave table at run time or load it from
a resource. You can open multiple wave-table channels (up to a maximum of four).
A wave table is a sequence of wave amplitudes measured at fixed intervals. For instance, a
sine wave can be converted into a wave table by taking the value of the wave’s amplitude at
every '/si2 interval of the wave (see Figure 22-4).

nN
nm

LzZ
2
s
=

lo!

a

—

+)

Single wave cycle

—

~

py)

|

$FF

ge

‘o)
=“

$80

00
wm,
Packed array of bytes

Figure 22-4.

A graph of a wave table

A wave table is represented as a packed array of bytes. Each byte contains a value in the
range $00-$FF. These values are interpreted as offset values, where $80 represents an
amplitude of 0. The largest negative amplitude is $00 and the largest positive amplitude
is $FF. When playing a wave-table description of a sound, the wave-table synthesizer
loops through the wave table for the duration of the sound.
Introduction to Sound

22-9

Inside Macintosh,

The

Sampled

Volume VI

Sound

Synthesizer

You can use the sampled sound synthesizer to play back sounds that have been digitally
recorded (that is, sampled) as well as sounds that are computed, possibly at run time. The
sampled sound synthesizer is the most widely used of all the available synthesizers, primarily
because it is relatively easy to generate a sampled sound and because such samples can contain
a wide variety of sounds. The sampled sound synthesizer is typically used to play back prerecorded sounds such as speech or special sound effects.
You can use the Sound Manager to store sounds in one of two ways, either as resources of
type 'snd' or as AIFF or AIFF-C format files. The structure of resources of type 'snd ' is
given in “Sound Resources” later in this chapter, and the structure of AIFF and AIFF-C files
is given in “Sound Files” later in this chapter. If you simply want to play short prerecorded
sampled sounds, you should probably include the sound data in an 'snd ' resource. If you
want to allow the user to transfer recorded sound data from one application to another (or
from one operating system to another), you should probably store the sound data in an AIFF
or AIFF-C file. In certain cases, you need to store sampled sounds in files and not in
resources. For example, some sampled sounds might be too large to store as resources; in
those cases, you should store the sounds in an AIFF or AIFF-C file.
Regardless of how you store a sampled sound, you can use Sound Manager routines to play
that sound using the sampled sound synthesizer. If you choose to store sampled sounds in
files of type AIFF or AIFF-C, you can play those sounds by calling the SndStartFilePlay
function. If you store sampled sounds in resources, your application can play those sounds
by passing the Sound Manager function SndPlay a handle to a resource of type 'snd ' that
contains a sampled sound header. (The SndStartFilePlay function can also play 'snd '
resources directly from disk.) There are three types of sampled sound headers: the standard
sound header (used for monophonic sampled sounds), the extended sound header (used for
stereo samples), and the compressed sound header (used for compressed samples, whether
monophonic or stereo). The sampled sound header contains information about the sample
(such as the original sampling rate, the length of the sample, and so forth), together with an

indication of where the sample data is to be found. The data can be stored in a buffer separate
from the sound resource or as part of the sound resource at the end of the sound header.
Note:

The terminology sampled sound header can be confusing because in most

cases the sound header (and hence the 'snd ' resource) contains the sound data as

well as information describing the data.

You can play a sampled sound at its original rate or play it at some other rate to change its
pitch. Thus, once you install a sampled sound header into a channel, it can be played at
varying rates to provide a number of pitches and hence can be used as a voice to play a series
of sounds.

Sound

Commands

The Sound Manager provides routines that allow you to create and dispose of sound channels
and send control information directly to synthesizers. These routines allow you to manipulate
sound channels and synthesizers, but (except for the SndPlay and SndStartFilePlay functions)
they do not directly produce any sounds. To actually produce sounds, you need to issue
sound commands. A sound command is an instruction to a synthesizer to produce sound,
modify sound, or otherwise assist in the overall process of sound production.
22-10

Introduction to Sound

The Sound Manager

You can issue sound commands in several ways. You can send sound commands one at a
time into a sound channel by repeatedly calling the SndDoCommand function. Or you can
bypass a sound channel altogether and send commands directly to a playback synthesizer
by calling the SndDolmmediate function. You can also issue sound commands by calling
the function SndPlay and specifying a sound resource of type 'snd ' that contains the sound
commands you want to issue. A sound resource can contain any number of sound commands
and can be used to send commands and data to any of the available sound synthesizers. As
a result, you may be able to accomplish all sound-related activity simply by creating sound
resources and calling SndPlay in your application. See “Sound Resources” later in this
chapter for details on the format of an 'snd ' resource.
Generally speaking, no matter how they are issued, all sound commands are eventually sent
to the playback synthesizer, which interprets the commands and plays the sound on the available audio hardware. All synthesizers are designed to accept the most general set of sound
commands, although some commands are specific to a particular synthesizer. Here is the
structure of a generic sound command:
TYPE

SndCommand
PACKED

=

ly
Nm

RECORD

cmd:

Integer;

{command

paraml:

Integer;

{first

number}

ZN

parameter}

=

param2:

LongiInt

{second

—

=
ajou
=)
—

parameter}

END;

ae
SY)

Commands are always 8 bytes in length. The first 2 bytes are the command number, and
the next 6 make up the command’s options. The format of the last 6 bytes depends on the
command in use, although typically those 6 bytes are interpreted as an integer followed by
a long integer. For example, an application can install a wave table into a sound channel
by using SndDoCommand with a sound command whose cmd field is the waveTableCmd
constant. In that case, the param1 field specifies the length of the wave table, and the param2
field is a pointer to the wave-table data itself. Other sound commands may interpret the
6 parameter bytes differently or may not use them at all.
The sound commands available to your application are defined by constants.
CONST

nullCmd

=

0%

{do

quietCmd

=

3

{stop

flushCmd

=

4%

{flush

53

{reinitialize

waitCmd

=

10;

{suspend

pauseCmd
resumeCmd

=
=

11;
12;

{pause processing
in a channel}
{resume processing
in a channel}

callBackCmd
syncCmd

=
=

13;
14;

{execute
a callback procedure}
{synchronize
channels}

availableCmd
versionCmd

=
=

24;
25;

{see
if initialization
{determine
synthesizer

totalLoadCmd
loadCmd

=
=

26;
27;

{report
{report

freqDurationCmd

=

40;

{play

a

frequency

restCmd

=

41;

{rest

a

channel

freqCmd

=

42;

{change

reInitCmd

nothing}
a

sound
a

that

sound

is

playing}

channel}

a

sound

processing

channel}
in

a

channel}

option available}
version}

total
CPU load}
CPU
load
for a new

the

pitch

for
for

of

channel}

specified

specified

a

duration}
duration}

sound}

Introduction to Sound

=. 22-11

—
—

i

itjo)
o
a

Inside Macintosh,

Volume VI

ampCmd

=

43;

{change

the

amplitude

of

a

timbreCmd

=

44;

{change

the

timbre

of

a

sound}

amplitude

of

a

sound}

table

the

sound}

getAmpCmd

=

45;

{get

waveTableCmd

=

60;

{install

as

a

soundCmd
bufferCmd

=
=

80;
81;

{install
a sampled
sound
{play a sampled
sound}

as

rateCmd

=

82;

{set

the

pitch

of

a

sampled

sound}

getRateCmd

=

85;

{get

the

pitch

of

a

sampled

sound}

a

wave

voice}
a

voice}

For details on each sound command, see the relevant sections in “Using the Sound Manager”
later in this chapter. Also see Table 22-6 for a complete summary of the available sound
commands, their parameters, and their uses.

Sound

Channels

A sound channel is a queue of sound commands that is managed by the Sound Manager.
The commands placed into the channel might originate from an application or from the
Sound Manager itself (in response to instructions from a playback synthesizer). The commands in the queue are passed one by one, in a first-in, first-out (FIFO) manner, to the
playback synthesizer.
The Sound Manager uses the SndChannel data type to define a sound channel.
TYPE

SndChannel
PACKED

=

RECORD

nextChan:
firstMod:

SndChannel Ptr;
Ptr;

{pointer
to next
channel}
{used
internally}

callBack:

ProcPtr;

{pointer

userinfo:

Longint ;

{free

for

to

callback

wait:

Time;

{used

internally}

cmdInProgress:

SndCommand;

{used

internally}

flags:

Integer;

{used

internally}

qLength:

Integer;

{used

internally}

qHead:

Integer;

{used

internally}

qTail:

Integer;

{used

queue:

ARRAY[0..stdQLength-1]

proc}

application's

use}

internally}
OF

SndCommand

END;

Most applications do not need to worry about creating or disposing of sound channels
because the high-level Sound Manager routines take care of these automatically. If you are
using low-level Sound Manager routines, you can create your own sound channels (with

the SndNewChannel function).

Multiple Channels

of Sound

One of the most useful enhancements made to the Sound Manager is the ability to have
multiple channels of sampled sound produce output on the Macintosh audio hardware
concurrently. Previous versions of the Sound Manager could play only a single channel
22-12

Introduction to Sound

The Sound Manager

of sampled sound at a time. One consequence of this was that if a system alert sound was
called while a sampled sound was playing, the alert sound would not be heard (although, if
you were lucky, the menu bar might flash). A more important consequence was that it was
impossible to provide the layering of sound that can bring a touch of reality to a simulation
or presentation. Furthermore, the limitation to one sampled sound at a time made it very
difficult for an application to incorporate Macintosh-synthesized voice output with any other
kind of Macintosh-generated sound.
Using the enhanced Sound Manager, your application can open several channels of sampled
sound for concurrent output on the available audio hardware. Similarly, multiple applications
can each open channels of sampled sound. The number and quality of concurrent channels of
sound are limited only by the abilities of the machine, particularly by the speed of the CPU.
Different Macintosh computers have different CPU clock speeds and execute instructions at
quite different rates. This means that some machines can manage more channels of sound and
produce higher-quality sound than other machines. For example, a Macintosh II may be able
to support several channels of high-quality stereo sound without significant impact on other
processing, whereas a Macintosh Plus is able to support only a single channel before other
processing slows significantly. The enhanced Sound Manager provides the capability to
balance CPU loads for sound-related activity, thereby further insulating the application from
the underlying hardware.
The Sound Manager currently supports multiple channels of sampled sound only on machines
equipped with an Apple Sound Chip. To maintain maximum compatibility between machines
for your applications, you should always check the operating environment (using the Gestalt
function documented in the Compatibility Guidelines chapter in this volume) to make sure that
the ability to play multiple channels of sampled sound is present before attempting to do so.

Sound

Compression

and

Expansion

One minute of single-channel sound recorded with the fidelity you would expect from a
commercial compact disc occupies about 5.3 MB of disk space. One minute of sound
digitized by the current low-fidelity digitizing peripherals for the Macintosh occupies
more than | MB of disk space. Even one minute of telephone-quality speech takes up more
than half of a megabyte on a disk. Despite the increased capacities of mass-storage devices,
disk space can be a problem if your application incorporates sound. The space problem
is particularly acute for multimedia applications. Because a large portion of the space
occupied by a multimedia application is likely to be taken up by sound data, the complexity
and richness of the application’s sound component are limited.
To help remedy this problem, the enhanced Sound Manager includes a set of new routines
known

collectively as Macintosh

Audio

Compression

and

Expansion (MACE).

MACE enables you to provide more audio information in a given amount of storage space
by allowing you to compress sound data and then expand it for playback. These enhancements are based entirely in software and require no specialized hardware.
The new audio compression and expansion features allow you to enhance your applications
by including more audio data. MACE also relieves some distribution problems by reducing
the number of disks required for shipping an application that relies heavily on sound. MACE
may make some new kinds of applications feasible as well, such as talking dictionaries and
language-instruction software.

Introduction to Sound

= 22-13

nN
i)
7 2)
=
i=
=
Q.

2
—

pe)
=
mS
Te
@

ox |

Inside Macintosh,

Volume VI

MACE adds three main kinds of capabilities to those already present in the Sound Manager—
audio data compression, real-time expansion and playback of compressed audio data, and
buffered expansion and playback of compressed audio data.
=» Compression. The Sound Manager can compress a buffer of digital audio data either
in the original buffer or in a separate buffer. If a segment of audio data is too large to fit
into a single buffer, then your application can make repeated calls to the compression
routine.
a Real-time expansion playback. The Sound Manager can expand compressed audio
data contained in a small internal buffer and play it back at the same time. Since the
audio data expansion and playback occur at the same time, there is greater CPU loading
when using this method of sound expansion rather than buffered expansion.
=» Buffered expansion. The Sound Manager can expand a specified buffer of compressed audio data and store the result in a separate buffer. The expanded buffer can
then be played back using other Sound Manager routines with minimal processor
overhead during playback. Applications that require screen updates or user interaction
during playback (such as animation or multimedia applications) should use buffered
expansion.
MACE provides audio data compression and expansion capabilities in ratios of either 3:1 or
6:1 for all currently supported Macintosh models, from the Macintosh Plus forward. The
principal trade off when using MACE is that the expanded audio data suffers a loss of fidelity
in comparison to the original data. A small amount of noise is introduced into a 3:1 compressed sound when it is expanded and played back, and a greater amount of noise for the
6:1 ratio. The 3:1 buffer-to-buffer compression and expansion option is well suited for highfidelity sounds. The 6:1 buffer-to-buffer compression and expansion option provides greater
compression at the expense of lower-fidelity results and is recommended for voice data only.
This technique reduces the frequency bandwidth of the audio signal by a factor of two to
achieve the higher compression ratio.
Table 22-1 provides a summary of the available compression and expansion options.
Table

22-1.

Audio compression and expansion options
3:1

and

6:1

Stereo

Computer

3:1 and 6:1
compression

expansion
and playback

expansion
and playback

Sample-rate
conversion

Macintosh Plus

Real-time

Real-time

No

No

Macintosh SE

Real-time

Real-time

No

No

Macintosh Portable

Real-time

Real-time

Yes

Yes

Macintosh II
and successors

Real-time

Real-time

Yes

Yes

Note: Macintosh Plus, Macintosh SE, and Macintosh Portable computers play
only the right channel of stereo 'snd ' data through the internal speaker. Certain
Macintosh II models may play only a single channel through the internal speaker.
22-14

Introduction to Sound

The Sound Manager

Existing applications that use the Sound Manager’s SndPlay function to play digitized audio
signals can play compressed audio signals without modification or recompilation.
The MACE routines assume that each sample consists of 8 contiguous bits of data. The
compression techniques do not, however, depend on a particular sample rate. The compression techniques produce their best quality output when the sample rate is the same as the
output rate of the sound hardware of the machine playing the audio data. The output rate used
in current Macintosh computers is 22.254 kilohertz (hereafter referred to as the 22 kHz rate).
Because of speed limitations, the Macintosh Plus and Macintosh SE cannot perform samplerate conversion during expansion playback. On those machines, all sounds are played back
at a 22 kHz rate. To provide consistent quality in sounds that may be played on different
machines, you should record all sounds at a 22 kHz sample rate.
The MACE algorithms are optimized to provide the best sound quality possible through the
internal speaker in real time. However, the user who employs high-quality speakers may
notice a high-frequency hiss for some sounds compressed at the 3:1 ratio. This hiss results
from a design trade off between maintaining real-time operation on the Macintosh Plus and
preserving as much frequency bandwidth of the signal as possible. If you think that your
output may be played on high-quality speakers, you may want to filter out the hiss before
compression by passing the audio output through an equalizer that removes frequencies
above 10 kHz. When you use the 6:1 compression and expansion ratio, your frequency
response is cut in half. For example, when you use the 22 kHz sample rate, the highest
frequency possible would normally be 11 kHz; however, after compressing and expanding
the data at the 6:1 ratio, the highest frequency you could get would be only 5.5 kHz.

Continuous

Play From

Disk

Nm
nN
i? 2)
oS
&
|
2.
Pm
—

©
=}
i)
Aj=)
fe)
Ler

The enhanced Sound Manager provides the ability to play a sampled sound continuously
from disk while other tasks execute. You might think of the play-from-disk routines as
providing you with the ability to install a “tape player” in a sound channel. Once the sound
begins to play, it continues uninterrupted unless an application pauses or stops it.
A new function, SndStartFilePlay, allows you to play sounds stored in AIFF format or
AIFF-C format, as well as 'snd ' resources, continuously from disk. SndStartFilePlay
works like SndPlay but does not require that the entire sound be in RAM at one time. Hence,
SndStartFilePlay is ideal for playing very large sounds. The continuous play-from-disk
routines use a buffer area that is smaller than the sampled sound, and they update the buffer
from disk by using a double-buffering scheme. This technique minimizes RAM usage at the
expense of additional disk overhead. The disk overhead is relatively light, however, and
most mass-storage devices currently available for Macintosh computers have response times
good enough that SndStartFilePlay can retrieve audio data from disk and play the sound
without gaps.
There are no limits on the number of concurrent disk-based sampled sound playbacks other
than those imposed by processor speed. On machines with sufficient CPU resources, several
continuous playbacks may occur at once. Disk fragmentation can also affect the performance
of playing sampled sound files from disk. It is recommended that no more than one file per
hard disk be played at any time.
When multiple disk-based sampled sounds are playing, the Sound Manager automatically
mixes the playbacks for output on the available sound hardware. Note, however, that the

Introduction to Sound

22-15

|

Inside Macintosh,

Volume V1

Sound Manager supports continuous play from disk only on machines equipped with an

Apple Sound Chip. Also, if a sound channel is being used for continuous play from disk,
then no other sound commands can be sent to that channel.

Sound

Recording

The Sound Manager provides your application with the ability to record and digitally store
sounds in a device-independent manner. Your applications can create a resource or a file
containing a recorded sound simply by calling SndRecord or SndRecordToFile. In cases
where you need very fine control over the recording process, you can call various lowlevel sound input routines. You can then use the recorded sound in any way appropriate to
your application.
The sound input and storage routines can be used with any available sound input hardware for which there is an appropriate device driver. To allow the user to select from
among multiple possible input devices, the Sound control panel lists the available sound
input devices, as illustrated in Figure 22-5.
|
Speaker
Yolume

one —
Alert Sounds

O-NW

BOD

Clink-Klank
Boing
Monkey

{Add...

HP UGBHRS...

Microphones

sia

o
a

| [ Remove |

Ez

HackRecorder

iy

rs

Figure 22-5. The Sound control panel
Devices are listed if their drivers have previously registered themselves with the Sound
Manager and provided a name and device icon. In Figure 22-5, two sound input devices
are available, a device named Built-in and a device named HackRecorder. The user has
selected Built-in. The selected device is the current sound input device.
The new Sound control panel also includes three new buttons, Add, Remove, and Options.
These buttons allow the user to add sounds to and remove sounds from the list of available
system alert sounds and to set any device-specific recording options. The Add button is used
to record a new alert sound and add it to the list. Clicking the Add button causes the Sound
Manager to put up a sound recording dialog box (explained in the next section). Clicking
the Remove button causes the Sound Manager to remove the selected alert sound from the
list. The user can achieve the same effect by selecting a sound and then choosing the Clear
command in the Edit menu. If no sound input drivers are installed in the system, then these
three buttons do not appear.

22-16

Introduction to Sound

The Sound Manager

If the sound recording dialog box was called up by clicking the Add button of the Sound
control panel, then the recorded sound is saved as a resource of type 'snd' in the System file.
That sound then appears in the list of available alert sounds. Note that the standard Edit menu
commands can be used on sounds stored in the System file. The Cut command copies the
selected sound to the Clipboard and removes it from the list of system alert sounds. The
Copy command just copies the selected sound to the Clipboard. The Paste command copies
a sound from the Clipboard and places it in the list of available alert sounds. However, the
Undo command does not work with sound-related editing operations.
The Sound Manager provides two high-level routines that allow your application to record
sounds from the user and store them in memory or in a file. When you call either SndRecord
or SndRecordToFile, the Sound Manager presents a sound recording dialog box to the user,
illustrated in Figure 22-6.

Celi)

Record

0

Stop

Pause

seconds

Play

10

<p
07

(save)

'
tS)
Dn
=
=
a.

Figure 22-6. The sound recording dialog box

<—

Using the controls in this dialog box, the user can start, pause, resume, and stop recording
on the currently selected sound input device. The user can also play back the recorded sound.
The time indicator bar provides an indication of the current length of the recorded sound.
When the user clicks the Save button, another dialog box appears asking the user to give the
sound a name. Unless the user cancels the save operation at that point, the recorded sound is
saved into a file (if SndRecordToFile was called) or into RAM

(if SndRecord was called).

The Sound Manager also provides a set of low-level routines that are of interest to you only
if your application needs to intervene in the normal sound-recording process or if you are
writing a driver to support a sound input device. If you simply want a resource (or a file)
that contains a recorded sound, you can get that most easily by calling SndRecord (or
SndRecordToFile). If you need to modify the features or operation of the sound recording
dialog box, you can usually do so by defining a custom filter procedure.
In instances where you need to gain greater control over the recording process, you can
use a set of routines that manipulate the incoming sound data by using sound parameter
blocks. The parameter blocks contain information about the current recording device, the
length recorded, a routine to call on completion of the recording, and so forth. You can
call SPBRecord (or SPBRecordToFile) to begin a recording. Then you can use the functions SPBPauseRecording, SPBResumeRecording, and SPBStopRecording to control
the recording. Note that you need to open a device (using SPBOpenDevice) before you
can record from it. On completion of the recording, you should close the device (using
SPBCloseDevice).

There are also several routines intended for use by sound input device drivers. Sound input
drivers need to register with the Sound Manager by calling SPBSignInDevice. This makes
that device visible in the Sound control panel for possible selection as the current input
device. You can remove a device from that panel by calling SPBSignOutDevice.

Introduction to Sound

22-17

gs
=
=

ve
@
=

Inside Macintosh,

Volume VI

Two functions—SPBGetDevicelInfo and SPBSetDeviceInfo—allow you to examine and
change certain settings in a sound input device. For example, you can set the recording
quality by passing the appropriate selector code and setting to SPBSetDevicelnfo.

SOUND

STORAGE

FORMATS

The Sound Manager can create and play back sounds stored as sound resources (of format |
‘snd ' resources) and as sound files (of type 'AIFF' or 'AIFC’). In general, your application
should use the available Sound Manager routines to create or play back sounds stored in one
or both of these two ways. The information in this section is important only if you want to
read or write sound data directly (without the assistance of the Sound Manager).

Sound

Resources

The Sound Manager uses two types of resources to help it interpret and play sounds: 'snd '
resources (also called sound resources) and 'snth' resources (also called sound synthe-

sizers). The 'snth' resources are code resources that interpret Sound Manager commands
and data destined for a particular synthesizer. Apple provides 'snth' resources for all three
supported synthesizers, which are contained in the System file. Applications generally do
not need to know anything about 'snth' resources.

Resources of type 'snd ' can contain both sound commands and sound data, and are widely
used by sound-producing applications. These resources provide a simple and portable way
for you to incorporate sounds into your applications. For example, the sounds that a user can
select in the Sound control panel as the system alert sound are stored in the System file as
‘snd ' resources. Unless you use the new sound-recording routines provided by the enhanced
Sound Manager, creating 'snd ' resources requires an understanding of sound synthesis to
build a sampled sound header, wave-table data, or sound commands. You can also use the
SetupSndHeader function to help you create an 'snd ' resource (format 1).
There are two types of 'snd ' resources, known as format | and format 2. Figure 22-7
illustrates the structures of both kinds of 'snd ' resources.

Note: Resource [Ds for 'snd' resources in the range 0 to 8191 are reserved for use
by Apple Computer, Inc. The 'snd' resources numbered | through 4 are defined to
be the standard system alert sounds.
The format | 'snd ' resource is the most general kind of sound resource. A format | 'snd '
resource may contain a specification of the intended output synthesizer, along with a sequence
of Sound Manager commands and associated sound data (such as a sampled sound header or
a wave table). In this case, your application can produce sounds simply by passing a handle
to that resource to the SndPlay function, which loads the specified synthesizer into memory,
opens a sound channel, and sends the commands and data contained in the resource into the

channel. Alternatively, a format | 'snd' may contain a sequence of commands that describe
a sound, without specifying a synthesizer and without providing any other sound data. In
this case, your application can use the SndPlay function to play the sound on any channel.
Accordingly, you can use a format | 'snd' with any one of the available synthesizers.
22-18

Sound Storage Formats

The Sound Manager

These fields may be

absent if "number of

Word

format

synthesizers" is 0

Word

number of synthesizers
first synthesizer

|
Long word

resourceID

Word;

format

init option for synth

Word

reference count

Word

| number of sound commands

8 bytes

first sound command

8 bytes

first sound command

4

4

a

4
8 bytes

Word | number of sound commands

last sound command

8 bytes

Variable

last sound comman

Variable
sound data (optional)

f

(

sound data (optional)

f

boto

7
=
=
2.
2
ee)
=i
geic
~

‘snd ‘ format 1

‘snd ' format 2

—

Figure

22-7.

The

structure of 'snd ' resources

Lew

The format 2 'snd' resource is obsolete and your applications should use format | 'snd '
resources. The format 2 'snd ' resource was designed for use by HyperCard® and can be
used with the sampled sound synthesizer only. A format 2 'snd' resource simply contains
a sound command that points to a sampled sound header.
When a sound command contained in an 'snd' resource has associated sound data, the high
bit of the command is set. This changes the param2 field of the command to an offset value
that specifies the distance in bytes from the resource’s beginning to the location of the
associated sound data. Figure 22-8 illustrates the location of this data offset bit.
<-—Word—» <-Word—»<—- Long

l

Command |

Param

1

word

——>

Param 2

Data offset bit (used by ‘snd ' resource only)

Figure 22-8. The location of the data offset bit
The offset bit is used only by sound commands that are stored in sound resources of type

‘snd ' and that have associated sound data (that is, sampled sound or wave-table data). If the

high bit of the command is set, then param2 is interpreted as an offset in bytes from the
beginning of the sound resource to the associated data.

Sound Storage Formats

22-19

|

Inside Macintosh,

Volume

VI

You can use a constant to set that flag.
CONST

dataOffsetFlag

=

$8000;

{sound

command

data

offset

bit}

If the offset bit is not set, param2 is interpreted instead as a pointer to the location in memory
(outside the sound resource) where the data is located.

To calculate the offset for a format | 'snd ' resource, use the following formula:
offset

= 6 + (number of synthesizers * size of synthesizer information) +
(number of commands * size of command)

For example, if a format | 'snd' resource specifies that a sound channel is to be linked to a
synthesizer and if that resource contains a single sound command (perhaps bufferCmd), then
the offset from the beginning of the resource to the associated sound data is as follows:
offset
= 6 + (1 * 6) + (1 * 8) = 20 bytes
To calculate this offset for a format 2 'snd ' resource, use this formula:
offset = 6 + (number of commands * 8)

The first few bytes of the resource contain 'snd ' header information and are a different size
for each format. A synthesizer specified in a format | 'snd' requires 6 bytes. The number of

synthesizers multiplied by 6 is added to this offset. The number of commands multiplied by
8 bytes, the size of a sound command, is added to the offset.

The

Format

1

'snd

' Resource

Figure 22-7 shows the fields of a format | 'snd ' resource. A format | 'snd ' resource contains information about the format of the resource (namely, 1), the intended output synthesizer,
and the initialization options for that synthesizer. A format | 'snd ' resource may also contain
the actual sound data for the wave-table synthesizer or the sampled sound synthesizer.
If an 'snd ' resource specifies a synthesizer, it can supply an initialization option in the field
immediately following the resource ID. You specify the number of commands in the resource
in the number of sound commands field. The sound commands follow in the order in which
they should be sent to the channel.
The format | 'snd ' resource might contain only a sequence of commands describing a sound
that can be played by any synthesizer. In this case, the number of synthesizers should be 0,
and there should be no synthesizer resource ID or initialization option in the 'snd ' resource.
This allows the 'snd ' to be used on any channel.
Listing 22-1 shows the output of the MPW® tool DeRez when applied to the 'snd ' resource
with resource ID | contained in the System file.

22-20

Sound Storage Formats

The Sound Manager

Listing 22-1.
data

};

'snd

$"00
$"00
$"00
$"00
$"00
$"00
$"00
$"00
$"00
$"00
$"00
$"00
$"00
$"00
$"00

'

01
00
00
00
00
00
00
00
00
00
00
00
00
00
00

(1,

00
00
00
00
00
00
00
00
00
00
00
00
00
00
00

"Simple

01
00
45
00
00
00
00
00
00
00
00
00
00
00
00"

00
00
00
00
00
00
00
00
00
00
00
00
00
00

01
2B
OA
OA
OA
OA
OA
OA
OA
OA
OA
OA
OA
OA

Beep",

00
00
00
00
00
00
00
00
00
00
00
00
00
00

00
EO
28
28
28
28
28
28
28
28
28
28
28
28

A format

| 'snd ' resource

purgeable)

00
00
00
00
00
00
00
00
00
00
00
00
00
00

00
00
00
00
00
00
00
00
OO
00
00
00
00
00

00
00
00
00
00
00
00
00
OD
00
00
00
00
00

{

1B
00
00
00
OO
00
00
O00
O00
O00
00
00
00
00

00
00
00
00
00
00
OO
00
OO
00
00
00
00
00

2c
2A
2B
2B
2B
2B
2B
2B
2B
2B
2B
2B
2B
2B

OO
00
00
00
00
00
00
00
00
00
00
00
00
00

Sa"
OO"
C8"
CO"
B8"
BO"
As"
AO"
90"
80"
60"
40"
20"
O00"
NS)
nN

In Listing 22-1, DeRez simply lists the raw data contained in that resource. To make sense of

this data, see Listing 22-2, which shows the same data restructured and commented.

S

5

=

Listing 22-2. A restructured format | 'snd ' resource
data

'snd

'

(1,

"Simple

Beep",

purgeable)

{

$"0001"
$"0001"
$"0001"

/*format
type*/
/*number
of synthesizers*/
/*resource
ID of square-wave

$"00000000"

/*initialization

S*001B"

/*number

S*002¢c"

/*command

of

sound

=

A
<

synthesizer*/

option*/
commands

1--timbreCmd

that

090

follow

(27)*/

000*/

$"005A00000000"
$"002B"
/*command

2--ampCmd

224

000*/

$"00E000000000"
$"002A"
/*command

3--freqCmd

000

069*/

4--waitCmd

040

000*/

5--ampCmd

200

000*/

$"000000000045"

$"000A"

/*command

$"002800000000"
$"002B"
/*command

$"00C800000000"
/*commands
6 through
26 are omitted;
they are alternating
pairs
/* of waitCmd
and ampCmd commands,
where
the
first
parameter
of
/*

ampCmd

/*

192,

$"002B"

has

184,

the

176,

values

168,

/*command

*/
*/

*/

160,

144,

128,

27--ampCmd

000

96,

64,

and

32*/

000*/

$"000000000000"
+3

As you can see, the Simple Beep is actually a rather sophisticated sound, where the loudness
(or amplitude) of the beep gradually decreases from an initial value of 224 to 0.

Sound Storage Formats

— 22-21

Inside Macintosh,

Volume VI

Notice that the sound described in the previous two listings is played by the square-wave
synthesizer and is completely determined by a sequence of specific commands. (“Play an A
at loudness 224, wait 20 milliseconds, play it at loudness 200....”) Often an 'snd ' resource
consists only of a single sound command (usually the bufferCmd command) together with —
data that describes a sampled sound to be played. Listing 22-3 illustrates an example like this;
once again, the output of DeRez has been restructured and commented to improve readability.
Listing 22-3. A format | 'snd ' resource containing sampled sound data
data

'snd
$"0001"
"0001"
$"0005"

'

(19068,

$"00000080"

/*initialization

$"0001"

/*number

of

sound

$"0000"
$"00000014"

/*paraml
/*param2

=
=

0*/
offset

$"8051"

/*command

$"00000000"
$"00000BB8"
$"56EE8BA3"
$"000007D0"
$"00000898"

di

"hello daddy",
purgeable)
{
/*format
type*/
/*number
of synthesizers*/
/*resource
ID of first
synthesizer*/

option:

commands

initMono*/

1--bufferCmd*/
to

sound

that

sampled
80 81 81
83 82 82
7C 7D 7D
83 82 81
80 81 81

S$"7F

7F

7E

7F

(20

bytes)

header

/*standard
sample
encoding*/
/*baseFrequency
at which
sample
sound data*/
81 81 81 81 80 80 80 80 80 81 82
81 80 80 7F 7F 7F 7E 7D 7D 7D 7C
7D 7D 7E 7F 80 80 81 81 82 82 83
81 80 80 81 81 81 81 81 82 81 81
81 83 83 83 82 81 81 80 7F 7E 7D

of

(1)*/

/*pointer to data
(it follows immediately)*/
/*number of bytes in sample
(3000 bytes)
*/
/*sampling rate of this sound
(22 kHz) */
/*starting of the sample's loop point*/
/*ending of the sample's loop point*/

$"00"
Stace"
/*the
$"80
$"82
$"7C
$"83
$"80

/*rest

follow

7F

data

7F

7F

7F

omitted

7F

in

this

7F

7F

7F

7F

7F

7F

was

*/

taken*/

82"
7C"
83"
80"
7D"
80"

example*/

This 'snd ' resource specifies the sampled sound synthesizer and includes a call to a single

sound command, the bufferCmd command. The offset bit of the command number is set to

indicate that the sound data is contained in the resource itself. Following that command and
its two parameters is the sampled sound header, the first part of which contains important
information about the sample. The second parameter to the bufferCmd command indicates the

offset from the beginning of the resource to the sampled sound header, in this case 20 bytes.

It is not always necessary to specify 'snd ' resources by listing the raw data stream contained
in them; indeed, for certain types of format | 'snd ' resources, it can be easier to supply a
resource specification like the one given in Listing 22-4.
Listing 22-4.
resource
'snd
'
FormatOne
{

{

/*array

ha) We

(9000,

},

22-22

Beep",

Synthesizers:

squareWaveSynth,

}

"New

0

Sound Storage Formats

A resource specification

1

purgeable)

element*/

{

The Sound Manager

{

/*

[1])*/

/* [2]*/
[3]*/

/*

{

be

},

/*array

noData,

noData,
noData,
/*array

SoundCmnds:

3

timbreCmd

elements*/

{90},

freqDurationCmd
quietCmd
{},
0

DataTables:

{480,

$00000045},

elements*/

};

When you pass a handle to this resource to the SndPlay function, three commands are executed
by the square-wave synthesizer: a timbreCmd command, a freqDurationCmd command, and a
quietCmd command. The sound specified in Listing 22-4 is just like the Simple Beep, except
that there is no gradual reduction in the loudness. To duplicate the Simple Beep exactly, you
could use the resource specification given in Listing 22-5.
Listing 22-5. Resource specification for the Simple Beep
resource
‘snd
'
FormatOne
{
{
/*array

},
{

}

(9001,

"Copy

of

Synthesizers:

Y odll TE Fal eae
squareWaveSynth,

Simple
1

mnoData,

noData,

waitCmd

freqCmd

{69},

/*(5)*/

noData,

ampCmd

{200},

/*([7]*/

mnoData,

ampCmd

{192},

/*(6]*/

/*(8]*/
/*[9]*/

/*[(10]*/
/*{11)]*/
/*(12]*/
/*[{13]*/

/*[14]*/
/*[15]*/

/*[(16]*/
/*({17]*/
/*[(18]*/
/*({19]*/
/*[20]*/
/*({21)*/
/*[22]*/
/*[23]*/
/*(24]*/
/*([25]*/

/*[26]*/

=
&

{40},

waitCmd {40},
ampCmd {184},

noData,
noData,

waitCmd {40},
ampCmd {160},

noData,

2

timbreCmd {90},
ampCmd {224},

noData,
noData,

noData,

<

elements*/

waitCmd

noData,
noData,
noData,
noData,
noData,
noData,
noData,
noData,
noData,
noData,

2
=

{40},

waitCmd
{40},
ampCmd
{176},
waitCmd
{40},
ampCmd
{168},

waitCmd
ampCmd
waitCmd
ampCmd
waitCmd
ampCmd
waitCmd
ampCmd
waitCmd
ampCmd

{40},
{144},
{40},
{128},
{40},
{96},
{40},
{64},
{40},
{32},

ampCmd

{0}

waitCmd

{40},

/*array

DataTables:

0

elements*/

SS

pee

ee

/*(27]*/

27

noData,

noData,
noData,
noData,
noData,

te

2.

/*[3])*/

/*({4]*/

{

0

SoundCmnds:

noData,
noData,

purgeable)

element*/

/*array

/*({1])*/
/*(2]*/

Beep",

Sound Storage Formats

— 22-23

Inside Macintosh,

Volume

The

2 'snd

Format

VI

' Resource

The SndPlay function can also play format 2 'snd' resources, which are designed for use
only with the sampled sound synthesizer. The SndPlay function supports this format by
automatically opening a channel to the sampled sound synthesizer and using the bufferCmd
command to send the data contained in the resource to that synthesizer.
Figure 22-7 illustrates the fields of a format 2 'snd' resource. The reference count field
is for your application’s use and is not used by the Sound Manager. The number of sound
commands field and the sound command fields are the same as described in a format |
resource. The last field of this resource contains the sampled sound. The first command
should be either a soundCmd command or bufferCmd command with the data offset bit
set in the command to specify the location of this sampled sound header.

Listing 22-6 shows a resource specification that illustrates the structure of a format 2 'snd'
resource; it contains the information necessary to create a sound with SndPlay and the
sampled sound synthesizer.
Listing 22-6.
data

'snd

'

(9003,

"Pig

Squeal",

$"0002"

/*format

$"0000"
$"0001"

/*reference
/*number
of

S*sosi

"

A format 2 ‘snd ' resource
purgeable)

{

type*/

/*command

count
sound

for application's
use*/
commands
that
follow
(1)*/

1--bufferCmd* /

$"0000"

/*paraml

=

0*/

S"O0000000E"

/*param2

=

offset

$"00000000"
$"00000BB8"

/*pointer
to data
/*number
of bytes

$"56EE8BA3"

/*sampling

rate

$"000007D0"

/*starting

of

$"00000898"
s*00"

/*ending
of the sample's
loop
/*standard
sample
encoding*/

oo
$"80
S"6F

80
68

81
6D

82
65

$"91
S"6F
$"89

8E
6D
8F

8D
71
8D

8F 86 7E 7C 79"
70 70 79 7F 81"
8B" /*rest of data

to

of
the

sound

header

(14

bytes)
*/

(it
follows
immediately)
*/
in sample
(3000 bytes)
*/

this

sound

sample's

(22

loop

point*/

/*baseFrequency
at which
sample
84 87 93 84"
/*the sampled
sound
72 7B 82 88"

omitted

in

this

kHz) */

point*/

was
taken*/
data*/

example*/

};

For a complete explanation of the fields following the sampling rate field, see the description
of the sampled sound header in “Playing Sampled Sounds.” To play the sounds described by
these resources, see the instructions given in “Playing 'snd ' Resources.” Both sections occur
later in this chapter.

Sound

Files

Although most sampled sounds that you want your application to produce can be stored as
resources of type 'snd ', there are times when it is preferable to store sounds in sound
files, not in resources. For example, it is usually easier for different applications to share
22-24

Sound Storage Formats

The Sound Manager

files than it is to share resources. So if you want your application to play sampled sounds
created by other applications (or if you want other applications to be able to play sampled
sounds created by your application), it might be better to store the sampled sound data in a
file, not in a resource. Similarly, if you are developing versions of your application that are
intended to run on other operating systems, you might need a method of storing sounds that
is independent of the Macintosh Operating System and its reliance on resources to store data.
Generally, it is easier to transfer data stored in files from one operating system to another
than it is to transfer data stored in resources.
There are other reasons you might want to store some sampled sounds in files and not in
resources. If you have a very large sampled sound, it may be impossible to create a resource
large enough to hold all the audio data. Resources are limited in size by the structure of

resource files (and in particular because offsets to resource data are stored as 24-bit quantities).

Sound files, however, can be much larger because the only size limitations are those imposed
by the file system on all files. If the sampled data for some sound occupies more than about
a half megabyte of space, you should probably store the sound as a file.
To address these various needs, Apple and several third-party developers have defined two
sampled sound file formats, known

as the Audio

Interchange

File Format

(AIFF) and

the Audio Interchange File Format extension for Compression (AIFF-C). The names emphasize
that the formats are designed primarily as data interchange formats. However, you should find
both AIFF and AIFF-C flexible enough to use as data storage formats as well. Even if you
choose to use a different storage format, your application should be able to convert to and from
AIFF and AIFF-C if you want to facilitate sharing of sound data among applications.
The main difference between the AIFF and AIFF-C formats is that AIFF-C allows you to
store both compressed and noncompressed audio data, whereas AIFF allows you to store
noncompressed audio data only. The AIFF-C format is more general than the AIFF format
and is easier to modify. The AIFF-C format can be extended to handle new compression types
and application-specific data. As a result, you should revise any application that currently
supports only AIFF files to also support AIFF-C files. An application that currently reads
AIFF files should also be able to read AIFF-C files. An application that currently writes AIFF
files should also be able to write AIFF-C files. It is recommended that the default write format
be AIFF-C. Table 22-2 summarizes the capabilities of the AIFF and AIFF-C file formats.
Table

22-2.

AIFF and AIFF-C capabilities

File
type

Read
sampled

Read
compressed

Write
sampled

Write
compressed

AIFF
AIFF-C

16
Yes

No
yes

Yes
Yes

No
Yes

The enhanced Sound Manager includes support for reading and writing both AIFF and AIFF-C
files. You can play from disk a sampled sound stored in a file of type AIFF or type AIFF-C by
opening that file and passing its file reference number to the SndStartFilePlay function. (If the
file is of type AIFF-C and if the data is compressed, the data is automatically expanded during
playback.) You can create files of type AIFF or AIFF-C by calling the SndRecordToFile and
SPBRecordToFile functions. SndRecordToFile creates an AIFF or AIFF-C file, complete
with compressed sound data and all the needed chunks. SPBRecordToFile, however, simply
records audio data (compressing it if necessary) and saves that data into a specified file.
SPBRecordToFile does not create any AIFF or AIFF-C chunks. You can, however, use the
SetupAIFFHeader function to create the appropriate headers before you call SPBRecordToFile.
Sound Storage Formats

— 22-25

i
N
Lf

=
5
o.
=
£9
=
fo
i
o
—

Leer |

Inside Macintosh,

Volume

VI

Note: Both SndRecordToFile and SPBRecordToFile automatically compress the
recorded audio data if instructed to do so. Neither function does any expansion.
The following six sections describe in detail the structure of AIFF and AIFF-C files. Both
of these types of sound files are collections of “chunks” that define characteristics of the
sampled sound or other relevant data about the sound. Currently, the AIFF and AIFF-C
specifications include the following chunk types.
Chunk

types

Form Chunk

Contains all the other chunks of an AIFF or AIFF-C file

Format Version Chunk

Contains an indication of the version of the AIFF-C

Common Chunk

Contains information about the sampled sound, such as the
sampling rate and sample size

Sound Data Chunk

Contains the sample frames that comprise the sampled sound

Marker Chunk

Contains markers that point to positions in the sound data

Comments Chunk

Contains comments about markers in the file

Sound Accelerator Chunk

Contains information intended to allow applications to
accelerate the decompression of compressed audio data

Instrument Chunk

Defines basic parameters that an instrument (such as a
sampling keyboard) can use to play back the sound data

MIDI Data Chunk

Contains MIDI data

Audio Recording Chunk

Contains information pertaining to audio recording devices

Application Specific Chunk

Contains application-specific information

Name Chunk

Contains the name of the sampled sound

Author Chunk

Contains one or more names of the authors (or creators) of the

Copyright Chunk

Contains a copyright notice for the sampled sound

Annotation Chunk

Contains a comment

specification according to which this file is structured
(AIFF-C only)

sampled sound

The following sections document only four of the kinds of chunks that can occur in AIFF and
AIFF-C files. A more complete specification of AIFF files is available from APDA.

Chunk

Organization

and

Data

Types

An AIFF or AIFF-C file is a file that is organized as a collection of “chunks” of data. For
example, there is a Common Chunk that specifies important parameters of the sampled
sound, such as its size and sample rate. There is also a Sound Data Chunk that contains the

22-26

Sound Storage Formats

The Sound Manager

actual audio samples. A chunk consists of some header information followed by some data.
The header information consists of a chunk ID number and a number that indicates the size of
the chunk data. In general, therefore, a chunk has the structure illustrated in Figure 22-9.
ckID
:
ckSize

+ header info
<

data

-data bytes

Figure 22-9. The general structure of a chunk
The header information of a chunk has this structure:
~
tN
TYPE

ChunkHeader

RECORD
END;

=

L

ckID:

ID;

{chunk

type

ID}

ckSize:

LongInt

{number

of

bytes

=

=
of

data}

=

5

FormID

'FORM';

{chunk

ID

for

Form

'FVER';

{chunk

ID

for

Format

Version

=

'COMM';

{chunk

ID

for

Common

Chunk}

'SSND';

{chunk

ID

for

Sound

Data

WW

CONST

i

The ckID field specifies the chunk type. An ID is a 32-bit concatenation of any four printable
ASCII characters in the range '' (space character, ASCII value $20) through '~' (ASCII
value $7E). Spaces cannot precede printing characters, but trailing spaces are allowed.
Control characters are not allowed. You can specify values for the four types of chunks
described later by using these constants:

FormatVersionID
CommonID
SoundDataID

Chunk}
Chunk}

Chunk}

The ckSize field specifies the size of the data portion of a chunk and does not include the
length of the chunk header information.

The

Form

Chunk

The chunks that define the characteristics of a sampled sound and that contain the actual
sound data are grouped together into a container chunk, known as the Form Chunk.
The Form Chunk defines the type and size of the file and holds all remaining chunks in
the file. The chunk ID for this container chunk is 'FORM',

Sound Storage Formats

— 22-27

re@

Lr

Inside Macintosh,

Volume VI

A chunk of type 'FORM' has this structure:
TYPE

ContainerChunk

=

RECORD
ckID:

LD

{'FORM' }

ckSize:

LongInt;

{number

formType:

ID

{type

of
of

bytes

of

data}

file}

END;

The fields of this chunk have the following meanings:
Field

descriptions

ckID

The ID of this chunk. For a Form Chunk, this ID is 'FORM('.

ckSize

The size of the data portion of this chunk. Note that the data portion of a
Form Chunk is divided into two parts, formType and the chunks that
follow the formType field. These chunks are called /ocal chunks because
their chunk IDs are local to the Form Chunk.

formType

The type of audio file. For AIFF files, formType is ‘AIFF’. For AIFF-C
files, formType is 'AIFC’.

The local chunks can occur in any order in a sound file. As a result, your application should
be designed to get a local chunk, identify it, and then process it without making any assumptions about what kind of chunk it is based on its order in the Form Chunk.

The

Format

Version

Chunk

One difference between the AIFF and AIFF-C file formats is that files of type AIFF-C
contain a Format Version Chunk and files of type AIFF do not. The Format Version Chunk

contains a timestamp field that indicates when the format version of this AIFF-C file was
defined. This in turn indicates what format rules this file conforms to and allows you to
ensure that your application can handle a particular AIFF-C file. Every AIFF-C file must
contain one and only one Format Version Chunk.
In AIFF files, there is no Format Version Chunk.
In AIFF-C files,
TYPE

a Format Version Chunk has this structure:

FormatVersionChunk

=

RECORD
ckID:

LD;

ckSize:

Longint;

{4}

timestamp:

Longint

{date

END;

22-28

Sound Storage Formats

{'FVER' }

of

format

version}

The Sound Manager

The fields of this chunk have the following meanings:
Field

descriptions

ckID

The ID of this chunk. For a Format Version Chunk, this ID is 'FVER'.

ckSize

The size of the data portion of this chunk. This value is always 4 in a
Format Version Chunk because the timestamp field is 4 bytes long (the
8 bytes used by ckID and ckSize fields are not included).

timestamp

An indication of when the format version for this kind of file was
created. The value indicates the number of seconds since January 1,
1904, following the normal time conventions used by the Macintosh
Operating System. (See the Operating System Utilities chapter of
Volume II for several routines that allow you to manipulate timestamps.)

You should not confuse the format version timestamp with the creation date of the file. The
format version timestamp indicates the time of creation of the version of the format according
to which this file is structured. Because Apple defines the formats of AIFF-C files, only
Apple can change this value. The current version is defined by a constant:

nN
i)
ve
=

CONST

The

AIFCVersionl

Common

=

$A2805140;

{2726318400

in

i)
=

decimal}

<

iS
=
)
ge
i)
la

Chunk

Every AIFF and AIFF-C file must contain a Common Chunk that defines some fundamental
characteristics of the sampled sound contained in the file. Note that the format of the Common
Chunk is different for AIFF and AIFF-C files. As a result, you need to determine the type

of file format (by inspecting the formType field of the Form Chunk) before reading the
Common Chunk.
For AIFF files, the Common Chunk has this structure:
TYPE

CommonChunk

=

RECORD
ckID:

ID;

{'COMM' }

ckSize:

LongInt;

{size

numChannels:
numSampleFrames:

Integer;
LongInt;

{number
{number

of
of

channels}
sample
frames}

sampleSize:

Integer;

{number

of

bits

sampleRate:

Extended

{number

of

frames

of

chunk

data}

per

sample}

per

second}

END;

For AIFF-C files, the Common
TYPE

ExtCommonChunk

Chunk has this structure:

=

RECORD
ckID:

ED:

{ 'COMM' }

ckSize:

LongIint;

{size

of

chunk

data}

Sound Storage Formats

— 22-29

Inside Macintosh, Volume VI

numChannels:

Integer;

{number

of

numSampleFrames:

LongInt;

{number

of

channels}
sample

sampleSize:

Integer;

{number

of

bits

sampleRate:

Extended;

{number

of

frames

per

compressionType:

ID;

{compression

type

ID}

compressionName:

PACKED

frames}
per

ARRAY[0..0]
OF Byte
{compression
type

sample}
second}

name}

END;

The fields that exist in both types of Common Chunk have the following meanings:
Field

descriptions

ckID

The ID of this chunk. For

a Common

Chunk, this ID is 'COMM',

ckSize

The size of the data portion of this chunk. In AIFF files, this field is
always 18 in the Common Chunk because the 8 bytes used by the
ckID and ckSize fields are not included. In AIFF-C files, this size is
22 plus the number of bytes in the compressionName string.

numChannels

The number of audio channels contained in the sampled sound. A
value of | indicates monophonic sound; a value of 2 indicates stereo
sound; a value of 4 indicates four-channel sound, and so forth. Any
number of audio channels may be specified. The actual sound data is
stored elsewhere, in the Sound Data Chunk.

numSampleFrames

The number of sample frames in the Sound Data Chunk. Note that
this field contains the number of sample frames, not the number of
bytes of data and not the number of sample points. For noncompressed
sound data, the total number of sample points in the file is
numChannels * numSampleFrames. (See the discussion of the
Sound Data Chunk in the following section for a definition of a
sample frame.)

sampleSize

The number of bits in each sample point of noncompressed sound
data. The sampleSize field can contain any integer from | to 32. For
compressed sound data, this field indicates the number of bits per
sample in the original sound data, before compression.

sampleRate

The sample rate at which the sound is to be played back, in sample
frames per second.

An AIFF-C Common Chunk includes two fields that describe the type of compression (if
any) used on the audio data:
Field

descriptions

compressionType

The ID of the compression algorithm, if any, used on the sound data.

compressionName

A human-readable name for the compression algorithm ID specified in
the compressionType field. This string is useful when putting up alert
boxes (perhaps because a necessary decompression routine is missing).

22-30

Sound Storage Formats

The Sound Manager

Remember to pad the end of this array with a byte having the value 0 if
the length of this array is not an even number (but do not include the
pad byte in the count).
Here are the currently available compression IDs and their associated compression names:
compressionType
'NONE'

'ACE2'

compressionName

Description

‘not compressed’

Noncompressed samples

'ACE 8-to-3'
"MACE 3-to-1'
"MACE 6-to-1'

IIGS 8-to-3 compressed
Macintosh 3-to-1 compressed
Macintosh 6-to-1 compressed

'ACE 2-to-1'

"ACE8'
'MAC3'
'MAC6'

IIGs® 2-to-1 compressed

You can define your own compression types, but you should register them with Apple.

The

Sound

Data

Chunk

)
ss)

The Sound Data Chunk contains the actual sample frames that make up the sampled
sound. The Sound Data Chunk has this structure:
TYPE

SoundDataChunk

Wn
=
=

<

=

S

RECORD

a

ckID:

1i B

{'SSND'

ckSize:

LongIint;

{size

offset:

LongInt;

{offset

blockSize:

LongInt

{size

}

e

of

chunk
to

of

data}

sound

alignment

data}
blocks}

END;

The fields in a Sound Data Chunk have the following meanings:
Field

descriptions

ckID

The ID of this chunk. For a Sound Data Chunk, this ID is 'SSND'.

ckSize

The size of the data portion of this chunk. This size does not include
the 8 bytes occupied by the values in the ckID and the ckSize fields. If
the data following the blockSize field contains an odd number of
bytes, a pad byte with a value of 0 is added at the end to preserve an
even length for this chunk. If there is a pad byte, it is not included in
the ckSize field.

offset

An offset (in bytes) to the beginning of the first sample frame in the
chunk data. Most applications do not need to use the offset field and
should set it to 0.

blockSize

The size (in bytes) of the blocks to which the sound data is aligned.
This field is used in conjunction with the offset field for aligning
sound data to blocks. As with the offset field, most applications do not
need to use the blockSize field and should set it to 0.

Sound Storage Formats

— 22-31

Inside Macintosh,

Volume

VI

The format of the sound data following the blockSize field depends on whether the data is
ype
compressed or noncompressed, which you can determine by inspecting the compressionT
field in the Common Chunk. If the compression type is 'NONE'’, then each sample point in a
sample frame is a linear, two’s complement value. Sample points are from | to 32 bits wide, as
determined by the sampleSize parameter in the Common Chunk. Each sample point is stored in
an integral number of contiguous bytes. Sample points that are from | to 8 bits wide are stored
in | byte; sample points that are from 9 to 16 bits wide are stored in 2 bytes, and so forth.
When the width of a sample point is less than a multiple of 8 bits, the sample point data is left
aligned (using a shift-left instruction), and the low-order bits at the right end are set to 0.
For multichannel sounds, a sample frame is an interleaved set of sample points. (For monophonic sounds, a sample frame is just a single sample point.) The sample points within a
sample frame are interleaved by channel number. For example, the sound data for a stereo,
noncompressed sound is illustrated in Figure 22-10.
Sample

Sample

frame 0
I[ en

Sample

frame 1

ch 2

ch 1

cn

frame n
|

chi}

ch2

= One sample point

Figure

22-10.

Interleaving stereo sample points

Sample frames are stored contiguously in order of increasing time. There are no pad bytes
between samples or between sample frames.
Note: The Sound Data Chunk is required unless the numSampleFrames field in
the Common Chunk is 0. A maximum of one Sound Data Chunk can appear in an
AIFF or AIFF-C file.

Reading

and Writing Sound

Files

Figure 22-11 illustrates an AIFF-C format file that contains approximately 4.476 seconds of
8-bit monophonic sound data sampled at 22 kHz. The sound data is not compressed. Note
that the number of sample frames in this example is odd, forcing a pad byte to be inserted
after the sound data. This pad byte is not reflected in the ckSize field of the Sound Data
Chunk, which means that special processing is required to correctly determine the actual
chunk size.
On a Macintosh computer, the Form Chunk (and hence all the other chunks in an AIFF or
AIFF-C file) is stored in the data fork of the file. The file type of an AIFF format file is
‘AIFF’ and the file type of an AIFF-C format file is 'AIFC'. Macintosh applications should
not store any information in the resource fork of an AIFF or AIFF-C file because that information might not be preserved by other applications that edit sound files.

22-32

Sound Storage Formats

The Sound Manager

FORM AIFC file

ckID 7]

ckSize

||

formType

Format

ckSize

SUES

|

99690

f{ Al | [FE [Cc]

cKID #|

Version

FLO[RIM

F[V JE [R |

J]

4

14

timestamp } [ 2726318400_|

Common

Chunk

“

kID

Leo

|

38

1M

IM |

numSampleFrames J |

99611

‘|

ckSize

numChannels
sampleSize
sampleRate § |

compressionType
compressionName
Sound

Shunk

Data

kID

ckSize

offset
blockSize

sound data
padbyte

Figure

J[ N] O|N[E |
}{i4|n]o|t|
LS[S|N[D

J]

99619

|
}|

0
0

[0 |

Se
-

22-11.

22254.54

|

|clolm]

p[rle[s|sle[d]o]

|

si
|
|

ga

=v2

E
Se

ee
,

sample frames

=
=~

oe

a®

99611th

=

A sample AIFF-C file

Every Form Chunk must contain a Common Chunk and every AIFF-C file must contain a
Format Version Chunk. In addition, if the sampled sound has a length greater than 0, there
must be a Sound Data Chunk in the Form Chunk. All other chunk types are optional. Your
application should be able to read all the required chunks if it uses AIFF or AIFF-C files,
but it can choose to ignore any of the optional chunks.
When reading or writing AIFF or AIFF-C files, you should keep the following points
in mind:
= Remember that the local chunks in an AIFF or AIFF-C file can occur in any order. An
application that reads these types of files should be designed to get a chunk, identify it,
and then process it without making any assumptions about what kind of chunk it is
based on its order in the Form Chunk.
a If your application allows modification of a chunk, then it must also update other
chunks that may be based on the modified chunk. However, if there are chunks in the
file that your application does not recognize, you must discard those unrecognized
chunks. Of course, if your application is simply copying the AIFF or AIFF-C file
without any modification, you should copy the unrecognized chunks, too.

Sound Storage Formats

— 22-33

Inside Macintosh,

Volume

V1

= You can get the clearest indication of the number of sample frames contained in an AIFF
or AIFF-C file from the numSampleFrames parameter in the Common Chunk, not from
the ckSize parameter in the Sound Data Chunk. The ckSize parameter is padded to
include the fields that follow it, but it does not include the byte with a value of 0 at the

end if the total number of sound data bytes is odd.

= Remember that each chunk must contain an even number of bytes. Chunks whose total
contents would yield an odd number of bytes must have a pad byte with a value of 0
added at the end of the chunk. This pad byte is not included in the ckSize parameter.
= Remember that the ckSize parameter of any chunk does not include the first 8 bytes of
the chunk (which specify the chunk type).

USING

THE

SOUND

MANAGER

The Sound Manager provides a wide range of methods for creating sound and manipulating
audio data on the Macintosh. Usually, your application needs to use only a few of the many
routines or sound commands that are available. You can also use Sound Manager routines to
record sounds through any available sound input hardware.
The Sound Manager routines can be divided into high-level routines and low-level routines.
The high-level routines (like SndRecord, SndPlay, and SysBeep) give you the ability to
produce very complex audio output at very little programming expense. The next section
shows how your application can produce sounds simply by obtaining a handle to an existing ‘snd ' resource and passing that handle to the SndPlay function. Moreover, if the data
in the 'snd' resource is stored in a compressed format, SndPlay automatically expands it
for play-back in real time without further intervention from your application.
Although the high-level Sound Manager routines are sufficient for many applications, lowlevel Sound Manager routines are available to provide your application with much greater
control over sound recording and production than is provided by the high-level routines.
Using these low-level routines, your application can record directly from sound input
devices, allocate and release sound channels, queue sound commands to a channel or
bypass a sound queue altogether, perform modifications on sound data and commands
sent into a channel, create and mix multiple channels of sound, compress and expand audio
data, disable and enable the system alert sound, obtain information about current sound
activity, and play sounds continuously from disk.
Some of these operations are carried out by specialized low-level routines, but most of
them are accomplished by passing appropriate sound commands to the SndDoCommand,
SndDoImmediate, and SndControl functions. For example, your application can alter the
pitch of a sampled sound that is currently playing by calling SndDoImmediate with the
rateCmd command as one of its parameters.
Some of the Sound Manager routines and commands cannot be called at interrupt time because
they attempt to allocate or release memory. In particular, the routines SndNewChannel,
SndDisposeChannel, SndAddModifier, SysBeep, SndPlay, SndStartFilePlay, SndRecord,
and SndRecordToFile cannot be called at interrupt time. In addition, callback procedures,

22-34

Using the Sound Manager

The Sound Manager

specified in calls to SndNewChannel and SndStartFilePlay, and doubleback routines, specified in calls to SndPlayDoubleBuffer, are executed at interrupt time and therefore must not
allocate, release, or move memory. You can safely call all other Sound Manager routines at
interrupt time.

Playing

‘snd ' Resources

Perhaps the simplest Sound Manager routine is SndPlay, which requires nothing more than a
handle to an existing 'snd ' resource. An 'snd ' resource contains the information necessary
for the Sound Manager to create a channel linked to the required synthesizer, together with the
sound commands that are to be sent to that synthesizer to play the desired sound. The ‘snd '
resource may or may not contain sound data. If it does, as in the case of a sampled sound, that
data can be either compressed or uncompressed. As long as the resource is created correctly,
SndPlay will play it. Listing 22-7 illustrates how to play back an 'snd ' resource.
Listing
PROCEDURE

CONST

kAsync

mySndID

22-7.

Playing an 'snd ' resource with SndPlay

CallSndPlay;

iS

= TRUE;
=

{play

9000;

is

{resource

DL

asynchronous}
ID

of

an

'snd

<

'}

=

VAR

=
mySndHandle:

Handle;

{handle

to

my SndChan:

SndChannelPtr;

{pointer

myErr:

OSErr;

an

'snd

a

sound

to

'

resource}

S

channel}

te
=

BEGIN

mySndChan
:= NIL;
mySndHandle
:= GetResource
IF

mySndHandle

BEGIN
myErr
:=
IF myErr

<>

NIL

SndPlay
<> noErr

THEN

('snd

',

{check

mySndID);
for

a

(mySndChan,
mySndHandle,
THEN
DoError (myErr) ;

NIL

handle}

kAsync) ;

END;
END;

When your application uses SndPlay and passes NIL as the pointer to a sound channel, it
does not need to concern itself with any memory allocation or deallocation. The Sound
Manager automatically opens a sound channel (in the application’s heap) and then closes
it when the sound is completed.
For more complete control of the sound channel, your application can open a sound channel
by using SndNewChannel. The application then sends commands to that channel with
SndDoCommand or SndDoImmediate. When the sound is completed, your application closes
the channel with SndDisposeChannel. Listing 22-8 shows how your application can use lowlevel Sound Manager routines in the simple case of calling the sampled sound synthesizer to
play back a buffer of sampled sound. The buffer can be either compressed or uncompressed.
This example assumes that the sampled sound is uncompressed and that the sound header
whose address is passed as an argument has already been filled out correctly.

Using the Sound Manager

— 22-35

Inside Macintosh, Volume VI

22-8.

Listing
PROCEDURE

Using low-level Sound Manager routines
SoundHeaderPtr);

DoBufferCmd(mySHPtr:

VAR

{a

:=

mySndChan

bufferCmd;
:= 0;

mySndCmd.param2

:=

<>

noErr

THEN

bufferCmd

in

the

sampledSynth,

sound

{dispose

of

SndDisposeChannel

IF

myErr

<>

noErr

THEN

SoundHeader }

initMono,

NIL);

channel}

myErr

channel

here}
to

DoError(myErr) ;

SndDoCommand(mySndChan,
mySndCmd,
<> noErr THEN DoError(myErr) ;

the

used

{pointer

myErr
:=
IF myErr

:=

channel}

command}

sound

{not

ORD4(mySHPtr) ;

{allocate
a sound channel}
myErr
:= SndNewChannel (mySndChan,

{queue

sound

channel}
{Sound Mgr allocates
is bufferCmd}
{the command

NIL;

:=
mySndCmd.cmd
mySndCmd.paraml

myErr

a

OSErr;

BEGIN

IF

to

{pointer

SndChannelPtr;
SndCommand;

mySndChan:
my SndCmd:
myErr:

when

FALSE) ;

finished}

(mySndChan,

FALSE) ;

DoError(myErr) ;

END;

The Sound Manager functions used in Listing 22-8 (SndNewChannel, SndDoCommand, and
SndDisposeChannel) are explained in detail in the following sections. Note that the procedure
does not do proper error handling; it is intended primarily to illustrate the proper order in
which you should call the low-level Sound Manager routines.

Allocating

Sound

Channels

To use most of the low-level Sound Manager routines, you must specify a sound channel that
maintains a queue of commands destined for a particular synthesizer. Generally you do not
need to worry about allocating memory for sound channels because the SndNewChannel
function automatically allocates a sound-channel record in the application’s heap if passed a
pointer to a NIL sound channel. For example, the following lines of code request that the
Sound Manager open a new sound channel and link it to the sampled sound synthesizer:
mySndChan
myErr

:=

:=

NIL;

SndNewChannel

(mySndChan,

sampledSynth,

0,

NIL);

If you are concerned with memory management, you can allocate your own channel memory
and pass the address of that memory as the first parameter to SndNewChannel. Listing 22-9
illustrates one way to do this.

22-36

Using the Sound Manager

The Sound Manager

Listing
FUNCTION

CreateSndChannel

22-9.
:

Creating a sound channel

SndChannelPtr;

VAR

mySndChan:

SndChannelPtr;
OSErr;

myErr:
BEGIN
{allocate

a

mySndChan
:=
IF mySndChan

sound

{pointer

to

a

sound

channel}

channel}

SndChannelPtr(NewPtrClear
<> NIL THEN

(Sizeof(SndChannel)));

BEGIN

mySndChan*.qLength
myErr

:=

:=

stdQLength;

SndNewChannel

(mySndChan,

{128

sound

sampledSynth,

commands}
initMono,

NIL);

END;

CreateSndChannel

:=

mySndChan;

{return

SndChannelPtr}

END;

Note that if you allocate your own channel memory, you must set the size of the sound

channel (the number of sound commands that the channel can store). You should set the size

by assigning a value to the qLength field of the sound channel you allocate. You can use the
constant stdQLength, as illustrated in Listing 22-9, or provide a value of your own.

i)

nN
WN

S
=
=|
Ce

an

CONST

stdQLength

=

128;

{default

size

of

standard

sound

channel}

Note: The number of sound commands in a channel should be an integer greater
than Q. If you open a channel with a 0-length queue, most of the Sound Manager
routines will return a badChannel result code.
The second parameter in the SndNewChannel function is the resource ID of the playback synthesizer that is to be linked to the new sound channel. Currently recognized
playback synthesizer values are
CONST

squareWaveSynth

=

1;

{square-wave

waveTableSynth

=

BF

{wave-table

sampledSynth

=

5

{sampled

synthesizer}

synthesizer}

sound

synthesizer}

The third parameter in the SndNewChannel function specifies the initialization parameters to
be associated with the new channel. These are discussed in the following section. The fourth
parameter in the SndNewChannel function is a pointer to a callback procedure. If your application produces sounds asynchronously or needs to be alerted when a command has
completed, you can specify a callback procedure by passing the address of that procedure
in the fourth parameter. If you pass NIL as the fourth parameter, then no callback routine
executes. See “Specifying Callback Routines” later in this chapter for more information on
setting up and using callback procedures.

Using the Sound Manager

— 22-37

irot
mS
=
eo)
i)
iS)

Inside Macintosh,

Initializing

Volume VI

Sound

Channels

When you first create a sound channel with SndNewChannel, you can request that the channel
have certain characteristics as specified by a sound-channel initialization parameter.
For example, to indicate that you want to allocate a channel capable of producing stereo sound,
you might use the following code:
myErr

:=

SndNewChannel

(mySndChan,

sampledSynth,

NIL);

initStereo,

These are the currently recognized constants for the sound-channel initialization parameter.
CONST

initChanLeft

=

$0002;

{left

initChanRight

=

$0003;

{right

channel--sampledSynth

only}

initChan0

=

$0004;

{channel

1--wave

table

only}

initChanl

=

$0005;

{channel

2--wave

table

only}

initChan2
initChan3

=
=

$0006;
$0007;

{channel
{channel

3--wave
4--wave

table
table

only}
only}

initMono

=

$0080;

{mono

initStereo

=

$00C0;

{stereo

initMACE3

=

$0300;

{3:1

compression--sampledSynth

only}

initMACE6

=

$0400;

{6:1

comopression--sampledSynth

only}

initNoInterp

=

$0004;

{no

linear

initNoDrop

=

$0008;

{no

drop-sample

channel--sampledSynth

channel--sampledSynth

only}

only}

channel--sampledSynth

only}

interpolation}

conversion}

Constant

Description

initChanLeft

Play sounds through the left channel of the Macintosh audio jack.

initChanRight

Play sounds through the right channel of the Macintosh audio jack.

initChanO

Play sounds through the first channel of the wave-table synthesizer.

initChan 1

Play sounds through the second channel of the wave-table synthesizer.

initChan2

Play sounds through the third channel of the wave-table synthesizer.

initChan3

Play sounds through the fourth channel of the wave-table synthesizer.

initMono

Play sounds through both channels of the Macintosh audio jack and
the internal speaker. This is the default channel mode.

initStereo

Play sounds through both channels of the Macintosh audio jack and
the internal speaker. A stereo sound contains left and right samples
that are interleaved (that is, left, right, left, right, and so forth). Note
that some machines cannot play stereo sounds.

inittMACE3

Assume that the sounds to be played through the channel are MACE
3:1 compressed. The loadCmd command and the SndNewChannel
function calculate CPU loading based on MACE 3:1 overhead. A
noncompressed sound plays normally, even through a channel that
has been initialized for MACE.

22-38

— Using the Sound Manager

The Sound Manager

initMACE6

Assume that the sounds to be played through the channel are MACE
6:1 compressed. The loadCmd command and the SndNewChannel
function calculate CPU loading based on MACE 6:1 overhead. A
noncompressed sound plays normally, even through a channel that
has been initialized for MACE.

initNoInterp

Do not use linear interpolation when playing a sound back at a
different frequency from the sound’s recorded frequency. Using the
initNoInterp initialization parameter decreases the CPU load for this
channel. Sounds most affected by the absence of linear interpolation
are sinusoidal sounds. Sounds least affected are noisy sound effects
like explosions and screams.

initNoDrop

Do not use drop-sample conversion when playing a sound back.

Note:

Most Macintosh computers play only the left channel of stereo sounds out the

internal speaker. Some machines (for example, the Macintosh SE/30 and Macintosh

IIsi) mix both channels together before sending a signal to the internal speaker. You
can use the Gestalt function to determine if a particular machine mixes both left and
right channels to the internal speaker. All models of the Macintosh, however, play
stereo signals out the headphone jack.

nN
i)

L

=
=
Qo.
4

Because MACE is extremely CPU-intensive, using the initMACE3 and initMACE6
options reserves considerably more time for a channel than does using the other
options. If you can determine whether MACE sounds will be used for a given
channel, then the CPU loading values will be much more accurate.

—

+)
i)
te)
iti=)
oe

Le 4

The initialization parameters are additive. To initialize a channel for stereo sound with no
linear interpolation, simply pass an initialization parameter that is the sum of the desired
characteristics, as follows:

myErr

:=

SndNewChannel(mySndChan,

sampledSynth,

initStereo+initNoInterp,

NIL) ;

Note that the call to SndNewChannel is really only a request that the Sound Manager open a
channel having the desired characteristics. It is possible that the parameters requested cannot
be provided without consuming too much CPU time. See “Managing the CPU Load” later
in this chapter for a method of determining when a call to SndNewChannel succeeds. In
general, you should initialize a sound channel for the most processor-intensive case (that is,
monophonic sound with linear interpolation and MACE 3:1 compression) unless you know
exactly what kind of sound is to be played.
When the Sound Manager does succeed in opening a new sound channel with the requested
characteristics, it links that channel to the desired playback synthesizer. The synthesizer reacts
to that command by allocating any private memory it needs and performing other necessary
initialization procedures.
You can alter certain initialization parameters, even while a channel is actively playing a
sound, by issuing the reInitCmd sound command. For example, you can change the

output channel from left to right, as follows:
mySnaCmd.cmd
:=
mySnaCmd.paraml
mySndCmd.param2

reInitCmd;
:= 0;
:= initChanRight;

{unused}
{new
init

parameter}

Using the Sound Manager

— 22-39

Inside Macintosh, Volume VI

:=
myErr
IF myErr

mySndCmd)
SndDoImmediate(mySndChan,
<> noErr
THEN DoError (myErr);

;

The reInitCmd command accepts the initNoInterp constant to toggle linear interpolation on
and off; it should be used with uncompressed sounds only. If an uncompressed sound is
playing when you send a reInitCmd command with this constant, linear interpolation begins
immediately. You can also pass initMono, initChanLeft, or initChanRight to pan to both
channels, to the left channel, or to the right channel. This affects only monophonic sounds.
Note that the Sound Manager remembers the settings you pass and applies them to all further
sounds played on that channel.

Releasing

Sound

Channels

To release a sound channel that you have allocated with SndNewChannel, use
SndDisposeChannel. SndDisposeChannel requires two parameters, a pointer to the
channel that is to be disposed and a Boolean value that indicates whether the channel
should be flushed before disposal. Here’s an example:
myErr

:=

SndDisposeChannel

(mySndChan,

TRUE);

Because the second parameter is TRUE, the Sound Manager sends both a flushCmd
command and a quietCmd command to the sound channel (using SndDolmmediate). This
removes all commands from the sound channel and stops any sound already in progress.
Then the Sound Manager disposes of the channel.
If the second parameter is FALSE, the Sound Manager simply queues a quietCmd command
(using SndDoCommand) and waits until quietCmd is received by the synthesizer before
disposing of the channel. In this case, the call to SndDisposeChannel is synchronous.
Note: It is important to remember that sound channels are for temporary use and that
you should create them just before playing sounds. Once the sound is completed, you
should dispose of the channel. One reason for this is that only one playback synthesizer can be active at any time. If your application is switched into the background and
does not release a sound channel, then other applications are unable to open channels
linked to other synthesizers. In particular, the system alert sound may not be heard
and the user may not be notified of important system occurrences.

Determining

Features

of Synthesizers

You can determine certain information about the capabilities of a synthesizer by using the
SndControl function. For example, you can determine whether a particular synthesizer
supports a particular initialization option (some synthesizers do not support all initialization
options). This can be most useful if you want your application to run under the enhanced
Sound Manager as well as under earlier versions where the playback synthesizers do not
have the same output characteristics. By first determining whether the intended synthesizer
supports the desired output characteristics, you can avoid requesting characteristics that are
not available. Because you generally need to know about the capabilities of a synthesizer
before you actually create a sound channel, you can call SndControl even if no channel has
been created for the synthesizer.
22-40

Using the Sound Manager

The Sound Manager

To determine whether an initialization option is supported by a particular synthesizer, call the
SndControl function and pass it the availableCmd command. Listing 22-10 illustrates how to
determine if the sampled sound synthesizer supports stereo sound output.
Listing 22-10.
mySndCmd.cmd

:=

Using the availableCmd command

availableCmd;

mySndCmd.paraml

:=

0;

{unused

mySndCmd.param2

:=

initStereo;

{test

myErr
IF

:=

myErr

SndControl(sampledSynth,
<>

noErr

StereoAvailable

THEN
:=

DoError

on
for

input}
stereo}

mySndCmd);

(myErr)

(mySndCmd.paraml

;
<>

0);

The SndControl function requires two parameters. The first parameter indicates the resource
ID of the synthesizer whose characteristics are to be determined. The second parameter is a
sound command. In the case illustrated, the cmd field of that sound command is set to
availableCmd. The param2 field of the sound command contains the initialization parameter in
question. (The initialization parameters are discussed in the preceding section, “Initializing
Sound Channels.”) The param] field of the sound command is unused on input. If SndControl
returns successfully, then param! contains | if the synthesizer has the requested characteristics
and 0 otherwise.
To determine which version of a synthesizer is available, call the SndControl function with
the versionCmd command. Neither param! nor param2 of the sound command passed to
SndControl is used on input. If the function returns successfully, the version is returned in
param2 of the sound command. For example, version 2.0 of a synthesizer would be returned
as $00020000. Listing 22-11 illustrates how to use the versionCmd command.
Listing 22-11.
mySndCmd.cmd

:=

Using the versionCmd

versionCmd;

mySndCmd.paraml

:=

0;

{unused

on

input}

mySndCmd.param2

:=

0;

{unused

on

input}

version

of

{determine
myErr
:=
IF myErr
DoError

command

sampled

sound

SndControl(sampledSynth,
<> noErr THEN

synthesizer}

mySndCmd) ;

(myErr)

ELSE

version

Playing

:=

mySndCmd.param2;

Frequencies

You can play frequencies one at a time by using the SndDoCommand or SndDoImmediate
function to issue freqDurationCmd sound commands. A sound plays for a specified duration
at a specified frequency. You can use any of the three available playback synthesizers to play
the sound. If you use the wave-table synthesizer or sampled sound synthesizer, then a voice
must previously have been installed in the channel. (See “Installing Voices Into Channels”
later in this chapter for instructions on installing wave tables and sampled sounds as voices.)
Using the Sound Manager

—_ 22-41

nN
nN
ep)
~
=

~

—

~

vont
ae
nd
al

be)
i}
a
ge
@
a!

Inside Macintosh,

Volume VI

You can also play frequencies by issuing the freqCmd command, which is identical to the
freqDurationCmd command, except that no duration is specified when you issue freqCmd.
Note: A freqDurationCmd command continues playing until another command is
available in the sound channel. Therefore, to play a single frequency for a specified
duration, you should issue freqDurationCmd followed immediately by quietCmd.
See “Manipulating a Sound That Is Playing” later in this chapter for further details
on quietCmd.
When you use the freqDurationCmd command and are using a sampled sound as the voice,
freqDurationCmd starts at the beginning of a sampled sound. The freqDurationCmd

command plays the sound between the loop points specified in the sampled sound header
to extend the sound to the specified duration. There must be an ending-point for the loop

specified in the header in order for freqDurationCmd to work properly.

The structure of a freqDurationCmd command is slightly different from that of most other
sound commands. The param| field contains the duration of the sound, specified in halfmilliseconds. (A duration of 2000 represents a duration of 1 second. The maximum duration
is a duration of 32,767, or about 16 seconds.) The param? field specifies the frequency of the
sound. The frequency is specified as a MIDI value. Listing 22-12 demon-strates the use of
the freqDurationCmd command.
Listing 22-12.

Using the freqDurationCmd command

VAR

mySndChan:
mySndCmd:

SndChannelPtr;
SndCommand;

myErr:

OSErr;

{pointer
{a sound

to a sound
command}

channel}

BEGIN

mySndCmd.cmd

:=

mySndCmd.paraml
mySndCmd.param2

freqDurationCmd;
:=

2000;
60;

{play the sound}
{assume that mySndChan
myErr
:=
IF myErr

{duration

points

to

a

in

half-milliseconds}

valid

SndDoCommand(mySndChan,
mySndCmd,
<> noErr THEN DoError (myErr);

sound

channel}

false);

END;

Table 22-3 shows the decimal values that can be sent with a freqDurationCmd or
freqCmd command. Middle C is represented by a value of 60. These values correspond
to MIDI values.
To calculate a duration, use the following formula:
duration = (2000/(repetitions per minute/60)) * repetitions per sound

You can rest a channel for a specified duration by issuing a restCmd command. The duration,
specified in half-milliseconds, is passed in the param] field of the sound command.

22-42

Using the Sound Manager

The Sound Manager

Table

22-3.

MIDI values

A

A#

Interval |
Interval 2
Interval 3
Interval 4
Interval 5
Interval 6
Interval 7
Interval 8
Interval 9
Interval 1O
Intervalll

ao
21
33.
45
57
69
81
93
=105
117

WW
22
34.
46
58
70
82
94
106
118

Playing

Sampled

B

Cc

c#

p

|
LBB
23
WA
DB
C35
386
387s
47
48
49
59
60
61
71
72
73
83
84
85
95
96
97
107
108
109
119
120
121

2
oh
26
388
50
62
#74
86
98
#110
122

p#t

gE

F

Ft

6

G#

3
4
)
6
7
8
hUDDlhCUIGlCUMTCOS
IS).
20
27
28
29
30
31
32
C9
S400
4
444
SI
52
53
54
55
56
63
64
65
66
67
68
$75
##$%7
77
#78
$79
80
87
88
89
90
91
92
99
100
101
102
103 = 104
Itt
112
#113
#114
#%I15
116
123
#124
#125
126
127

Sounds

You can play a sampled sound by calling the SndPlay function and passing it a handle to an
‘snd ' resource that contains a sampled sound header. To gain greater control over the sound
output, you can use a number of sound commands, including bufferCmd, soundCmd,
rateCmd, and getRateCmd. Both bufferCmd and soundCmd specify a pointer to a sampled
sound header that is locked into memory. The soundCmd command is used to install a
sampled sound into a channel as a voice and is discussed in the next section, “Installing
Voices Into Channels.”
To play a sampled sound in one-shot mode (without any looping), use the bufferCmd
command. The pointer in the param2 field of the sound command is the location of a sampled
sound header. A bufferCmd command is queued in the channel until the preceding commands
have been processed. If the bufferCmd command is contained within an 'snd ' resource, the
high bit of the command must be set. If the sound was loaded in from an 'snd ' resource,
your application is expected to unlock this resource and allow it to be purged after using it.
You can use the bufferCmd command to handle compressed sound samples in addition to
sounds that are not compressed. To expand and play back a buffer of compressed samples,
you pass the sampled sound synthesizer a bufferCmd command where param2 points to a
compressed sound header.
Note: Using the bufferCmd command to play several consecutive compressed
samples on the Macintosh Plus and the Macintosh SE is not guaranteed to work
without an audible pause or click.
To play sampled sounds that are not compressed, pass bufferCmd a standard or extended
sound header. The extended sound header is used for stereo sampled sounds. The standard
sampled sound header is used for all other noncompressed sampled sounds.
You can divide large sampled sounds into multiple buffers and then issue successive
bufferCmd commands to play that sound. In this case, each buffer must contain a sampled
sound header. Except as noted just above, the sound will play smoothly, without audible
gaps. It is usually much easier, however, to play large sampled sounds from disk by
using the play-from-disk routines or the SndPlayDoubleBuffer function. See “Playing
Sampled Sounds From Files” and “Managing Double Buffers” later in this chapter for
complete details.
Using the Sound Manager

—_22-43

nN
nN

2)
LY
~
—
_

-_~

—

=F
rd
_—

+e
—

ae

as
—

iio)
a")
x|

Inside Macintosh, Volume VI

Note: Ifa sound is playing and you send a bufferCmd command by using
SndDoImmediate, the sound specified in the bufferCmd command will not play.
You should send all bufferCmd commands by using SndDoCommand, or else
you should first stop the sound that is playing by sending a quietCmd command
with SndDoImmediate. Alternatively, you can call the SndChannelStatus function
repeatedly until the scChannelBusy flag of the sound-channel status record
turns FALSE.

This is the structure of the standard sampled sound header used by the sampled sound
synthesizer:
TYPE

SoundHeader
PACKED

RECORD

samplePtr:

Ptr;

{if

length:

Longint;

{number

NIL,

of

samples

in

sampleRate:

Fixed;

{sample

rate}

loopStart:

Longint;

{loop

loopEnd:
encode:

Longint;
Byte;

{loop point
ending}
{sample's
encoding
option}

baseFrequency:

Byte;

{base

sampleArea:

PACKED

ARRAY[0..0]

samples

point

array}

beginning}

frequency
OF

samoleArea}
in

of

sample}

Byte

END;

Field

descriptions

samplePtr

A pointer to the sampled sound data. If the sampled sound is located in
memory immediately after the baseFrequency field, then this field
should be set to NIL. Otherwise, this field is a pointer to the memory
location of the sampled sound data.

length

The number of bytes in the sampled sound data.

sampleRate

The rate at which the sample was originally recorded. The approximate
sample rates are shown in Table 22-4. Note that the sample rate is
declared as a Fixed data type, but the most significant bit is not treated
as a sign bit; instead, that bit is interpreted as having the value 32,768.

loopStart

The starting point of the portion of the sampled sound header that is to
be used by the Sound Manager when determining the duration of
freqDurationCmd. These loop points specify the byte numbers in the
sampled data to be used as the beginning and end points to cycle
through when playing the sound.

loopEnd

The end point of the portion of the sampled sound header that is to be
used by the Sound Manager when determining the duration of
freqDurationCmd. If no looping is desired, set both loopStart and
loopEnd to 0.

encode

The method of encoding used to generate the sampled sound data. The
current encoding option values are
CONST

22-44

stdSH
extSH

=
=

$00;
SFF;

{standard
{extended

cmpSH

=

SFE;

{compressed

—_ Using the Sound Manager

sound
sound
sound

header}
header}
header}

The Sound Manager

For a standard sound header, you should specify the constant stdSH.
Encode option values in the ranges 0 through 63 and 128 to 255 are
reserved for use by Apple. You are free to use numbers in the range
64 through 127 for your own encode options.
baseFrequency

The pitch at which the original sample was taken. This value
must be in the range | through 127. Table 22-3 lists the possible
baseFrequency values. The baseFrequency value allows the Sound
Manager to calculate the proper playback rate of the sample when
an application uses the freqDurationCmd command. Applications
should not alter the baseFrequency field of a sampled sound; to play
the sample at different pitches, use freqDurationCmd or freqCmd.

sampleArea

An array of bytes, each of which contains a value similar to the values
in a wave-table description. These values are interpreted as offset
values, where $80 represents an amplitude of 0. The value $00 is the
most negative amplitude and $FF is the largest positive amplitude. The
samples are numbered | through the value in the length parameter.

The Sound Manager can play sounds sampled at any rate up to 64 kHz. Table 22-4 lists
approximate values for the most common sample rates. When you specify a value in the
sampleRate field of a sound header, you should use the values in the third column of
Table 22-4.

Table
Rate

22-4.

Sample rates

(kHz)

Rate

5 kHz
7 kHz
11 kHz
22 kHz
44 kHz

(Hz)

5563.6363
7418.1818
L1127.2727
22254.5454
44100.0000

sampleRate
value

(Fixed)

$ISBBA2E8
$1CFA2E8B
$2B7745D1
$56EE8BA3
$AC440000

Here is the structure of the extended sampled sound header used by the sampled
sound synthesizer:
TYPE

ExtSoundHeader
PACKED

=

RECORD

samplePtr:
numChannels:
sampleRate:
loopStart:
loopEnd:

Ptr;
LongInt;
Fixed;
Longint;
LongInt;

{if NIL,
samples
in sampleArea}
{number
of channels
in sample}
{rate of original
sample}

{sample's
encoding
option}
{base
freq.
of original
sample}

encode:

Byte;

baseFrequency:
numFrames:

Byte;
Longint;

AIFFSampleRate:

Extended;

markerChunk:
instrumentChunks:
AESRecording:
sampleSize:

Ptr;
Ptr;
Ptr;
Integer;

{loop
{loop

point
point

beginning}
ending}

{total
number
of frames}
{rate of original
sample}
{pointer
{pointer

to
to

marker
info}
instrument
info}

{pointer
to audio
info}
{number
of bits per sample}

Using the Sound Manager

— 22-45

nN
nN

”N
=)
=
=|
.=
2—
ho
=
9
ge
©

Inside Macintosh,

Volume

VI

futureUsel:

Integer;

{reserved}

futureUse2:

LongIint;

{reserved}

futureUse3:

Longint;

{reserved}

futureUse4 :
sampleArea:

Longint;
{reserved}
PACKED ARRAY[0..0]
OF

Byte

END;

Field

descriptions

samplePtr

A pointer to the sampled sound data. If the sampled sound is located in
memory immediately after the futureUse4 field, then this field should
be set to NIL. Otherwise, this field is a pointer to the memory location
of the sampled sound data.

numChannels

The number of channels in the sampled sound data.

sampleRate

The rate at which the sample was originally recorded. The approximate
sample rates are shown in Table 22-4. Note that the sample rate is
declared as a Fixed data type, but the most significant bit is not treated
as a sign bit; instead, that bit is interpreted as having the value 32,768.

loopStart

The starting point of the portion of the extended sampled sound header
that is to be used by the Sound Manager when determining the duration of freqDurationCmd. These loop points specify the byte numbers
in the sampled data to be used as the beginning and end points to cycle
through when playing the sound.

loopEnd

The end point of the portion of the extended sampled sound header
that is to be used by the Sound Manager when determining the
duration of freqDurationCmd.

encode

The method of encoding used to generate the sampled sound data. For
an extended sound header, you should specify the constant extSH.
Encode option values in the ranges 0 through 63 and 128 to 255 are
reserved for use by Apple. You are free to use numbers in the range
64 through 127 for your own encode options.

baseFrequency

The pitch at which the original sample was taken. This value must be in
the range | through 127. Table 22-3 lists the possible baseFrequency
values. The baseFrequency value allows the Sound Manager to
calculate the proper playback rate of the sample when an application
uses the freqDurationCmd command. Applications should not alter
the baseFrequency field of a sampled sound; to play the sample at
different pitches, use freqDurationCmd or freqCmd.

numFrames

The number of frames in the sampled sound data.

AIFFSampleRate

The sample rate at which the frames were sampled before
compression, as expressed in an extended data type representation.

markerChunk

Synchronization information. The markerChunk field is not presently
used and should be set to NIL.

instrumentChunks

Instrument information.

AESRecording

Audio information.

sampleSize

The number of bits in each sample frame.

22-46

—_ Using the Sound Manager

The Sound Manager
futureUsel
futureUse2
futureUse3
futureUse4

Reserved.
Reserved.
Reserved.
The four futureUse fields are reserved for use by Apple. To maintain
compatibility with future releases of system software, you should
always set these fields to 0.

sampleArea

An array of bytes, each of which contains a value similar to the values

in a wave-table description. These values are interpreted as offset

values, where $80 represents an amplitude of 0. The value $00 is the

largest negative amplitude and $FF is the largest positive amplitude.
To store and operate on compressed audio data, you use a compressed sound header, a
record of type CmpSoundHeader that is a logical extension of the sound header. The
compressed sound header is defined like this:
TYPE

CmpSoundHeader

PACKED

=

RECORD

samplePtr:

Ptr;

{if

numChannels:

LongIint;

{number

sampleRate:

Fixed;

{rate

of

loopStart:

Longint;

{loop

point

beginning}

=

loopEnd:

LongIint;

{loop

point

ending}

=

encode:

Byte;

{sample's

baseFrequency:
numFrames:

Byte;
LongIint;

{base
freq.
of original
sample}
{length of sample
in frames}

AIFFSampleRate:

Extended;

{rate

markerChunk:

Ptr;

{unused}

futureUsel:

Ptr:

{reserved}

futureUse2:

Ptr;

{reserved}

stateVars:

StateBlockPtr;

{pointer

to

StateBlock}

leftOverSamples:

LeftOverBlockPtr;

{pointer

to

LeftOverBlock}

compressionID:

Integer;

{ID

packetSize:

Integer;

{number

snthID:
sampleSize:

Integer;
Integer;

{ID of compression
synth}
{bits
in each sample point}

sampleArea:

PACKED

ARRAY[0..0]

OF

NIL,

samples
of

original

original

bits

tN

in

a

sample}

=

option}

>.

sample}

compression
of

sampleArea}

sample}

encoding

of

of

in

channels

per

algorithm}
packet}

Byte

END;

Field

descriptions

samplePtr

Indicates the location of the compressed sound frames. If samplePtr is
NIL, then the frames are located in the sampleArea field of the
compressed sound header. Otherwise, samplePtr points to a buffer
that contains the frames.

numChannels

Indicates how many channels are in the sample.

sampleRate

Indicates the sample rate at which the frames were sampled before
compression. The approximate sample rates are shown in Table 22-4.
Note that the sample rate is declared as a Fixed data type, but the most
significant bit is not treated as a sign bit; instead, that bit is interpreted
as having the value 32,768.
Using the Sound Manager

—_-.22-47

2
&

Inside Macintosh,

Volume VI

loopStart

Indicates the beginning of the loop points of the sound before
compression.

loopEnd

Indicates the end of the loop points of the sound before compression.

encode

Indicates the method of encoding (if any) used to generate the sampled
sound data. For a compressed sound header, you should specify the
constant cmpSH. Encode option values in the ranges 0 through 63 and
128 to 255 are reserved for use by Apple. You are free to use numbers
in the range 64 through 127 for your own encode options.

baseFrequency

Indicates the pitch of the original sampled sound. It is not used by
bufferCmd. If you wish to make use of baseFrequency with a
compressed sound, you must first expand it and then play it with
soundCmd and freqDurationCmd.

numFrames

Indicates the number of frames contained in the compressed sound
header. When you store multiple channels of uncompressed sound,
store them as interleaved sample frames (as in AIFF). When you store
multiple channels of compressed sounds, store them as interleaved
packet frames.

AIFFSampleRate

Indicates the sample rate at which the frames were sampled before
compression, as expressed in an extended data type representation.

markerChunk

Specifies synchronization information. The markerChunk field is not
presently used and should be set to NIL.

futureUse 1
futureUse2

Reserved.
The two futureUse fields are reserved for use by Apple. To maintain
compatibility with future releases of system software, you should
always set these fields to 0.

state Vars

Points to a state block record. The state Vars field is used to store the
state variables for a given algorithm across consecutive calls.

leftOverSamples

Points to a left over block record. You can use this block to store
samples that will be truncated across algorithm invocations.

compressionID

Identifies the compression algorithm used on the samples in the
compressed sound header. You can use a constant to define the
compression algorithm.
CONST

notCompressed

=

0;

{noncompressed

threeToOne

=

3;

{3:1

compressed

samples}
samples}

sixToOne

=

4;

{6:1

compressed

samples}

Apple reserves the right to use compression IDs in the range 0
through 511.
packetSize

Indicates the size, specified in bits, of the smallest element that a given
expansion algorithm can work with. You can use a constant to define
the packet size.
CONST

22-48

sixToOnePacketSize
threeToOnePacketSize

— Using the Sound Manager

=
=

8;
16;

{size
{size

for
for

6:1}
3:1}

The Sound Manager

snthID

Indicates the resource ID number of the 'snth' resource that was used
to compress the packets contained in the compressed sound header. A
3:1 'snd' resource would have a snthID of 11, and a 6:1 'snd ' would

have a snthID of 13. If a compressed sound header contains samples
that aren’t compressed, you should set the snthID field to 0.
sampleSize

Indicates the size of the sample before it was compressed. Currently,
the Sound Manager works only with 8-bit samples. The samples
should be in offset binary format; applications that read their data
from AIFF files must convert the samples from two’s complement
format to the binary format. The samples passed in the compressed
sound header should always be byte-aligned, and any padding done
to achieve byte alignment should be done from the left with zeros.

sampleArea

Contains the sample frames, but only when the samplePtr field is NIL.
Otherwise, the sample frames are in the location indicated by samplePtr.

Listing 22-13 illustrates the structure of an 'snd ' resource that contains compressed sound data.
Listing 22-13.
data

'snd

'

(9004,

"Sample

i",

purgeable)

=

/*format

$"0005"
$"00000380"

/*resource ID of
/*initialization

first synthesizer*/
option:
initMACE3
+

/*sampling

of

$"0001"
$*°8051"
$"0000"
$"00000014"

type*/

/*number

of

=

synthesizers*/

iS

$"00000000"
$"00000001"
$"00000000"
$"00000000"
S"FE"
$"00"

/*starting
of the sample's
loop point;
not used*/
/*ending
of the sample's
loop point;
not used*/
/*compressed
sample
encoding* /
/*baseFrequency;
not used*/

$"00006590"

/*number

rate

of

frames

this

in

sound

sample

(22

/*compressionID,

3

means

3:1*/

(26,000)
*/

omitted

in

$"0010"
$"000B"
$"0008"
S"2F
85
S"6F 48

$"91

FE

81
6D

/*packetSize,
packetSize
for 3:1
is 16 bits*/
/*snthID
is 11*/
/*sampleSize,
sound was
8-bit
before processing*/
32 64 87 33 86"
/*the compressed
sound data*/
65 72 6B 82 88"

8E

86

4E

7C

S"6F

6D

71

70

7E

79

4F

$"59

8F

8F

65"

8D

/*rest

ss

kHz) */

$"400DADDD1745D145826B"
/*AIFFSampleRate
(22 kHz
in extended
$"00000000"
/*markerChunk;
NIL
for
'snd
' resource*/
$"00000000"
/*futureUsel;
NIL for
‘snd
' resource*/
$"00000000"
/*futureUse2;
NIL
for
‘snd
resource® /
$"00000000"
/*stateVars;
NIL
for
‘snd
' resource*/
$"00000000"
/*leftOverBlockPtr;
not used here*/

S*0003"

=
fe

initMono*/

/*number
of sound commands
that
follow
(1)*/
/*cmad:
bufferCmd* /
/*paraml:
unused*/
/*param2:
offset
to sound header
(20 bytes)
*/
/*compressed
sound header
follows:*/
/*pointer
to data
(it follows
immediately)
*/
/*number
of channels
in sample*/

S"S6EE8BA3"

P

{

$"0001"

$"0001"

i)
Ss)

An 'snd ' resource containing compressed sound data

type)

*/

E9"

83"

of

data

this

example*/

Using the Sound Manager

—_22-49

Inside Macintosh,

Volume

VI

This resource has the same general structure as the 'snd' resource illustrated in “The Format |
‘snd ' Resource” earlier in this chapter. The principal difference is that the standard sound
header is replaced by the compressed sound header. This example resource specifies a monophonic sound compressed by using the 3:1 compression algorithm.

Installing Voices

Into Channels

You can play frequencies through any of the three available playback synthesizers. By playing
a frequency through the wave-table or sampled sound synthesizer, you can achieve a different
sound than by playing that same frequency through the square-wave synthesizer. To do that,
however, you need to install a voice into the sound channel to which you want to send
freqDurationCmd commands.
You can install a wave table into a channel as a voice by issuing the waveTableCmd command.
The param! field of the sound command specifies the length of the wave table and the param2
field is a pointer to the wave-table data itself. Note that the Sound Manager will resample the
wave table so that it is exactly 512 bytes long.
You can install a sampled sound into a channel as a voice by issuing the soundCmd command.
You can either issue this command from your application or put it into an 'snd ' resource. If
your application sends this command, param? is a pointer to the sampled sound locked in
memory. If soundCmd is contained within an 'snd ' resource, the high bit of the command
must be set. To use a sampled sound 'snd' as a voice, first obtain a pointer to the sampled
sound header locked in memory. Then pass this pointer in param2 of a soundCmd command.
After using the sound, your application is expected to unlock this resource and allow it to
be purged.

Manipulating

a Sound

That Is Playing

The Sound Manager provides a number of sound commands that allow you to manipulate
sounds currently in progress. You can also pause or stop a sound currently in progress. See
“Pausing and Restarting Sound Channels” later in this chapter for information on how to
pause the processing of a sound channel.
You can use the getRateCmd command to determine the rate at which a sampled sound is
currently playing. If SndDoImmediate returns noErr when you pass it getRateCmd, the
current rate of the channel is returned as a Fixed value in param2 of the sound command.
(As usual, the high bit of the value returned is not interpreted as a sign bit.)
To modify the pitch of the sampled sound currently playing, use the rateCmd command.
The current pitch is set to the rate specified in the param? field of the sound command.
Listing 22-14 illustrates how to halve the frequency of a sampled sound.
You can also use rateCmd and getRateCmd to pause a sampled sound that is currently
playing. To do this, read the rate at which it is playing, issue a rateCmd command with a
rate of 0, and then issue a rateCmd command with the previous rate when you want the
sound to resume playing.

22-50

Using the Sound Manager

The Sound Manager

Listing 22-14.
PROCEDURE

HalveFreq

Halving the frequency of a sampled sound

(mySndChan:

SndChannelPtr);

VAR
myRate:

Longint;

mySndCmd:
BEGIN

SndCommand;

mySndCmd.cmd

:=

getRateCmd;

mySndCmd.paraml

:=

0;

mySndCmd.param2

:=

@myRate;

myErr
IF

:=

myErr

{unused}

SndDoImmediate(mySndChan,
=

noErr

mySndCmd) ;

THEN

BEGIN
mySndCmd.cmd

IF

:=

rateCmd;

mySndCmd.paraml

:=

0;

mySndCmd.param2

:=

FixDiv(myRate,

{unused}
$0002000);

myErr

:=

SndDoImmediate(mySndChan,

myErr

<>

noErr

THEN

DoError

(myErr)

mySndCmd) ;
;

S)
rs)
<2
=
=
3

You can use the gettAmpCmd command to determine the current amplitude of a sound in
progress. The getAmpCmd command is similar to getRateCmd, except that the value
returned is an integer. The value returned is in the range 0-255. Here’s an example:

<

69
=;
pt)
iT)@

<a

VAR
myAmp:

Integer;

BEGIN
mySndCmd.cmd

:=

mySndCmd.paraml

getAmpCmd;
:=

0;

{unused}

mySndCmd.param2
:= @myAmp;
myErr
:= SndDoImmediate(mySndChan,

mySndCmd) ;

END;

To change the amplitude of the sound in progress, issue the ampCmd command. If no sound
is currently playing, ampCmd sets the amplitude of the next sound. The desired new
amplitude is passed in the param! field of the sound command and should be a value in the
range 0 to 255.
To modify the timbre of a sound being played by the square-wave synthesizer, use the
timbreCmd command. A sine wave is specified as 0 in param! and produces a very clear
sound. A value of 255 in param! represents a modified square wave and produces a buzzing
sound. You should change the square-wave synthesizer’s timbre before playing the sound.
Only a Macintosh with the Apple Sound Chip allows this command to be sent while a sound
is in progress.
To cause a synthesizer to stop playing the sound in progress, send the quietCmd sound
command. Here’s an example:
mySndCmd.cmd

:=

mySndCmd.paraml
mySndCmd.param2
{stop
myErr

quietCmd;

{the

:=
:=

{unused}
{unused}

0;
0;

command

the sound now playing}
:= SndDoImmediate(mySndChan,

is

mySndCmd,

quietCmd}

FALSE) ;

Using the Sound Manager

—22-51

Inside Macintosh,

Volume VI

To stop a sound that is currently playing on the specified sound channel, send a quietCmd
command. To bypass the command queue, you should issue quietCmd by using
SndDoImmediate. Any sound commands that are already in the sound channel remain
there, however, and further sound commands can be queued in that channel.

Flushing

Sound

Channels

If you wish to flush a sound channel without disturbing any sounds already in progress,
issue the flushCmd command. Here’s an example:
mySndCmd.cmd

:=

mySndCmd.paraml
mySndCmd.param2

flushCmd;

{the

:=
:=

{unused}
{unused}

0;
0;

command

{flush
the channel}
myErr
:= SndDoImmediate(mySndChan,

is

flushCmd}

mySndCmd,

FALSE);

If you want to stop all sound production by a particular sound channel immediately, you
should issue a flushCmd command and then a quietCmd command. If you issue only
a flushCmd command, the sound currently playing is not stopped. If you issue only a
quietCmd command, the synthesizer stops playing the current sound but continues with
any other queued commands. (By calling flushCmd before quietCmd command, you ensure
that there are no other queued commands to process.)
Note: The Sound Manager sends a quietCmd command when your application
calls the SndDisposeChannel function. The quietCmd command is preceded by a
flushCmd command if the quietNow parameter is TRUE.

Pausing

and

Restarting

Sound

Channels

If you want to pause command processing in a particular channel, you can use either of two
sound commands, waitCmd or pauseCmd. The waitCmd command suspends all processing
in a channel for a specified number of half-milliseconds. Here’s an example:
mySndCmd.cmd

waitCmd;

{the

mySndCmd.paraml

:=

2000;

{1

mySndCmd.param2

:=

0;

{unused}

{pause

the

myErr

:=

:=

command

second

wait

is

waitCmd}
duration}

channel}

SndDoImmediate(mySndChan,

mySndCmd,

FALSE);

To pause the processing of commands in a sound channel for an unspecified duration, use the
pauseCmd command. Unlike waitCmd, pauseCmd suspends processing for an undetermined
amount of time. Processing does not resume until the Sound Manager receives a resumeCmd
command for the specified channel.
To issue waitCmd or pauseCmd, you can use either SndDoImmediate or SndDoCommand,
depending on whether you want the suspension of sound-channel processing to begin
immediately or when the synthesizer reaches that command in the normal course of reading
commands from a sound channel. The resumeCmd command, which is simply the opposite
22-52

Using the Sound Manager

The Sound Manager

of pauseCmd, should be issued by using SndDoImmediate. Neither waitCmd nor pauseCmd
stops any sound that is currently playing; these commands simply stop further processing of
commands queued in the sound channel.
Note: Synthesizers expect to receive additional commands after a resumeCmd
command. If no other commands are pending in the sound channel, the Sound
Manager sends an emptyCmd command. The emptyCmd command is sent only
by the Sound Manager and should not be issued by your application.

Synchronizing

Sound

Channels

You can synchronize several different sound channels by issuing syncCmd commands.
The param! field of the sound command contains a count, and the param2 field contains
an arbitrary identifier. Every syncCmd command is held in the channel, suspending any
further processing until its count equals 0. The Sound Manager first decrements the count
and then waits for another syncCmd command having the same identifier to be received
on another channel.
For example, to synchronize four wave-table channels, send a syncCmd command to the
first channel with a count equal to 4, to the second channel with a count equal to 3, and so
on, giving each command the same identifier. The Sound Manager decrements the count for
each channel having a given identifier each time it receives a syncCmd command. As a result,
after you send the fourth channel a count equal to |, all four channels will have their count
set to 0 and will resume processing their queued commands.

nN
i)
ZN
So
=
=
2.

<<
—

rt)
~
ee)
tj)
ic
bea

Note: The syncCmd command is intended to make it easy to synchronize channels
linked either to the wave-table synthesizer or to the square-wave synthesizer. Applications needing to synchronize and control the execution of multiple channels of
sampled sound should probably use the Time Manager.

Managing

the CPU

Load

When you want to open multiple channels of sound, or even when you want to open a single
channel of sound that requires intensive processing to provide a high-quality sound (for
example, real-time expansion of compressed sampled sound with stereo output and linear
interpolation), you may want to pay close attention to the amount of processing power
consumed by your sound-related activity. The new Sound Manager allows you to monitor
and limit the load placed on the CPU by sound activity.
You need to be able to monitor the sound processing done by your application because
every Macintosh computer has some absolute limit to its processing power, which is
determined largely by the speed of the CPU. Other factors also affect how much soundrelated activity a given computer can support, such as processing necessary to track mouse
movements, processing done by the Operating System, processing done by interrupt
routines, and so on. When no sound channels are open, the Sound Manager considers the
computer to be completely available for sound tasks. In that case, the current load value
is 0 percent. As sound channels are opened, the current CPU loading value increases from
0 percent to the maximum value, 100 percent. The amount of increase due to a new sound
channel depends on the initialization parameters specified in the call to SndNewChannel that
created that channel.
Using the Sound Manager

—-22-53

|

Inside Macintosh,

Volume

VI

Note: The CPU load values provided by the Sound Manager do not account for any
nonsound processing, such as networking software or other interrupt code.
In the enhanced Sound Manager, the loadCmd command returns (in param!) the percentage

of CPU load that would be reserved by calling SndNewChannel with the initialization parameters passed into param2 of the loadCmd command. On a Macintosh II, the value returned in
param! might be 15 percent, indicating that a stereo sound channel would need 15 percent of
the available processor power to play sound.
The totalLoadCmd command returns a potentially more useful number. The totalLoadCmd
command is identical to the loadCmd command except that instead of returning just the
percentage of processor power for the specified initialization parameters, it adds the current
CPU loading value to that number. The value returned in param] is the total processor power
that would be used by the Sound Manager if those initialization parameters were actually used
to allocate a sound channel. If the number returned is greater than 100 percent, allocating that
channel would not be advisable.

Producing

an Alert Sound

You can produce a system alert sound to catch the user’s attention by calling the
SysBeep procedure. The SysBeep procedure is a Sound Manager routine that plays the
system alert sound, selected by the user in the Sound control panel. Here’s an example
of calling SysBeep:
IF

myErr

<>

noErr

THEN

SysBeep(30) ;

You must supply a parameter when you call the SysBeep procedure, even though the Sound
Manager ignores that parameter in most cases. All system alert sounds are stored as format |
‘snd ' resources in the System file and are played by the Sound Manager. There is, however,
one exception to this rule: if the user has selected the Simple Beep as the system alert sound
on a Macintosh Plus or Macintosh SE, then the beep is generated by code stored in ROM
rather than by the Sound Manager, and the duration parameter is interpreted in ticks.
If an application has an open sound channel, your call to the SysBeep procedure may not
generate any sound because only one synthesizer can be active at any time. For example,
if an application is using the square-wave synthesizer to play sounds, SysBeep may fail to
generate the system alert sound because that sound uses the sampled sound synthesizer.
Even if the user has selected the Simple Beep as the system alert sound (which uses the
square-wave synthesizer), the alert sound will not be heard if some application already has
an open channel linked to the square-wave synthesizer. This is because only one channel at
a time can be linked to the square-wave synthesizer.
In cases like these where the system alert sound cannot be created, the Operating System
flashes the menu bar. Applications using any of the sound synthesizers should dispose of
their channels as soon as they have finished making a sound so that the system alert sound
can be played. Once again, Macintosh computers without the Apple Sound Chip (that is,
the Macintosh Plus and Macintosh SE) operate differently: when the Simple Beep is
selected, the beep is heard because the Operating System bypasses the Sound Manager to
make the sound.
The SysBeep procedure cannot be called at interrupt time because doing so may cause the
Sound Manager to attempt to allocate memory and load a resource.
22-54

— Using the Sound Manager

The Sound Manager

Note: If your primary use of the SysBeep procedure is to alert the user of important
or abnormal occurrences, it may be better to use the Notification Manager. See the
Notification Manager chapter in this volume for complete details on alerting the user.
The new Sound Manager includes two functions—SndGetSysBeepState and

SndSetSysBeepState—that allow you to determine and alter the status of the system

sysBeepDisable
sysBeepEnable

=

$0000;

{system

alert

sound

disabled}

$0001;

{system

alert

sound

enabled}

When the system alert sound is disabled, the Sound Manager effectively ignores all calls to
SysBeep. No sound is created and the menu bar will not flash. Also, no resources are loaded
into memory. Even when the system alert sound is enabled, it is possible that the system alert
sound will not be played; for example, the speaker volume may be set to 0, or playing the
requested system alert sound might require too much CPU time. In these cases, the menu bar
will flash. By default, the system alert sound is enabled.

Compressing

and

Expanding

CC

CONST

I

alert sound. Currently, two states are defined:

7 2)
-)
i=
=
2.

Sounds

—

Some of the capabilities provided by MACE are transparently available to your application.
For example, if you pass the SndPlay function a handle to an 'snd ' resource that contains a
compressed sampled sound, the sampled sound synthesizer automatically expands the sound
data for playback in real time. Your application does not need to know whether the 'snd'
resource contains compressed or noncompressed samples when it calls SndPlay. This is
because sufficient information is in the resource itself to allow the synthesizer to determine
whether it should expand the data samples.
However, aside from expansion playback, all of the MACE capabilities need to be specifically requested by your application. For example, you can use the procedures Comp3tol
or Comp6tol if you want to compress a sampled sound (for example, to create an ‘snd '
resource containing compressed audio data). And you can use the procedures Exp1to3 and
Exp|to6 to expand compressed audio data.
All of these procedures require you to specify both an input and an output buffer, from and
to which the sampled sound data to be converted is read and written. Your application must
allocate the appropriate amount of storage for each buffer. For example, if you want to
expand a buffer of compressed sampled sound data by using Exp1to6, the output buffer
must be at least six times the size of the input buffer.
When calling these routines, you must also specify addresses of two small buffers (128 bytes
each) that the Sound Manager uses to maintain state information about the compression or
expansion process. When you first call a MACE routine, the state buffers should be filled
with zeros to initialize the state information. You can pass NIL for both buffers if you do not
want to save state information across calls to the MACE routines. Listing 22-15 illustrates the
use of the Comp3tol procedure.
Because the numChannels and the whichChannel parameters are both set to 1, CompressBy3
compresses monophonic audio data.
Using the Sound Manager

— 22-55

©
=
et)
8f=)
a)

“

Inside Macintosh,

Volume

VI

PROCEDURE

CompressBy3

Ptr;

outBuf:

state

buffer}

(inBuf:

audio data

Compressing

Listing 22-15.

Ptr;

numSamp:

LongInt) ;

VAR

myInState:

Ptr;

{input

myOutState:

Ptr;

{output

state

buffer}

BEGIN

myinState
myOutState
IF

:=

NewPtrClear (128) ;
NewPtrClear(128) ;

:=

(myInState

<>

NIL)

Comp3tol(inBuf,

AND

(myOutState

outBuf,

numSamp,

Sounds

From

<>

NIL)

myInState,

THEN

myOutState,

1,

1);

END;

Playing

Sampled

Files

There are three functions that you can use to initiate and control a continuous playback of
sampled sounds stored in files—SndStartFilePlay, SndPauseFilePlay, and SndStopFilePlay.
You use SndStartFilePlay to initiate the playing of the sound. You use SndPauseFilePlay to
temporarily suspend a sound from playing. If a sound is playing and you call
SndPauseFilePlay, then the sound is paused. If the sound is paused and you call
SndPauseFilePlay again, then the sound resumes playing. Hence, the SndPauseFilePlay
routine acts like a pause button on a tape player, which toggles the tape between playing
and pausing. (You can determine the current state of a play from disk by using the
SndChannelStatus function. See “Obtaining Information About a Single Sound Channel”
later in this chapter for complete details.) Finally, you can use SndStopFilePlay to stop
the file from playing.
SndStartFilePlay can play sampled sounds stored in 'snd ' resources (either format | or
format 2) or in files that conform to the AIFF or AIFF-C format. In addition, you can specify
whether the play from disk should be asynchronous or synchronous. The SndStartFilePlay
function is a high-level Sound Manager routine, like SndPlay. If you specify NIL as the
sound channel, then SndStartFilePlay allocates memory for a channel internally. However,
since you must specify a sound-channel pointer when calling either SndPauseFilePlay
or SndStopFilePlay, you must allocate a sound channel yourself and call SndStartFilePlay
asynchronously if you want to be able to pause or stop the sound prior to its natural
ending point.

Playing

an ‘snd

' Resource

From

Disk

To play a sampled sound that is contained in an 'snd' resource, you need to pass
SndStartFilePlay the resource ID number of the resource to play. Listing 22-16 illustrates
how to play an 'snd' resource synchronously from disk.
Notice that the second parameter passed to SndStartFilePlay here is set to 0. That parameter
is used only when playing files from disk.

22-56

Using the Sound Manager

The Sound Manager

Listing 22-16.
PROCEDURE
CONST

Playing an ‘snd ' resource from disk

SyncStartFilePlay

(myResNum:

kTotalSize

=

16*1024;

kAsync

=

TRUE;

myErr:

OSErr:

mySndChan:

SndChannelPtr;

kQuietNow

=

{play

TRUE;

{quiet

sound

Integer);

asynchronously? }

channel

now?}

VAR

BEGIN

{allocate

a

sound

mySndChan

:=

NIL;

myErr
:=
IF myErr
{play

the

myErr

:=

IF

channel}

SndNewChannel
<> noErr THEN
'snd

'

(mySndChan,
sampledSynth,
DoError (myErr) ;

NIL);

resource}

SndStartFilePlay(mySndChan,

myErr

<>

noErr

{dispose

of

the

IF

mySndChan

<>

IF

myErr
myErr

:=
<>

initMono,

THEN

NIL,
DoError

0,

myResNum,

NIL,
NOT
(myErr) ;

kAsync);

kTotalSize,

NIL,
NM
N

ZN
~

channel}
NIL

=

foal
—

—

—_

THEN

jon

SndDisposeChannel (mySndChan,
noErr THEN DoError (myErr) ;

NOT

a
ae

kQuietNow) ;

ou
~
oo
ge

END;

ic
“

Playing a File From

Disk

To play a sampled sound that is contained in a file, you need to pass SndStartFilePlay the file
reference number of the file to play. The sample should be stored in either AIFF or AIFF-C
format. If the sample is compressed, then it will be automatically expanded during playback.
For example, to play a sampled sound that is found in a file whose file reference number is
stored in the variable myfRefNum, you could write
myErr

:=

SndStartFilePlay

(mySndChan,
NIL,

myfRefNum,

0,

kTotalSize,

NIL,

NIL,

FALSE);

Notice that the third parameter passed to SndStartFilePlay here is set to 0. That parameter is
used only when playing resources from disk.

Playing

Selections

The sixth parameter passed to SndStartFilePlay is a pointer to an audio selection record,
which allows you to specify that only part of the sound be played. If that parameter has a
value different from NIL, then SndStartFilePlay plays only a specified selection of the entire
sound. You indicate which part of the entire sound to play by giving two offsets from the
beginning of the sound, a time at which to start the selection and a time at which to end the
selection. Currently, both time offsets must be specified in seconds.

Using the Sound Manager

— 22-57

Inside Macintosh,

Volume VI

Here is the structure of an audio selection record:
TYPE

AudioSelection
PACKED

=

RECORD

unitType:

Longint;

{type

selStart:

Fixed;

{starting

of

time

selEnd:

Fixed

{ending

unit}

point

point

of
of

selection}

selection}

END;

Field

descriptions

unitT ype

The type of unit of time used in the start and end fields. You should
set this to seconds by specifying the constant unitTypeSeconds.

selStart

The starting point in seconds of the sound to play.

selEnd

The ending point in seconds of the sound to play.

Use a constant to specify the unit type.
CONST

unitTypeSeconds

=

$0000;

{seconds}

unitTypeNoSelection

=

SFFFF;

{no

Recording

Sounds

Through

selection}

the Sound

Input Dialog Box

You can record sounds from the current input device by using the SndRecord or
SndRecordToFile function. You can use the SndRecord function to present a standard
user interface for recording sounds. When calling SndRecord, you need to provide a
handle to a block of memory where the incoming data should be stored. If you pass the
address of a NIL handle, however, the Sound Manager allocates a large block of space
and resizes it when the recording stops. Listing 22-17 illustrates how to call SndRecord.
Listing 22-17.
PROCEDURE
VAR

Recording through the sound input dialog box

RecordThruDialog

myErr:

OSErr;

myCorner:

Point;

(VAR

mySndH:

Handle);

BEGIN

SetPt

(myCorner,

mySndH
myErr

:=
:=

50,

50);

NIL;
SndRecord(NIL,

myCorner,

siBetterQuality,

mySndH) ;

END;

If you pass a sound handle that is not NIL, the time of recording is derived from the amount
of space reserved by that handle. The handle is resized on completion of the recording.

22-58

Using the Sound Manager

The Sound Manager

The first parameter in the call to SndRecord is the address of a filter procedure that determines
how user actions in the dialog box are filtered. In Listing 22-17, no filter procedure is
desired, so the parameter is specified as NIL. The third parameter specifies the quality of the
recording. Currently three values are supported:
CONST

siBestQuality

=

'best';

{the

siBetterQuality
siGoodQuality

=
=

'betr';
"good";

{a
{a

best

quality

quality
better
good quality}

available}
than

good}

The precise meanings of these constants are driver-specific. The constant siBestQuality
indicates that you want the highest quality recorded sound, usually at the expense of
increased storage space (probably because no compression is performed on the sound data).
The constant siGoodQuality indicates that you are willing to sacrifice audio quality if
necessary to minimize the amount of storage space required (typically this means that MACE
6:1 compression is performed on the sound data). For most voice recording, you should
specify siGoodQuality. The constant siBetterQuality defines a quality and storage space
combination that is between those provided by the other two constants.
After the procedure in Listing 22-17 has executed successfully, you could play the recorded
sound by calling SndPlay and passing it mySndH. Note that mySndH is a handle to some
data in memory that has the structure of an 'snd ' resource, not a handle to an existing
resource. To save the recorded data as a resource, you can call AddResource.

to
tS)
D
=
=
iY
<2

De

pe)

To record a sound directly into a file, you can call SndRecordToFile. The SndRecordToFile
function works exactly like SndRecord, except that you must pass it the file reference number
of an open file instead of a handle to some memory. When SndRecordToFile exits successfully, that file contains the recorded audio data in AIFF or AIFF-C format. You can then play
the recorded sound by passing that file reference number to the SndStartFilePlay function.

Recording

Sounds

Directly From

a Device

There are a number of routines that are intended for use by applications that need more
control over the recording process (such as the ability to intercept sound input data at interrupt
time). You can open a sound input device and read data from it by calling these low-level
Sound Manager routines. Several of these routines access information through a sound input
parameter block:
TYPE

SPB

=

RECORD

inRefNum:

Longint;

{reference

number

count:
milliseconds:
bufferLength:

Longint;
Longint;
Longint;

{number
{number
{length

bytes
to record}
milliseconds
to record}
buffer
to record
into}

bufferPtr:
completionRoutine:
interruptRoutine:

Ptr’
ProcPtr;
ProcPtr;

{pointer
{pointer
{pointer

userLong:
error:

Longint;
OSErr;

{for application's
use}
{error
returned
after
recording}

unusedl:

LongInt

{reserved}

of
of
of
to
to
to

of

input

device}

buffer
to record
into}
a completion
routine}
an interrupt
routine}

END;

Using the Sound Manager

—-22-59

=

itj=)

g

Inside Macintosh,

Field

Volume VI

descriptions

inRefNum

The reference number of the sound input device (as received from
SPBOpenDevice) from which the recording is to occur.

count

On input, the number of bytes to record. On output, the number
of bytes actually recorded. If this field specifies a longer recording
time than the milliseconds field, then the milliseconds field is ignored
on input.

milliseconds

On input, the number of milliseconds to record. On output, the
number of milliseconds actually recorded. If this field specifies a
longer recording time than the count field, then the count field is
ignored on input.

bufferLength

The length of the buffer into which recorded sound data is placed.
The recording time specified by the count or milliseconds field is
truncated to fit into this length, if necessary.

bufferPtr

A pointer to the buffer into which recorded data is placed. If this
field is NIL, then the count, milliseconds, and bufferLength fields
are ignored and the recording will continue indefinitely until
SPBStopRecording is called. However, the data is not stored
anywhere, so setting this field to NIL is useful only if you want to
do something in your interrupt routine but do not want to save the
recorded sound.

completionRoutine

A pointer to a completion routine that is called when the recording
terminates as a result of your calling SPBStopRecording or when the
limit specified by the count or milliseconds field is reached. The
completion routine executes only if SPBRecord is called asynchronously and therefore is called at interrupt time.

interruptRoutine

A pointer to a routine that is called by asynchronous recording devices
when their internal buffers are full.

userLong

A long integer available for the application’s own use. You can use
this field, for instance, to pass a handle to an application-defined
structure to the completion routine or to the interrupt routine.

error

A code describing any errors that occur during the recording. If the
recording terminates without an error, this field contains noErr. If any
error occurs during the recording, this field contains a value of type
OSErr. If the recording is terminated by a call to SPBStopRecording,
this field contains the value abortErr. You can poll this field while
recording asynchronously to determine if any errors have occurred.

unused 1

Reserved for use by Apple. You should always initialize this field
to 0.

Listing 22-18 shows how to set up an SPB structure and record synchronously using the
SPBRecord function. This procedure takes one parameter, a handle where the recorded
sound data is to be stored. It is assumed that the handle is large enough to hold the sound
to be recorded.

22-60

— Using the Sound Manager

The Sound Manager

Listing 22-18.
PROCEDURE
CONST

RecordSnd

kAsynch

=

Recording directly from a sound input device

(mySndH:

Handle);

TRUE;

VAR

mySPB:
myErr:

SPB;
OSErr;

{a

sound

input

myIinRefNum:

LongInt;

{device

reference

myBuffSize:

LongInt;

{size

buffer

to

myHeadrLen:

Integer;

{length

of

header}

myNumChans:
mySampSize:

Integer;
Integer;

{number of
{size of a

of

parameter

block}

number}

sound

record

into}

channels}
sample}

mySampRate:

Fixed;

{sample

myCompType:

OSType;

{compression

rate}
type}

BEGIN
{open

the

default

myErr

:=

SPBOpenDevice('',

IF

myErr

=

input

noErr

device

for

reading

and

writing}

siWritePermission,

myInRefNum) ;

THEN

BEGIN

{get

current

settings

of

sound

input

device

{ using an application-defined
routine}
GetDeviceSettings (myInRefNum,
myNumChans,

}

mySampRate,

mySampSize,

up

myErr

handle
:=

to

contain

SetupSndHeader

the

proper

(mySndH,

down

(mySndH)

;

{set

up

sound

WITH

mySPB

the

BEGIN
inRefNum

the

sound

handle

input

‘snd

'

resource

mySampRate,

60,

myHeadrLen) ;

until

parameter

0,

i)

ar

header}

myNumChans,

{leave
room in buffer
for the sound
myBuffSize
:= GetHandleSize(mySndH)
{lock

mySampSize,

header}
- myHeadrLen;

the

recording

is

over}

block}

do
:=

myInRefNum;

{input

device

reference

count
:= myBuffSize;
milliseconds
:= 0;
bufferLength
:= myBuffSize;

{number of bytes
to
{no milliseconds}
{length of buffer}

bufferPtr

+ myHeadrLen) ;
{put data after

:=

Ptr(ORD4(mySndH*)

completionRoutine

interruptRoutine

:=

:=

NIL;

NIL;

{no

completion

{no

interrupt

‘snd

'

header}

routine}

:= 0;
noErr?

{no user data}
{clear error
field}

unusedl

:=

{clear

reserved

number}

record}

routine}

userLong
error
+=

0;

a

£9
ga

myCompType,

HLock

—

=.

myCompType) ;
{set

)
SS)
ee)
S
=
=
-¥
<

field}

END;

(Continued)

Using the Sound Manager

—_ 22-61

Inside Macintosh, Volume VI

Listing 22-18.

Recording directly from a sound input device (Continued)
input

the open sound
through
synchronously
{record
kAsynch) ;
not
:= SPBRecord(@mySPB,
myErr
is done,
{recording
HUnlock (mySndH) ;
{now

unlock

the

sound

handle}

fill
in the number
of bytes actually
recorded}
mySampSize,
mySampRate,
myNumChans,
:= SetupSndHeader(mySndH,
myCompType,
60,
mySPB.count,
myHeadrLen) ;

myErr

{close

myErr

so

device}

the

:=

input

device}

SPBCloseDevice

(myInRefNum)

;

END;
END;

The RecordSnd procedure defined in Listing 22-18 opens the default sound input device by
using the SPBOpenDevice function. You can specify one of two values for the permissions
parameter of SPBOpenDevice:
CONST

siReadPermission
siWritePermission

=

0;

{open

device

for

reading}

1;

{open

device

for

reading/writing}

If SPBOpenDevice successfully opens the specified device for reading and writing,
RecordSnd calls the GetDeviceSettings procedure (defined in Listing 22-20). That procedure

calls the Sound Manager function SPBGetDeviceInfo (explained in “Getting and Setting

Sound Input Device Information” later in this chapter) to determine the current number of
channels, sample rate, sample size, and compression type in use by the device.

This information is then passed to the SetupSndHeader function, which loads the initial
segment of the handle with a sound header describing the current device settings. After
doing this, RecordSnd sets up a sound input parameter block and calls SPBRecord
to record a sound. Note that the handle must be locked during the recording because
the parameter block contains a pointer to the input buffer. After the recording is done,
RecordSnd calls SetupSndHeader once again to fill in the actual number of bytes recorded.
Once the procedure defined in Listing 22-18 executes successfully, the handle mySndH
points to a resource of type 'snd '. Your application can then play the recorded sound, for
example, by executing the following lines of code:
RecordSnd

(mySndH)

myErr

SndPlay(NIL,

:=

;

Defining a Sound

{procedure
mySndH,

shown

in

Listing

22-18}

FALSE) ;

Input Completion

Routine

The completionRoutine field of the SPB structure contains the address of a completion
routine that executes when the recording terminates normally either by reaching its prescribed
time or size limits, or by the application calling SPBStopRecording. A completion routine
should have the following format:
PROCEDURE

22-62

MyRecordCompletionRoutine

Using the Sound Manager

(inParamPtr:

SPBPtr);

The Sound Manager

The completion routine is passed the address of the sound input parameter block that was
passed to SPBRecord. You can gain access to other data structures in your application by
passing an address in the userLong field of the parameter block. After the completion routine
executes, your application should check the error field of the sound input parameter block to
see if an error code was returned.

Defining

an Interrupt

Routine

The interruptRoutine field of the sound input parameter block contains the address of a
routine that executes when the internal buffers of an asynchronous recording device are filled.
The internal buffers contain raw samples taken directly from the input device. The interrupt
routine can modify the samples in the buffer in any way it requires. The processed samples
are then written to the application buffer. If compression is enabled, then the modified data is
compressed after your interrupt routine operates on the samples and before the samples are
written to the application buffer. You can determine the size of the sample buffer by calling
SPBGetDevicelnfo with the 'dbin' selector.
to
NS)
”
S
=
=
3
Ss
&
=:
ie@

Assembly-language note: Interrupt routines are typically written in
assembly language to maximize real-time performance in recording sound. On
entry, registers are set up as follows:
AQ:
Al:
DO:
D1:

— Address of the sound parameter block passed to SPBRecord
— Address of the start of the sample buffer
Peak amplitude for sample buffer if metering is on
— Size of the sample buffer in bytes

—

ede

sere

Your interrupt routine is always called at interrupt time, so it should not call routines that
might move or compact memory.

Getting and Setting Sound

Input Device

Information

You can get information about a specific sound input device and alter that information by
calling the functions SPBGetDevicelInfo and SPBSetDevicelnfo. These functions accept
selectors that determine which information you need or want to change. The currently defined
selectors are defined by constants of type OST ype:
CONST

siActiveChannels

=

'chac';

{channels

siActiveLevels

=

'lmac';

{levels

active}

siAGCOnOoOff
siAsync

=
=

'agce
';
'asyn';

{automatic
gain control
state}
{asynchronous
capability}

siNumberChannels
siChannelAvailable

=
=

“ehan’ s
'chav';

{current
number of channels}
{number of channels
available}

siCompressionAvailable

=

'cmav';

{compression

siCompressionFactor

=

'cmfa';

{current

siCompressionHeader
siCompressionType

=
=

'cmhd';
'comp';

{return compression
header}
{current
compression
type}

active}

types

compression

available}
factor}

Using the Sound Manager

—_ 22-63

|

Inside Macintosh,

Volume VI

siContinuous

=

'cont';

{continuous

siDeviceBufferInfo

=

'dbin';

{size

siDeviceConnected

=

'dcon';

{input

device

connection

siDevicelIcon

=

'jcon';

{input

device

icon}

siLevelMeterOnOff

=

'lmet';

{level

meter

state}

siDeviceName

=

'name';

{input

device

name}

siOptionsDialog

=

'optd';

{display

siPlayThruoOnoff

=

'plth';

{play-through

siRecordingQuality
siSampleRate

=
=

'qual';
'srat';

{recording
quality}
{current
sample
rate}

siSampleRateAvailable
siSampleSizeAvailable
siSampleSize

=
=
=

'srav';
'ssav';
'ssiz';

{sample rates available}
{sample sizes available}
{current sample size}

siTwosComplementOnOff

=

'twos';

{two's

siVoxRecordiInfo

=

'voxr';

{VOX

record

siVoxStopInfo

=

'voxs';

{VOX

stop

of

recording}

interrupt

options

buffer}

dialog

status}

box}

state}

complement

state}

parameters}

parameters}

The format of the relevant data (either returned by the Sound Manager or provided by you)
depends on the selector you provide. For example, if you want to determine the name of
some sound input device, you can pass the siDeviceName selector and a pointer to a 256-byte
buffer to the SPBGetDevicelnfo function. If SPBGetDevicelInfo can get the information, it
fills that buffer with the name of the specified sound input device. Listing 22-19 illustrates
one way you can determine the name of a particular sound input device.
Listing 22-19.
FUNCTION

DeviceName

Determining the name of a sound input device

(myInRefNum:

LongInt;

VAR

dName:

Str255)

:

OSErr;

VAR

myErr:

OSErr;

BEGIN

myErr
:= SPBGetDeviceInfo(myInRefNum,
DeviceName
:= myErr;

siDeviceName,

Ptr(dName)
) ;

END;

Some selectors cause SPBGetDevicelInfo to return data of other types. Listing 22-20 illustrates how to determine the number of channels, the sample rate, the sample size, and the
compression type currently in use by a given sound input device. The procedure defined in
Listing 22-20 is called in the procedure defined in Listing 22-18.
Listing 22-20. Determining some sound input device settings
PROCEDURE

GetDeviceSettings

(myInRefNum:
Integer;

VAR

sampleSize:

LongInt;

VAR

sampleRate:
Integer;

VAR

numChannels:
Fixed;

OSType) ;

VAR

myErr:

OSErr;

BEGIN

{get

number

myErr

:=

of

active

channels}

SPBGetDeviceInfo(myInRefNum,

siNumberChannels,

Ptr(@numChannels)
);

22-64

Using the Sound Manager

VAR

compressionType:

The Sound Manager

{get

sample

myErr

:=

{get

sample

myErr

:=

rate}

SPBGetDeviceInfo(myInRefNum,
siSampleRate,
Ptr(@sampleRate)
);
size}

SPBGetDeviceInfo(myInRefNum,

siSampleSize,

Ptr (@sampleSize)
);
{get

compression

myErr

:=

type}

SPBGetDeviceInfo(myInRefNum,

siCompressionType,

Ptr (@compressiontType)
);
END;

Some other selectors return a list of items, which your application must interpret. Table 22-5
lists the available selectors together with the size and meaning of the associated information
whose address is passed or returned in the infoData parameter. Note that all of the selectors
returning a handle will allocate the memory for that handle in the current heap zone; you are
responsible for disposing of that handle when you are done with it.
Table

22-5.

Sound input device information selectors

bh

Selector

Description

'age |

Gets or sets the current state of the automatic gain control feature.
infoData
Integer
0 if off, | if on

‘asyn'

2
=
=
2.
—

=<
—

Determines if driver supports asynchronous recording functions. Some sound
input drivers might support synchronous recording only.
infoData
Integer
0 if synchronous calls only, | otherwise

‘chac'

Gets or sets the channels to record from. When setting the active channels, the
data passed in is a long integer that is interpreted as a bitmap describing the
channels to record from. For example, if bit 0 is set, then the first channel is
made active. The samples for each active channel are stored one after another
in the application’s buffer. When reading the active channels, the data returned
is a bitmap of the active channels.
infoData
LongInt
bitmap of active channels

‘chan'

Gets or sets the number of channels this device is to record.
infoData
Integer
number of channels

'chav'

Gets the maximum number of channels this device can record.
infoData
Integer
number of available channels

‘cmav'

Gets the number and list of compression types this device can produce.
infoData
Integer
number of compression types supported
Handle
list of compression types (each is OSType, 4 bytes)

‘cmfa'

Gets the number of samples per byte at the current compression setting.
infoData
Integer
compression factor

‘emhd'

Gets a compression header for the current recording settings. Your application
passes in a pointer to a compressed sound header and the driver fills it in. Before
calling SPBGetDevicelnfo with this selector, you should set the numFrames
field of the compressed sound header to the number of bytes in the sound.
When SPBGetDevicelnfo returns successfully, that field contains the number
(Continued)

Using the Sound Manager

— 22-65

rt)

=i]
i)@

“

Inside Macintosh,

Table

22-5.

Volume VI

Sound input device information selectors (Continued)

Selector

Description

‘cmhd'
(continued)

of sample frames in the sound. This selector is needed only by drivers that use
compression types that are not directly supported by Apple. If you call this
selector after recording a sound, your application can get enough information
about the sound to play it or save it in a file.
infoData
Pointer
pointer to a compressed sound header

‘comp'

Gets or sets the compression type. Some devices allow the incoming samples to
be compressed before being placed in your application’s input buffer.
infoData
OSType
compression type

‘cont’

Gets or sets the state of continuous recording from this device. If continuous
recording is being turned on, the driver records samples into an internal buffer
between calls to SPBRecord. This allows a subsequent recording to begin where
the previous one stopped. If continuous recording is being turned off, the driver
stops recording samples to its internal buffer.
infoData

Integer

state of continuous recording (0 is off, 1 is on)

‘dbin'

Gets the size of the device’s internal buffer. This information can be useful

‘dcon'

Gets the state of the device connection.

when you want to modify sound input data at interrupt time.
infoData
LongInt
size of device’s internal buffer

infoData

Integer

one of the following values:

CONST
siDeviceIsConnected
siDeviceNotConnected

=
=

1;
0;

{device
{device

is
is

siDontKnowlfConnected

=

-1;

{can't

tell

connected
and ready}
not connected}
if

device

connected}

‘icon'

Gets the device’s icon and icon mask.
infoData
Handle
icon and icon mask

‘Imac'

Gets the current signal level for each active channel. Each value returned is

"lmet'

Gets or sets the current state of the level meter. Once the level meter has been
turned on, calling SPBGetDevicelnfo returns a value in the level meter setting
that ranges from 0 (no volume) to 255 (full volume).
infoData
Integer
state of level meter (0 is off, | is on)

an integer, and the number of values returned depends on the number of
active channels. You can determine how many channels are active by calling
SPBGetDevicelnfo with the 'chan' selector.
infoData
Integer
level meter setting

Integer

‘name'

22-66

level meter setting

Gets the name of the sound input device. Your application must pass a pointer to
a buffer that will be filled in with the device’s name. The buffer needs to be large
enough to hold a Str255 data type.
infoData
Pointer
pointer to buffer for name of device

— Using the Sound Manager

The Sound Manager

Table

22-5.

Sound input device information selectors (Continued)

Selector

Description

‘optd'

Gets or sets the Options dialog box feature. The Options dialog box is designed to
allow the user to configure device-specific features of the sound input hardware.
Note that no argument should be supplied when you pass this selector to
SPBSetDevicelnfo.
infoData
Integer
| if device supports options, 0 otherwise

‘pith’

Gets or sets the current play-through volume.

‘qual’

Gets or sets the current quality of recorded sound. Currently three qualities are
supported: ‘good’, 'betr', and ‘best’.
infoData
OSType
recording quality

‘srat’

Gets or sets the sample rate to be produced by this device. The sample rate must
be in the range 0 to 65535.99998 Hz. Note that the sample rate is declared as a
Fixed data type, but the most significant bit is not treated as a sign bit: instead,
that bit is interpreted as having the value 32,768.
infoData
Fixed
sample rate

infoData

Integer

volume (0 is off, 1—7 otherwise)

"srav'

Gets the range of sample rates this device can produce. The first 2 bytes of the
information returned specify how many different sample rates the device
supports. If that number is 0, then the next two sample rates define a continuous
range of sample rates. Otherwise, a list is returned that contains the sample rates
supported. Each sample rate is of type Fixed and occupies 4 bytes. Note that the
sample rates are declared as Fixed data types, but their most significant bit is not
treated as a sign bit; instead, that bit is interpreted as having the value 32,768.
infoData
Integer
number of sample rates
Handle
list of sample rates

"ssav'

Gets the range of sample sizes supported by this device. The first 2 bytes of
the information returned specify how many different sample sizes the device
supports. A list is returned that contains the sample sizes supported. Each
sample size is an integer and occupies 2 bytes.
infoData
Integer
number of sample sizes
Handle
list of sample sizes

"SS1Z'

Gets or sets the sample size to be produced by this device. Because some
compression formats require specific sample sizes, this selector may return
an error when compression is used.
infoData
Integer
sample size

'twos'

Gets or sets the current state of the two’s complement feature.
infoData
Integer
| if two’s complement output desired, 0 otherwise

‘voxr’

Gets or sets the current VOX record parameters. The first 2 bytes of the infoData
parameter indicate whether VOX recording is on or off. The next 2 bytes contain
the VOX record trigger value. Trigger values range from 0 to 255 (0 is trigger
immediately, 255 is trigger only on full volume).
infoData
Integer
O if off, 1 if on
Integer
record trigger value
(Continued)

Using the Sound Manager

— 22-67

nN
N
7 2)

S)
=
=
2.
<—
yD
=
fn
ge
fo)
ar

Inside Macintosh,

Table

22-5.

Volume VI

Sound input device information selectors (Continued)

Selector

Description

'VOxs'

Gets or sets the current VOX stop parameters. The first 2 bytes of the infoData
parameter indicate whether VOX stopping is on or off. The next 2 bytes contain
the VOX stop trigger value. Trigger values range from 0 to 255 (255 is stop
immediately, 0 is stop only on total silence). The final 2 bytes indicate how
many milliseconds the trigger value must be continuously valid for recording to
be stopped. Delay values range from 0 to 65,535.
infoData
Integer
0 if off, 1 if on
Integer
record trigger value
Integer
delay value

Obtaining

Information

About

Sound

Features

Developments in the sound hardware available on Macintosh computers and in the Sound
Manager routines that allow you to drive that hardware have made it imperative that your
application pays close attention to the sound-related features of the operating environment.
For example, the routines that provide continuous play from disk operate only on machines
that are equipped with an Apple Sound Chip that have the enhanced Sound Manager. So
before issuing any play-from-disk calls, you should check to make sure that the target
machine provides the features you need.
Similarly, the ability to have multiple channels of sound open simultaneously makes it
important that you monitor the load placed on the CPU by those channels. The enhanced
Sound Manager provides several new routines that you can use to determine information
about open sound channels and the amount of CPU loading they create.
To make appropriate decisions about the sound you want to produce, you may need to know
some or all of the following types of information:
m whether the machine can produce stereophonic sounds
m whether the internal speaker mixes both right and left channels of sound
m whether the sound input routines and hardware are available
m whether multiple channels of sound are supported
= how much CPU load is produced by a single channel of sound or by all channels
of sound
m whether the system beep has been disabled
=» how much of the available processing power a new channel of sound would consume
a whether a sound playing from disk is active or paused
ms how many channels of sound are currently open

22-68

— Using the Sound Manager

The Sound Manager

To determine how much of the available processing power a new channel of sound would
consume, you can use the loadCmd sound command, described earlier in “Managing the
CPU Load.” The following sections describe how to use the Gestalt function and new Sound
Manager routines to determine these other types of information.

Obtaining

Information

About

Available

Sound

Features

You can use the Gestalt function with the gestaltSoundAttr selector to determine whether
various new Sound Manager capabilities are present (for example, whether the machine can
produce stereophonic sounds and whether it can mix both left and right channels of sound
on the external speaker). Currently, Gestalt returns a bit field that may have some or all of
the following bits set:
CONST

gestaltStereoCapability
gestaltStereoMixing

=
=-

0;
1;

{stereo
{stereo

capability
present}
mixing
on internal
speaker}
input

gestaltSoundIOMgrPresent

=

3;

{sound

gestaltBuiltInSoundInput

=

4;

{built-in

gestaltHasSoundInputDevice

=

5;

{sound

routines

input

input

available}

device

device

available}

available}

nN

Ss)
v2

=

If the bit gestaltStereoCapability is TRUE, the available hardware can play stereo sounds.
The bit gestaltStereoMixing indicates that the sound hardware of the machine mixes both left
and right channels of stereo sound into a single audio signal for the internal speaker. The
gestaltSoundIOMgrPresent bit indicates that the new sound input routines are available, and
the gestaltBuiltInSoundInput bit indicates that a built-in sound input device is available. The
gestaltHasSoundInputDevice bit indicates that some sound input device is available.

Obtaining

Version

Information

The Sound Manager provides functions that allow you to determine the version numbers of
the Sound Manager itself and of two distinct subsets of the Sound Manager routines, the
MACE compression and expansion routines and the sound input routines. Generally, you
should avoid trying to determine which features or routines are present by reading a version
number. Usually, the Gestalt function discussed in the previous section provides a better way
to find out if some set of features, such as sound input capability, is available. In some cases,
however, you can use these version routines to overcome current limitations of the information returned by Gestalt.
All three of these functions return a value of type NumVersion that contains the same
information as the first 4 bytes of a resource of type 'vers'. The first and second bytes
contain the major and minor version numbers, respectively; the third and fourth bytes contain
the release level and the stage of the release level. For most purposes, the major and minor
release version numbers are sufficient to identify the version. (See the Finder Interface
chapter in this volume for a complete discussion of the format of 'vers' resources.)
You can use the SndSoundManagerVersion function to determine which version of the
Sound Manager is present. The Sound Manager provided with system software
version 6.0.7 and later contains the routines supporting multichannel sound, play from
disk, and channel status inquiries.

Using the Sound Manager

—_22-69

=
Qo.

<—
)
=)
f°
ge
ic
“

Inside Macintosh,

Volume VI

You can use the MACEVersion function to determine the version number of the available
MACE routines (for example, Comp3to!).

You can use the SPBVersion function to determine the version number of the available sound
input routines (for example, SndRecord). If SPBVersion returns a value that is greater than
0, then the sound input routines are available.

Obtaining

Information

About a Single Sound

Channel

You can use the SndChannelStatus function to obtain information about a single sound channel
and about the status of a disk-based playback on that channel, if one exists. For example, you
can use SndChannelStatus to determine if a channel is being used for play from disk, how
many seconds of the sound have been played, and how many seconds remain to be played.
One of the parameters required by the SndChannelStatus function is a pointer to a soundchannel status record, which you must allocate before calling SndChannelStatus. A
sound-channel status record has this structure:
TYPE

SCStatus

=

RECORD
scStartTime:

Fixed;

{starting

scEndTime:

Fixed;

{ending

scCurrentTime:
scChannelBusy:

Fixed;
Boolean;

{current
{TRUE if

scChannelDisposed:

Boolean;

{reserved}

scChannel
scUnusea:

Boolean;
Boolean;

{TRUE
if
{unused}

scChannelAttributes:

LongInt;

{attributes

scCPULoaad:

Longint

{CPU

Paused:

time
time

load

for
for

play

play

from
from

disk}

disk}

time for play from disk}
channel
is making sound}
channel
of
for

is
this

this

paused}
channel}
channel}

END;

Field

descriptions

scStartTime

If seChannelBusy is TRUE, then scStartTime is the starting time in
seconds for a play from disk on the specified channel. If
scChannelBusy is FALSE, then scStartTime is 0.

scEndTime

If secChannelBusy is TRUE, then scEndTime is the ending time in
seconds for a play from disk on the specified channel. If
scChannelBusy is FALSE, then scEndTime is 0.

scCurrentTime

If seChannelBusy is TRUE, then scCurrentTime is the current time in
seconds for a play from disk on the specified channel. If
scChannelBusy is FALSE, then scCurrentTime is 0.

scChannelBusy

If the specified channel is currently making sound, then
scChannelBusy is TRUE; otherwise, scChannelBusy is FALSE.

scChannelDisposed

Reserved for use by Apple.

scChannelPaused

If the specified channel is paused, then scChannelPaused is TRUE;
otherwise, scChannelPaused is FALSE.

22-70

~~ Using the Sound Manager

The Sound Manager

scUnused

Reserved for use by Apple.

scChannelAttributes

The current attributes of the specified channel. These attributes are in
the channel initialization parameters format.

scCPULoad

The CPU load for the specified channel.

You can mask out certain values in the scChannelAttributes field to how a channel has been
initialized.
CONST

initPanMask
initSRateMask

=
=

$0003;
$0030;

{mask
{mask

for
for

right/left pan values}
sample rate values}

initStereoMask

=

$00C0;

{mask

for

mono/stereo

values}

initCompMask

=

SFFOO;

{mask

for

compression

IDs}

Listing 22-21 illustrates the use of the SndChannelStatus function. It defines a function that
takes a sound-channel pointer as a parameter and determines whether a disk-based playback
on that channel is paused.
Listing 22-21.
FUNCTION

Determining whether a sound channel is paused

ChannelIsPaused

(chan:

SndChannelPtr)

:

Boolean;

VAR

')
Ss)
D
=)
=
a
4
89
|
6
ga
et

myErr:

OSErr};

mySCStatus:

SCStatus;

@

BEGIN
ChannelIsPaused
:= FALSE;
myErr
:= SndChannelStatus
IF

myErr
= nokrr THEN
ChannelIsPaused
:=

(chan,

Sizeof(SCStatus),

@mySCStatus) ;

mySCStatus.scChannelPaused;

END;

The function defined here simply reads the scChannelPaused field to see if the playback is
currently paused.

Obtaining

Information

About All Sound

Channels

You can use the SndManagerStatus function to determine information about all the sound
channels that are currently allocated by all applications. For example, you can use this
function to determine how many channels are currently allocated.
One of the parameters required by the SndManagerStatus function is a pointer to a Sound
Manager status record, which you must allocate before calling SndManagerStatus. A
Sound Manager status record has this structure:
TYPE

SMStatus
PACKED

=
RECORD

smMaxCPULoad:
smNumChannels:

Integer;
Integer;

{maximum
load on all
{number of allocated

channels}
channels}

smCurCPULoad:

Integer

{current

channels}

load

on

all

END;

Using the Sound Manager

—_ 22-71

Inside Macintosh,

Field

Volume VI

descriptions

smMaxCPULoad

The maximum load that the Sound Manager will not exceed when
allocating channels. The smMaxCPULoad field is set to a default
value of 100 when the system starts up.

smNumChannels

The number of sound channels that are currently allocated by all
applications. This does not mean that the channels allocated are being
used, only that they have been allocated and that CPU loading is
being reserved for these channels.

smCurCPULoad

The CPU load that is being taken up by currently allocated channels.

Listing 22-22 illustrates the use of SndManagerStatus. It defines a function that returns the
number of sound channels currently allocated by all applications.
Listing 22-22.
FUNCTION

Determining the number of allocated sound channels

NumChannelsAllocated

:

Integer;

VAR

myErr:

OSErr;

mySMStatus:
BEGIN

SMStatus;

NumChannelsAllocated
myErr
IF

:=

myErr

:=

0;

SndManagerStatus
=

noErr

(Sizeof(SMStatus),

@mySMStatus) ;

THEN

NumChannelsAllocated

:=

mySMStatus.smNumChannels;

END;

Using Double Buffers
The play-from-disk routines make extensive use of the SndPlayDoubleBuffer function.
You can use this function in your application if you wish to bypass the normal play-fromdisk routines. You might want to do this if you wish to maximize the efficiency of your
application while maintaining compatibility with the Sound Manager. By using
SndPlayDoubleBuffer instead of the normal play-from-disk routines, you can specify
your own doubleback procedure (that is, the algorithm used to switch back and forth
between buffers) and customize several other buffering parameters.
Note: SndPlayDoubleBuffer is a very low-level routine and is not intended for
general use. You should use SndPlayDoubleBuffer only if you require very fine
control over double buffering.
You call SndPlayDoubleBuffer by passing it a pointer to a sound channel (into which the
double-buffered data is to be written) and a pointer to a sound double-buffer header. Here’ s
an example:
myErr

22-72

:=

SndPlayDoubleBuffer

Using the Sound Manager

(mySndChan,

@myDoubleHeader) ;

The Sound Manager

A SndDoubleBufferHeader record has the following structure:
TYPE

SndDoubleBufferHeader
PACKED

=

RECORD

adbhNumChannels:

Integer;

{number

of

dbhSampleSize:

Integer;

{sample

size,

dbhCompressionID:

Integer;

{ID

dbhPacket Size:
adbhSampleRate:

Integer;
Fixed;

{number
{sample

dbhBufferPtr:

ARRAY[0..1]

OF

of

ProcPtr

channels}

if

uncompressed}

compression
of bits
rate}

per

algorithm}
packet}

SndDoubleBufferPtr;

{pointers
dpbhDoubleBack:

sound

{pointer

to
to

SndDoubleBuffer}
doubleback

procedure}

END;

Field

descriptions

dbhNumChannels
dbhSampleSize

Indicates the number of channels for the sound (1 for monophonic
sound, 2 for stereo).

N
i)

Indicates the sample size for the sound if the sound is not compressed.
If the sound is compressed, dbhSampleSize should be set to 0.
Samples that are 1-8 bits have a dbhSampleSize value of 8; samples
that are 9-16 bits have a dbhSampleSize value of 16. Currently, only
8-bit samples are supported. For further information on sample sizes,
refer to the AIFF specification.

dbhCompressionID

Indicates the compression identification number of the compression
algorithm, if the sound is compressed. If the sound is not compressed,
dbhCompressionID should be set to 0.

dbhPacketSize

Indicates the packet size for the compression algorithm specified by
dbhCompressionID, if the sound is compressed.

dbhSampleRate

Indicates the sample rate for the sound. Note that the sample rate is
declared as a Fixed data type, but the most significant bit is not treated
as a sign bit; instead, that bit is interpreted as having the value 32,768.

dbhBufferPtr

Indicates an array of two pointers, each of which should point to a
valid SndDoubleBuffer record.

dbhDoubleBack

Points to the application-defined routine that is called when the double
buffers are switched and the exhausted buffer needs to be refilled.

The values for the dbhCompressionID, dbhNumChannels, and dbhPacketSize fields are the
same as those for the compressionID, numChannels, and packetSize fields of the compressed
sound header, respectively.
The dbhBufferPtr array contains pointers to two records of type SndDoubleBuffer. These are
the two buffers between which the Sound Manager switches until all the sound data has been
sent into the sound channel. When the call to SndPlayDoubleBuffer is made, the two buffers
should both already contain a nonzero number of frames of data.

Using the Sound Manager

—_22-73

DM
=
=
=
a

4

—

a
=)
a
ve
&

Inside Macintosh,

Volume VI

Here is the structure of a sound double buffer:
TYPE

SndDoubleBuffer

=

PACKED RECORD
dbNumFrames:

LongInt;

{number

of

abFlags:

LongInt;

{buffer

status

dbUserInfo:

ARRAY[0..1]

dbSoundData:

PACKED

OF

LongInt;

ARRAY[0..0]

OF

{for

frames

in

buffer}

flags}

application's

use}

Byte
{array

of

data}

END;

Field

descriptions

dbNumFrames

The number of frames in the dbSoundData array.

dbFlags

Buffer status flags.

dbUserInfo

Two long words into which you can place information that you need
to access in your doubleback procedure.

dbSoundData

A variable-length array. You write samples into this array, and the
synthesizer reads samples out of this array.

The buffer status flags field for each of the two buffers may contain either of these values:
dbBufferReady

nou

CONST

dbLast Buffer

$00000001;
$00000004;

All other bits in the dbFlags field are reserved by Apple, and your application should not
modify them.
The following two sections illustrate how to fill out these data structures, create your two
buffers, and define a doubleback procedure to refill the buffers when they become empty.

Setting

Up Double

Buffers

Before you can call SndPlayDoubleBuffer, you need to allocate two buffers (of type
SndDoubleBuffer), fill them both with data, set the flags for the two buffers to
dbBufferReady, and then fill out a record of type SndDoubleBufferHeader with the
appropriate information. Listing 22-23 illustrates how you might accomplish these tasks.
Listing 22-23.

Setting up double buffers

CONST
kDoubleBufferSize

=

4096;

TYPE

LocalVarsPtr

22-74

=

“LocalVars;

— Using the Sound Manager

{size

of

each

buffer

(in

bytes) }

The Sound Manager

LocalVars

=

{variables

used

by

doubleback

proc}

RECORD
bytesTotal:
bytesCopied:

Longint;
LongIint;

{total
number
of samples}
{number
of samples
copied

dataPtr:

Ptr

{pointer

to

sample

to

to

buffers}

copy}

END;

{This

function

FUNCTION

uses

SndPlayDoubleBuffer

DBSndPlay

(chan:

to

SndChannelPtr;

play

the

sndHeader:

sound

specified.}

SoundHeaderPtr)

OSErr;

VAR
myVars:
GoubleHeader:

LocalVars;
SndDoubleBufferHeader;

GoubleBuffer:
status:

SndDoubleBufferPtr;
SCStatus;

i:

Integer;

err:

OSErr;

BEGIN

{set up myVars with
initial
information}
myVars.bytesTotal
:= sndHeader*.length;
myVars.bytesCopied
myVars.dataPtr

:=

:=

0;

nN
Nm

{no

samples

up

SndDoubleBuf

GoubleHeader.dbhSampleSize

1;

8;

GoubleHeader.dbhCompressionID

:=

to

{one

channel}

{8-bit
0;

{no

compression}

{no

compression}

:=

0;

doubleHeader.dbhSampleRate

:=

sndHeader*.sampleRate;

doubleHeader.dbhDoubleBack

:=

@MyDoubleBackProc;

0

TO

1

BO

oe

samples}

GoubleHeader.dbhPacketSize

:=

sample}

~~

oe

:=

:=

i

first

ZN
~~
—
—os
on)
2.
a
Lmel
as
—
es
po)
tjo

ferHeader}

doubleHeader.dbhNumChannels

FOR

yet}

Ptr(@sndHeader*.sampleArea[0]);
{pointer

{set

copied

{initialize

both

@
“

buffers}

BEGIN

{get memory
for
GoubleBuffer
:=

double buffer}
SndDoubleBufferPtr(NewPtr(Sizeof(SndDoubleBuffer)

IF

=

+

kDoubleBufferSize)
) ;
doubleBuffer

NIL

THEN

BEGIN

DBSndPlay

:=

MemError;

DoError;
END;

doubleBuffer*.dbNumFrames
:=
doubleBuffer*.dbFlags
:= 0;

0;

doubleBuffer*.dbUserInfo[0]

:=

{fill

buffer

with

buffer

LongInt

(@myVars)

yet}
empty}

;

samples}

MyDoubleBackProc(sndChan,
{store

{no frames
{buffer
is

pointer

in

doubleBuffer) ;
header}

dGoubleHeader.dbhBufferPtr[i]

:=

doubleBuffer;

END;
(Continued)

Using the Sound Manager

—_.22-75

Inside Macintosh,

Volume VI

Listing 22-23.

Setting up double buffers (Continued)

{start
err
:=

the sound playing}
SndPlayDoubleBuffer(sndChan,

IF

<>

err

noErr

@doubleHeader) ;

THEN

BEGIN

DBSndPlay

:=

err;

sound

to

DoError;
END;

{wait

for

the

complete

by

watching

the

channel

status}

REPEAT

err
UNTIL

:=

SndChannelStatus(chan,

NOT

status.scChannelBusy;

{dispose

double-buffer

FOR.

0

1.

+=

TO

DisposPtr
DBSndPlay

:=

1

sizeof(status),

@status) ;

memory}

DO

(Ptr(doubleHeader.dbhBufferPtr[i]));
noErr;

END;

The function DBSndPlay takes two parameters, a pointer to a sound channel and a pointer to
a sound header. It reads the sound header to determine the characteristics of the sound to be
played (for example, how many samples are to be sent into the sound channel). Then
DBSndPlay fills in the fields of the double-buffer header, creates two buffers, and starts the
sound playing. The doubleback procedure MyDoubleBackProc is defined in the next section.

Writing

a Doubleback

Procedure

The dbhDoubleBack field of a double-buffer header specifies the address of a doubleback
procedure, an application-defined procedure that is called when the double buffers are
switched and the exhausted buffer needs to be refilled. The doubleback procedure should
have this format:
PROCEDURE

MyDoubleBackProc

(chan:

SndChannelPtr;

exhaustedBuffer:

SndDoubleBufferPtr) ;

The primary responsibility of the doubleback procedure is to refill an exhausted buffer of
samples and to mark the newly filled buffer as ready for processing. Listing 22-24 illustrates
how to define a doubleback procedure. Note that the sound-channel pointer passed to the
doubleback procedure is not used in this procedure.
This doubleback procedure extracts the address of its local variables from the dbUserInfo
field of the double-buffer record passed to it. These variables are used to keep track of how
many total bytes need to be copied and how many bytes have been copied so far. Then the
procedure copies at most a buffer-full of bytes into the empty buffer and updates several
fields in the double-buffer record and in the structure containing the local variables. Finally,

if all the bytes to be copied have been copied, the buffer is marked as the last buffer.

22-76

Using the Sound Manager

The Sound Manager

Note: Because the doubleback procedure is called at interrupt time, it cannot make
any calls that move memory either directly or indirectly. (Despite its name, the
BlockMove procedure does not cause blocks of memory to move or be purged, so
you can safely call it in your doubleback procedure, as illustrated in Listing 22-24.)
Listing 22-24.
PROCEDURE

MyDoubleBackProc

Defining a doubleback procedure
(chan:

SndChannelPtr;

doubleBuffer:

SndDoubleBufferPtr) ;
VAR
myVarsPtr:

LocalVarsPtr;

bytesToCopy:
BEGIN
{get

LongInt;

pointer

myVarsPtr
{get

to

:=

my

local

variables}

LocalVarsPtr

number

of

bytes

bytesToCopy

:=

myVarsPtr®.bytesTotal

{If

the

amount

left

(doubleBuffer*.dbUserInfo[0]);

left

{ then
limit
the
IF bytesToCopy
>
bytesToCopy

:=

is

to

copy}

greater

than

-

myVarsPtr®.bytesCopied;

double-buffer

number
of bytes
to copy
kDoubleBufferSize
THEN

to

the

size,
size

nN
nN

}

of

the

buffer. }

<
—

kDoubleBufferSize;

f
=]
&

{copy
samples
to double
buffer}
BlockMove (myVarsPtr®.dataPtr,
@doubleBuffer®.dbSoundData[0],
bytesToCopy) ;
number

of

samples

in

doubleBuffer®.dbFlags
{update

data

pointer

myVarsPtr®.dataPtr

:=

and

mark

buffer

as

number

of

bytes

:=

{If all
samples
have been
IF myVarsPtr* .bytesCopied
doubleBuffer®.dbFlags

Lene |

ready}

dbBufferReady) ;

copied}

Ptr(ORD4(myVarsPtr®.dataPtr)

myVarsPtr®.bytesCopied

@

bytesToCopy;

BOR(doubleBuffer®*.dbFlags,

and
:=

buffer
:=

ge

myVarsPtr®.bytesCopied

+
+

bytesToCopy) ;

bytesToCopy;

copied,
then
this
is the last
myVarsPtr*.bytesTotal
THEN

buffer. }

it

{store

doubleBuffer*.dbNumFrames

BOR (doubleBuffer*.dbFlags,

dbLastBuffer);

END;

Specifying

Callback

ZN
o
=
~
2.

Routines

The SndNewChannel function allows you to associate a completion routine or callback procedure with a sound channel. This procedure is called whenever a callBackCmd command is
received by the synthesizer linked to that channel, and the procedure can be used for various
purposes. Generally, your application uses a callback procedure to determine that the channel
has completed its commands and to arrange for disposal of the channel. The callback procedure cannot itself dispose of the channel because it may execute at interrupt time. A callback

Using the Sound Manager

— 22-77

Inside Macintosh,

Volume VI

procedure can also be used to signal that a channel has reached a certain point in the queue.
Your application may wish to perform particular actions based on how far along the sequence
of commands a channel has processed. This allows you, for example, to synchronize sound
output with other actions in the computer.
A callback procedure has the following syntax:
PROCEDURE

MyCallBack

(chan:

SndChannelPtr;

cmd:

SndCommand) ;

When called, the procedure is passed two parameters—a pointer to the sound channel that
received the callBackCmd command and the sound command that caused the callback
procedure to be called. Applications can use param or param2 of the sound command as
flags to pass information or instructions to the callback procedure. If a callback procedure is
to use an application’s global data storage, it must first reset A5 to the application’s A5 and
then restore it on exit. For example, Listing 22-25 illustrates how to set up a callBackCmd
command that contains the required A5 information. The InstallCallBack function defined
there must be called at a time when the application’s A5 world is known to be valid.
Listing 22-25.
FUNCTION

InstallCallBack

Issuing a callback command

(mySndChan:

SndChannelPtr)

:

OSErr;

CONST
kWaitIfFull

=

TRUE;

{wait

for

room

in

queue}

VAR

mySndCmd:
BEGIN
mySndCmd.cmd

SndCommana;
:=

callBackCmd;

{install

the

mySndCmd.paraml

:=

kSoundComplete;

{last

command

mySndCmd.param2

:=

SetCurrentA5;

{pass

the

SndDoCommand

InstallCallBack

(mySndChan,

callback
for

this

callback

the

mySndCmd,

command}
channel}
A5}

kWaitIfFull);

END;

In this function, kSoundComplete is an application-defined global constant that indicates that
the requested sound has finished playing. You could define it like this:
CONST

kSoundComplete

=

1;

{sound

is

done

playing}

Because param2 of a sound command is a long integer, you can use it to pass the application’s AS to the callback procedure. That allows the callback procedure to gain access to the
application’s A5 world. The sample callback procedure defined in Listing 22-26 can set A5
to access the application’s global variables when the synthesizer receives this command.
Here, the callback procedure simply sets a global variable that indicates that the callback
procedure has been called. The application can then read that variable to determine that it can
safely dispose of the corresponding sound channel. The functions SetCurrentA5 and SetA5
are documented in the Memory Management chapter in this volume.
Note: These callback routines are called at interrupt time and therefore must not
attempt to allocate, move, or dispose of memory, dereference an unlocked handle, or
call other routines that do so.

22-78

— Using the Sound Manager

The Sound Manager

Listing 22-26.
PROCEDURE
VAR
myA5:

SampleCallBack

Defining a callback procedure

(theChan:

SndChannelPtr;

theCmd:

SndCommand) ;

Longint;

BEGIN
IF

(theCmd.paraml

=

kSoundComplete)

THEN

SetA5(theCmd.param2);

{set

my

A5}

{set

a

global

flag}

the

current

BEGIN

myA5

:=

gCallBackPerformed
myA5

:=

:=

TRUE;

SetA5(myA5);

{restore

A5}

END;

END;

Assembly-language note: A callback procedure is a Pascal procedure and
must preserve all registers other than AO-Al and DO—D2.
nN
nN

SOUND

MANAGER

N
S
om
=
a
2

ROUTINES

—

SN)

This section describes the routines you use to play 'snd ' resources, allocate new sound
channels and dispose of old ones, send sound commands to a synthesizer, play sounds
directly from disk, balance CPU loading during sound production, determine the status of
sound channels, and manage the reading and writing of sound double buffers.
This section also describes the routines you can use to record sound on machines equipped
with some sound input hardware. The Sound Manager provides two general classes of sound
input routines, a set of high-level routines for recording and storing sound input from the
user, and a set of low-level routines. Most applications should be able to accomplish all
sound input by using just the high-level routines. The low-level routines are provided
primarily for applications that need more control over the recording process or that need to
intercept sound input data at interrupt time. There are also low-level routines that are intended
for use by sound input drivers.

Playing

Sound

Resources

You can use the SndPlay function to play the sounds that are stored in an 'snd ' resource,
either format | or format 2. You can use the SysBeep procedure to play the system alert
sound. Alert sounds are stored in the System file as format | 'snd ' resources. The user
selects an alert sound in the Sound control panel. The default alert sound is a simple beep.
SndPlay and SysBeep are the highest-level sound routines and are generally used separately
from the other Sound Manager routines. Depending on the needs of your application, you
may be able to accomplish all desired sound-related activity simply by using SysBeep to
produce the system alert sound or by using SndPlay to play other sounds that are stored as
‘snd ' resources.
Sound Manager Routines

— 22-79

=
m
Ge

&
“

Inside Macintosh,

FUNCTION

Volume VI

SndPlay

(chan:

SndChannelPtr;

sndHdl:

Handle;

async:

Boolean)

SndPlay attempts to play the sound located at sndHdl, which is expected to have the structure
of a format | or format 2 'snd ' resource. If the sound handle is in format | and specifies a

synthesizer, then the appropriate 'snth' resource is loaded into memory and linked to the

channel. All commands and data contained in the sound handle are then sent to the channel.
Note that you can pass SndPlay a handle to some data created by calling SndRecord as well
as a handle to an actual 'snd' resource that you have loaded into memory.
The chan parameter is a pointer to a sound channel. If your application passes NIL as the
channel pointer, the Sound Manager creates a channel in your application’s heap. The Sound
Manager releases this memory after the sound has completed. If your application passes NIL as
the sound-channel pointer, the async parameter is ignored and the sound plays synchronously.
If, however, your application does supply a sound-channel pointer in the chan parameter,
then the sound can be produced asynchronously. When a sound is played asynchronously,
a completion routine can be called when the last command has finished processing. This
procedure is the callback procedure supplied to SndNewChannel.
If a format | 'snd' resource does not specify which synthesizer is to be used, SndPlay
defaults to the square-wave synthesizer. SndPlay also supports format 2 'snd ' resources
using the sampled sound synthesizer and a bufferCmd command. Note that to use SndPlay
and the sampled sound synthesizer with a format | 'snd' resource, you must include a
bufferCmd command in the resource.
Result codes

noErr
resProblem
badChannel
badFormat

PROCEDURE

SysBeep

0
-—204
-—205
-206

No error
Problem loading the resource
Channel is corrupt or unusable
Resource is corrupt or unusable

(duration:

Integer) ;

The SysBeep procedure causes the Sound Manager to play the system alert sound selected
in the Sound control panel. The duration parameter specifies the duration (in ticks) of the
resulting sound and is used only on a Macintosh Plus, Macintosh SE, or Macintosh Classic
when the system alert sound is the Simple Beep. In all other cases, the duration parameter is
ignored, but you must specify it when you call this procedure.
The volume of the sound produced depends on the setting of the current speaker volume,
which the user can adjust in the Sound control panel. If the speaker volume has been set to 0
(silent) and the system alert sound is enabled, SysBeep causes the menu bar to blink once.
PROCEDURE

SndGetSysBeepState

(VAR

sysBeepState:

Integer);

SndGetSysBeepState is used to determine whether SysBeep is enabled. It returns one of
two states in the sysBeepState parameter, either the sysBeepDisable or the sysBeepEnable
constant.
22-80

= Sound Manager Routines

The Sound Manager

FUNCTION

SndSetSysBeepState
is

(sysBeepState:

Integer)
Gg

:

OSErr;

You can use SndSetSysBeepState to set the state of the system alert sound. The sysBeepState
parameter should be set to either sysBeepDisable or sysBeepEnable.
Result codes
noErr
paramErr

Allocating

0)
—50

and

No error
A parameter is incorrect

Releasing

Sound

Channels

You can allocate a new sound channel by using the SndNewChannel function.
FUNCTION

SndNewChannel

(VAR

chan:

init:

SndChannelPtr;

LongInt;

synth:

userRoutine:

Integer;

ProcPtr)

:

OSErr;
nN

nN

If you pass a pointer to NIL as the chan parameter, SndNewChannel allocates a soundchannel record in your application’s heap and returns a pointer to that record. Applications
that allocate their own channel memory can pass a pointer to a sound-channel record in the
chan parameter. Each channel holds 128 commands as a default size. Your application can
allocate a channel that is larger or smaller than the default size by creating its own channel
in memory.
The synth parameter specifies which playback synthesizer is to be used. You specify a
synthesizer by its resource ID, and this 'snth' resource is loaded into memory and linked
to the channel. To create a channel without linking it to a synthesizer, pass 0 as the synth
parameter. In general, however, you should specify a nonzero value in the synth parameter
to ensure that CPU load tests are performed and hence that you can actually produce sound
in the new channel.
The init parameter specifies an initialization option that should be sent to the synthesizer when
you open the channel. For example, to open the third wave-table channel, use initChan2 as
the init parameter. Only the wave-table synthesizer and sampled sound synthesizer currently
use the init options. To determine if a particular option is understood by the synthesizer, use
the availableCmd command with the SndControl function.
If your application produces sounds asynchronously or needs to be alerted when a command
has completed, define a callback procedure and pass a pointer to that procedure in the
userRoutine parameter. This routine is called once the synthesizer has received the callBackCmd
command. If you pass NIL as the userRoutine parameter, then any callBackCmd commands
are ignored.
Result codes

noErr
resProblem
badChannel

0
—204
—205

No error
Problem loading the resource
Channel is corrupt or unusable

Sound Manager Routines

— 22-81

A
=

=
=

2
—

Sy)

=

ey

ge

©
=

Inside Macintosh,

Volume VI

To release the memory previously allocated to a sound channel that is no longer needed, call
SndDisposeChannel.
FUNCTION

SndDisposeChannel

(chan:

SndChannelPtr;

quietNow:

Boolean)

OSErr;

The SndDisposeChannel function disposes of the channel specified in the chan parameter and
releases all memory allocated by the Sound Manager for that channel. If your application
created its own sound-channel record in memory or installed a sound as a voice, the Sound
Manager does not dispose of that memory.
SndDisposeChannel can dispose of a channel immediately or wait until the queued commands
are processed. If quietNow is set to TRUE, a flushCmd command and then a quietCmd
command are sent to the channel. This removes all commands, stops any sound in progress,
and closes the channel. If quietNow is set to FALSE, then the Sound Manager issues a
quietCmd command only and waits until the quietCmd command is received by the synthesizer before disposing of the channel.
Result codes
noErr
badChannel

0)
-—205

No error
Channel is corrupt or unusable

Linking Synthesizers to Sound

Channels

The Sound Manager uses the SndAddModifier function to link synthesizers to sound channels.
FUNCTION

SndAddModifier

(chan:

SndChannelPtr;

Integer;

init:

modifier:

LongInt)

:

ProcPtr;

id:

OSErr;

SndAddModifier installs a synthesizer into an open channel specified in the chan parameter.
The modifier parameter should be NIL, and the id parameter is the resource ID of the synthesizer. SndAddModifier causes the Sound Manager to load the 'snth' resource, lock it in
memory, and link it to the channel specified.
Note: SndAddModifier is for internal Sound Manager use only. You should not call
it in your application.
Result codes
noErr

resProblem
badChannel

Sending

0)

No error

—204
—205

Commands

Problem loading the resource
Channel is corrupt or unusable

to a Sound

Channel

Once a sound channel is opened and linked to a particular synthesizer, you can send
commands to that synthesizer by issuing requests with the SndDoCommand and
SndDoImmediate functions.
FUNCTION

SndDoCommand

(chan:

SndChannelPtr;

Boolean)

22-82

Sound Manager Routines

:

OSErr;

cmd:

SndCommand;

noWait:

The Sound Manager

The SndDoCommand function sends the sound command specified in the cmd parameter to
the command queue of the channel specified in the chan parameter. If the noWait parameter is
set to FALSE and the queue is full, the Sound Manager waits until there is space to add the
command. If noWait is set to TRUE and the channel is full, the Sound Manager does not
send the command and returns the queueFull result code.
Result codes

noErr
queueFull
badChannel

0
—-—203
-—205

No error
No room in the queue
Channel is corrupt or unusable

The SndDoImmediate function operates much like SndDoCommand, except that it bypasses
the existing command queue of the sound channel and sends the specified command directly
to the synthesizer. This routine also overrides any waitCmd, pauseCmd, or syncCmd
commands that may have already been received by the synthesizer.
FUNCTION

SndDoImmediate

(chan:

SndChannelPtr;

cmd:

SndCommand)

:

OSErr;

The chan parameter is a pointer to a sound channel. The requested command is specified in
the cmd parameter. Unlike SndDoCommand, SndDoImmediate loops indefinitely when you
pass it a freqDurationCmd command. To cause the sound to play for the specified duration,
send a quietCmd command into the channel.
Result codes
noErr
badChannel

0)
—205

No error
Channel is corrupt or unusable

Table 22-6 lists the sound commands that you can send using SndDoCommand,
SndDoImmediate, or (in several cases) SndControl.

Table

22-6.

Sound commands

Command

Description

ampCmd

Changes the amplitude (or loudness) of a sound. If no sound is
currently playing, then ampCmd sets the amplitude of the next sound
to be played. The amplitude is sent in param! and should be an integer
in the range 0 to 255. You can send ampCmd to any of the available
synthesizers.
param |
desired amplitude
param2
_O (ignored on input and output)

availableCmd

Determines if the initialization parameters passed in param2 are supported by the synthesizer to which this command is sent. The result is
returned in param 1; the result is | if the synthesizer supports the desired
characteristics and 0 if it does not. You can send availableCmd to any of
the available synthesizers, but you must send it by using SndControl.
param |
0 on input; result of command on output
param2 _ initialization parameters
(Continued)

Sound Manager Routines

— 22-83

nN
nN
2)
©
=
=
ios
4
—
fo
=
po
ti
©
ses |

Inside Macintosh,

Table

22-6.

Volume VI

Sound commands (Continued)

Command

Description

bufferCmd

Plays a buffer of sampled sound data. If the high bit of the command is
set, param? is interpreted as an offset from the beginning of the 'snd '
resource containing the command to the sound data. If the high bit is
not set, param2 is interpreted as a pointer to the sound data. You can
send bufferCmd only to the sampled sound synthesizer.
param |
0 (ignored on input and output)
param2
offset or pointer to sound data

callBackCmd

Executes the callback procedure specified as a parameter to
SndNewChannel. Both param! and param2 are application-specific;
you can use these two parameters to send data to your callback
routine. You can send callBackCmd to any of the available synthesizers.
param |
application-defined
param2
—_application-defined

flushCmd

Removes all commands currently queued in the specified sound
channel. A flushCmd command does not affect any sound that is
currently in progress. You can send flushCmd to any of the available
synthesizers, but you should send it by using SndDoImmediate.
param |
() (ignored on input and output)
param2 — () (ignored on input and output)

freqCmd

Changes the frequency (or pitch) of a sound. If no sound is currently
playing, then freqCmd causes the synthesizer linked to the specified
channel to begin playing indefinitely at the frequency specified in
param?2. If, however, the channel is linked to the wave-table or sampled
sound synthesizer and no instrument is installed in the channel, no
sound is produced. The param2 parameter must contain a value
in the range 0 to 127. The freq¢Cmd command is identical to the
freqDurationCmd command, except that no duration is specified to a
freqCmd command. You can send freqCmd to any of the available
synthesizers.
param |
0 (ignored on input and output)
param2
desired frequency

freqDurationCmd

Plays the frequency specified in param2 for the duration specified in
param1|. The param2 parameter must contain a value in the range 0 to 127.
You can send freqDurationCmd to any of the available synthesizers.
param |

param2

duration in half-milliseconds (0 to 32,767)

desired frequency

getAmpCmd

Determines the current amplitude (or loudness) of a sound. The amplitude is returned in an integer variable whose address you pass in
param2 and is in the range 0 to 255. You can send getAmpCmd to any
of the available synthesizers.
param |
0 (ignored on input and output)
param2
pointer to amplitude variable

getRateCmd

Determines the sample rate of the sampled sound currently playing. The
current rate of the channel is returned in a Fixed variable whose address
you pass in param2 of the sound command. You can send getRateCmd

22-84

Sound Manager Routines

The Sound Manager

Table

22-6.

Command

Sound commands

(Continued)

Description
only to the sampled sound synthesizer, but you should send it by using
SndDolmmediate.
param!
0 (ignored on input and output)
param2
pointer to rate variable

loadCmd

Determines the CPU load factor that would be incurred by a new
channel of sound having the initialization parameters specified in
param2. The load factor returned in param1| is the percentage of CPU
processing power that the specified sound channel would require. You
can send loadCmd to any of the available synthesizers. You should
send loadCmd using SndControl.
param |
0 on input, load factor on output
param2 _ initialization options

nullCmd

Does nothing. You can send nullCmd to any of the available synthesizers.
param |
0 (ignored on input and output)
param2
_() (ignored on input and output)

pauseCmd

Pauses any further command processing in a channel until resumeCmad is
received. You can send pauseCmd to any of the available synthesizers.
param |
0 (ignored on input and output)
param2
_—_() (ignored on input and output)

quietCmd

Stops the sound that is currently playing. You can send quietCmd to
any of the available synthesizers, but you should send it by using
SndDolmmediate.
param |
0 (ignored on input and output)
param2
_() (ignored on input and output)

rateCmd

Sets the rate (or pitch) of a sampled sound that is currently playing. The
new pitch is set to the value specified in param2. You can send rateCmd
only to the sampled sound synthesizer.
param |
0 (ignored on input and output)
param2
desired rate of sound

reInitCmd

Resets the initialization parameters specified in param2 for the specified
channel. You can send reInitCmd to any of the available synthesizers.
param |
0 (ignored on input and output)
param2
initialization options

restCmd

Rests a channel for a specified duration. The duration is specified in
half-milliseconds in param!. You can send restCmd to any of the
available synthesizers.
param |

param2
resumeCmd

duration in half-milliseconds (0 to 32,767)

_() (ignored on input and output)

Resumes command processing in a channel that was previously paused by
pauseCmd. You can send resumeCmd to any of the available synthesizers.
param |
0 (ignored on input and output)
param2
_() (ignored on input and output)
(Continued)

Sound Manager Routines

— 22-85

bh
i)
72)
o
=
=}
2.

<4
—_

&
~
a
ge

@
er |

Inside Macintosh,

Table

22-6.

Volume VI

Sound commands

(Continued)

Command

Description

soundCmd

Installs a sampled sound as a voice in a channel. If the high bit of the
command is set, param2 is interpreted as an offset from the beginning
of the 'snd ' resource containing the command to the sound data. If the
high bit is not set, param? is interpreted as a pointer to the sound data.
You can send soundCmd only to the sampled sound synthesizer.
param |
0 (ignored on input and output)
param2
offset or pointer to sound data

syncCmd

Synchronizes multiple channels of sound. A syncCmd command is held
in the specified channel, suspending all further command processing.
The param2 parameter contains an identifier that is arbitrary. Each time
the Sound Manager receives syncCmd, it decrements the count
parameter for each channel having that identifier. When the count for
a specific channel reaches 0, command processing in that channel
resumes. You can send syncCmd to any of the available synthesizers.
param |
count
param2 __ identifier

timbreCmd

Changes the timbre (or tone) of the sound currently being played by the
square-wave synthesizer. You can send timbreCmd only to the squarewave synthesizer.
param |
desired timbre (0 to 255)
param2 __ () (ignored on input and output)

totalLoadCmd

Determines the total CPU load factor for all existing sound activity and
for anew sound channel having the initialization options specified in
param2. You can send totalLoadCmd to any of the available
synthesizers. You should send totalLoadCmd using SndControl.
param!
(on input, load factor on output
param2 _ initialization options

versionCmd

Determines which version of the specified synthesizer is available. The
result is returned in param2. The high word of the result indicates the
major revision number, and the low word indicates the minor revision
number. For example, version 2.0 of a synthesizer would be returned
as $00020000. You can send versionCmd to any of the available
synthesizers, but you must send it by using SndControl.
param |
0 (ignored on input and output)
param2
_() on input; version of synthesizer on output

waitCmd

Suspends further command processing in a channel until the specified
duration has elapsed. You can send waitCmd to any of the available
synthesizers.
param! — duration in half-milliseconds (0 to 65,535)
param2
_() (ignored on input and output)

waveTableCmd

Installs a wave table as a voice in the specified channel. The param 1
parameter specifies the length of the wave table, and the param2
parameter is a pointer to the wave-table data itself. You can send
waveTableCmd only to the wave-table synthesizer.
param |
length of wave table
param2
pointer to wave-table data

22-86

Sound Manager Routines

The Sound Manager

Obtaining

Information

You can obtain information about a sound channel and about the Sound Manager itself
by calling the SndControl, SndChannelStatus, and SndManagerStatus functions. You
can obtain the version numbers of the Sound Manager, the MACE tools, and the sound
input routines by calling the SndSoundManagerVersion, MACEVersion, and SPBVersion
functions, respectively.
Note:

You can call all of the functions documented in this section at interrupt time

except SndControl (because it may need to load a resource into memory).

FUNCTION

SndControl

(id:

Integer;

VAR

cmd:

SndCommand)

:

OSErr;

The SndControl function sends control commands directly to a synthesizer specified by its
resource ID. This can be called even if no channel has been created for the synthesizer. This
control function is used with availableCmd or versionCmd to request information about a
synthesizer. You can also use the totalLoadCmd and loadCmd commands with SndControl to
determine the sound-related CPU load factor. The requested information is returned in the
cmd parameter.

iS)
Nn
7 2)

°

=

Result code
noErr

=

a.

()

No error

You can use SndChannelStatus to determine the status of a Sound Manager sound channel.
FUNCTION

SndChannelStatus

(chan:
SndChannelPtr;
theLength:
Integer;
theStatus:
SCStatusPtr)
: OSErr;

The chan parameter should be a pointer to a valid sound channel. The parameter theLength
should be the size in bytes of the status structure that theStatus points to. The parameter
theStatus should be a pointer to an SCStatus structure. On successful completion of the call,
the fields of that structure contain the information about the specified sound channel.
Result codes

noErr
paramErr
badChannel

0
—50
—205

No error
A parameter is incorrect
Channel is corrupt or unusable

You can use SndManagerStatus to determine information about the Sound Manager.
FUNCTION

SndManagerStatus

(theLength:

Integer;

theStatus:

SMStatusPtr)

OSErr};

The parameter theLength should be the size in bytes of the SMStatus structure. The parameter
theStatus is a pointer to an SMStatus structure, which is filled out with the status information.
Result code
noErr

()

No error

Sound Manager Routines

— 22-87

ma
—_—
)
=
oy
Vi)
@
er

Inside Macintosh,

Volume V1

You can use SndSoundManagerVersion to determine the version of the Sound Manager tools
available on a machine.
FUNCTION

SndSoundManagerVersion

:

NumVersion;

SndSoundManagerVersion returns a version number that contains the same information as in
the first 4 bytes of a 'vers' resource.
You can use MACEVersion to determine the version of the MACE
machine.
FUNCTION

MACE

MACEVersion

Version

:

tools available on a

NumVersion;

returns a version number that contains the same information as in the first

4 bytes of a 'vers’ resource.

You can use SPBVersion to determine the version of the sound input tools available on
a machine.
FUNCTION

SPBVersion

:

NumVersion;

SPBVersion

returns a version number that contains the same information as in the first

Playing

From

4 bytes of a 'vers' resource.

Disk

Use the SndStartFilePlay, SndPauseFilePlay, and SndStopFilePlay functions to manage a
continuous play from disk.
FUNCTION

SndStartFilePlay

(chan:
resNum:

SndChannelPtr;
Integer;

fRefNum:

Integer;

bufferSize:

LongIint;

theBuffer:
Ptr; theSelection:
AudioSelectionPtr;
theCompletion:
async:

Boolean)

:

ProcPtr;

OSErr;

SndStartFilePlay is used to initiate continuous play from disk on a sound channel. The chan
parameter is a pointer to a sound channel. If chan is not NIL, it is used as a valid channel. If
chan is NIL, an internally allocated sound channel is used for play from disk. This internally
allocated sound channel is not passed back to you. Since the other two play-from-disk
routines require a sound-channel pointer, you must allocate your own channel if you wish to
use those routines.
The sounds you wish to play can be stored either in a file or in an 'snd ' resource. If you are
playing a file, then fRefNum should be the file reference number of the file to be played, and
the parameter resNum should be set to 0.
If you are playing an 'snd ' resource, then fRefNum should be set to 0, and resNum should
be the resource ID number (not the file reference number) of the resource to play. Both
format | and format 2 'snd' resources are supported.
22-88

Sound Manager Routines

The Sound Manager

The bufferSize parameter contains the number of bytes of memory that the Sound Manager
is to use for input buffering while reading in sound data. If theBuffer is a NIL pointer, then
the Sound Manager internally allocates two relocatable blocks, each of which is half the size
of bufferSize; otherwise, theBuffer should be a pointer to a nonrelocatable block of size

bufferSize.

If theSelection is a NIL pointer, then the entire sound is played; otherwise, theSelection
should point to an audio selection record. You use that record to specify the segment of the
sound to be played.
The theCompletion parameter is a pointer to a routine that is called when the sound is finished
playing. Set theCompletion to NIL if you do not wish to specify a completion routine. The
completion routine should be declared like this:
PROCEDURE

MyFilePlayCompletionRoutine

(chan:

SndChannel
Ptr) ;

This routine is called at interrupt time and must preserve all registers other than DO—D2 and
AOQ-A1. In addition, it must not make any calls to the Memory Manager, either directly or
indirectly. If your completion routine needs to access your application’s global variables,
you must ensure that register A5 contains your application’s A5. (You can use the userInfo
field of the sound channel pointed to by the chan parameter to pass that value to your completion routine.)

If the async parameter is TRUE, then the call is made asynchronously; otherwise, the call is
synchronous.

Result codes

noErr
notEnoughHardwareErr
queueFull
badChannel
badFormat
notEnoughBufferSpace
badFileFormat
channelBusy
buffersTooSmall
silnvalidCompression

Note:

)
=
=)
Qu

=&

—]
iS)
tf)

(a)

QO
~201
—203
—205
—206
—207
—208
—209
—210
—223

Noerror
Insufficient hardware available
Noroom in the queue
Channel is corrupt or unusable
Resource is corrupt or unusable
Insufficient memory available
File is corrupt or unusable
Channel is busy
Buffer is too small
Invalid compression type

SndStartFilePlay allocates memory so it cannot be called at interrupt level.

SndPauseFilePlay

7 2)

Lear |

You can use SndPauseFilePlay alternately to suspend and resume asynchronous play from disk.
FUNCTION

nN
i)

(chan:

SndChannelPtr)

:

OSErr;

SndPauseFilePlay is used in conjunction with SndStopFilePlay to control play from disk on
a sound channel. Note that this call can be made only if your application has already called
SndStartFilePlay with a valid sound channel. This function cannot be used with a synchronous SndStartFilePlay because, by definition, program control does not return to the caller
until after the sound has completely finished playing.

Sound Manager Routines

— 22-89

Inside Macintosh,

Volume VI

The chan parameter should be a pointer to a valid sound channel. If the channel is not being
used for play from disk, then SndPauseFilePlay returns the result code channelNotBusy.
If the channel is busy and paused, then play from disk is resumed. If the channel is busy and
the channel is not paused, then play from disk is suspended.
Result codes

noErr
queueFull
badChannel
channelNotBusy

Note:

0
—203
—205
-211

Noerror
Noroom in the queue
Channel is corrupt or unusable
Channel not currently used

You can call SndPauseFilePlay at interrupt time.

You can use SndStopFilePlay to stop an asynchronous play from disk.
FUNCTION

SndStopFilePlay

(chan:

SndChannelPtr;

async:

Boolean)

:

OSErr;

The chan parameter should be a pointer to a valid sound channel. If the async parameter is
TRUE, then the play from disk stops as soon as possible, and program control returns to
your application. All asynchronous file I/O calls will have completed, and any internally
allocated memory will have been released. If async is FALSE, then SndStopFilePlay lets the
sound complete normally and returns only after the sound has completed, all asynchronous
file I/O calls have completed, and any internal allocated memory has been released.
Note:

You can call SndStopFilePlay at interrupt time.

Result codes
noErr
badChannel

Managing

Double

0
—205

Noerror
Channel is corrupt or unusable

Buffers

SndPlayDoubleBuffer is a low-level routine that gives you maximum efficiency and control
over double buffering while still maintaining compatibility with the Sound Manager.
FUNCTION

SndPlayDoubleBuffer

(chan:

SndChannelPtr;

theParams:

SndDoubleBufferHeaderPtr)

:

OSErr;

The chan parameter is a pointer to a valid sound channel. The parameter theParams is a
pointer to a SndDoubleBufferHeader record.
Result codes
noErr

badChannel

22-90

Q

—205

Noerror

Channel is corrupt or unusable

Sound Manager Routines

The Sound Manager

Compressing

and

Expanding

Audio

Data

You can use the procedures Comp3tol and Comp6to! to compress sounds, and you can use
the procedures Exp|to3 and Exp1|to6 to expand compressed audio data. The procedures
Comp3tol and Comp6to! compress a sound at ratios of 3:1 and 6:1, respectively.
PROCEDURE

Comp3tol

(inBuffer:

Ptr;

inState:
Ptr;
whichChannel:
PROCEDURE

Comp6tol

(inBuffer:

Ptr;

inState:
Ptr;
whichChannel:

outBuffer:
outState:
LongInt);
outBuffer:
outState:
LongInt) ;

Ptr;
Ptr;

Ptr;
Ptr;

cnt:

LongInt;

numChannels:

cnt:

LongInt;

LongInt;

numChannels:

LongInt;

The inBuffer parameter is a pointer to a buffer of samples to be compressed. The samples
must be in 8-bit offset binary format. The outBuffer parameter is a pointer to a buffer where
the samples are to be written. This buffer must be greater than or equal to cnt/6 bytes for
6:1 compression and cnt/3 bytes for 3:1 compression. The cnt parameter is the number of
samples to compress.
The inState parameter is a pointer to a buffer from which the input state of the algorithm is
read. To initialize the algorithm, this buffer should be filled with zeros. The size of the buffer
should be 128 bytes for both algorithms.
The outState parameter is a pointer to a buffer to which the output state of the algorithm is
written. The size of the buffer should be 128 bytes for both algorithms. The inState and
outState parameters may point to the same buffer.
The numChannels parameter is the number of channels in the buffer pointed to by the
inBuffer parameter. It is assumed that if numChannels is greater than 1, then the uncompressed sound is stored in interleaved format on a sample basis.
The whichChannel parameter is used to specify which channel to expand when numChannels
is greater than 1. When numChannels is set to 1, whichChannel is unused. Acceptable values
of the whichChannel parameter range from | to numChannels.
Note: The output stream that is produced by these two compression routines is
always monophonic, regardless of the value you pass in the numChannels parameter.
The procedures Exp1to3 and Exp1|to6 expand a sound that was previously compressed at
ratios of 3:1 and 6:1, respectively.
PROCEDURE

Explto3

(inBuffer:
inState:

PROCEDURE

Exp1to6

Ptr;

outBuffer:

Ptr;

outState:

whichChannel:

LongInt);

(inBuffer:
inState:

Ptr;
Ptr;

cnt:

LongInt;

numChannels:

LongInt;

Ptr;
outBuffer:
Ptr;
cnt:
LongInt;
Ptr;
outState:
Ptr;
numChannels:
LongInt;

whichChannel:

LongInt) ;

Sound Manager Routines

— 22-91

nN
hn

”
=)
=
=
3
Ka
s
=
ga

pd

~

@

2 |

Inside Macintosh,

Volume V1

The inBuffer parameter is a pointer to a buffer of packets to be expanded. The samples must
be in 8-bit offset binary format. The outBuffer parameter is a pointer to a buffer where the
expanded samples will be written. This buffer must be at least cnt * 6 bytes in size for both
3:1 and 6:1 expansion.
The cnt parameter is the number of packets to expand. The packet size for 3:1 is 2 bytes;
therefore one packet of 3:1 expands into 6 bytes. The packet size for 6:1 is | byte; therefore,
one packet of 6:1 expands into 6 bytes.
The inState parameter is a pointer to a buffer from which the input state of the algorithm is
read. To initialize the algorithm, this buffer should be filled with zeros. The size of the buffer
should be 128 bytes for both algorithms.
The outState parameter is a pointer to a buffer to which the output state of the algorithm is
written. The size of the buffer should be 128 bytes for both algorithms. The inState and
outState parameters may point to the same buffer.
The numChannels parameter is the number of chaanels in the buffer pointed to by the
inBuffer parameter. It is assumed that if numCharinels is greater than 1, then the compressed
sound is stored in interleaved format on a packet |asis.
The whichChannel parameter is used to specify which channel to expand when numChannels
is greater than 1. When numChannels is set to 1, whichChannel is unused. Acceptable values
of the whichChannel parameter range from 1 to numChannels.
Note: The output stream that is produced by these expansion routines is always
monophonic, regardless of the value you pass in the numChannels parameter.

Recording

Sounds

The Sound Manager provides two high-level sound input routines, SndRecord and
SndRecordToFile, for recording sound. These input routines are analogous to the two
output routines SndPlay and SndStartFilePlay. By using these high-level routines, you
can be assured that your application will present 2 user interface that is consistent with that
displayed by other applications doing sound inpu:. Both SndRecord and SndRecordToFile
attempt to record sound data from the sound inpu' hardware currently selected in the Sound
control panel.
The SndRecord function records sound into memory. The recorded data has the structure of a
format | 'snd ' resource and can later be played using SndPlay or can be stored as a resource.
FUNCTION

SndRecord

(filterProc:
VAR

ProcPtr;

sndHandle:

Hanc.le)

corner:
:

Point;

quality:

OSType;

OSErr;

SndRecord displays a sound input dialog box and is always called synchronously. Controls
in the dialog box allow the user to start, stop, pause, and resume sound recording, as well as
to play back the recorded sound. The dialog box iilso lists the amount of time remaining to
record and the current microphone sound level.

22-92

Sound Manager Routines

The Sound Manager

The filterProc parameter determines how user actions in the dialog box are filtered (and hence
is similar to the filterProc parameter specified in a call to ModalDialog). By specifying your
own filter procedure, you can override or add to the default actions of the items in the dialog
box. If filterProc isn’t NIL, SndRecord filters events by calling the procedure that filterProc

points to.

The corner parameter gives the horizontal and vertical coordinates of the upper-left corner of
the dialog box (in global coordinates).
The quality parameter defines the desired quality of the recorded sound. Currently, three
values are recognized for the quality parameter: ‘good’, 'betr', and 'best'. The precise
meanings of these parameters are dependent on the sound input driver. For Apple-supplied
drivers, this parameter determines whether the recorded sound is to be compressed, and if so,
whether at a 6:1 or a 3:1 ratio. A quality of 'best' does not compress the sound and provides
the best quality output, but at the expense of memory. The quality 'betr' is suitable for most
nonvoice recording, and 'good' is suitable for voice recording.
The sndHandle parameter is a handle to some storage space. You must pass in either a valid
handle or NIL. If sndHandle is NIL, the Sound Manager allocates the largest amount of
space in the application’s heap that it can and then resizes the handle when the user clicks the
Save button in the sound input dialog box. If the sndHandle parameter passed to SndRecord
is not NIL, the recording time is derived from the amount of memory reserved by the handle.
Result codes

noErr
userCanceledErr
siBadSoundInDevice
siUnknownQuality

<

0
—128
—221
—232

£9
=}
oy
te
o

No error
User canceled the operation
Invalid sound input device
Unknown quality

er

You can use SndRecordToFile to record sound data into a file. SndRecordToFile operates
exactly like SndRecord except that it stores the sound input data into a file. The resulting file
is in either AIFF or AIFF-C format and contains the information necessary to play the file by
using SndStartFilePlay. SndRecordToFile is always called synchronously.
FUNCTION

SndRecordToFile

(filterProc:
OSType;

ProcPtr;

fRefNum:

corner:

Integer)

:

Point;

quality:

OSErr;

The filterProc, corner, and quality parameters are identical to those provided to SndRecord.
The fRefNum parameter indicates the file reference number of an open file to save the audio
data in. (In other words, your application must first open the file with write access, pass the
returned file reference number to SndRecordToFile, and eventually close the file.) If the
audio data to be recorded into a file is uncompressed, then SndRecordToFile writes a file of
type AIFF. If the data is compressed, SndRecordToFile writes a file of type AIFF-C.
Result codes

noErr
userCanceledErr
siBadSoundInDevice
siUnknownQuality

bo
Ss)
n
=
=
—¥

0
—128
—221
-—232

No error
User canceled the operation
Invalid sound input device
Unknown quality

Sound Manager Routines

— 22-93

Inside Macintosh,

Volume VI

Manipulating

Sound

Input Devices

The Sound Manager provides a number of routines for use by sound input drivers or by
applications that need more control over the recording process (such as the ability to intercept
sound input data at interrupt time). These routines allow low-level recording to memory or to
a file, configuration of recording parameters, and monitoring of the recording status.

Opening

and Closing Sound

Input Devices

You can open and close sound input devices by calling SPBOpenDevice and
SPBCloseDevice. You must open a device before you can record from it by using
SPBRecord.
FUNCTION

SPBOpenDevice

(deviceName:
inRefNum:

Str255;
LongInt)

permission:
:

Integer;

VAR

OSErr;

The SPBOpenDevice function attempts to open a sound input device having name deviceName.
If the call succeeds, it returns a device reference number in inRefNum. The permission
parameter indicates whether subsequent operations with that device are to be read/write
or read-only. If the device is not already in use, read/write permission is granted; otherwise,
only read-only operations are allowed. To make any recording calls or to call
SPBSetDevicelnfo, read/write permission must be available.
You can request that the current default sound input device be opened by passing either a
zero-length string or a NIL string as the deviceName parameter. If only one sound input
device is installed, that device is used. Generally you should open the default device unless
you specifically want to use some other device. You can get a list of the available devices
by calling SPBGetIndexedDevice.
Result codes

noErr

0

permErr

siBadDeviceName

FUNCTION

SPBCloseDevice

—54

-—228
(inRefNum:

No error

Attempt to open locked file for writing
Invalid device name
LongInt)

:

OSErr;

The SPBCloseDevice function closes a device that was previously opened by
SPBOpenDevice.
Result codes
noErr
siBadRefNum

Recording

Sounds

0
—229

No error
Invalid reference number

Directly From

Sound

Input Devices

The Sound Manager provides a number of routines that allow you to begin, pause, resume,
and stop recording directly from a sound input device. (These low-level routines do not
present the sound input dialog box to the user.)
22-94

Sound Manager Routines

The Sound Manager

You can use the SPBRecord function to record audio data into memory, either synchronously
or asynchronously.
FUNCTION

SPBRecord

(inParamPtr:

SPBPtr;

asynchFlag:

Boolean)

:

OSErr;

Parameter block
=>

0

inRefNum

long

input device reference number

o

4

count

long

number of bytes to record

o

8

milliseconds

long

number of milliseconds to record

>

12

bufferLength

long

length of buffer

>

16

bufferPtr

long

address of buffer

~

20

completionRoutine

long

pointer to completion routine

~

24

interruptRoutine

long

pointer to interrupt routine

>

28

userLong

long

for application’s use

-

32

error

word

error returned after recording

_

36

unused |

long

reserved

The SPBRecord function starts recording into memory from a specified device. The sound
data recorded is simply stored in the buffer indicated, so it is up to your application to insert
whatever headers are needed to play the sound with the Sound Manager. The asynchFlag
parameter specifies whether the recording occurs asynchronously.
SPBRecord accepts a sound input parameter block to control the recording process. The
inRefNum field of the parameter block should contain the reference number of the device to
record from. The count field contains the number of bytes to record and the milliseconds
field contains the number of milliseconds to record. If one of these fields specifies a longer
recording time than the other, then the longer time is used and both fields are updated to
reflect the actual amount recorded.
The bufferPtr field points to the buffer to record into, and the bufferLength field gives the
length (in bytes) of that buffer. The recording times given in the count and milliseconds fields
are always truncated to the size of this buffer, if necessary. If the bufferPtr field contains
NIL, then the count, milliseconds, and bufferLength fields are ignored, and the recording
continues indefinitely until you call SPBStopRecording. If bufferPtr is NIL, the audio data is
not saved anywhere; this feature is useful only if you want to do something in your interrupt
routine and do not want to save the audio data. If the recording is synchronous and bufferPtr
is NIL, SPBRecord returns the result code siNoBufferSpecified.
The completion routine specified in the completionRoutine field is called when the recording
terminates (either when you call SPBStopRecording or when the prescribed limit is reached).
The completion routine is called only for asynchronous recording.
The interrupt routine specified in the interruptRoutine field is called by asynchronous
recording devices when their internal buffers are full.
You can set the userLong field to any value. The error field contains a value greater than 0
while recording occurs. When recording terminates without an error, the error field is set
to 0. If an error occurs during the recording, the error field will contain a value that is less
than 0 and is of type OSErr.
Sound Manager Routines

— 22-95

tw
tS)
a
=
=
a.
S
f
=
iy
ge
—

ic)

Lar |

Inside Macintosh,

Volume VI

Note: If more than one channel is being recorded, the samples are interleaved into
the buffer.
Result codes

noErr
siNoSoundInHardware
siBadSoundInDevice
siNoBufferSpecified
siDeviceBusyErr

0
—220
—221
—222
—227

No error
No sound input hardware available
Invalid sound input device
No buffer specified
Sound input device is busy

You can use the SPBRecordToFile function to record audio data into a file, either
synchronously or asynchronously.
FUNCTION

SPBRecordToFile

(fRefNum:

Integer;

asynchFlag:

Parameter block
=>
0

inParamPtr:

Boolean)

:

SPBPtr;

OSErr;

inRefNum

long

input device reference number

oO

4

count

long

number of bytes to record

oO

8

milliseconds

long

number of milliseconds to record

>

20

completionRoutine

long

pointer to completion routine

>

24

interruptRoutine

long

pointer to interrupt routine

>

28

userLong

long

for application’s use

ce

32

error

word

error returned after recording

=>

36

unused |

long

reserved

The SPBRecordToFile function starts recording from a specified device into a file. The sound
data recorded is simply stored in the file, so it is up to your application to insert whatever
headers are needed to play the sound with the Sound Manager. The fRefNum parameter must
contain a valid reference number for an open file. (In other words, your application must first
open the file with write access, pass the returned file reference number to SPBRecordToFile,
and eventually close the file.) The asynchFlag parameter specifies whether the recording occurs

asynchronously. The fields in the parameter block specified by the inParamPtr parameter are

identical to the fields in the parameter block passed to SPBRecord, except that the bufferLength
and bufferPtr fields are not used. The interruptRoutine field is ignored by SPBRecordToFile,
but you should initialize it to NIL.
SPBRecordToFile writes samples to disk in the same format that they are read in from
the sound input device. If compression is enabled, then the samples written to the file
are compressed.

If any errors occur during file writes, recording is suspended. All File Manager errors
are returned through the function’s return value if the routine is called synchronously. If
the routine is called asynchronously and the completion routine is not NIL, the completion
routine is called and is passed a single parameter on the stack that points to the sound input
parameter block; any errors are returned in the error field of the sound input parameter block.
The error field in the sound input parameter block is | while input is active, 0 when input is
complete, and less than 0 if an error occurs.
22-96

Sound Manager Routines

The Sound Manager

Result codes

noErr
permErr
siNoSoundInHardware
siBadSoundInDevice
siHardDriveTooSlow

FUNCTION

0)
—54
-220
—221
-224

SPBPauseRecording

No error
Attempt to open locked file for writing
No sound input hardware available
Invalid sound input device
Hard drive too slow to record

(inRefNum:

LongInt)

:

OSErr;

The SPBPauseRecording function pauses recording from the device specified by the inRefNum
parameter. The recording must be asynchronous for this call to have any effect.
Result codes
noErr

siBadSoundInDevice

FUNCTION

(0)

No

—221

SPBResumeRecording

error

Invalid sound input device

(inRefNum:

LongInt)

:

OSErr;

nN
nN
ZN

The SPBResumeRecording function resumes recording from the device specified by the
inRefNum parameter. The recording must be asynchronous for this call to have any effect.
Result codes
noErr

siBadSoundInDevice

FUNCTION

SPBStopRecording

—221

0

:

OSErr;

The SPBStopRecording function stops recording from the device specified by the inRefNum
parameter. The recording must be asynchronous for this call to have any effect. When you call
SPBStopRecording, the completion routine specified in the completionRoutine field of the sound
input parameter block is called and the error field of that parameter block is set to abortErr.
Result codes
noErr
siBadSoundInDevice

—221

0)

No error
Invalid sound input device

You can use SPBGetRecordingStatus to obtain recording status information about a sound
input device.
FUNCTION

SPBGetRecordingStatus

<4
nl

is)

Invalid sound input device
LongInt)

—=

—)

lol
jas

+)
~
=
ge

No error

(inRefNum:

—)

-

(inRefNum:
LongInt;
VAR recordingStatus:

Integer;

VAR
VAR

meterLevel:
Integer;
totalSamplesToRecord:

VAR

numberOfSamplesRecorded:

VAR

totalMsecsToRecord:

VAR

numberOfMsecsRecorded:

Longint;
LongInt;

LongIint;
LongInt)

OSErr;

Sound Manager Routines

22-97

Inside Macintosh,

Volume VI

The inRefNum parameter contains the reference number of a sound input device. While the
input device is recording, recordingStatus is greater than 0. When the recording terminates
without an error, recordingStatus is equal to 0. If any error occurs during the recording,
recordingStatus is less than 0 and contains an error code. If the recording is terminated by
calling SPBStopRecording, then recordingStatus contains the abortErr result code.
The meterLevel parameter gives the current input signal level. Values returned are in the range
0 to 255.
The totalSamplesToRecord and numberOfSamplesRecorded parameters give an indication of
how many samples have been recorded out of the total to record. The totalMsecsToRecord

and numberOfMsecsRecorded parameters likewise give an indication of how much time has
been recorded out of the total to record.
Result codes
noErr
siBadSoundInDevice

Manipulating

Device

—221

0

No error
Invalid sound input device

Settings

You can use the two functions SPBGetDeviceInfo and SPBSetDeviceInfo to read and change
the settings of a sound input device.
FUNCTION

SPBGetDeviceInfo

(inRefNum:
infoData:

LongInt;
infoType:
Ptr)
: OSErr;

OSType;

The SPBGetDevicelInfo function returns information about the sound input device specified
by the inRefNum parameter. The type of information you desire is specified in the infoType
parameter. The information is copied into infoData as an address to the appropriate data.
Result codes

noErr
siBadSoundInDevice
siUnknownInfoType

FUNCTION

SPBSetDeviceInfo

—221
—231

0

No error
Invalid sound input device
Unknown type of information

(inRefNum:

LongInt;

infoData:

Ptr)

:

infoType:

OSType;

OSErr;

The SPBSetDevicelnfo function sets information in the device specified in the inRefNum
parameter. The infoType parameter is a selector that specifies the type of information you
want to set, and infoData provides a pointer to the data. A number of selectors are defined by
Apple (listed in “Getting and Setting Sound Input Device Information” earlier in this chapter).
Third-party devices can support additional selectors to allow applications to control special
features available on that hardware.

22-98

Sound Manager Routines

The Sound Manager

Result codes

noErr
permErr
siBadSoundInDevice
siDeviceBusyErr
siUnknownInfoType

Constructing

Sound

0
—54
—22]
—227
—23]

Resource

No error
Attempt to open locked file for writing
Invalid sound input device
Sound input device is busy
Unknown type of information

and

File Headers

The Sound Manager provides two functions, SetupSndHeader and SetupAIFFHeader, to
help you set up headers for 'snd' resources and AIFF files.
FUNCTION

SetupSndHeader

(sndHandle:
sampleRate:

Handle;

numChannels:

Integer;

Fixed;

sampleSize:

Integer;

compressionType:

numBytes:
OSErr;

LongInt;

OSType;

VAR

baseFrequency:

headerLen:

Integer;

Integer)

You can use SetupSndHeader to construct a sampled sound header that can be passed to
SndPlay or stored as an 'snd ' resource. SetupSndHeader creates a format | 'snd ' resource
header for a sampled sound only, containing one synthesizer field (the sampled synthesizer)
and one sound command (a bufferCmd command to play the accompanying data). A sampled
sound header is stored immediately following the sound command and is in one of three
formats depending on several of the parameters passed. Table 22-7 shows how
SetupSndHeader determines what kind of sound header to create.
Table

22-7.

The sound header format used by SetupSndHeader

compressionType

numChannels

sampleSize

Sound
header format

'NONE'

I

8

SoundHeader

'NONE'

l

more than 8

ExtSoundHeader

"NONE'

2 or more

8 or more

ExtSoundHeader

not 'NONE'

any

any

CmpSoundHeader

The sndHandle parameter is a handle that is at least large enough to store the 'snd ' header
information. The handle is not resized in any way upon successful completion of
SetupSndHeader. SetupSndHeader simply fills the beginning of the handle with the header
information needed for a format | 'snd' resource. It is your application’s responsibility to
append the desired sampled sound data.

Sound Manager Routines

— 22-99

tw
Ns)
Dn
=
=
a.
<4

—

oe)

=
oy

ge
@

Inside Macintosh,

Volume

VI

The numChannels parameter specifies the number of channels for the sound. The sampleRate
parameter specifies the sampling rate for the sound (that is, samples per second). Note that
the most significant bit of this value is interpreted as having the value 32,768 (not as a sign
bit). The sampleSize parameter specifies the sample size for the sound (that is, bits per
sample). The compressionType parameter specifies the compression type for the sound
(‘NONE’, 'MAC3', 'MAC6', or other third-party types). The baseFrequency parameter
specifies the base frequency for the sound.
The numBytes parameter specifies the number of bytes of audio data that are to be stored in
the handle. (This value is not necessarily the same as the number of samples in the sound.)

The headerLen parameter returns the size of the 'snd ' resource header that is created, in
bytes. This allows you to put the audio data right after the header in the handle. The value
returned depends on the type of sound header created.
A good way to use this function is to create a handle that you want to store a sampled sound
in, then call SetupSndHeader with the numBytes parameter set to 0 to see how much room
the header for that sound will occupy and hence where to append the audio data. Then record
the data into the handle and call SetupSndHeader again with numBytes set to the correct
amount of sound data recorded. The handle filled out in this way can be passed to SndPlay to
play the sound.
Result codes
noErr
silnvalidCompression

0
—223

No error
Invalid compression type

You can use the SetupAIFFHeader function to set up a file that can be played by
SndStartFilePlay.
FUNCTION

SetupAIFFHeader

(fRefNum:

Integer;

sampleRate:

Fixed;

numChannels:

Integer;

sampleSize:

Integer;

compressionType:
OSType;
numBytes:
numFrames:
LongInt)
: OSErr;

LongInt;

Depending on the parameters passed, SetupAIFFHeader creates an AIFF or AIFF-C file
header:
=» Uncompressed sounds of any type are stored in AIFF format (that is, compressionT
ype
is 'NONE'’).
a Compressed sounds of any type are stored in AIFF-C format (that is, compressionType
is different from 'NONE’).
The fRefNum parameter contains a file reference number for a file that is open for writing.
The AIFF header information is written starting at the current file position, and the file
position is left at the end of the header upon completion.
The numChannels parameter, the sampleRate parameter, the sampleSize parameter, and the
compressionT
ype parameter have the same meanings as with the SetupSndHeader function.

22-100

Sound Manager Routines

The Sound Manager

The numBytes parameter specifies the number of bytes of audio data that are to be stored in
the Common Chunk of the AIFF or AIFF-C file. This data should be stored right after the
sound header in the file. (This value is not necessarily the same as the number of samples in
the sound.)

The numFrames parameter specifies the number of sample frames for the sound. A
value needs to be passed here only for third-party compression types. If you are using
'"NONE', 'MAC3', or 'MAC6' compression types, you can pass a 0 in this field, and
SetupAIFFHeader will calculate the number of sample frames and store it in the header.
A good way to use this routine is to create a file that you want to store a sound in, then call
SetupAIFFHeader with numBytes set to 0 to see how much room the header will take up and
hence to position the file to be ready to write the audio data. Then record the data to the file,
set the file position to the beginning of the file, and call SetupAIFFHeader again with
numBytes set to the correct amount of sound data recorded. The file created in this way can
be passed to SndStartFilePlay to play the sound.

Registering

Sound

Input Devices

nN
i)

Drivers for sound input devices must call SPBSignInDevice to register with the Sound
Manager before they can use its sound input services. You might call this routine at system
startup time from within a resource of type 'INIT' to install a sound input driver. You can get
information about registered devices by calling SPBGetIndexedDevice. You can unregister
your driver by calling SPBSignOutDevice.

ve

=

=
oe

<

+)

=

a
ve
@
“

FUNCTION

SPBSignInDevice

(deviceRefNum:

Integer;

deviceName:

Str255)

OSEYTT >

The SPBSignInDevice function registers with the Sound Manager the device whose driver
reference number is deviceRefNum. The deviceName parameter specifies this device’s name
as it is to appear to the user in the Sound control panel (which is not the name of the driver
itself). Accordingly, the name should be as descriptive as possible. You should call
SPBSignInDevice after you have already opened your driver by calling normal Device
Manager routines.
Result codes
noErr

siBadSoundInDevice

FUNCTION

SPBSignOutDevice

—221

0

No error

Invalid sound input device

(deviceRefNum:

Integer)

:

OSErr;

The SPBSignOutDevice function unregisters the device whose driver reference number is
deviceRefNum; the device is unregistered from the Sound Manager’s list of available drivers.
Result codes

noErr
siBadSoundInDevice
siDeviceBusyErr

0
—221
—227

No error
Invalid sound input device
Sound input device is busy
Sound Manager Routines

22-101

Inside Macintosh,

FUNCTION

Volume VI

SPBGetIndexedDevice

(count:
VAR

Integer;

VAR

deviceName:

deviceIconHandle:

Handle)

Str255;
:

OSErr;

The SPBGetIndexedDevice function returns the name and icon of the device whose index is
specified in the count parameter. Your application can create a list of sound input devices by
calling this function with a count starting at | and incrementing until the function returns
siBadSoundInDevice. On completion, the deviceName parameter contains a string that is the
name of the device, and the devicelconHandle parameter is a handle to a block of memory in
your application’s heap containing the device’s icon. The SPBGetIndexedDevice function
allocates this memory for you, but it is your responsibility to dispose of that handle when you
are finished with it.
Note:

You cannot call SPBGetIndexedDevice at interrupt time.

Result codes
noErr
siBadSoundInDevice

Converting

Between

—221

0

No error
Invalid sound input device

Milliseconds

and

Bytes

The Sound Manager provides two routines that allow you to convert between millisecond and
byte values.
FUNCTION

SPBMilliSecondsToBytes

(inRefNum:
Longint)

LongInt;
:

VAR

milliseconds:

OSErr;

The SPBMilliSecondsToBytes function reports how many bytes are required to hold a
recording of duration milliseconds, given the input device’s current sample rate, sample size,
number of channels, and compression factor. The inRefNum parameter indicates the input
device to use, and the milliseconds parameter points to a millisecond value to convert. On
return, the number of bytes is returned in the milliseconds parameter.
Result codes
noErr
siBadSoundInDevice
FUNCTION

—221

0)

SPBBytesToMilliSeconds

No error
Invalid sound input device
(inRefNum:
Longint)

LongInt;
:

VAR

byteCount:

OSErr;

The SPBBytesToMilliSeconds function reports how many milliseconds of audio data can be
recorded in a buffer that is byteCount bytes long, given the input device’s current sample
rate, sample size, number of channels, and compression factor. The inRefNum parameter
indicates the input device to use, and the byteCount parameter points to a byte value to
convert. On return, the number of milliseconds is returned in the byteCount parameter.
Result codes
noErr
siBadSoundInDevice
22-102

—221

Sound Manager Routines

0

No error
Invalid sound input device

The Sound Manager

SUMMARY

OF

THE

SOUND

MANAGER

Constants
{Gestalt

response

bit

fl ags}

gestaltStereoCapability

=

0;

{stereo

capability

present}

gestaltStereoMixing

=

1;

{stereo

mixing

internal

gestaltSoundIOMgrPresent

=
=

3;
4;

{sound
input
routines
available}
{built-in
input
device available}

=

5;

{sound

gestaltBuiltInSoundInput

gestaltHasSoundInputDevi ce

input

on

device

speaker}

available}

{channel initialization parameters}
{left channel--sampledSynth
only}
initChanLeft
= $0002;
{right channel--sampledSynth only}
initChanRight
= $0003;
{channel
1--wave
table only}
initChan0o
= $0004;
{channel
2--wave
table only}
initChanl
= $0005;
{channel 3--wave table only}
initChan2
= $0006;
{channel 4--wave table only}
initChan3
= $0007;
{mono channel--sampledSynth only}
initMono
= $0080;
{stereo
channel--sampledSynth
only}
initStereo
= $00C0;
initMACE3

=

initMACE6

=

initNoInterp
initNoDrop

=
=

init PanMask
initSRateMask
initStereoMask

=
=
=

initCompMask

=

{sound

command

$0300;

{3:1

compression--sampledSynth

$0400;
$0004;

{6:1 compression--sampledSynth
{no linear interpolation}

$0008;

{no

$0003;

{mask

for

right/left

$0030;

{mask

for

sample

rate

values}

$00CO0;

{mask

for

mono/stereo

values}

SFFOO;

{mask

for

compression

IDs}

drop-sample

=

resumeCmd
callBackCmd
syncCmd

=
=
=

availableCmd

=

versionCmd

a

253

{determine

totalLoadCmd

=

26;

loadCmd
freqDurationCmd

=
=

27;

{report
{report

40;

{play

©

pauseCmd

{do

W

=
=
=
=
=

{stop
{flush

only}

conversion}
pan

values}

=
=

nothing}

a

sound
a

{suspend

that

sound

{reinitialize

is

playing}

channel}

a

sound

processing

channel}
in

a

channel}

{pause processing
in a channel}
{resume processing
in a channel}
14;

{execute
a callback procedure}
{synchronize
channels}
{see
if initialization
option

{

{
restCmd
freqCmd

only}

numbers}

nullCmd
quietCmd
flushCmd
reInitCmd
waitCmd

me

CONST

41;
42;

}

available}
synthesizer

version}

total
CPU load}
CPU load
for a new

a

frequency

for

a

channel}

specified

}

duration}

{rest

a

{change

channel
the

pitch

for
of

specified
a

duration}

sound}

Summary of the Sound Manager

22-103

x
ee

2
=

=
>
=

aS
a

Inside Macintosh,

Volume VI

ampCmd

=

£35

{change

the

amplitude

of

a

timbreCmd

=

44;

{change

the

timbre

of

a

sound}

getAmpCmd

=

45;

{get

amplitude

of

a

sound}

waveTableCmd

=

60;

{install

a

wave

table

as

a

soundCmd

=

80;

{install

a

sampled

sound

as

buf ferCcmd

=

845

{play

a

sampled

rateCmd

=

82;

{set

the

pitch

of

a

sampled

sound}

getRateCmda

=

§5;

{get

the

pitch

of

a

sampled

sound}

the

sound}

voice}

a

voice}

{sampled

sound

header

encoding

options}

stdSH

=

$00;

{standard

sound

header}

extSH

=

SFF;

{extended

sound

header}

cmpSH

=

SFE;

{compressed

128;

{default

{size

of

data

sound

header}

structures}

stdQLength

=

{

{sound command
dataOffsetFlag
{synthesizer

mask}

resource

=

$8000;

size

of

standard

sound

channel}

{sound

command

data

offset

bit}

IDs}

squareWaveSynth

wld

{square-wave

waveTableSynth

*s

Bf

{wave-table

sampledSynth

x

5s

{sampled

$0000;

{system

alert

sound

disabled}

$0001;

{system

alert

sound

enabled}

=

field in
$0000;

AudioSelection}
{seconds }

=

SFFFF;

{no

{system

beep

{values for the
unitTypeSeconds

unitType

unitTypeNoSelection
{double-buffer
dbBuf ferReady

status

dbLast Buffer
{values

for

synthesizer}
synthesizer}

sound

synthesizer}

states}

sysBeepDisable
sysBeepEnable

=
the

selection}

flags}
= $00000001;

$00000004;

compressionID

field

of

CmpSoundHeader}

notCompressed

=:

‘O's

{noncompressed

threeToOne

=:

By

{3:1

compressed

samples}

sixToOne

=

4;

{6:1

compressed

samples}

{values for the packetSize field
sixToOnePacketSize
= 8;

22-104

sound}

threeToOnePacketSize

=

{information

selectors

16;

of

CmpSoundHeader}
{packet size for

6:1}

{packet

3:1}

for

sound

siActiveChannels

=

'chac';

{channels

siActiveLevels

=

'lmac';

{levels

Summary of the Sound Manager

samples}

input

size

for

drivers}
active}
active}

}

The Sound Manager

SiAGCOnO£f£

=

'agc

siAsync

=

'asyn';

';

{asynchronous

{automatic

gain

siChannelAvailable

=

'chav';

{number

siCompressionAvailable
siCompressionFactor
siCompressionHeader
siCompressionType
siContinuous
siDeviceBufferInfo
siDeviceConnected
siDeviceIcon
siDeviceName
siLevelMeterOnOff

=
=
=
=
=
=
=
=
=
=

'cmav';
'cmfa';
'cmhd';
'comp';
'cont';
'dbin';
'dcon';
'icon';
'name';
'lmet';

{compression types available}
{current compression factor}
{return compression header}
{current compression type}
{continuous recording}
{size of interrupt buffer}
{input device connection status}
{input device icon}
{input device name}
{level meter state}

siNumberChannels

=

'chan';

{current

number

siOptionsDialog

=

'optd';

{display

options

of

channels

siPlayThruoOnoff

=

'plth';

{play-through

siRecordingQuality

=

'qual';

{recording

siSampleRate

=

'srat';

{current

siSampleRateAvailable

=

'srav';

{sample

siSampleSize

=

'ssiz';

{current

siSampleSizeAvailable

=

'ssav';

{sample

siTwosComplementOnOff

=

'twos';

{two's

siVoxRecordinfo

=

'voxr';

{VOX

record

siVoxStopInfo

=

'voxs';

{VOX

stop

{sound-recording
siBestQuality
siBetterQuality
siGoodQuality

qualities}
= 'best';
= 'betr';
= 'good';

{sound input device
siReadPermission
siWritePermission

permissions}
= Dis
= as

control

state}

capability}
available}

of

channels}

dialog

box}

state}

quality}
sample

rates

rate}

available}

sample
sizes

aR

size}

~

available}

4

complement

state}

=

parameters}

=

parameters}

S

{the best quality
{a quality better
{a good quality}

available}
than good}

{open
{open

reading}
reading/writing}

device
device

for
for

{device-connection
states}
siDeviceIsConnected
= 1:

{device

is

connected

siDeviceNotConnected

=

0;

{device

is

not

siDontKnowlfConnected

=

-l;

{can't

tell

if

{IDs
for
FormID

=

file chunks}
'FORM';
{chunk

ID

for

Form

FormatVersionID

=

'FVER';

{chunk

ID

for

Format

Version

CommonID

=

'COMM';

{chunk

ID

for

Common

Chunk}

SoundDataID

=

'SSND';

{chunk

ID

for

Sound

{version

AIFF

of

AIFCVersion1l

and

AIFC

AIFF-C

format
=

and

ready}

connected}
device

is

connected}

Chunk}

Data

Chunk}

Chunk}

specification}
$A2805140;

{2726318400

in

decimal}

Summary of the Sound Manager

22-105

Inside Macintosh, Volume VI

Data
TYPE

Types
Time

=

SndCommand
PACKED

LongInt;

{in

=

{generic

half-milliseconds}
sound

command}

RECORD

cmd:
param1:

Integer;
Integer;

{command number}
{first parameter}

param? :

Longint

{second

parameter}

END;

SndChannelPtr
SndChannel
=
PACKED

=

*SndChannel;
{sound

channel}

RECORD

nextChan:

SndChannelPtr;

{pointer

firstMod:

Ptr;

{used

to

next

channel}

internally}

callBack:

ProcPtr;

{pointer

userinfo:

Longint;

{free

for

to

callback

wait:
cmdinProgress:

Time;
SndCommand;

{used
{used

internally}
internally}

proc}

application's

flags:

Integer;

{used

internally}

qLength:

Integer;

{used

internally}

qHead:

Integer;

{used

internally}

qTail:

Integer;

{used

internally}

queue:

ARRAY[0..stdQLength-1]

OF

use}

SndCommand

END;

SoundHeaderPtr
SoundHeader
PACKED

=

*SoundHeader;

=

{standard

sampled

sound

header}

RECORD

samplePtr:
length:

Ptr;
LongInt;

{if NIL,
samples in sampleArea}
{number of samples in array}

sampleRate:

Fixed;

{sample

loopStart:

LongIint;

{loop

point

loopEnd:

LongInt;

{loop

point

encode:

Byte;

{sample's

baseFrequency:

Byte;

{base

sampleArea:

PACKED

ARRAY[0..0]

OF

rate}

beginning}
ending}

encoding

frequency

option}

of

sample}

Byte

END;

ExtSoundHeaderPtr
ExtSoundHeader =
PACKED

22-106

=

“ExtSoundHeader;
{extended

sampled

sound

header}

RECORD

samplePtr:
numChannels:

Ptr?
LongInt;

{if NIL,
samples
in
{number of channels

sampleRate:

Fixed;

{rate

of

loopStart:

LongInt;

{loop

point
point

loopEnd:

Longint;

{loop

encode:

Byte;

{sample's

baseFrequency:

Byte;

{base

Summary of the Sound Manager

original

sampleArea}
in sample}

sample}

beginning}
ending}

encoding

frequency

of

option}
original

sample}

The Sound Manager

numFrames:

LongIint;

AIFFSampleRate:
markerChunk:

{total

Extended;
Ptr’

instrumentChunks:
AESRecording:

Ptr

{rate of
{pointer
{pointer

original sample}
to marker info}
to instrument info}

Pim:

{pointer

to

Integer;

{number of
{reserved}
{reserved}

sampleSize:
futureUsel:

Integer;

number

futureUse2:

LongInt;

futureUse3:

LongInt;

{reserved}

futureUse4:

LongIint;

{reserved}

PACKED

sampleArea:
END;
CmpSoundHeaderPtr
CmpSoundHeader
=
PACKED

=

ARRAY[0..0]

of

frames}

audio
bits

info}

per

sample}

OF Byte

*“CmpSoundHeader;
{compressed

sampled

sound

header}

RECORD

samplePtr:
numChannels:

Ptr;
Longint;

{if NIL,
samples
in
{number of channels

sampleRate:
loopStart:

Fixed;
LongInt;

{rate
{loop

of original
sample}
point
beginning}
point

loopEnd:

LongIint;

{loop

encode:

Byte;

{sample's

baseFrequency:

Byte;

{base

numFrames:

LongInt;

{length

AIFFSampleRate:

Extended;

{rate

markerChunk:
futureUsel:

freq.
of

of

{unused}
{reserved}
{reserved}

tw
2y

ending}

Zz

encoding

Ptr;
Ptr;

sampleArea}
in sample}

of

option}

original

sample

in

original

sample}

frames}

sample}

futureUse2:

Ptr;

stateVars:

StateBlockPtr;

{pointer

to

StateBlock}

leftOverSamples:

LeftOverBlockPtr;

{pointer

to

LeftOverBlock}

compressionID:

Integer;

{ID

packetSize:

Integer;

{number

of

snthID:

Integer;

{ID

sampleSize:

Integer;

sampleArea:

PACKED

of

{bits
ARRAY[0..0]

compression

of

OF

bits

each

sample

=

packet}
synth}
point}

Byte

END;
SCStatusPtr
eacStatus.

=

“SCStatus;

=

{sound-channel

status

record}

RECORD

scStartTime:
scEndTime:
scCurrentTime:

Fixed;
Fixed;

{starting time for play from disk}
{ending time for play from disk}

Fixed;
Boolean;
Boolean;

{current
time
for play
from disk}
{TRUE
if channel
is making
sound}
{reserved}

Boolean;
Boolean;
Longint;

{TRUE

scUnused:
scChannelAttributes:
scCPULoad:

LongInt

{CPU

scChannelBusy:

scChannelDisposed:
scChannelPaused:

if

{unused}

channel

{attributes
load

of
for

is
this

this

paused}
channel}
channel}

END;

Summary of the Sound Manager

=
S.

es

algorithm}

per

compression
in

=|

22-107

Inside Macintosh,

Volume VI

SMStatusPtr

“SMStatus;

SMStatus

=

{Sound

=

PACKED RECORD
smMaxCPULoad:
smNumChannels:
smCurCPULoad:

Manager

status

Integer;

{maximum

Integer;

{number

Integer

{current

record}

load
of

all

channels}

allocated

on

channels}

load

on

all

channels}

END;

AudioSelectionPtr

AudioSelection
PACKED

=

“AudioSelection;
{audio selection}

=

RECORD

Longint;
Fixed;
Fixed

unitType:
selStart:
selEnd:

{type of time unit}
{starting point of selection}
{ending point of selection}

END;
SndDoubleBufferPtr
SndDoubleBuffer

=

“SndDoubleBuffer;

=

PACKED RECORD
GbNumFrames:

{double

buffer

for

play

from

disk}

LongInt;

{number

of

dbFlags:

LongInt;

{buffer

status

dbUserInfo:

ARRAY[0..1]

adbSoundData:

PACKED

OF

Longint;

ARRAY[0..0]

OF

{for

frames

in

buffer}

flags}

application's

use}

Byte
{array

of

data}

END;

SndDoubleBufferHeaderPtr
SndDoubleBufferHeader
PACKED

=

=

“SndDoubleBufferHeader;

{double-buffer

header

for

play

from

disk}

RECORD

adbhNumChannels:

Integer;

{number

of

dbhSampleSize:

Integer;

{sample

size,

adbhCompressionID:

Integer;

{ID

dbhPacketSize:

Integer;

{number

of

dbhSampleRate:

Fixed;

{sample

rate}

aGbhBufferPtr:

ARRAY[0..1]

OF

GbhDoubleBack:

ProcPtr

of

sound

channels}

if

uncompressed}

compression

bits

algorithm}

per

packet}

SndDoubleBufferPtr;

‘pointers

to

‘pointer

to

SndDoubleBuffer}
doubleback

procedure}

END;
SPBPtr

SPB

=

=

“SPB;

{sound

input

parameter

block}

RECORD

inRefNum:

LongInt

{reference

number

of

input

count:

Longint;

{number

of

bytes

to

record}

milliseconds:
bufferLength:

Longint;
Longint;

{number
{length

of
of

milliseconds to record}
buffer to record into}

bufferPtr:
completionRoutine:
interruptRoutine:

PUL:
ProcPtr;
ProcPtr;

{pointer
{pointer
{pointer

to
to
to

userLong:

LongInt;

{for

error:

OSErr;

{error

unusedl:

LongiInt

{reserved}

END;

22-108

;

Summary of the Sound Manager

device}

buffer
to record
into}
a completion
routine}
an interrupt
routine}

application's
returned

use}

after

recording}

The Sound Manager

TYPE

ID

=

LongInt;

ChunkHeader

=

RECORD

{chunk

ID

type}

{AIFF

and

AIFF-C

file

chunk

header}

CkID:

ID;

ckSize:

{chunk

type

ID}

Longint

{mumber

of

bytes

of

data}

of

bytes

of

data}

END;

ContainerChunk

=

{Container

Chunk}

RECORD

eckID:

ID;

{'FORM' }

ckSize:

Longint;

{number

formType:

ID

{type

of

file}

END;

FormatVersionChunk

=

{Format

Version

Chunk}

RECORD

ckID:

ID;

{'FVER‘'}

ckSize:

LongInt;

timestamp:

LongInt

{4}
{date

of

i
nN

format

version}

io 2
—
S

END;

=
—)

-!

—

CommonChunk

=

{AIFF

Common

a
vt

Chunk}

bs]
_
=)

RECORD

fo
ga

ckID:

LD:

ckSize:

Longint ;

{ 'COMM' }
{size of

numChannels:

Integer;

{number

of

channels}

numSampleFrames:
sampleSize:

Longint;
Integer;

{number
{number

of
of

sample
frames}
bits per sample}

sampleRate:

Extended

{number

of

frames

chunk

[a*)
Lex |

data}

per

second}

END;

ExtCommonChunk

=

{ATFF-C

Common

Churk}

RECORD

ckID:
ckSize:

{'COMM' }

LD:

Longint;

{size

Integer;

of

of
of

chunk

channels}
sample
frames}

data}

Longint;

{number
{number

sampleSize:

Integer;

{number

of

bits

sampleRate:
compressionType:

Extended;

{number

of

frames

compressionName:

PACKED

numChannels:
numSampleFrames:

ID;

{compression

per

type

ARRAY[0..0]
OF Byte
{compression
type

sample}

per

ID}

second}

name}

END;
SoundDataChunk

=

{Sound

Data

Chunk}

RECORD

{'SSND'}

ckID:

LD;

ckSize:

Longint;

offset:

LongIint;

{size of chunk data}
{offset
to sound data}

blockSize:

Longint

{size

of

alignment

blocks}

END;

Summary of the Sound Manager

22-109

Inside Macintosh,

Volume VI

Routines

Playing

Sound

FUNCTION

SndPlay

Resources

PROCEDURE

SysBeep

(duration:

PROCEDURE

SndGetSysBeepState

(VAR

FUNCTION

SndSetSysBeepState

Allocating and
FUNCTION

SndNewChannel

sysBeepState:

Sound

(VAR

SndDisposeChannel

(chan:

Integer);

Integer)

:

OSErr;

Channels

chan:

LongInt;

FUNCTION

Integer);

(sysBeepState:

Releasing

async:

Handle;

sndHdl:

(chan: SndChannelPtr;
Boolean)
: OSErr;

SndChannelPtr;
userRoutine:

SndChannelPtr;

synth:

Integer;

ProcPtr)

:

init:

OSErr;

quietNow:

Boolean)

modifier:

ProcPtr;

OSErr;

Linking

Synthesizers to Sound

FUNCTION

SndAddModifier

(chan:

SndChannelPtr;

Integer;

Sending
FUNCTION

Commands

init:

to a Sound

SndDoCommand

(chan:

SndDoImmediate

LongInt)

(chan:

:

id:

OSErr;

Channel

SndChannelPtr;

Boolean)

FUNCTION

Channels

:

cmd:

SndCommand;

cmd:

SndCommand)

cmd:

SndCommand)

noWait:

OSErr;

SndChannelPtr;

OSErr;

Obtaining

Information

FUNCTION

SndControl

(id:

FUNCTION

SndChannelStatus

(chan:

FUNCTION

SndManagerStatus

Integer;

SndChannelPtr;

theLength:

theStatus:

SCStatusPtr)

(theLength:

Integer;

SMStatusPtr)

FUNCTION

SndSoundManagerVersion

:

NumVersion;

FUNCTION

MACEVersion

:

NumVersion;

FUNCTION

SPBVersion

:

NumVersion;

22-110

VAR

Summary of the Sound Manager

:

OSErr;

:

OSErr;

theStatus:

:

OSErr;

Integer;

The Sound Manager

Playing

From

Disk

FUNCTION

SndStartFilePlay

(chan:

SndChannelPtr;

fRefNum:
bufferSize:

Integer;

resNum:

Integer;
LongInt;

Ptr; theSelection:
theBuffer:
theCompletion:
AudioSelectionPtr;
async:

Boolean)

:

ProcPtr;

OSErr;

FUNCTION

SndPauseFilePlay

(chan:

SndChannelPtr)

:

OSErr;

FUNCTION

SndStopFilePlay

(chan:

SndChannelPtr;

async:

SndChannelPtr;

theParams:

Boolean)

OSErr;

Managing
FUNCTION

Double

Buffers

SndPlayDoubleBuffer

(chan:

SndDoubleBufferHeaderPtr)

Compressing

and

Expanding

Audio

:

OSErr;
i)
Ss)

Data

72
cS

=

=

PROCEDURE

Comp3tol

(inBuffer:

Ptr;

outBuffer:

Ptr;

=

cnt:

a

Longint;
inState:
Ptr;
outState:
Ptr;
numChannels:
LongInt;
whichChannel:
LongInt);

PROCEDURE

PROCEDURE

PROCEDURE

Comp6tol

Explto3

Exp1to6

Recording

(inBuffer:

Ptr;

outBuffer:

inState:

Ptr;

outState:

LongiInt;

wnichChannel:

Ptr;
Ptr;

(inBuffer:

Ptr;

outBuffer:

inState:

Ptr;

outState:

Ptr;

Longint;

whichChannel:

(inBuffer:
inState:

Ptr;
outBuffer:
Ptr;
cnt:
LongInt;
Ptr;
outState:
Ptr;
numChannels:

Longint;

whichChannel:

Ptr;

LongInt;

LongInt);

Sounds
(filterProc:
OSType;
VAR

FUNCTION

SndRecordToFile

(filterProc:
ProcPtr;
corner:
OSType;
fRefNum:
Integer)
:

FUNCTION

cnt:

numChannels:

LongInt};

SndRecord

FUNCTION

LongInt;

LongInt);

FUNCTION

Opening

cnt:

numChannels:

and Closing Sound
SPBOpenDevice

SPBCloseDevice

ProcPtr;
corner:
Point;
quality:
sndHandle:
Handle)
: OSErr;
Point;
OSErr;

quality:

Input Devices

(deviceName:

Str255;

permission:

inRefNum:

LongInt)

:

OSErr;

(inRefNum:

LongInt)

:

OSErr;

Integer;

Summary of the Sound Manager

VAR

22-111

—

S)
~
gS
ve
o
|
—

Inside Macintosh,

Recording
FUNCTION

Volume VI

Sounds

Boolean)

asynchFlag:

SPBPtr;

(inParamPtr:

SPBRecord

Input Devices

Sound

Directly From
OSErr;

FUNCTION

SPBRecordToFile

inParamPtr:
Integer;
(fRefNum:
: OSErr;
Boolean)
asynchFlag:

FUNCTION

SPBPauseRecording

(inRefNum:

LongInt)

:

OSErr;

FUNCTION

SPBResumeRecording

(inRefNum:

LongIint)

:

OSErr;

FUNCTION

SPBStopRecording

(inRefNum:

LongInt)

:

OSErr;

FUNCTION

SPBGetRecordingStatus

(inRefNum:

LongInt;

VAR

Integer;

VAR

recordingStatus:

meterLevel:

totalSamplesToRecord:

Integer;

LongInt;

numberOfSamplesRecorded:
totalMsecsToRecord:

FUNCTION

Device

SPBGetDeviceInfo

(inRefNum:

SPBSetDeviceliInfo

:

FUNCTION

LongInt)

:

OSErr;

LongInt;

Sound

(inRefNum:

Resource

SetupSndHeader

infoType:

OSType;

infoType:

OSType;

infoData:

OSErr;
LongInt;

infoData:

Constructing

VAR

VAR

Settings
Per)

FUNCTION

VAR

VAR

LongInt;

LongInt;

numberOfMsecsRecorded:

Manipulating

SPBPtr;

Ptr)

and

(sndHandle:

:

OSErr;

File Headers

Handle;

numChannels:

Integer;

sampleRate:
Fixed;
sampleSize:
Integer;
compressionType:
OSType;
baseFrequency:

FUNCTION

SetupAIFFHeader

Integer;
Integer)

numBytes:
: OSErr;

LongInt;

VAR

(fRefNum:

Integer;

numChannels:

headerLen:

Integer;

sampleRate:
Fixed; sampleSize:
Integer;
compressionType:
OSType;
numBytes:
LongInt;
numFrames:

Registering
FUNCTION

Sound

LongInt)

:

OSErr;

Input Devices

SPBSignInDevice

(deviceRefNum:

Integer;

deviceName:

Integer)

:

Str255)

OSErr;

FUNCTION

SPBSignOutDevice

(deviceRefNum:

FUNCTION

SPBGetIndexedDevice

(count:

Integer;

deviceIconHandle:

22-112

Summary of the Sound Manager

VAR

OSErr;

deviceName:

Handle)

:

Str255;

OSErr;

VAR

The Sound Manager

Converting
FUNCTION

Between

Milliseconds

SPBMilliSecondsToBytes

and

(inRefNum:
Longint)

FUNCTION

SPBBytesToMilliSeconds

Application-Defined

LongInt;
OSErr;

VAR

milliseconds:

:

LongInt;
OSErr;

VAR

byteCount:

:

(inRefNum:
Longint)

Bytes

Routines

PROCEDURE

MyRecordCompletionRoutine

(inParamPtr:

PROCEDURE

MyDoubleBackProc

(chan:

SPBPtr);

SndChannelPtr;

exhaustedBuffer:

SndDoubleBufferPtr) ;
PROCEDURE

MyCallBack

(chan:

SndChannelPtr;

cmd:

to
Ns
n
=
=

SndCommand) ;
PROCEDURE

MyFilePlayCompletionRoutine

(chan:

SndChannelPtr);

ou

K<
—

Result

=
=
rr)
©

Codes

noErr
noHardwareErr
notEnoughHardwareErr
queueFull
resProblem
badChannel
badFormat
notEnoughBufferSpace
badFileFormat
channelBusy
buffersTooSmall
channelNotBusy
noMoreRealTime
siNoSoundInHardware
siBadSoundInDevice
siNoBufferSpecified
silnvalidCompression
siHardDriveTooSlow
silnvalidSampleRate
silnvalidSampleSize
siDeviceBusyErr
siBadDeviceName
siBadRefNum
silnputDeviceErr
siUnknownInfoType
siUnknownQuality

Mee

0
—200
-201
—203
—204
—205
—206
-—207
—208
—209
—210
211
—212
—-—220
—22]
—222
—223
—224
—225
—226
—227
—228
—229
—230
—23]
—232

No error
Required sound hardware not available
Insufficient hardware available
No room in the queue
Problem loading the resource
Channel is corrupt or unusable
Resource is corrupt or unusable
Insufficient memory available
File is corrupt or unusable, or not AIFF or AIFF-C
Channel is busy
Buffer is too small
Channel not currently used
Not enough CPU time available
No sound input hardware available
Invalid sound input device
No buffer specified
Invalid compression type
Hard drive too slow to record
Invalid sample rate
Invalid sample size
Sound input device is busy
Invalid device name
Invalid reference number
Input device hardware failure
Unknown type of information
Unknown quality
Summary of the Sound Manager

22-113

Inside Macintosh,

Volume VI

Assembly-Language
Sound

Information

Input Parameter

Block

Data Structure

>

0

inRefNum

long

input device reference number

o

4

count

long

number of bytes to record

~&

8

milliseconds

long

number of milliseconds to record

>

12

bufferLength

long

length of buffer

—

16

bufferPtr

long

address of buffer

—»

20

completionRoutine

long

pointer to completion routine

—

24

interruptRoutine

long

pointer to interrupt routine

—>

28

userLong

long

for application’s use

<

32

error

word

error returned after recording

—>

36

unused |

long

reserved

22-114

Summary of the Sound Manager

NO
GO
WW
OOwononanf

THE

TIME

MANAGER

About This Chapter
About the Time Manager
Time Manager Versions
The Original Time Manager
The Revised Time Manager
The Extended Time Manager
Other Time-Related Facilities
The TickCount Function
The Delay Function
The Vertical Retrace Manager
Using the Time Manager
Installing and Activating Task Records
Using Application Global Variables in Tasks
Performing Periodic Tasks
Computing Elapsed Time
Time Manager Routines
Summary of the Time Manager

)
ae)
ar
=f

oO

=<
p9
=}
Y
re

—=

@
a

23-1

Inside Macintosh,

23-2

Volume VI

The Time Manager

ABOUT

THIS

CHAPTER

This chapter describes how you can use the Time Manager to schedule execution of a routine
after a specified amount of time has elapsed. This chapter replaces the Time Manager chapter
in Volume IV. It includes all the information about the original Time Manager, as well
as additional information about the revised Time Manager included with system software
version 6.0.3 (and later) and about the extended Time Manager included with system
software version 7.0.
Because different versions of the Time Manager are available under different system software
versions, your application may need to determine which version is available in its current
operating environment. To do so, you can use the Gestalt function explained in the Compatibility Guidelines chapter of this volume.
To use this chapter, you should already be familiar with
m operating-system queues, as described in the Operating System Utilities chapter of
Volume II
m the Vertical Retrace Manager, as described in the Vertical Retrace Manager chapter in
Volume II and Volume V
You need to know about operating-system queues because all Time Manager routines involve
inserting entries into a queue and then activating or removing queued entries. You should be
acquainted with the Vertical Retrace Manager because it provides an alternative (and
sometimes preferable) method for scheduling routines for future or periodic execution.

nN

we

.

=we
)
2

—

a

ABOUT

THE

TIME

=
ga
s

MANAGER

The primary service that the Time Manager provides to applications is a method for
scheduling routines to execute at a later time. By suitably defining the task that later executes,
you can use the Time Manager to accomplish a wide range of time-related activities. For
example, because one of the actions a routine can perform is to reschedule itself for later
execution, the Time Manager provides your application with a means to perform periodic or
repeated actions. You can use the Time Manager to
m schedule routines to execute after a specified delay
w set up tasks that run periodically
= compute the time a routine takes to execute
= coordinate and synchronize actions in the Macintosh® computer

About the Time Manager

23-3

Inside Macintosh,

Volume VI

The Time Manager provides a hardware-independent method of performing these and other
time-related tasks. You should use the Time Manager instead of cycle-counting timing loops,
which can vary in duration because they are dependent upon clock speed and interrupthandling speed. Furthermore, on machines with 68020 or 68030 microprocessors, It 1s
almost impossible to rely on cycle-counting loops because instructions may be both cached
and pipelined. In such cases, it is very difficult to tell what part of the instruction cycle the
machine is currently in.
To use the Time Manager, you must first issue a request by passing the Time Manager the
address of a task record, one of whose fields contains the address of the routine that is to
execute. Then you need to activate that request by specifying the delay until the routine is
to execute. The Time Manager maintains requests that you issue in a queue, whose structure
is similar to that of standard Macintosh operating-system queues. Any number of outstanding
requests can be in the Time Manager queue, and each application can add any number of
entries to the queue. If several requests happen to schedule routines for execution at exactly
the same time, those routines will execute as close to the scheduled time as possible, in the
order in which they entered the Time Manager queue.
The routine you place in the queue can perform any desired action so long as it does not call
the Memory Manager, either directly or indirectly. You cannot call the Memory Manager
because Time Manager tasks execute at interrupt time.

Time

Manager

Versions

The Time Manager included in system software version 7.0 is the third version released. The
three versions are all upwardly compatible—that is, each succeeding Time Manager version is
a functional superset of the previous one, and code written for a version of the Time Manager
executes on any later version. The reverse, however, is not true, and code written for the
extended Time Manager may not execute properly on either the original or revised version.
As a result, it is sometimes important to know which Time Manager version is available on a
specific machine. You can use the Gestalt function to determine which version is present.

The

Original

Time

Manager

The Time Manager was first introduced with the Macintosh Plus ROMs (which are also

contained in the Macintosh 512K enhanced) and was intended for use internally by the
Operating System. Volume IV of Inside Macintosh documented the routines in the original
Time Manager, and thereafter some applications used them to schedule tasks to be executed
at later times. The original Time Manager allows delays as small as | millisecond, resulting
in a maximum range of about 24 days.
To schedule a task for later execution, you place an entry into the Time Manager queue and
then activate it. All Time Manager routines manipulate elements of the Time Manager queue,
which are stored in a Time Manager task record. The task record for the original Time
Manager looks like this:

23-4

About the Time Manager

The Time Manager

TYPE

TMTask

=

{original

qLink:

QElemPtr;

{next

qType:

Integer;

{queue

tmAddr:
tmCount:

ProcPtr;
LongInt

to
{pointer
{reserved}

RECORD

and

revised

Time

Manager

queue

type}

task

record}

entry}
task}

END;

Of the four fields in this record, your application needs to supply only the tmAddr field,
which contains a pointer to the routine that is to be executed at some time in the future.
The remaining fields are used internally by the Time Manager or are reserved by Apple
Computer, Inc. Your application should set these remaining fields to 0 when you set up a
task record.
The original Time Manager includes three routines:
w The InsTime procedure installs a task record into the Time Manager queue.
a The PrimeTime procedure schedules a previously queued task record for future
execution.

Note that installing a request into the Time Manager queue (using the InsTime procedure) does
not by itself schedule the specified routine for future execution. After you queue a request, you
still need to activate (or prime) the request by specifying the desired delay until execution (using
the PrimeTime procedure). Note also that the task record is not automatically removed from the
Time Manager queue after the routine executes. As a result, the task may be reactivated when
you subsequently call PrimeTime; you do not have to reinstall the task record. To remove a task
record from the queue, you must call the RmvTime procedure. RmvTime removes a task record
from the Time Manager queue whether or not that task was ever activated and whether or not its
specified time delay has expired.

£7

ms The RmvTime procedure removes a task record from the Time Manager queue.

——e
=ad
@

<

et

©

os
_

=

ge
@
“

The

Revised

Time

Manager

System software version 6.0.3 contains a revised version of the Time Manager. This version
provides better time resolution and the ability to perform measurements of elapsed time with
much greater accuracy. You can represent time delays in the revised Time Manager as
microseconds as well as milliseconds, with

a maximum resolution of 20 microseconds. The

external programming interface did not change from the original to the revised Time Manager,
although the revised version provides a means to distinguish microsecond delays from
millisecond delays. The revised Time Manager interprets negative time values (which were
not formerly allowed) as negated microseconds. For example, a value of —50O is interpreted as
a delay of 50 microseconds. Positive time values continue to represent milliseconds. When
you specify delays as microseconds, the maximum delay is about 35 minutes. When you
specify delays as milliseconds in the revised Time Manager, the maximum delay is about
| day. The delay specified to PrimeTime is converted to an internal form, so it makes no
difference which unit you use if the delay falls within the ranges of both.

About the Time Manager

23-5

Inside Macintosh,

Volume VI

The revised Time Manager provides additional Time Manager features. The principal change
concerns the tmCount field of the Time Manager task record (previously reserved for use by
Apple). When you remove an active task from the revised Time Manager's queue, any time
remaining until the scheduled execution time is returned in the tmCount field. This change
allows you to use the Time Manager to compute elapsed times (as explained in “Computing
Elapsed Time” later in this chapter). In addition, the high-order bit of the qType field of the
task record is now a flag to indicate whether the task timer is active. The InsTime procedure
initially clears this bit, PrimeTime sets it, and it is cleared when the time expires or when your
application calls RmvTime.
Although the revised Time Manager supports delay times specified in microseconds, you
should use this feature primarily for the more accurate measurement of elapsed times.
Applications that specify very small delay times in order to execute a routine at a high
frequency may use a considerable amount of processor time. The amount of processor time
consumed by such timing services varies, depending largely on the performance of the
CPU. With low-performance CPUs, little or no time may be left for other processing on
the system (for instance, moving the mouse or running the application).

The

Extended

Time

Manager

The extended Time Manager (available with system software version 7.0) contains all the

features of earlier Time Managers, with several extensions intended primarily to provide driftfree, fixed-frequency timing services. These services ensure that a routine executes promptly
after a specified delay and are important for sound and multimedia applications that require
precise timing and real-time synchronization among different events.

In the original and revised Time Managers, the delay time passed to PrimeTime indicates a
delay that is relative to the current time (that is, the time at which you execute PrimeTime).
This presents problems when you need a fixed-frequency timing service and attempt to
implement it by having the task reissue a PrimeTime call. The problem is that the time
consumed by the Time Manager and by any interrupt latency (which is not predictable)
causes the task to be called at a slightly slower and unpredictable frequency, which drifts
over time. In Figure 23-1, a fixed frequency of 1000 microseconds is desired but cannot be
achieved because the Time Manager overhead and interrupt latency cause a small and
unpredictable delay each time the task is reactivated.
Elapsed time

0

1000

7000

_s

2100

1000 1s
100

3300

1000 1s

r

200

4350

1000 1s »

al

v

50

Time taken to reinstall routine

Figure 23-1. Original and revised Time Managers (drifting, unpredictable frequency)
23-6

About the Time Manager

The Time Manager

The extended Time Manager solves this problem by allowing you to reinstall a task with an
execution time that is relative to the time when the task last expired—not relative to the time
when the task is reinstalled. The extended Time Manager compensates for the delay between
the time when the task last expired and the time at which it was reinstalled, thereby providing
a truly drift-free, fixed-frequency timing service.
For example, if an application needs to execute a routine periodically at 1-millisecond
intervals, it can reactivate the existing Time Manager queue element by calling PrimeTime
in the task with a specified delay of | millisecond. When the Time Manager receives this
new execution request, it determines how long ago the previous PrimeTime task expired
and then decrements the specified delay by that amount. For instance, if the previous task
expired 100 microseconds ago, then the Time Manager installs the new task with a delay
of 900 microseconds. This is illustrated in Figure 23-2.
Elapsed time

0

1000

2000

3000

100

200

50

4000

5000

i
ww

=
—

Time taken to reinstall routine

cee

a
—

a
a
1—

Figure 23-2. The extended Time Manager (drift-free, fixed frequency)

—

me

ew)

ge
@
ar

The extended Time Manager implements these features by recognizing an expanded task
record and providing a new procedure, InsXTime. The Time Manager task record for the
extended Time Manager looks like this:
TYPE

TMTask

=

{extended

RECORD
qLink:

QElemPtr;

{next

Integer;
ProcPtr;

{queue
type}
{pointer
to task}

tmCount:

Longint;

{unused

tmWakeUp:
tmReserved:

Longint;
Longint

{wakeup
time}
{reserved
for

qType:
tmAddr:

Time

Manager

task

queue

record}
entry}

time}
future

use}

END;

Once again, your application provides the tmAddr field. You should set tmWakeUp and
tmReserved to 0 when you first install an extended Time Manager task. The remaining
fields are used internally by the Time Manager. As in the revised Time Manager, the
tmCount field holds the time remaining until the scheduled execution of the task (this field
is set by RmvTime).

About the Time Manager

23-7

Inside Macintosh,

Volume VI

The tmWakeUp field contains the time at which the Time Manager task specified by tmAddr
last executed or contains 0 if it has not yet executed. Its principal intended use is to provide
drift-free, fixed-frequency timing services, which are available only when you use the
extended Time Manager and only when you install Time Manager tasks using the new
InsXTime procedure. When your application installs an extended Time Manager task (using
the InsXTime procedure), the behavior of the PrimeTime procedure changes slightly, as
described earlier in this section. If the tWakeUp field is zero when PrimeTime is called, the
delay parameter to PrimeTime is interpreted as relative to the current time (just as in the
original Time Manager), but the Time Manager sets the tn WakeUp field to a nonzero value
that indicates when the delay time should expire. When your application calls PrimeTime on a
Time Manager task that has a nonzero value in the tmWakeUp field, the Time Manager
interprets the specified delay as relative to the time that the last call to PrimeTime on this task
was supposed to expire.
Note: Nonzero values in tnWakeUp are in a format that is used internally by the
Time Manager and is subject to change. Your application should never use the value
stored in this field and should either set it to 0 or leave it unchanged. When you first
create an extended task record, you must ensure that the tmWakeUp field is 0;
otherwise, the Time Manager may interpret it as a prior execution time.
The extended Time Manager allows for a situation that was previously impossible and that
may lead to undesirable results. It is possible to call PrimeTime with an execution time that is
in the past instead of in the future. (With the original and revised Time Managers, only future
execution times are possible.) This situation arises when the time in the tmWakeUp field is
sometime in the past (which is most common in the tmAddr service routine) and you issue a

new PrimeTime request with a delay value that is not large enough to cause the execution time
to be in the future. This may occur when fixed, high-frequency execution is required and the
time needed to process each execution, including the Time Manager overhead, is greater than
the delay time between requests.
When your application issues a PrimeTime request with a tnWakeUp value that would
result in a negative delay, the actual delay time is set to 0. The Time Manager updates the
tmWakeUp field to indicate the time when the task should have awakened (in the past).

Because the actual delay time is set to 0, the task executes immediately. If your application
continually issues PrimeTime requests for times in the past, the Time Manager and the
tmAddr tasks consume all of the processor cycles. As a result, no time is left for the application to run. This situation is a function of processor speed, so you should test applications
that use extended Time Manager features on the slowest processors to ensure compatibility.
Another solution to this problem is to vary the wakeup frequency according
to the processing power of the machine.

Other

Time-Related

Facilities

The Operating System and Toolbox include several other time-related facilities that complement
the services provided by the Time Manager. There are three principal facilities: the TickCount
function, the Delay function, and the Vertical Retrace Manager. One or more of these services
may be more appropriate for your particular timing needs than the Time Manager.

23-8

About the Time Manager

The Time Manager

The

TickCount

Function

The Toolbox Event Manager includes the TickCount function, which returns the total number

of ticks (sixtieths of a second) that have elapsed since the system last started up. The tick
count (maintained in the Ticks global variable) is incremented during the vertical retrace

interrupt. Because this interrupt can sometimes be disabled, the value TickCount returns may

not be exact.

Using the TickCount function, you can write code that mimics some of the capabilities of the
Time Manager. For example, your application can cause a routine to be executed at some time
in the future by simply waiting until the appropriate time and then executing the desired
routine. Your application can delay its own operation by repeatedly calling TickCount until
Ticks exceeds a specified threshold value. Similarly, your application can obtain elapsed-time
information by reading the current tick count at the beginning and at the end of the routine that
you want to time.

The

Delay

Function

There is a better way for your application to delay its own operation than repeatedly calling
the TickCount function—namely, by executing Delay, an operating-system routine that
causes the system to wait a specified number of ticks before resuming execution of your
application. When Delay exits, the Operating System returns the current value of the Ticks
global variable to the calling application. Delay is used primarily to suspend an application
for a particular amount of time and to execute a routine at a later time—after Delay has exited.
But this provides much less control over a routine’s future execution than that provided by
the scheduling services of the Time Manager. With the Delay function, you cannot return to
your application’s code during the delay. Once you queue and activate a Time Manager task,
however, control immediately returns to your application.
Furthermore, the Time Manager provides far greater accuracy than the Delay function. Using
the TickCount and Delay functions may provide sufficiently accurate timing control, but you
need to use the Time Manager routines in cases where very high resolutions are required, as
in performance measurements based on elapsed-time information.

The

Vertical

Retrace

Manager

Originally, the Vertical Retrace Manager handled the queuing and execution of tasks
scheduled to run during VBL interrupts, which occurred each time the electron beam in
the video screen returned from the lower-right to the upper-left corner of the built-in screen.
The VBL interrupts occurred at a known frequency (once every sixtieth of a second), and
an application could use the VInstall function to schedule execution of a task once or
continually after some specified number of VBL interrupts. In this way, your application
could schedule periodic tasks even before the Time Manager existed.
Once it became possible to use external monitors with certain Macintosh computers, the Vertical
Retrace Manager was changed to support different refresh rates and multiple queues. New slotbased VBL interrupts were added—one for each attached video device, with a rate determined
by that video device. The older once-a-tick VBL interrupts were retained, however, for
compatibility reasons. So an application can still schedule routines for execution during a slotgenerated VBL interrupt (using the slotVInstall function) or during a system-generated VBL
interrupt (using the original VInstall). In either case, the indicated routine runs at the future time
specified in the call.
About the Time Manager

23-9

tN

Ge

esr
— |

©
—

<
—

=

=

o9
©

ga

Lee |

Inside Macintosh,

Volume VI

You can use either the Time Manager or the Vertical Retrace Manager to schedule future or
periodic tasks. The main difference between the two scheduling methods is the precision with
which those tasks can be scheduled. You can call system-generated VBL tasks with a
minimum period of 1 tick (one-sixtieth of a second), which is approximately 16 milliseconds.
You can call slot-generated VBL tasks with a minimum period that depends on the refresh
rate of the particular video device associated with that slot, which is usually close to | tick.
The extended Time Manager routines provide much finer resolution, up to 20 microseconds.
Hence, the resolution of the Time Manager is about 1000 times greater than that of the

Vertical Retrace Manager. So in cases where very high resolution is important, you should
use the Time Manager routines instead of the Vertical Retrace Manager routines.
Unlike the Time Manager, the Vertical Retrace Manager is not an absolute time mechanism.
Its operations are always relative to the VBL interrupt, which may be disabled (for instance,
during disk access). As a result, you should use the Time Manager in cases where absolute
time delays are important. Use the Vertical Retrace Manager, however, in cases where the
scheduled actions need simply to be synchronized with other VBL tasks, such as cursor
movement or screen refresh. Applications that do animation on the screen (for example,
some games or multimedia applications) are the kinds of programs that should probably use
VBL tasks instead of Time Manager tasks to perform periodic actions.

USING

THE

TIME

MANAGER

The Time Manager is automatically initialized when the system starts up. At that time, the
queue of Time Manager task records is empty. The Operating System and applications may
place records into the queue. Because the delay time for a given task can be as small as 20
microseconds, you need to install an element into the Time Manager queue before actually
issuing a request to execute it at some future time. You place elements into the queue by
calling the InsTime procedure or (if you need the fixed-frequency services of the extended
Time Manager) the InsXTime procedure. To activate the request, call PrimeTime. The Time
Manager then marks the specified task record as active by setting the high-order bit in the
qT ype field of that record.
The tmAddr field of the Time Manager task record contains the address of a task that the
Time Manager calls when the time delay specified by a previous call to PrimeTime has
elapsed. The task can perform any desired actions, so long as those actions do not call the
Memory Manager (either directly or indirectly) and do not depend on the validity of handles
to unlocked blocks. Time Manager tasks must also preserve all registers other than AOQ—-A3
and DO-D3.
If the routine specified in the Time Manager task record is loaded into the application’s heap,
then the application must still be active when the specified delay elapses, or the application
should call RmvTime before it terminates. Otherwise, the Time Manager will not know that
the address of that routine is not valid when the routine is called. The Time Manager will
then attempt to call the task, but with a stale pointer. If you want to let the application
terminate after it has installed and activated a Time Manager task record, you should load the
routine into the system heap. Generally, however, you should avoid loading routines into
the system heap.

23-10

— Using the Time Manager

The Time Manager

Assembly-language note: In the revised and extended Time Managers,
when a Time Manager task is called, register Al contains a pointer to the Time
Manager task record associated with that routine.

There are two ways in which an active queue element can become inactive. First, the specified time delay can elapse, in which case the routine pointed to by the tmAdadr field is called.
Second, your application can call the RmvTime procedure, in which case the amount of time
remaining before the delay would have elapsed (the unused time) is reported in the tmCount

field of the task record. This feature allows you to use the Time Manager to compute elapsed
times (see “Computing Elapsed Time” later in this chapter), which is useful for obtaining
performance measurements. Calling RmvTime removes an element from the queue whether
or not that task is active at the time RmvTime is called.
To use the Time Manager to perform actions periodically, you simply need to have the routine
pointed to by tmAddr call PrimeTime again. This technique is illustrated in “Performing
Periodic Tasks” later in this chapter. Similarly, you can set up a Time Manager task to
execute a specific number of times by keeping a count of the number of times the task has
been called. In cases where the task needs access to your application’s global variables (such
as a count variable), you need to ensure that the AS register points to your application’s
global variables when the task executes and that A5 contains its original value when your task
exits. A technique for doing this is illustrated in “Using Application Global Variables in
Tasks” later in this chapter.

Installing and Activating Task

Records

Listing 23-1 shows how to install and activate a Time Manager task. It assumes that the
procedure MyTask has already been defined; see Listings 23-3 and 23-4 for examples of
simple task definitions.
Listing 23-1. Installing and activating
PROCEDURE

a Time Manager task

InstallTMTask;

VAR

myTMTask:

TMTask;

{an

myDelay:

LongInt;

{delay

2000;

{no.

BEGIN

myDelay

:=

@MyTask;
myTMTask.tmAddr
myTMTask.tmWakeUp
:= 0;
myTMTask.tmReserved
:= 0;
:=

InsXTime
PrimeTime

(@myTMTask) ;
(@myTMTask,

myDelay);

extended

task

record}

value}
of

milliseconds

to

delay}

of task}
address
{get
{initialize
tmWakeUp}
{initialize
tmReserved}
record}
the task
{install
the task record}
{activate

END;

In this example, InstallTMTask installs an extended task record into the Time Manager queue
and then activates the task. After the specified delay has elapsed (in this case, 2000
milliseconds, or 2 seconds), the procedure MyTask executes.

Using the Time Manager

= 23-11

Inside Macintosh,

Volume

VI

In cases where no task is to run after the specified time delay has elapsed, you should set the
tmAdar field to NIL. To determine if the time has expired, you can check the task-active bit in
the qType field.
Calling PrimeTime on a Time Manager task record that has not yet expired yields unpredictable results and should therefore be avoided. If a prior unexpired request exists in the Time
Manager queue that you wish to reactivate for some different delay, you should call
RmvTime to cancel the prior request, then call InsTime to reinstall the timer task, and finally
call PrimeTime to reschedule the task. Note, however, that it is possible and sometimes
desirable to call PrimeTime in a Time Manager task that you want to reactivate, because the
timer will have expired before the task is called.

Using Application

Global Variables in Tasks

When a Time Manager task executes, the AS world of the application that installed the
corresponding task record into the Time Manager queue might not be valid (for example, the
task might execute at interrupt time when that application is not the current application). If so,
an attempt to read the application’s global variables would return erroneous results because

the A5 register would point to the application global variables of some other application.

When a Time Manager task uses an application’s global variables, it must therefore ensure
that register A5 contains the address of the boundary between the application global variables
and the application parameters of the application that launched it. The task must also restore
register A5 to its original value before exiting.
It is relatively straightforward to read the current value of the A5 register when a Time Manager
task begins to execute (using the SetCurrentA5 function) and to restore it before exiting (using
the SetA5 function). It is more complicated, however, to pass to a Time Manager task the value
to which it should set A5 before accessing its application’s global variables. The reason for this
is quite simple: neither the original nor the extended Time Manager task record contains an
unused field in which the application could pass this information to the task. The situation here
is unlike the situation with Notification Manager tasks or Sound Manager callback routines
(both of which provide an easy way to pass the address of the application’s A5 world to the
task), but it is similar to the situation with VBL tasks.

One way to gain access to the global variables of the application that launched a Time

Manager task from within that task is to pass to InsTime (or InsXTime) and PrimeTime the

address of a structure, the first segment of which is simply the corresponding Time Manager

task record and the remaining segment of which contains the address of the application’s A5
world. For example, you can define a new data structure, a Time Manager information

record, as follows:
TYPE

TMInfo

=

{Time

Manager

information

record}

RECORD

atmTask:
tmWakeUp:

TMTask;
Longint;

{original
{tmWakeUp

tmReserved:

LongInt;

{tmReserved

tmRefCon:

Longint

{space

END;

TMInfoPtr

23-12

=

“TMInfo;

Using the Time Manager

to

and revised
in extended
in
pass

extended
address

TM task record}
task
record}
task
of

A5

record}
world}

The Time Manager

Then you can install and activate your Time Manager task as illustrated in Listing 23-2.
Listing 23-2. Passing the address of the application’s AS world to a Time Manager task
PROCEDURE
VAR

InstallTMTask;

myTMInfo:

TMinfo;

{a

myDelay:

LongIint;

{delay

TM

information

record}

value}

BEGIN
myDelay

:=

2000;

{no.

myTMInfo.atmTask.tmAddr
myTMinfo.tmWakeUp
:= 0;

:=

@MyTask;

of

milliseconds

to

delay}

{get address
of task}
{initialize
tmWakeUp}

myTMInfo.tmReserved
:= 0;
myTMInfo.tmRefCon
:= SetCurrentA5;

{initialize
tmReserved}
{store
address
of your AS

InsTime (@myTMInfo)

{install

PrimeTime

;

(@myTMInfo,

myDelay);

the

{activate

info

the

world}

record}

info

record}

END;

With the revised and extended Time Managers, the task is called with register Al containing
the address passed to InsTime (or InsXTime) and PrimeTime. So the Time Manager task

simply needs to retrieve the TMInfo record and extract the appropriate value of the
application’s A5 world. Listing 23-3 illustrates a sample task definition that does this.
Listing 23-3. Defining
FUNCTION

GetTMInfo:

INLINE

PROCEDURE

a Time Manager task that can manipulate global variables

TMInfoPtr;

$2E89;

{MOVE.L

MyTask;

{for

Al,

(SP)

revised

}

and

extended

is

called}

TMs}

VAR

oldA5:

Longint;

recPtr:

TMInfoPtr;

{A5

when

task

BEGIN

recPtr
Ol1dA5

{do

:=
:=

GetTMInfo;

{first

SetA5(recPtr®.tmRefCon) ;

{set

something

Ol1dA5

:=

with

the

SetA5(ol1dA5);

application's

get

your

record}

to

app's

A5

A5

globals

in

{restore

original

{

and

ignore

world}

here}
A5

}

result}

END;

The main reason that this technique works is that the revised and extended Time Managers
do not care if the record whose address is passed to InsTime (or InsXTime) and PrimeTime
is bigger than what they are expecting. If you use this technique, however, you should take
care to retrieve the address of the task record from register Al as soon as you enter the Time
Manager task (because some compilers generate code that uses registers AO and A] to
dereference structures).

Using the Time Manager

23-13

Inside Macintosh,

Volume

VI

Note: The technique illustrated in Listing 23-3 cannot be used with the original Time
Manager because that version of the Time Manager does not pass the address of the
Al. To gain access to your application’s global variables when
task record in register
using the original Time Manager, you would need to store your application’s A5 in
one of the application’s code segments (in particular, in the code segment that
contains the Time Manager task). This technique involves the use of self-modifying
code segments and is not recommended. Applications that attempt to modify their
own 'CODE ' resources may crash in operating environments that restrict an
application’s access to its own code segments (as, for example, in A/UX®).

Performing

Periodic

Tasks

One way to install a periodic Time Manager task is to have the task reactivate itself. Because
the task record is already inserted into the Time Manager task queue, the task can simply call
PrimeTime to do this. To call PrimeTime, however, the task needs to know the address of
the corresponding task record. In the revised and extended Time Managers, the task record’s
address is placed into register Al when the task is called. Listing 23-4 illustrates how the
task can reactivate itself by retrieving the address in register Al and passing that address
to PrimeTime.
Listing 23-4. Defining a periodic Time Manager task
FUNCTION

GetTMInfo:

INLINE

PROCEDURE
VAR

TMInfoPtr;

$2E89;

{MOVE.L

MyTask;

{for

recPtr:
myDelay:

TMInfoPtr;
LongInt;

Al,

(SP) }

revised

{delay

value}

{first

get

and

extended

TMs}

BEGIN
recPtr

:=

myDelay
{do

GetTMInfo;
:=

2000;

something

PrimeTime

in

{no.

of

your

own

milliseconds

address}
to

delay}

here}

(QElemPtr(recPtr),

myDelay);

END;

Note: The technique illustrated in Listing 23-4 cannot be used with the original Time
Manager because that version of the Time Manager does not pass the address of the
task record in register Al.

Computing

Elapsed

Time

The RmvTime procedure in the revised and extended Time Managers returns any unused time
in the tmCount field of the task record. This feature makes the Time Manager extremely
useful for computing elapsed times, which can, in turn, provide performance measurements.

23-14

— Using the Time Manager

The Time Manager

To compute the amount of time that a routine takes to execute, call PrimeTime at the begin-

ning of the interval to be measured and specify a delay greater than the expected elapsed time.
Then call RmvTime at the end of the interval and subtract the unused time returned in
tmCount from the original delay passed to PrimeTime. To obtain the most accurate results,
you should do all timing in microseconds (in which case the tmCount field of the task record
has a range of about 35 minutes). To get an exact measurement, you should compute the
overhead associated with calling the Time Manager and subtract it from the preliminary result.
Listing 23-5 illustrates a technique for doing this.
Listing 23-5.
;allocate

and

;setting

tmAddr

clear

a

:=

movegq.l1
@clear

TMTask

0

means

Computing

record

no

#(tmQSize/2)-1,d0

;set
; to

so

-(sp)

;allocate

dod,@clear
#60*1000*1000,d7

;clear
;D7 :=

movea.l

sp,a0

; (1 minute)
;AQ0 points
to

TMTask

;install

task

;D6

;DO
:= delay
time
;negate
it for microseconds

will
is

copy

of

initial

;start
the timer
;immediately
stop

be

returned

really

in

negated

subtracting

tmCount

contains
movea.l

(a0) ,da7

the overhead
sp,a0

in

;DO

;negate

it

for

;start

the

timer

of

DBRAs

dbra

a0,

code to be
_RmvTime

timed

@dbraLoop

tmCount

add.1
adda.w
D6

;

the

;number

@dbraLoop

;waste

(a0)

,d6

a7 ,d6

sub.1

;register

loop)

a0

TimeDBRA,

now

contains

the

delay

a

—

number

2
—

_RmvTime

microseconds

per

;subtract

the

Time

TMTask

in

millisecond

microseconds

Mgr

overhead

record

microseconds

code

If you run this code, you might notice that on some models of the Macintosh, register D6 is
not very close to 1000 (one millisecond). This is not due to a problem in the Time Manager.
Rather, this occurs because TimeDBRA is the number of DBRA instructions per millisecond
when executing out of ROM, and RAM accesses have different timing on some models.
Using the Time Manager

Sy)
~
=
FQ

co)
|

time

;stop the timer
:= time used
;D6

of

)
=

millisecond

;deallocate

#tmQSize,sp

timed

Ue

task

do

move .w

:=

the

dé, do

be timed
TimeDBRA

bt

it

=)

neg.1

to
a

delay

;D7 := initial delay ; time remaining
microseconds of _PrimeTime and
;A0 points to TMTask record
;install

of code
example,

record

microseconds,

move.1

;beginning
; (in this

by

the

a7,d0od
ole)

_ PrimeTime

used

TMTask

a7,d6

add.l

of

clear

move.1
neg.l

time

:=

and

it a word at a time
delay in microseconds

move. 1

_InsTime

;end

up loop counter
clear TMTask

clr.w

adding

now

:D7

stack

dbra
move. 1

_ PrimeTime
_RmvTime
:

the

task

_InsTime

sunused

on

elapsed time

= 23-15

Inside Macintosh,

Volume VI

Note: You should not run this sample code on a Macintosh Plus because that
computer’s ROM does not support the TimeDBRA variable.

TIME

MANAGER

ROUTINES

You can insert a task record into the Time Manager’s queue by calling InsTime or InsXTime.
Use InsXTime only if you wish to use the drift-free, fixed-frequency timing services of the
extended Time Manager; use InsTime in all other cases. After you have queued a task record,
you can activate it by calling PrimeTime. You can remove a task record from the queue by
calling RmvTime.
PROCEDURE

InsTime

(tmTaskPtr:

Trap macro

_InsTime

On exit

DO:

On entry

AO:

QElemPtr);

address of TMTask record
result code

InsTime adds the Time Manager task record specified by tmTaskPtr to the Time Manager
queue. Your application should fill in the tmAddr field of the task record and should set
the remaining fields to 0. The tmTaskPtr parameter must point to an original Time Manager
task record.
With the revised and extended Time Managers, you can set tmAddr to NIL if you do not want
a task to execute when the delay passed to PrimeTime expires. Also, calling InsTime with the
revised Time Manager causes the high-order bit of the qT ype field to be reset to 0.
Use the InsXTime procedure if you want to take advantage of the drift-free, fixed-frequency
timing services of the extended Time Manager.
PROCEDURE

InsXTime

Trap macro
On entry
On exit

(tmTaskPtr:

QElemPtr);

_InsXTime
AO: address of TMTask record
DO: result code

InsXTime adds the Time Manager task record specified by tmTaskPtr to the Time Manager
queue. The tmTaskPtr parameter must point to an extended Time Manager task record. Your
application must fill in the tmAddr field of that task. You should set the tmWakeUp and
tmReserved fields to 0 the first time you call InsXTime.
With the extended Time Manager, you can set tmAddr to NIL if you do not want a task to
execute when the delay passed to PrimeTime expires. Also, InsXTime resets the high-order
bit of the qType field to 0.
23-16

Time Manager Routines

The Time Manager

The PrimeTime procedure schedules the routine specified by the tmAddr field of tmTaskPtr
for execution after the delay specified by the count parameter has elapsed.
PROCEDURE

PrimeTime

Trap macro
On entry
On exit

(tmTaskPtr:

QElemPtr;

count:

LongInt);

_PrimeTime
AO: address of TMTask record
DO: specified delay time (long)
DO: result code

If the count parameter is a positive value, it is interpreted in milliseconds. If count is a
negative value, it is interpreted in negated microseconds. (Microsecond delays are allowable
only in the revised and extended Time Managers.) The task record specified by tmTaskPtr
must already be inserted into the queue (by a previous call to InsTime or InsXTime) before
your application calls the PrimeTime procedure. The PrimeTime procedure returns
immediately, and the specified routine is executed after the specified delay has elapsed. If you
call PrimeTime with a time delay of 0, the procedure runs as soon as interrupts are enabled.
In the revised and extended Time Managers, PrimeTime sets the high-order bit of the qType
field to 1. In addition, any value of the count parameter that exceeds the maximum
millisecond delay is reduced to the maximum. If you pause an unexpired task (with
RmvTime) and then reinstall it (with InsXTime), you can continue the previous delay by
calling PrimeTime with the count parameter set to 0.

PROCEDURE

RmvTime

(tmTaskPtr:

QElemPtr) ;

No
ww

=
o

a

Trap macro

_RmvTime

On exit

DO:

On entry

AO:

im

address of TMTask record

=

result code

The RmvTime procedure removes the Time Manager task record specified by tmTaskPtr from
the Time Manager queue. In both the revised and extended Time Managers, if the specified
task record is active (that is, it has been activated but the specified time has not yet elapsed),
the tmCount field of the task record returns the amount of time remaining. To provide the
greatest accuracy, the unused time is reported as negated microseconds if that value is small
enough to fit into the tmCount field (even if the delay was originally specified in
milliseconds); otherwise, the unused time is reported in positive milliseconds. If the time has
already expired, tmCount contains 0.
In the revised and extended Time Managers, PrimeTime sets the high-order bit of the qT ype
field to 0.

Time Manager Routines

23-17

Inside Macintosh,

SUMMARY
Data

OF

THE

TIME

MANAGER

Types

TMTaskPtr

TYPE

Volume VI

=

TMTask

“TMTask;

=

{original

qLink:

QElemPtr;

qType:
tmAddr:

Integer;

{queue

ProcPtr;

tmCount:

Longint

{pointer
to
{reserved}

and

revised

Time

Manager

{next

queue

entry}

task

RECORD

type}

record}

task}

END;

TYPE

TMTask

{extended

Time

Manager

task

record}

RECORD

qLink:

QElemPtr;

qType:
tmAdadr :

Integer;
ProcPtr;

tmCount:

tmWakeUp:

LongInt;

tmReserveda:

{next queue
entry}
{queue
type}
{pointer

to

{unused

time}

LongIint;

{wakeup

time}

Longint

{reserved

task}

for

END;

future

use}

Routines
PROCEDURE

InsTime

(tmTaskPtr:

QElemPtr);

PROCEDURE

InsXTime

(tmTaskPtr:

QElemPtr) ;

PROCEDURE

PrimeTime

(tmTaskPtr:

QElemPtr;

PROCEDURE

RmvTime

(tmTaskPtr:

QElemPtr) ;

Assembly-Language

Information

Structure of Original

and

Revised

qLink
qT ype
tmAddr
tmCount

long
word
long
long

23-18

— Summary of the Time Manager

Time

count:

Manager

pointer to next queue entry
queue type
pointer to task
unused time; returned to caller

LongInt);

Queue

Entry

The Time Manager

Structure of Extended

Time

qLink

pointer to next queue entry
queue type

qType

tmAddr
tmCount

tmWakeUp

tmReserved

long
word
long
long
long
long

Manager

Queue

Entry

pointer to task

unused time; returned to caller

wakeup time; used internally by the Time Manager
reserved for future use

nN

oO
=
=|
_—

@

<
=i]

ge@

Ler |

Summary of the Time Manager

— 23-19

—

NOODOWANAW W

THE

NOTIFICATION

MANAGER

About This Chapter
About the Notification Manager
Using the Notification Manager
Creating a Notification Request
Defining a Response Procedure
Installing a Notification Request

Removing a Notification Request

Notification Manager Routines
Summary of the Notification Manager

Ww
—_

Z.
Sc

=.
=e
¢)

mh
=

—¥

=}

cn
—
a

=

i]
ga
@

Ler |

The Notification Manager

ABOUT

THIS

CHAPTER

This chapter describes how you can use the Notification Manager to inform users of significant occurrences in applications that are running in the background or in software that is
largely invisible to the user. This software includes device drivers, vertical blanking (VBL)
tasks, Time Manager tasks, completion routines, and desk accessories that operate behind the
scenes. It also includes code that executes during the system startup sequence, such as code
contained in 'INIT' resources.
The Notification Manager is available in system software versions 6.0 and later. You can use
the Gestalt function to determine whether the Notification Manager is present. See the
Compatibility Guidelines chapter in this volume for complete details on using Gestalt.
The information in this chapter supersedes the information that was previously published in
Appendix D of the Programmer’s Guide to MultiFinder. You need to read this chapter if your
application, desk accessory, or device driver might need to notify the user of some
occurrence while it is running in the background or is otherwise invisible to the user. You
also need to read this chapter if you want to write 'INIT' resources that might need to inform
the user of important occurrences during their execution at system startup time.

ABOUT

THE

NOTIFICATION

MANAGER

The Notification Manager provides an asynchronous notification service. It allows software
running in the background (or otherwise unseen by the user) to communicate information to
the user. For example, applications that manage lengthy background tasks (such as printing
many documents or transferring large amounts of data to other machines) might need to
inform the user that the operation is complete. These applications cannot use the standard
methods of communicating with the user, such as alert or dialog boxes, because such
windows might easily be obscured by the windows of other applications. Moreover, even if
those windows are visible, the background application cannot be certain that the user is aware
of the change. So some more reliable method must be used to manage the communication
between a background application and the user, who might be awaiting the completion of the
background task while running other applications in the foreground.
In the same way, relatively invisible operations such as Time Manager tasks, VBL tasks, or
device drivers might need to inform the user that some previously started routine is complete
or perhaps that some error has rendered further execution undesirable or impossible.
In all these cases, the communication generally needs to occur in one direction only, from the
background application (or task, or driver) to the user. The Notification Manager, included in
system software versions 6.0 and later, allows you to post to the user a notification, which
is an audible or visible indication that your application (or other piece of software) requires the
user’s attention. You post a notification by issuing a notification request to the Notification
Manager, which places your request into a queue. When your request reaches the top of the
queue, the Notification Manager posts a notification to the user.

About the Notification Manager

24-3

nN
_

Zz
=pe
a

'?)
L
—s

hl @

°
=

2
—

rev)
=
ey)
ge
@i

Inside Macintosh,

Volume VI

You can request three types of notification:
= Polite notification. A small icon appears to flash by periodically alternating with the
Apple® menu icon (which is the Apple symbol) or the Application menu icon in the
menu bar.
=» Audible notification. The Sound Manager plays the system alert sound or a sound
contained in an 'snd ' resource.
a Alert notification. An alert box containing a short message appears on the screen.
The user must dismiss the alert box (by clicking the OK button) before foreground

processing can continue.

These types of notification are not mutually exclusive; for example, an application can
request both audible and alert notifications. Moreover, if the requesting software is listed
in the Application menu (and hence represents a process that is loaded into memory),
you can instruct the Notification Manager to place a diamond-shaped mark next to the
name of the requesting process. The mark is usually intended to prompt the user to switch
the marked application into the foreground. Finally, you can request that the Notification
Manager execute a notification response procedure, which is a procedure that is
executed as the final step in a notification.
In short, a notification consists of one or more of five possible actions. If you request more
than one action, they occur in the following order:
1. A diamond-shaped mark appears next to the name of your application in the Application
menu, as illustrated in Figure 24-1. Note that the diamond is present only when your
application is in the background (because the diamond is replaced by a checkmark if
your application is the active application). In Figure 24-1, the Other App application is
the active application.
2. A small icon alternates with the Apple menu icon or the Application menu icon in the
menu bar. Typically, the small icon is your application’s small icon. Note that several
applications might post notifications, so there might be a series of small icons alternating in the menu bar. The location of each flashing icon follows that of the posting
application’s mark (if any). If your application is marked with a diamond (or a checkmark) in the Application menu, the icon flashes above the Application menu; otherwise,
the icon flashes above the Apple menu.
3. The Sound Manager plays a sound. Your application can supply its own sound (by
passing the Notification Manager a handle to an 'snd ' resource loaded into memory)
or request that the Sound Manager use the user’s system alert sound.

omy

Hide Other App
Hide Others
Shous REE

Finder

+ (7? Sample

/<& Other App

Figure 24-1. A notification in the Application menu
24-4

About the Notification Manager

The Notification Manager

4. An alert box appears, and the user dismisses it. Your application specifies the text in the
alert box; the box looks like the alert box shown in Figure 24-2.
5. A response procedure executes. You can use the response procedure to remove the
notification request from the queue or perform other processing.
The mark in the Application menu and the alternating small icon remain until the requesting
application removes the notification request from the queue. However, the sound and the
alert box are presented only once, if at all.
Any applications, desk accessories, tasks, routines, or drivers can use the Notification
Manager, whether they are running in the background or not. It is especially useful for
background applications, such as the PrintMonitor application. (The system alarm, which
is called by the Alarm Clock desk accessory, also uses the Notification Manager.) Foreground applications can, however, use the services of the Notification Manager to achieve
effects (such as the alternating small icon) that are otherwise more difficult to create. For
the same reasons, the Notification Manager can be useful even to applications that might be

executing in a Finder™-only environment under system software version 6.0.

The Notification Manager provides applications with a standard user interface for notifying
the user of significant events. It is suggested that your application adopt the following threelevel notification strategy for communicating with the user:
|. Display a diamond next to the name of the application in the Application menu.
2. Insert a small icon into the list of icons that alternate with the Apple menu icon or the
Application menu icon in the menu bar, and display a diamond next to the name of

your application in the Application menu.

3. Display a diamond, insert a small icon, and put up an alert box to notify the user that
something needs to be done.

nN
don

Ideally, the user should be allowed to set the desired level of notification. The suggested
default level of notification is level 2. In levels 2 and 3, you might also play a sound, but the
user should have the ability to turn the sound off. In addition, a user should have the ability
to turn off background notification altogether, except in cases where damage might occur or
data would be lost.

alert

—_—

ie)
~

te
-_~
ws

=

~

—
—
—

—

i>)

@
“

A sample alert box
About the Notification Manager

ie
mans 8

¢)

i)

box!

Figure 24-2.

=

—
as

Note: This suggested notification strategy may not be appropriate for your application. Notifications posted by system software do not follow these guidelines.

Sample

4.
—

24-5

Inside Macintosh,

Volume

VI

Each application, desk accessory, and device driver can issue any number of notification
requests. Each requested notification is presented separately to the user. For this reason, you
should try to avoid posting multiple notification requests for the same occurrence. Depending
on the method of notification you specify, multiple requests might result in an annoying
number of notification sounds or a large number of alert boxes that the user must dismiss
before continuing.
Note that the Notification Manager provides a one-way communications path from an application to the user. There is no provision for carrying information back from the user to the
requesting application, although it is possible for the requesting application to determine if

the notification was received. If you require this secondary communications link, do not use
the Notification Manager. Instead, you should wait until the user switches your application
into the foreground and then use standard means (for example, a dialog box) to obtain the
required information.

USING

THE

NOTIFICATION

MANAGER

To issue a notification to the user, you need to create a notification request and install it into

the notification queue. The Notification Manager interprets the request and presents the
notification to the user at the earliest possible time. After you have notified the user in the
desired manner (that is, placed a diamond mark in the Application menu, added a small icon
to the list of icons that alternate in the menu bar, played a sound, or presented the user with
an alert box), you might want the Notification Manager to call a response procedure. The
response procedure is useful for determining that the user has indeed seen the notification or
for reacting to the successful posting of the notification. Eventually, you will need to remove
the notification request from the notification queue; you can do this in the response procedure
or when your application returns to the foreground.
The Notification Manager is automatically initialized at system startup time. It includes two
functions, one that allows you to install a request into the notification queue and one that
allows you to remove a request from that queue.

Creating

a Notification

Request

Information describing each notification request is contained in the notification queue,
which is a standard Macintosh® queue, as described in the Operating System Utilities chapter
of Volume II. When installing a request into the notification queue, your application must
supply a pointer to a notification record that indicates the type of notification you desire. Each
entry in the notification queue is a notification record—a static and nonrelocatable record
of type NMRec.
TYPE

NMRec

=

RECORD

24-6

qLink:

QElemPtr;

{next

qType:
nmFlags:

Integer;
Integer;

{queue
type:
{reserved}

nmPrivate:

Longint;

{reserved}

nmReserved:
nmMark:

Integer;
Integer;

{reserved}
{item to mark

Using the Notification Manager

queue

entry}
ORD(nmType)

in

menu}

=

8}

The Notification Manager

nmicon:

Handle;

{handle

to

icon}

nmSound:

Handle;

{handle

to

sound

nmStr:

StringPtr;

{string

to

appear

nmResp:

ProcPtr;

{pointer

nmRefCon:

LongInt

{for

to

resource}
in

response

application's

alert

box}

procedure}

use}

END;

To set up a notification request, you need to fill in the fields ql ype, nmMark, nmiIcon,
nmSound, nmStr, nmResp, and nmRefCon. The remaining fields of this record are used
internally by the Notification Manager or are reserved for use by Apple Computer, Inc.
Note: In system software version 6.0, the field nmIcon is named nmSIcon and
should contain a handle to a small icon (a 16-by-16 bitmap, often stored as an
'SICN' resource).
Field

descriptions

qLink

Points to the next element in the queue. This field is used internally by
the Notification Manager.

qType

Indicates the type of operating-system queue. You should set this field
to the value ORD(nmType), which is 8.

nmFlags

Reserved for use by Apple.

nmPrivate

Reserved for use by Apple.

nmReserved

Reserved for use by Apple.

nmMark

Indicates whether to place a diamond-shaped mark next to the name of
the application in the Application menu. If nmMark is 0, no such mark
appears. If nmMark is 1, the mark appears next to the name of the
calling application. If nmMark is neither 0 nor 1, it is interpreted as the
reference number of a desk accessory. An application should pass 1, a
desk accessory should pass its own reference number, and a driver or
a detached background task (such as a VBL task or Time Manager
task) should pass 0.

nmicon

Contains a handle to a small icon or to an icon family containing a
small color icon that is to alternate periodically in the menu bar. If
nmicon is NIL, no icon appears in the menu bar. If nmIcon is not
NIL, then the Notification Manager determines whether it is a handle
to a small icon or to an icon family containing a small color icon. This
handle must be valid at the time that the notification occurs; it does not
need to be locked, but must be nonpurgeable.

nmSound

Contains a handle to a sound resource to be played with SndPlay. If
nmSound is NIL, no sound is produced. If nmSound is —1, then the
system alert sound plays. This handle does not need to be locked, but
it must be nonpurgeable.

nmStr

Points to a string that appears in the alert box. If nmStr is NIL, no
alert box appears. Note that the Notification Manager does not make
a copy of this string, so your application should not dispose of this
storage until it removes the notification request.
Using the Notification Manager

24-7

boN
F

=

it

©

~~

=.

S
=

2
—

i)

=re)
ge
ic

Inside Macintosh,

Volume VI

nmResp

Points to a response procedure. If nmResp is NIL, no response
procedure executes when the notification is posted. If nmResp is -1,
then a predefined procedure removes the notification request
immediately after it has completed.

nmRefCon

A long integer available for your application’s own use.

Listing 24-1 illustrates how to set up a notification record.
Listing 24-1.

Setting up a notification record

VAR
myNotification:

NMRec;

{a

myResNum:
myResHand:

Integer;
Handle;

{resource
ID of small
{handle
to small
icon

myText :

Str255;

{string

BEGIN
myResNum

:=

1234;

myResHand

:=

myText

'Sample

WITH

:=

notification

to

{resource

GetResource('SICN',
Alert

myNotification

Box';

record}

print
ID

in

in

icon resource}
resource}

alert

box}

resource

fork}

myResNum) ;

{get

small

{set

message

icon

from

for

resource

alert

fork}

box}

DO

BEGIN

qType
:= ORD(nmType) ;
nmMark
:= 1;
nmicon
:= myResHand;

{set queue
type}
{put mark
in Application
{alternating
icon}

nmSound

{play

nmmStr

:=
:=

nmResp
nmRefCon

:=

Handle(-1);

system

@myText;

{display

NIL;

ino

response

:=

{not

needed}

NIL;

alert

alert

menu}

sound}

box}
procedure}

END;
END;

This notification record requests all three types of notification—polite (alternating small icon),
audible (system alert sound), and alert (alert box). In addition, the diamond appears in front
of the application’s name in the Application menu. In this case, the small icon has resource ID
1234 of type 'SICN' in the application’s resource fork.

Defining

a Response

Procedure

The nmResp field of the notification record contains the address of a response procedure
that executes as the final stage of a notification. If you do not need to do any processing in
response to the notification, then you can supply the value NIL in that field. If you supply
the address of your own response procedure in the nmResp field, the Notification Manager
passes it one parameter, a pointer to your notification record. For example, this is how you
would declare a response procedure having the name MyResponse:
PROCEDURE

24-8

MyResponse

(nmReqPtr:

NMRecPtr) ;

Using the Notification Manager

The Notification Manager

When the Notification Manager calls this response procedure, it does not set up A5 or lowmemory global variables for you. If you need to access your application’s global variables,
you should save its A5 in the nmRefCon field. See the Memory Management chapter in this
volume for more information on saving and restoring the A5 world.
Response procedures should never draw on the screen or otherwise affect the human interface.
Rather, you should use them simply to remove notification requests from the notification
queue and free any memory. If you specify the special nmResp value of —1, the Notification
Manager removes the queue element from the queue automatically, so you don’t have to do it
yourself. You have to pass your own response routine, however, if you need to do anything
else in the response procedure, such as free the memory block containing the queue element or
set an application global variable that indicates that the notification was received.
If you choose to use audible or alert notifications, you should probably use an nmResp value
of —1 so that the notification record is removed from the queue as soon as the sound has
finished or the user has dismissed the alert box. However, if either nmMark or nmIcon is
nonzero, you should not use an nmResp value of —1 because the Notification Manager would
remove the diamond mark or the small icon before the user could see it. Note that an nmResp
value of —1 does not free the memory block containing the queue element; it merely removes
that element from the notification queue.
Since the response procedure executes as the last step in the notification process, your application can determine that the notification was posted by examining a global variable that you
set in the response procedure. In addition, to determine that the user has actually received the
notification, you need to request an alert notification. This is because the response procedure
executes only after the user has clicked the OK button in the alert box.

Installing a Notification

Request

To add a notification request to the notification queue, call NMInstall. For example, you can
install the notification request defined in Listing 24-1 with the following line of code:

bh
4+
—)
-_
tae
—
ous
ic)
as
oe
~

myErr

:=

NMInstall

(@myNotification);

{install

notification

request}

cae
=

-_

Before calling NMInstall, you should check to make sure that your application is running in
the background. If your application is in the foreground, you do not need to use the
Notification Manager to notify the user; instead, you can simply use standard methods for
playing sounds or putting up alert boxes.

~
-

—

a
an
2°
A
ij=}

—_—

—
as

-~

ae)
—

Note: VBL tasks, Time Manager tasks, and device drivers that want to install
notification requests do not need to make this check because they are never in the
foreground. Generally, however, a VBL task or a Time Manager task can avoid
issuing notification requests by setting a global flag that informs the application
that installed it that a notification needs to be requested. When that application
receives some processing time, it can alert the user in the appropriate manner (that
is, by putting up an alert box or by issuing a notification request). This method
allows you to keep interrupt-time tasks, such as VBL and Time Manager tasks,
small and quick.

Using the Notification Manager

24-9

,

Inside Macintosh, Volume VI

If the call to NMInstall returns an error, then you cannot install the notification request in
the notification queue. In that case, your application must wait for the user to switch it into
the foreground before doing further processing. While waiting for a resume event, your
application should take care of other events, such as updates. Note, however, that the only
reason that NMInstall might fail is if it is passed invalid information, namely, the wrong
value for qT ype.
You can install notification requests at any time, even when the system is executing 'INIT'
resources as part of the system startup sequence. If you need to notify the user of some
important occurrence during the execution of your 'INIT' resource, you should use the
Notification Manager to install a request in the notification queue. The system notifies the
user after the startup process completes, that is, when the normal event mechanism begins.
This saves you from having to interrupt the system startup sequence with dialog or alert
boxes and results in a cleaner and more uniform startup appearance.

Removing

a Notification

Request

To remove a notification request from the notification queue, call NMRemove. For example,
you can remove a notification request with this code:
myErr

:=

NMRemove

(@myNotification);

{remove

notification

request}

You can remove requests at any time, either before or after the notification actually occurs.
Note that requests that have already been issued by the Notification Manager are not
automatically removed from the queue.

NOTIFICATION

MANAGER

ROUTINES

The Notification Manager includes two functions, one to install a notification request and one
to remove a notification request. To install a notification request, use the function NMInstall.
FUNCTION

NMInstall

(nmReqPtr:

Trap macro
On entry
On exit

NMRecPtr)

_NMInstall
AO: address of
DO: result code

: OSErr;

NMRec record

NMInstall has a single parameter, nmRecPtr, which is a pointer to a notification record. It
adds the notification request specified by that record to the notification queue and returns a
result code.
Result codes
noErr
nmTypErr
24-10

0
-299

No error
Invalid qTlype (must be ORD(nmType))

Notification Manager Routines

The Notification Manager

Note: NMInstall does not move or purge memory, so you can call it from
completion routines or interrupt handlers as well as from the main body of an
application and from the response procedure of a notification request.
NMRemove removes the notification request identified by nmReqPtr from the notification
queue and returns a result code.
FUNCTION

NMRemove

(nmReqPtr:

NMRecPtr)

Trap macro

_NMRemove

On exit

DO:

On entry

Result codes

noErr
qErr
nmTypErr

AO:

0)
—|
-299

:

OSErr;

address of NMRec record
result code

No error
Not in queue
Invalid qlype (must be ORD(nmType))

Note: NMRemove does not move or purge memory, so you can call it from
completion routines or interrupt handlers as well as from the main body of an
application and from the response procedure of a notification request.

iw)
+
Zz

S

_

=
ee}
O

+)

=.
So
=
2

Loma

yy
=
i)
ge

ic)

Notification Manager Routines

24-11

Inside Macintosh,

Volume VI

SUMMARY

OF

THE

NOTIFICATION

MANAGER

Constant
CONST

nmType

Data

Types

TYPE

NMRec

=

8

=

RECORD

END;

qLink:

QElemPtr;

{next

qType:

Integer;

nmFlags:

Integer;

{queue
type:
{reserved}

queue

entry}

nmPrivate:
nmReserved:

LongInt;
Integer;

nmMark:

Integer;

{reserved}
{item to mark

nmicon:

Handle;

{handle

to

ORD(nmType)

in

Handle;

{handle

to

sound

StringPtr;

{string

to

appear

nmResp:

PrOCPERT;

{pointer

nmRefCon:

Longint

{for

to

menu}

icon}

nmSound:

=

resource}
in

response

application's

use}

Routines
FUNCTION

NMInstall

(nmRegPtr:

NMRecPtr)

OSErr;

FUNCTION

NMRemove

(nmReqPtr:

NMRecPtr)

OSErr;

PROCEDURE

Result
noErr
qErr
nmTypErr
24-12

MyResponse

Routines
(nmReqPtr:

NMRecPtr) ;

Codes
0
—]
—299

No error
Not in queue
Invalid qT ype (must be ORD(nmType))

Summary of the Notification Manager

alert

box}

procedure}

“NMRec;

Application-Defined

8}

{reserved}

nmStr:

NMRecPtr

=

NO
O1
VW
& W
Ooms

10

THE

FILE

MANAGER

About This Chapter
About the File Manager
Identifying Files, Directories, and Volumes
File System Specifications
The Evolution of File Specification Strategies
Limitations on MFS Disks
A Simpler Safe-Save Strategy
New Special-Purpose Features
A Quick, Thorough Catalog Search
File IDs
Shared Environments
Remote Mounting
Privilege Information in Foreign File Systems
Using the File Manager
Using FSSpec Records
Updating Files
Searching a Volume
Tracking Files With File IDs
Mounting Volumes Programmatically
Manipulating Privilege Information in Foreign File Systems
High-Level File Manager Routines
Routines That Use FSSpec Records
Making FSSpec Records
Exchanging the Data in Two Files
Functions Modified to Accept FSSpec Records
Opening a Data Fork
Managing HFS
Functions New With HFS
MES Functions Modified to Accommodate Directory IDs
Low-Level File Manager Routines
Reading Volume Information
Searching a Catalog
Creating FSSpec Records
Swapping Data Between Two Files
Creating and Using File IDs
Functions for Manipulating File [Ds
Functions Changed to Accommodate File IDs
Mounting Volumes
Accessing Privilege Information in Foreign File Systems
Opening Data Forks
Summary of the File Manager

ty
wm

=

oO

=<

D
=
ge@

—

Lew

25-1

|

The File Manager

ABOUT

THIS

CHAPTER

This chapter describes how your application can use the File Manager features introduced in
system software version 7.0 to manipulate files. This chapter supplements the File Manager
information in Volumes IV and V.
Read this chapter if your application creates, saves, or opens files.
Most of the features described in this chapter are available only in system software version 7.0
or later. To determine which features are available in a specific operating environment, use the
Gestalt function, described in the Compatibility Guidelines chapter of this volume. The availability of some features depends on the characteristics of the volume rather than on the system
software. To determine which features a volume supports, use the PBHGetVolParms function,
described in this chapter. A complete description of how you check for various new features
appears at the beginning of “Using the File Manager” in this chapter.
To use this chapter you must be familiar with the file system documentation in Volume IV.

ABOUT

THE

FILE

MANAGER

The File Manager is the part of the Operating System that gives your application access to data
storage devices such as disk drives. You use the File Manager to create, write, and read files.
To fully exploit system software version 7.0, your application should adopt two new File
Manager features:
w the file system specification record, a new convention for identifying files and
directories (see “Identifying Files, Directories, and Volumes” later in this chapter)
m the strategy of updating a stored file by changing the catalog entries (see “A Simpler
Safe-Save Strategy” later in this chapter)
The File Manager in version 7.0 also introduces a number of special-purpose functions that

you can use to

bo
Un
Ee?

m search an entire volume quickly, matching entries in almost any of the catalog
information fields, such as file creation date or file length

oO

a
teal
=)

=

a track files by assigning and resolving file identification numbers

ye
@

-y

m= mount volumes
= manipulate access-control privileges in foreign file systems
Version 7.0 supplies high-level versions of some functions previously available only as
low-level functions. These functions have been available historically in some development
environments but have not been documented before in /nside Macintosh.
About the File Manager

25-3

Inside Macintosh,

Volume

VI

The PBHGetVolParms function, which reports volume information, has been expanded and
updated to reflect features in version 7.0. Some File Manager routines have been modified to
accommodate file identification numbers.
System software version 7.0 includes a local version of Apple’s file-server application,
AppleShare®. This feature allows the user to make some or all of the files on a local volume
available over a network, increasing the chance that your application may be used in a shared
environment. As long as you follow the standard guidelines for Macintosh® programming,
your application should work in a shared environment. If you want to exploit the full power
of a shared environment, follow the guidelines in the File Manager Extensions in a Shared
Environment chapter of Volume V.
To help you understand and use the version 7.0 File Manager, the first few sections of this
chapter introduce the new features you should use: the new convention for identifying files
and directories and the new strategy for updating stored files safely. The “New SpecialPurpose Features” section later in this chapter introduces an assortment of other powerful but
more specialized features.
The “Using the File Manager” section later in this chapter contains instructions for using the
new features of the File Manager to
recognize and use a standard file identification convention
m update a stored file safely
m search a volume for one or more files or directories
m assign and resolve file ID numbers
= manipulate the permission information that controls access to files on volumes
controlled by different operating systems, such as A/UX®

IDENTIFYING

FILES,

DIRECTORIES,

AND

VOLUMES

Your application typically specifies a filename and location when it calls the File Manager to
open or delete a file. It typically receives filenames and locations from the Standard File
Package and the Finder™, which handle the user interface for creating, saving, opening, and
removing files.

File System

Specifications

Conventions for identifying files, directories, and volumes have evolved as the File Manager
has matured. Version 7.0 introduces a simple, standard form for identifying a file or directory, called a file system specification. You can use a file system specification whenever you
must identify a file or directory for the File Manager.

25-4

Identifying Files, Directories, and Volumes

The File Manager

The file system specification contains
w the volume reference number of the volume on which the file or directory resides
m the directory ID of the parent directory
m the name of the file or directory
For a complete description of the new data structure, the file system specification (FSSpec)
record, see “Using FSSpec Records” later in this chapter.
The Standard File Package in system software version 7.0 uses FSSpec records to identify
files to be saved or opened. The File Manager provides a new set of high-level routines that
accept FSSpec records as input, so that your application can pass the data directly from the
Standard File Package to the File Manager. The Alias Manager and the Edition Manager
accept file specifications only in the form of FSSpec records.
The Finder in version 7.0 uses alias records, which are resolved into FSSpec records, to
identify files to be opened or printed. (The description of required Apple® events in the Apple
Event Manager chapter of this volume explains how the Finder passes file information to
your application and how your application retrieves it.)
Version 7.0 also introduces the FSMakeFSSpec function, which creates an FSSpec record
for a file or directory. For a complete description of FSMakeFSSpec, see “Using FSSpec
Records” and “Making FSSpec Records” later in this chapter.

The

Evolution

of File Specification

Strategies

The original Macintosh File System (MFS) is a “flat” file system—that is, a system in

which all files are stored at the same level on a volume (the volume is not subdivided into

directories). To uniquely identify a file, you need to specify only a volume and a filename.
In high-level MFS functions, you pass the specification in parameters called VRefNum and
fileName. (For a complete description of MFS, see the File Manager chapter in Volume II
or IV.)

In MFS, you can specify a file in either of two ways:
w a full pathname, which contains the names of both the volume and the file, in the
fileName parameter
= filename by name in the fileName parameter and volume by volume reference number, a
unique number assigned when the volume is mounted, in the vVRefNum parameter

—

=
~

tis)
io

Figure 25-1 illustrates the two ways to identify a file in MFS.

Identifying Files, Directories, and Volumes

=
=:
@
<4
oS

Lear

25-5

|

Inside Macintosh,

Volume VI

Full pathname
cl

vRefNum_

/ Loma Prieta

|

ignored

+ fileName

full pathname

} vRefNum

volume reference number
or 0 for default volume

Loma

Prieta:Lines

+

Lines

Volume and partial pathname

=

/ Loma'Prieta

fileName

partial pathname
Lines

Lines

Figure 25-1.

Identifying a file in MFS

To improve performance, especially with larger volumes, Apple Computer, Inc., introduced
the Hierarchical File System (HFS) on the Macintosh Plus computer and later models. In
HES, a volume can be divided into smaller units known as directories, which can them-

selves contain files or other directories. Each file on an HFS volume is stored in a directory.
To identify a file in HFS, you must specify its volume, its parent directory, and its name.
The File Manager assigns each directory a directory ID, and the user or the system software
assigns each directory a name. The HFS File Manager routines include an additional parameter, the dirID parameter, to handle the directory specification. (For a complete description of
HFS, see the File Manager chapter in Volume IV.)
In HFS, each folder created by the user is a directory. The folders represent a true hierarchy
in the file system. In MFS, folders are an illusion maintained for the user by the system
software. The first-level directory on a volume, the one that contains all of the other
directories, is known as the root directory.
For compatibility between HFS and MFS, Apple introduced the concept of working
directories. A working directory is a combined directory and volume specification. To
make a directory into a working directory, the File Manager establishes a control block
that contains both the volume and the directory ID of the target directory. The File Manager
then returns a unique working directory reference number, which you can use to identify
the directory. You can use the working directory reference number in place of a volume
specification in all of the MFS functions.

25-6

Identifying Files, Directories, and Volumes

The File Manager

Note: Working directories were introduced solely for compatibility between HFS
and MFS. If you are writing an application to run in system software version 7.0,
you do not need to use working directories.
In summary, HFS recognizes three kinds of file system objects: files, directories, and
volumes. You can identify them using these labels:
File

filename

Directory

directory name
directory ID
working directory reference number, which also implies a volume

Volume

volume name
volume reference number
working directory reference number, which also implies a directory

In HFS, you can pass a complete file specification in any of four ways:
a full pathname
m volume reference number and partial pathname
w working directory reference number and partial pathname
= volume reference number, directory ID, and partial pathname
A full pathname consists of the name of the volume, the names of all directories between
the root directory and the target, and the name of the target. A full pathname starts with a
character other than a colon and contains at least one colon. If the first character is a colon,
or if the pathname contains no colons, it is a partial pathname. If a partial pathname starts
with the name of a parent directory, the first character in the pathname must be a colon. If
a partial pathname contains only the name of the target file or directory, the leading colon
is optional.
You can identify a volume in the vVRefNum parameter by volume reference number or drive
number, but volume reference number is preferred. A value of 0 represents the default
volume. A volume name in the pathname overrides any other volume specification. Unlike
a volume name, a volume reference number is guaranteed to be unique. It changes, however,
each time a volume is mounted.
Note: The system software that accompanied the release of HFS introduced the
PBHSetVol function for setting the default volume on a hierarchical disk. Do not use
the PBHSetVol function or the high-level version, HSetVol, which is available in
some development environments. If you need to set the default volume, use SetVol
or PBSetVol, described in the File Manager chapter of Volume IV.
A working directory reference number represents both the directory ID and the volume
reference number. If you specify any value other than 0 for the dirID parameter, that value
overrides the directory ID implied by a working directory reference number in the volume
parameter. The volume specification remains valid.
Figure 25-2 illustrates the four ways to identify a file in HFS.
Identifying Files, Directories, and Volumes

25-7

Inside Macintosh,

Volume VI

Full pathname
|

Loma Prieta

vRefNum

ignored

dirlD

ignored

Art
- fileName

full pathname
Loma

Prieta:Art:Lines

Lines

enh

Volume and partial pathname
0

- vRefNum

a

Loma Prieta

—

dirlD

volume reference number
or O for default volume

0

Art
- fileName
Lines

partial pathname
:Art:Lines

~

Working directory and partial pathname
4
oO

- vRefNum

_ Loma Prieta

dirlD

Art

- fileName
Lines

working directory

reference number

0
partial pathname
Lines

4

Volume, directory ID, and partial pathname
—

- vRefNum

volume reference number,
O for default volume,
or working directory reference number

F dirlD

directory ID (a nonzero value here
overrides directory implied
by working directory reference

Loma Prieta

Art

+

fy fileName

25-8

partial pathname
Lines

Lines

Figure 25-2.

number in vRefNum)

Identifying a file in HFS

Identifying Files, Directories, and Volumes

The File Manager

The FSSpec record described in the previous section, “File System Specifications,” replaces
both the MFS and the HFS conventions for identifying files and directories in most cases. In
system software version 7.0, you use the historical forms primarily when calling low-level
File Manager functions.

LIMITATIONS

ON

MFS

DISKS

System software version 7.0 still supports MFS disks, insofar as your application can

still read and write files on MFS disks. There are, however, limitations on MFS disks in
version 7.0.
MES disks cannot be renamed.
MFS disks cannot have comments; however, files located within MFS disks can have
comments.

The Finder in system software version 7.0 ignores folders created on an MFS disk by
older versions of the Finder. The folders are not displayed. A file in such a folder
appears in the root level of the disk but has the same relative position in the window
that it has in the MFS folder.
The Finder does not use or save window position or size information about files located
on an MFS disk.
You cannot create an alias for an MFS volume. More generally, Alias Manager functions
and the FSMakeFSSpec function do not work if their target is an MFS volume. You can,
however, create aliases for files on an MFS volume. Similarly, you can use the new File
Manager functions that use FSSpec records on files on an MFS volume.
You should not call the File Manager function PBGetFCBInfo on MFS volumes.
The Process Manager’s GetProcessInformation function may not return correct results
about the location of the application file if the application file resides on an MFS
volume.
If the user renames an edition located on an MFS volume, the Edition Manager may not
be able to find that edition for any document that publishes to or subscribes to it. Also,
if the user opens an edition in the Finder that is located on an MFS volume and updates
that edition, the Finder window closes.

A SIMPLER

SAFE-SAVE

)
un

=

oO

=

oS
=
$9
re
©

STRATEGY

ar

When the user saves a changed version of a document, most applications perform a “safe
save” —a sequence of updating, renaming, saving, and deleting files that preserves the
contents of the old file until the new version is safely recorded. Typically, an application
saves the new version of the file under a temporary name, renames both files, and then
discards the original.
A Simpler Safe-Save Strategy

25-9

Inside Macintosh,

Volume VI

Version 7.0 introduces the FSpExchangeFiles and PBExchangeFiles functions, which
simplify a safe save. Both functions exchange the contents of two files by altering the catalog
entries for the files. To save a new version of a file using file exchange, you save the copy,

exchange the contents of the two files, and discard the newly saved file, which now holds the

original version of the file. See “Updating Files” later in this chapter for a description of how
to update files with FSpExchangeFiles.
Updating a file with FSpExchangeFiles preserves the file’s ID, which is used by the Alias
Manager. (See “File IDs” later in this chapter for a description of file IDs; see the Finder
Interface chapter of this volume for a description of Finder aliases and the Alias Manager
chapter of this volume for a description of the underlying software.) Although the Alias
Manager is usually able to resolve an alias with an obsolete file ID, you can improve the
reliability of aliases by preserving file IDs on all saves.

NEW

SPECIAL-PURPOSE

FEATURES

Version 7.0 contains a number of specialized functions that give you more control over
various kinds of file manipulation. You can use these functions to examine the information
in a volume’s catalog, to track files on a volume, and to manipulate access privileges on
non-Macintosh file systems.

A

Quick,

Thorough

Catalog

Search

Version 7.0 introduces the PBCatSearch function, a new function for examining a volume’s
catalog, which contains descriptions of all the files and directories on the volume.
A single call to the PBCatSearch function can replace a series of indexed calls to the

PBGetFInfo, PBHGetFInfo, or PBGetCatInfo function, which all return a collection of catalog

information about an individual file or directory. In MFS, you could examine all catalog entries
on a volume by calling PBGetFInfo repeatedly, using an index to step through the catalog. On
an HFS volume, indexed calls to the equivalent function, PBHGetFInfo, examine the files and
directories in only one directory. To examine the catalog information for all files on an HFS
volume with PBHGetFInfo, or all the files and directories with PBGetCatInfo, you have to
perform a recursive search through the hierarchy. Especially on a large hierarchical volume,
searching the catalog with a series of individual calls can be time-consuming.
The PBCatSearch function lets you search the entire catalog with a single procedure call.
It compares each catalog entry with a set of specifications you provide, and it gives you a
list of all entries that meet your search criteria. For a detailed description of how to use the
PBCatSearch function, see “Searching a Volume” later in this chapter.

File IDs
Version 7.0 introduces the file ID, a tool for identifying a file that your application may
need to find again later. The file ID lets you reference a file through its file number in the
volume catalog.

25-10

New Special-Purpose Features

The File Manager

A file number is a unique number assigned to a file when it’s created. The File Manager can
set up an internal record in the volume’s catalog that records the filename and parent directory
ID of the file with a given file number, establishing the file number as the file’s ID and
enabling you to reference the file by that number. (For more information about the volume’s
catalog, see the File Manager chapter of Volume IV.)
Note: The file ID is a low-level tool and is unique only on one HFS volume. In
most cases, your application should track files using the Alias Manager, described in
the Alias Manager chapter of this volume. The Alias Manager can track files across
volumes. It creates a detailed record describing a file that you want to track, and,
when you need to resolve the record later, it performs a sophisticated search. The
Alias Manager uses file IDs internally.
A file ID is analogous to a directory ID. A file ID is unique only within a volume. A file ID
remains constant even when the file is moved or renamed. When a file is copied or restored
from backup, however, the file ID changes. Like file numbers, file IDs are unique over
time—that is, once a number has been assigned to a file, that number is not reused even after
the file has been deleted.
The file ID represents a permanent reference for a file, a reference that a user cannot change.
Your application can store a file ID so that it can locate a specific file quickly and automatically, even if the user has moved or renamed it on the same volume.
File IDs are intended only as a tool for tracking files, not as a new element in file specification
conventions. Neither high-level nor low-level File Manager functions accept file [Ds as
parameters. If you want to use file IDs, you must use the new functions for manipulating
them, described in “Tracking Files With File IDs” and “Functions for Manipulating File IDs”
later in this chapter.

Shared

Environments

AppleShare, Apple’s file-server application, allows users to share data, applications, and
disk storage over a network. System software version 7.0 introduces a local version of
AppleShare that allows users to make some or all of the files on a volume available over
the network.
Most applications do not have to accommodate shared environments explicitly. As long as
you follow the programming guidelines recommended in /nside Macintosh, your application
should work in a shared environment. If your application directly manipulates files across a
network, however, it should use the File Manager extensions described in Volume V.

oO

<
iS
="

Mounting

The user mounts remote shared volumes through the Chooser. The version 7.0 File Manager
provides a set of calls that you can use to collect the mounting information from a mounted
volume and then use that information to mount the volume again later, without going through
the Chooser.
New Special-Purpose Features

2.
$9
=|
g9
oe

This section introduces two new File Manager features for use in shared environments:
volume mounting and manipulating privilege information in foreign file systems.

Remote

S)
mr

= 25-11

Inside Macintosh,

Volume

VI

Privilege Information

in Foreign

File Systems

Virtually every file system has its own privilege model, that is, conventions for controlling
access to stored files. A number of non-Macintosh file systems support access from a
Macintosh computer by mapping their native privilege models onto the model defined by the
AppleTalk Filing Protocol (AFP). Most applications that manipulate files in foreign file
systems can rely on the intervening software to translate AFP privileges into whatever is
required by the remote system.

The correlation is not always simple, however, and some applications require more control

over the files stored on the foreign system. The A/UX privilege model, for example, recognizes four kinds of access: read, write, execute, and search. The AFP model recognizes only
read and read-and-write access. (See the File Manager chapter of Volume V for a description
of the AFP model.) If a shell program running on the Macintosh Operating System wants to
allow the user to set native A/UX privileges on a remote file, it has to communicate with the
A/UX file system using the A/UX privilege model.
System software version 7.0 provides two new functions, PBGetForeignPrivs and
PBSetForeignPrivs, for manipulating privileges in a non-Macintosh file system. These
functions do not relieve a foreign file system of the need to map its own privilege model
onto the AFP calls.

USING

THE

FILE

MANAGER

This section provides specific techniques for using the new features of the File Manager.
mw Youcan pass FSSpec records received from the Standard File Package and the Finder
directly to a set of high-level File Manager functions.
m Youcan exchange the contents of two files when updating a stored file, using the
FSpExchangeFiles function.
m= You can search a volume’s catalog quickly, looking for files or directories that meet the
criteria you specify, using the PBCatSearch function.
m= You can track files within a volume by file number, using the set of functions that create
and manipulate file ID references.
m You can mount a remote volume programmatically, without going through the Chooser,
using the remote mounting functions.
m You can read and change privilege information in foreign file systems using the
PBGetForeignPrivs and PBSetForeignPrivs functions.
Some of the new File Manager features depend on the system software; others depend on
the characteristics of the volume. Before using any of the new File Manager features, check
for availability by calling either the Gestalt function or the PBHGetVolParms function,
depending on whether the feature’s presence depends on the system software or the characteristics of the volume.
You can use Gestalt to determine whether or not you can call the functions that accept and
support FSSpec records. Call Gestalt with the gestaltFSAttr selector to check for File
Manager features. The response parameter has two relevant bits.
25-12

Using the File Manager

The File Manager

Constant

Meaning

gestaltFullExtFS Dispatching

All of the routines selected through the _HFSDispatch
trap macro are available to external file systems.

gestaltHasFSSpecCalls

The operating environment provides the file system
specification versions of the basic file manipulation
functions, plus the FSMakeFSSpec function.

For a complete description of the Gestalt function, see the Compatibility Guidelines chapter
of this volume.
To test for the availability of the features that depend on the volume, you call the lowlevel function PBHGetVolParms, documented later in “Reading Volume Information.”
PBHGetVolParms returns the volume description in an attributes buffer, defined in
system software version 7.0 as the GetVolParmsInfoBuffer record.
TYPE

GetVolParmsInfoBuffer

=

RECORD

vMVersion:

Integer;

{version

vMAttrib:

Longint;

{bit
{

vMLocalHand:

number}

vector

see

of

attributes;

vMAttrib

constants}

Handle;

{handle

Longint;

{network

vMVolumeGrade:

Longint;

{relative

vMForeignPrivID:

Integer

{access

vMServerAdr

:

to

private

data}

server

address}

speed

rating}

privilege

}

model}

END;

Offset

Field

Size

Meaning

14

vMVolumeGrade

long

Relative speed rating of volume. This scale is
currently uncalibrated. Generally, lower
values represent faster speeds. A value of 0
means the volume is unrated.

18

vMForeignPrivID

word

Code for the privilege model supported by the
volume. This field now has two possible
values: 0 represents a standard HFS volume,
which might or might not support the AFP
privilege model; fsUnixPriv represents an
A/UX volume.

To determine whether the functions for manipulating privilege information in foreign file

systems are available on a volume, check the vMForeignPrivID field in the attributes buffer.
If this field contains a nonzero value, the functions are available.

Using the File Manager

—-25-13

SZ

The first four fields are the same as those in the original PBHGetVolParms attributes buffer,
introduced with the network software described in the File Manager Extensions in a Shared
Environment chapter of Volume V. The last two fields are new in system software version 7.0.

-_ 4
tr)
—

)

=
Cal

Pe)
—

~_

=

ve

iS)
“

Inside Macintosh, Volume VI

PBHGetVolParms returns the bulk of its volume description in the vVMAttrib field of the
attributes buffer. Version 7.0 has defined additional bits in the vVMAttrib field to signal
whether the following features are present.
Feature

Constant

Volume supports PBCatSearch

bHasCatSearch

Volume supports the file ID functions,
including PBExchangeFiles

bHasFileIDs

Volume supports inherited access privileges
for folders

bHasBlankAccessPrivileges

Volume supports the Desktop Manager
functions, described in the Finder Interface
chapter of this volume

bHasDesktopMegr

Volume supports a shorter name, for
compatibility with other file systems

bHasShortName

Local file sharing is enabled

bHasPersonalAccessPrivileges

Volume supports the Users and Groups file and
thus the AFP privilege functions, documented
in the File Manager chapter of Volume V

bHasUserGroupList

The description of PBHGetVolParms in “Reading Volume Information” lists all of the bits in
the vMAttrib field and their meanings.

Listing 25-1 illustrates how you can determine whether the PBCatSearch function is available
before using it to search a volume’s catalog.
Listing 25-1.
FUNCTION

SupportsCatSearch

Testing

(yourVRef:

for PBCatSearch
Integer)

:

VAR

Boolean;

myHPBRec:

HParamBlockRec;

myHPBPtr:

HParmBlkPtr;

VParmsBuf:

GetVolParmsInfoBuffer;

myErr:

OSErr;

BEGIN

myHPBPtr
WITH

:=

@myHPBRec;

myHPBRec

DO

BEGIN

ioCompletion
ioVRefNum
:=
ioBuffer
ioReqCount

:=

:= NIL;
{no
yourVRef;

routine}

@VParmsBuf;
:=

SIZEOF(GetVolParmsInfoBuffer) ;

END;

25-14

completion

Using the File Manager

The File Manager

myErr
:=
IF myErr
IF

PBHGetVolParms(myHPBPtr,
FALSE) ;
<> NoErr THEN DoError (myErr) ;

BAND(VParmsBuf.vMAttrib,
THEN

ELSE

SupportsCatSearch

SupportsCatSearch

:=

:=

{process

BSL(1,bHasCatSearch))

the
<>

error}

0

TRUE

FALSE

END;

To determine whether the remote mounting functions are available, you must attempt to call
one of them. If they are not available, the functions return a result code of paramErr.

Using

FSSpec

Records

The system software now recognizes the file system specification (FSSpec) record,
which provides a simple, standard way to specify the name and location of a file or directory.
TYPE

FSSpec

=

RECORD

vRefNum:

Integer;

{volume

parID:

LongiInt;

{directory

reference

name:

Str63

{filename

ID

or

of

number}
parent

directory

directory}

name}

END;
FSSpecPtr

=

“FSSpec;

FSSpecHandle

=

“FSSpecPtr;

The FSSpec record can describe only a file or a directory, not a volume. A volume can be
identified by its root directory, although the system software never uses an FSSpec record to
describe a volume. (The directory ID of the root’s parent directory is fsRtParID, defined in
the interface files. The name of the root directory is the same as the name of the volume.)
Some of the system software uses arrays of FSSpec records.
TYPE

FSSpecArray

=

ARRAY[0..0]

FSSpecArrayPtr

=

“FSSpecArray;

OF

FSSpec;

FSSpecArrayHandle

=

“FSSpecArrayPtr;

Your application typically receives FSSpec records from the Standard File Package or the
Finder and passes them on to the File Manager. For example, the sample code fragments in
Listing 25-2 illustrate how your application might call first the Standard File Package and
then the File Manager when the user chooses Open from the File menu.
Listing 25-2. Opening a document using the FSSpec record
StandardFileReply;
SFTypeList;
OSErr;
Integer;

—

=

—
~
As
—

@
m7

{reply
record}
{list
of types
to display}
{error
returned by open
function}
{path reference
number}
(Continued)

Using the File Manager

—

ga

VAR

mySFR:
myTypeList:
fsopenErr:
fsRefNum:

- 4
—

-O

= 25-15

Inside Macintosh,

Volume VI

Listing 25-2. Opening a document using the FSSpec record (Continued)
BEGIN

myTypeList[0]

:=

'TEXT';

{set

myTypeList[1]
:=
'RAYS';
StandardGetFile(NIL,
2, myTypeList,
IF

mySFR.sfGood

=

TRUE

up

list

of

types}

mySFR);

THEN

BEGIN

fsopenErr

:=

FSpOpenDF(mySFR.sfFile,

myErrCheck(fsopenErr);
{check
{display
document,
or whatever

fsCurPerm,

fsRefNum) ;

for errors}
else your application

does}

END

ELSE
BEGIN
{if

the

user

cancels

the

open,

do

whatever

cleanup

is

necessary}

END;

END;

If you need to convert a file specification into an FSSpec record, call the new FSMakeFSSpec
function. Do not fill in the fields of an FSSpec record yourself.
Three of the parameters to FSMakeFSSpec represent the volume, directory, and file specifications of the target object. You can provide this information in any of the four combinations
described earlier in “The Evolution of File Specification Strategies.” Table 25-1 details the
ways your application can identify the name and location of a file or directory in a call to
FSMakeFSSpec.
Table 25-1.

|. How FSMakeFSSpec interprets file specifications

vRefNum

dirID

fileName

Interpretation

Ignored

Ignored

Full
pathname

Full pathname overrides any other
information

Volume reference

DirectoryID

Partial

Partial pathname starts in the directory

number or drive
number

Working directory
reference number

DirectoryID

pathname
Partial
pathname

whose parent is specified in the dirlD
parameter

Directory specification in dirID
overrides the directory implied by the
working directory reference number
Partial pathname starts in the directory
whose parent is specified in dirID

Volume reference
number or drive
number

0

Partial
pathname

Partial pathname starts in the root
directory of the volume specified in
vRefNum

Working directory
reference number

0

Partial
pathname

Partial pathname starts in the directory
specified by the working directory

25-16

— Using the File Manager

reference number

The File Manager

Table 25-1.

How FSMakeFSSpec interprets file specifications (Continued)

vRefNum

dirID

fileName

Interpretation

Volume reference
number or
drive number

DirectoryID

Empty string
or NIL

The target object is the directory
specified by the directory ID in dirID

Working directory
reference number

0

Empty string
or NIL

Volume reference
number or
drive number

0

Empty string
or NIL

— The target object is the directory
specified by the working directory
reference number in vRefNum
The target object is the root directory
of the volume specified in vVRefNum

The fourth parameter to FSMakeFSSpec is a pointer to the FSSpec record.
For a detailed description of FSMakeFSSpec, see “Making FSSpec Records” later in
this chapter.

Updating

Files

You can update an existing file simply and safely with the new FSpExchangeFiles function.
FSpExchangeFiles exchanges the contents of two files on a volume. You can use it to update
a file without writing over the old version until the new version is stored safely. To update a
file with FSpExchangeFiles, you first save a copy of the new data, and then call
FSpExchangeFiles to put the new data in the original file. The file that you created to hold the
new data now holds the original (obsolete) data. Updating files with the FSpExchangeFiles
function preserves a file’s Finder information and file ID.
FSpExchangeFiles does not move the data on the volume; it merely changes the information
in the volume’s catalog and, if the files are open, in the file control blocks (FCBs). The

catalog entry for a file contains

m fields that describe the physical data, such as the first allocation block, physical end, and
logical end of both the resource and data forks
m fields that describe the file within the file system, such as file number and parent
directory ID

nN

1S 4]

3

oO

K<
eden
pe)
—

—

Fields that describe the data remain with the data; fields that describe the file remain with the
file. The creation date remains with the file; the modification date remains with the data.

Table 25-2 illustrates the effects of FSpExchangeFiles on a set of sample catalog information.

Using the File Manager

— 25-17

pe)
ge
ie)

Inside Macintosh,

Table 25-2.

Volume

VI

The effect of FSpExchangeFiles on a catalog entry

Before

FSpExchangeFiles

First

Second

information

After

FSpExchangeFiles

First

Second

catalog entry catalog entry

Catalog

catalog entry

catalog entry

File A

File B

File description
Filename

File A

File B

30

100

Parent directory

30

100

3000

100

File number

3000

100

Jan 1990

June 2000

Creation date

Jan 1990

June 2000

300

1000

Data description
First allocation block

1000

300

1024

7680

Physical end of datafork

7680

1024

998

7649

Logical end of data fork

7649

998

April 1990

July 2000

Last modification date

July 2000

April 1990

If one or both files are open, FSpExchangeFiles also updates the file control block, which
describes the access path to data identified by a path reference number. Like the catalog entry,
the file control block contains both physical information about the data and file system information about the file. Table 25-3 illustrates the effects of FSpExchangeFiles on the file
control block.
Table 25-3.

The effect of FSpExchangeFiles on a file control block

Before

FSpExchangeFiles

Path
reference

Path
reference

number

4

number

10

After

FCB

information

FSpExchangeFiles

Path
reference

number

4

Path
reference

number

File A

File B

File description
Filename

File B

File A

30

100

Parent directory

100

30

First allocation block

300

1000

Data description

300

1000

1024

7680

Physical end-of-file

1024

7680

998

7649

Logical end-of-file

998

7649

10

Listing 25-3 illustrates the safe-save strategy using FSpExchangeFiles for an application that
uses a memory-based editing system.
For complete descriptions of FSpExchangeFiles and PBExchangeFiles, see “Exchanging the
Data in Two Files” and “Swapping Data Between Two Files” later in this chapter.
25-18

— Using the File Manager

The File Manager

Listing 25-3. Updating a file with FSpExchangeFiles
VAR

reply:

StandardFileReply;

error:

OSErr;

seconds:

Longint;

tempFileName:
tempVRefNum:

Str255;
Integer;

tempDirID:

LongIint;

tempFSSpec:

FSSpec;

fileRefNum:

Integer;

buffer:

PCE;

count:

Longint;

BEGIN

StandardPutFile('Safe
IF reply.sfGood THEN

Save',
'filename',
reply);
{user saves file}

BEGIN

IF

reply.sfReplacing
THEN
BEGIN
GetDateTime (seconds) ;

NumToString(seconds,
error

:=

{make

up

{
{check

for

:=

temporary

filename}

FindFolder(reply.sfFile.vRefNum,
kTemporaryFolderType,
kCreateFolder,
tempVRefNum,
tempDirID);

{find

error

a

tempFileName) ;

the

temporary

create

it

if

folder;

}

necessary}

error}

FSMakeFSSpec(tempVRefNum,

tempDirID,

tempFileName,
{make

{

tempFSSpec) ;

an

FSSpec

temporary

for

filename}

the

}

{check
for error}
error
:= FSpCreate(tempFSSpec,
‘trsh',
‘'trsh',
reply.sfScript);
{create a temporary
file}
error
:= FSpOpenDF(tempFSSpec,
fsRdWrPerm,
fileRefNum) ;
{open the newly
created
file}
{check
for error}

GetMyDataSizeLoc(count,
error

:=

{check

error

for

:=

error}

{check

for

error}

error

:=

buffer);

FSWrite(fileRefNum,

{get

{write

FSClose(fileRefNum) ;

{close

data's

buffer);

to

the

the

FSpExchangeFiles(tempFSSpec,

for

error}

{delete

the

size

and

location}

file}

temporary

=

contents

temporary
_

4

Me

file}

reply.sfFile);

{exchange
the
{ two
files}

{check
for error}
error
:= FSpDelete(tempFSSpec) ;
{check

the

count,

of

>
S

the

}

file}

END;
END;
END;

Using the File Manager

— 25-19

gg

ae)

Inside Macintosh,

Searching

Volume VI

a Volume

You can search a volume’s catalog efficiently using the new PBCatSearch function.
PBCatSearch looks at all entries in all directories on the volume, and it returns a list of all
files or directories that match the criteria you specify. You can ask PBCatSearch to match
for names or partial names; file and directory attributes; Finder information; physical and
logical file length; creation, modification, and backup dates; and parent directory ID.

Like all low-level File Manager functions, PBCatSearch exchanges information with your

application through a parameter block. The PBCatSearch function uses a new parameter
block variant, CSParam, which contains these fields:
CSParam:

(ioMatchPtr:

FSSpecArrayPtr;

{pointer

to

i1oReqMatchCount:

LongInt;

{maximum

number

ioActMatchCount:
LloSearchBits:

LongInt;
Longint;

{actual
{enable

ioSearchInfol:
ioSearchInfo2:

CInfoPBPtr;
CInfoPBPtr;

{pointer
{pointer

to
to

ioSearchTime:

Longint;

{maximum

time

{

Time

list

of
of

matches}
matches

to

return}

number of matches}
bits for matching rules}
values
and
lower bounds}
masks
and upper
bounds}

to

Manager

ioCat Position:

CatPositionRec;

{current

catalog

ioOpt Buffer:

Ptr;

{pointer

to

ioOptBufSize:

Longint);

{length

of

search,

in

}

form}
position}

optional
optional

read
read

buffer}
buffer}

For a description of all fields in the parameter block and how they are used, see the description of PBCatSearch in “Searching a Catalog” later in this chapter.
PBCatSearch manipulates file and directory data in a catalog information (CInfoPBRec)
record. (This record, also used by the PBGetCatInfo function, is described fully in the File
Manager chapter of Volume IV.) You specify the limits of the search criteria to PBCatSearch
in two catalog information records, called ioSearchInfol and ioSearchInfo2.
Some fields in the catalog information records apply only to files, some only to directories,
and some to both. Some of the fields that apply to both have different names, depending on
whether the target of the record is a file or a directory. PBCatSearch uses only some fields in
the catalog information record. Table 25-4 lists the fields used for files, and Table 25-5 lists
the fields used for directories.
The fields in ioSearchInfol and ioSearchInfo2 have different uses:

a The name field in ioSearchInfol holds a pointer to the target string; the name field
in ioSearchInfo2 must be NIL. (If you’re not searching for the name, the name
field in ioSearchInfol must also be NIL.)
a The date and length fields in ioSearchInfol hold the lowest values in the target range: the
date and length fields in ioSearchInfo2 hold the highest values in the target range.
PBCatSearch looks for values greater than or equal to the field values in ioSearchInfo |
and less than or equal to the values in ioSearchInfo2.
m The attributes and Finder information fields in ioSearchInfol hold the target values; the
same fields in ioSearchInfo2 hold masks that specify which bits are relevant. (File
attributes are described in the File Manager chapter of Volume IV, and the Finder
information is described in the Finder Interface chapter of this volume.)
25-20

— Using the File Manager

The File Manager

Table 25-4.
Offset

Fields in ioSearchInfol and ioSearchInfo2 used for a file
Field

Size

18
30
32

ioNamePtr
ioF Attrib
ioFlFndrInfo

Long
Byte
16 bytes

54
58
64
68
72
76
80
84

ioFlLgLen
ioFlPyLen
ioFIRLgLen
ioFIRPyLen
ioFIlCrDat
i0FIMDat
i0FIBakDat
ioFlXFndrInfo

Long
Long
Long
Long
Long
Long
Long
16 bytes

100

ioFlParID

Long

Table 25-5.

Offset

Meaning
Filename
File attributes
_‘ Finder information (FInfo record, described
in the Finder Interface chapter of this volume)
Data fork logical length
Data fork physical length
Resource fork logical length
Resource fork physical length
File creation date
File modification date
File backup date
Extended Finder information (FXInfo record,
described in the Finder Interface chapter of
this volume)

File’s parent directory ID

Fields in ioSearchInfol and ioSearchInfo2 used for a directory

Field

Size

18
30
32

ioNamePtr
ioFlAttrib
ioDrUsrWds

Long
Byte
16 bytes

52
72
76
80
84

ioDrNmFls
ioDrCrDat
ioDrMdDat
ioDrBakDat
ioDrFndrInfo

Word
Long
Long
Long
16 bytes

100

ioDrParID

Long

Meaning
Directory name
Directory attributes
_‘ Finder information (DInfo record, described
in the Finder Interface chapter of this volume)
Number of files in the directory
Directory creation date
Directory modification date
Directory backup date
Extended Finder information (DXInfo record,
described in the Finder Interface chapter of
this volume)

Directory’s parent directory ID

In a pair of records that describe a file, for example, the variable fields have these meanings:
Field

ioSearchInfol

ioNamePtr

Target string

ioF Attrib

Desired attributes

ioFlFndrInfo

Desired Finder profile

ioFlLgLen
ioFlPyLen
ioFIRLgLen

Smallest desired size
Smallest desired size
Smallest desired size

ioFlCrDat

Earliest desired date

nN
wn

>|

ioSearchInfo2

oO

Reserved (must be NIL)

b=)

a

—

Mask specifying which attributes are used
in search
Mask specifying which Finder information
is used in search
Largest desired size
Largest desired size
Largest desired size
Latest desired date

Using the File Manager

= 25-21

~
&
ve
@

La

|

Inside Macintosh,

Volume VI

Field

ioSearchInfol

ioSearchInfo2

ioFIMDat
ioFlBakDat
ioFlXFndrinfo

Earliest desired date
Earliest desired date
Desired extended

Latest desired date
Latest desired date

Finder profile

Mask specifying which extended Finder
information is used in search

PBCatSearch searches only on bits 0 and 4 in the file attributes field (ioFlAttrib).
Attributes
bit
0
A

Meaning
File or directory is locked
Entry is a directory

To fully describe the search criteria to PBCatSearch, you pass it a pair of catalog information
records that determine the limits of the search and a mask that identifies the relevant fields
within the catalog information records. You pass the mask in the ioSearchBits field in the
PBCatSearch parameter block. To determine the value of ioSearchBits, add together th
appropriate constants.
CONST

fsSBPartialName

=

1;

fsSBFullName

es

2:

fsSBFlAttrib

=

4;

fsSBNegate

= 16384;

{reverse

fsSBF1FndriInfo

=

Si

fsSBFlLgLen

=

323

{Finder file info}
{data fork logical

fsSBF1PyLen

=

64;

{data

fsSBF1RLgLen

=

128;

{resource

fsSBF1RPyLen
fsSBF1CrDat

=
=

256%
5123

fsSBF1MdDat
fsSBF1BkDat

=
=

1024;
2048;

{resource fork physical length}
{file creation date}
{file modification date}

fsSBF1XFndrinfo
fsSBF1ParID

=
=

4096;
8192;

{for

only}

{for

files

{substring of
{full name}
{directory

name}

flag;

match

software

lock

flag}

status}

only}

directories

fork

physical
fork

length}
length}

logical

{file

backup

date}

{more

Finder

file

{file's

parent

{Finder

directory

length}

info}

ID}

info}

fsSBDrUsrwds
fsSBDrNmFls

=
=

8;
16;

fsSBDrCrDat
fsSBDrMdDat

=
=

512;
1024;

{number of
{directory
{directory

fsSBDrBkDat
fsSBDrFndriInfo

=
=

2048;
4096;

{directory backup date}
{more Finder directory info}

fsSBDrParID

=

$192;

{directory's

files
in directory}
creation
date}
modification
date}

parent

ID}

Figure 25-3 illustrates how the value in ioSearchBits determines which fields are used in
ioSearchInfol and ioSearchInfo2.

25-22

Using the File Manager

The File Manager

fsSBPartialName

Il

—

fsSBFIAttrib

ul

AS

Calculation of ioSearchBits

Available search fields

(in ioSearchinfo1 and ioSearchinfo2)

|__ioFIAttrib—
ee

oF IFndrinfe

fsSBFICrDat = 512

|

ioFicrDat
+

|

AA

ioFlMDat

ioSearchBits

= 517

An ioSearchBits value of
517 limits the search criteria
to the boxed fields.

Figure 25-3. The effect of ioSearchBits on interpretation of ioSearchInfol
and ioSearchInfo2
A catalog entry must meet all of the specified criteria to be placed in the list of matches. After
PBCatSearch has completed its scan of each entry, it checks the fsSBNegate bit. If that bit is
set, PBCatSearch reverses the entry’s match status (that is, if the entry is a match but the

fsSBNegate bit is set, the entry is not put in the list of matches; if it is not a match, it is put
in the list).

Although the use of PBCatSearch is significantly more efficient than searching the directories

recursively, searching a large volume can take long enough to affect user response time. You
can break a search into several shorter searches by specifying a maximum length of time in
the ioSearchTime field and keeping an index in the ioCatPosition field. PBCatSearch stores
its directory-location index in a catalog position record.
TYPE

CatPositionRec

=

{catalog

position

record}

RECORD

initialize:

Longint;

priv:

ARRAY[1..6]

{starting
OF

Integer

{private

point}

le)
er.
—
©
na=$9
—
=$9

data}

—

END;

t=)

Te

To start a search at the beginning of the catalog, set the initialization field to 0. When it exits
because of a timeout, PBCatSearch updates the record so that it describes the next entry to be
searched. When you call PBCatSearch to resume the search after a timeout, pass the entire
record that was returned by the last call.

Using the File Manager

— 25-23

©mm
:

Inside Macintosh,

Volume VI

PBCatSearch returns a list of the names and parent directories of all files and directories that
match the criteria you specify. It places the list in an array pointed to by the FSSpecArrayPtr
field. The array contains FSSpec records, described earlier in “Using FSSpec Records.”

Listing 25-4 illustrates a code segment that uses PBCatSearch to find all files (not directories)
whose names contain the string “Temp” and which were created within the past two days.
Listing 25-4, Searching a volume with PBCatSearch
CONST
kMaxMatches

=

30;

{find

kOptBufferSize

=

16384;

{use

up

err:

OSErr;

loopy:
fileName:

Integer;
Str2553

{loop
{name

vRefNum:
dirID:
currentDateTime:

Integer;
LongIint;
LongInt;

{volume on which to search}
{ignored dir ID for HGetVol}
{current date in seconds}
{date

a

to

16K

30

matches

search

in

one

cache

for

control
variable}
of string
to look

for}

pass}

speed}

VAR

twoDaysAgo:

LongInt;

pb:

HParamBlockRec;

two

days

theResults:

PACKED

specl:

CInfoPBRec;

spec2:
buffer:

CInfoPBRec;
{search criteria,
PACKED ARRAY[1..kOptBufferSize]

done:

Boolean;

{parameter

PROCEDURE

ago

block

ARRAY[1..kMaxMatches]

in

seconds}

for
OF

PBCatSearch}

FSSpec;

{put matches
here}
{search criteria,
part

{search
{set
to

1}

part 2}
OF Char;

cache}
TRUE when

all

matches

found}

SetupForFirstTime;

BEGIN
err

:=

HGetVol(NIL,

vRefNum,

dirID);

.
fileName

:=

'Temp';

GetDateTime

(currentDateTime)

twoDaysAgo

:=

WITH

pb

DO

;

currentDateTime

{search

on

{search

for

{get

-

default

current

time

24

*

*

volume}

"Temp"}

60

in

seconds}

(2

*

60);

completion routine}
volume name; use vRefNum}

BEGIN

ioCompletion
ioNamePtr
:=

:= NIL;
NIL;

{no
{no

ioVRefNum

vRefNum;

{volume

:=

ioMatchPtr

:=

ioReqMatchCount

:=

search}

ioSearchBits

fsSBPartialName

:=

+

£sSBFlAttrib

+

f£sSBF1CrDat;

buffer}

kMaxMatches;
{number

25-24

to

FSSpecArrayPtr(@tneResults) ;
{points to results
of

matches}

{search

on

partial

{search

on

file

name}

attributes}

{search

on

creation

ioSearchinfol

:=

@specl;

{points

to

first

ioSearchInfo2

:=

@spec2;

{points

to

second

Using the File Manager

date}

criteria
criteria

set}
set}

The File Manager

ioSearchTime

:=

-1;

{don't

ioCatPosition.initialize
ioOptBuffer

:=

ioOptBufSize
END;
WITH
specl

:=

@buffer;

:=

0;
{set

time

hint

{point

to

to

kOptBufferSize;
{size

out

of

on

searches}

0}

search

search

cache}

cache}

DO

BEGIN

ioNamePtr

:=

ioFlAttrib
ioFlCrDat

@fileName;
:=

:=

$00;
twoDaysAgo;

{point

to

string

{clear

bit

{lower

bound

4

to

find}

to

ask

for

files}

of

creation

date}

END;

WITH

spec2

DO

BEGIN

ioNamePtr
:= NIL;
ioFlAttrib
:= $10;
ioFlCrDat

:=

{set
{set

to NIL}
mask for

bit

4}

currentDateTime;
{upper

bound

of

creation

data

records}

date}

END;
END;

BEGIN

SetupForFirstTime;

{initialize

REPEAT

err

:=

PBCatSearchSync(@pb);
eofErr);

some

:=

(err

IF

((err

=

noErr)

|

done)

loopy

:=

TO

pb.ioActMatchCount

FOR

=

{get

done

1

{eofErr
&

files}

returned

when

(pb.ioActMatchCount
{report

all

>

all
0)

done}

THEN

DO
matches

found}

Writeln(theResults[loopy]
.name) ;
UNTIL

done;

END.

Tracking

Files With

File IDs

The File Manager provides a set of three low-level functions for creating, resolving, and
deleting file ID references. These functions were developed for use by the Alias Manager,
which uses them to track files that have been moved or renamed. In most cases, your
application should track files with the Alias Manager, described in the Alias Manager chapter
of this volume, not with file IDs.
You establish a file ID reference when you need to identify a file by file number (see “File

IDs” earlier in this chapter). You create a file ID reference with the PBCreateFileIDRef

function. Because the File Manager assigns file numbers independently on each volume, a
file ID is not guaranteed to be unique across volumes.
You can resolve a file ID reference by calling the PBResolveFileI[DRef function, which determines the name and parent directory ID of the file with a given ID. With this information and
a volume specification, you can uniquely identify any file in the file system.

Using the File Manager

= 25-25

Le -9|
—
o@
so
—

oy)
=}
te)
ge
is)
at

Inside Macintosh,

Volume VI

If you no longer need a file ID, remove its record from the directory by calling the
PBDeleteFileIDRef function. Removing a file ID is seldom appropriate, but the function
is provided for completeness.
To preserve a file’s ID when you are saving a new version of it, you should use the new
safe-save strategy described earlier in “Updating Files.”

Mounting

Volumes

Programmatically

Your application can mount remote volumes, without requiring the user to go through the
Chooser, using a set of three new functions: PBGetVolMountInfoSize, PBGetVolMountInfo,
and PBVolumeMount.
Ordinarily, before you can mount a volume programmatically, you must record its mounting
information while it’s mounted. Because the size of the mounting information can vary, you
first call the PBGetVolMountInfoSize function, which returns the size of the record you'll
need to allocate to hold the mounting information. You then allocate the record and call
PBGetVolMountInfo, passing a pointer to the record. When you want to mount the volume
later, you can pass the record directly to the PB VolumeMount function.
Note: The functions for mounting volumes programmatically are low-level functions
designed for specialized applications. Even if your application needs to track and
access volumes automatically, it can ordinarily use the Alias Manager, described in
the Alias Manager chapter of this volume. The Alias Manager can record mounting
information and later remount most volumes, even those that do not support the
programmatic mounting functions.
The programmatic mounting functions can now be used to mount AppleShare volumes. The
functions have been designed so that they can eventually be used to mount local Macintosh
volumes, such as partitions on devices that support partitioning, and local or remote volumes
managed by non-Macintosh file systems.
The programmatic mounting functions use the ioParam variant of the ParamBlockRec record,
described in the File Manager chapter of Volume IV. They store the mounting information in
a variable-sized structure called the VolMountInfoHeader record.
TYPE

VolMountInfoHeader

=

RECORD

length:

Integer;

{length

of

mounting

{

including

{

variable-length

information,

standard

header

and

}
}

data}

media:
VolumeType;
{type of volume}
{volume-specific,
variable-length
location

data}

The size and contents of the record can vary, depending on the external file system that’s
handling the particular volume.
The length field contains the length of the structure (that is, the total length of the structure
header described here plus the variable-length location data). The length of the record is
flexible so that non-Macintosh file systems can store whatever information they need for
volume mounting.
25-26

Using the File Manager

The File Manager

The media field identifies the volume type of the remote volume. The value
AppleShareMediaType (a constant that translates to 'afpm') represents an AppleShare
volume. If you are adding support for the programmatic mounting functions to a nonMacintosh file system, you should register a four-character identifier for your volumes
with Macintosh Developer Technical Support at Apple Computer, Inc.
The only volumes that currently support the programmatic mounting functions are
AppleShare servers, which use this volume mounting record.
TYPE

AFPVolMountInfo

=

RECORD

length:

Integer;

{length

of

mounting

{

information,

{
{

standard header
variable-length

}

and
}
data}

media:

VolunmeType;

{type

flags:

Integer;

{reserved;

must

nbpInterval:

SignedByte;

{NBP

retry

interval}

nbpCount

retry

count}

:

of

}

including

volume}
be

set

to

0}

SignedByte;

{NBP

uamType:

Integer;

{user

zoneNameOffset:

Integer;

{offset
from start
{ to zone name}

of

record

}

serverNameOffset:

Integer;

{offset

of

record

}

of

record

}

of

record

}

of

record

}

of

record

}

{
volNameOffset:

Integer;
Integer;
Integer;
Integer;
PACKED

to

volume-specific,

start

name}
from

start

password}
from

volume

ARRAY[1..144]

{standard

{optional

start
name}

from

user

{offset
{

AFPData:

to

from

user

{offset
{

volPassWordOffset:

to

start

method}

name}

volume

{offset
{

userPassWordOffset:

to

from

server

{offset
{

userNameOffset:

to

authentication

variable-length

start

password}

OF

Char;

AFP

mounting

info}

data}

END;

The length and media fields in the AFP volume mounting record are the same as the length
and media fields in the generic volume mounting record.
The nbpInterval and nbpCount fields are used by the AppleTalk® Name-Binding Protocol
(NBP). Their functions are described in the AppleTalk Manager chapter of Volume II.
The uamType field specifies the access-control method used by the remote volume.
AppleShare uses four methods:
kNoUserAuthentication

=

1;

{guest

no

password

kPassword
kEncrypt Password

=
=

2;
3;

{8-byte password}
{encrypted
8-byte

password}

6

{two-way
random
encryption;
}
{ authenticate
both user and server}

kTwoWayEncrypt

Password

~

CONST

status;

needed}

Using the File Manager

— 25-27

Inside Macintosh,

Volume V1

The six offset fields contain the offsets from the beginning of the record, in bytes, to the
entries in the data field of the volume’s AppleShare zone and server name, the volume name,
the name of the user, the user’s password, and the volume password.
PBGetVolMountInfo does not return the user and volume passwords; they’re returned as
blank. Typically, your application asks the user for any necessary passwords and fills in
those fields just before calling PBVolumeMount. No passwords are required for mounting a
volume with guest status.
If you have enough information about the volume, you can fill in the mounting record
yourself and call PBVolumeMount, even if you did not save the mounting information while
the volume was mounted. To mount an AFP volume, you must fill in the record with at least
the zone name, server name, user name, user password, and volume password. You can lay
out the fields in any order within the data field, as long as you specify the correct offsets.

Manipulating

Privilege Information

in Foreign

File Systems

Version 7.0 includes two low-level functions that support interaction with foreign file
systems: PBGetForeignPrivs and PBSetForeignPrivs. These functions let you manipulate
privilege information on a file system with a non-Macintosh privilege model.
The access-control functions were designed for use by shell programs, such as the Finder,
that need to use the native privilege model of the foreign file system. Most applications can
rely on using AFP functions, which are recognized by file systems that support the
Macintosh privilege model. The new access-control functions do not relieve a foreign file
system of the need to map its own privilege model onto the AFP functions.
Like all other low-level File Manager functions, the access-control functions exchange information with your application through parameter blocks. The meanings of some fields depend
on what the foreign file system is. These fields are currently defined for A/UX, and you can
define them for other file systems. If you are defining a new privilege model, register it with
Macintosh Developer Technical Support.
You can identify the foreign file system through the PBHGetVolParms function, described
later in “Reading Volume Information.” Version 7.0 defines a new attributes buffer for the
PBHGetVolParms function, with a field for the foreign privilege model, vMForeignPrivID.
Note: The value of vMForeignPrivID is unrelated to whether the remote volume
supports the AFP access-control functions, described in the File Manager chapter of
Volume V. You can determine whether the volume supports the AFP access-control
functions by checking the bHasAccessCntl bit in the VMAttrib field. See the description
of PBHGetVolParms in “Reading Volume Information” later in this chapter.
A value of 0 for vMForeignPrivID signifies an HFS volume that supports no foreign
privilege models. The field currently has one other defined value.
CONST

fsUnixPriv

=

1;

{A/UX

privilege

model}

For an updated list of supported models and their constants and fields, contact Macintosh
Developer Technical Support.
25-28

Using the File Manager

The File Manager

A volume can support no more than one foreign privilege model.
The access-control functions store information in a new parameter block type,
ForeignPrivParam, described in “Accessing Privilege Information in Foreign File
Systems” later in this chapter.
The parameter block can store access-control information in one or both of
m a buffer of any length, whose location and size are stored in the parameter block
a four long words of data stored in the parameter block itself
The meanings of the fields in the parameter block depend on the definitions established by the
foreign file system.

HIGH-LEVEL

FILE

MANAGER

ROUTINES

Version 7.0 introduces three kinds of high-level File Manager routines:
= functions that identify files with the new FSSpec record, introduced in version 7.0,
including a new function that exchanges the data in two files
= anew set of three functions for opening only the data fork of a file, to be used instead of
the earlier function FSOpen
= functions that identify files using the three parameters vRefNum, dirID, and fileName,
introduced with the Hierarchical File System
Most of the new functions in version 7.0 are adaptations of functions introduced either in the
original Macintosh File System or with the Hierarchical File System. Modified functions bear
the same root name as the original functions. The prefix FSp identifies functions modified to
accommodate FSSpec records; the prefix H identifies functions modified to accommodate
directory IDs for compatibility with HFS.

Routines

That

Use

FSSpec

Records

Version 7.0 of the system software introduces the FSSpec record, a simple, standard way to
specify the name and location of a file or directory. Other parts of the Macintosh system
software now identify files and directories with FSSpec records. The File Manager supports
FSSpec records by providing

—_
=~
=
—

a)

tome
as
_
—_
~
as
~
TS
.

ic
—

= a function for converting other file specifications to FSSpec records
a aset of File Manager functions that accept and return FSSpec records instead of the
parameters vRefNum, dirID, and fileName
The new FSpExchangeFiles function, which exchanges the data in two files, accepts file
specifications in a pair of FSSpec records.
High-Level File Manager Routines

— 25-29

;

Inside Macintosh, Volume VI

Making

FSSpec

Records

You use the FSMakeFSSpec function to convert a conventional file or directory specification
into an FSSpec record.
FUNCTION

FSMakeFSSpec

(vRefNum:

Integer;

dirID:

fileName:

Str255;

VAR

LongInt;

spec:

FSSpec)

:

OSErr;

FSMakceFSSpec places the specification in the spec parameter. (See “Using FSSpec Records”
earlier in this chapter for a description of the FSSpec record.) Call FSMakeFSSpec whenever
you want to create an FSSpec record.
The vRefNum parameter is the volume reference number, a working directory reference
number, a drive number, or 0 for the default volume.
The dirlID parameter is usually the parent directory ID of the target object. If the directory is
sufficiently specified by either vVRefNum or fileName, dirID can be 0. If you explicitly
specify dirID (that is, if it is any value other than 0), and if VRefNum is a working directory
reference number, dirID overrides the directory ID included in vRefNum. If the fileName
parameter is an empty string, FSMakeFSSpec creates an FSSpec record for a directory
specified by either the dirID or vVRefNum parameter.
The fileName parameter is a full or partial pathname. If it is a full pathname, FSMakeFSSpec
ignores vVRefNum and dirID. A partial pathname might identify only the final target, or it might
include one or more parent directory names. If fileName is a partial pathname, vRefNum,
dirID, or both must be valid.
The spec parameter is an FSSpec record, which FSMakeFSSpec fills in.
You can pass the input to FSMakeFSSpec in any of the four ways described in “The Evolution of File Specification Strategies” earlier in this chapter. See Table 25-1 in “Using FSSpec
Records” earlier in this chapter for details of how FSMakeFSSpec interprets input.
If the specified volume is mounted and the specified parent directory exists, but the target file
or directory doesn’t exist in that location, FSMakeFSSpec fills in the record and then returns
fnfErr instead of noErr. The record is valid, but it describes a target that doesn’t exist. You
can use the record for other operations, such as creating a file with the FSpCreate function.
In addition to the result codes listed here, FSMakeFSSpec can return a number of different
File Manager error codes. If you receive any result code other than noErr or fnfErr,
FSMakeFSSpec returns a NIL FSSpec record.
Result codes
noErr

fnfErr

25-30

Q

—43

No error

_ File or directory does not exist
(FSSpec is still valid)

High-Level File Manager Routines

The File Manager

Exchanging

the Data in Two

Files

You use the FSpExchangeFiles function to exchange the data between two files on a volume.
FUNCTION

FSpExchangeFiles

(source:

FSSpec;

dest:

FSSpec)

:

OSErr;

FSpExchangeFiles swaps the files’ data by changing the information in the volume’s catalog
and, if the files are open, in the file control blocks. Tables 25-2 and 25-3 in “Updating Files”
earlier in this chapter illustrate how FSpExchangeFiles alters the catalog entries and file
control blocks.
You should use FSpExchangeFiles when updating an existing file, so that if the file is being
tracked through its file ID, the ID remains valid. Typically, you use PBExchangeFiles after

creating a new file during a safe save (see “Updating Files” earlier in this chapter). You

identify the two files to be exchanged in the source and dest parameters. FSpExchangeFiles
changes the fields in the catalog entries that record the location of the data and the modification dates. It swaps both the data forks and the resource forks.
FSpExchangeFiles works on either open or closed files. If either file is open, FSpExchangeFiles
updates any file control blocks associated with the file. Exchanging the contents of two files
requires essentially the same access as opening both files for writing.
FSpExchangeFiles does not require that file [Ds exist for the files being exchanged.
Result codes

noErr
nsvErr
ioErr
fnfErr
fLckdErr
volOfflinErr
extFSErr
wreVolTypeErr
notAFileErr
diffV olErr

Functions

QO
Noerror
-35
Volume not found
-36
[/Oerror
-43
File not found
-45 __ File locked
-—53
Volume is off line
—58
External file system
-123
Notan HFS volume
-1302
Specified file is a directory
-1303
Files on different volumes

Modified

to Accept

FSSpec

ho

Records

12 |

3)

The File Manager contains modified versions of the basic functions for manipulating files so
that you can use FSSpec records for tasks such as creating, opening, and deleting files. This
section specifies the syntax of the new functions. For descriptions of how the functions
work, see the entries for the equivalent functions in the File Manager chapter of Volume IV.

High-Level File Manager Routines

— 25-31

oO
2a

met

be)
=}
&
ge
(2)

Ler |

Inside Macintosh,

FUNCTION

Volume VI

FSpOpenDF

(spec:
VAR

FSSpec;
refNum:

permission:
Integer)

:

SignedByte;

OSErr;

The FSpOpenDF function creates an access path to the data fork of a file. It is the FSSpec
version of the new function HOpenDF, which replaces the functions FSOpen and HOpen.
The difference is that HOpenDF opens only the data fork of a file; FSOpen and HOpen can
open either a driver or the data fork of a file. Using FSpOpenDF eliminates the ambiguity and
ensures that you can open even a file whose name begins with a period (.). You specify the
file to be opened with an FSSpec record in the spec parameter. FSpOpenDF opens the data
fork and places the path reference number in the refNum parameter.
FSpOpenDF takes a permission parameter not available in FSOpen. Set this parameter to
request the kind of access path permission you want.
CONST

fsCurPerm

=

Qs

{exclusive

read/write

{

available;

{

that

is

otherwise,

permission

exclusive

if

it

read,

is

}

if

}

available}

fsRdPerm
fsWrPerm

=
=

1%
23

{exclusive
{exclusive

read permission}
write permission}

fsRdwWrPerm

=

3;

{exclusive

read/write

fsRdWrShPerm

=

4;

{shared

read/write

permission}

permission}

In most cases, you can simply set the permission parameter to fsCurPerm. Some applications
request fsRdWrPerm, to ensure that they can both read and write to a file. For more infor-

mation about permissions, see the description of the ioParam variants of the parameter block
records (ParamBlockRec and HParamBlockRec) in the File Manager chapter of Volume IV.
In shared environments, permission requests are translated into the “deny-mode” permissions
defined by AppleShare and described in the File Manager chapter of Volume V.
For more information, see the entry for FSOpen in the File Manager chapter of Volume IV.
FUNCTION

FSpOpenRF

(spec:
VAR

FSSpec;
refNum:

permission:
Integer)

:

SignedByte;

OSErr;

The FSpOpenRF function creates an access path to the resource fork of a file. It is the highlevel, FSSpec version of the PBHOpenRF function, documented in the File Manager chapter
of Volume IV.
FUNCTION

FSpCreate

(spec:
FSSpec;
creator:
scriptTag:
ScriptCode)

OSType;
: OSErr;

fileType:

OSType;

The FSpCreate function creates a new file and sets the type and creator. It is the high-level,
FSSpec version of the PBHCreate function, documented in the File Manager chapter of
Volume IV. The scriptTag parameter specifies the code of the script system in which the
docu-ment name is to be displayed. If you have established the name and location of the new
file through either the StandardPutFile or CustomPutFile procedure, specify the script code
returned in the reply record. (See the Standard File Package chapter of this volume for a

25-32

High-Level File Manager Routines

The File Manager

description of StandardPutFile and CustomPutFile.) Otherwise, specify the system script by
setting the scriptlag parameter to smSystemScript. See the Worldwide Software Overview
chapter of this volume for more information on script systems.
FUNCTION

FSpDirCreate

(spec:
VAR

FSSpec;

scriptTag:

createdDirID:

ScriptCode;

LongInt)

:

OSErr;

The FSpDirCreate function creates a new directory. It is a high-level, FSSpec version of
PBDirCreate, documented in the File Manager chapter of Volume IV.
FUNCTION

FSpDelete

(spec:

FSSpec)

:

OSErr;

The FSpDelete function removes a closed file. It is the high-level, FSSpec version of the
PBHDelete function, which is documented in the File Manager chapter of Volume IV.
FUNCTION

FSpGetFinfo

(spec:

FSSpec;

VAR

fndriInfo:

FInfo)

:

OSErr;

The FSpGetFInfo function returns the Finder information from the volume catalog entry for
the specified file or directory. It provides only the original Finder information—the FlInfo and
DInfo records, not FXInfo and DXInfo. (See the Finder Interface chapter of this volume for
a discussion of Finder information.) It is the high-level, FSSpec version of the PBHGetFInfo
function, documented in the File Manager chapter of Volume IV.
FUNCTION

FSpSetFiInfo

(spec:

FSSpec;

fndrInfo:

FInfo)

:

OSErr;

The FSpSetFInfo function sets the Finder information in the volume catalog entry for the
specified file or directory. It affects only the original Finder information—the FlInfo and
DInfo records, not FXInfo and DXInfo. (See the Finder Interface chapter of this volume for
a discussion of Finder information.) It is the high-level, FSSpec version of the PBHSetFInfo
function, documented in the File Manager chapter of Volume IV.
FUNCTION

FSpSetFLock

(spec:

FSSpec)

:

OSErr;

The FSpSetFLock function locks a file. It is the high-level, FSSpec version of the
PBHSetFLock function, documented in the File Manager chapter of Volume IV.
FUNCTION

FSpRstFLock

(spec:

FSSpec)

:

rj
oe

OSErr;

—
a)

4
—

6

The FSpRstFLock function unlocks a file. It is the high-level, FSSpec version of the
PBHRstFLock function, documented in the File Manager chapter of Volume IV.
FUNCTION

FSpRename

(spec:

FSSpec;

newName:

Str255)

:

i]
=
to
&
“I

OSErr;

The FSpRename function changes the name of a file or directory. It is the high-level, FSSpec
version of the PBHRename function, documented in the File Manager chapter of Volume IV.

High-Level File Manager Routines

— 25-33

Inside Macintosh,

FUNCTION

Volume

FSpCatMove

VI

(source:

FSSpec;

dest:

FSSpec)

:

OSErr;

The FSpCatMove function moves the file or directory specified by the source parameter to the
destination specified by the dest parameter. It is the high-level, FSSpec version of the lowlevel function PBCatMove, documented in the File Manager chapter of Volume IV. The
source and dest parameters specify the name and location of the file or directory before and
after the move.

Opening

a Data

Fork

The File Manager contains three new functions for opening only the data fork of a file.
FSpOpenDF, the function that accepts an FSSpec record, is documented earlier in “Functions
Modified to Accept FSSpec Records.” The other two functions accept file specifications in
the traditional MFS and HFS forms.
FUNCTION

HOpenDF

(vRefNum:

Integer;

permission:

dirID:

SignedByte;

LongInt;
VAR

fileName:

refNum:

Str255;

Integer)

:

OSErr;

The HOpenDF function creates an access path to the data fork of a file. It is an HFS version
of OpenDF. The vRefNum parameter can hold a volume reference number or a working
directory reference number. The dirID parameter holds a directory ID.
FUNCTION

OpenDF

(fileName:
>

Str255;

vRefNum:

Integer;

VAR

refNum:

Integer)

OSEry;

The OpenDF function creates an access path to the data fork of a file. It is almost identical
to FSOpen, which is documented in the File Manager chapter of Volume IV. The difference is
that FSOpen can open both files and devices, but OpenDF can open only files. Using OpenDF
instead of FSOpen when your application is opening a file prevents naming conflicts or
ambiguities and ensures that your application can open files whose names start with a period (.).

Managing

HFS

When HFS was first introduced, it was accompanied by a set of low-level functions with no
high-level equivalents. Some of these functions were designed for handling hierarchical
volumes; some were simply modifications of MFS routines, adapted to accommodate directory information. This section documents the high-level versions of the low-level functions
introduced with HFS. For more information, see the entries for the equivalent low-level
functions in the File Manager chapter of Volume IV.

Functions

New

With

HFS

This section documents the high-level versions of the functions for handling hierarchical
volumes.
FUNCTION

AllocContig

(refNum:

Integer;

VAR

count:

LongInt)

:

OSErr;

The AllocContig function is a high-level function that calls PBAllocContig, which is
documented in the File Manager chapter of Volume IV.
25-34

High-Level File Manager Routines

The File Manager

FUNCTION

DirCreate

(vRefNum:

Integer;

directoryName:

parentDirID:

Str255;

VAR

LongInt;

createdDirID:

LongInt)

OSErr;

The DirCreate function is a high-level function that calls PBDirCreate, which is documented
in the File Manager chapter of Volume IV.
FUNCTION

CatMove

(vRefNum:

Integer;

newDirID:

LongInt;

dirID:

LongInt;

newName:

oldName:

Str255)

:

Str255;

OSErr;

The CatMove function is a high-level function that calls PBCatMove, which is documented in
the File Manager chapter of Volume IV.
FUNCTION

OpenWD

(vRefNum:
Integer;
dirID:
VAR wdRefNum:
Integer)
:

LongInt;
OSErr;

procID:

LongInt;

The OpenWD function is a high-level function that calls PROpenWD, which is documented
in the File Manager chapter of Volume IV.
FUNCTION

CloseWD

(wdRefNum:

Integer)

:

OSErr;

The CloseWD function is a high-level function that calls PBCloseWD, which is documented
in the File Manager chapter of Volume IV.
FUNCTION

GetWDInfo

(wdRefNum:
VAR

dirID:

Integer;
LongInt;

VAR
VAR

vRefNum:

Integer;

procID:

LongInt)

:

OSErr;

The GetWDInfo function is a high-level function that calls PBGetWDInfo, which is
documented in the File Manager chapter of Volume IV.

MFS

Functions

Modified

to Accommodate

Directory

IDs

This section documents the high-level versions of the basic file manipulation functions

introduced with HFS. These functions are all adaptations of MFS functions, modified to
accept a directory ID parameter. Some of these functions have been superseded by the
new functions that accept FSSpec records, documented earlier in “Functions Modified to
Accept FSSpec Records.”

bo
1o4)

<7

o

<saat
oS

=

FUNCTION

HCreate

(vRefNum:
creator:

Integer;
OSType;

dirID:
LongInt;
fileName:
fileType:
OSType)
: OSErr;

Str255;

The HCreate function creates a new file and sets the type and creator. It is a high-level
function that calls PBHCreate, documented in the File Manager chapter of Volume IV.

High-Level File Manager Routines

— 25-35

be
ge

o
“

Inside Macintosh,

Volume VI

FUNCTION

(vRefNum:

HOpen

Integer;

permission:

dirID:

LongInt;

SignedByte;

VAR

fileName:

refNum:

Str255;

Integer)

:

OSErr;

The HOpen function creates an access path to the data fork of a file. It is a high-level function
that calls PBHOpen, documented in the File Manager chapter of Volume IV.
FUNCTION

HOpenRF

(vRefNum:

Integer;

permission:

dirID:

LongInt;

SignedByte;

VAR

refNum:

fileName:

Str25

Integer)

:

OSErr;

The HOpenRF function creates an access path to the resource fork of a file. It is a high-level
function that calls PBHOpenRF, documented in the File Manager chapter of Volume IV.
FUNCTION

HDelete

(vRefNum:

Integer;

dirID:

LongInt;

fileName:

Str255)

OSErr;

The HDelete function removes a closed file. It is a high-level function that calls PBHDelete,
documented in the File Manager chapter of Volume IV.
FUNCTION

HSetFLock

(vRefNum:

Integer;

dirID:

LongInt;

fileName:

Str255)

OSErr;

The HSetFLock function locks a file. It is a high-level function that calls PBHSetFLock,
documented in the File Manager chapter of Volume IV.
FUNCTION

HRstFLock

(vRefNum:

Integer;

dirID:

LongInt;

fileName:

Str255)

OSErr;

The HRstFLock function unlocks a file. It is a high-level function that calls PBHRstFLock,
documented in the File Manager chapter of Volume IV.
FUNCTION

HRename

(vRefNum:

Integer;

newName:

Str255)

dirID:
:

LongInt;

oldName:

Str255;

OSErr;

The HRename function changes the name of a file or directory. It is a high-level function that
calls PBHRename, documented in the File Manager chapter of Volume IV.
FUNCTION

HGetFInfo

(vRefNum:
VAR

Integer;

fndrinfo:

dirID:

FiInfo)

:

LongInt;

fileName:

Str255;

OSErr;

The HGetFInfo function returns the Finder information stored in the volume’s catalog for a

file. It is a high-level function that calls PBHGetFInfo, documented in the File Manager

chapter of Volume IV.
FUNCTION

25-36

HSetFInfo

(vRefNum:

Integer;

fndrinfo:

FInfo)

High-Level File Manager Routines

dirID:
:

OSErr;

LongInt;

fileName:

Str255;

The File Manager

The HSetFInfo function changes the Finder information stored in the volume’s catalog for a
file. It is a high-level function that calls PBHSetFInfo, documented in the File Manager
chapter of Volume IV.
FUNCTION

HGetVol

(volName:
VAR

StringPtr;

dirID:

VAR

LongInt)

:

vRefNum:

Integer;

OSErr;

The HGetVol function returns the volume reference number of the default volume. It is a highlevel function that calls PBHGetVol, documented in the File Manager chapter of Volume IV.

LOW-LEVEL

FILE

MANAGER

ROUTINES

This section describes the low-level File Manager routines new in version 7.0.
All low-level routines exchange parameters with your application in a parameter block, which
is a data structure in the heap or stack. When calling low-level routines, you usually pass a
pointer to the parameter block and a Boolean value that determines whether the routine is run
synchronously (FALSE) or asynchronously (TRUE). The new routines for mounting
volumes take only a pointer to the parameter block. These functions are always run synchronously. See the introduction to low-level routines in the File Manager chapter of Volume IV
for a description of the standard parameters in a low-level function.
You cannot assume that a series of asynchronous calls will be executed in the order in which
they are issued, especially in a shared environment. When the order and timing of functions
are important (if, for example, you are first reading and then writing data), you can either call
the functions synchronously or check the completion routines of functions called asynchronously before acting on the result.

Reading

Volume

Information

The PBHGetVolParms function describes the characteristics of a volume. You specify
a volume (by either name or volume reference number) and a buffer size, and
PBHGetVolParms fills in the volume-attributes buffer, as described in this section.
FUNCTION

PBHGetVolParms

(paramBlock:

HParmBlkPtr;

async:

nN

Boolean)

4

OSErr;

Parameter block
12

oO

ioCompletion

long

pointer to completion routine

E
we

-

16

ioResult

word

error result code

>

22

ioVRefNum

word

volume specification

>

32

ioBuffer

long

pointer to GetVolParmsInfo record

4

36

ioReqCount

long

size of buffer area

—

40

ioActCount

long

length of attributes data
Low-Level File Manager Routines

— 25-37

Inside Macintosh,

Volume VI

A volume’s characteristics can change when the user enables and disables file sharing. You
might have to make repeated calls to PBHGetVolParms to ensure that you have the current
status of a volume.
The ioCompletion field holds an optional pointer to a completion routine, which executes
after PBHGetVolParms completes if you call the function asynchronously. Set this field
to NIL when you call the function synchronously.
PBHGetVolParms puts the result code in the ioResult field.
Specify the volume to be described with a volume reference number, drive number, or
working directory reference number in the ioVRefNum field.
You must allocate memory to hold the returned attributes and put a pointer to the buffer in the
ioBuffer field. Specify the size of the buffer in the ioReqCount field.
PBHGetVolParms places the attributes information in the buffer pointed to by the ioBuffer
field and specifies the actual length of the data in the ioActCount field.
The new version of PBHGetVolParms uses a new format for the GetVolParmsInfo
attributes buffer.

Offset

Field

Size

Meaning

0)

vMVersion

word

Version number (02 in system software

2
6
10
14
18

vMAttrib
vMLocalHand
vMServerAdr
vMVolumeGrade
vMForeignPrivID

long
long
long
long
word

Attributes
Reserved
AppleTalk server address (0 if not supported)
Relative speed rating of volume
Foreign privilege model supported
(two values are currently defined: 0 for an HFS

version 7.0)

volume; fsUnixPriv for an A/UX volume)

The vMVersion field specifies the version of the attributes buffer.
The vMAttrib field contains 32 bits that describe the volume. When set, the bits in VMAttrib

have these meanings:
Bit

Name

31

bLimitFCBs

30

bLocalWList

29

bNoMiniFndr

Use the returned shared volume handle for the
Finder’s local window list.
Disable Mini Finder menu item.

26

bTrshOffLine

Zoom volume when it is unmounted.

28
21
25

25-38

bNoVNEdit
bNoLclSync

bNoSwitchTo

Low-Level File Manager Routines

Meaning
Limit the number of file control blocks used

during copying to 8 instead of 16.

Lock volume name against editing.
Do not let Finder change the modification date.
Do not switch launch to any application on
the volume.

The File Manager

Bit
24-21

Name

19

bNoDeskItems
bNoBootBlks

18

bAccessCntl

17

bNoSysDir

16

bHasExtFS
Vol

bHasOpenDeny

14

bHasCopyFile

bHasMoveRename

bHasDesktopMer
bHasShortName
bHasFolderLock

bHasPersonalAccessPrivileges
bHasUserGroupList
bHasCatSearch
bHasFileIDs

bHasBtreeMer
bHasBlankAccessPrivileges

Meaning
Reserved.
Do not place objects on the Finder desktop.
Not a startup volume. Startup menu item disabled.
Boot blocks not copied.
Volume supports AppleTalk AFP access-control
interfaces. The GetLoginInfo, GetDirAccess,
SetDirAccess, MapID, and MapName functions
are supported. Special folder icons are used. The
Access Privileges menu command is enabled for
disk and folder items. The privileges field of
GetCatInfo calls is assumed to be valid.
Volume doesn’t support a system directory.
Do not switch launch to this volume.
Volume is an external file system volume.
Disk initialization package is not called. Erase
Disk menu command is disabled.
Volume supports _OpenDeny and OpenRFDeny.
For copy operations, source files are opened with
reading enabled and writing denied; destination
files are opened with writing enabled and
reading and writing disabled.
Volume supports _CopyFile. _CopyFile is
used in copy and duplicate operations if both
source and destination volumes have the same
server address.
Volume supports _MoveRename.
Volume supports all of the new desktop
functions (described in the Finder Interface
chapter of this volume).
Volume supports a name that fits the shorter
length requirements of another file system.
Folder is locked.
Local file sharing is enabled.
Volume supports the Users and Groups file and
thus the AFP privilege functions.
Volume supports PBCatSearch.
Volume supports file ID functions, including
PBExchangeFiles.
Reserved for internal use.
Volume supports inherited access privileges
for folders.
Reserved.

The vMLocalHand field is reserved.

The vMServerAdr field specifies the internet address of the server that manages an AppleTalk
server volume. This value is 0 if the volume does not have a server.
The vMVolumeGrade field specifies the relative speed rating of the volume. This scale is
currently uncalibrated. Generally, lower values represent faster speeds, but a value of 0
means that the volume is unrated.
Low-Level File Manager Routines

— 25-39

nN
uw

a}

oC

K<
et
&
=|

&
ge
@
=

Inside Macintosh,

Volume VI

The vMForeignPrivID field specifies an operating system with which the volume can communicate access-control information. For more information about access-control privileges,
see “Manipulating Privilege Information in Foreign File Systems” earlier in this chapter and
“Accessing Privilege Information in Foreign File Systems” later in this chapter. A value of 0
means that the volume cannot share privilege information with any other file system; a value
of fsUnixPriv means it can share privilege information with the A/UX file system.
Result codes
noErr
nsvErr

0
—35

paramErr

Searching

No error
Volume not found

—50

Volume doesn’t support the function

a Catalog

The PBCatSearch function searches a volume’s catalog, using a set of search criteria that you
specify. It builds a list of all files or directories that meet your specifications.
FUNCTION

PBCatSearch

(paramBlock:

HParmBlkPtr;

async:

Boolean)

:

OSErr;

Parameter block

—

12

ioCompletion

long

pointer to completion routine

<

16

ioResult

word

result code

—

18

ioNamePtr

long

pointer to volume name

—

22

ioVRefNum

word

volume specification

—

24

ioMatchPtr

long

pointer to array of matches

—

28

ioReqMatchCount

long

maximum match count

<

32

ioActMatchCount

long

actual match count

—>

36

ioSearchBits

long

enable bits for fields in criteria records

—

40.

ioSearchInfol

long

values and lower bounds

—

44

ioSearchInfo2

long

masks and upper bounds

—

48

ioSearchTime

long

maximum elapsed search time

—

52

ioCatPosition

16 bytes

current catalog position

—

68

ioOptBuffer

long

pointer to optional read buffer

—

72

ioOptBufSize

long

length of optional read buffer

PBCatSearch searches the volume you specify for files or directories that match two coordinated sets of selection criteria. PBCatSearch returns a pointer to an array of FSSpec records
identifying the files and directories that match the criteria.
Field descriptions
ioCompletion

A pointer to the completion routine.

ioResult

Result code.

25-40

— Low-Level File Manager Routines

The File Manager

ioNamePtr

A pointer to the name of the volume to be searched.

ioVRefNum

The volume specification (volume reference number, working
directory reference number, drive number, or 0 for default volume).

ioMatchPtr

A pointer to an array where the file and directory names that match the
selection criteria are returned. The array must be large enough to hold
the largest possible number of FSSpec records, as determined by the
ioReqMatchCount field.

ioReqMatchCount

The maximum number of matches to return. This number should be
the number of FSSpec records that will fit in the memory pointed to by
ioMatchPtr. Use this field to avoid a possible excess of matches for
criteria that prove to be too general.

ioActMatchCount

The number of actual matches found.

ioSearchBits

The fields of the parameter blocks ioSearchInfol and ioSearchInfo2
that are relevant to the search. See “Searching a Volume” earlier in this
chapter for the values of ioSearchBits.

ioSearchInfol

A pointer to a CInfoPBRec parameter block that contains values and
the lower bounds of ranges for the fields selected by ioSearchBits.

ioSearchInfo2

A pointer to a second CInfoPBRec parameter block that contains
masks and upper bounds of ranges for the fields selected by
ioSearchBits.

ioSearchTime

A time limit on a search, in Time Manager format. Use this field to
limit the run time of a single call to PBCatSearch. A value of 0
imposes no time limit.

ioCatPosition

A position in the catalog where searching should begin. Use this field
to keep an index into the catalog when breaking PBCatSearch down
into a number of smaller searches. This field is valid whenever
PBCatSearch exits because it either spends the maximum time allowed
by ioSearchTime or finds the maximum number of matches allowed
by ioReqMatchCount.
To start at the beginning of the catalog, set the initialize field of
ioCatPosition to 0. Before exiting after an interrupted search,
PBCatSearch sets that field to the next catalog entry to be searched.
To resume where the previous call stopped, pass the entire CatPosition
record returned by the previous call as input to the next.

ioOptBuffer

A pointer to an optional read buffer. The ioOptBuffer and ioOptBufSize
fields let you specify a part of memory as a read buffer, increasing
search speed.

ioOptBufSize

The length of the buffer pointed to by ioOptBuffer. Buffer effectiveness
varies with models and configurations, but a 16 KB buffer is likely
to be optimal. Even a | KB buffer provides some performance
improvement.

See the earlier section “Searching a Volume” for a description of how to use PBCatSearch.

Low-Level File Manager Routines

25-41

i)

ui

ri

o

<

coal

9
5
g9
ge
@

eae

|

Inside Macintosh,

Volume VI

If the catalog changes between two timed calls to PBCatSearch (when you are using
ioSearchTime and ioCatPosition to search a volume in segments and the catalog changes
between searches), PBCatSearch returns a result code of catalogChangedErr. Depending
on what has changed on the volume, ioCatPosition might be invalid, most likely by a few
entries in one direction or another. You can continue the search, but you risk either skipping
some entries or reading some twice.
When PBCatSearch has searched the entire catalog, it returns eofErr. If it exits because it
either spends the maximum time allowed by ioSearchTime or finds the maximum number
of matches allowed by ioReqMatchCount, it returns noErr.
Result codes

noErr
nsvErr
i0Err
eofErr
paramErr
extPSErr
catalogChangedErr

Creating

FSSpec

0
-35
-36
-39
—50
—58
-1304

Noerror (entire catalog has not been searched)
Volume not found
I[/Oerror
Logical end-of-file reached
Parameters don’t specify an existing volume
External file system
Catalog has changed and catalog position record
may be invalid

Records

Use the PBMakeFSSpec function to make an FSSpec record that identifies a file or directory.
FUNCTION

PBMakeFSSpec

Parameter block
>
12

(paramBlock:

HParmBlkPtr;

async:

Boolean)

:

ioCompletion

long

pointer to completion routine

OS#rr;

-

16

ioResult

word

result code

=

18

ioNamePtr

long

pointer to file or directory name

>

22

ioVRefNum

word

volume specification

~

28

ioMisc

long

pointer to FSSpec record

>

48

ioDirID

long

parent directory ID

Given a complete specification for a file or directory, PBMakeFSSpec fills in an FSSpec
record that identifies the file or directory. (See Table 25-1 in “Using FSSpec Records” for a
detailed description of valid file specifications.)
Field descriptions
ioCompletion

A pointer to the completion routine.

ioResult

Result code.

ioNamePtr

A pointer to the file or directory name.

25-42

Low-Level File Manager Routines

The File Manager

ioVRefNum

The volume specification (volume reference number, working
directory reference number, drive number, or 0 for default volume).

ioMisc

A pointer to the FSSpec record.

ioDirID

The directory or parent directory specification.

If the specified volume is mounted and the specified parent directory exists, but the target file
or directory doesn’t exist in that location, PBMakeFSSpec fills in the record and returns
fnfErr instead of noErr. The record is valid, but it describes a target that doesn’t exist. You
can use the record for another operation, such as creating a file to replace one that is missing.
In addition to the result codes listed here, PBMakeFSSpec can return a number of different
File Manager error codes. When PBMakeFSSpec returns any result other than noErr or
fnfErr, all fields of the resulting FSSpec record are set to 0.
Result codes
noErr
fnfErr

Swapping

0
—43

Data

No error
File or directory does not exist
(FSSpec is still valid)

Between

Two

Files

Use the PBExchangeFiles function to swap the data stored in two files on the same volume.
FUNCTION

PBExchangeFiles

Parameter block
—
12
ioCompletion

(paramBlock:

HParmBlkPtr;

async:

Boolean)

long

pointer to completion routine

:

OSErr;

<

16 — ioResult

word

result code

—

18

ioNamePtr

long

pointer to first filename

—>

22

ioVRefNum

word

volume specification (volume reference
number, working directory reference number,

drive number, or 0 for default volume)

—

28

ioDestNamePtr

long

pointer to second filename

—

36

ioDestDirID

long

second parent directory ID

—

48

= ioSrcDirID

long

first parent directory ID

PBExchangeFiles swaps the data in two files by changing the information in the volume
catalog and, if the files are open, in the file control blocks. See Tables 25-2 and 25-3 in the
earlier section “Updating Files” for an illustration of how PBExchangeFiles changes the
catalog entries and file control blocks. PBExchangeFiles uses the file ID parameter block,
described in “Creating and Using File IDs” later in this chapter.
You should use PBExchangeFiles or FSpExchangeFiles to preserve the file ID when
updating an existing file, in case the file is being tracked through its file ID.
Low-Level File Manager Routines

— 25-43

Inside Macintosh,

Volume VI

Typically, you use PBExchangeFiles after creating a new file during a safe save. You identify
the names and parent directory IDs of the two files to be exchanged in the fields ioNamePtr,
ioDestNamePtr, ioSrcDirID, and ioDestDirID. PBExchangeFiles changes the fields in the

catalog entries that record the location of the data and the modification dates. It swaps both
the data forks and the resource forks.
PBExchangeFiles works on either open or closed files. If either file is open, PBExchangeFiles
updates any file control blocks associated with the file. Exchanging the contents of two files
requires essentially the same access as opening both files for writing.
PBExchangeFiles does not require that file IDs exist for the files being exchanged.
Result codes
noErr
nsvErr
ioErr
fnfErr
fLekdErr
volOfflinErr

extFSErr
wrgVolTypeErr
diffV olErr

Creating

and

0
—35
—36
43
—45
—53

—58
-123

—1303

Using

No error
Volume not found
I/O error
File not found
File locked
Volume is off line

External file system
Notan HFS volume

Files on different volumes

File IDs

This section describes the new functions for tracking files with file IDs and lists the
previously released functions that have been affected by file IDs.
The functions for manipulating file [IDs use a new parameter block variant, FIDParam.
CASE

ParamBlockType

OF

FIDParam:

25-44

(filleri4:
ioDestNamePtr:
filler15:

Longint;
StringPtr;
LongiInt;

{filler}
{pointer
{filler}

ioDestDirID:

Longint;

{destination

fillerlé6é:

LongiInt;

{filler}

fillerl17:
ioSrcDirID:

Longint;
Longint;

{filler}
{source parent

fFiller18:
ioFileID:

Integer;
Longint) ;

{filler}
{file ID}

Low-Level File Manager Routines

to

destination
parent

filename}

directory

directory

ID}

ID}

The File Manager

The ioDestNamePtr and ioDestDirID fields are used only with the PBExchangeFiles function,
described in the preceding section.
The fields common to all low-level functions and the other parameter block types are
described in the File Manager chapter of Volume IV.

Functions

for Manipulating

File IDs

Use the PBCreateFileI[DRef function to establish a file ID reference for a file.
FUNCTION

PBCreateFileIDRef

(paramBlock:

HParmBlkPtr;

async:

Boolean)

OSErr;

Parameter block
>
12

ioCompletion

long

pointer to completion routine

on

16

ioResult

word

result code

>

18

ioNamePtr

long

pointer to filename

>

22

ioVRefNum

word

volume specification

>

48

ioSrcDirID

long

parent directory ID

+

54

i0FileID

long

file ID

Given a volume reference number, filename, and parent directory ID, PBCreateFileIDRef
creates a record to hold the name and parent directory ID of the specified file.
PBCreateFileIDRef places the file ID in the ioFileID field. If a file ID reference already
exists for the file, PBCreateFileIDRef supplies the file ID but returns fidExists.
Result codes
noErr
nsvErr
ioErr
fnfErr
wPrErr
vLckdErr

volOfflinErr
extFSErr
wrgVolTypeErr
fidExists
notAFileErr

0
—35
—36
—43
—44
—46

-53
-58
-123
-1301
-1302

No error
Volume not found
J/Oerror
File not found
Hardware volume lock
Software volume lock

Volume is off line
External file system
Notan HFS volume
File ID already exists
Specified file is a directory

»
ny
=
=
S
tie)

Low-Level File Manager Routines

— 25-45

Inside Macintosh,

Volume VI

Use the PBDeleteFileIDRef function to delete a file ID reference.
FUNCTION

PBDeleteFileIDRef

(paramBlock:

HParmBlkPtr;

async:

Boolean)

OSErr;

Parameter block
>
12

ioCompletion

long

pointer to completion routine

oa

16

ioResult

word

result code

as

18

ioNamePtr

long

pointer to filename

=

22

ioVRefNum

word

volume specification

=

54

ioFileID

long

file ID

PBDeleteFileIDRef invalidates the specified file ID on the volume specified by ioVRefNum
or ioNamePtr. After it has invalidated a file ID, the File Manager can no longer resolve that
ID to a filename and parent directory ID.
Result codes
noErr
nsvErr
ioErr
wPrErr
vLckdErr
volOfflinErr

extPSErr

fidNotFoundErr

)
—35
—36
—44
—46
—53

-58

—1300

No error
Volume not found
I/O error
Hardware volume lock
Software volume lock
Volume is off line

External file system
File ID not found

Use the PBResolveFileIDRef function to retrieve the filename and parent directory ID of the
file with a specified file ID.
FUNCTION

PBResolveFileIDRef

(paramBlock:

HParmBlkPtr;

async:

Boolean)

OSErr;

Parameter block
=
12

25-46

ioCompletion

long

pointer to completion routine

-

16

ioResult

word

result code

o

18

ioNamePtr

long

pointer to filename

=>

22

ioVRefNum

word

volume specification

—

48

ioSrcDirID

long

parent directory ID

=>

54

ioFileID

long

file ID

Low-Level File Manager Routines

The File Manager

PBResolveFileIDRef returns the filename and parent directory ID of the file referred to by file
ID in the ioFileID field. It places the filename in the string pointed to by the ioNamePtr field and
the parent directory ID in the ioSrcDirID field. If the name string is NIL, PBResolveFileIDRef
returns only the parent directory ID. If the name string is not NIL but is only a volume name,
PBResolveFileIDRef ignores the value in the ioVRefNum field, uses the volume name instead,
and overwrites the name string with the filename. A return code of fidNotFoundErr means that
the specified file ID has become invalid, either because the file was deleted or because the file ID
was destroyed by PBDeleteFileIDRef.
Result codes
noErr
nsvErr
ioErr
fnfErr
volOfflinErr

extFSErr
wrgVolTypeErr
fidNotFoundErr
notAFileErr

Functions

0
—35
—36
—43
—53

-58
-123
-1300
-1302

Changed

No error
Volume not found
I/O error
File not found
Volume is off line

External file system
Notan HFS volume
File ID not found
Specified file is a directory

to Accommodate

File IDs

Some existing HFS functions now support file [Ds as appropriate. Support for file IDs
requires some change in function, but no changes in the program interface. This section lists
the affected functions and describes how they accommodate file IDs.
FUNCTION

PBHDelete

(paramBlock:

HParmBlkPtr;

async:

Boolean)

:

OSErr;

If a file ID reference exists for the file being deleted, the file ID reference is also deleted.
FUNCTION

PBHRename

(paramBlock:

HParmBlkPtr;

async:

Boolean)

:

OSErr;

If a file ID exists for the file being renamed, the file ID remains with the file.
FUNCTION

PBCatMove

(paramBlock:

CMovePBPtr;

async:

Boolean)

:

OSErr;

If a file ID exists for the file being moved, the file ID remains with the file.
FUNCTION

PBGetCatInfo

(paramBlock:

CInfoPBPtr;

async:

Boolean)

:

OSErr;

You can use the PBGetCatInfo function to determine whether a file has a file ID. The value of

the file ID is returned in the ioDirID field. Because that parameter could also represent a
directory ID, call PBResolveFileIDRef to see if the value is a real file ID. If you want to both

determine whether a file ID exists for a file and create one if it doesn’t, use PBCreateFileIDRef,
which either creates a file ID or returns fidExists.

Low-Level File Manager Routines

= 25-47

Inside Macintosh, Volume VI

Mounting

Volumes

A set of three functions allows your application to record the mounting information for a
volume and then to mount the volume later.
The programmatic mounting functions store the mounting information in a structure called the
AFPVolMountInfo record, described earlier in “Mounting Volumes Programmatically.”
The programmatic mounting functions use the ioParam variant of the ParamBlockRec record,
described in the File Manager chapter of Volume IV.
You use the PBGetVolMountInfoSize function to determine how much space to allocate for
the volume-mounting record.
FUNCTION

PBGetVolMountInfoSize

Parameter block
~
12

(paramBlock:

ParmBlkPtr)

:

OSErr;

ioCompletion

long

pointer to completion routine

e

16

ioResult

word

result code

>

22

ioVRefNum

word

volume specification

>

32

ioBuffer

long

pointer to storage for size (4 bytes
of storage)

For a specified volume, the PBGetVolMountInfoSize function provides the size of the record

needed to hold the volume’s mounting information.
Result codes

noErr
nsvErr
paramErr
extFSErr

0
—35
—50
—58

No error
Volume not found
Parameter error
External file system error; typically,

function is not available for that volume

After ascertaining the size of the record needed and allocating storage, you call the
PBGetVolMountInfo function to retrieve a record containing all the information needed
to mount the volume, except for passwords. You can later pass this record to the
PBVolumeMount function to mount the volume.
FUNCTION

PBGetVolMountInfo

Parameter block
>
12

25-48

(paramBlock:

ParmBlkPtr)

:

OSErr;

ioCompletion

long

pointer to completion routine

<

16

ioResult

word

result code

a

22

ioVRefNum

word

volume specification

>

32

ioBuffer

long

pointer to mounting information

Low-Level File Manager Routines

The File Manager

PBGetVolMountInfo places the mounting information for a specified volume into the buffer
pointed to by the ioBuffer field. The mounting information for an AppleShare volume is stored
as an AFP mounting record, described earlier in “Mounting Volumes Programmatically.” The
length of the buffer is specified by the value pointed to by the ioBuffer field in a previous call
to PBGetVolMountInfoSize.
PBGetVolMountInfo does not return the user password or volume password in the
AFPVolMountInfo record. Your application solicits these passwords from the user
and fills in the record before attempting to mount the remote volume.
Result codes

noErr
nsvErr
paramErr
extFSErr

Q
-35
—50
-58

Noerror
Volume not found
Parameter error
External file system error; typically,

function is not available for that volume

You use the PBVolumeMount function to mount a volume, using either the information
returned by the PBGetVolMountInfo function or a structure you filled in yourself.
FUNCTION

PBVolumeMount

(paramBlock:

ParmBlkPtr)

:

OSErr;

Parameter block

>

12

ioCompletion

long

pointer to completion routine

—

16

ioResult

word

result code

-

22

ioVRefNum

word

volume reference number

>

32

ioBuffer

long

pointer to mounting information

The PBVolumeMount function mounts a volume and returns its volume reference number. If
you're mounting an AppleShare volume, place the volume’s AFP mounting record in the
buffer pointed to by the ioBuffer field. Because the password fields are not included in an

AFP mounting record returned by PBGetVolMountInfo, you must set these fields before

calling PBVolumeMount.
Result codes
noErr

0

notOpenErr
nsvErr
paramErr

-28
—35
-50

extFSErr

-58

memFullErr

—108

afpBadUAM

—5002

Noerror

=

AppleTalk is not open
Volume not found
Parameter error; typically, zone, server, and volume
name combination is not valid or not complete, or the
user name is not recognized
External file system error; typically, file system
signature was not recognized, or function is not
available for that volume

2
=
a

Not enough memory to create a new volume

control block for mounting the volume
User authentication method is unknown

Low-Level File Manager Routines

25-49

Inside Macintosh,

Volume

VI

afpBadVersNum

—5003

afpNoServer
afpUserNotAuth

—5016
—5023

afpPwdExpired
afpBadDirlIDType
afpCantMountMoreSrvrs

—5042
—5060
-5061

afpAlreadyMounted
afpSameNodeErr

—5062
—5063

Accessing

Workstation is using an AFP version that the
server doesn’t recognize
Server is not responding
_ User authentication failed (usually, password is
not correct)

Password has expired on server
Nota fixed directory ID volume
Maximum number of volumes has been
mounted
Volume already mounted
Attempt to log on to a server running on the
same machine

Privilege Information

in Foreign

File Systems

The File Manager provides two functions that an application or shell program can use to
communicate with a foreign file system about its native access-control system. The functions
retrieve and set access permissions on the foreign file system. The access-control functions
use a new parameter block variant, ForeignPrivParam.
CASE

ParamBlockType

OF

ForeignPrivParam:
(filler21:

Longint;

{filler}

filler22:

Longint;

{filler}

ioForeignPrivBuffer:

Ptr:

{privileges

ioForeignPrivReqCount:

LongInt;

{size

ioForeignPrivActCount:

LongInt;

{amount

filler23:

Longint;

{filler}

ioForeignPrivDirID:

LongInt;

{parent
{

of

data}

buffer}
of

buffer

used}

directory

foreign

file

ID

or

ioForeignPrivinfol:

Longint;

{privileges

data}

ioForeignPrivinfo2:

Longint;

{privileges

data

ioForeignPrivinfo3:

Longint;

{privileges

data}

ioForeignPrivinfoé4:

Longint);

{privileges

data}

of

}

directory}

Use the PBGetForeignPrivs function to determine the native access-control information for a
file or directory stored on a volume managed by a foreign file system.
FUNCTION

PBGetForeignPrivs

(paramBlock:

HParmBlkPtr;

async:

Boolean)

OSEYr;

Parameter block
—
12. ioCompletion

25-50

long

pointer to completion routine

<—

16.

ioResult

word — result code

—

18

ioNamePtr

long

pointer to file or directory name

—>

22

ioVRefNum

word

volume specification

—

32

toForeignPrivBuffer

long

Low-Level File Manager Routines

__ pointer to privilege info buffer

The File Manager

—

36

ioForeignPrivReqCount

long _ size allocated for buffer

<

40

ioForeignPrivActCount

long

—

48

1oForeignPrivDirID

word _ parent directory ID

<

52.

ioForeignPrivinfol

long

_ information specific to privilege model

<

56.

ioForeignPrivInfo2

long

_ information specific to privilege model

<

60

ioForeignPrivInfo3

long

information specific to privilege model

<

64

ioForeignPrivInfo4

long

information specific to privilege model

amount of buffer used

PBGetForeignPrivs retrieves access information for a file or directory on a volume managed
by a file system that uses a privilege model different from the AFP model. See “Manipulating
Privilege Information in Foreign File Systems” earlier in this chapter for a fuller explanation
of access-control privileges. See the File Manager chapter of Volume V for a description of
the AFP privilege model.
Result codes

noErr
nsvErr
paramErr

0)
—35
—50

No error
Volume not found
Volume is HFS or MFS (that is, it has no foreign privilege
model), or foreign volume does not support these calls

Use the PBSetForeignPrivs function to change the native access-control information for a file
or directory stored on a volume managed by a foreign file system.
FUNCTION

PBSetForeignPrivs

(paramBlock:

HParmBlkPtr;

async:

Boolean)

OSETY}

Parameter block
amd
12 ioCompletion

long

pointer to completion routine

on

16

ioResult

word — result code

>

18

ioNamePtr

long

>

22

ioVRefNum

word

>

32

ioForeignPrivBuffer

long

>

36

ioForeignPrivReqCount

long _ size allocated for buffer

ce

>

40

ioForeignPrivActCount

long

a

>

48

ioForeignPrivDirID

word _ parent directory ID

3

>

52

ioForeignPrivinfol

long

information specific to privilege model

"

>

56

10ForeignPrivInfo2

long

information specific to privilege model

>

60

ioForeignPrivInfo3

long

information specific to privilege model

>

64

ioForeignPrivInfo4

long

information specific to privilege model

__ pointer to file or directory name
volume specification
__ pointer to privilege info buffer

hb

amount of buffer used

PBSetForeignPrivs modifies access information for a file or directory on a volume managed
by a file system that uses a privilege model different from the AFP model.
Low-Level File Manager Routines

— 25-51

Inside Macintosh, Volume VI

Result codes

noErr
nsvErr
paramErr

Opening

Data

0
—35
—50

No error
Volume not found
Volume is HFS or MFS (that is, it has no foreign privilege
model), or volume doesn’t support these functions

Forks

Use the PBOpenDF function to open the data fork of a file. PROpenDF replaces PBOpen,
which can open either a driver or the data fork of a file.
FUNCTION

PBOpenDF

(paramBlock:

ParmBlkPtr;

async:

Boolean)

:

OSErr;

Parameter block

>

12

ioCompletion

long

pointer to completion routine

-

16

ioResult

word

result code

>

18

ioNamePtr

long

pointer to file or directory name

=>

22

ioVRefNum

word

volume specification

-

24

ioRefNum

word

access path number

acd

zd

ioPermssn

byte

permission

PBOpenDF creates an access path to the data fork of a file. It is almost identical to PBOpen,
which is documented in the File Manager chapter of Volume IV. The difference is that
PBOpen can open both files and drivers, but PBOpenDF can open only files. Using OpenDF
instead of FSOpen when your application is opening a file prevents naming conflicts or ambiguities and ensures that your application can open files whose names begin with a period (.).
Result codes
noErr
nsvErr
ioErr
bdNamErr

No error
Volume not found
I/O error
Bad filename

tmfoErr

—42

Too many files open

opWrErr
extFSErr

49
—58

File already open for writing
External file system

fnfErr

25-52

0
—35
—36
—37
—43

File not found

Low-Level File Manager Routines

The File Manager

Use the PBHOpenDF function to open the data fork of a file on a hierarchical volume.
PBHOpenDF replaces PBHOpen, which can open either a driver or the data fork of a file.
FUNCTION

PBHOpenDF

(paramBlock:

HParmBlkPtr;

async:

Boolean)

:

OSErr;

Parameter block
=>

12

ioCompletion

long

pointer to completion routine

on

16

ioResult

word

result code

>

18

ioNamePtr

long

pointer to file or directory name

>

22

ioVRefNum

word

volume specification

-

24

ioRefNum

word

access path number

>

27

ioPermssn

byte

permission

>

48

ioDirID

long

parent directory ID

PBHOpenDF creates an access path to the data fork of a file. It is almost identical to
PBHOpen, which is documented in the File Manager chapter of Volume IV. The difference is
that PBHOpen can open both files and drivers, but PBHOpenDF can open only files. Using
PBHOpenDF instead of PBHOpen when your application is opening a file prevents naming
conflicts or ambiguities and ensures that your application can open files whose names begin
with a period (.).
Result codes
noErr
nsvErr
ioErr
bdNamErr
tmfoErr
fnfErr

0)
—35
—36
—37
—42
—43

extFSErr
dirNFErr

—58
—120

opWrErr

—49

No error
Volume not found
I/O error
Bad filename
Too many files open
File not found
File already open for writing
External file system
Directory not found
i)
ui
<.

o
A
fo
=,
$9
re

—

a7

“

Low-Level File Manager Routines

— 25-53

Inside Macintosh,

SUMMARY

Volume VI

OF

THE

FILE

MANAGER

='fe

‘%s

Constants
CONST

{Gestalt

constants}

gestaltFSAttr

{file

system

attributes

selector}

gestaltFullExtFSDispatching
=

0;

{exports

HFSDispatch

1;

{supports

traps}

gestaltHasFSSpecCalls
=

{values
for ioSearchBits
in
fsSBPartialName
=
Lie
fsSBFullName
=
2;
fsSBFlAttrib
fsSBNegate

=
=

4;
16384;

{for files only}
fsSBF1lFndriInfo

cS

8;

fsSBFlLgLen

=

32+

fsSBF1PyLen
fsSBF1RLgLen
fsSBF1RPyLen
£sSBF1CrDat
fsSBF1MdDat
fsSBF1BkDat
f£sSBF1XFndrinfo
f£sSBF1ParID

=
=
=
=
=
=
=
=

64;
128:
2563
512;
1024;
2048;
4096;
8192;

{for directories
fsSBDrUsrwds
fsSBDrNmFls

only}
=
=

8;
16;

{directory
flag;
software
{reverse match status}

{Finder
{data

file
fork

{Finder
{number

=

512.

{directory

1024;

£sSBDrBkDat
fsSBDrFndrinfo
fsSBDrParID

=
=
=

2048;
4096;
§192%

{directory

fsRdWrPerm

fsRdWrShPerm

flag}

info}
logical

length}

directory info}
of files in directory}

=

fsRdPern
fsWrPerm

lock

{data fork physical length}
{resource fork logical
length}
{resource fork physical length}
{file creation date}
{file modification date}
{file backup date}
{more Finder file info}
{file's parent ID}

fsSBDrMdDat

for

records}

PBCatSearch param block}
{substring
of name}
{full
name}

fsSBDrCrDat

{permissions
E~sCurPerm

creation date}
modification
date}

{directory backup date}
{more Finder directory info}
{directory's parent ID}

opening files}
=
0;
{exclusive read/write permission if it
{ is available;
otherwise,
exclusive
}
if that is available}
{ read,
=
=
=

=

1;
23
3;

4;

{value of vMForeignPrivID in
fsUnixPriv
=
1;

25-54

FSSpec

— Summary of the File Manager

{exclusive
{exclusive
{exclusive

{shared

read permission}
write permission}
read/write
permission}

read/write

file attributes
{A/UX privilege

permission}

buffer}
model}

}

The File Manager

{vMAttribut

bit

position

constants}
{limit

bLimitFCBs

=

313

bLocalWList

=

30;

{use

file

control

shared

volume

bNoMiniFndr

=

29;

{ window
{disable

bNoVNEdit

—

28;

{lock

bNoLclSync

=

27;

{do

blocks}
handle

list}
Mini Finder

volume

not

let

for

menu

}

item}

name}
Finder

change

}

bTrshOffLine
bNoSwitchTo

=
=

26;

bNoDeskIitems

=

20;

date}
{ modification
{zoom volume when
it is unmounted}
{do
not
switch
launch to applications}
{do not place objects on the
}

bNoBootBlks

=

19;

{ Finder desktop}
{not a startup volume}

bAccessCntl
bNoSysDir

=
-

18;

{volume

L7:

{no

bHasExtFSVol
bHasOpenDeny

=
=

16;

{external

Lee

{volume

bHasCopyFile

=

14;

bHasMoveRename
bHasDesktopMgr

=
=

bHasShortName

=

253

supports

system

AFP

access

control}

directory}
file

system

volume}

support

shared

{volume

supports

_CopyFile}

133
Lis

{volume

supports

_MoveRename}

{volume

Lae

{volume

supports
supports

Desktop
shorter

bHasFolderLock
=
Le
bHasPersonalAccessPrivileges

{folder

is

locked}

{local

file

sharing

bHasUserGroupList
bHasCatSearch
bHasFileIDs

{volume

supports

AFP

{volume

supports

PBCatSearch}

=
=
=

{volume

bHasBtreeMgr
bHasBlankAccessPrivileges
4;

enabled}

privileges}

fileID

{volume

inherited

supports

privileges

mounting

information}

‘afpm';

{an

{user authentication methods in
1 ‘
kNoUserAuthentication
2 ‘
kPassword
3 ‘
kEncrypt Password
6 ’
kTwoWayEncrypt Password

for

AppleShare

AFP

remote

{guest

modes}

Manager}
name}

supports
{reserved}

{

{media type in remote
AppleShareMediaType =

is

access

functions}

access

volume}

mounting

status;

no

information}

password

needed}

{8-byte password}
{encrypted
8-byte password}
{two-way
random encryption;
{

}

folders}

authenticate

both

user

and

}
server}

=

©
a
J
as
~~
~~
—
a
=

tio
@

ar |

Summary of the File Manager

— 25-55

Inside Macintosh,

Data
TYPE

Volume VI

Types
FSSpec

=

RECORD
vRefNum:

Integer;

{volume

parID:

Longint;

{directory

reference

name:

Str63

{filename

FSSpecPtr

=

“FSSpec;

FSSpecHandle

=

“FSSpecPtr;

FSSpecArray

=

ARRAY[0..0]

FSSpecArrayPtr

=

“FSSpecArray;

=

“FSSpecArrayPtr;

ID
or

number}

of

parent

directory

directory}
name}

END;

FSSpecArrayHandle

CatPositionRec

=

OF

FSSpec;

{catalog

position

{starting

point}

record}

RECORD

initialize:

LongInt;

priv:

ARRAY[1..6]

OF

Integer

{private

data}

Integer;

{version

number}

LongIint;

{bit

END;

GetVolParmsInfoBuffer

RECORD
vMVersion:
vMAttrib:

=

{

see

vector

of

vMAttrib

vMLocalHand:

Handle;

{handle

vMServerAdr:
vMVolumeGrade:

LongInt;
LongIint;

{network
server
{relative
speed

to

vMForeignPrivID:

Integer

{access

attributes;

}

constants}

private

privilege

data}

address}
rating}
model}

END;

VolumeType
= OSType;
VolMountInfoHeader
=

{template

{

volume

mounting

}

information}

RECORD

length:

media:

Integer;

{length

VolumeType;

{volume-specific,

25-56

=

{

variable-length

{type

variable-length

*VolMountInfoHeader;

Summary of the File Manager

mounting

including

END;

VolMountInfoPtr

of

{

information,

standard

of

volume}

private

data}

header

data}

and

}
}

The File Manager

AFPVolMountInfo

=

{AFP

volume

mounting

information}

RECORD

length:

Integer;

{length

{
{

of

mounting

media:

VolumeType;

{type

flags:

Integer;

{reserved;

must

nbpInterval:

SignedByte;

{NBP

interval}

nbpCount :
uamType:

SignedByte;
Integer;

{NBP retry count}
{user authentication

zoneNameOffset:

Integer;

{offset
{

serverNameOffset:

Integer;

Integer;

to

{

volPassWordOffset:

to

{optional

set

to

0}

method}
of

record

}

start

of

record

}

of

record

}

of

record

}

name}

from

volume

start
name}

from

user

start

name}

Integer;

{offset

of

record

}

Integer;

{ to user password}
{offset
from start
of

record

}

{
AFPData:

be

start

from

{offset

PACKED

volume-specific,

to

}

name}

server

{offset
{

userPassWordOffset:

from

zone

to

}

and

volume}

retry

{offset

Integer;

userNameOffset:

of

to

{
volNameOffset:

information,

including standard header
variable-length data}

from

volume

ARRAY[1..144]

start

password}

OF

Char;

{standard AFP mounting
variable-length data}

info}

END;
AFPVolMountInfoPtr

=

“AFPVolMountInfo;

HParmBlkPtr

=

“HParamBlockRec;

HParamBlockRec

=

RECORD
qLink:

QElemPtr;

{next

qType:
ioTrap:

Integer;
Integer;

{queue
type}
{routine
trap}

ioCmdAddr :
ioCompletion:
ioResult:

Ptr;
ProcPtr;
OSErr;

{routine address}
{completion routine}
{result code}

ioNamePtr:

StringPtr;

{pointer

ioVRefNum:

CASE

{other

Integer;

ParamBlkType

types

OF

described

in

{volume

Volume

FIDParam:

queue

{file

to

entry}

pathname}

reference

{

number,

{

reference

or

number,

working

drive

}

directory

}

number}

4
_
>
=

IV}

=

8
ID

functions

(fillerl4:

LongInt;

{filler}

ioDestNamePtr:

StringPtr;

{pointer

filler15:

Longint;

{filler}

ioDestDirID:

Longint;

{destination

fillerlé6:

Longint;

{filler}

fillerl7:

Longint;

{filler}

to

and

PBExchangeFiles}

destination
parent

filenames}

directory

Summary of the File Manager

ID}

— 25-57

Inside Macintosh,

Volume VI

ioSrceDirID:

Longint;

{source

filler18:

Integer;

{filler}

ioFileID:

Longint)

;

CSParam:

{file

parent

directory

ID)

ID}

{PBCatSearch}

(ioMatchPtr:

FSSpecArrayPtr;

{pointer

ioReqMatchCount:

LongInt;

ioActMatchCount:

LongInt;

{maximum number
of matches
{ to return}
{actual
number
of matches}

to

array

ioSearchBits:

LongInt;

{enable

ioSearchInfol:

CInfoPBPtr;

{pointer
to
{ bounds}

ioSearchinfo2:

CInfoPBPtr;

ioSearchTime:

LongInt;

{pointer to masks and upper
{ bounds}
{maximum time to search,
}
{ in Time Manager form}

ioCatPosition:

CatPositionRec;

{current

ioOptBuffer:

Ptr;

{pointer to
{ buffer}

ioOptBufSize:

Longint);

{length

bits

of

for

}

matching

values

catalog

of

matches}

and

rules}

lower

}

}

position}

optional
optional

ForeignPrivParam:
(filler21:
filler22:
ioForeignPrivBuffer:
ioForeignPrivReqCount:
ioForeignPrivActCount:
filler23:
ioForeignPrivDirID:

Longint;
Longint;
Ptr;
LongInt;
LongiInt;
Longint;
LongInt;

ioForeignPrivinfol:
ioForeignPrivinfo2:
ioForeignPrivinfo3:

Longint;
LongiInt;
Longint;

{filler}
{filler}
{privileges data}
{size of buffer}
{amount of buffer
{filler}
{parent directory
{ foreign file or
{privileges data}
{privileges data}
{privileges data}

ioForeignPrivinfod:

Longint);

{privileges

read
read

}
buffer}

used}
ID of }
directory}

data}

ioParam:
(i0RefNum:

Integer;

{path

ioVersNum:
ioPermssn:
1oMisc:
ioBuffer:
ioReqCount:

SignedByte;
SignedByte;
Ptr;
Ptr;
LongIint ;

{version number}
{read/write permission}
{miscellaneous}
{data buffer}
{requested number of bytes}

ioActCount:
ioPosMode:
LoPosOffset:

Longint;
Integer;
LongInt )

{actual
number of bytes}
{positioning
mode and newline}
{positioning
offset}

END;

Summary of the File Manager

reference

number}

The File Manager

Routines

Making

FSSpec

Records

FUNCTION

FSMakeFSSpec

(vRefNum:

Integer;

fileName:

Exchanging
FUNCTION

FSpExchangeFiles

Functions
FUNCTION

the Data in Two

Modified

(source:

(spec:
VAR

FUNCTION

FSpOpenRF

FSSpec;

FSSpec;
refNum:

(spec:

FSpCreate

LongInt;

spec:

FSSpec)

FSSpec)

:

:

OSErr;

permission:

FSSpec;

:

SignedByte;

OSErr;

permission:

Integer)

fileType:

OSErr;

Records

Integer)

FSSpec;

(spec:

dest:

FSSpec

refNum:
FUNCTION

VAR

Files

to Accept

FSpOpenDF

dirID:

Str255;

:

creator:

OSType;

SignedByte;

VAR

OSErr;
OSType;

scriptTag:

ScriptCode)

OSErr;
FUNCTION

FSpDirCreate

(spec:
VAR

FSSpec;

scriptTag:

createdDirID:

FUNCTION

FSpDelete

(spec:

FSSpec)

:

FUNCTION

FSpGetFiInfo

(spec:

FSSpec;

VAR

FUNCTION

FSpSetFInfo

(spec:

FSSpec;

fndriInfo:

FUNCTION

FSpSetFLock

(spec:

FSSpec)

:

OSErr;

FUNCTION

FSpRstFLock

(spec:

FSSpec)

:

OSErr;

FUNCTION

FSpRename

(spec:

FSSpec;

newName:

FUNCTION

FSpCatMove

(source:

Opening

a Data

FSSpec;

ScriptCode;

LongInt)

:

OSErr;

OSErr;
fndriInfo:

dest:

FInfo)

:

OSErr;

FInfo)

:

OSErr;

Str255)

:

OSErr;

FSSpec)

:

OSErr;

les)
=r
—
©
rd
i
as
=
-_
~a
~

Fork

fi

FUNCTION

HOpenDF

(vRefNum:

Integer;

dirID:

LongInt;

fileName:
Str255;
permission:
VAR refNum:
Integer)
: OSErr;
FUNCTION

OpenDF

@
“

SignedByte;

(fileName:
Str255;
vRefNum:
Integer;
VAR refNum:
Integer)
: OSErr;

Summary of the File Manager

= 25-59

Inside Macintosh,

Functions

Volume VI

New

With

HFS

FUNCTION

AllocContig

(refNum:

FUNCTION

DirCreate

Integer;
parentDirID:
(vRefNum:
directoryName:
Str255;
VAR

FUNCTION

CatMove

Integer;

VAR

createdDirID:

count:

LongInt)

Longint)

(vRefNum:

Integer;

dirID:

Stxr255;

newDirID:

Longint;

OSErr;

LongInt;
OSErr;

LongInt;

oldName:

newName:

Str255)

OSErr;

FUNCTION

OpenWD

(vRefNum:
procID:

Integer;

dirID:

LongInt;

VAR

LongInt;

wdRefNum:

Integer)

OSErr;

FUNCTION

CloseWD

(waRefNum:

FUNCTION

GetWDInfo

(waGRefNum:
Integer;
VAR vRefNum:
Integer;
VAR
dirID:
LongiInt;
VAR procID:
LongInt)
OSErr;

MFS

Functions

FUNCTION

HCreate

Integer)

OSErr;

Modified to Accommodate
(vRefNum:
Str255;

Directory IDs

Integer;

dirID:

LongInt;

fileName:

creator:

OSType;

fileType:

OSType)

OSErr;

FUNCTION

HOpen

(vRefNum:
Str255;

Integer;
dirID:
LongInt;
fileName:
permission:
SignedByte; VAR refNum:

Integer)
FUNCTION

FUNCTION

FUNCTION

FUNCTION

FUNCTION

FUNCTION

FUNCTION

HOpenRF

HDelete

HSetFLock

HRstFLock

HRename

HGetFinfo

HSetFInfo

(vRefNum:

Integer;

Str255;

permission:

Integer)

OSErr;

(vRefNum:

Integer;

Str255)

OSErr;

HGet Vol

(vRefNum:

Integer;

Str255)

OSErr;

(vRefNum:

Integer;

Str255)

OSErr;

(vRefNum:

LongInt;

SignedByte;

fileName:
VAR

refNum:

LongInt;

fileName:

dirID:

LongInt;

fileName:

dirID:

LongInt;

fileName:

dirID:
Str255)

LongInt;
OSErr;

oldName:

Str255;

Integer;
newName:

(vRefNum:
St7255°

Integer;

dirID:

LongInt;

fileName:

VAR

(vRefNum:

(volName:

GirID:

25-60

dirID:

dirID:

Stxr255's
FUNCTION

OSErr;

Summary of the File Manager

fndriInfo:

Integer;
fndrinfo:
StringPtr;

LongInt)

FInfo)

dirID:
FInfo)
VAR
OSErr;

OSErr;

LongInt;
OSErr;
vRefNum:

fileName:

Integer;

VAR

The File Manager

Reading
FUNCTION

Volume

Information

PBHGetVolParms

(paramBlock:

HParmBlkPtr;

async:

Boolean)

HParmBlkPtr;

async:

Boolean)

HParmBlkPtr;

async:

Boolean)

HParmBlkPtr;

async:

Boolean)

OSErr;

Searching

a Catalog

FUNCTION

PBCatSearch

Creating

FSSpec

FUNCTION

PBMakeFSSpec

(paramBlock:
OSErr;

Records
(paramBlock:
OSErr;

Swapping
FUNCTION

Data

Between

PBExchangeFiles

Two

Files

(paramBlock:
OSErY }

Functions for Manipulating

File IDs

FUNCTION

PBCreateFileIDRef

(paramBlock:
OSErr;

HParmBlkPtr;

async:

Boolean)

FUNCTION

PBDeleteFileIDRef

(paramBlock:

HParmBlkPtr;

async:

Boolean)

HParmBlkPtr;

async:

Boolean)

async:

Boolean)

OSErr;
FUNCTION

PBResolveFileIDRef

(paramBlock:
OSErr;

Functions
FUNCTION

Changed

PBHDelete

to Accommodate
(paramBlock:

File IDs

HParmBlkPtr;

OSErr;

FUNCTION

PBHRename

(paramBlock:
OSErr;

HParmBlkPtr;

async:

>
‘A

S

Boolean)

=
TS

FUNCTION

PBCatMove

(paramBlock:

CMovePBPtr;

async:

Boolean)

CInfoPBPtr;

async:

Boolean)

"

OSErr};
FUNCTION

PBGetCatInfo

(paramBlock:
OSErr}

Summary of the File Manager

—_ 25-61

Inside Macintosh,

Mounting

Volume VI

Volumes

FUNCTION

PBGetVolMountInfoSize

(paramBlock:

ParmBlkPtr)

:

OSErr;

FUNCTION

PBGetVolMountIinfo

(paramBlock:

ParmBlkPtr)

:

OSErr;

FUNCTION

PBVolumeMount

(paramBlock:

ParmBlkPtr)

:

OSErr;

Accessing
FUNCTION

Privilege Information

PBGetForeignPrivs

(paramBlock:

in Foreign

File Systems

HParmBlkPtr;

async:

Boolean)

HParmBlkPtr;

async:

Boolean)

OSErr;

FUNCTION

PBSetForeignPrivs

(paramBlock:
OSErr;

Opening

Data

FUNCTION

PBOpenDF

Forks
(paramBlock:

ParmBlkPtr;

async:

Boolean)

OSErr;

FUNCTION

PBHOpenDF

(paramBlock:

HParmBlkPtr;

async:

OSErr;

Result
noErr

Codes

notOpenErr
nsvErr
ioErr
bdNamErr
eofErr
tmfoErr
fnfErr
wPrErr
fLekdErr
vLcekdErr
opWrErr
paramErr
volOfflinErr
extFSErr
memFullErr
dirNFErr
wrgVolTypeErr
fidNotFoundErr
fidExists
notAFileErr
diffVolErr

25-62

0)

—28
—35
—36
—37
—39
—42
43
—44
—45
—46
—49
—50
—53
—58
—108
—120
—123
—1300
—1301
—1302
—1303

Summary of the File Manager

No error

AppleTalk is not open
Volume not found
I/O error
Bad filename
Logical end-of-file reached
Too many files open
File not found
Hardware volume lock
File locked
Software volume lock
File already open for writing
Parameter error
Volume is off line
External file system
Insufficient memory available
Directory not found
Not an HFS volume
File ID not found
File ID already exists
Specified file is a directory
Files on different volumes

Boolean)

The File Manager

catalogChangedErr

—1304

afpBadUAM
afpBadVersNum

—5002
—5003

afpNoServer
afpUserNotAuth

—5016
—5023

afpPwdExpired
afpBadDirIDType
afpCantMountMoreSrvrs
afpAlreadyMounted
afpSameNodeErr

—5042
—5060
-—5061
—5062
—5063

Assembly-Language
FSSpec

Data

not correct)

Password has expired on server
Not a fixed directory ID volume
Maximum number of volumes has been mounted
Volume already mounted
Attempt to log on to a server running on the same
machine

Information

Structure

vRefNum
parID
name

Catalog

Catalog has changed and catalog position record may
be invalid
User authentication method is unknown
Workstation is using an AFP version that the server
doesn’t recognize
Server is not responding
User authentication failed (usually, password is

2 bytes
4 bytes
64 bytes

Position

initialize
priv

Data

volume reference number

directory ID
filename

Structure

4 bytes
12 bytes

Volume

Mounting

Information

length
2 bytes
media
4 bytes
variable-length private data

AFP

Mounting

starting place for next search
private data

Information

length
2 bytes
media
4 bytes
flags
2 bytes
nbpInterval
byte
nbpCount
byte
uamType
2 bytes
zoneNameOftset
2 bytes
serverNameOffset
2 bytes
volNameOffset
2 bytes
userNameOffset
2 bytes
userPassWordOffset
2 bytes
volPassWordOffset
2 bytes
AFPData
144 bytes
variable-length private data

Data

Structure

length of record
type of volume

Data Structure

bo
ui

length of record
type of volume

=

o

reserved

2
.
=iv
ga2)

NBP retry interval
NBP retry count

—

user authentication method
offset to zone name
offset to server name
offset to volume name
offset to user name

“|

offset to user password
offset to volume password
mounting data
Summary of the File Manager

— 25-63

Inside Macintosh,

Catalog

Volume VI

Search

24
~—long
28 ~— long
32 ~— long
36 ~— long
40
long
44
long
48
long
52
16bytes
68
long
72
~—‘long

Parameter

ioMatchPtr
ioReqMatchCount
ioActMatchCount
ioSearchBits
ioSearchInfo|
ioSearchInfo2
ioSearchTime
ioCatPosition
ioOptBuffer
ioOptBufSize

File ID Parameter
24
_~—silong
28
long
32
long
36 ~— long
40
long
44
long
48
long
52
2bytes
54
long

Foreign
24
~—silong
28
long
32 ~— long
36 ~— long
40
long
44
long
48
long
52
long
56
long
60
long
64
~=—long

25-64

Block

Block

filler14
ioDestNamePtr
filler15
ioDestDirID
filler16
filler 17
ioSreDirID
fillerl8
ioFileID

Privileges

pointer to match array
maximum match count
actual match count
search criteria selector
pointer to search values and lower bounds
pointer to search values and upper bounds
time limit on search
catalog position record
pointer to optional read buffer
length of optional read buffer

Parameter

filler2 |
filler22
ioForeignPrivBuffer
ioForeignPrivReqCount
ioForeignPrivActCount
filler23
ioForeignPrivDirID
ioForeignPrivInfol
ioForeignPrivInfo2
ioForeignPrivInfo3
ioForeignPrivInfo4

Summary of the File Manager

filler
pointer to destination filename
filler
destination parent directory ID
filler
filler
parent directory ID
filler
file ID

Block
filler
filler
pointer to privileges data buffer
size allocated for buffer
amount of buffer used
filler
parent directory ID of target
privileges data
privileges data
privileges data
privileges data

The File Manager

Trap

Macros

Requiring

Routine

Selectors

_HFSDispatch
Selector

Routine

$0014

PBCreateFileIDRef

$0018
$0030

PBCatSearch
PBHGetVolParms

$0015
$0016
$0017

$003F
$0040
$004 |

$0060
$0061

PBDeleteFileIDRef
PBResolveFileIDRef
PBExchangeFiles
PBGetVolMountInfoSize
PBGetVolMountInfo
PBVolumeMount

PBGetForeignPrivs
PBSetForeignPrivs

_HighLevelFSDispatch
Selector

Routine

$0001
$0002
$0003
$0004
$0005
$0006
$0007
$0008

FSMakeFSSpec
FSpOpenDF
FSpOpenRF
FSpCreate
FSpDirCreate
FSpDelete
FSpGetFInfo
FSpSetFInfo

$000A

FSpRstFLock

$0009

$000B

$000C
$000D
$000E
$O00F

FSpSetFLock
FSpRename

FSpCatMove
FSpOpenResFile
FSpCreateResFile
FSpExchangeFiles
nN
wn

=
—
©
~<
—e

a

=

=

~
ge

©

ae

Summary of the File Manager

— 25-65

|

Inside Macintosh,

25-66

Volume VI

THE

STANDARD

FILE

PACKAGE

About This Chapter
About the Standard File Package
Using the Standard File Package
Presenting the Default Interface
Customizing Your Interface
Customized Dialog Boxes
Callback Routines
Compatibility With Earlier Procedures
Standard File Package Routines
Saving Files
Opening Files
Summary of the Standard File Package

S
a
a
S
=
=
po)
sa |
=
ae
-

o

Inside Macintosh,

26-2

Volume VI

The Standard File Package

ABOUT

THIS

CHAPTER

This chapter describes how your application can use the Standard File Package in system
software version 7.0 to present a standard user interface for naming and identifying files. The
Standard File Package displays the dialog boxes that let the user specify the names and
locations of files to be saved or opened, and it reports the user’s choices to your application.
The new procedures introduced in version 7.0 allow your application to either streamline its
interaction with the Standard File Package or exercise more control over the user interface.
This chapter supplements the Standard File Package chapters in Volumes I and IV.
Read this chapter if your application lets the user save and open files.
The features described in this chapter are available only in system software version 7.0 or
later. Call the Gestalt function, described in the Compatibility Guidelines chapter of this
volume, to determine whether the new features are present.
To use this chapter you must be familiar with earlier versions of the Standard File Package,
described in Volumes I and IV; the Dialog Manager, described in Volume I; the file system
specification (FSSpec) record, described in the File Manager chapter of this volume; and the

new features of the version 7.0 Finder™, described in the Finder Interface chapter of this
volume.

ABOUT

THE

STANDARD

FILE

PACKAGE

The Standard File Package handles the interface between the user and your application when
the user saves or opens a document. It displays dialog boxes through which the user
specifies the name and location of the document to be saved or opened. It allows your application to customize the dialog boxes and, through callback routines, to handle user actions
during the dialogs. The Standard File Package procedures describe the user’s choices through
a reply record.
The Standard File Package in version 7.0 introduces
m a pair of simplified procedures that you call to display and handle the standard Open
and Save dialog boxes
m a pair of customizable procedures that you call when you need more control over
the interaction
m anew reply record (StandardFileReply) that identifies files and folders with a file
system specification record and that accommodates the new Finder features

to
a
”,
ss
=|
3
fs
a,
a.

m= anew layout for the default dialog boxes

)

o

About the Standard File Package

26-3

Inside Macintosh,

Volume VI

USING

STANDARD

THE

FILE

PACKAGE

You use the Standard File Package to handle the user interface when the user must specify a
file to be saved or opened. You typically call the Standard File Package after the user chooses
Save, Save As, or Open from the File menu.
When saving a document, you call one of the “PutFile” procedures; when opening a
document, you call one of the “GetFile” procedures. The Standard File Package in
version 7.0 introduces two new pairs of procedures:
mw StandardPutFile and StandardGetFile, for presenting the standard interface
a

CustomPutFile and CustomGetFile, for presenting a customized interface

The next section illustrates the standard file dialog boxes.
Before calling any of the new Standard File Package procedures, verify that they are available
by calling the Gestalt function with a selector of gestaltStandardFileAttr. If Gestalt sets the
gestaltStandardFile58 bit in the reply, the four new procedures are available. For a complete
description of the Gestalt function, see the Compatibility Guidelines chapter of this volume.
All the new procedures return the results of the dialog boxes in a new reply record,
StandardFileReply.
TYPE

StandardFileReply

=

RECORD
sfGood:

Boolean;

{user

sfReplacing:
sfType:

Boolean;
OSType;

{replace file
{file type}

sfFile:

FSSpec;

{selected

sfScript:

ScriptCode;

{script
{

did

not

cancel}

with

file,

of

volume

same

folder,

file,

folder,

name}
or

volume}

or

}

name}

sfFlags:

Integer;

{Finder

sfisFolder:

Boolean;

{selected

flags}
item

is

a

folder}

sfIsVolume:

Boolean;

{selected

item

is

a

volume}

sfReservedl1:
sfReserved2:

Longint;
Integer

{reserved}
{reserved}

END;

The reply record identifies selected files with a file system specification (FSSpec) record.
You can pass the FSSpec record directly to a set of new File Manager functions provided
with version 7.0. The reply record also contains additional fields that support the Finder
features introduced in system software version 7.0.
The sfGood field reports whether the reply record is valid. The value is TRUE after
the user clicks Save or Open, FALSE after the user clicks Cancel. When the user has
completed the dialog box, the other fields in the reply record are valid only if sfGood

is TRUE.

26-4

Using the Standard File Package

The Standard File Package

The sfReplacing field reports whether a file to be saved replaces an existing file of the same
name. This field is valid only after a call to the StandardPutFile or CustomPutFile procedure.
When the user assigns a name that duplicates that of an existing file, the Standard File Package
asks for verification by displaying a subsidiary dialog box (illustrated in Figure 26-4). If the
user verifies the name, the Standard File Package sets the sfReplacing field to TRUE and
returns to your application; if the user cancels the overwriting of the file, the Standard File
Package returns to the main dialog box. If the name does not conflict with an existing name,
the Standard File Package sets the field to FALSE and returns. Your application can rely on
the value of this field instead of checking for and handling name conflicts itself.
The sfType field contains the file type of the selected file. (File types are described in the
Finder Interface chapter of this volume.) Only StandardGetFile and CustomGetFile return a
file type in this field.
The sfFile field describes the selected file, folder, or volume with a file system specification
record, which contains a volume reference number, parent directory ID, and name. (See the
File Manager chapter of this volume for a complete description of the file system specification record.) If the selected item is an alias for another item, the Standard File Package
resolves the alias and places the file system specification record for the target in the sfFile
field when the user completes the dialog. If the selected file is a stationery pad, the reply
record describes the file itself, not a copy of the file.
The sfScript field identifies the script in which the name of the document is to be displayed.
(This information is used by the Finder and by the Standard File Package. See the Script
Manager section of the Worldwide Software Overview chapter in this volume for a list
of defined script codes.) A script code of smSystemScript (—1) represents the default
system script.
The sfFlags field contains the Finder flags from the Finder information record in the catalog
entry for the selected file. (See the Finder Interface chapter in this volume for a description of
the Finder flags.) This field is returned only by StandardGetFile and CustomGetFile. If your
application supports stationery, it should check the stationery bit in the Finder flags to
determine whether to treat the selected file as stationery. Unlike the Finder, the Standard File
Package does not automatically create a document from a stationery pad and pass your
application the new document. If the user opens a stationery document from within an
application that does not support stationery, the Standard File Package displays a dialog box
warning the user that the master copy is being opened.
The sflsFolder field reports whether the selected item is a folder (TRUE) or a file or
volume (FALSE).

The sflsVolume field reports whether the selected item is a volume (TRUE) or a file or
folder (FALSE).

Presenting

the

Default

Interface

nN
2.

If your application has no special interface requirements, you can use the StandardGetFile
and StandardPutFile procedures to display the default dialog boxes for opening and saving
documents.

NM
a

=)
=
joe
iy
ac}

2.

ee
o

Using the Standard File Package

26-5

Inside Macintosh,

Volume VI

The version 7.0 Standard File Package introduces a number of user interface enhancements,
most of which have no effect on your application. Most noticeably, the version 7.0 standard
file dialog boxes use a slightly different point of view. Instead of displaying only one volume
at a time and showing the root of that volume at the top of the hierarchy, the file list now
displays all mounted volumes and shows the desktop as the top level of the hierarchy. The
Drive button, which previously allowed users to move among all mounted volumes, is now
the Desktop button, which returns the display to the top of the hierarchy.
You use the StandardGetFile procedure when you want to let the user choose a file to be
opened. Figure 26-1 illustrates a sample dialog box displayed by StandardGetFile.
| Gi Desktop w]

= Loma Prieta

San Benito

DC October sales
DC Septembersales

|

foo
Cancel

ih

@! Trash

i

rt

Open

Figure 26-1. The default Open dialog box
When you call StandardGetFile, you can supply a list of the file types that your application
can open. StandardGetFile then displays only files of the specified types. You can also
supply your own filter function to determine which files are displayed. (See “Opening Files”
later in this chapter for details.)
When the user is opening a document, StandardGetFile interprets keystrokes as selectors in
the displayed list. Pressing A, for example, selects the first item in the list that starts with the
letter a (or, if no items in the list start with the letter a, the item that starts with the letter

closest to a). The Standard File Package sets a timer on keystrokes: keystrokes in rapid
succession form a string; keystrokes spaced in time are processed separately.
When the user is saving a document, StandardPutFile can direct keystrokes to either of two
targets: the filename field or the displayed list. When the dialog box first appears, keystrokes
are directed to the filename field. If the user presses the Tab key or clicks to select an item in
the displayed list, subsequent keystrokes are interpreted as selectors in the displayed list. Each
time the user presses the Tab key, keyboard input shifts between the two targets. (The list at
the end of this section describes all keystrokes that affect the standard file dialog boxes.)
When the user is saving a file, the new Save dialog box offers the option of creating a new
folder, as illustrated in Figure 26-2.

26-6

Using the Standard File Package

The Standard File Package

[<> Loma PrietaY|

<= Loma Prieta

i} datepreliminar gy

Lieet

Diane’s folder
Edition Folder
Laine’s tests
Lori’s stuff
Lucas’s art

Save

this document

as:

| October sales

|

|

save

—
—

©
©
(5
©
©

Figure 26-2. The default Save dialog box
When the user clicks the New Folder button, the Standard File Package presents a subsidiary
dialog box like the example in Figure 26-3.
|< Loma PrietaY |

= Loma Prieta

O dgtea.pretiminarty
© Diane’s folder
© Edition Folder

ty
Name

of new

©
©

[Sales

Eeparss

Laine’s tests
Lori’s stuff

© Lucas’s art
Save

this document

| October

(rinses)
folder:
|

(create: )

as:

sales

(

Figure 26-3. The New

Se

}

Folder dialog box

If the user asks to save a file with a name that already exists at the specified location, the
Standard File Package displays a subsidiary dialog box to verify that the new file should
replace the existing file, as illustrated in Figure 26-4.

Replace
sales”

existing

“October

?

Figure 26-4. The name conflict dialog box

nN
“N
MN
_
es)
|
a.
+e)

=

Le sy

oO

Using the Standard File Package

26-7

Inside Macintosh,

Volume VI

The StandardGetFile and StandardPutFile procedures always display the new dialog boxes.
The procedures available before version 7.0 (SFGetFile, SFPutFile, SFPGetFile, and
SFPPutFile) also display the new dialog boxes when running in version 7.0, unless the
application has customized the dialog box. For more details on how the version 7.0 Standard
File Package handles earlier procedures, see “Compatibility With Earlier Procedures” later in
this chapter.
StandardGetFile and StandardPutFile fill in the reply record and return when the user
completes the dialog box—either by selecting a file and clicking Save or Open, or by clicking
Cancel. Your application checks the values in the reply record to see what action to take, if
any. If the selected item is an alias for another item, the reply record describes the target of
the alias. (See the Finder Interface chapter of this volume for a description of aliases.)

You can pass file descriptions directly from the Standard File Package to the File Manager.

The new reply record identifies files with file system specification records, which are
recognized by a new set of high-level File Manager functions. (See the File Manager chapter
of this volume for a description of the new File Manager functions that use file system
specification records.)
Listing 26-1 illustrates how an application calls first the Standard File Package and then the
File Manager after the user chooses Open from the File menu.
Listing 26-1.

Opening

a document

VAR
mySFR:

StandardFileReply;

{reply

myTypeList:

SFTypeList;

{list

fsOpenErr:

OSErr;

{error

returned

by

fsRefNum:

Integer;

{path

reference

number,

{

record}

of

types

by

open

{set

up

to

display}
open

function}
to

be

set

function}

BEGIN
myTypeList[0]

:=

'MDOC';

myTypeList[1]

:=

'YDOC';

StandardGetFile(NIL,

2,

myTypeList,

type

mySFR);

{display
IF mySFR.sfGood
BEGIN
fsOpenErr

:=

=

TRUE

THEN

{user

{open

(fsopenErr)

document

;

through

END;

Using the Standard File Package

box}

Open}

fsCurPerm,
the

{routine
reference

END;

26-8

dialog

clicks

FSpOpenDF(mySFR.sfFile,
{open

LetMeCheck

list}

number

fsRefNum) ;

file}
to

check

returned

errors}
by

FSpOpenDF}

}

The Standard File Package

The Standard File Package now recognizes a longer list of keyboard equivalents during dialogs.
Keystrokes

Action

Up Arrow

Command-Shift-1
Command-Shift-2
Tab
Return or Enter

Scroll up (backward) through displayed list
Scroll down (forward) through displayed list
Display contents of parent
Display contents of selected directory or
volume
Display contents of previous volume
Display contents of next volume
Display contents of desktop
Eject disk in drive |
Eject disk in drive 2
Move to next keyboard target
Invoke the default option for the dialog box

Escape or Command-.
Command-O
Command-D
Command-N
Option-Command-O
or Option-[click Open]

Cancel
Open the selected item
Display contents of desktop
Create a new folder
Select the target of the selected alias item instead
of opening it

Down Arrow

Command—Up Arrow
Command—Down

Arrow

Command—Left Arrow

Command-Right Arrow
Command-Shift-Up Arrow

(Open or Save)

When the user selects a button in the dialog box using a keyboard equivalent, the
button flashes.

Customizing

Your

Interface

If your application requires it, you can customize the user interface for identifying files.
Note: Alter the dialog boxes only if necessary. Apple Computer, Inc., does not
guarantee future compatibility if you use a customized dialog box.
To customize a dialog box, you should
m design your display and create the resources that describe it
m write callback routines, if necessary, to process user actions in the dialog box
m

call the Standard File Package using the CustomPutFile and CustomGetFile procedures,

passing the resource IDs of the customized dialog boxes and pointers to the callback
routines

nN
“N

io— 2)

Whether or not you change the dialog box display, you can write your own dialog hook
callback function to handle user actions in the dialog box.

ps)
>
ou.
oo
se

a

)

Oo

Using the Standard File Package

26-9

Inside Macintosh,

Volume VI

Customized

Dialog

Boxes

To describe a dialog box, you must supply a'DLOG' resource that defines the box itself and
a 'DITL' resource that defines the items in the dialog box.
Listing 26-2 shows the resource definition of the default Open dialog box, in Rez input
format. (Rez is the resource compiler provided with Apple’s Macintosh Programmer’ s
Workshop [MPW®]. For a description of Rez format, see the manual that accompanies the
MPW software, MPW: Macintosh Programmer’s Development Environment.)
Listing 26-2. The definition of the default Open dialog box
resource

{

'DLOG'

{0,

0,

166,

-6042,

"",

(-6042,

purgeable)

344},

dBoxProc,

invisible,

noGoAway,

0,

noAutoCenter

};3

Listing 26-3 shows the resource definition of the default Save dialog box, in Rez input format.
Listing 26-3. The definition of the default Save dialog box
resource

'DLOG'

(-6043,

purgeable)

344},

dBoxProc,

{
{0,

0,

188,

-6043,

"",

invisible,

noGoAway,

0,

noAutoCenter

yy

The default Standard File Package dialog boxes now support color. The System file contains
‘dctb' resources with the same resource IDs as the default dialog boxes, so that the Dialog
Manager uses color grafPorts for the default dialog boxes. (See the Dialog Manager chapter
of Volume V for a description of the 'dctb' resource.) If you create your own dialog boxes,
include ‘dctb' resources.
You must provide an item list (in a 'DITL' resource with the ID specified in the 'DLOG'
resource) for each dialog box you define. Add new items to the end of the default lists.
CustomGetFile expects the first nine items in a customized dialog box to have the same
functions as the corresponding items in the StandardGetFile dialog box; CustomPutFile
expects the first twelve items to have the same functions as the corresponding items in

the StandardPutFile dialog box. If you want to eliminate one of the standard items from
the display, leave it in the item list but place its coordinates outside the bounds of the

dialog box rectangle.

Listing 26-4 shows the dialog item list for the default Open dialog box, in Rez input format.
The constant statements in the next section, “Callback Routines,” list which elements the
items represent in the dialog boxes.
Listing 26-5 shows the dialog item list for the default Save dialog box, in Rez input format.

26-10

—_ Using the Standard File Package

The Standard File Package

Listing 26-4. The item list for the default Open dialog box
resource

£

'DITL'

(-6042)

{135,

252,

155,

332},

Button

{

enabled,

"Open"

{104,

252,

124,

332},

Button

{

enabled,

"Cancel"

a

{0,

0,

0,

{8,

235,

0},

HelpItem

24,

337},

{

disabled,

UserItem

{

132,

252,

D2,

332},

Button

{

{60,
{29,

252,
80,
12,
159,

332},
230},

Button
{
UserItem

},

HMScanhdlg

enabled

},

{-6042}},

},

enabled,

"Ejyect”

},

enabled,
"Desktop"
{ enabled
},

{6, 12, 25, 230}, UserItem {
{91, 251,
92, 333},
Picture
Pie

enabled },
{ disabled,

11

},

},

Listing 26-5. The item list for the default Save dialog box
resource

i.

'DITL'

(-6043)

{161,

252,

181,

332},

Button

{

enabled,

"Save"

{130,

252,

150,

332},

Button

{

enabled,

"Cancel"

&

{0,

0,

0,

{8,

235,

0},

HelpItem

24,

337},

{

disabled,

UserItem

{

{32,

252,

52,

332},

Button

{60,
{29,

252,
80,
12,
127,

332},
230},

Button
{
UserItem

{6,

12,

25,

{119,

250,

{i57,

2S,

230},

120,

UserItem

334},

173,

227},

{

{

},

HMScanhdlg

enabled

},

enabled,

"Eject"

},

enabled,
"Desktop"
{ enabled
},
enabled

{

disabled,

11

BditText

{

enabled,

"*

{

disabled

15,

152,

227},

StaticText

{88,

252,

108,

332},

UserItem

{

},

},

Picture

{136,

},

{-6043}},

disabled,

},
},

"Save

as:"

},

},

se

The third item in each list (HelpItem) supplies Apple’s Balloon Help™ ™ for items in the dialog
box. HelpItem specifies the resource ID of the 'hdlg' resource that contains the help strings
for the standard dialog items. To provide Balloon Help for your own items, supply a second
‘hdlg' resource and reference it with another help item at the end of the list. For more
information about Balloon Help, see the Help Manager chapter of this volume.

Callback

Routines

You can supply callback routines that control these elements of the user interface:
m determining which files the user can open

nN

>)
M
en

w handling user actions in the dialog boxes

a
im)

=

m handling user events received from the Event Manager

~

sor |

a

w highlighting the display when keyboard input is directed at a customized field defined by
your application
Using the Standard File Package

26-11

—

=

o

Inside Macintosh,

Volume VI

You can also supply data of your own to be passed into the callback routines through a new
parameter, yourDataPtr, that you can pass to CustomGetFile and CustomPutFile.
A file filter function determines which files appear in the display list when the user is
opening a file. Both StandardGetFile and CustomGetFile recognize file filter functions,
which are described in the Standard File Package chapter in Volume I.
When the Standard File Package is displaying the contents of a volume or folder, it checks
the file type of each file and filters out files whose types do not match your application’s
specifications. (Your application can specify which file types are to be displayed through
the typeList parameter to either StandardGetFile or CustomGetFile, as described in “Opening
Files” later in this chapter.) If your application also supplies a file filter function, the
Standard File Package calls that function each time it identifies a file of an acceptable type.
The file filter function receives a pointer to the file’s catalog information record (described in
the File Manager chapter of Volume IV). It evaluates the catalog entry and returns a Boolean
value that determines whether the file is filtered (that is, a value of TRUE suppresses display
of the filename, and a value of FALSE allows the display). If you do not supply a file filter
function, the Standard File Package displays all files of the specified types.
A file filter function to be called by StandardGetFile must use this syntax:
FUNCTION

MyStandardFileFilter

(pb:

CInfoPBPtr)

:

Boolean;

When your file filter function is called by CustomGetFile, it can also receive a pointer to any
data that you passed in through the call to CustomGetFile. A file filter function to be called by
CustomGetFile must use this syntax:
FUNCTION

MyCustomFileFilter

(pb:

CInfoPBPtr;

myDataPtr:

Ptr)

:

Boolean;

A dialog hook function handles item hits in the dialog box. It receives a dialog record and
an item number from the ModalDialog procedure via the Standard File Package each time the
user causes a hit on one of the dialog items. Your dialog hook function checks the item
number of each item hit, and then either handles the hit or passes it back to the Standard File
Package. (The dialog hook function is described in the Standard File Package chapters in
Volumes I and IV.)

If you provide a dialog hook function, CustomPutFile and CustomGetFile call your function
immediately after calling ModalDialog. They pass your function the item number returned by
ModalDialog, a pointer to the dialog record, and a pointer to the data received from your
application, if any. The dialog hook function must use this syntax:
FUNCTION

MyDlgHook

(item:

Integer;

theDialog:

DialogPtr;

myDataPtr:

Ptr)

Integer;

Your dialog hook function returns an item number or the sfHookNullItem constant as its
function result. If it returns one of the item numbers in the following list of constants, the
Standard File Package handles the item hit as described. If your dialog hook function does
not handle an item hit, it should pass the item number back to the Standard File Package for
processing by setting its return value equal to the item number.

26-12

Using the Standard File Package

The Standard File Package

MyDlgHook

:=

item;

When your application handles the item hit, it should return the sfHookNullEvent constant.
When the Standard File Package receives either sfHookNullEvent or an item number that it
doesn’t recognize from a dialog hook function, it does nothing.
The Standard File Package recognizes these item numbers:
boxes}
Ls
7

BW

=

™.

=

sfItemVolumeUser
sfItemEjectButton

™

il

sfItemDesktopButton

nDU

il

sfiItemBalloonHelp

™*

=

ND

dialog

i

sfItemFileListUser

™*

in

s

items

sfItemOpenButton
sfItemCancelButton

OA

{default

i

CONST

~*

sfItemPopUpMenuUser

{items

that

appear

in

“ee

Wo

sfItemDividerLinePict

{Save or Open button}
{Cancel
button}
{Balloon

Help}

{volume

icon

{Eject

button}

and

{Desktop

button}

{display

list}

name}

{directory

pop-up

{dividing

line

Save

dialog

sfItemFileNameTextEdit

=

10;

boxes only}
{filename field}

sfItemPromptStaticText

=

Lis

{filename

sfltemNewFolderUser

=

12;

{New

menu}

between

prompt

Folder

buttons}

text

area}

button}

{pseudo-items available prior to
sfHookFirstCall
=
-1;
sfHookCharOffset
=. $1000

{initialize
{offset for

sfHookNullEvent

—

100;

{null

sfHookRebuildList

=

101;

{redisplay

sfHookFolderPopUp

=

102;

{display

parent-directory

sfHookOpenFolder

=

103;

{display

contents

{

folder

or

with

version

7.0}

up

display}

{additional

pseudo-items

version

available

7.0}

{clean

—

-2;

sfHookOpenAlias
sfHookGoToDesktop
sfHookGoToAliasTarget

=
—
=

104;
LOS?
106;

{resolve

=

input}

event}

sfHookLastCall

sfHookGoToParent

display}
character

{display
{select

list}

after

}

alias}
contents
target

of

L073

{display

contents

=

108;

{display

contents

sfHookGoToPrevDrive

=

109;

sfHookChangeSelection
sfHookSetActiveOffset

=
=

110;
200;

contents

{ previous
drive}
{select
target
of

{switch

selected

volume}

sfHookGoToNextDrive

{display

of

menu}

active

of

desktop}

alias}
of

parent}

of

}

of

next

reply

drive}

record}

item}

You must write your own dialog hook function to handle any items you have added to the
dialog box.
The Standard File Package uses a set of modal-dialog filter functions (described later in this
section) to map user actions during the dialog onto the defined item numbers. Some of the

bo
nN
2
PN
—
es
—
=&.
pS)
$
o2.
oe
ss

—

es) 3|
=
it
&

Using the Standard File Package

26-13

Inside Macintosh,

Volume VI

mapping is indirect. A click on the Open button, for example, is mapped to sfItemOpenButton
only if a file is selected in the display list. If a folder or volume is selected, the Standard File
Package maps the hit onto the pseudo-item sfHookOpenFolder.
The lists that follow summarize when various items are generated and how they are handled.
The lists describe the simplest mouse action that generates each item; many of the items can
also be generated by keyboard actions, as described earlier in “Presenting the Default
Interface.”
The first twelve defined constants represent the items in the Save and Open dialog boxes. The
constants that represent disabled items (sfltemBalloonHelp, sfItemDividerLinePict, and
sfltemPromptStaticText) have no effect, but they are defined in the header files for the sake of
completeness. Except under extraordinary circumstances, your dialog hook function always
passes any of the first twelve item numbers back to the Standard File Package for processing.
Constant

Cause

Effect

sfltemOpenButton

The user clicks Open or Save
while a filename is selected.

The Standard File Package
fills in the reply record
(setting sfGood to TRUE),
removes the dialog box, and
returns.

sfltemCancelButton

The user clicks Cancel.

The Standard File Package
sets sfGood to FALSE,
removes the dialog box, and
returns.

sfltemVolumeUser

The user clicks the volume icon
or its name.

The Standard File Package
rebuilds the display list to
show the contents of the
folder that is one level up the
hierarchy (that is, the parent
directory of the current
parent directory).

sfIltemEjectButton

The user clicks Eject.

The Standard File Package
ejects the volume that is
currently selected.

sfltemDesktopButton

The user clicks the Drive button
in a customized dialog box
defined by one of the earlier
procedures. You never receive
this item number with the new
procedures; when the user clicks
the Desktop button, the action
is mapped to the item
sfHookGoToDesktop, described
in a list later in this section.

The Standard File Package
displays the contents of the
next drive.

26-14

Using the Standard File Package

The Standard File Package

Constant

Cause

Effect

sfltemFileListUser

The user clicks an item in the
display list. The Standard File
Package updates the selection
and generates this item for
your information.

No action.

sfltemPopUpMenuUser

Never generated. The Standard
File Package’s modal-dialog
filter function maps clicks on the
directory pop-up menu to
sfHookFolderPopUp, described
in a list later in this section.

No action.

sfltemFileNameTextEdit

The user clicks in the filename
field. TextEdit and the Standard
File Package process mouse
clicks in the filename field, but
the item number is generated for
your information.

No action.

sfltemNewFolderUser

The user clicks New Folder.

The Standard File Package
displays the New Folder
dialog box.

The pseudo-items are messages that allow your application and the Standard File Package to
communicate and support various features added since the original design of the Standard
File Package.
The Standard File Package generates three pseudo-items that give your application the chance
to control a customized display.
Constant

Cause

Response

sfHookFirstCall

The Standard File Package
generates this item as a signal to
your dialog hook function that it
is about to display a dialog box.

If you want to initialize the
display, do it when you
receive this item. You can
specify where in the file
system the dialog box should
open either by returning
sfHookGoToDesktop or by
changing the reply record
and returning
sfHookChangeSelection.

sfHookLastCall

The Standard File Package
generates this item number as
a signal to your dialog hook
function that it is about to
remove a dialog box.

If you created any structures
when the dialog box was
first displayed, remove them
when you receive this item.

Using the Standard File Package

26-15

nN
=

2)
AY

a

-_~
ve

—_
loan!

Lr

—

a

gr |

Q

Le wyy
ome
—
fae]

Inside Macintosh,

Volume VI

Constant

Cause

Response

sfHookNullEvent

The Standard File Package
issues this null item periodically
if no user action has taken place.

Your application can use this
event to perform any
updating or periodic
processing that might be
necessary.

Your application can generate three pseudo-items to request services from the Standard File
Package.
Constant

Cause

sfHookRebuildList

Your dialog hook function
The Standard File Package
returns this item to the Standard — rebuilds and displays the list
File Package when itneeds to __ of files that can be opened.
redisplay the file list. Your
application might need to
redisplay the list if, for example,
it allows the user to change the
file types to be displayed.

sfHookChangeSelection

Your application returns this
value to the Standard File
Package after changing the reply
record so that it describes a
different file or folder.

sfHookSetActiveOffset

| Your application adds this

constant to an item number and
sends the result to the Standard
File Package.

Effect

The Standard File Package
rebuilds the display list to
show the contents of the
folder or volume containing
the object described in the
reply record. It selects the
item described in the reply
record.

The Standard File Package
activates that item in the
dialog box, making it the
target of keyboard input.
This constant allows your
application to activate a
specific field in the dialog
box without explicit input
from the user.

The Standard File Package’s own modal-dialog filter functions generate a number of pseudoitems that allow its dialog hook functions to support various features introduced since the
original design of the standard file dialog boxes. Except under extraordinary circumstances,
your dialog hook function always passes any of these item numbers back to the Standard File
Package for processing.

26-16

— Using the Standard File Package

The Standard File Package
Constant

Cause

sfHookCharOffset

The Standard File Package adds The Standard File Package
this constant to the value of an —_ uses the decoded ASCII
ASCII character when it’s using character to select an entry in
keyboard input for item
the display list.
selection.

sfHookFolderPopUp

The user clicks the directory
pop-up menu.

The Standard File Package
displays the pop-up menu
showing all parent
directories.

sfHookOpenFolder

The user clicks the Open button
while a folder or volume is
selected in the display list.

The Standard File Package
rebuilds the display list to
show the contents of the

The Standard File Package
generates this item number asa __
signal that the selected item is an
alias for another file, folder, or
volume.

If the selected item is an
alias for a file, the Standard
File Package resolves the
alias, places the file system
specification record of the
target in the reply record,
and returns.

sfHookOpenAlias

Effect

folder or volume.

If the selected item is an
alias for a folder or volume,

the Standard File Package

resolves the alias and

rebuilds the display list to
show the contents of the

alias target.
sfHookGoToDesktop

The user clicks the Desktop
button.

The Standard File Package
displays the contents of the
desktop in the display list.

sfHookGoToAliasTarget

The user presses the Option key
while opening an item that is an
alias.

The Standard File Package
rebuilds the display list to
display the volume or folder
containing the alias target
and selects the target.

sfHookGoToParent

The user presses Command—Up
Arrow.

The Standard File Package
rebuilds the display list to
show the contents of the
folder that is one level up the
hierarchy (that is, the parent
directory of the current
parent directory).

tnt
co 9)

2)
—
+)
~

fe
=
.

ea
o

Using the Standard File Package

26-17

Inside Macintosh,

Volume

VI

Constant

Cause

Effect

sfHookGoToNextDrive

The user presses Command—
Right Arrow.

The Standard File Package
displays the contents of the
next volume.

sfHookGoToPrevDrive

The user presses Command—
Left Arrow.

The Standard File Package
displays the contents of the
previous volume.

The CustomGetFile and CustomPutFile procedures call your dialog hook function for item
hits in both the main dialog box and any subsidiary dialog boxes (such as the dialog box
for naming a new folder while saving a document through CustomPutFile). To determine
whether the dialog record describes the main dialog box or a subsidiary dialog box, check
the value of the refCon field in the window record in the dialog record.
Note: Prior to system software version 7.0, the Standard File Package did not call
your dialog hook function during subsidiary dialog boxes. Dialog hook functions for
the new CustomGetFile and CustomPutFile procedures must check the refCon field
to determine the target of the dialog record.
The defined values for the refCon field represent the standard file dialog boxes.
Constant

Value

Dialog

box

sfMainDialogRefCon

'stdf"

Main dialog box, either Open or Save

sf{NewFolderDialogRefCon — 'nfdr'

New Folder dialog box

sfReplaceDialogRefCon

Verification for replacing a file of the

'rple'

Same

name

sfStatWarnDialogRefCon

‘stat’

Warning that the user is opening the
master copy of a stationery pad, not a
piece of stationery

sfErrorDialogRefCon

ext '

Report of a general error

sfLockWarnDialogRefCon

— 'lock'

Warning that the user is opening a locked file
and won’t be able to save any changes

A modal-dialog filter function controls events closer to their source by filtering the
events received from the Event Manager. The modal-dialog filter function is described in the
Dialog Manager chapter of Volume I. The Standard File Package itself contains a modaldialog filter function that maps keypresses and other user input onto the equivalent dialog box
item hits. If you want to process events yourself, you can supply your own filter function.

26-18

— Using the Standard File Package

The Standard File Package

Your modal-dialog filter function determines how the Dialog Manager procedure ModalDialog
filters events when called by the CustomGetFile and CustomPutFile procedures. (Those procedures retrieve item hits by calling ModalDialog.) ModalDialog retrieves events by calling
the Event Manager function GetNextEvent. If you provide a modal-dialog filter function,
ModalDialog calls your filter function before processing an event and passes it a pointer to
the dialog record, a pointer to the event record, the item number, and a pointer to the data
received from your application, if any.
FUNCTION

MyModalFilter

(theDialog:
VAR

DialogPtr;

itemHit:

Integer;

VAR

theEvent:

myDataPtr:

EventRecord;

Ptr)

:

Boolean;

Your modal-dialog filter function returns a Boolean value that reports whether it handled the
event. If your function returns a value of FALSE, ModalDialog processes the event through
its own filters. If your function returns a value of TRUE, ModalDialog returns with no
further action.
This function is the same as the modal-dialog filter function passed directly to ModalDialog
(described in the Dialog Manager chapter of Volume I), with the addition of the optional
pointer to your own data.
The CustomGetFile and CustomPutFile procedures call your filter function to process events
in both the main dialog box and any subsidiary dialog boxes (such as the dialog box for
naming a new folder while saving a document through CustomPutFile). To determine whether
the dialog record describes the main dialog box or a subsidiary dialog box, check the value of
the refCon field in the window record in the dialog record, as described earlier in the description of dialog hook functions.
The activation procedure controls the highlighting of dialog items that are defined by your
application and can receive keyboard input. Ordinarily, you need to supply an activation
procedure only if your application builds a list from which the user can select entries. The
Standard File Package supplies the activation procedure for the file display list and for all
TextEdit fields. You can also use the activation procedure to keep track of which field is
receiving keyboard input, if your application needs that information.
The target of keyboard input is called the active field. The two standard keyboard-input
fields are the filename field (present only in Save dialog boxes) and the display list. Unless
you override it through your own dialog hook function, the Standard File Package handles
the highlighting of its own items and TextEdit fields. When the user changes the keyboard
target by pressing the mouse button or the Tab key, the Standard File Package calls your
activation procedure twice: the first call specifies which field is being deactivated, and the
second specifies which field is being activated. Your application is responsible for removing
the highlighting when one of its fields becomes inactive and for adding the highlighting
when one of its fields becomes active. The Standard File Package can handle the highlighting
of all TextEdit fields, even those defined by your application.
The activation procedure receives four parameters: a dialog pointer, a dialog item number, a
Boolean that specifies whether the field is being activated (TRUE) or deactivated (FALSE),

and a pointer to your own data.

nN
nN
2

—
Sy

=

a

pt)
-~

PROCEDURE

MyActivateProc

(theDialog:

DialogPtr;

itemNo:

Integer;

activating:

Boolean;

myDataPtr:

Ptr);

Using the Standard File Package

=

=
o

26-19

Inside Macintosh,

Volume VI

Compatibility

With

Earlier Procedures

The Standard File Package still recognizes all procedures available before version 7.0

(SFGetFile, SFPutFile, SFPGetFile, and SFPPutFile). It displays the new interface for all

applications that use the default dialog boxes (that is, applications that specify both the dialog
hook and the modal-dialog filter pointers as NIL and that specify no alternative dialog ID).
When the Standard File Package can’t use the new interface because an application
customized the dialog box with the earlier procedures, it nevertheless makes some changes to
the display:
a

It changes the label of the Drive button to Desktop and makes the desktop the root of the
display.

a It moves the volume icon slightly to the right, to make room for selection highlighting
around the display list field.
If, however, a customized dialog box has suppressed the file display list (by specifying coordinates outside of the dialog box), the Standard File Package uses the earlier interface,
on the assumption that the dialog box is designed for volume selection.

STANDARD

FILE

PACKAGE

ROUTINES

This section describes the new routines in version 7.0 of the Standard File Package. The
StandardPutFile and StandardGetFile procedures are simplified versions of the original procedures for handling the user interface when storing and retrieving files. The CustomPutFile
and CustomGetFile procedures are customizable versions of the same procedures.
The callback routines in the new custom procedures all take an additional parameter not
available in earlier versions of the Standard File Package. The new parameter is an optional
pointer to data set up by your application and passed into the calling procedure in the
yourDataPtr parameter.

Saving

Files

Use the StandardPutFile procedure to display the default Save dialog box when the user is
saving a file.
PROCEDURE

StandardPutFile

(prompt:
VAR

Str255;

reply:

defaultName:

Str255;

StandardFileReply) ;

StandardPutFile presents a dialog box through which the user specifies the name and location
of a file to be written to. During the dialog, StandardPutFile gets and handles events until the
user completes the interaction, either by selecting a name and authorizing the save or by
canceling the save. StandardPutFile returns the user’s input in a standard file reply record,
described earlier in “Using the Standard File Package.”

26-20

= Standard File Package Routines

The Standard File Package

The prompt parameter specifies the prompt message to be displayed over the text field.

The defaultName parameter contains the initial name of the file, if any.
The reply parameter is the reply record, which StandardPutFile fills in before returning.
pi the CustomPutFile procedure when your application requires more control over the Save
ialog box.
PROCEDURE

CustomPutFile

(prompt:

Str255;

defaultName:

Str255;

VAR reply:
StandardFileReply;
dlgID:
Integer;
where:
Point;
dlgHook:
DlgHookYDProcPtr;
filterProc:

ModalFilterYDProcPtr;

activeList:
Ptr;
activateProc:
ActivateYDProcPtr;
yourDataPtr:

UNIV

Ptr);

CustomPutFile is an alternative to StandardPutFile when you want to display a customized
Save dialog box or handle the default dialog box in a customized way.
The first three parameters are identical to the parameters of StandardPutFile. The prompt
parameter specifies the prompt message to be displayed over the text field. The defaultName
parameter contains the initial name of the file, if any. The reply parameter is the reply record,
which StandardPutFile fills in before returning.
The dlgID parameter is the resource ID of a customized dialog template. To use the standard
template, set this parameter to 0.
The where parameter specifies the upper-left corner of the dialog box in global coordinates. If
you specify the point (—1,—1), CustomPutFile automatically centers the dialog box on the
screen.
The dlgHook parameter points to your dialog hook function, which handles item hits received
from the Dialog Manager. Specify a value of NIL if you have not added any items to the dialog
box and want the standard items handled in the standard ways. See “Callback Routines” earlier
in this chapter for a description of the dialog hook function, which uses this syntax:
FUNCTION

MyDlgHook

(item:

Integer;

myDataPtr:

Ptr)

theDialog:
:

DialogPtr;

Integer;

The filterProc parameter points to your modal-dialog filter function, which determines
how the ModalDialog procedure filters events when called by the CustomPutFile procedure.
Specify a value of NIL if you are not supplying your own function. See “Callback Routines”
earlier in this chapter for a description of the modal-dialog filter function, which uses
this syntax:

nN

—

ef)

FUNCTION

MyModalFilter

S

(theDialog:
DialogPtr;
VAR theEvent:
EventRecord;
VAR

itemHit:

Integer;

myDataPtr:

—
—

~~

Qu

9
=

Ptr)

joe

Boolean;

_=:
o)

Standard File Package Routines

— 26-21

Inside Macintosh, Volume VI

The activeList parameter points to a list of all items in the dialog box that can be activated—
that is, can be the target of keyboard input. If you supply an activeList parameter of NIL,
CustomPutFile uses the default targets (the filename field and the list of files and folders that
can be opened). If you have added any fields that can accept keyboard input, you must
modify the list. The list is stored as an array of 16-bit integers. The first integer 1s the number
of items in the list. The remaining integers are the item numbers of all possible keyboard
targets, in the order that they are activated by the Tab key.

The activateProc parameter points to your activation procedure, which controls the high-

lighting of dialog items that are defined by your application and that can receive keyboard
input. See “Callback Routines” earlier in this chapter for a description of the activation
procedure, which uses this syntax:
PROCEDURE

MyActivateProc

(theDialog:
DialogPtr;
itemNo:
Integer;
activating:
Boolean;
myDataPtr:
Ptr);

The yourDataPtr parameter points to optional data supplied by your application. When
CustomPutFile calls any of your callback routines, it pushes this parameter on the
stack, making the data available to your callback routines. If you are not supplying any
data of your own, you can specify a value of NIL.

Opening

Files

Use the StandardGetFile procedure to display the default Open dialog box when the user is
opening a file.
PROCEDURE

StandardGetFile

(fileFilter:

FileFilterProcPtr;

numTypes:

Integer;

VAR

StandardFileReply) ;

reply:

typeList:

SFTypeList;

StandardGetFile presents a dialog box through which the user specifies the name and location
of a file to be opened. During the dialog, StandardGetFile gets and handles events until the
user completes the interaction, either by selecting a file to open or by canceling the operation.
StandardGetFile returns the user’s input in a standard file reply record, described earlier in
“Using the Standard File Package.”
The fileFilter, numTypes, and typeList parameters together determine which files appear in
the display list. (These three parameters are still used as described in the Standard File
Package chapter of Volume I. The rules are summarized here for your convenience.) The first
filtering is by file type, which you specify in the numTypes and typeList parameters.
= The numTypes parameter specifies the number of file types to be displayed. You can
specify one or more types. If you specify a numTypes value of —1, the first filtering
passes files of all types. A numTypes value of 0 filters out all files.
a The typeList parameter is the list of types to be displayed.
The fileFilter parameter points to an optional file filter function, provided by your application,
through which StandardGetFile passes files of the specified types. See “Callback Routines”
earlier in this chapter for a description of the file filter function, which uses this syntax:
FUNCTION

26-22

MyStandardFileFilter

Standard File Package Routines

(pb:

CInfoPBPtr)

:

Boolean;

The Standard File Package

The reply parameter is the reply record, which StandardPutFile fills in before returning.
= the CustomGetFile procedure when your application requires more control over the Open
ialog box.
PROCEDURE

CustomGetFile

(fileFilter:

FileFilteryYDProcPtr;

numTypes:

Integer;

VAR

StandardFileReply;

reply:

where:

Point;

typeList:

dlgHook:

SFTypeList;
dlgID:

Integer;

DlgHookYDProcPtr;

filterProc:

ModalFilterYDProcPtr;

activeList:

Ptr;

activateProc:

ActivateYDProcPtr;

yourDataPtr:

UNIV

Ptr);

CustomGetFile is an alternative to StandardGetFile when you want to use a customized
dialog box or handle the default Open dialog box in a customized way.
The first four parameters are similar to the same parameters in StandardGetFile. The fileFilter,
numTypes, and typeList parameters determine which files appear in the list of choices. If you
specify a value of —1 in the numTypes parameter, CustomGetFile displays or passes to your
file filter function all files and folders at the current level of the display hierarchy, not just the
files. If you provide a filter function, CustomGetFile passes it both the pointer to the catalog
entry for each file to be processed and also a pointer to the optional data passed by your
application in its call to CustomGetFile.
FUNCTION

MyCustomFileFilter

(pb:
CInfoPBPtr;
Boolean;

myDataPtr:

Ptr)

The reply parameter is the reply record, which CustomGetFile fills in before returning.
The dlgID parameter is the resource ID of a customized dialog template. To use the standard
template, set this parameter to 0.
The where parameter specifies the upper-left corner of the dialog box in global coordinates.
If you specify the point (—1,—-1), CustomGetFile automatically centers the dialog box on
the screen.
The dlgHook parameter points to your dialog hook function, which handles item hits received
from the Dialog Manager. Specify a value of NIL if you have not added any items to the dialog
box and want the standard items handled in the standard ways. See “Callback Routines” earlier
in this chapter for a description of the dialog hook function, which uses this syntax:
FUNCTION

MyDlgHook

(item:

Integer;

myDataPtr:

Ptr)

theDialog:
:

DialogPtr;

Integer;
nN
=

2)
_

as
be)
—
a
—
aa
pot
sea |
—

=)
oo

—
—
@o

Standard File Package Routines

26-23

Inside Macintosh,

Volume VI

The filterProc parameter points to your modal-dialog filter function, which determines how
ModalDialog filters events when called by CustomGetFile. Specify a value of NIL if you are
not supplying your own function. See “Callback Routines” earlier in this chapter for a
description of the modal-dialog filter function, which uses this syntax:
FUNCTION

MyModalFilter

(theDialog:
DialogPtr;
VAR theEvent:
EventRecord;
VAR itemHit:
Integer;
myDataPtr:

Ptr)

Boolean;

The activeList parameter points to a list of all items in the dialog box that can be activated—

that is, made the target of keyboard input. The list is stored as an array of 16-bit integers. The

first integer is the number of items in the list. The remaining integers are the item numbers of
all possible keyboard targets, in the order that they are activated by the Tab key. If you
supply an activeList parameter of NIL, CustomGetFile directs all keyboard input to the
displayed list.

The activateProc parameter points to your activation procedure, which controls the
highlighting of dialog items that are defined by your application and that can receive keyboard
input. See “Callback Routines” earlier in this chapter for a description of the activation
procedure, which uses this syntax:
PROCEDURE

MyActivateProc

(theDialog:

DialogPtr;

itemNo:

Integer;

activating:

Boolean;

myDataPtr:

Ptr);

The yourDataPtr parameter points to optional data supplied by your application.When
CustomGetFile calls any of your callback routines, it pushes this parameter on the
stack, making the data available to your callback routines. If you are not supplying any
data of your own, specify a value of NIL.

26-24

= Standard File Package Routines

The Standard File Package

SUMMARY

OF THE

STANDARD

FILE

PACKAGE

{Save

dialog

box}

{Open

dialog

box}

or

Constants
CONST

{Gestalt
selector
and reply}
gestaltStandardFileAttr
= 'stdf';
gestaltStandardFile58
=
0;

{standard dialog
sfPutDialogID

resource IDs}
= -6043;

sfGetDialogID

{default

=

items

in

-6042;

dialog

boxes}

sfItemOpenButton

«

ty

{Save

sfiItemCancelButton

=

24

{Cancel

38

{Balloon Help}
icon and
{volume

Se

{Eject

{Desktop
{display

sfItemBalloonHelp
sfItemVolumeUser

=

sfItemEjectButton

=

sfItemDesktopButton

=

6%

sfItemFileListUser

=

73

sfItemPopUpMenuUser
sfItemDividerLinePict

=
=

68¢

Open

button}
list}

{directory pop-up menu}
buttons}
line between
{dividing

only}

dialog

boxes

=

10;

{filename

sfItemPromptStaticText

=

11;

sfItemNewFolderUser

=

12;

that

appear

Save

in

{pseudo-items available prior
-1;
=
sfHookFirstCall
$1000;
=
sfHookCharOffset

field}
text
{filename prompt
{New Folder button}

to

version 7.0}
{initialize display}
{offset for character
{null

area}

input}

event}

=

100;

sfHookRebuildList

is

101;

{redisplay

sfHookFolderPopUp
sfHookOpenFolder

=

102;

{display

=

LOS?

{display
{ folder

sfHookNullEvent

name}

button}

sfItemFileNameTextEdit

{items

button}

button}

list}

parent-directory menu}
}
of selected
contents
or

volume}

sfHookGoToNextDrive
sfHookGoToPrevDrive

=
=

7.0}
available with version
{clean up after display}
-=-2;
alias}
{resolve
104;
of desktop}
{display contents
LOS
of alias}
target
{select
106;
of parent}
contents
{display
107;
of next drive}
contents
{display
108;
}
of previous
contents
{display
109;

sfHookChangeSelection
sfHookSetActiveOffset

=
=

110;
200;

pseudo-items
{additional
=
sfHookLastCall
=
sfHookOpenAlias
=
sfHookGoToDesktop
=
t
sfHookGoToAliasTarge
=
arent
sfHookGoToP

{ drive}

reply

{select

target

of

{switch

active

item}

record}

Summary of the Standard File Package

— 26-25

S
=:
=
4
=

=
=

Inside Macintosh, Volume VI

{refCon

in

field

window

the

sfMainDialogRefCon

“std

';

{main

dialog

box}

=

'nfdr';

{New

Folder

dialog

=
=

“rple*;
‘stat’;

{name conflict dialog
{stationery warning}

=

“err

{general

error

report}

=

*loclk' s

{software

lock

warning}

sfNewFolderDialogRefCon

sfReplaceDialogRefCon
sfStatWarnDialogRefCon

sfErrorDialogRefCon
sfLockWarnDialogRefCon

Data
TYPE

record}

dialog

the

in

record

=

‘;

box}

box}

Types
StandardFileReply

=

RECORD

sfGood:

Boolean;

{user

sfReplacing:

Boolean;

{replace

sfType:

OSType;

{file

sfFile:
sfScript:

FSSpec;
ScriptCode;

{selected file,
folder,
or volume}
{script of file,
folder,
or }

sfFlags:

Integer;

{Finder

sfIsFolder:

Boolean;

{selected

item

is

a

folder}

item

is

a

volume}

{

did

not

cancel}

file

with

same

name}

type}

volume

name}
flags

sfIsVolume:

Boolean;

{selected

sfReservedl:

LongInt;

{reserved}

sfReserved2:

Integer

{reserved}

of

selected

item}

END;

SFTypeList

=

ARRAY[0..3]

FileFilteryDProcPtr

OF

OSType;

DlgHookYDProcPtr
ModalFilteryDProcPtr

=

ProcPtr;

{see

=
=

ProcPtr;
ProcPtr;

{see sample
{see sample
{ function}

dialog hook function}
modal-dialog filter }

ActivateYDProcPtr

=

ProcPtr;

{see

activation

sample

sample

file

filter

function}

procedure}

Routines

Saving

Files

PROCEDURE

StandardPutFile

(prompt:
Str255;
defaultName:
Str255;
VAR reply: StandardFileReply) ;

PROCEDURE

CustomPutFile

(prompt:
Str255; defaultName:
Str255;
VAR reply: StandardFileReply;
GlgID:
Integer;
where:
Point;
GlgHook:
DlgHookYDProcPtr;

filterProc:
activeList:
activateProc:
yourDataPtr:

26-26

Summary of the Standard File Package

ModalFilterYyDProcPtr;
Ptr;
ActivateYDProcPtr;
UNIV

Ptr);

The Standard File Package

Opening

Files

PROCEDURE

StandardGetFile

(fileFilter:
VAR

PROCEDURE

CustomGetFile

FileFilterProcPtr;

typeList:

Integer;

numTypes:
reply:

(fileFilter:

SFTypeList;

StandardFileReply) ;

FileFilterYDProcPtr;

numTypes:
Integer;
typeList:
VAR reply:
StandardFileReply;

SFTypeList;

GlgID:
Integer;
where:
Point;
dlgHook:
DlgHookYDProcPtr;
filterProc:

ModalFilterYDProcPtr;

activeList:
Ptr;
activateProc:
ActivateYDProcPtr;
yourDataPtr:

Application-Defined

UNIV

Ptr);

Routines

FUNCTION

MyStandardFileFilter

(pb:

CInfoPBPtr)

:

Boolean;

FUNCTION

MyCustomFileFilter

(pb:

CInfoPBPtr;

myDataPtr:

Ptr)

Boolean;
FUNCTION

MyDlgHook

(item:
Integer;
theDialog:
DialogPtr;
myDataPtr:
Ptr)
: Integer;

FUNCTION

MyModalFilter

(theDialog:
DialogPtr;
VAR theEvent:
EventRecord;
VAR

itemHit:

Integer;

myDataPtr:

Ptr)

Boolean;
PROCEDURE

MyActivateProc

(theDialog:
DialogPtr;
itemNo:
Integer;
activating:
Boolean;
myDataPtr:
Ptr);

Assembly-Language

Information

Standard

File Reply

Record

sfGood
sfReplacing
sfType
sfFile
sfScript
sfFlags
sflsFolder
sfls Volume
sfReserved |
sfReserved2

byte
byte
4 bytes
70 bytes
2 bytes
2 bytes
byte
byte
4 bytes
2 bytes

command-valid flag
replace existing file flag
file type
selected item
display script
Finder flags from catalog
folder flag
volume flag
reserved
reserved

Summary of the Standard File Package

~

~*

a
~
—
=
os
—
as
a
_;

mel

=)

—
nee
_s
—
&
2

— 26-27

|

Inside Macintosh,

Volume

Trap

Requiring

Macro

VI

Routine

Selector

_Pack3
Selector

Routine

$0001
$0002
$0003

SFPutFile
SFGetFile
SFPPutFile

$0005
$0006

StandardPutFile
StandardGetFile

$0004

$0007

$0008

26-28

SFPGetFile

CustomPutFile

CustomGetFile

— Summary of the Standard File Package

NO
N
COMDBDDAIDFLWW
KK

nt YVNNN
i)

20

THE

ALIAS

MANAGER

About This Chapter
About the Alias Manager
About Alias Records
Search Strategies for Resolving Alias Records
Fast Search
Exhaustive Search
Using the Alias Manager
Creating Alias Records
Resolving Alias Records
ResolveAlias
MatchAlias
Maintaining Alias Records
Getting Information About Alias Records
Customizing Alias Records
Alias Manager Routines
Creating and Updating Alias Records
Resolving and Reading Alias Records
Filtering Possible Targets
Summary of the Alias Manager

i)
SJ

ee
i

”n

<4

$9
4
gea2)
—

27-1

oo

ber

Inside Macintosh,

27-2

Volume VI

The Alias Manager

ABOUT

THIS

CHAPTER

This chapter describes how your application can use the Alias Manager to establish and
resolve alias records, which are data structures that describe file system objects (that is,
files, directories, and volumes).
You create an alias record to take a fingerprint of a file system object, usually a file, that you
might need to locate again later. You can store the alias record, instead of a standard file
specification, and then let the Alias Manager find the file again when it’s needed. The Alias
Manager contains algorithms for locating files that have been moved, renamed, copied, or
restored from backup.
Note:

The Alias Manager lets you exploit alias records. It does not directly

manipulate Finder™ aliases, which are created and managed by the user through

the Finder. The Finder Interface chapter in this volume describes Finder aliases
and how your application can accommodate them.

The Alias Manager is available only in system software version 7.0 or later. Call the Gestalt
function, described in the Compatibility Guidelines chapter of this volume, to determine
whether the Alias Manager is present.
Read this chapter if you want your application to create and resolve alias records. You might
store an alias record, for example, to identify a customized dictionary from within a wordprocessing document. When the user runs a spelling checker on the document, your
application can ask the Alias Manager to resolve the record to find the correct dictionary.
To use this chapter, you should be familiar with the File Manager’s conventions for identifying files, directories, and volumes, as described in the File Manager chapter in this volume.

ABOUT

THE

ALIAS

MANAGER

The Alias Manager creates and resolves alias records. The next section, “About Alias
Records,” describes how you can use alias records.
In general, you should use the Alias Manager to create an alias record whenever you find
yourself storing a specific file description, such as filename and parent directory ID. The
Alias Manager stores this information and more in the alias record, and it also provides a
set of search strategies for resolving the record later. The search strategies are described
later in this chapter in “Resolving Alias Records.”
You can use the Alias Manager to
m

create alias records

m

resolve alias records

m

update alias records

to
XQ

pe=

a get information about alias records

~

4
x
5
re
a9@
—

About the Alias Manager

27-3

Ler

|

Inside Macintosh,

Volume

VI

The Alias Manager can track files and directories across volumes. If the target of an alias
record is on an unmounted AppleShare® volume, the Alias Manager automatically mounts the
volume when it resolves the alias. If the target object is on an unmounted ejectable volume,
the Alias Manager prompts the user to insert the volume.
When the Alias Manager creates an alias record, it allocates the storage, fills in the record,
and returns a handle to it. Your application is responsible for storing the record and retrieving
it when needed. Your application must also supply strategies for handling various aliasresolution problems, described in “Resolving Alias Records” later in this chapter.
To help you understand and use the Alias Manager, this chapter provides
m an overview of alias records
m a description of how the Alias Manager resolves alias records
m specific techniques for using the Alias Manager in your application

ABOUT

ALIAS

RECORDS

An alias record is a data structure that describes a file, directory, or volume. The record
contains
m location information, such as name and parent directory ID
m

verification information, such as creation date, file type, and creator

m

volume mounting information (that is, server and zone), if applicable

By storing alias records, you can allow your users to create a robust connection to a file—
that is, a connection that can survive the moving or renaming of the target file. The Finder
in system software version 7.0, for example, stores alias records in aliases created by the
user to represent other files or folders. The Edition Manager uses alias records to support
data sharing among separate documents. (The Finder Interface and Edition Manager
chapters in this volume describe those features in detail.)
An alias record is a reliable way to identify a file system object when your application is
communicating with a process that might be running on a different machine.
The creation of an alias record has no effect on the target of the record, except to establish a
file ID if one did not previously exist for the target file. (See the File Manager chapter of this
volume for a description of file IDs.)
The alias record contains only two fields of public information available to your application.
The bulk of the record is managed privately by the Alias Manager.

27-4

About Alias Records

The Alias Manager

TYPE

AliasRecord

=

RECORD

userType:

OSType;

{application's

signature}

aliasSize:

Integer

{size

when

{variable-length

private

of

record

created}

data}

END;

Your application can use the userType field to store its own signature or any other data that
fits into 4 bytes. When the Alias Manager creates an alias record, it stores 0 in that field.
The Alias Manager stores the size of the record when it was created in the aliasSize field.
Knowing the starting size allows you to store and retrieve data of your own at the end of the
record (see “Customizing Alias Records” later in this chapter). An alias record 1s typically
200 to 300 bytes long.
The private Alias Manager data includes all of the location, verification, and mounting
information needed to resolve the alias record with the various search strategies described
in this chapter.
When you create an alias record, you have the option of recording a relative path, that is,
a path to the target from another file or directory on the same volume. (Relative paths don’t
work across volumes.) The beginning point of a relative path is called the fromFile. To
record a relative path, the Alias Manager saves the distances from the target and the fromFile
to their common parent, that is, the lowest-level directory that appears in the pathnames of
both. The Alias Manager can later use those distances in conjunction with the full pathname
to conduct a relative search.
Suppose, for example, that you are writing a word-processing application that allows the
user to build a customized, supplemental dictionary for each document. You create the
dictionary as a separate document in the same directory as the document it serves, as
Figure 27-1 shows.
Distance to

common parent = 1

Distance to

Common
parent

common parent = 1

Sample

fromFile

Pathname from
common parent
:Dictionary

=

(starting

(file

point
for relative
search)

described
by alias
record)

My File

Dictionary

Figure 27-1.

nm
~I

Resolving a relative path

2

oy

i? 2)

=—

About Alias Records

27-5

=

x
ge
fc)

Ler 3

Inside Macintosh,

Volume VI

When resolving the alias record by using a relative path, the Alias Manager starts at the
directory that is the specified distance above the fromFile, the directory named Sample in
the example in Figure 27-1. The Alias Manager then constructs a partial pathname by
extracting one field of the absolute pathname for each step from the target to the common
parent. In this example, the distance is one, so the pathname contains only the name of the
target document, Dictionary.
In some circumstances, a relative search identifies the correct target when a direct search
cannot. For example, suppose the user of your word-processing application creates a
working copy of a document and dictionary by copying the entire folder Sample to another
disk. The user later updates the original document and dictionary by copying the folder
from the working disk. All of the underlying file and directory identifications change, but
the filenames and relative path remain the same. When the user later runs the spelling
checker on the document, a relative-path search finds the correct target dictionary.
The Alias Manager accepts and returns file specifications in the form of file system specification records (FSSpec records), described in the File Manager chapter of this volume. The
FSSpec record represents a standard, complete description of a file system object. It contains
a volume reference number, a parent directory ID, and a name.

SEARCH

STRATEGIES

FOR

RESOLVING

ALIAS

RECORDS

One of the key features of the Alias Manager is the search strategies built into the aliasresolution functions. The search strategies are designed to find the original target of an alias
record, even if the target has been moved, renamed, copied, or restored from backup.
The Alias Manager provides two basic alias-resolution algorithms: a fast search and an
exhaustive search. This section describes the search algorithms. For descriptions of the
functions that perform the searches, see “Resolving Alias Records” and “Resolving and
Reading Alias Records” later in this chapter.
The first step in any nonrelative search is to identify the volume on which the target resides.
The volume search considers the volume’s name, creation date (which acts almost as a unique
identifier for a volume), and type (for example, a hard disk, a 3.5-inch floppy disk, or an
AppleShare volume).
The Alias Manager first looks for a volume that matches all three criteria: name, creation date,
and type. The search succeeds if the volume is mounted and if its name and creation date have
not changed since the record was created. If the search fails, the Alias Manager attempts to
match by creation date and type only. This step locates volumes that have been renamed.
Finally, the Alias Manager attempts to match by volume name and type only.
If the target is on an unmounted AppleShare volume, the Alias Manager attempts to mount
the volume. It presents a name and password dialog box if appropriate. If the target is on
an unmounted ejectable volume, the Alias Manager displays a dialog box prompting the user
to insert the volume. Your application can suppress the automatic mounting, as explained in
the description of the MatchAlias function in “Resolving and Reading Alias Records” later
in this chapter.

27-6

Search Strategies for Resolving Alias Records

The Alias Manager

Fast

Search

The fast-search algorithm is designed to find the target of an alias record quickly.
Depending on how you invoke it, the fast-search algorithm starts with either a relative search

(described earlier in “About Alias Records”) or a direct search (described in this section). Fast

search can perform a relative search whether or not it has identified the target volume, but it
must identify the volume before it can perform a direct search.

In a direct search, the fast-search algorithm first looks for the target by file ID (if the target is
a file) or directory ID (if the target is a directory). (File IDs and directory IDs are described in
the File Manager chapter of this volume.) Even if a file has been renamed or moved on a
volume, the Alias Manager can find it quickly through its file ID.
If the search by file ID or directory ID fails, fast search looks for the target by name in the
original parent directory. This search locates the target if its file or directory ID has changed
but it still exists by the same name in the parent directory (for example, if the target was
restored from backup). Fast search compares file numbers on files found by name in the
correct parent directory. If the file numbers do not match, the file is treated as a possible
match—that is, it is put on the list of candidates and the search continues. If the target is not
found by name in the parent directory, fast search looks for a file by file number in the parent
directory. A file with the same file number but a different name replaces a file with the same
name but a different file number in the list of matches.
If the search by file ID or directory ID fails and if fast search cannot find the original parent
directory, it searches for the target by full pathname. This search finds the target if it resides
in the same location on the volume but the directory ID of its parent directory has changed
(for example, if the entire parent directory was restored from backup).
If the search by full pathname fails, fast search attempts to find the file by tracing partial
pathnames up through all parent directories, using parent directory IDs instead of directory
names. For example, consider this full pathname:
Loma Prieta:MyReports:October:Sales Report
If the search by full pathname fails, fast search first looks for the partial pathname :Sales
Report in the directory with the ID that the directory Loma Prieta:MyReports:October had
when the alias record was created. If that search fails, it looks for :October:Sales Report in
the directory with the ID that Loma Prieta:MyReports had, and so on.
If you do not ask for a search by relative path first but do provide a starting point for a
relative search, and if the alias record contains relative path information, fast search performs
a relative search after the direct search. The relative search succeeds if the relative path is the
same as when the record was created and if the names of the target and its intervening parent
directories have not changed.

te

~I

>
=
i? 2)

s
£9
=|
st)
ge
©
—

Search Strategies for Resolving Alias Records

27-7

Inside Macintosh,

Volume

Exhaustive

Search

V1

The exhaustive-search algorithm scans an entire volume to look for possible matches.
The Alias Manager typically performs an exhaustive search by calling the File Manager
function PBCatSearch, searching for files or directories with a matching creation date,
creator, and type. (See the File Manager chapter of this volume for a description of
PBCatSearch.)
PBCatSearch is available only on HFS volumes, not on MFS volumes. (See the File
Manager chapter of this volume for a description of the two file systems.) PBCatSearch is
also available only on systems running version 7.0 and later. When PBCatSearch is not
available, exhaustive search performs a search of the entire volume by making a series of
indexed File Manager calls, searching for objects with matching creation date, type, creator,
or file number.

USING

THE

ALIAS

MANAGER

You use the Alias Manager primarily to create and resolve alias records. You can also use it to
get information about and update alias records.
The Alias Manager creates an alias record in memory and provides you with a handle to the
record. When you no longer need a record in memory, free the memory by calling the
DisposHandle procedure, described in the Memory Manager chapter of Volume II. You can
store and retrieve alias records as resources of type ‘alis’.
Alias Manager functions accept and return file specifications in the form of FSSpec records,
which contain a volume reference number, a parent directory ID, and a target name. See the
File Manager chapter in this volume for a description of file identification conventions.
Before calling any of the Alias Manager functions, verify that the Alias Manager is available
by calling the Gestalt function with a selector of gestaltAliasMgrAttr. If Gestalt sets the
gestaltAliasMgrPresent bit in the response parameter, the Alias Manager is present. For a
complete description of the Gestalt function, see the Compatibility Guidelines chapter of
this volume.
For more detailed descriptions of the functions described in this section, see “Alias Manager
Routines” later in this chapter.

Creating

Alias

Records

You create a new alias record by calling one of three functions: NewAlias, NewAliasMinimal,
or NewAliasMinimalFromFullpath. The NewAlias function creates a complete alias record
that can make full use of the alias-resolution algorithms. The other two functions are streamlined variations designed for circumstances when speed is more important than robust
resolution services. All three functions allocate the memory for the record, fill it in, and
provide a handle to it.

27-8

Using the Alias Manager

The Alias Manager

NewAlias always records the name and the file or directory ID of the target, its creation date,
the parent directory name and ID, and the volume name and creation date. It also records the
full pathname of the target and a collection of other information. You can request that
NewAlias store relative path information as well by supplying a starting point for a relative
path (see “About Alias Records” earlier in this chapter for a description of relative path).
Call NewAlias when you want to create an alias record to store for later use. For example,
suppose you are writing a word-processing application that allows the user to customize a
dictionary for use with a single text file. Your application stores the custom data in a separate
dictionary file in the same directory as the document. As soon as you create the dictionary
file, you call NewAlias to create an alias record for that file, including path information
relative to the user’s text file:
VAR

textFile:

FSSpecPtr;

target:

FSSpec;

myAliasHdl:

AliasHandle;

myErr

:=

NewAlias(textFile,

target,

myAliasHdl);

The textFile parameter is a pointer to a file system specification record that identifies the
starting point for the relative search, in this case the user’s text file. If you do not want
relative path information recorded, pass a value of NIL in the first parameter.
The target parameter is a file system specification record that identifies the target file, in this
example the dictionary file.
The myAliasHdl parameter is a variable in which the Alias Manager returns the handle to the
alias record that describes the target.
The two variations on the NewAlias function, NewAliasMinimal and
NewAliasMinimalFromFullpath, record only a minimum of information about the target.
NewAliasMinimal records only the target’s name, parent directory ID, volume name and
creation date, and volume mounting information. NewAliasMinimalFromFullpath
records only the full pathname of the target, including the volume name.
Use NewAliasMinimal or NewAliasMinimalFromFullpath when you are willing to give up
robust alias-resolution service in return for speed. The Finder, for example, stores minimal
aliases in the Apple® events that tell your application to open or print a document. Because
the alias record is resolved almost immediately, the description is likely to remain valid, and
the shorter record is probably safe.
You can use NewAliasMinimalFromFullpath to create an alias record for a target that doesn’t
exist or that resides on an unmounted volume.

Resolving

Alias Records

The Alias Manager provides two alias-resolution functions:
m the high-level function ResolveAlias, which performs a fast search and identifies only
one target

i)
~l

>

w the low-level function MatchAlias, which can perform a fast search, an exhaustive
search, or both, and which can return a list of target candidates

creme

po)

i? 21

=

a
—

Using the Alias Manager

27-9

==}
bee)
ve
@

“

Inside Macintosh,

Volume VI

In general, when you want to identify only the single most likely target of an alias
record, you call ResolveAlias. You call MatchAlias when you want your program to
control the search.
This section describes the alias-resolution functions. The section “Search Strategies for
Resolving Alias Records” earlier in this chapter describes the underlying fast and exhaustive searches.

ResolveAlias
Typically, you call the ResolveAlias function to resolve an alias record. ResolveAlias
performs a fast search (described earlier in “Fast Search’’) and exits after it identifies

one target.

By calling low-level functions, ResolveAlias compares some key information about the
identified target with the information stored in the alias record. If any of the information is
different, ResolveAlias automatically updates the record.
Note: As with all other Alias Manager functions, ResolveAlias updates the record
only in memory. Your application is responsible for updating alias records stored on
disk when appropriate.
In the dictionary example illustrated in Figure 27-1 earlier in this chapter, the application calls
ResolveAlias with a relative path specification when the user runs the spelling checker on a
document with a customized dictionary.
myErr

:=

ResolveAlias(textFile,

myAliasHdl,

target,

wasChanged) ;

The textFile parameter is a pointer to a file system specification record that identifies the
starting point for the relative search, in this case the user’s text file. If you do not want
relative path information used in the search, pass a value of NIL in the first parameter. If
you provide a relative starting point, ResolveAlias performs the relative search first.
The myAliasHdl parameter is a handle to the alias record to be resolved. In this example, the
alias record describes the dictionary file.
The target parameter is the file system specification record where the Alias Manager places
the results of its search. After ResolveAlias completes, target contains the specification for
the dictionary file.
The ResolveAlias function uses the wasChanged parameter to report whether it updated
the alias record. After ResolveAlias completes, wasChanged is TRUE if the record was
updated and FALSE if it was not. If you are storing the alias record, check the value of
wasChanged (as well as the function’s result code) to see whether to update the stored

record after resolving an alias.

If ResolveAlias can’t resolve the alias record, it returns a nonzero result code. A result code
of fnfErr signals that ResolveAlias has found the correct volume and parent directory but not
the target file or folder. In this case, ResolveAlias constructs a valid FSSpec record that
describes the target. You can use this record to explore possible solutions to the resolution
failure. You can, for example, use the FSSpec record to create a replacement for a missing
file with the File Manager function FSpCreate.
27-10

— Using the Alias Manager

The Alias Manager

MatchAlias
The MatchAlias function is a low-level routine that gives your application control over the
searching algorithm.
You can control
= whether to attempt an automatic mounting of unmounted volumes
m whether to search on more than one volume
= whether to perform a fast search, an exhaustive search, or both
w the order of the direct and relative searches in a fast search
= whether to pursue search strategies that require interaction with the user (such as asking
for a password while mounting an AppleShare volume)
You can also specify a maximum number of candidates that MatchAlias can identify.
See “Resolving and Reading Alias Records” later in this chapter for details about controlling a
search with the MatchAlias function.
You can supply an optional filter function that MatchAlias calls
m each time it identifies a possible match
m when three seconds have elapsed without a match
The filter function determines whether each candidate is added to the list of possible targets.
It can also terminate the search. See “Filtering Possible Targets” later in this chapter for a
description of the filter function.
MatchAlias returns all candidates that it identifies in an array of file system specification records.

Maintaining

Alias

Records

You can store alias records as resources of type ‘alis’.
CONST

rAliasType

=

‘alis';

{resource

type

for

saved

alias

records}

To store and retrieve resources, use the standard Resource Manager functions (AddResource,
GetResource, and GetNamedResource) described in the Resource Manager chapter of
Volume I.
To update an alias record, use the UpdateAlias function. You typically call UpdateAlias any
time you know that the target of an alias record has been renamed or otherwise changed.
You are most likely to call UpdateAlias after a call to the MatchAlias function. If MatchAlias
identifies a single target, it sets a flag telling you whether or not the key information about the
target file matches the information in the alias record. It is the responsibility of your
application to update the record.

nN

~J

a

=
~”

a
—

Using the Alias Manager

=. 27-11

pe)
j=}
2
ge
@
“

Inside Macintosh,

Volume VI

The ResolveAlias function automatically updates an alias record if any of the the key information about the identified target does not match the information in the record.

Getting

Information

About

Alias Records

To retrieve information from an alias record without actually resolving the record, call the
GetAliasInfo function. You can use GetAliasInfo to retrieve the name of the target, the
names of the target’s parent directories, the name of the target’s volume, or, in the case of
an AppleShare volume, its zone or server name.

Customizing

Alias Records

An alias record contains two kinds of information: public information available to your application and private information available only to the Alias Manager. Your application can use
the first field, userType, to store its own signature or any other data that fits into 4 bytes.
Your application can use the second field, aliasSize, to customize the alias record for storing
additional data.
The Alias Manager stores the size of the record when it is created or updated in the aliasSize
field. To customize an alias record, you first increase the size of the record with the

SetHandleSize procedure, described in the Memory Manager chapter of Volume II. You can
then find the starting address of your own data in the record by adding the record’s starting
address to the length recorded in the aliasSize field. If you expand the record through the
Memory Manager, the Alias Manager preserves your data, even if it changes the size of its
own data when updating the record.
In general, you should customize only alias records that you have created.

ALIAS

MANAGER

ROUTINES

This section describes the routines you use to create, update, resolve, and read alias records.
Alias Manager routines use file system specification records (FSSpec records) to identify
files, directories, and volumes. To create an FSSpec record, call the function MakeFSSpec,
described in the File Manager chapter of this volume.
The Alias Manager routines can return the result codes listed in this section or any other
applicable file system or memory management result codes.

Creating

and

Updating

Alias

Records

You use the NewAlias function to create a complete alias record.
FUNCTION

NewAlias

(fromFile:
VAR

27-12

alias:

Alias Manager Routines

FSSpecPtr;

target:

AliasHandle)

:

FSSpec;

OSErr;

The Alias Manager

NewAlias creates an alias record that describes the specified target. It allocates the storage,
fills in the record, and puts a record handle in the alias parameter. NewAlias always records
the name and file or directory ID of the target, its creation date, the parent directory name and
ID, and the volume name and creation date. It also records the full pathname of the target
and a collection of other information relevant to locating the target, verifying the target, and
mounting the target’s volume, if necessary. You can request that it store relative path information as well by supplying a starting point for a relative path (see “About Alias Records”
earlier in this chapter for a description of relative path).
The fromFile parameter represents the starting point for a relative path, to be used later in a

relative search. If you do not need relative path information in the record, pass a fromFile
value of NIL. If you want NewAlias to record relative path information, pass a pointer to a
valid FSSpec record in this parameter. The two files or directories, fromFile and target, must
reside on the same volume.

The target parameter is an FSSpec record for the target of the alias record.
NewAlias puts a handle to the newly created alias record in the alias parameter. If the function
fails to create an alias record, it sets alias to NIL.
Result code
noErr

0)

No error

You use the NewAliasMinimal function to create a short alias record quickly.
FUNCTION

NewAliasMinimal

(target:

FSSpec;

VAR

alias:

AliasHandle)

OSErr;

NewAliasMinimal creates an alias record that contains only the minimum information
necessary to describe the target: the target name, the parent directory ID, the volume name
and creation date, and the volume mounting information. NewAliasMinimal uses the
standard alias record data structure, but fills in only parts of the record.
The target parameter points to an FSSpec record for the target of the alias record.
NewAliasMinimal puts a handle to the newly created alias record in the alias parameter. If the
function fails to create an alias record, it sets alias to NIL.
The ResolveAlias function, described in “Resolving and Reading Alias Records” later in this
chapter, never updates a minimal alias record.
Result code
noErr

@

No error

Alias Manager Routines

— 27-13

Inside Macintosh, Volume VI

You use the function NewAliasMinimalFromFullpath to quickly create an alias record that
contains only the full pathname of the target.
FUNCTION

NewAliasMinimalFromFullpath

(fullpathLength:
fullpath:
Ptr;

Integer;
zoneName:

serverName:
Str3l1;
VAR alias:
AliasHandle)

Str32;
:

OSErrz;

NewAliasMinimalFromFullpath creates an alias record that identifies the target by full pathname. You can call NewAliasMinimalFromFullpath to create an alias record for a file that
doesn’t exist or that resides on an unmounted volume. NewAliasMinimalFromFullpath uses
the standard alias record data structure, but it fills in only the information provided in the
input parameters. You can therefore use NewAliasMinimalFromFullpath to create alias
records for targets on unmounted volumes.
The fullpathLength parameter identifies the number of characters in the full pathname.

The fullpath parameter is a pointer to a buffer that contains the full pathname of the target.

The full pathname starts with the name of the volume, includes all of the directory names in
the path to the target, and ends with the target name. (For a description of pathnames, see
the File Manager chapter in this volume.)
The parameters zoneName and serverName are strings that identify the AppleTalk® zone and
server name of the AppleShare volume on which the target resides. Set these parameters to
null strings if you do not need them.
NewAliasMinimalFromFullpath puts a handle to the newly created alias record in the alias
parameter. If the function fails to create an alias record, it sets alias to NIL.
Result code
noErr

0

No error

You use the UpdateAlias function to update an alias record.
FUNCTION

UpdateAlias

(fromFile:
alias:

FSSpecPtr;

AliasHandle;

target:
VAR

FSSpec;

wasChanged:

Boolean)

OSErr;

UpdateAlias updates the alias record pointed to by the alias parameter so that it describes the
target specified by the target parameter. UpdateAlias rebuilds the entire alias record, and fills
it in as the NewAlias function would.
The fromFile parameter represents the starting point for a relative path, to be used later in a
relative search. If you do not need relative path information in the record, pass a fromFile
value of NIL. If you want UpdateAlias to record relative path information, pass a pointer
to a valid FSSpec record in this parameter. The two files or directories, fromFile and
target, must reside on the same volume.
The target parameter is the target of the alias record. This parameter must be a valid
FSSpec record.
27-14

Alias Manager Routines

The Alias Manager

The alias parameter is a handle to the alias record to be updated.

If the newly constructed alias record is exactly the same as the old one, UpdateAlias sets the
wasChanged parameter to FALSE. Otherwise, it sets it to TRUE. Check this parameter to
determine whether you need to save an updated record.
UpdateAlias always creates a complete alias record. When you update a minimal alias record
with UpdateAlias, you convert the minimal record to a complete record.
Result codes
noErr
paramErr

Resolving and

0
—50

No error
Target, alias, or both are NIL, or the alias record is corrupt

Reading

Alias Records

You use the ResolveAlias function to identify the single most likely target of an
alias record.
FUNCTION

ResolveAlias

(fromFile:
VAR

target:

FSSpecPtr;
FSSpec;

alias:
VAR

AliasHandle;

wasChanged:

Boolean)

OSErr;

ResolveAlias performs a fast search for the target of the alias, as described earlier in “Fast
Search.” If the resolution is successful, ResolveAlias returns the FSSpec record for the target
file system object through the target parameter, updates the alias record if necessary, and
reports whether the record was updated through the wasChanged parameter. If the target is
on an unmounted AppleShare volume, ResolveAlias automatically mounts the volume. If the
target is on an unmounted ejectable volume, ResolveAlias asks the user to insert the volume.
ResolveAlias exits after it finds one acceptable target.
The fromFile parameter represents the starting point for a relative search. If you pass a
fromFile parameter of NIL, ResolveAlias performs only a direct search. If you pass a pointer
to a valid FSSpec record in the fromFile parameter, ResolveAlias performs a relative search
for the target, followed by a direct search only if the relative search fails. If you want to
perform a direct search followed by a relative search, you must use the MatchAlias function.
The alias parameter is a handle to the alias record to be resolved and, if necessary, updated.
The target parameter receives the FSSpec record of the target file system object.
After it identifies a target, ResolveAlias compares some key information about the target with
the information in the alias record. (The description of the MatchAlias function that follows
lists the key information.) If the information differs, ResolveAlias updates the record to
match the target. If it updates the alias record, ResolveAlias sets the wasChanged parameter
to TRUE. Otherwise, it sets it to FALSE. (Because ResolveAlias never updates a minimal
alias, it never sets wasChanged to TRUE when resolving a minimal alias.)
When it finds the specified volume and parent directory but fails to find the target file or
directory in that location, ResolveAlias returns a result code of fnfErr and fills in the target
parameter with a complete FSSpec record describing the target (that is, the volume reference

i)
er
>
=
NM

=—

Alias Manager Routines

= 27-15

£9
o
oe
~

i

Inside Macintosh,

Volume VI

number, parent directory ID, and filename or folder name). The FSSpec record is valid,

although the object it describes does not exist. This information is intended as a “hint” that
lets you explore possible solutions to the resolution failure. You can, for example, use the
FSSpec record to create a replacement for a missing file with the File Manager function
FSpCreate.
ResolveAlias displays the standard dialog boxes when it needs input from the user, such as a
name and password for mounting a remote volume. The user can cancel the resolution
through these dialog boxes.
Result codes

noErr
nsvErr
fnfErr

0
—35
43

No error
The volume is not mounted
Target not found, but volume and parent directory
found; if aliasCount is |, target parameter contains a valid
FSSpec record
Target, alias, or both are NIL, or the alias record is corrupt
Parent directory not found
The user canceled the operation

paramErr
—50
dirNFErr
—120
usrCanceledErr —128

You use the MatchAlias function to identify a list of possible matches and pass the list
through an optional selection filter. The filter can pass more than one possible match.
FUNCTION

MatchAlias

(fromFile:

FSSpecPtr;

rulesMask:

LongInt;

alias:
AliasHandle;
VAR aliasCount:
Integer;
aliasList:
FSSpecArrayPtr;
VAR needsUpdate:
Boolean;
aliasFilter:
Ptr)

:

AliasFilterProcPtr;

yourDataPtr:

UNIV

OSErr;

MatchAlias resolves the alias record specified by the alias parameter, following the rules

specified by the rulesMask parameter, and returns a list of possible candidates in the struc-

ture specified by the aliasList parameter. MatchAlias places the number of candidates
identified in the aliasCount parameter.

The fromFile parameter represents the starting point for a relative search. If you do not want
MatchAlias to perform a relative search, set fromFile to NIL. If you want MatchAlias to
perform a relative search, pass a pointer to a file system specification record that describes the
starting point for the search.

The rulesMask parameter specifies a set of rules to guide the resolution. Pass the sum of all
of the rules you want to invoke.
Constant

Description

kARMSearch

Perform a fast search for the alias target.
If kARMSearchRelFirst is not set, perform a direct search first,
followed by a relative search only if the fromFile parameter is not
NIL and the list of matches is not full.

27-16

Alias Manager Routines

The Alias Manager

Constant

Description

kARMSearchMore

Perform an exhaustive search for the alias target.
On HFS volumes, the exhaustive search uses the File Manager
function PBCatSearch to identify candidates with matching
creation date, type, and creator. PBCatSearch is available only
on HFS volumes and only on systems running version 7.0 or
later. On MFS volumes or HFS volumes that do not support
PBCatSearch the exhaustive search makes a series of indexed
calls to File Manager functions, using the same search criteria.
If you set KARMSearchMore and one or both of kARMSearch and
kARMSearchRelFirst, MatchAlias performs the fast search first.

kARMSearchRelFirst

If kARMSearch is also set, perform a relative search before the

direct search. (If KARMSearch is also set and the target is found
through the direct search, MatchAlias sets the needsUpdate flag
to TRUE.)
If neither KARMSearch nor kARMSearchMore is set, perform
only a relative search.
If kARMSearch is not set but kARMSearchMore is set, perform a
relative search followed by an exhaustive search.

kARMMountVol

Automatically try to mount the target’s volume if it is not mounted.

kARMMultVols

Search all mounted volumes.

The search begins with the volume on which the target resided
when the record was created.
When you specify a fast search of all mounted volumes, MatchAlias
performs a formal fast search only on the volume described in the
alias record. On all other volumes, it looks for the target by ID or by
name in the directory with the specified parent directory ID.
When you specify an exhaustive search of multiple volumes,
MatchAlias performs the same search on all volumes.
When resolving an alias record created by
NewAliasMinimalFromFullpath, MatchAlias ignores this flag.
kARMNoUI

Stop if a search requires user interaction, such as a password
dialog box when mounting a remote volume.
If user interaction is needed and kARMNOoUL is in effect, the
search fails.

You must specify at least one of the first three parameters: kARMSearch, kARMSearchMore,
and kARMSearchRelFirst.
The alias parameter is a handle to the alias record to be resolved.
Your application can specify a maximum number of possible matches by setting the aliasCount
parameter. MatchAlias changes the aliasCount parameter to the actual number of candidates
identified. If MatchAlias finds the parent directory on the correct volume but does not find the

nN
|
=
S
i? 2)

a
—

Alias Manager Routines

27-17

ry)
=
i)
ge

@
ar |

Inside Macintosh, Volume VI

target, it sets the aliasCount parameter to 1, puts the file system specification record for the —
target in the results list, and returns fnfErr. The FSSpec record is valid, although the object it
describes does not exist. This information is intended as a “hint” that lets you explore possible
solutions to the resolution failure. You can, for example, use the FSSpec record to create a
replacement for a missing file with the File Manager function FSpCreate.
The aliasList parameter points to the array that holds the results of the search.
The needsUpdate flag is a signal to your application that the record might need to be updated.
After it identifies a target, MatchAlias compares some key information about the target with
the same information in the record. If the information does not match, MatchAlias sets the
needsUpdate flag to TRUE. The key information is
m the name of the target
m the directory ID of the target’s parent
a the file ID or directory ID of the target
m the name and creation date of the volume on which the target resides
MatchAlias also sets the needsUpdate flag to TRUE if it identifies a list of possible matches
rather than a single match or if kARMsearchRelFirst is set but the target is identified through
either a direct search or an exhaustive search. Otherwise, MatchAlias sets the needsUpdate

flag to FALSE. MatchAlias always sets the needsUpdate flag to FALSE when resolving an
alias created by NewAliasMinimal. If you want to update the alias record to reflect the final
results of the resolution, call UpdateAlias.
The aliasFilter parameter points to a filter function supplied by your application. The Alias
Manager executes this function each time it identifies a possible match and after the search
has continued for three seconds without a match. Your filter function returns a Boolean

value that determines whether the possible match is discarded (TRUE) or added to the list of

possible targets (FALSE). It can also terminate the search by setting the variable parameter
quitFlag. See “Filtering Possible Targets” later in the chapter for a description of the filter

function, which follows this syntax:
FUNCTION

MyMatchAliasFilter

(cpbPtr:
VAR

CInfoPBPtr;

quitFlag:

myDataPtr:

Ptr)

Boolean;
:

Boolean;

The yourDataPtr parameter can point to any data that your application might need in the filter
function. Use the myDataPtr parameter to pass global or local data to your filter function.
Result codes

noErr
nsvErr
fnfErr

paramErr
usrCanceledErr

27-18

0
—35
—43

Noerror
The volume is not mounted
Target not found, but volume and parent directory

-50
-128

FSSpec record
Target, alias, or both are NIL, or the alias record is corrupt
The user canceled the operation

Alias Manager Routines

found; if aliasCount is 1, target parameter contains a valid

The Alias Manager

You use the GetAliasInfo function to get information from an alias record without actually
resolving the record.
FUNCTION

GetAliasInfo

(alias:
VAR

AliasHandle;

theString:

Str63)

index:
:

AliasInfoType;

OSErr;

GetAliasInfo retrieves the information specified by the index parameter from the record
pointed to by the alias parameter and places it in the parameter theString.
The alias parameter is a handle to the alias record to be read.
The index parameter specifies the kind of information to be retrieved. If index is a positive
integer, GetAliasInfo retrieves the parent directory that has the same hierarchical level above
the target as the index parameter (for example, an index value of 2 returns the name of the
parent directory of the target’s parent directory). You can therefore assemble the names of the
target and all of its parent directories by making repeated calls to GetAliasInfo with incrementing index values, starting with a value of 0. When index is greater than the number of levels
between the target and the root, GetAliasInfo returns an empty string. You can also set the
index parameter to one of the following five values.
Constant

Value

Description

asiZoneName

—3

If the record represents a target on an AppleShare volume,
retrieve the server’s zone name. Otherwise, return an
empty string.

asiServerName

—2

If the record represents a target on an AppleShare volume,
retrieve the server name. Otherwise, return an empty string.

asiVolumeName

-!1

Return the name of the volume on which the target resides.

asiAliasName

0

Return the name of the target.

asiParentName

l

Return the name of the parent directory of the target of the
record. If the target is a volume, return the volume name.

GetAliasInfo places the requested information in the parameter theString.
GetAliasInfo returns the information stored in the alias record, which might not be current.
To ensure that the information is current, you can resolve and update the alias record before
calling GetAliasInfo.
GetAliasInfo cannot provide all kinds of information on a minimal alias.
Result codes
noErr
paramErr

0
—50

No error
Alias, theString, or both are NIL; the index is less
than asiZoneName; or the alias record is corrupt
i)
~]

>

=
77)
g
—€

Alias Manager Routines

27-19

po)
i]
po)

ge

Oo

Inside Macintosh,

Filtering

Volume

Possible

VI

Targets

You can write your own filter function to examine possible targets identified by the MatchAlias
function. MatchAlias calls your filter function each time it identifies a possible match and when
three seconds have elapsed without a match.
The filter function takes three parameters and returns a Boolean value:
FUNCTION

MyMatchAliasFilter

(cpbPtr:

CInfoPBPtr;

myDataPtr:

Ptr)

:

VAR

quitFlag:

Boolean;

Boolean;

The cpbPtr parameter points to the catalog information parameter block record (as returned
by the File Manager function PBGetCatInfo) of the possible match. MatchAlias sets this
parameter to NIL if it is calling your function to give it the periodic chance to terminate the
search. (Do not use this pointer without checking for NIL.)
Your filter function sets the quitFlag parameter to terminate the search.
The myDataPtr parameter points to any customized data that your application passed when it
called MatchAlias. This parameter allows your filter function to access any data that your
application has set up on its own.
The Boolean return value determines whether the possible match is discarded (TRUE) or
added to the list of possible targets (FALSE).

27-20

Alias Manager Routines

The Alias Manager

SUMMARY

OF THE

ALIAS

MANAGER

Constants
CONST

gestaltAliasMgrAttr
gestaltAliasMgrPresent
=

rAliasType
{rulesMask

=
=

for

"alias 's
0;
{alias

‘alas';

MatchAlias}
§00000001;
=
§00000002;
=

record

resource

type}

=

§00000008;

kARMSearch

=

§00000100;

kARMSearchMore
kARMSearchRelFirst

=

§00000200;

automatically}
the volume
{mount
interface}
user
{suppress
volumes}
on multiple
{search
search}
{perform a fast
search}
{perform an exhaustive

-

§00000400;

{perform

kARMMountVol
kARMNoUL
kARMMult Vols

{index

values

for

a

relative

GetAliasInfo}
= <3;

{get

=

225

{get

asiAliasName

=
=

=;
iQ;

{get
{get

zone name}
name}
server
name}
volume
name}
target

asiParentName

=

1;

{get

parent

asiZoneName
asiServerName
asiVolumeName

Data

Types

TYPE

AliasHandle
AliasPtr

=

“AliasPtr;

=

“AliasRecord;

AliasRecord

=

RECORD

directory

name}

signature}
{application's
{size of record when created}

userType:
aliasSize:

OSType;
Integer

AliasInfoType

=

Integer;

{alias

AliasFilterProcPtr

=

ProcPtr;

{application-defined
{ see sample
}

{variable-length

first}

search

private

data}

END;

{

record

FUNCTION

information

type}

routine;

}

MyMatchAliasFilter}

Ne)
~]

>=
tf 2)

io
—

po)

Summary of the Alias Manager

— 27-21

=

eh)

itj=)

©

Inside Macintosh, Volume VI

Routines

Creating

and

FUNCTION

NewAlias

FSSpec;
target:
FSSpecPtr;
(fromFile:
VAR alias:
AliasHandle)
: OSErr;

FUNCTION

NewAliasMinimal

(target:
FSSpec;
VAR alias:
AliasHandle)

FUNCTION

Updating

Alias Records

NewAliasMinimalFromFullpath

(fullpathLength:
fullpath:
Ptr;

UpdateAlias

(fromFile:
alias:
VAR

Resolving
FUNCTION

FUNCTION

and

Reading

ResolveAlias

FSSpecPtr;

Str32;
:

OSErr;

target:

FSSpec;

AliasHandle;

wasChanged:

Boolean)

:

OSErr;

Alias Records
(fromFile:

MatchAlias

OSErr;

Integer;
zoneName:

serverName:
Str31;
VAR alias:
AliasHandle)
FUNCTION

:

FSSpecPtr;

VAR

target:

VAR

wasChanged:

(fromFile:
alias:

Boolean)

FSSpecPtr;

AliasHandle;

:

OSErr;

rulesMask:

AliasHandle;

aliasList:
VAR

alias:

FSSpec;

VAR

LongInt;

aliasCount:

Integer;

FSSpecArrayPtr;

needsUpdate:

Boolean;

AliasFilterProcPtr;

aliasFilter:

yourDataPtr:

UNIV

Ptr)

OSErr;
FUNCTION

GetAliasInfo

(alias:
VAR

Application-Defined
FUNCTION

AliasHandle;

theString:

:

AliasInfoType;

OSErr;

Routine

MyMatchAliasFilter

(cpbPtr:

CInfoPBPtr;

myDataPtr:

27-22

index:

Str63)

Summary of the Alias Manager

Ptr)

:

VAR

quitFlag:

Boolean;

Boolean;

The Alias Manager

Result

Codes

nsvErr
fnfErr

—35
43

paramErr
dirNFErr
usrCanceledErr

—50
—120
—128

Assembly-Language
Alias

Record

The volume is not mounted
Target not found, but volume and parent directory
found; if aliasCount is 1, target parameter contains a valid
FSSpec record
Target, alias, or both are NIL, or the alias record is corrupt
Parent directory not found
The user canceled the operation

Information

Data Structure

userType
4 bytes
file type of target file
aliasSize
2 bytes
size of record in bytes
{ variable-length private data}

Nm
|

==
D

Summary of the Alias Manager

— 27-23

P<
—
+)
=}
te)
ge
co

Inside Macintosh,

27-24

Volume VI

to
os
<—
@

=|
°
™
<<

oad

MEMORY

=<

MANAGEMENT

g
|
$9
ge@

—

5<)

About This Chapter
About Memory Management
Dividing Memory Among Multiple Applications
Extending an Application’s Available Memory
Extending the Operating System’s Available Memory
Controlling the System Memory Settings
About the Memory Manager
Using Master Pointers
Using Window and Control Definition Functions
Manipulating 24-Bit and 32-Bit Memory Addresses
Using the Memory Manager
Setting and Restoring the A5 Register
Manipulating AS Without MPW
Memory Manager Routines
Setting and Restoring the AS World
Manipulating Memory Addresses
About Virtual Memory
Using Virtual Memory
Holding and Releasing Memory
Locking and Unlocking Memory
Obtaining Information About Virtual Memory
Information About the System Memory Configuration
Information About Page Mapping
Deferring User Interrupt Handling
Debugger Support Under Virtual Memory
Bus Error Vectors
Special Nonmaskable Interrupt Needs
Supervisor Mode
The Debugging State
Keyboard Input
Page States
Virtual Memory Routines
Holding and Releasing Pages
Locking and Unlocking Pages
Obtaining Page-Mapping Information
Deferring User Interrupt Handling
Determining Which Debugger Functions Are Present
Determining Whether Paging Is Safe
Locking and Unlocking Memory With Caching Enabled
Entering and Exiting the Debugging State
Obtaining Keyboard Input
Determining Page State
About Temporary Memory
Using Temporary Memory
Allocating Temporary Memory
Locking Temporary Memory
Unlocking Temporary Memory
Releasing Temporary Memory
Determining Features of Temporary Memory

=|=

28-1

Inside Macintosh,

38
38
39
40
41

28-2

Volume VI

Temporary Memory Routines
Requesting Temporary Memory
Locking and Unlocking Temporary Memory
Freeing Temporary Memory
Summary of Memory Management

i

of

Memory Management

a
—

o
—

4
ad

=)

Law

—
y

ABOUT

THIS

—

CHAPTER

p=)
~
ey)
ge

‘<)

=

as

This chapter describes several new features of memory management on Macintosh® computers
introduced in system software version 7.0, including changes to the Memory Manager—the
part of the Operating System that controls the dynamic allocation of space in the application
heap and the system heap. Two important additions to memory management in version 7.0 are
support for 32-bit addressing and virtual memory. This chapter also describes changes to the
temporary memory routines that were already available under MultiFinder® starting with
system software version 6.0.
The information in this chapter supplements the chapters on the Memory Manager found in
Inside Macintosh, Volumes I, I, and IV, and it supersedes the discussion of temporary
memory routines contained in Chapter 3 of the Programmer’s Guide to MultiFinder. To use
this chapter, you should already be familiar with the material presented in those chapters of
Inside Macintosh.
The changes and additions to memory management on Macintosh computers described here are
available only in system software version 7.0. Support for 32-bit addressing is available only
on machines with 32-bit clean ROMs (for example, the Macintosh IIci and the Macintosh IIfx).
You can use the Gestalt function documented in the Compatibility Guidelines chapter of this
volume to determine whether a machine was started up with 32-bit addressing and whether
the enhanced temporary memory routines are available. Virtual memory is available only on
machines equipped with a memory management unit (MMU). Currently, these machines
include 68030-based machines (where the MMU

is built into the CPU) as well as 68020-based

machines that contain the 68851 Paged Memory Management Unit (PMMU). You can use the
Gestalt function to determine whether virtual memory is installed. Most applications, however,
do not need to know whether virtual memory is installed.
You need to read this chapter if your application
m uses any of the temporary memory routines available under MultiFinder in system
software version 6.0 and built into the Operating System in version 7.0
m has critical timing requirements, executes code at interrupt time, or performs debugging
operations, any of which might be affected by the presence of virtual memory
m is not 32-bit clean (that is, does not operate correctly in an environment that uses the full
32 bits of a pointer or handle for memory addresses)
m

uses customized window definitions (resources of type 'WDEF'’) or customized control

definitions (resources of type 'CDEF’)

m uses the StripAddress function documented in the Operating System Utilities chapter of
Volume V
m installs routines (such as Time Manager tasks, VBL tasks, Notification Manager tasks,
I/O completion routines, and so forth) that execute at interrupt time or at times when
your application is not the active application

About This Chapter

28-3

‘<7

|

-

|

Inside Macintosh,

Volume

V1

This chapter begins with an overview of memory management on Macintosh computers and
explains the connections between cooperative multitasking, the Memory Manager, virtual
memory, and your application’s use of its own private memory. This overview also describes
how the user controls various aspects of memory management through the Memory control
panel. The subsequent sections provide greater detail about 32-bit addressing, virtual
memory, and temporary memory.

ABOUT

MEMORY

MANAGEMENT

The Macintosh Operating System manages the loading of applications, desk accessories,
resources, and other code into and out of memory. Prior to the introduction of MultiFinder in
system software version 5.0, only one application could execute at a time. As a result, the
organization of the available physical memory was relatively simple, as shown below in
Figure 28-1. The available RAM was divided into two broad zones, a system zone and an
application zone. The system zone, which resides at the bottom of memory, contains room
for system global variables and a system heap. The system global variables maintain information about the operation of the Operating System itself (for example, the amount of time
elapsed since the system was started up). The system heap contains the executable code for
the Operating System, as well as some of the data structures used by the system software.
High memory
i

Jump table
Application parameters
—
Application globals

—

BufPtr

—— A§

QuickDraw globals
Application —
partition

y

Stack

A

Application heap

System —
partition
|

——

AppliLimit

—

ApplZone

System heap
System globals
Low memory

Figure 28-1. The memory organization in a single-application environment

28-4

About Memory Management

nN
of

Memory Management

i
—

@

=

=}

‘z.

When your application is launched, it is allocated a partition or heap of memory called the
application partition. That partition must contain required segments of the application code
as well as any other data associated with the application. You allocate space within your
application’s partition by making calls to the Memory Manager, either directly (for instance,
using the NewHandle function) or indirectly (for instance, using a routine like NewWindow
that calls Memory Manager routines). The Memory Manager controls the dynamic allocation
of space in your application’s heap.
The application partition is divided into three main parts: an application heap (which holds the
executable code of the application and perhaps some of the application’s resources), a stack,
and a set of parameters and global variables that are private to the application. This set includes

the application’s QuickDraw™ global variables, the application’s own global variables

and parameters, and a jump table. The divisions of the application partition are illustrated
in Figure 28-2.

ae

Jump table

ae ‘

Application parameters

;

pointer to

Globals

Stack
grows down

i

‘s

rr os

Application globals

es
i"

ApplLimit —

thePort

a

%
Heap

grows up
AppiZone

QuickDraw globals

"

’

‘

QuickDraw
globals

—

Figure 28-2. The organization of the application partition
The Operating System keeps track of information in the application partition by storing various
addresses in system global variables. For instance, the beginning of the application heap is
stored in the global variable AppIZone. Similarly, the system global variable CurrentA5 points
to the application parameters, the first long word of which is a pointer to the application’s
QuickDraw global variables.

About Memory Management

28-5

<<
2

a

gea7)
=—
@

=—_

Inside Macintosh,

Volume VI

Note that CurrentA5 points to a boundary between the application’s parameters and its global
variables, so the application’s own global variables are found as negative offsets from the
value of CurrentAS. This particular boundary is important because the Operating System uses
it as a way of accessing your application’s QuickDraw globals and application globals as well
as the application parameters and the jump table, both of which are fixed distances from that
boundary. This information is known collectively as the A5 world because the Operating
System uses the microprocessor’s A5 register to point to that boundary.
Note: An application’s global variables may appear either above or below
the QuickDraw global variables because the relative locations of these items
are linker-dependent.

Dividing

Memory

Among

Multiple Applications

In system software version 7.0 (or when running MultiFinder in system software versions
5.0 and 6.0), the user can have multiple applications open at once. The Operating System
organizes the available memory in a slightly different manner, as shown in Figure 28-3.
Here two applications are open, sharing the available memory.
When multiple applications are open, there are multiple application partitions, each with its
own copy of QuickDraw global variables, application global variables, and so forth. Each
application allocates and frees space within its own application zone by using Memory
Manager routines. Even though multiple applications are open, only one application at a time
can have control of the CPU. When your application is brought into the foreground or when
it receives processing time in the background, the Operating System ensures that certain lowmemory global variables have appropriate values and that the A5 register contains the address
of the boundary between your application’s parameters and global variables.
It sometimes happens, however, that your routines execute at times when the low-memory
global variables and the A5 register are not set up for your application. For instance, the
application in partition 2 (in Figure 28-3) might have installed a Time Manager task to run
periodically. That task can execute even though that application is not in control of the
processor because the Time Manager task executes at interrupt time. Problems may occur if
that task tries to access any information in its AS world, for register A5 might not be pointing
to its A5 world when the task is called. Accessing this information includes reading or
writing the values of the application’s global variables and QuickDraw global variables, as
well as calling subroutines that are in different segments (because different segments are
accessed through the jump table, which is part of the A5 world).
In a task or completion routine that may run even when the application that created it is not
the active process, you need to save and restore the value of the A5 register whenever you
access information in the application’s AS world. These tasks include all routines that execute
at interrupt time, such as Time Manager tasks, VBL tasks, Sound Manager completion
routines, I/O completion routines, device drivers, and so forth. You can use the two functions
SetCurrentA5 and SetAS5 to save and restore the value of the A5 register. See “Setting and
Restoring the A5 Register” later in this chapter for a detailed discussion of these functions.

28-6

About Memory Management

i)

eo

Memory Management

a

—_—_

<7)
_
—

——
-_
=

teax!
rd
—
aa
—
nn

High memory

—_—
—

a

ge
oe
=

_—

’

Jump table

—

BufP

—

A5

—

i.)
=
—

—

Application parameters
Application globals

QuickDraw globals

partition 2

v

Stack
Ss

“

s

+ar

+

1 | | i

Application —

A
f

ia

32

Application heap
Jump table
Application parameters

;
Application —

Application globals

partition 1

QuickDraw globals

y
ee

L

System
partition

A

Stack
A

ee

Application heap

System heap
System globals
Low memory

Figure 28-3. The memory organization in a multiple application environment

Extending

an Application’s Available

Memory

In the Macintosh multitasking environment, each application is limited to a particular memory
partition (the size of which is determined by information in the 'SIZE' resource of that application). The size of your application’s memory partition places certain limits on how big your
application heap can become and hence on how large the buffers and other data structures that
your application uses can be. If for some purpose you need more memory than is currently
available in your application heap, you can ask the Operating System to let you use any
available memory that is not yet allocated to any other application. This memory is known as
temporary memory and is allocated from the available unused RAM; in general, that
memory is not contiguous with the memory in the requesting application’s zone. Figure 28-4
shows an application using some temporary memory.

About Memory Management

28-7

Inside Macintosh, Volume VI

Your application should use temporary memory only for occasional short-term purposes that
could be accomplished in less space, though perhaps less efficiently. One good reason for
using temporary memory only occasionally is that you cannot assume that you will always
receive the temporary memory you request. For example, in Figure 28-3, all the available
memory is used by the two applications; any requests by either one for some temporary memory would fail.
High memory

BufPtr

LT

Td
will Mil

— —

Temporary memory
Jump table
Application parameters

——
Application globals

Application —

—

A5

QuickDraw globals

partition 1

y

Stack

A

Application heap

System heap

System

partition

System globals

Low memory
Figure

28-4.

Using

temporary

memory

Note that temporary memory is provided by the Operating System and not by the Memory
Manager (because the Memory Manager can allocate space only within your application heap
or the system heap). In system software version 7.0, however, you can free temporary
memory by using normal Memory Manager routines. In system software version 6.0, you
need to use special operating-system routines to allocate temporary memory. There are also
special routines to lock, unlock, and free temporary memory.

28-8

About Memory Management

nN

oe)

Memory Management

<

@

=

=)
Lg |
<4

Extending

the

Operating

System’s

Available

<2
rt

Memory

pe)

~

In system software version 7.0, suitably equipped Macintosh computers can take advantage
of an operating-system feature known as virtual memory, by which the machines have a
logical address space that extends beyond the limits of the available physical memory. This
means that a user can load more programs and data into the logical address space than if
limited to the actual physical RAM installed in the machine. The Operating System extends
the address space by using part of the available secondary storage (that is, part of a hard disk)
to hold portions of programs and data that are not currently needed in RAM. When some of
those portions of memory are needed, the Operating System swaps other parts of programs
or data that are not needed out to the secondary storage, thereby making room for the parts
that are needed.
It is important to realize that virtual memory operates transparently to most applications. You
allocate and release memory in your application heap exactly as you always have, by calling
Memory Manager routines. You can also request temporary memory by using special
Operating System routines. But unless your application has time-critical needs that might be
adversely affected by the operation of virtual memory, you do not need to know whether
virtual memory is operating.

Controlling

the System

Memory

Settings

A user can alter several of the system memory configuration settings by changing controls in
the Memory control panel. This panel contains controls governing the operation of the disk
cache, virtual memory, and the addressing used by the Memory Manager. Figure 28-5 shows
the Memory control panel.

Disk cache] |
panel

=

zs

[EJ
=

:

ecm

heise

Virtual Memory

panel

3]af

Select Hard Disk:

;

Virtual memory -

‘

Cache Size

—

@ on

©) off

co

loma prieta

Available on disk; 35M

we |

Total memory : 4M
After restart

—

H

H

32-bit addressing

cd

panel

User panel

a
32
=

—

v1.0

32-Bit Addressing
@
On

ee
5
32-bit address is off

©) off

(will be on after restart)

[ Use Defaults |

Figure 28-5. The Memory

control panel

About Memory Management

28-9

=
i)
@

=ad

@

=

—s

Inside Macintosh,

Volume VI

The Disk Cache panel is a replacement for the HFS RAM Cache panel found in earlier system
software versions in the General control panel. The controls allow the user to configure the
size of the disk cache used by the Operating System during file access operations. In system
software version 7.0, unlike earlier versions, the user cannot turn off disk caching.
A disk cache is a part of RAM that acts as an intermediate buffer when data is read from
and written to file systems on secondary storage devices. Data is saved there in case it is
needed again in the very near future. If it is, then the Operating System reads the data from
the disk cache and not from the secondary storage device (which would take considerably
longer). By increasing the cache size, the user can increase the likelihood that data recently
read from or written to the file system is still in the cache. The minimum cache size is 32 KB.
The default size is 32 KB per megabyte of installed RAM (so a machine with 4 MB of RAM
would have a default disk cache size of 128 KB). The maximum disk cache size is 128 KB
per megabyte of installed RAM (so a machine with 4 MB of RAM would have a maximum
disk cache size of 512 KB).

The Virtual Memory controls allow a user to set various features of virtual memory, including
whether virtual memory is turned on and, if so, how much virtual memory is available. The
user can also specify the volume of the backing-store file, the file used by the Operating
System to store unused portions of code and data. The user must restart the machine for any
changes to the virtual memory configuration to take effect. Note that the Virtual Memory panel
appears only on machines capable of supporting virtual memory.
The 32-Bit Addressing controls determine the size of the address space to use in the machine.
The size of the address space is determined by the number of bits used to store memory
addresses, as explained in the next section. The 32-Bit Addressing panel appears only on
machines capable of running with 32-bit addressing. The user can use these controls to turn
32-bit addressing off and on. Any changes made to the addressing will not take place until
the machine is restarted.

ABOUT

THE

MEMORY

MANAGER

On suitably equipped Macintosh computers, system software version 7.0 supports 32-bit
addressing, that is, the ability to use all 32 bits of a pointer or handle in determining
memory addresses. Earlier versions of system software use 24-bit addressing, where the
upper 8 bits of memory addresses are ignored or used as flag bits. In a 24-bit addressing
scheme, the logical address space has a size of 16 MB. Because 8 MB of this total are
reserved for I/O space, ROM, and slot space, the largest contiguous program address space
is 8 MB. When 32-bit addressing is in operation in system software version 7.0, the maximum program address space is | GB.
The ability to operate with 32-bit addressing is available only on certain models of the
Macintosh, namely those with ROMs that contain a 32-bit Memory Manager. (For

compatibility reasons, these ROMs also contain a 24-bit Memory Manager.) In order for
your application to work when the machine is using 32-bit addressing, it must be 32-bit
clean, that is, able to run in an environment where all 32 bits of a memory address are
significant. Fortunately, writing applications that are 32-bit clean is relatively easy if you
follow the guidelines given in /nside Macintosh. The major reason that some applications
are not 32-bit clean is that their developers have violated warnings not to manipulate data
structures directly. In particular, the single most common reason that some applications are
28-10

About the Memory Manager

nN

io)

Memory Management

=<
—
eo)

=

Ss

=“

“<<

not 32-bit clean is that they manipulate bits in master pointers directly (for instance, to mark
the associated memory blocks as locked or purgeable) instead of using Memory Manager
routines that achieve the desired result.
A

Pointers

The Memory Manager on the original Macintosh computers used a 24-bit addressing system.
To the underlying hardware, only the lower 24 bits of a 32-bit address were significant. The
upper 8 bits were always ignored in an address reference, a circumstance that led both system
software developers and third-party software developers to put those 8 bits to some other use.
For example, the Memory Manager itself took advantage of the upper 8 bits of an address in a
master pointer to maintain information about heap blocks. (Master pointers are pointers to
blocks of memory in the heap.) In the original Macintosh computers, the master pointers had
a structure illustrated in Figure 28-6.

4/615

Not used

Address of block's contents

Lock bit J

Purge bit —
Resource bit —

Figure 28-6. A master pointer structure in the 24-bit Memory Manager
Both A/UX® and system software version 7.0 support 32-bit addressing, where all 32 bits of
a memory address are significant. In this case, the flag bits in a master pointer must be stored
elsewhere. Applications do not need to know where or how those flags are now stored if they
use routines provided by the Memory Manager for setting and clearing those flags. (For
example, to set or clear the Lock flag, you should use the procedures HLock and HUnlock.)
If your application bypasses these routines and takes advantage of knowledge about the
structure of master pointers to set and clear the flag bits directly, then it will not execute
correctly in an environment where all 32 bits of the master pointer are significant. On such
systems, setting or clearing the upper 3 bits of a master pointer directly does not change the
flags but changes the address itself.
Note: The issue of being 32-bit clean is not limited to direct manipulation of a
master pointer’s flag bits. Rather, every memory address must contain a full 32 bits.
If, under systems using 24-bit addressing, you have used any of the upper 8 bits of
pointers or handles for anything other than part of an address, then you must find
an alternate representation for that information.
About the Memory Manager

iS)
@

=—_
=—

The following four sections provide more explanation of how to make sure that your application 1s 32-bit clean, with detailed discussion of several additional issues, including
customized window and control definition functions, and the StripAddress trap.

Master

om)
ge
@

Warning: You should never make assumptions about the contents of Memory
Manager data structures, including master pointers and zone headers. These
structures have changed in the past and they are likely to change again in the
future. a

Using

=ov)

— 28-11

Inside Macintosh,

Using

Volume VI

Window

and

Control

Definition

Functions

Two other times that you need to avoid 32-bit address violations are when using customized
window definition functions (stored in resources of type 'WDEF'’) and when using customized control definition functions (stored in resources of type 'CDEF'’). In earlier versions of
system software, the Window Manager stored the window variant code number (which

defines how the window looks) in the upper 8 bits of the handle to the window definition
procedure. Under version 7.0, this is no longer true. As a result, if you need to retrieve the
window variant code, use the GetW Variant function.
Similarly, the Control Manager used to store a variant code in the high bits of the control
definition procedure handle. This also has changed under system software version 7.0, so
you should use the GetC Variant function to retrieve the variant control value for a control.
A further problem arises if you define your own controls. To define a customized control,
you need to provide a control definition function that interprets messages indicating what
action your function is to perform. A customized control definition function is a function
having the following declaration:
FUNCTION

MyControl

(varCode:

Integer;

Integer;

param:

theControl:
LongInt)

:

ControlHandle;

message:

LongInt;

Previously, when passed the calcCRgns message, your control definition needed to test the
high-order bit of the param parameter to determine whether to return a handle to the region of
the control indicator or to the region of the entire control. In addition, your function had to
clear the high bit of that parameter before passing back a handle to the calculated region. As a
result, it was impossible to write a 32-bit clean control definition. The Control Manager in
system software version 7.0 has a new mechanism for instructing your control definition to
calculate control regions. In particular, two new messages have been defined:
CONST

calcCntlRgn

10:

{calculate

control's

calcThumbRgn

Lis

{calculate

indicator's

region}

region}

When the 32-bit Memory Manager is in operation, the Control Manager uses one of these
two new messages in cases where it would previously have used calcCRgns. When the
24-bit Memory Manager is in operation, the Control Manager still uses caleCRgns. If your
application uses customized control definitions, you should update it to support the new
messages as soon as possible. Because many users will still be running your application on
machines with 24-bit addressing, you should also continue to support caleCRgns.

Manipulating

24-Bit

and

32-Bit

Memory

Addresses

In environments where the machine might be executing with a 24-bit Memory Manager, it
is sometimes necessary to strip off the flag bits of a memory address before you use that

address. The Memory Manager provides the StripAddress function to allow you to do this.
FUNCTION

28-12

StripAddress

(address:

About the Memory Manager

UNIV

Ptr)

:

Ptr;

nN
2)

Memory Management

—a
@

=

2

Lew

|

<

The StripAddress function takes an address as a parameter and returns the value of the loworder 3 bytes if the 24-bit Memory Manager is operating. Otherwise, StripAddress returns
the full 32-bit address unchanged.

NuBus™

card. Suppose that this driver has an address in the heap (which is under the control of the
Memory Manager) to which it wants to transfer data. If a 24-bit Memory Manager is in
operation, the driver must call StripAddress on the heap address before using that address;
otherwise, the CPU would interpret the high byte of that heap address as part of the address
and (probably) transfer the data to the wrong address.

Even if you are not writing Macintosh drivers, you might still find it useful to call StripAddress.
Occasionally, you need to compare two memory addresses (for example, two master pointers).
If you’re using the 24-bit Memory Manager and you compare those addresses without first
stripping off the flag bits, you might end up with invalid results. You should call StripAddress
to convert those addresses to the correct format.
As you can see, the operation of StripAddress is not dependent on the 24-bit or 32-bit state of
the hardware, but on the 24-bit or 32-bit state of the Memory Manager. Calling StripAddress
is necessary only when a 24-bit Memory Manager is operating. When a 32-bit Memory
Manager is operating, StripAddress does nothing to addresses passed to it because those
addresses are already valid 32-bit addresses.
Sometimes drivers or other code must run in 32-bit mode to perform special hardware manipulations. You can use the Translate24To32 function to translate 24-bit addresses into 32-bit
addresses.

THE

MEMORY

MANAGER

In system software version 7.0, you can continue to use any memory management routines
documented in Volumes I, II, and IV, with two notable exceptions. The SetupA5 procedure
and the RestoreA5 procedure documented in the Operating System Utilities chapter of
Volume II do not work properly when used with some optimizing compilers. The MPW®
Version 3.0 (and later) development system provides two new functions, SetCurrentA5
and SetA5, that perform the same operations without the problems of the earlier procedures.
See “Setting and Restoring the A5 Register” for examples of using these two new functions.
If you are using a development system other than MPW, you can include inline function
definitions for these functions, as explained in “Manipulating AS Without MPW,” later in
this chapter.

Using the Memory Manager

=

ps

j=)

a7)

=—_—
=~

To appreciate the need for StripAddress, you need to distinguish between the addressing state
of the Memory Manager and the addressing state of the underlying hardware. Macintosh II
hardware, for example, is fully capable of handling all 32 bits of a memory address. For
consistency with earlier Macintoshes, the Macintosh II CPU spends most of its time in 24-bit
mode and ignores the high-order byte of all memory addresses. (The information encoded
there is of significance only to the Memory Manager, not to the CPU.) However, a driver

USING

=

@

Note: This discussion replaces the information about the StripAddress function in
the Operating System Utilities chapter of Volume V.

might temporarily switch the CPU to 32-bit mode to access a hardware address on a

=<
Lamal

—- 28-13

Inside Macintosh,

Volume VI

Several Memory Manager routines have changed to support operations on temporary memory
as well as memory allocated from your application’s heap. For example, you can now
dispose of temporary memory by calling DisposHandle. Changes to the Memory Manager
connected to temporary memory are discussed in “Using Temporary Memory,” later in this
chapter. The behavior of Memory Manager routines on blocks in your application’s heap
remains unchanged.

Setting and Restoring the A5 Register
Suppose you want to alert the user about something important that happens when your
application is running in the background. To do so, you can use the Notification Manager to
install a notification request. You request a notification by passing the Notification Manager
the address of a notification record, which contains information about the ways in which

the Notification Manager should alert the user. One of the fields in the notification record

(nmRefCon) is a reference constant that is reserved for your application’s use. When you
set up a notification request, you can use that field to hold the value in the A5 register.
Listing 28-1 illustrates how to save the current value in the A5 register and pass that value
to a response procedure.
Listing 28-1. Passing A5 to a notification response procedure
VAR

myNotif:
BEGIN

WITH

NMRec;

myNotif

BEGIN
qType

nmStr

nmType;
:=
:=

nmSound

1;
NIL;
:=

:=

nmResp
nmRefCon

notification

record}

DO

:=

nmMark
nmIcon

{a

Handle(-1);

NIL;
:=

{set

queue

type}

{put mark
in Application
{no alternating
icon}
{play
{no

system
alert

sound}

box}

@SampleResponse;

{set

response

:=

{pass

A5

SetCurrentA5;

alert

menu}

to

procedure}
notification

task}

END;
END;

The key step is to save the value of the CurrentA5 global variable in a location where the
response procedure can find it—in this case, in the nmRefCon field. You must call
SetCurrentAS5 at non-interrupt time (or else you cannot be certain that it is returning you
the correct value),

When the notification’s response procedure executes, the first thing it should do is set register
AS to the application’s value of CurrentA5. The response procedure needs to set up the application’s A5 because it may execute at a time when that application is not the active application.
Listing 28-2 shows a simple response procedure that sets up A5, modifies a global variable,
and then restores A5.,
You can use similar techniques with other routines that may execute when your application is
not in control of the CPU. However, not every manager provides such facilities for passing
the value of an application’s CurrentAS to a task or completion routine. For example, the
Time Manager task record does not contain a field that you can use to store this value. As a
28-14

— Using the Memory Manager

ce

or
<

Memory Management

pat

&

c

Listing 28-2. Setting up and restoring A5
PROCEDURE

SampleResponse

(nmReqPtr:

NMRecPtr)j;

VAR

OldA5:

LongIint;

‘

{AS

when

procedure

{set
{set

A5
an

{

show

is

called}

BEGIN

Ol1dA5
:= SetAS5(nmReqPtr®.nmRefCon);
g_NotifReceived
:= TRUE;
OoldA5

:=

SetA5(ol1dA5);

to

to the app's A5}
application
global

{restore

alert
AS

to

was

}

received}

original

value}

END;

Note: Many optimizing compilers (including MPW) may put the address of a global
variable into a register before the call to SetA5, thereby possibly generating incorrect
references to global data. To avoid this problem, you can divide your completion
routine into two separate routines, one to set up and restore A5 and one to do the
actual completion work. Check the documentation for your development environment
to see if this division is necessary, or contact Macintosh Developer Technical Support.

Manipulating

A5

Without

MPW

Note: If you are using MPW Version 3.0 or later, you do not need to be concerned
with the information in this section.
If you are not using the MPW Version 3.0 (or later) development system, you can achieve the
same results as SetCurrentA5 and SetA5 by including the following inline definitions:
FUNCTION

SetCurrentA5

INLINE
FUNCTION

SetA5

INLINE

$2E8D,

:

(newA5
$2F4D,

LongInt;

$2A78,
:

$0904;

LongiInt)

$0004,

:

LongInt;

S2A5F;

If you are programming in assembly language or are using a compiler that is not able to
handle multiple inline functions, you can use the following definitions:
SetCurrentA5

move. |
move.1

A5,4(A7)
currentA5,A5

;store
old
;set
A5 to

A5 as
function
result
low-memory
global

move.1
move. 1
move.l

(A7)+,A0
A5,4(A7)
(A7)+,A5

;save
return
address
;store old A5 as function
;set
A5 to passed
value

jmp

(AQ)

rts
SetA5

result

Using the Memory Manager

— 28-15

<Lend

g9
=
fo

quoWoS

result, you need to use other techniques to pass that value to a Time Manager task. See
“Using Application Global Variables in Tasks” in the Time Manager chapter in this volume
for an example of one technique for doing this.

=
<

Inside Macintosh,

MEMORY

Volume

VI

MANAGER

ROUTINES

You can use several utility routines to set and restore the A5 world and to manipulate memory
addresses. The routines documented in this section supplement the Memory Manager routines
documented in Volumes I, IT, and IV.

Setting and Restoring the A5 World
You can use the functions SetCurrentA5 and SetAS5 to save and restore your application’s A5
world. Use SetCurrentAS5 to get the current value of the system global variable CurrentAS.
FUNCTION

SetCurrentA5

:

LongIint;

The SetCurrentA5 function does two things: First, it gets your application’s A5 and returns it
to your application. Second, SetCurrentAS5 sets register A5 to the value of the application’s
low-memory global variable CurrentA5.
Use the SetA5 function to set the A5 register to the application’s A5.
FUNCTION

SetA5

(newA5:

LongInt)

:

LongInt;

Calling SetA5 performs two tasks: It sets the A5 register to the address specified as newAS5,
and it returns the actual address that is in register A5 before the function is called.

Manipulating

Memory

Addresses

The Memory Manager includes several routines that allow you to manipulate memory
addresses. The StripAddress function allows you to mask out the high-order byte of a
24-bit address to obtain an address that is meaningful to the 32-bit Memory Manager.
FUNCTION

StripAddress

(address:

UNIV

Ptr)

:

Ptr;

You can use the Translate24To32 function to translate 24-bit addresses into the 32-bit

address space.
FUNCTION

Translate24To32

(addr24:

UNIV

Ptr)

:

Ptr;

Unlike the StripAddress function, this function does not necessarily return an address that is
meaningful to the 24-bit Memory Manager.

28-16

| Memory Manager Routines

hn
ioe)

Memory Management

2vot
@

—
_

_~

-_~
=

“

a

ABOUT

VIRTUAL

<4

al
x

MEMORY

=
=
ve

@

=

Virtual memory is the part of system software version 7.0 that allows any Macintosh computer equipped with an MMU to extend the available amount of memory beyond the limits
of physical RAM. Virtual memory extends the logical address space by using part of the
available secondary storage (such as a hard disk) to hold portions of programs and data that
are not currently in use. When an application needs to operate on portions of memory that
have been transferred to disk, the Operating System loads those portions back into physical
memory by making them trade places with other, unused segments of memory. This process
of shuttling portions (or pages) of memory between physical RAM and the hard disk is
called paging.
For the most part, virtual memory operates invisibly to applications and to the user. Most
applications do not need to know whether virtual memory is installed unless they have
critical timing requirements, execute code at interrupt time, or perform debugging operations.
The only time that users need to know about virtual memory is when they configure it in
the Memory control panel. One visible cost of this extra memory is the use of an equivalent
amount of storage on a backing device, such as a SCSI hard disk. Another cost of using
virtual memory is a possible loss of speed as paged-out segments of memory are pulled back
into physical memory. Performance degradation when using virtual memory ranges from
unnoticeable to severe, depending on the ratio of virtual to physical RAM and the behavior
of the actual applications running.
The principal benefit of using virtual memory is that users can run more applications at once
and work with larger amounts of data than would be possible if the logical address space
were limited to the available RAM. Instead of equipping a machine with amounts of RAM
large enough to handle all possible needs, a user can install only enough RAM to meet
average needs. Then, when more memory is occasionally needed for large tasks or many
applications, virtual memory can provide the extra amount of memory required. When virtual
memory is present, the perceived amount of RAM can be extended to as much as 14 MB on
systems with 24-bit addressing and as much as | GB on systems with 32-bit addressing.
There are two main requirements for running virtual memory. First, the Macintosh must be
running system software version 7.0. Second, the Macintosh must be equipped with an
MMU or PMMU. Apple’s 68030-based machines have an MMU built into the CPU and are
ready to run virtual memory with only a software upgrade to version 7.0; no additional
hardware is needed. A Macintosh II (68020-based) can take advantage of virtual memory if

it has the 68851 PMMU coprocessor on its main logic board in place of the standard address
management unit. (The PMMU is the same coprocessor needed to run A/UX.) Apple's
68000-based machines cannot take advantage of the virtual memory capability of version 7.0,
even though they can run version 7.0 if they have at least 2 MB of RAM.
Users control and configure virtual memory through the Memory control panel. Controls
in this panel allow the user to turn virtual memory on or off, set the size of virtual memory,
and set the volume on which resides the invisible backing-store file (the file that the Operating
System uses to store the contents of non-resident portions of memory). Other memory-related
user controls are combined in this control panel. These include settings for the disk cache and
for 24-bit or 32-bit Memory Manager addressing. If users change the virtual memory,
addressing, or disk cache settings, they must restart the machine in order for the changes
to take effect.

About Virtual Memory

— 28-17

~
@

=

-_

Inside Macintosh,

Volume

VI

Note that the amount of virtual memory that users select in the control panel is the total amount
of memory that is to be available to the system (and not simply the amount of memory to be
added to available RAM). Also, the backing-store file is as large as the amount of virtual

memory. This backing-store file might be located on any HFS volume that allows block-level
access. (This volume is known as the paging device or backing volume.) Because the
paging device must support block-level access, users cannot select as the paging device a
volume that they mount using AppleShare®. Also, users cannot select removable disks,
including floppy disks, as paging devices.

USING

VIRTUAL

MEMORY

The routines described in this section allow drivers and applications with critical timing needs
to intervene in the otherwise automatic workings of the virtual memory paging mechanism.
Note: The vast majority of applications do not need to use these routines. They are
used primarily by drivers, debuggers, and other interrupt-servicing code.
If necessary, your software can request that a range of memory be held in physical memory.
Holding means that the specified memory range cannot be paged out to disk, although it
might be moved around within physical RAM. As a result, no page faults can result from
reading or writing memory addresses of pages that are held in memory.
Similarly, a page or range of pages can be locked into physical memory. Locking means that
the specified memory cannot be paged out to disk and that the memory cannot change its real
(physical) RAM location. (Locking, therefore, is a superset of holding.) You can also request
that a range of pages be locked into contiguous physical memory, although contiguity is not
guaranteed. Locking pages into contiguous physical memory is used primarily when external
hardware transfers data directly into physical RAM. This might be useful for keeping a
contiguous range of memory stationary during operations of an external CPU (on a NuBus
card, for example) that cannot support a DMA action.
Most applications do not need to hold or lock pages into physical RAM because the operation
of virtual memory is usually fast enough that your application is not affected by any delay that
might result from paging. Software that does need to hold or lock pages, such as drivers or

sound and animation applications with critical timing requirements, normally needs only to hold
memory, not lock it. Here are some general rules regarding when to hold or lock memory:

m Avoid executing tasks that could cause page faults at interrupt time. The less work done
at interrupt time, the better things are for all applications running.
m

You cannot hold or lock memory (or call any other Memory Manager routine) at
interrupt time.

= Don’t lock or hold everything in RAM. Sometimes either holding or locking pages in
RAM is essential, but if you are ever in doubt, then probably neither one is needed.
a Whatever is held or locked must be explicitly unheld or unlocked by the application. If
for some reason an area of RAM gets held and locked, or held twice, then it must be
unheld and unlocked, or unheld twice.

28-18

— Using Virtual Memory

nN

oa)

Memory Management

=
=
5

a

This last directive is especially important. Your application is responsible for undoing any of
the effects it causes by locking or holding ranges of memory. In particular, virtual memory
does not automatically unlock pages that have been locked down. If you do not undo these
effects in a timely fashion, you are likely to cause poor performance. In the worst case, you
could cause the system to run out of physical memory.

Holding

and

Releasing

Memory

You can use the HoldMemory function to make a portion of the address space resident in
physical memory and ineligible for paging. This function is intended primarily for use by
drivers that access user data buffers at interrupt level, whether transferring data to or from
them. Calling HoldMemory on the appropriate memory ranges thus prevents them from
causing page faults at interrupt level. The contents of the specified range of virtual addresses
can move in physical memory, but they are guaranteed always to be in physical memory
when accessed.
Note: If you use the device-level Read and Write functions when doing data
transfers, the Operating System automatically ensures that the data buffers are
held down before the transfer of data.
The following sample code instructs the Operating System to hold in RAM the range of
memory that starts at address $32500 and that is 8192 bytes long.
myAddress
myLength

:=

myErr

HoldMemory

:=

:=

$32500;
8192;
(myAddress,

myLength) ;

Note that holding is applied to whole pages of the virtual address space, regardless of the
starting address and length parameters you supply. If the starting address parameter supplied
to the HoldMemory function is not on a page boundary, then it is rounded down to the nearest
page boundary. Similarly, if the specified range does not end on a page boundary, the length
parameter is rounded up so that the entire range of memory is held. This rounding might result
in the holding of several pages of physical memory, even if the specified range is less than a
page.
To release memory that was held down using HoldMemory, you must use the UnholdMemory
function, which simply reverses the effects of the HoldMemory function. For example, the
pages held in memory in the previous example can be released as follows:
myErr

:=

UnholdMemory

(myAddress,

myLength) ;

As with holding, letting go is applied to whole pages of the virtual address space. Similar
rounding of the address and length parameters is performed as required to keep the range
on page boundaries.
Note:

The system heap is always held in memory and is never paged out.

Using Virtual Memory

28-19

<

+S)

=

oe

to)

a)

=<7)

=}
~e

Inside Macintosh,

Volume

Locking

Unlocking

and

VI

Memory

You can use the LockMemory function to make a portion of the address space immovable in
physical memory and ineligible for paging. The Operating System may move the contents of
the specified range of logical addresses to a more convenient location in physical memory
during the locking operation, but on completion, the contents of the specified range of logical
addresses are resident and do not move in physical memory.
LockMemory is used by drivers and other code when hardware other than the Macintosh
CPU is transferring data to or from user buffers, such as any NuBus master peripheral card
or DMA hardware. This function prevents both paging and physical relocation of a specified
memory area and enables the physical addresses of a memory area to be exported to the nonCPU hardware. Typically, you would use this service for the duration of a single I/O request.
However, you could use this service to lock data structures that are permanently shared
between driver or other code and a NuBus master.
Note: Do not confuse locking addresses in RAM (using LockMemory) with locking
a handle (using HLock). A locked handle can still be paged out.
The main reason to disable movement of pages in physical memory is to translate virtual
addresses to physical addresses. This translation is needed by bus masters, which must
write to memory in the physical address space. To avoid stale data, the memory locked in
RAM is marked noncacheable in the CPU cache.
You can lock a range of memory into contiguous physical memory by using the
LockMemoryContiguous function. This function is used by driver and NuBus master
or driver and DMA hardware combinations when a non-CPU device accessing memory
is unable to handle physically discontiguous data transfers. You can also use this service
when it is possible to handle physically discontiguous data transfers, but doing so causes
performance degradation. However, the call to LockMemoryContiguous may be expensive
because entire pages might need to be copied in order to make a range contiguous.
Note: It might not be possible to make a range physically contiguous if
any of the pages contained in the range are already locked. Because a call to
LockMemoryContiguous is not guaranteed to return the desired results, all
code that uses LockMemoryContiguous must have an alternate method for
locking the necessary ranges of memory.
To unlock a range of previously locked pages, use the UnlockMemory function. This
function reverses the effects of LockMemory or LockMemoryContiguous. Unlocked
pages are marked as cacheable.
Locking, contiguous locking, and unlocking operations are applied to ranges of the logical
address space. If necessary to force the ranges onto page boundaries, the Operating System
performs rounding of addresses and sizes, as described in the previous section, “Holding
and Releasing Memory.”

28-20

Using Virtual Memory

nN

io

Memory Management

=<7)
=

o

as}
<4

Obtaining

Information

About

Virtual

S

Memory

1)

~

If your application or driver needs to use the virtual memory routines described so far, you
might also need to obtain information about the operation of virtual memory. You can get two
kinds of information: information about the system memory configuration and information
about the page-mapping employed by virtual memory. Use the Gestalt function for the first
sort of information, and use the GetPhysical function for the second sort.

Information

About

the

System

Memory

Configuration

To obtain information regarding the system memory configuration, use the Gestalt function,
which is documented in the Compatibility Guidelines chapter of this volume. Gestalt can
provide information about the amount of physical memory installed in a machine, the amount
of logical memory available in a machine, the version of virtual memory installed (if any),
and the size of a logical page. By obtaining this information from Gestalt, you can help
insulate your applications or drivers from possible future changes in the details of the virtual
memory implementation.
You should always determine whether virtual memory is installed before attempting to use the
services it provides. To do this, pass Gestalt the gestaltVMAttr selector. Gestalt’s response
indicates the version of virtual memory, if any, installed. If bit 0 of the response is set to I,
then the system software version 7.0 implementation of virtual memory is installed.

Information

About

Page

Mapping

To obtain information about page mapping between logical and physical addresses, use the
GetPhysical function. GetPhysical translates logical addresses into their corresponding
physical addresses. It provides drivers with actual physical memory addresses of pages in a
specified logical address range. This information is needed to permit non-CPU devices to
access memory mapped by the CPU. Mapping information is needed to enable data transfers
by non-CPU devices to physically discontiguous memory by means of external software or
hardware mapping mechanisms.
The GetPhysical routine takes as one of its parameters a parameter block with a table to store
pairs of physical addresses and counts.
TYPE

MemoryBlock
RECORD
address:
count:

=
Ptr;
LongiInt

{start
of block}
{size of block}

END;

The translation table is an array of ordered pairs of addresses and counts. GetPhysical
translates up to the size of the table or until the translation is completed, whichever
comes first.

Using Virtual Memory

— 28-21

pe)

ge
@

=

<7)

=}

-

Inside Macintosh, Volume VI

If you call GetPhysical with a table size of 0, it returns the number of table entries necessary
to translate the entire address range. On exit, the virtual information is updated to indicate the
next virtual address and the number of bytes left to translate. If the translation is incomplete,

the same translation table can again be passed to GetPhysical to continue the translation of the
remaining addresses. The return value from the routine indicates the number of pairs of
physical addresses and counts actually placed in the translation table.
The translation parameter block consists of two elements, the virtual information and the
physical translation table, and is defined as follows:
TYPE

LogicalToPhysicalTable

=

RECORD

logical:
physical:

MemoryBlock;
{logical block}
ARRAY [0..defaultPhysicalEntryCount-1]

OF

MemoryBlock
{equivalent

physical

blocks}

END;

The information is stored as an ordered pair of address and count. The physical translation
table is an array of address and count pairs that define sections of physical memory
representing the virtual address range input parameter. On exit, the virtual information is
updated to reflect the address range that was not translated. The virtual address field contains
the next virtual address to be translated, and the virtual count field has the number of bytes

left to be translated. The parameter count is used to indicate the size of the translation table
array. The actual count value is the number of physical ordered pairs that can be returned in
the translation table. Passing in the size of the table allows the calling software to adjust the
table size to fit its application. Calling software can then make the necessary trade-offs
between memory and complexity versus the overhead for multiple calls.
When GetPhysical returns, the physicalEntryCount parameter contains the number of address
and count pairs that were filled into the translation table. In addition, if physicalEntryCount
contained 0, the total number of entries required to map the entire logical space is returned
(and the contents of the table are unchanged). Listing 28-3 provides an example of using

GetPhysical.

Listing 28-3. Translating logical to physical addresses
VAR

table:

myErr:
numPhysicalBlocks:

LogicalToPhysicalTable;

OSErr;
Integer;

BEGIN

table.logical.address
table.logical.count
WHILE

:=
:=

table.logical.count

bufferAddress;
bufferSize;
<>

0

{virtual
address}
{bytes
in buffer}

DO

BEGIN

END;

numPhysicalBlocks
:= SIZEOF(table)
DIV SIZEOF(MemoryBlock)
myErr
:= GetPhysical(table,
numPhysicalBlocks) ;
IF myErr <> noErr
THEN DoError(myErr);
aRoutine(table,
numPhysicalBlocks) ;
{your routine
to }
{ process
results}

END;

28-22.

—_ Using Virtual Memory

1;

nN
o 2)

Memory Management

<=

=

i)

er 4

Note: The address range passed to GetPhysical must be locked (using LockMemory).
This is necessary to guarantee that the translation data returned are accurate (that is, that
paging activity has not invalidated the translation data). An error is returned if you call
GetPhysical on an address range that is not locked.

Deferring

User

Interrupt

Handling

During the time that the Macintosh is handling a page fault, it is critical that no other page
faults occur. Since no other work is explicitly done by the system while it is handling a page
fault, the only code that can cause this to occur is code that runs as a result of an interrupt.
Consequently, the HoldMemory function must be called on buffers or code that are to be
referenced by any interrupt service routine. You must call this function at non-interrupt level
because the MemoryDispatch calls may cause movement of memory and possible I/O.
The use of procedure pointers (ProcPtrs) in specifying I/O completion routines, socket

listeners, and so forth makes it impossible for drivers to know the exact location and size

of all code or buffers that might be referenced when invoking these routines. However,
these routines must still be called only at a safe time, when paging is not currently in
progress. Because the locations of all needed pages cannot be known, an alternate strategy
is used to prevent a fatal double page-fault condition.
The DeferUserFn routine is provided to allow interrupt service routines to defer, until a safe
time, code that might cause page faults. DeferUserFn determines whether the call can be
made immediately and, if it is safe, makes the call. If a page fault is in progress, the address
of the service routine and its parameter are saved, and the routine is deferred until page faults
are again permitted.

Debugger

Support

Under

Virtual

Memory

Note: You need the information in this section only if you are writing a debugger
that is to operate under virtual memory.
Debuggers running under virtual memory can use any of the virtual memory routines
discussed in the previous sections. For example, if a debugger is in a situation where
page faulting would be fatal, it can use DeferUserFn to defer the debugging until paging
is safe. However, debuggers running under virtual memory might require a few routines
that differ from those available to all applications. In addition, debuggers might depend
on some specific features of virtual memory that other applications should not.
For example, because debugger code might be entered at a time when paging would be
unsafe, you should lock (and not just hold) the debugger and all of its data and buffer
space in memory. Normally, the locking operation is used to allow NuBus masters or
other DMA devices to transfer data directly into physical memory. This requires that data
caching be disabled on the locked page. You might, however, want your debugger to
benefit from the performance of the data cache on pages belonging solely to the debugger.
The DebuggerLockMemory function does exactly what LockMemory does, except that it
leaves data caching enabled on the affected pages. The DebuggerUnlockMemory function
reverses the effects of DebuggerLockMemory.

Using Virtual

Memory

— 28-23

t<
2—
fo
=)
£9

ga

:

©

=_

Inside Macintosh,

Volume VI

Other special debugger support functions determine whether paging is safe, allow the
debugger to enter supervisor mode, enter and exit the debugging state, obtain keyboard
input while in the debugging state, and determine the state of a page of logical memory.
All of these functions are implemented as extensions of the DebugUtil trap, a new trap
intended for use by debuggers to allow greater machine independence. This trap is not
present in the Macintosh II, Macintosh ITx, Macintosh IIcx, or Macintosh SE/30, but it
is present in all later ROMs. Virtual memory implements this trap for all machines that it
supports, so a debugger can use DebugUtil (and functions defined in terms of Debug Util)
if Gestalt reports that virtual memory is present.
When the virtual memory extensions to DebugUtil are not present (that is, the machine
supports virtual memory but is not a Macintosh II, Macintosh IIx, Macintosh IIcx, or
Macintosh SE/30), DebugUtil provides functions that can determine the highest DebugUtil
function supported, enter the debugging state, poll the keyboard for input, and exit the
debugging state.
You can call DebugUtil to determine how many of the debugger functions or extensions are
present. The DebuggerGetMax function returns the highest function number supported by
the DebugUtil trap. The numbers correspond to the following functions:
Selector

Routine

$0000
$0001
$0002
$0003
$0004
$0005
$0006

DebuggerGetMax
DebuggerEnter
DebuggerExit
DebuggerPoll
GetPageState
PageFaultFatal
DebuggerLockMemory

$0008

EnterSupervisorMode

$0007

Bus

DebuggerUnlockMemory

Error

Vectors

When a page of memory is read in from disk, it is triggered by a bus error (this kind of bus
error is called a page fault). The Operating System needs to intercept these page faults and do
the necessary paging. In addition, various applications and pieces of system software need to
handle other kinds of bus errors. Virtual memory takes care of the complications of bus error
handling by having two bus error vectors. The vector that applications and other system
software see is the one in low memory (at address $8). The vector that virtual memory uses
(the one actually used by the processor) is in virtual memory’s private storage and is pointed
to by the vector base register (VBR). Virtual memory’s bus error handler handles page faults
and passes other bus errors to the vector in low memory at address $8.
When a debugger wants the contents of a page to be loaded into memory, it can read a byte
from that page. The Operating System detects the page fault and loads the appropriate page
(perhaps swapping another page to disk).
Note that a debugger will probably temporarily replace one or both of the bus error vectors
while it is executing. A debugger that wants virtual memory to continue paging while the
debugger runs can put a handler only in the low-memory bus error vector. A debugger that
28-24

Using Virtual Memory

nN
io)

Memory Management

<‘c)

z
“

<

displays memory without allowing virtual memory to continue paging can put a handler in
the virtual memory’s bus error vector (at VBR+$8).

Nonmaskable

Interrupt

bs)

Needs

Since a debugger can be triggered with a nonmaskable interrupt (level 7, triggered by the
interrupt switch), it has special needs that other code in the system does not. For example,
because a nonmaskable interrupt might occur while virtual memory is moving pages around
(to make them contiguous, for example), debugger code must be locked down (instead of
held, like most other code that must run at a time when page faults would be fatal). Unfortunately, the LockMemory function is intended for use by device drivers and automatically
disables data caching for the locked pages. Because this is not desirable for the debugger,
the debugger support functions DebuggerLockMemory and DebuggerUnlockMemory lock
pages without inhibiting the caching of those pages. Note that both the stack, code, and
other storage used by the debugger might need to be locked in this way.

Supervisor

Mode

Because a debugger is typically activated through one of the processor vectors, it normally
executes in supervisor mode, allowing it access to all of memory and all processor registers.
When the debugger is entered in another way—for example, through the Debugger or
DebugStr trap or when it is first loaded—it is necessary to enter supervisor mode. You can
accomplish this with the following assembly-language instructions:
MOVEQ

EnterSupervisorMode,D0

_DebugUtil

70S

trap

;on

exit,

to
DO

DebugUtils
holds

old

SR

This code switches the caller into supervisor mode. The previous status register is returned in
register DO so that when the debugger returns to the interrupted code, the previous interrupt
level, condition codes, and so forth, can be restored. When the debugger is ready to return to
user mode, it simply loads the status register with the result returned in DO.

The

Debugging

—

=}

tf)

Because the current version of virtual memory is not reentrant, there are times when trying to
load a page into memory would be fatal. To allow for this, you can use the PageFaultFatal
function to determine whether a page fault would be fatal at that time. If this function returns
TRUE, the debugger should not allow the virtual memory’s bus error handler to detect any
page faults. This means that the virtual memory’s bus error vector should always be replaced
if the PageFaultFatal function returns TRUE.

Special

a

ph)

State

When activated by an exception, Debug or DebugStr trap, or any other means, the debugger
should call DebuggerEnter to notify DebugUtil that the debugger is entering the debugging
state. Then DebugUtil can place hardware in a quiescent state and prepare for subsequent
DebugUtil calls.
Before returning to the interrupted application code, the debugger must call DebuggerExit to
allow DebugUtil to return hardware affected by DebuggerEnter to its previous state.

Using Virtual Memory

— 28-25

ie

=}
@

=}a

Inside Macintosh,

Keyboard

Volume VI

Input

A debugger can obtain the user’s keyboard input by using the DebuggerPoll procedure. This
routine can obtain keyboard input even with interrupts disabled. After you call this service,
you must then obtain keyboard events through the normal event queue mechanism.

Page

States

Debuggers need a way to display the contents of memory without paging or to display the
contents of pages that are currently on disk. The GetPageState function returns the state
of a page containing a virtual address. GetPageState returns one of these values:
TYPE

PageState

CONST

=

Integer;

kPageInMemory

=

0;

{page

is

in

RAM}

kPageOnDisk

=

1;

{page

is

on

disk}

kNot

=

2

{address

is

not

Paged

paged}

A debugger can use this information to determine whether certain memory addresses should
be referenced. Note that ROM and I/O space are not pageable and therefore are considered
not paged.

VIRTUAL

MEMORY

ROUTINES

This section describes the routines you can use to hold logical pages in physical memory and
let go of them, lock and unlock pages in physical memory, obtain information about pagemapping, and handle interrupts. It also describes the routines that pertain primarily to
debuggers; you can use those routines to determine the state of a page, determine whether
a page fault would be fatal, enter the supervisor mode, enter and exit the debugging state,
and obtain keyboard input while in the debugging state. You can also use special debugger
versions of the routines that lock and unlock pages in memory.

Holding

and

Releasing

Pages

The HoldMemory function makes a portion of the address space resident in physical memory
and ineligible for paging.
FUNCTION

HoldMemory

(address:

28-26

Virtual Memory Routines

UNIV

Ptr;

count:

LongInt)

:

OSErr;

nN
oO

Memory Management

K<
a

:

o
i)

a

Trap macro
On entry
On exit

<4

_MemoryDispatch
DO: selector code
AO: address
Al: count
DO: result code

A

=
~
eS)
oe

is
=)
@

=}
—

The address parameter is the start address of the range of memory that is to be held in RAM,
and count is the size in bytes of that range. If the starting address parameter supplied to the
HoldMemory function is not on a page boundary, then it is rounded down to the nearest page
boundary. Similarly, if the specified range does not end on a page boundary, the count
parameter is rounded up so that the entire range of memory is held.
Result codes

noErr
paramErr
notEnoughMemoryErr
interruptsMaskedErr

0)
—5()
—620
—624

No error
Error in parameter list
Insufficient physical memory
Called with interrupts masked

The UnholdMemory function makes eligible for paging again a portion of the address space
that is currently held. This function reverses the effects of HoldMemory.
FUNCTION

UnholdMemory

Trap macro
On entry
On exit

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

_MemoryDispatch
DO: selector code
AO: address
Al: count
DO: result code

The address parameter is the start address of the range that is to be let go, and count is the
size in bytes of that range. If the starting address parameter supplied to the UnholdMemory
function is not on a page boundary, then it is rounded down to the nearest page boundary.
Similarly, if the specified range does not end on a page boundary, the count parameter is
rounded up so that the entire range of memory is let go.
Result codes

noErr
paramErr
notHeldErr
interruptsMaskedErr

0
—50
—62|
—624

No error
Error in parameter list
Specified range of memory is not held
Called with interrupts masked

Virtual

Memory Routines

— 28-27

Inside Macintosh,

Volume

Locking

Unlocking

and

VI

Pages

The LockMemory function makes a portion of the address space immovable in physical
memory and ineligible for paging.
FUNCTION

LockMemory

Trap macro
On entry
On exit

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

_MemoryDispatch
DO: selector code
AO: address
Al: count
DO: result code

The address parameter is the start address of the range that is to be locked in RAM, and count
is the size in bytes of that range. If the starting address parameter supplied to the LockMemory
function is not on a page boundary, then it is rounded down to the nearest page boundary.
Similarly, if the specified range does not end on a page boundary, the count parameter is
rounded up so that the entire range of memory is locked. Locked pages are marked noncacheable by the CPU.
Result codes

noErr
paramErr
notEnoughMemoryErr
interruptsMaskedErr

0
—50
-—620
—624

No error
Error in parameter list
Insufficient physical memory
Called with interrupts masked

The LockMemoryContiguous function is exactly like the LockMemory function, except that it
attempts to obtain a contiguous block of physical memory associated with the logical address
range specified.
FUNCTION

LockMemoryContiguous

Trap macro
On entry
On exit

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

_MemoryDispatch
DO: selector code
AO: address
Al: count
DO: result code

The address parameter is the start address of the range that is to be locked in RAM, and count
is the size in bytes of that range. If the specified address is not on a page boundary, it is
rounded down to the nearest page boundary. Similarly, if the specified range does not end on
a page boundary, the count parameter is rounded up so that the entire range of contiguous
memory is locked. Locked pages are marked noncacheable by the CPU.

28-28

Virtual Memory Routines

nN
KH

Memory Management

Result codes

noErr
paramErr
notEnoughMemoryErr
cannotMakeContiguousErr
interruptsMaskedErr

0
—50
—620
—622
—624

<

SS

No error
Error in parameter list
Insufficient physical memory
Cannot make specified range contiguous
Called with interrupts masked

=

coal

ge
©
=_
o
=

ts

The UnlockMemory function makes a portion of the address space movable in real memory
and eligible for paging again. It undoes the effects of both LockMemory and
LockMemoryContiguous.
FUNCTION

UnlockMemory

Trap macro
On entry

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

_MemoryDispatch
DO: selector code
AO: address
Al: count

On exit

DO: result code

The address parameter is the start address of the range that is to be unlocked, and count is the
size in bytes of that range. If the specified address is not on a page boundary, it is rounded
down to the nearest page boundary. Similarly, if the specified range does not end on a page
boundary, the length parameter is rounded up so that the entire range of memory is unlocked.
Result codes

noErr
paramErr
notLockedErr
interruptsMaskedErr

Obtaining

0
—50
—623
—624

Page-Mapping

No error
Error in parameter list
Specified range of memory is not locked
Called with interrupts masked

Information

The GetPhysical function translates logical addresses into their corresponding physical
addresses.
FUNCTION

GetPhysical

Trap macro
On entry
On exit

(VAR

addresses:

VAR

physicalEntryCount:

LogicalToPhysicalTable;
LongInt)

:

OSErr;

_MemoryDispatchAOResult
DO: selector code
AO: addresses
A]: physicalEntryCount in table
AO: physicalEntryCount translated
DO: result code
Virtual

Memory Routines

<
—
o
=ad
Ss
S|
a

28-29

Inside Macintosh,

Volume VI

The addresses parameter is a translation table, that is, an array of ordered pairs (address
and count). The physicalEntryCount parameter specifies the number of physical entries to
translate. GetPhysical translates up to the size of the table or until the translation is completed,
whichever comes first. If GetPhysical is called with a table size of 0, the number of table
entries needed to translate the entire address range is returned. On exit from this function,

the virtual information is updated to indicate the next virtual address and the number of

bytes left to translate. The logical address range must be locked to ensure validity of the
translation data.
Result codes

noErr
paramErr
notLockedErr
interruptsMaskedErr

Deferring

User

0
—50
—623
—624

Interrupt

No error
Error in parameter list
Specified range of memory is not locked
= Called with interrupts masked

Handling

You can use the DeferUserFn function to determine whether code that might cause page faults
can safely be called immediately. If the code can be called safely, then it is called. If a page
fault is in progress, however, the routine address and its parameter are saved, and the routine
is deferred until page faults are again permitted.
FUNCTION

DeferUserFn

(userFunction:

Trap macro

_DeferUserFn

On exit

AO: function
DO: result code

On entry

ProcPtr;

argument:

UNIV

Ptr)

:

OSErr;

DO: argument

You pass DeferUserFn the address of the routine that you want to run and a pointer to the
argument to pass to the specified routine. The specified routine is called with register AO
containing the value of the argument parameter to the DeferUserFn call. Note that the routine
can be called immediately (before returning to the caller of DeferUserFn). Deferred functions
must follow the register conventions used by interrupt handlers: they may use registers
AO-A3 and DO-D3, and must restore all other registers used.
Result codes
noErr

cannotDeferErr

Determining

Which

0

—625

Debugger

No error

Unable to defer additional user functions

Functions

Are

Present

The DebuggerGetMax function returns a long integer indicating the highest function number
supported by the DebugUtil trap.
28-30

Virtual Memory Routines

nN
o2)

Memory Management

4

Lonel

a)

=

i)

“|

<<

a

FUNCTION

DebuggerGetMax:

LongInt;

—

ts)
=}
eS)
go

we
=

Trap macro
On entry
On exit

7)
=

_DebugUtil
DO: selector
DO: highest available selector

oe

The returned value is the highest selector number of the debugger functions that are defined in
terms of the DebugUtil trap. See “Debugger Support Under Virtual Memory” earlier in this
chapter for a complete list of these numbers.

Determining

Whether

Paging

Is Safe

A debugger can use the PageFaultFatal function to determine whether it should capture all bus
errors or whether it is safe to allow them to flow through to virtual memory. When paging is
safe, the debugger can allow virtual memory to continue to service page faults, thus allowing
the user to view all of memory.
FUNCTION

PageFaultFatal:

Trap macro
On entry
On exit

Boolean;

_DebugUtil
DO: selector
DO: returned value

If this function returns TRUE, then the debugger should not allow the virtual memory’s bus
error handler to detect any page faults.

Locking and

Unlocking

Memory

With Caching

Enabled

The DebuggerLockMemory function performs the same operations as LockMemory, except
that it leaves data caching enabled on the affected pages.
FUNCTION

DebuggerLockMemory

Trap macro
On entry
On exit

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

_DebugUtil
DO: selector code
AO: address
Al: count
DO: result code

Virtual Memory Routines

—_ 28-31

Inside Macintosh,

Volume VI

The address parameter is the start address of the range that is to be locked in RAM, and
count is the size in bytes of that range. If the starting address parameter supplied to the
DebuggerLockMemory function is not on a page boundary, then it is rounded down to the
nearest page boundary. Similarly, if the specified range does not end on a page boundary,
the length parameter is rounded up so that the entire range of memory is locked.
Result codes

noErr
paramErr
notEnoughMemoryErr

0
—50
—620

No error
Error in parameter list
Insufficient physical memory

The DebuggerUnlockMemory function reverses the effects of DebuggerLockMemory.
FUNCTION

DebuggerUnlockMemory

(address:

UNIV

Ptr;

count:

LongInt)

OSErr;

Trap macro

_DebugUtil

On exit

AO: address
Al: count
DO: result code

On entry

DO: selector code

DebuggerUnlockMemory makes the portion of the address space starting with address and
continuing for count bytes movable in physical memory and eligible for paging again.
Unlocking is applied to whole pages of the virtual address space. Unlocked pages are marked
as cacheable.
Result codes

noErr
paramErr
notLockedErr

Entering and

0
—50
—623

No error
Error in parameter list
Specified range of memory is not locked

Exiting the Debugging

State

The two procedures DebuggerEnter and DebuggerExit allow you to enter and exit the
debugger state. These calls allow the DebugUtil trap to make preparations for subsequent
debugging calls and to clean up after all debugging calls are completed.
PROCEDURE

DebuggerEnter;

PROCEDURE

DebuggerExit;

Trap macro
On entry
28-32

_DebugUtil
DO: selector code

Virtual Memory Routines

nm
io <)

Memory Management

a

La)

7)

=—_
S
<<
a
oy
~*~

Obtaining

Keyboard

Input

S
ge

A debugger can use the DebuggerPoll procedure to poll for keyboard input.

ia)

lon
ww
a7)

PROCEDURE

=—

DebuggerPoll;

Trap macro
On entry
On exit

_DebugUtil
DO: selector code
DO: result code

The DebuggerPoll procedure can be used even if interrupts are disabled.

Determining

Page

State

The GetPageState function returns the state of a page of logical memory.
FUNCTION

GetPageState

Trap macro
On entry
On exit

(address:

UNIV

Ptr)

:

PageState;

_DebugUtl
DO: selector code
AO: address
DO: page state

The address parameter specifies an address in the page whose state you want to determine.
The returned value is one of these constants:
CONST

ABOUT

kPageInMemory

=

kPageOnDisk
kNot

Paged

TEMPORARY

0;

{page

is

in

RAM}

=

Ls

{page

is

on

disk}

2

2s

{adaress

is

not

paged}

MEMORY

To operate efficiently with other applications in the system software version 7.0 environment,
your application should contain a 'SIZE' resource that specifies both a minimum and a
preferred memory partition size. The actual partition size allocated to your application upon
launch is set to the preferred size if that much contiguous memory is available, or to some
smaller size if that much contiguous memory is not available. Note that once the application is
launched, its partition cannot change i in size, so the application’s heap must always remain
within some predetermined limit.
About Temporary Memory

— 28-33

Inside Macintosh,

Volume VI

Rather than specify a preferred partition size that is large enough to contain the largest possible application heap, you should specify a smaller but adequate partition size. When you need
more memory for temporary use, you can use a set of temporary memory allocation services
provided by the Operating System. The memory allocated using these services is known as
temporary memory.
By using the temporary memory allocation routines, your application can request some
additional memory for occasional short-term needs. For example, the Finder™ uses these
temporary memory routines to secure buffer space to be used during file copy operations.
Any available memory (that is, memory currently unallocated to any application’s partition)
is dedicated to this purpose. The Finder releases this memory as soon as the copy is completed, thus making the memory available to other applications or to the Operating System
for launching new applications.
Because the requested amount of memory might not be available, you should not rely on
always getting the memory you need when you issue a temporary memory request. You
should make sure that your applications still work even if no temporary memory is available
when you request it. For example, if the Finder cannot allocate a large temporary copy
buffer, it performs the copying using a reserved small copy buffer from within its own heap
zone. While the copying might take longer, it is nonetheless performed.
In system software version 6.0, any memory you allocated using the temporary memory
routines had to be released before your next call to GetNextEvent or WaitNextEvent. In
addition, you had to perform all operations on that temporary memory by using specialized
MultiFinder routines rather than the usual Memory Manager routines. In version 7.0, both of
these restrictions have been relaxed (though not completely removed). The memory you
allocate using the temporary memory routines can now be used for longer intervals and does
not need to be released before the next call to WaitNextEvent. In version 7.0, you can think
of temporary memory simply as an extension of your application’s heap. You should still use
temporary memory for as short a time as possible, and you must release that memory before
your application terminates.
Because temporary memory is taken from RAM that is reserved for (but not yet used by)
other applications, you might prevent the user from being able to launch other applications
by using too much temporary memory or by holding temporary memory for long periods of
time. You can hold temporary memory indefinitely, however, in certain circumstances. For
example, if the temporary memory is used for open files and the user can free that memory
simply by closing those files, it is safe to hold onto that memory as long as necessary. But
you should make sure not to lock temporary memory across event calls.
Temporary memory is tracked (or monitored) for each application, so you must use it only
for code that is running on an application’s behalf. Moreover, because the Operating System
frees all temporary memory allocated to an application when it quits or crashes, you should
not use temporary memory for procedures such as VBL tasks or Time Manager tasks that you
want to continue running after the application quits. Similarly, it is wise not to use temporary
memory for interprocess buffers (that is, a buffer whose address is passed to another
application in a high-level event) because the originating application could crash, thereby
causing the temporary memory to be released before (or even while) the receiving application
uses that memory.

28-34

About Temporary Memory

Nm

> 2)

Memory Management

2

—

@

_

~~
—
~
=
—

ta

Another main difference between temporary memory routines under version 6.0 and
version 7.0 is that although you must still allocate temporary memory by using special routines, you can release and otherwise manipulate it by using normal Memory Manager
routines. Even though you don’t know where the additional memory comes from, you are
encouraged to operate on that memory in the same way that you manipulate memory
allocated from the application or system heaps. In short, temporary memory allocation
remains specialized, but operations on existing temporary blocks can be performed by using
Memory Manager routines.
Under system software version 7.0, the following Memory Manager routines work even if
the handle or pointer is allocated by one of the temporary memory routines.
DisposHandle
Empty Handle

GetHandleSize
HandleZone
HClIrRBit
HGetState
HLock

HNoPurge

HPurge
HSetRBit

HSetState
HUnlock
ReallocHandle
RecoverHandle
SetHandleSize

Prior to system software version 7.0, you need to use these seven routines on temporary
memory:
TempFreeMem
TempMaxMem
TempDisposeHandle
TempHLock

TempHUnlock
TempNewHandle
TempTopMem

Note: In system software version 6.0, these routines have the following
names: MFFreeMem,

MFMaxMem,

MFTempDisposHandle, MFTempHLock,

MFTempHUnlock, MFTempNewHandle, MFTopMem. For compatibility,
you can continue to use these names.

Note that TempDisposeHandle, TempHLock, TempHUnlock, and TempTopMem are now
obsolete, although they still work (for the sake of compatibility).
A

Warning: Although you can determine the zone from which the temporary
memory is generated (using HandleZone), do not use this information to make
new blocks or perform heap operations on your own. a

Some of these routines rely on the current zone if the handle has been purged. They have
been made to work correctly in this case, even if the current zone is the application or system
zone and the handle is from a temporary block.
The Gestalt function includes several selectors that return information about the temporary
memory routines. See “Determining Features of Temporary Memory” later in this chapter
for examples of using Gestalt in this manner.

About Temporary Memory

— 28-35

a

>

—
—

—_

f°

©a

t i>)
a
—_

©

om

—
~

Inside Macintosh,

USING

Volume VI]

TEMPORARY

MEMORY

You can use temporary memory routines to determine how much memory is available for
temporary allocation, to allocate blocks of memory for temporary use, to lock and unlock
relocatable blocks of temporary memory, and to release memory previously allocated for
temporary use.
As indicated in “About Temporary Memory,” you do not need to use the special temporary
memory routines to lock, unlock, or release temporary memory blocks if your application is
executing under system software version 7.0. Instead, you can employ the usual Memory
Manager routines to accomplish those tasks. You can use temporary memory longer under
version 7.0 than under version 6.0. Before taking advantage of these two new features,
however, you should make sure that they are present. Methods for doing this are presented
in “Determining Features of Temporary Memory,” later in this chapter.

Allocating Temporary

Memory

You can request a block of memory for temporary use by calling the TempNewHandle
function. This function attempts to allocate a new relocatable block of the specified size for
temporary use. For example, to request a block that is one-quarter megabyte in size, you
might issue these commands:
mySize

:-

myHandle

$40000;
:=

{one-quarter

megabyte}

TempNewHandle(mySize,

myErr) ;

If the routine succeeds, it returns a handle to the block of memory. The block of memory
returned by a successful call to TempNewHandle is unlocked. If an error occurs and the
routine fails, it returns a NIL handle. You should always check for NIL handles before using
any temporary memory. If you detect a NIL handle, the second parameter (in this example,
myErr) contains the result code from the function.

Instead of asking for a specific amount of memory and then checking the returned handle to
see if you actually got it, you might prefer to determine beforehand how much temporary
memory is available. There are two functions that return information on the amount of free
memory available for allocation using the temporary memory routines. First, you can use the
TempFreeMem function, as follows:
memFree:
memFree

LongInt;
{amount
:= TempFreeMem;

of

free

temporary

memory}

The result is a long integer containing the amount of free memory, in bytes, available for
temporary allocation. It usually isn’t possible to allocate a block of this same size because
of fragmentation due to nonrelocatable or locked blocks. Consequently, you'll probably
want to use the function TempMaxMem to determine what is the largest contiguous block
of space available. To allocate that block, you can write:
mySize

:=

myHandle

28-36

TempMaxMem(myGrow) ;
:=

TempNewHandle(mySize,

— Using Temporary Memory

myErr);

nN
oo

Memory Management

<—
oc)
=
S
“
<<
=<
eal
ey
=
mh
—

TempMaxMem compacts the heap zone and returns the size in bytes of the largest contiguous
free block available for temporary allocation. (TempMaxMenm is therefore analogous to
MaxMem; see the discussion of MaxMem in the Memory Manager chapter of Volume II for
full details on MaxMem.) The myGrow parameter is a variable parameter of type Size; after
the function is called, it always contains 0 because the temporary memory does not come from
the application’s heap. Even when you use TempMaxMem to size that available memory, you
should check the handle returned to make sure that is it not NIL.
The temporary memory routines include the TempTopMem function, originally designed to
help you determine how much memory is available in the current executing environment.
TempTopMem returns a pointer to the top of the addressable RAM space. Note that the return
value indicates the total amount of usable machine memory, not the amount of memory available to your application, so you should not use TempTopMem to calculate the size of your
application’s memory partition. Because you can determine the amount of available memory
by using the Gestalt function (using the gestaltLogicalRAMSize selector), you should
consider the TempTopMem function to be obsolete.

Locking

Temporary

Memory

Under system software version 7.0, you can lock a relocatable block of temporary memory
by calling the Memory Manager procedure HLock, thereby preventing that block from being
moved within the heap zone. In system software version 6.0, you can do this by using the
TempHLock procedure.

Unlocking

Temporary

Memory

To unlock a specified relocatable block of temporary memory, you can use the HUnlock
procedure. Once again, you can accomplish the same result in system software version 6.0
by calling the TempHUnlock procedure.

Releasing

Temporary

Memory

When you finish using a block of memory that you allocated using TempNewHandle, you
can release it by calling the DisposHandle routine.
In system software version 6.0, you can free temporary memory blocks by calling the
TempDisposeHandle procedure.

Determining

Features

of Temporary

Memory

Because the temporary memory routines are present only on systems that are running
MultiFinder (or on systems in which the functionality of MultiFinder is a standard part of
the Operating System) and because the features of those routines have changed in system
software version 7.0, you should always check that those routines are available and that
they have the features you require before calling them. This is easy to do if the Gestalt
function is available because Gestalt includes a selector to determine whether those routines
are present in the operating environment and, if they are, whether the temporary memory
handles are real (that is, whether you can use the normal Memory Manager routines to
manipulate them) and whether those handles are tracked. It is also possible to determine
whether the routines are available even if the Gestalt function is not available.
Using Temporary Memory

— 28-37

ge

=

©
=

-

Inside Macintosh,

Volume

V1

You can determine whether the temporary memory routines are implemented by checking the
return value of the TempMemCallsA vailable function that is defined in Listing 28-4.
Listing 28-4. Determining whether temporary memory routines are available
FUNCTION

TempMemCallsAvailable:

CONST
_OSDispatch

=

SA88F;

Boolean;

{trap

number

of

temp

memory

routines}

VAR
myErr:
myRsp:

OSErr;
LongInt;

{result
code
returned
{response
returned
by

BEGIN
TempMemCallsAvailable
IF gHasGestalt
THEN

:=

FALSE;
{gHasGestalt

is

set

by Gestalt}
Gestalt}

by

other

code}

BEGIN

myErr
IF

:=

myErr
DoError

Gestalt(gestaltOSAttr,
<>

noErr

myRsp) ;

THEN

(myErr)

ELSE
TempMemCallsAvailable

:=

BitTst(myRsp,

gestaltTempMemSupport) ;

END

ELSE

{Gestalt

TempMemCallsAvailable

:=

is

not

available}

TrapAvailable(_OSDispatch) ;

END;

The TrapAvailable function is defined in the Compatibility Guidelines chapter of this volume.
You can use similar code to determine whether temporary memory handles are real and
whether the temporary memory is tracked (that is, you can hold temporary memory until your
application terminates).

TEMPORARY

MEMORY

ROUTINES

This section describes the routines you can use to allocate temporary memory, lock temporary
memory blocks into RAM, unlock locked blocks, free temporary memory, and obtain infor-

mation about the amount of temporary memory available. Remember that most of these

routines can be replaced in system software version 7.0 by their normal Memory Manager
counterparts.

Requesting

Temporary

Memory

To find out how much memory is available for temporary use, you can use either
TempFreeMem or TempMaxMem.
FUNCTION

TempFreeMem

:

LongInt;

TempFreeMem returns the total amount of free memory available for temporary allocation
using TempNewHandle. The returned value is a long integer that indicates the total number
of bytes free.
28-38

— Temporary Memory Routines

ho

oo

Memory Management

a
—
@
=

—
oa
lon)
=

teLes |

TempMaxMem compacts the heap zone and returns the size of the largest contiguous block
available for temporary allocation.
FUNCTION

TempMaxMem

(VAR

grow:

Size)

:

Size;

a

om
$9
—
~
pS)
go
)
i
=)
a)
vag

—

~

—

a

—

The grow parameter always contains 0 after the function call because the temporary memory
does not come from the application’s heap.
You use TempNewHandle to allocate a new relocatable block of temporary memory.
FUNCTION

TempNewHandle

(logicalSize:

Size;

VAR

resultCode:

OSErr)

Handle;

TempNewHandle returns a handle to a block of size Size. The first parameter indicates how
many bytes you wish the block to contain. The second parameter contains the result code
from the function call.
Result codes
noErr

memFullErr

Locking

and

0

No error

-—108

Not enough memory

Unlocking

Temporary

Memory

You can use TempHLock to lock a specified relocatable block of temporary memory, thereby
preventing it from being moved within the heap zone.
PROCEDURE

TempHLock

(h:

Handle;

VAR

resultCode:

OSErr);

The first parameter is a handle to the block to be locked, which you must have obtained by a
call to TempNewHandle. TempHLock returns a result code in its second parameter.
Result codes

noErr
nilHandleErr
memWZErr

0)
-—109
-111

No error
NIL master pointer
Attempt to operate on a free block

In system software version 7.0, you can use the Memory Manager routine HLock to lock
temporary memory blocks.
You can use TempHUnlock to unlock a block of temporary memory. Once it is unlocked,
that block is allowed to move memory locations as needed to compact the heap.
PROCEDURE

TempHUnlock

(h:

Handle;

VAR

resultCode:

OSErr);

The first parameter is a handle to the block to be unlocked, which must have been obtained by
a call to TempNewHandle. TempHUnlock returns a result code in its second parameter.
Temporary Memory Routines

— 28-39

Inside Macintosh,

Result codes

noErr
nilHandleErr
memWZErr

Volume VI

0
—109
-—-I11

No error
NIL master pointer
Attempt to operate on a free block

Under system software version 7.0, you can use the Memory Manager routine HUnlock to
unlock temporary memory blocks.

Freeing

Temporary

Memory

You can use TempDisposeHandle to release the memory occupied by a relocatable temporary
memory block.
PROCEDURE

TempDisposeHanadle

(h:

Handle;

VAR

resultCode:

OSErr);

The first parameter is a handle to the block to be freed, which you must have obtained by a
call to TempNewHandle. TempDisposeHandle returns a result code in its second parameter.
Result codes
noErr
memWZErr

-111

0

No error
Attempt to operate on a free block

In system software version 7.0, you can use the Memory Manager routine DisposHandle to
free temporary memory blocks.

28-40

Temporary Memory Routines

c
2)
~y

Memory Management

—

@

e

OF

MEMORY

<

2

—

MANAGEMENT

&

a
Cet
as
~

JUDUIIS

SUMMARY

oad
—
—
=
~
_
7

Constants
CONST

gestaltAddressingModeAttr

=

‘addr';

gestalt32BitAddressing

=

04

gestalt32BitSysZone

=

1;

gestalt32BitCapable

=

is

gestaltOSAttr

=

A668

gestaltTempMemSupport

=

A;

gestaltRealTempMemory

=

gestaltTempMemTracked

=

gestaltVMAttr

=

‘vm

gestaltVMPresent
{default

number

=
of

{32-bit compatible
{machine is 32-bit

sys. zone}
capable}

53

{O/S attributes}
{temp memory
support
{temp memory
handles

present}
are real}

€%

{temp

tracked}

Q;5
blocks

physical

defaultPhysicalEntryCount

{addressing
mode attributes}
{booted
in 32-bit mode}

“s

';

memory

handles

{virtual

memory

attributes}

{virtual

memory

present}

in

table}

=

8;

kPageInMemory

=

OF

{page

is

in

RAM}

kPageOnDisk

=

ds

kNot

=

2s

{page
is
{address

on
is

disk}
not paged}

calcCnt1lRgn

=

10;

{calculate

control's

calcThumbRgn

=

Ais

{calculate

indicator's

{page

states}

Paged

Data

Types

TYPE

PageState
MemoryBlock

=

region}

region}

Integer;

=

RECORD
address:

Ptr;

count:

Longint

{start
of block}
{size of block}

END;

LogicalToPhysicalTable

RECORD
logical:
physical:

=

{logical
block}
MemoryBlock;
OF MemoryBlock
ARRAY[0..defaultPhysicalEntryCount-1]
{equivalent
physical
blocks}

END;

Summary of Memory Management

28-41

Inside Macintosh,

Memory

Volume VI

Manager

Routines

Setting and Restoring the A5 World
FUNCTION

SetCurrentA5

:

FUNCTION

SetA5

(newA5:

Manipulating

Memory

LongiInt;
LongInt)

:

LongInt;

Addresses

FUNCTION

StripAddress

(address:

FUNCTION

Translate24To32

(addr24:

Virtual

Memory

Holding

and

UNIV

Ptr)

UNIV

:

Ptr)

:

Ptr;
Ptr;

Routines

Releasing

Pages

FUNCTION

HoldMemory

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

FUNCTION

UnholdMemory

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

Locking

and Unlocking

Pages

FUNCTION

LockMemory

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

FUNCTION

LockMemoryContiguous

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

FUNCTION

UnlockMemory

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

Obtaining
FUNCTION

Page-Mapping

GetPhysical

Information

(VAR

addresses:

LogicalToPhysicalTable;

physicalEntryCount:

Deferring
FUNCTION

28-42

User

Interrupt

DeferUserFn

LongInt)

:

VAR

OSErr;

Handling
(userFunction:
OSErr;

Summary of Memory Management

ProcPtr;

argument:

UNIV

Ptr)

nN
oo)

Memory Management

—

io)

=
_
i)

Lew

Determining
UNCTION

Which

Debugger

DebuggerGetMax

:

Functions

Are

<

Present

2

—

pa
=
a
ge

ic)

LongInt;

=os
i)

=

=

Determining
FUNCTION

Whether

Paging

PageFaultFatal

Locking

and

:

Is Safe

Boolean;

Unlocking

Memory

With Caching

Enabled

FUNCTION

DebuggerLockMemory

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

FUNCTION

DebuggerUnlockMemory

(address:

UNIV

Ptr;

count:

LongInt)

:

OSErr;

Entering

and

PROCEDURE

DebuggerEnter;

PROCEDURE

DebuggerExit;

Obtaining
PROCEDURE

Keyboard

the

Debugging

State

Input

DebuggerPoll;

Determining
FUNCTION

Exiting

Page

State

GetPageState

(address:

Temporary

Memory

Requesting

Temporary

UNIV

Ptr)

:

PageState;

Routines
Memory

FUNCTION

TempFreeMem

:

LongiInt;

FUNCTION

TempMaxMem

(VAR

FUNCTION

TempNewHandle

(logicalSize:
Handle;

grow:

Size)

:

Size;

Size;

VAR

resultCode:

OSErr)

Summary of Memory Management

28-43

4

Inside Macintosh,

Volume

Locking

and

Unlocking

PROCEDURE

TempHLock

(h:

Handle;

VAR

resultCode:

OSErr) ;

PROCEDURE

TempHUnlock

(h:

Handle;

VAR

resultCode:

OSErr);

Freeing

Temporary

Memory

PROCEDURE

TempDisposeHandle

Result

VI

(h:

Handle;

Memory

VAR

resultCode:

OSErr);

Codes

noErr
memFullErr
nilHandleErr
memWZEtr
notEnoughMemoryErr
notHeldErr
cannotMakeContiguousErr
notLockedErr
interruptsMaskedErr
cannotDeferErr

QO
-108
-109
-l11
—620
—621
-622
-623
—624
-625

Assembly-Language
Trap

Temporary

Macros

Noetror
Not enough memory
NIL master pointer
Attempt to operate on a free block
—_ Insufficient physical memory
Specified range of memory is not held
Cannot make specified range contiguous
Specified range of memory is not locked
Called with interrupts masked
— Unable to defer additional user functions

Information

Requiring

Routine

_MemoryDispatch
Selector

Routine

$0000
$0001
$0002
$0003
$0004

HoldMemory
UnholdMemory
LockMemory
UnlockMemory
LockMemoryContiguous

_MemoryDispatchAOResult
Selector

Routine

$0005

GetPhysical

28-44

Summary of Memory Management

Selectors

bo
or

Memory Management

<o

ij

-_—

o

Ler 4

A

_DebugUul
Selector

Routine

$0000
$0001
$0002
$0003
$0004
$0005
$0006
$0007
$0008

DebuggerGetMax
DebuggerEnter
DebuggerExit
DebuggerPoll
GetPageState
PageFaultFatal
DebuggerLockMemory
DebuggerUnlockMemory
EnterSupervisorMode

£9
=|
o
veo
==

©

mt

-

_OSDispatch
Selector

Routine

$0015
$0016
$0018
$001D
$OOLE
SOO1F
$0020

TempMaxMem
TempTopMem
TempFreeMem
TempNewHandle
TempHLock
TempHUnlock
TempDisposeHandle

Summary of Memory Management

28-45

Inside Macintosh,

28-46

Volume VI

bt
S
lel

NNR
ee
Ree

NHL W
BRODNAADNDAMNNOWOOANA

PROCESS

MANAGEMENT

om

S

w
|

i]

3°)
NM
~”

<
fo
=
=
re

L el

About This Chapter
About Process Management
How the Process Manager Creates Processes
How the Process Manager Schedules Processes
How Your Application Specifies Scheduling Options
Using the Process Manager
Opening or Printing Files Based on Finder Information
Getting Information About Other Processes
Launching Other Applications
Specifying Launch Options
Controlling Launched Applications
Launching Desk Accessories
Process Manager Routines
Getting Process Information
Launching Applications and Desk Accessories
Summary of Process Manager Routines

S
@

==

29-]

Inside Macintosh,

29-2

Volume VI

Process Management
nN
=

ABOUT

THIS

~
en

CHAPTER

So
eT)
@®

~D
M

—<
lo

This chapter describes how process management in version 7.0 provides a cooperative multitasking environment. The Process Manager manages access to shared resources and the

scheduling and execution of applications. The Finder™ uses the Process Manager to launch

your application in response to the user opening either your application or a document created
by your application. This chapter discusses how your application can control its execution
and get information about itself or any other open application, such as the number of free
bytes in the application’s heap.
Read this chapter for an overview of how the Process Manager schedules applications and loads
applications into memory. If your application needs to launch other applications, read this chapter for information on the new high-level function that lets your application launch other
applications.
Although earlier versions of system software provide process management, the Process
Manager is available to your application only in system software version 7.0. The
Process Manager provides a cooperative multitasking environment, similar to the features
provided by the MultiFinder® option in earlier versions of system software. Use the Gestalt
function to find out if the Process Manager routines are available and to see which features
of the launch routine are available.
The information in this chapter about the Finder information supplements the description in
the Segment Loader chapters of Inside Macintosh, Volume II and Volume IV.
The information in this chapter about launching applications replaces the corresponding
discussion in the Programmer’s Guide to MultiFinder.
You should be familiar with how your application uses memory, as described in the Memory
Management chapter of this volume, and with how your application receives events, as
discussed in the Event Manager chapter of this volume.
This chapter provides an introduction to process management and then describes how
you can
= control the execution of your application
m get information about your application
a

launch other applications or desk accessories

= get information about applications launched by your application
= generate a list of all open applications and information about each one

About This Chapter

29-3

=

=

~
ve
co

=—_

is")

=sets

Inside Macintosh,

ABOUT

Volume VI

PROCESS

MANAGEMENT

The Process Manager schedules the processing of all applications and desk accessories, and
allows multiple applications to share the CPU and other resources. Applications share the
available memory and access to the CPU. Several applications can be open (loaded into
memory) at once, but only one uses the CPU at any one time.
The Process Manager manages the scheduling of processes. A process is an open application or, in some cases, an open desk accessory. (Desk accessories that are opened in the
context of an application are not considered processes.) In version 7.0, the number of
processes is limited only by available memory.
The Process Manager maintains information about each process—for example, the current
state of the process, the address and size of its partition, its type, its creator, a copy of its
low-memory globals, information about its 'SIZE' resource, and a process serial number.
This process information is referred to as the context of a process. The Process Manager
assigns a process serial number to identify each process. A process serial number
identifies a particular instance of an application; this number is unique during a single boot
of the local machine.
The foreground process is the one currently interacting with the user; it appears to
the user as the active application. The foreground process displays its menu bar, and its
windows are in front of the windows of all other applications.
A background process is a process that isn’t currently interacting with the user. At any
given time a process is either in the foreground or the background; a process can switch
between the two states at well-defined times.
The foreground process has first priority for accessing the CPU. Other processes can access
the CPU only when the foreground process yields time to them. There is only one foreground process at any one time. However, multiple processes can exist in the background.
An application that is in the background can get CPU time but can’t interact with the user
while it is in the background. (However, the user can choose to bring the application to the
foreground—for example, by clicking in one of the application’s windows.) Any application
that has the canBackground flag set in its 'SIZE' resource is eligible to obtain access to the
CPU when it is in the background.
Applications can be designed without a user interface. A background-only application is
an application that does not have a user interface. A background-only application does not call
the InitWindows routine and is identified by having the onlyBackground flag set in its 'SIZE'
resource. Background-only applications do not display windows or a menu bar and are not
listed in the Application menu.
Background-only applications and applications that can run in the background should be
designed to relinquish the CPU often enough so that the foreground process can perform
its work and respond to the user.

29-4

About Process Management

Process Management
bn

‘S

Once an application is executing, in either the foreground or the background, the CPU is
available only to that application. The application can be interrupted only by hardware
interrupts, which are transparent to the scheduling of the application. However, to give
processing time to background applications and to allow the user to interact with the foreground application or switch to another application, you must periodically relinquish the
CPU using the WaitNextEvent or EventAvail functions. (You can also use the GetNextEvent
function; however, you should use WaitNextEvent to provide greater support for multitasking.) Use these Event Manager functions to let the user interact with your application and
also with other applications.

How

the Process

Manager

Creates

Processes

When a user first opens your application, the Process Manager creates a partition for it. A
partition is a contiguous block of memory that the Process Manager allocates for the
application’s use. The partition is divided into specific areas: application heap, A5 world, and
stack. The application heap contains the application’s 'CODE' segment 1, data structures,

resources, and other code segments as needed. The A5 world refers to the QuickDraw™

globals, application global variables, and its jump table, all of which are accessed through the
A5 register. The application jump table contains one entry for every externally referenced
routine in every code segment of your application. The application stack is used to store
temporary variables. See the Memory Management chapter of this volume for illustrations of
these areas of your application’s partition.
When you create an application, you specify in the 'SIZE' resource how much memory you
want the Process Manager to allocate for your application’s partition. You specify two values:
the preferred amount of memory to allocate, and the minimum amount of memory to allocate.
When a user opens your application from the Finder, the Process Manager first attempts to
allocate a partition of the preferred size. If your application cannot be launched in the preferred amount of memory, the Finder displays a dialog box giving the user the option of
opening the application using less than the preferred size. The Finder will not launch your
application if the minimum amount of memory specified for your application is not available.
After the Process Manager creates a partition for your application, the Process Manager loads
your code into memory and sets up the stack, heap, and A5 world (including the jump table)
for your application. If the user selected one or more files to open or print, the Finder sets up
information your application can use to determine which files to open or print.
The Process Manager assigns the application a process serial number, records its context, and
returns control to the launching application (usually the Finder). The Process Manager transfers control to the new application after the launching application makes a subsequent call to
WaitNextEvent or EventAvail.

The next section describes how your application can allow other applications to receive CPU
time and how the Process Manager schedules CPU time among processes.

About Process Management

29-5

—
w
eae

SC

$7)
”
MN

i

=

mS

Ge

g

=

@

=—

Inside Macintosh,

How

the

Volume VI

Process

Manager

Schedules

Processes

Your application achieves control of how it receives processing time by using the Event
Manager functions WaitNextEvent or EventAvail. By calling these Event Manager functions,
your application agrees to yield the CPU. (Only at this well-defined time can your application
be switched out.) Whenever your application calls one of these functions, the Process Manager
checks the status of your process and takes the opportunity to schedule other processes.
Note: Your application can also yield processing time to other processes as a result
of calling other Toolbox routines that internally call WaitNextEvent or EventAvail.
For example, your application can yield the CPU to other processes as a result of
calling either of the Apple Event Manager functions AESend or AEInteractWithUser.
See the Apple Event Manager chapter for information on using these two functions.
In general, if any events are pending for your application, it continues to receive processing
time. When your application is the foreground process, it yields time to other processes in
these situations: when the user wants to switch to another application or when no events are
pending for your application. Your application can also choose to yield processing time to
other processes when it is performing a lengthy operation.
A major switch occurs when the Process Manager switches the context of the foreground
process with the context of a background process (including the A5 worlds and low-memory
globals) and brings the background process to the front, sending the previous foreground
process to the background.
When your application is the foreground process and the user chooses to work with another
application (by clicking in a window of another application, for example), the Process
Manager sends your application a suspend event. When your application receives a suspend
event, it should prepare to suspend foreground processing, allowing the user to switch to the
other application. For example, in response to the suspend event, your application should
remove the highlighting from the controls of its frontmost window and take any other
necessary actions. Your application is actually suspended the next time your application calls
WaitNextEvent or EventAvail.
After your application receives the suspend event and calls WaitNextEvent or EventAvail, the
Process Manager saves the context of your process, restores the context of the process to
which the user is switching, and sends a resume event to that process.
In response to a resume event, your application should resume processing and start interacting with the user. For example, your application should highlight the controls of its
frontmost window.
A major switch also occurs when the user hides the active application (by using the Application
menu). In general, a major switch cannot occur when a modal dialog box is the frontmost
window. However, a major switch can occur when a movable modal dialog box is the
frontmost window.
A minor switch occurs when the Process Manager switches the context of a process to
give time to a background process without bringing the background process to the front.
For example, a minor switch occurs when no events are pending in the event queue of
the foreground process. In this situation, processes running in the background have an
29-6

About Process Management

Process Management
bo
\©

opportunity to execute when the foreground process calls WaitNextEvent or EventAvail.
(If the foreground process has one or more events pending in the event queue, then the
next event 1s returned and the foreground process again has sole access to the CPU.)

a")
Lae |
i)

ra
©
WM
NM

When an application is switched out in this way, the Process Manager saves the context of
the current process, restores the context of the next background process scheduled to run,
and sends the background process an event. At this time, the background process can receive
either update, null, or high-level events.
A background process should not perform any task that would significantly limit the ability of
the foreground process to respond quickly to the user. A background process should call
WaitNextEvent often enough to let the foreground process be responsive to the user. Upon
receiving an update event, the background process should update only the content of its
windows. Upon receiving a null event, the background process can use the CPU to perform
tasks that do not require significant amounts of processing time.
The next time the background process calls WaitNextEvent or EventAvail, the Process Manager
saves the context of the background process and restores the context of the foreground process
(if the foreground process is not waiting for a specified amount of time to expire before being
scheduled again). The foreground process is then scheduled to execute. If no events are
pending for the foreground process and it is waiting for a specified amount of time to expire,
the Process Manager schedules the next background process to run. The Process Manager
continues to manage the scheduling of processes in this manner.
In version 7.0, drivers and VBL tasks in the system heap are scheduled regardless of which
application is currently executing. Drivers installed in an application’s heap are not scheduled
to run when the application is not executing.
See the Compatibility Guidelines chapter and the Event Manager chapter in this volume for
specific information on how your application can handle suspend and resume events and how
your application can take advantage of the cooperative multitasking environment.

How

Your Application

Specifies Scheduling

Options

Whenever your application calls WaitNextEvent or EventAvail, the Process Manager checks
the status of your process and takes the opportunity to schedule other processes. Using the
WaitNextEvent function, you can control when your process is eligible to be switched out.
The sleep parameter to WaitNextEvent specifies a length of time, in ticks, during which the
application relinquishes the CPU if no events are pending. For example, if you specify
15 ticks in the sleep parameter and no events are pending in your application’s event queue
when you call WaitNextEvent, the Process Manager saves the context of your process and

schedules other processes until an event becomes available or the time expires. Once the
specified time expires or an event becomes available for your application, your process
becomes eligible to run and the Process Manager schedules your process to run at the next
available chance. You can also use the WakeUpProcess function to make a process eligible
to run before the time in the sleep parameter expires.
In general, you should specify a value greater than 0 in the sleep parameter so that those
applications that need processing time can get it. If your application performs any periodic
task, then the frequency of the task usually determines what value you specify in the sleep
parameter. The less frequent the task, the higher the value of the sleep parameter.
About Process Management

29-7

<
teed

=
=
Te
o
=
©

ee

|

--

Inside Macintosh, Volume V1

USING

THE

PROCESS

MANAGER

The Process Manager manages the scheduling of all processes. You can use the Process
Manager routines to
= control the execution of your application
=

use the information provided by the Finder to open or print documents

= get information about processes
a

launch other applications

m

launch desk accessories

The Process Manager assigns a process serial number to each open application (or desk accessory, if it is not opened in the context of an application). The process serial number is unique
to each process on the local machine and is valid for a single boot of the machine. You can use
the process serial number to specify a particular process for most Process Manager routines.
You can use the process serial number returned from the GetCurrentProcess, GetNextProcess,
GetFrontProcess, and LaunchApplication functions in other Process Manager routines.

Opening

or Printing Files Based

on Finder Information

When a user opens or prints a file from the Finder, the Finder uses the Process Manager to
launch the application that created the file. The Finder sets up the information your application
can use to determine which files to open or print. The Finder information includes a list of
files to open or print.
In version 7.0, applications that support high-level events (that is, that have the
isHighLevelEventAware flag set in the 'SIZE' resource) receive the Finder information
through Apple events. The Apple Event Manager chapter in this volume describes how
your application processes Apple events to open or print files.
Applications that do not support high-level events can use the CountAppFiles, GetAppFiles,
and ClrAppFiles routines or the GetAppParms routine to get the Finder information. See the
Segment Loader chapter of Volume II for information on these routines.

Getting

Information

About

Other

Processes

You can use the GetNextProcess, GetFrontProcess, or GetCurrentProcess functions to get
the process serial number of a process. The GetCurrentProcess function returns the process
serial number of the process that is currently executing. The current process is the process
whose A5 world is currently valid; this process can be in the background or foreground. The
GetFrontProcess function returns the process serial number of the foreground process. For
example, if your process is running in the background, you can use GetFrontProcess to
determine which process is in the foreground.
The Process Manager maintains a list of all open processes. You can specify the process
serial number of a process currently in the list and use GetNextProcess to get the process
29-8

Using the Process Manager

Process Management
Ne
=)

serial number of the next process in the list. The interpretation of the value of a process serial
number and the order of the list of processes is internal to the Process Manager.
When specifying a particular process, use only a process serial number returned by a highlevel event, Process Manager routine, or constants defined by the Process Manager. You
can use these constants to specify special processes.

eS

lee]

)
OQ
ig")
2)

i? 2)

2
—

ee)

x
a

ic)

=

—_

@
~

CONST

kNoProcess

=

0;

kSystemProcess
kCurrent Process

8
ee

{process

doesn’t

—_

exist}

{process
belongs
to OS}
{the current
process}

In all Process Manager routines, the constant kNoProcess refers to a process that doesn’t
exist, the constant kSystemProcess refers to a process belonging to the Operating System,
and the constant kCurrentProcess refers to the current process.
To begin enumerating a list of processes, use the GetNextProcess function and specify the
constant kNoProcess as the parameter to return the process serial number of the first process
in the list. You can use the returned process serial number to get the process serial number of
the next process in the list. The GetNextProcess function returns the constant kNoProcess
and the result code procNotFound at the end of the list.
You can also use a process serial number to specify a target application when your application
sends a high-level event. See the Event Manager chapter for information on how to use a
process serial number when your application sends a high-level event.
You can use the GetProcessInformation function to obtain information about any process,
including your own. For example, for a specified process, you can find the application’s
name as it appears in the Application menu, the type and signature of the application, the
number of bytes in the application partition, the number of free bytes in the application heap,
the application that launched the application, and other information.
The GetProcessInformation function returns information about the requested process in a
process information record. The process information record is defined by the ProcessInfoRec
data type.
TYPE

ProcessInfoRec

=

RECORD

processInfoLength:

LongInt;

{length

processName:
processNumber:
processType:

StringPtr;
ProcessSerialNumber;
Longint;

{name of process}
{psn of the process}
{file
type of app file}

of

record}

processSignature:

OSType;

{signature

processMode:
processLocation:

Longint;
Ptr;

{'SIZE'
resource
flags}
{address
of partition}

of

processSize:
processFreeMem:
processLauncher:

Longint;
LongInt;
ProcessSerialNumber;

{partition
size}
{free bytes
in heap}
{process
that
launched}

processLaunchDate:
processActiveTime:

LongInt;
LongInt;

{time when
launched}
{accumulated
CPU time}

processAppSpec:

FSSpecPtr

{location

of

app

the

file}

file}

END;

Using the Process Manager

29-9

Inside Macintosh,

Volume VI

You specify the values for three fields of the process information record: processInfoLength,
processName and processAppSpec. You must either set the processName and processAppSpec
fields to NIL or set these fields to point to storage that you have allocated for them. The
GetProcessInformation function returns information in all other fields of the process
information record.
The processInfoLength field is the number of bytes in the process information record. For
compatibility, you should specify the length of the record in this field.
The name returned in the processName field is the name of the application or desk accessory.
For applications, this field contains the name of the application as designated by the user at
the time the application was opened. For example, for foreground applications, the
processName field is the name as it appears in the Application menu. For desk accessories,
the processName field contains the name of the 'DRVR' resource. You must specify NIL
in the processName field if you do not want the application name or the desk accessory name
returned. Otherwise, you should allocate at least 32 bytes of storage for the string pointed to
by the processName field. Note that the processName field specifies the name of either the
application or the 'DRVR' resource, whereas the processAppSpec field specifies the location
of the file.
The processNumber field specifies the process serial number. The process serial number is a
64-bit number; the meaning of these bits is internal to the Process Manager. You should not
interpret the value of the process serial number.
The processType field indicates the file type of the application, generally 'APPL' for applications, and 'appe' for background-only applications launched at startup. If the process is a
desk accessory, the processType field is the type of the file containing the 'DRVR' resource.
The processSignature field indicates the signature of the file containing the application or the
‘DRVR' resource (for example, the signature of the TeachText application is 'ttxt’).
The processMode field indicates whether the process is an application or desk accessory. For
applications, this field also returns information specified in the application’s 'SIZE' resource.
This information is returned as flags. You can refer to these flags by using these constants.
CONST

modeDeskAccessory

=

$00020000;

modeMultiLaunch

=

$00010000;

modeNeedSuspendResume

=

$00004000;

modeCanBackground

=

$00001000;

modeDoesActivateOnFGSwitch

=

$00000800;

modeOnlyBackground

=

$00000400;

modeGetFrontClicks
modeGetAppDiedMsg
mode32BitCompatible
modeHighLevelEventAware
modeLocalAndRemoteHLEvents

=
=
=
=
=

$00000200;
$00000100;
$00000080;
$00000040;
$00000020;

modeStationeryAware
modeUseTextEditServices

=
=

$00000010;
$00000008;

The processLocation field is the beginning address of the application partition.

29-10

— Using the Process Manager

Process Management
hn

‘So

The processSize field is the number of bytes in the application’s partition (including the heap,
stack, and A5 world).

od
w

-

=
ir)

@
<2)
~”

=

The processFreeMem field is the number of free bytes in the application’s heap.

—

=
=

—_

a

The processLauncher field is the process serial number of the process that launched the
application or desk accessory. If the original launcher of the process is no longer open,
this field contains the constant kNoProcess.

ge
@

as
_
—

@

_
a
—_

The processLaunchDate field contains the value of the Ticks global variable at the time that
the process was launched.
The processActiveTime field represents the accumulated time, in ticks, during which the
process has used the CPU, including both foreground and background processing time.
The processAppSpec field specifies the address of a file specification record that stores the
location of the file containing the application or 'DRVR' resource. You should specify NIL
in the processAppSpec field if you do not want the FSSpec record of the file returned.
Listing 29-1 shows how you can use the GetNextProcess function with the
GetProcessInformation function to search the process list for a specific process.
Listing 29-1.
FUNCTION

Searching for a specific process

FindAProcess(signature:
OSType;
VAR process:
ProcessSerialNumber;
VAR InfoRec:
aFSSpecPtr:

FSSpecPtr)

:

ProcessInfoRec;

Boolean;

BEGIN

FindAProcess

:=

FALSE;

process.highLongOfPSN
process. lowLongOfPSN

:=
:=

InfoRec.processiInfoLength
InfoRec.processName
:=
InfoRec.processAppSpec
WHILE

0;
kNoProcess;
:=

sizeof

=

FALSE

{start

from

(ProcessInfoRec)

StringPtr(NewPtr
:= aFSSpecPtr;

(GetNextProcess(process)

{assume

noErr)

to
the

begin

with}

beginning}

;

(32));

DO

BEGIN

IF

GetProcessInformation(process,

InfoRec)

=

noErr

THEN

BEGIN

IF

(InfoRec.processType
= Longint('APPL'))
AND
(InfoRec.processSignature
= signature)
THEN
BEGIN
{found
the

process}

FindAProcess
:= TRUE;
Exit (FindAProcess) ;
END;
END;
END;

{while}

END;

The code in Listing 29-1 searches the process list for the application with the specified
signature. For example, you might want to find a specific process in order to send a highlevel event to it.
Using the Process Manager

= 29-1 1

Inside Macintosh,

Launching

Volume VI

Other

Applications

You can launch other applications using the high-level LaunchApplication function. The
LaunchApplication function lets your application control various options associated with
launching an application. For example, you can
a allow the application to be launched in a partition smaller than the preferred size but
greater than the minimum size, or allow it to be launched only in a partition of the
preferred size
a launch an application without terminating your own application, bring the launched
application to the front, and get information about the launched application
m request that your application be notified if any application that it has launched terminates
Earlier versions of system software used a shorter parameter block as a parameter to the
_Launch trap macro. The _Launch trap macro still supports the use of this parameter block.
Applications using the LaunchApplication function should use the new launch parameter
block (LaunchParamBlockRec). Use the Gestalt function and specify the selector gestaltOS Attr
to determine which launch features are available. See the Compatibility Guidelines chapter for
information on how to use the Gestalt function.
Most applications don’t need to launch other applications. However, if your application
includes a desk accessory or another application, you might use either the high-level
LaunchApplication function to launch an application or the LaunchDeskAccessory function
to launch a desk accessory. For example, if you have implemented a spelling checker as a
separate application, you might use the LaunchApplication function to open the spelling
checker when the user chooses Check Spelling from one of your application’s menus.
You specify a launch parameter block as a parameter to the LaunchApplication function. You
use the launch parameter block to specify the filename of the application to launch, to specify
whether to allocate the preferred size for the application’s heap or to allow a partition size less
than the preferred size, and to set various other options—for example, whether your application should continue or terminate after it launches the specified application.
The LaunchApplication function launches the application from the specified file and returns

the process serial number, preferred partition size, and minimum partition size if the
application is successfully launched.

Note that if you launch another application without terminating your application, the launched
application does not actually begin executing until you make a subsequent call to
WaitNextEvent or EventAvail.
The launch parameter block is defined by the LaunchParamBlockRec data type.
TYPE

LaunchParamBlockRec

=

RECORD

reservedl:
reserved2:

Longint;
Integer;

{reserved}
{reserved}

launchBlockID:
launchnEPBLength:

Integer;
Longint;

{extended
block}
{length of block}

launchFileFlags:

Integer;

{Finder
{

29-12

Using the Process Manager

flags

application}

of

}

Process Management
i)
‘©
=

"i

launchControlFlags:

LaunchFlags;

launchAppSpec:

{launch

FSSpecPtr;

{location

launchProcessSN:

ProcessSerialNumber;

launchPreferredSize:
launchMinimumSize:

LongInt;

{returned

pref

LongIint;

{returned

min

launchAvailableSize:

LongInt;

{returned

available

AppParametersPtr

{ size}
{high-level

launchAppParameters:

options}

or |

i)
°
&

of
}
{ application
file}
{returned psn}

~M
v2)

<4

—
po)
~~
et)
ye

size}
size}

is”)

}

=—
&

—
=
=>

event}

END;

Specify the constant extendedBlock in the launchBlockID field to identify the parameter block
and to indicate that you are using the fields following it in the launch parameter block.
In the launchEPBLength field, specify the constant extendedBlockLen to indicate the length
of the remaining fields in the launch parameter block. For compatibility, you should always
specify the length value in this field.
The launchFileFlags field contains the Finder flags for the application file. (See the Finder
Interface chapter in this volume for a description of the Finder flags.) The LaunchApplication
function sets this field for you if you set the bit defined by the launchNoFileFlags constant in
the launchControlFlags field. Otherwise, you must get the Finder flags from the application
file and set this field yourself (by using GetFInfo, for example).
In the launchControlFlags field, you specify various options that control how the specified
application is launched. See the next section, “Specifying Launch Options,” for information
on the launch control flags.
You specify the application to launch using the launchAppSpec field of the launch parameter
block. You specify a pointer to a file system specification record (FSSpec) in this field. See
the File Manager chapter in this volume for a complete description of the file system
specification record.
LaunchApplication sets the initial default volume of the application to the parent directory of
the application file.
If LaunchApplication successfully launched the application, LaunchApplication returns in the
launchProcessSN field a process serial number that you can use in Process Manager routines
to refer to this application.
The launchPreferredSize and launchMinimumSize fields of the launch parameter block
are returned by LaunchApplication and are based on their corresponding values in the
'SIZE' resource. These values may be greater than those specified in the application’s 'SIZE'
resource because the returned sizes include any adjustments to the size of the application’s
stack. See the Event Manager chapter in this volume for information on how the size of the
application stack is adjusted. LaunchApplication always returns values for these fields
whether or not the launch was successful. These values are 0 if an error occurred—for
example, if the application file could not be found.
The launchAvailableSize field is returned by LaunchApplication only when the memFullErr
result code is returned. This value indicates the largest partition size currently available for
allocation.

Using the Process Manager

= 29-13

Inside Macintosh,

Volume VI

The launchAppParameters field specifies the first high-level event sent to an application. If
you set this field to NIL, the LaunchApplication function automatically creates and sends an
Open Application event to the launched application. (See the Apple Event Manager chapter for
a description of this event.) To send a particular high-level event to the launched application,
you can specify a pointer to an application parameters record. The application parameters
record is defined by the data type AppParameters.
TYPE

AppParameters
RECORD

=

theMscEvent:

EventRecord;

{event

eventRefCon:

Longint;

{reference

messageLength:
messageBuffer:

Longint;
ARRAY
[0..0]

{length
SignedByte

OF

(high-level) }
of

constant}
buffer}

END;

You specify the high-level event in the fields theMsgEvent, eventRefCon, messageLength,
and messageBuffer. The Event Manager chapter in this volume describes how to use highlevel events.
Listing 29-2 shows an example of using the LaunchApplication function.
Listing 29-2.
PROCEDURE

LaunchAnApplication

Launching
(mySFReply:

VAR

an application
StandardFileReply) ;

myLaunchParams:

LaunchParamBlockRec;

launchedProcessSN:
launchErr:

ProcessSerialNumber;
OSErr ;

prefSize:
minSize:

LongInt;
Longint;

availSize:

Longint;

BEGIN

WITH

myLaunchParams

DO

BEGIN

launchBlockID

:=

extendedBlock;

launchEPBLength
:= extendedBlockLen;
launchFileFlags:=
0;

launchControlFlags:=
launchAppSpec:=

launchContinue

@mySFReply.sfFile;

+

launchNoFileFlags;

launchAppParameters
:= NIL;
END;
launchErr
:= LaunchApplication(@myLaunchParams) ;
prefsize

minsize
IF

:=

:=

myLaunchParams.launchPreferredSize;

myLaunchParams.launchMinimumSize;

launchErr
= noErr
launchedProcessSN

THEN

:= myLaunchParams.launchProcessSN
ELSE
IF launchErr
= memFullErr
THEN
availSize
:= myLaunchParams.launchAvailableSize
ELSE
DoError(launchErr) ;
END;

29-14

— Using the Process Manager

Process Management
nN
NS

In Listing 29-2, the application file to launch is specified by using a file system specification
record returned by the StandardGetFile routine and specifying a pointer to this record in the
launchAppSpec field. The launchControlFlags field indicates that LaunchApplication should
extract the Finder flags from the application file, launch the application in the preferred size,
bring the launched application to the front, and that LaunchApplication should not terminate
the current process.

Specifying

Launch

=

$4000;

launchNoFileFlags

=

$0800;

launchUseMinimum

=

$0400;

launchDontSwitch

=

$0200;

launchinhibitDaemon

=

$0080;

oo)

©
@

2)
2)

<
—

pS)
=
=
ge
<7)

=
=

Options

launchContinue

gr

@

—

When you use the LaunchApplication function, you specify the launch options in the
launchControlFlags field of the launch parameter block. These are the constants you
can specify in the launchControlFlags field.
CONST

=
~

Set the launchContinue flag if you want your application to continue after the specified application is launched. If you do not set this flag, LaunchApplication terminates your application
after launching the specified application, even if the launch fails.
Set the launchNoFileFlags flag if you want the LaunchApplication function to ignore any
value specified in the launchFileFlags field. If you set the laanchNoFileFlags flag, the
LaunchApplication function extracts the Finder flags from the application file for you. If
you want to extract the file flags, clear the launchNoFileFlags flag and specify the Finder
flags in the launchFileFlags field of the launch parameter block.
Clear the launchUseMinimum flag if you want the LaunchApplication function to attempt to
launch the application in the preferred size (as specified in the application’s 'SIZE' resource).
If you set the launchUseMinimum flag, the LaunchApplication function attempts to launch the
application using the largest available size greater than or equal to the minimum size but less
than the preferred size. If the LaunchApplication function returns the result code memFullErr
or memFragErr, the application cannot be launched given the current memory conditions.
Set the launchDontSwitch flag if you do not want the launched application brought to the
front. If you set this flag, the launched application runs in the background until the user
brings the application to the front—for example, by clicking in one of the application’s
windows. Note that most applications expect to be launched in the foreground. If you clear
the launchDontSwitch flag, the launched application is brought to the front, and your
application is sent to the background.
Set the launchInhibitDaemon flag if you do not want LaunchApplication to launch a
background-only application. (A background-only application has the onlyBackground
flag set in its 'SIZE' resource.)

Using the Process Manager

— 29-15

Inside Macintosh,

Volume

V1

Controlling

Launched

Applications

When your application launches another application using LaunchApplication, the launched
application is automatically brought to the front, sending the foreground application to the
background. If you don’t want to bring the application to the front when it is first launched,
set the launchDontSwitch flag in the launchControlFlags field of the launch parameter block.
In addition, if you want your application to continue to run after it launches another
application, you must set the launchContinue flag in the launchControlFlags field of the
launch parameter block.
You can control the scheduling of the launched application in a limited way by using the
Process Manager routines SetFrontProcess and WakeUpProcess.
If you want your application to be notified when an application it has launched terminates, set
the acceptAppDiedEvents flag in your 'SIZE' resource. If you set this flag and an application
launched by your application terminates, your application receives an Application Died event
(‘aevt' 'obit'). See the Apple Event Manager chapter for information on receiving the
Application Died event and other Apple events.

Launching

Desk

Accessories

In version 7.0, when a desk accessory is opened, the Process Manager launches the desk
accessory in its own partition. The Process Manager gives it a process serial number and an
entry in the process list. The Process Manager puts the name of the desk accessory in the list
of open applications in the Application menu and also gives the active desk accessory its own
About menu item in the Apple menu that contains the name of the desk accessory. This makes
desk accessories more consistent with the user interface of small applications.
Your application can launch desk accessories using the LaunchDeskAccessory function.
However, you should use this function only when your application needs to launch a desk
accessory for some reason other than in response to the user choosing a desk accessory from
the Apple menu. In version 7.0, the Apple menu can contain any Finder object that the user
chooses to add to the menu. When the user chooses any item from the Apple menu that you
didn’t add specifically for your application, use the OpenDeskAcc function.

PROCESS

MANAGER

ROUTINES

You can use the Process Manager to get information about any currently open applications, to
launch other applications, and to control the scheduling of applications.
Use the Gestalt function with the selector gestaltOS
Attr to see if the Process Manager is
available and to find out which features of the launch routine are available. These constants
are names for the bit numbers returned in the response parameter to the Gestalt function.

29-16

— Process Manager Routines

Process Management
nN
=

CONST

gestaltLaunchCanReturn

=

1;

{can

return

from

gestaltLaunchFullFileSpec

=

2;

{LaunchApplication

gestaltLaunchControl

=

3;

{Process

Manager

—
w
~~

launch}
available}
is

available}

i)

°
is]
7)
~”
a
—

ps)
=)

The bit defined by the constant gestaltLaunchCanReturn is set if the _Launch trap macro can
return to the caller. The _Launch trap macro in version 7.0 (and in earlier versions of system
software running MultiFinder) provides an application with the option to continue running
after launching another application. The _Launch trap macro forces the launching application
to quit in earlier versions of system software not running MultiFinder.
The bit defined by the constant gestaltLaunchFullFileSpec is set if the launchControlFlags
field supports control flags in addition to the launchContinue flag, and if the parameters to the
_Launch trap macro include the launchAppSpec, launchProcessSN, launchPreferredSize,
launchMinimumSize, launchAvailableSize, and laanchAppParameters fields in the launch
parameter block.
The bit defined by the constant gestaltLaunchControl is set if the Process Manager is available.

Getting

Process

Information

You can use the Process Manager to get the process serial number of a particular process, to
get information about processes, or to change the scheduling status of a process.
FUNCTION

GetCurrentProcess(VAR

PSN:

ProcessSerialNumber):

OSErr;

The GetCurrentProcess function returns in the PSN parameter the process serial number of
the process that is currently executing. The currently executing process is the one currently
accessing the CPU; this is the application associated with the CurrentA5 global variable.
This application can be running in either the foreground or the background.
Applications can use this function to find their own process serial number. Drivers can use
this function to find the process serial number of the current process. You can use the
returned process serial number in other Process Manager routines.
Result code
noErr
FUNCTION

0

GetNextProcess(VAR

No error
PSN:

ProcessSerialNumber):

OSErr;

The Process Manager maintains a list of all open processes. You can derive this list by using
repetitive calls to GetNextProcess. Begin generating the list by calling GetNextProcess and
by specifying the constant kNoProcess in the PSN parameter. You can then use the returned
process serial number to get the process serial number of the next process. Note that the
order of the list of processes is internal to the Process Manager. GetNextProcess returns the
constant kKNoProcess in the PSN parameter and the result code procNotFound when the end
of the list is reached.

Process Manager Routines

— 29-17

a

ge
@

=ad

i)

=

—

Inside Macintosh,

Volume VI

The process serial number you specify in the PSN parameter should be a valid process
serial number returned from LaunchApplication, GetNextProcess, GetFrontProcess, or
GetCurrentProcess, or the defined constant kNoProcess.
You can use the returned process serial number in other Process Manager routines. You can
also use this process serial number to specify a target application when your application sends
a high-level event.
Result codes
noErr
paramErr
procNotFound

FUNCTION

0
—50
—-—600

No error
Process serial number is invalid
No process in the process list following the
specified process

GetProcessInformation(PSN:

ProcessSerialNumber;

ProcessinfoRec):

VAR

info:

OSErr;

The GetProcessInformation function returns information about the specified process in
a process information record. The information returned in the info parameter includes
the application’s name as it appears in the Application menu, the type and signature of the
application, the address of the application partition, the number of bytes in the application
partition, the number of free bytes in the application heap, the application that launched
the application, the time at which the application was launched, and the location of the
application file. The section “Getting Information About Other Processes,” earlier in this
chapter, shows the structure of the process information record.
The GetProcessInformation function also returns information about the application’s 'SIZE'’
resource and indicates whether the process is an application or a desk accessory.
You need to specify values for the processInfoLength, processName, and processAppSpec
fields of the process information record. Specify the length of the process information record
in the processInfoLength field. If you do not want information returned in the processName
and processAppSpec fields, specify NIL for these fields. Otherwise, allocate at least 32 bytes
of storage for the string pointed to by the processName field and specify a pointer to an
FSSpec record in the processAppSpec field.
The process serial number you specify in the PSN parameter should be a valid process
serial number returned from LaunchApplication, GetNextProcess, GetFrontProcess,
GetCurrentProcess, or a high-level event. You can use the constant kCurrentProcess to
get information about the current process.
Note:
time.

Do not call GetProcessInformation from a routine that executes at interrupt

Result codes
noErr
paramErr

29-18

0
—50

No error
Process serial number is invalid

— Process Manager Routines

Process Management
nN
Ne)

FUNCTION

SameProcess(PSN1,PSN2:
Boolean):

ProcessSerialNumber;

VAR

~
“

result:

>)
v)
®

OSErr;

i? 2]
~”

The SameProcess function compares two process serial numbers and determines whether
they refer to the same process. If the process serial numbers specified in the PSN1 and
PSN2 parameters refer to the same process, the SameProcess function returns TRUE in
the result parameter; otherwise, it returns FALSE in the result parameter.
When you compare two process serial numbers, use the SameProcess function rather than
any other means, because the interpretation of the bits in a process serial number is internal
to the Process Manager.
The process serial numbers you use should be valid process serial numbers returned from
LaunchApplication, GetNextProcess, GetFrontProcess, GetCurrentProcess, or a high-level
event. You can also use the constant kCurrentProcess to refer to the current process.
Result codes
noErr
paramErr
FUNCTION

0)
—50

No error
Process serial number is invalid

GetFrontProcess(VAR

PSN:

ProcessSerialNumber):

OSErr;

The GetFrontProcess function returns in the PSN parameter the process serial number of the
process running in the foreground. You can use this function to determine if your process or
some other process is in the foreground. You can use the process serial number returned in
the PSN parameter in other Process Manager routines.
If no process is running in the foreground, GetFrontProcess returns the result code
procNotFound.
Result codes
noErr
paramErr
procNotFound
FUNCTION

0
—50
—-—600

No error
Process serial number is invalid
No process in the foreground

SetFrontProcess(PSN:

ProcessSerialNumber):

OSErr;

The SetFrontProcess function schedules the specified process to become the foreground
process. The specified process becomes the foreground process after the current foreground process makes a subsequent call to WaitNextEvent or EventAvail.
The process serial number in the PSN parameter should be a valid process serial number
returned from LaunchApplication, GetNextProcess, GetFrontProcess, GetCurrentProcess,
or a high-level event. You can also use the constant kCurrentProcess to refer to the
current process.

Process Manager Routines

— 29-19

<4
—

ty)
=~
m=
ge
@
=—
©

=—

Inside Macintosh,

Volume

VI

If the specified process serial number is invalid or if the specified process is a backgroundonly application, SetFrontProcess returns a nonzero result code and does not change the
current foreground process.
If a modal dialog box is the frontmost window, the specified process does not become the
foreground process until after the user dismisses the modal dialog box.
Note:

Do not call SetFrontProcess from a routine that executes at interrupt time.

Result codes
noErr
procNotFound

0
-600

applsDaemon

-606

FUNCTION

No error
Process with specified process serial number
doesn’t exist or process is suspended by highlevel debugger
— Specified process is background-only

WakeUpProcess(PSN:

ProcessSerialNumber):

OSErr;

The WakeUpProcess function makes a process suspended by WaitNextEvent eligible to
receive CPU time. When a process specifies a nonzero value for the sleep parameter in the
WaitNextEvent function, and there are no events for that process pending in the event
queue, the process is suspended. This process remains suspended until the time specified
in the sleep parameter expires or an event becomes available for that process. You can use
WakeUpProcess to make the process eligible for execution before the time specified in the
sleep parameter expires.
The WakeUpProcess function does not change the order of the processes scheduled for
execution; it only makes the specified process eligible for execution.
The process serial number specified in the PSN parameter should be a valid process serial
number returned from LaunchApplication, GetNextProcess, GetFrontProcess,
GetCurrentProcess, or a high-level event.

Result codes
noErr
procNotFound

Launching

0
-600

No error
Suspended process with specified process serial
number doesn’t exist

Applications and

Desk Accessories

Your application can use the LaunchApplication function to launch other applications and the
LaunchDeskAccessory function to launch desk accessories.
The LaunchApplication function launches the application from the specified file and returns
the process serial number, preferred partition size, and minimum partition size if the application is successfully launched.

29-20

Process Manager Routines

Process Management
i)
.—)
—

Note that if you launch another application without terminating your application, the launched
application is not actually executed until you make a subsequent call to WaitNextEvent or
EventAvail.

>

7)
”
a

Set the launchContinue flag in the launchControlFlags field of the launch parameter block if
you want your application to continue after the specified application is launched. If you do
not set this flag, LaunchApplication terminates your application after launching the specified
application, even if the launch fails.
FUNCTION

a

°©

LaunchApplication(LaunchParams:

LaunchPBPtr):

Trap macro

_Launch

On entry

AO: Launch parameter block pointer

On exit

AO: Launch parameter block pointer
DO: Result code

Parameter block
>
6

OSErr;

launchBlockID

word

extended block

>

8

launchEPBLength

long

length of following fields

>

12

launchFileFlags

word

Finder flags for the application file

ed

14

launchControlFlags

word

flags for launch options

>

16

launchAppSpec

long

location of application file to launch

-

20

launchProcessSN

2 longs

process serial number

ce

28

launchPreferredSize

long

preferred application partition size

—

32

launchMinimumSize

long

minimum application partition size

-

36

launchA vailableSize

long

maximum available partition size

=>

40

launchAppParameters

long

high-level event for launched app

Field descriptions
launchBlockID

A value that indicates whether you are using the fields following it
in the launch parameter block. Specify the constant extendedBlock
if you use the fields that follow it.

launchEPBLength

The length of the fields following this field in the launch parameter
block. Use the constant extendedBlockLen to specify this value.

launchFileFlags

The Finder flags for the application file. Set the launchNoFileFlags
constant in the launchControlFlags field if you want the
LaunchApplication function to extract the Finder flags from the
application file and to set the launchFileFlags field for you.

Process Manager Routines

— 29-21

—
as
coe
we

veer!

is)

ga

io
_—
_

—

@

=_

Inside Macintosh,

Volume VI

launchControlFlags

The launch options that determine how the application is launched.
You can specify these constant values to set various options:
CONST

launchContinue

=

$4000;

launchNoFileFlags

=

$0800;

launchUseMinimum

=

$0400;

launchDontSwitch
launchinhibitDaemon

=
=

$0200;
$0080;

See “Specifying Launch Options” earlier in this chapter for a
complete description of these flags.
launchAppSpec

A pointer to a file specification record that gives the location of the
application file to launch.

launchProcessSN

The process serial number returned to your application if the launch
is successful. You can use this process serial number in other
Process Manager routines to refer to the launched application.

launchPreferredSize

The preferred partition size for the launched application as specified
in the launched application’s 'SIZE’ resource. LaunchApplication
sets this field to 0 if an error occurred or if the application is
already open.

launchMinimumSize

The minimum partition size for the launched application as specified
in the launched application’s 'SIZE' resource. LaunchApplication
sets this field to 0 if an error occurred or if the application is
already open.

launchA vailableSize

The maximum partition size that is available for allocation. This
value is returned to your application only if the memFullErr result
code is returned. If the application launch fails (because there
isn’t enough memory), you can use this value to determine if
there is enough memory available to launch in the minimum size.

launchAppParameters

The first high-level event to send to the launched application. If you
specify NIL for this field, LaunchApplication creates and sends the
Open Application event to the launched application.

Result codes
noErr
memFullErr

QO
—108

memFragErr

—601

appModeErr

—602

appMemFullErr

—605

appIsDaemon

—606

29-22

Noerror
Not enough memory to allocate the partition size
specified in the 'SIZE' resource
Not enough room to launch application with
special requirements
Memory mode is 32-bit, but application is not
32-bit clean
More memory for the partition size is required
than the amount specified in the 'SIZE’ resource
Application is background-only, and launch
flags don’t allow this

Process Manager Routines

Process Management
nN
SS

¢))

=}

bs

0

oO

O

©
2

Q

(D

co

VU

9 |
ae

ida)

dp)

(4)
w

'S
@)
Q

T
c

2)
(Dp
ap)

f

*

ae

QO

Oo
D

4

+9)
Cc

it ivV/in

t

{

1]

|

Your application can launch desk accessories using the LaunchDeskAccessory function. Use
this function only when your application needs to launch a desk accessory for some reason
other than in response to the user choosing a desk accessory from the Apple menu. (When
the user chooses any item from the Apple menu that you didn’t add specifically for your
application, use the OpenDeskAcc function.)
StringPtr):

LaunchDeskAccessory searches the resource fork of the file specified by the pFileSpec
parameter for the desk accessory with the 'DRVR' resource name specified in the pDAName
parameter. If the 'DRVR' resource name is found, LaunchDeskAccessory launches the desk
accessory. If the desk accessory is already open, it is brought to the front.
Specify the file to search using the pFileSpec parameter. Specify NIL for pFileSpec if you
want to search the current resource file and the resource files opened before it. Otherwise,
specify the file using a pointer to an FSSpec record.
In the pDAName parameter, specify the 'DRVR' resource name of the desk accessory to
launch. Specify NIL in pDAName if you want to launch the first 'DRVR' resource found in
the file as returned by the Resource Manager. Because the LaunchDeskAccessory function
opens the specified resource file for exclusive access, you cannot launch more than one desk
accessory from the same resource file.
If the 'DRVR' resource is in a resource file that is already open by the current process or if
the driver is in the System file and the Option key is down, LaunchDeskAccessory launches
the desk accessory in the application’s heap. Otherwise, the desk accessory is given its own
partition and launched in the system heap.
Result codes
noErr
resNotFound

(0)
—]92

No error
Resource not found

Process Manager Routines

— 29-23

a)
en
ra
o
lan)
=

”
~”

2
—
5
=

$9
©

JQ

=|—

io

=—_

Inside Macintosh, Volume VI

SUMMARY

OF

PROCESS

MANAGER

ROUTINES

Constants
CONST

kNoProcess

=

{process

kSystemProcess

=

kCurrent Process

=

{process
belongs
to OS}
{the current
process}

{launch

control

doesn’t

exist}

flags}

launchContinue

=

$4000;

{continue

launchNoFileFlags

=

$0800;

launchUseMinimum

=

$0400;

{ignore launchFileFlags}
{use minimum or greater

after

launch}

}

size}
launchDontSwitch

=

{launch

$0200;

{
launchAllow24Bit

=

$0100;

{reserved}

launchInhibitDaemon

=

$0080;

{don't

extendedBlockLen

=

sizeof

(LaunchParamBlockRec)

extendedBlock

=

$4C43;

{extended

block}

{process

is

modeUseTextEditServices

$00020000;
$00010000;
= $00004000;
= $00001000;
= $00000800;
= $00000400;
= $00000200;
= $00000100;
= $00000080;
= $00000040;
—— $00000020;
= $00000010;
= $00000008;

gestaltOSAttr

=

{OS

gestalt

{can

return

{launch

{flags

parameter

in

block

processMode

field}

modeDeskAccessory

=

modeMultiLaunch

=

modeCanBackground

modeDoesActivateOnFGSwitch
modeOnlyBackground
modeGetFrontClicks

modeGetAppDiedMsg
mode32BitCompatible
modeHighLevelEventAware
modeLocalAndRemoteHLEvents
modeStationeryAware

{Process

Mgr

in

}

{

launch

background

}

application}

length}

modeNeedSuspendResume

'os

';

desk

Es

-

acc}

{from

app

file's

{from

'SIZE'

resource}

{from

'SIZE'

resource}

{from

'SIZE'

resource}

{from

'SIZE'

resource}

{from

'SIZE'

resource}

{from

'SIZE'

resource}

{from

'SIZE'

resource}

{from

'SIZE'

resource}

{from
{from

'SIZE'
'SIZE'

resource}
resource}

{from

'SIZE'

flags}

resource}
selector}

attributes}
from

gestaltLaunchCanReturn

=

gestaltLaunchFullFileSpec

=

{LaunchApplication

=

{ available}
{Process
Manager

gestaltLaunchControl

29-24

application

background}

Summary of Process Manager Routines

{

is

available}

launch}

is
}

}

Process Management
i)

=

Data

vee

Types

w

—:
~
~~
©

C

P
+ 2
)

TYPE

ProcessSerialNumberPtr
ProcessSerialNumber

=

“ProcessSerialNumber;

—
as
oa
“_
~
As
-_

=

wo

RECORD

>

highLongOfPSN:

Longint;

{process

lowLongOfPSN:

LongInt

{

serial

_
a)
_

}

&

~
—
os

number}

END;
ProcessInfoRecPtr
ProcessInfoRec

=

*ProcessInfoRec;

=

RECORD
processinfoLength:

LongIint;

{length

processName:

StringPtr;

{name

of

processNumber:
processType:

ProcessSerialNumber;
LongInt;

{psn of the process}
{file type of app file}

processSignature:

OSType;

{signature

processMode:

Longint;

{'SIZE'

processLocation:
processSize:

Ptr;
Longint ;

{address of partition}
{partition size}

processFreeMem:
processLauncher:

Longint;
ProcessSerialNumber;

{free bytes
in heap}
{process
that
launched}

processLaunchDate:

LongInt;

{time

processActiveTime:

Longint;

{accumulated

CPU

time}

processAppSpec:

FSSpecPtr

{location

the

file}

of

record}

process}

of

app

resource

when

file}
flags}

launched}
of

END;
AppParametersPtr
AppParameters

=

RECORD
theMsgEvent

:

END;

=

“AppParameters;

EventRecord;

eventRefCon:
messageLength:
messageBuffer:

LaunchFlags

=

LaunchPBPtr

=

LaunchParamBlockRec
RECORD
reservedl:
reserved2:

Longint;
Longint ;
ARRAY [0..0]

{event

OF

(high-level) }

{reference
{length of
SignedByte

constant}
buffer}

Integer;
“LaunchParamBlocxkRec;
=
LongIint;
Integer;

{reserved}
{reserved}

launchBlockID:
launchEPBLength:

Integer;
Longint;

{extended
block}
{length of block}

launchFileFlags:

Integer;

{Finder flags of
{ application}

launchControlFlags:
launchAppSpec:

LaunchFlags;
FSSpecPtr;

{launch options}
{location of }

launchProcessSN:

ProcessSerialNumber;

{returned

{

application

}

file}

psn}

Summary of Process Manager Routines

29-25

Inside Macintosh,

Volume

VI

launchPreferredSize:
launchMinimumSize:

Longint;
Longint;

{returned
{returned

launchAvailableSize:

LongInt;
AppParametersPtr

{returned
avail
size}
{high-level
event}

launchAppParameters:

pref
size}
min size}

END;

Routines

Getting

Process

Information

FUNCTION

GetCurrentProcess

(VAR

PSN:

ProcessSerialNumber):

OSErr;

FUNCTION

GetNext

(VAR

PSN:

ProcessSerialNumber):

OSErr;

FUNCTION

GetProcessInformation

(PSN:
ProcessSerialNumber;
ProcessinfoRec):
OSErr;

FUNCTION

SameProcess

(PSN1,PSN2:

ProcessSerialNumber;

result:

Boolean):

OSErr;

ProcessSerialNumber):

Process

info:
VAR

FUNCTION

GetFrontProcess

(VAR

FUNCTION

SetFrontProcess

(PSN:

ProcessSerialNumber):

OSErr;

FUNCTION

WakeUpProcess

(PSN:

ProcessSerialNumber):

OSErr;

Launching

Applications

and

PSN:

VAR

Desk

Accessories

FUNCTION

LaunchApplication

(LaunchParams:

FUNCTION

LaunchDeskAccessory

(pFileSpec:
StringPtr):

Result

LaunchPBPtr):

FSSpecPtr;

OSErr;

pDAName:

OSErr;

Codes

noErr
paramErr
memFullErr

0
—50
—108

resNotFound
procNotFound
memFragErr

-—192
—600
-601

appModeErr
appMemFullErr

—602
—605

appIsDaemon

—606

29-26

OSErr;

No error
Process serial number is invalid
Not enough memory to allocate the partition size
specified in the 'SIZE' resource
Resource not found
No eligible process with specified process serial number
Not enough room to launch application with special
requirements
Memory mode is 32-bit, but application is not 32-bit clean
Partition size specified in 'SIZE' resource is not big
enough for launch
Application is background-only

Summary of Process Manager Routines

Process Management
nN
‘©

Assembly-Language

~~

Information

we |

Ss
©
&
”
nn

Process

Information

processInfoLength
processName
processNumber
processType
processSignature
processMode
processLocation
processSize
processFreeMem
processLauncher
processLaunchDate
processActiveTime
processAppSpec

Record

long
long
2 longs
long
long
long
long
long
long
2 longs
long
long
long

Data

<=

Structure

6

=

o
ge

length of this record
name of process
process serial number
type of application file
signature of application file
flags from 'SIZE' resource
address of process partition
partition size (in bytes)
amount of free memory
launcher of process
value of TICKS at time of launch
total time spent using the CPU
location of the file

i)

=
—

i)

=—

Launch

Parameter

Block

—

0
4
6

reserved |
reserved2
launchBlockID

long
word
word

reserved
reserved
specifies whether block is extended

—

8

launchEPBLength

long

length (in bytes) of rest of parameter block

—>

12

launchFileFlags

word

the Finder flags for the application file

—>

14

launchControlFlags

word

flags that specify launch options

—>

16

launchAppSpec

long

<

20

launchProcessSN

address of FSSpec that specifies the
application file to launch
2 longs _ process serial number

<

28

launchPreferredSize

long

application’s preferred partition size

<

32

launchMinimumSize

long

application’s minimum partition size

<

36

launchA vailableSize

long

maximum partition size available

—

40

launchAppParameters

long

high-level event for launched application

Summary of Process Manager Routines

— 29-27

Inside Macintosh, Volume VI

29-28

©
LAW
DBOAIDA

10
I |
13
13
16
19

THE

SLOT

MANAGER

About This Chapter
About the Slot Manager
Card Initialization
Using the Slot Manager
Enabling and Disabling NuBus Cards
Enabling and Disabling SResource Data Structures
Searching for Disabled SResource Data Structures
Restoring Deleted SResource Data Structures
Slot Manager Routines
The Slot Manager Parameter Block
Determining the Version of the Slot Manager
Getting Information About SResource Data Structures
Enabling, Disabling, or Restoring SResource Data Structures
Summary of the Slot Manager

ane

=

PD
o-

<

a
~
eS)

i)
)

ony

30-1]

Inside Macintosh,

30-2

Volume

VI

The Slot Manager

ABOUT

THIS

CHAPTER

This chapter describes the enhancements and new routines that have been added to the Slot
Manager with system software version 7.0. The information in this chapter supplements the
information in the Slot Manager chapter inVolume V.
You need to use Slot Manager routines only if you are writing an application or device driver
that must address a NuBus™ card directly. For example, you need to use the Slot Manager if
you are writing a driver for a video card, but not if you only want to display information on a
screen for which a device driver already exists. If you do have to use the Slot Manager, read
this chapter to see if any of the functions added to the Slot Manager by system software
version 7.0 are of use to you.
There are two variations of the system software version 7.0 Slot Manager: version | and
version 2. Version | of the Slot Manager is supplied with the version 7.0 System file on
disk for use with Macintosh® II-family computers that were designed and built before
system software version 7.0 was available. Version 2 is included in the ROM of newer
Macintosh II—family computers.
The Slot Manager polls the NuBus cards in the system and initializes the cards before patches
to the Operating System are loaded from disk. Version | of the 7.0 Slot Manager polls all
NuBus cards again in case any cards that must be addressed in 32-bit mode were not recognized by the older Slot Manager. It is not necessary for version 2 of the Slot Manager to poll
the NuBus cards a second time. Both versions of the Slot Manager reinitialize all NuBus
cards after RAM patches have been loaded, in case any card requires RAM patches to be
available before the card is used. Other than this difference in initialization sequence, the two
versions of the Slot Manager are identical.
You can use the SVersion function, described in this chapter, to determine whether the
system software version 7.0 Slot Manager is available and, if it is available, whether it is
version | or version 2. You cannot use the other routines described in this chapter if the
system software version 7.0 Slot Manager is not available.
Once the system software version 7.0 Slot Manager has been loaded into memory, the Slot
Manager no longer executes the InitSDeclMgr, SInitSRsrcTable, SInitPRAMRecs, and
SPrimaryInit functions. Because these functions are used for card initialization and all
initialization is handled by the Operating System, the availability of these functions should
not affect your program. See “Card Initialization” later in this chapter for more information
about the initialization of NuBus cards by the Slot Manager.
If you are writing a device driver, you need the book Designing Cards and Drivers for the
Macintosh Family, second edition. You will also find useful information in the chapters on
the Device Manager in Volumes II, IV, and V of Inside Macintosh.

About This Chapter

30-3

=
2)

So
=

<

cel

=

=

pe)
tf)
io)
~

Inside Macintosh,

Volume VI

ABOUT

SLOT

THE

MANAGER

The Slot Manager provided with system software version 7.0 addresses NuBus cards in 32-bit
mode to ensure that the Operating System recognizes all NuBus cards. It also performs card
initialization in a fashion different from that used by older versions of the Slot Manager to
ensure that all NuBus cards—including those that must be addressed in 32-bit mode—are
initialized correctly.
Several new routines have been added to the Slot Manager. You can use the new Slot
Manager routines to
m determine which version of the Slot Manager is available
m

determine what sResource data structures are available

m get information about an sResource data structure, whether or not the sResource data
structure is enabled
= get information about all sResource data structures that match the type of a specific
sResource data structure
w

enable and disable sResource data structures

m

restore an sResource data structure that has been deleted from the Slot Resource Table

Note: An sResource data structure is sometimes referred to as a slot resource. Note,
however, that a slot resource is a data structure in the firmware of a NuBus card and
not a type of Macintosh resource. The structure and content of an sResource data
structure are described in detail in Designing Cards and Drivers for the Macintosh
Family, second edition.
All of the Slot Manager routines use a data structure called the Slot Manager parameter block
to exchange information with the Slot Manager. The Slot Manager parameter block has been
modified to add a flag field that is used by two new Slot Manager routines: SGetSRsre and
SGetTypeSRsrc. These routines search for sResource data structures.

CARD

INITIALIZATION

When the user starts up a Macintosh II-family computer, the Slot Manager in ROM searches
each slot for a declaration ROM. It identifies all of the sResource data structures in each
declaration ROM and creates a table—the Slot Resource Table—that lists all of the
sResource data structures currently available to the system. The Slot Manager then initializes
the parameter RAM bytes reserved for each slot and executes the initialization code in the
PrimaryInit record in the declaration ROM of each NuBus card.

30-4

Card Initialization

The Slot Manager

The Slot Manager in the ROM of early Macintosh II computers (revision A of the ROM) can
address NuBus cards only in 24-bit mode and can search for declaration ROMs only in the
l-megabyte (MB) slot space for each slot—that is, in addresses $Fsxx xxxx, where s is the
slot number. Because some NuBus cards have a declaration ROM that must be addressed
with 32-bit addresses, not all NuBus cards can be addressed or even located by the Slot
Manager in ROM revision A. The Slot Manager released with system software version 7.0
remedies this problem.
There are two versions of the Slot Manager that address NuBus cards in 32-bit mode:
version | and version 2 (see “Determining the Version of the Slot Manager” later in this
chapter). When version | of the Slot Manager is loaded into memory, it conducts a second
search for declaration ROMs, this time addressing all of the slots in 32-bit mode. If it finds
any new NuBus cards, the Slot Manager adds their sResource data structures to the Slot
Resource Table and executes the code in the PrimaryInit records on those cards. Version 2
of the Slot Manager conducts only one search for declaration ROMs—before RAM patches
are loaded into memory—and it executes Primarylnit records at that time.
After RAM patches to the Operating System have been loaded from disk, either variant of the
system software version 7.0 Slot Manager executes the code in any SecondaryInit records it
finds in any of the declaration ROMs. It does not
m reexecute any PrimaryInit records that were executed by the ROM-based Slot Manager
® reinitialize the parameter RAM values that were initialized by the ROM-based
Slot Manager
m restore any sResource data structures that were loaded by the ROM-based Slot Manager
and subsequently deleted by the PrimaryInit code
The Slot Manager executes the code in PrimaryInit records with interrupts disabled before
Operating System patches have been loaded into RAM, but it executes SecondaryInit records
with interrupts enabled after system patches have been loaded.
A SecondarylInit record has the same format as a PrimaryInit record. To include a SecondaryInit
record in your declaration ROM, you must include a Secondary
Init field—a field with an identification (ID) number of 38—in the Board sResource data structure. (The Board sResource data

structure is a type of sResource data structure that must be present in the firmware of every
NuBus card that communicates with the computer. The format of a PrimaryInit record and the
Board sResource data structure are described in Designing Cards and Drivers for the Macintosh
Family, second edition.)
The system software version 7.0 Slot Manager allows you to disable a card temporarily until
the SecondaryInit record is executed. The SecondaryInit record can then enable the card and
complete initialization. You can use this feature, for example, to ensure that a card that requires
Color QuickDraw™ is not used until after Color QuickDraw has been loaded into memory.

Card Initialization

30-5

es)
—
—

ZN
—

len)
=_
[mal

=
—
.

£9
—
to

pt)
g Lal

o

—

.

4

Inside Macintosh,

Volume

USING

SLOT

THE

V]

MANAGER

The Slot Manager released with system software version 7.0 allows you to do four things
you couldn't do before:
mw You can temporarily disable and then reenable a NuBus card.
mw

Youcan

enable and disable sResource data structures.

=

Youcan

search for disabled sResource data structures.

m=

Youcan restore an sResource data structure that was deleted from the Slot
Resource Table.

This section describes how to do each of these things and provides some sample code to
illustrate how to do them.

Enabling

and Disabling

NuBus

Cards

If your NuBus card must be addressed in 32-bit mode or requires that RAM-based system
software patches be loaded into memory before the card is initialized, you can use the code in
the PrimaryInit record to disable the card temporarily and the code in the SecondaryInit record
to reenable it. To determine whether the system software version 7.0 (or later) Slot Manager
is present and, if present, whether it is the RAM-based version (version 1) or the ROM- based
version (version 2), use the SVersion function described in “Determining the Version of the
Slot Manager” later in this chapter. If version 2 of the Slot Manager is present, you can
assume that the Slot Manager operates in 32-bit mode. However, if you want to be sure that
all RAM patches to the Operating System have been loaded before your card is used, you can
still use the method described here to disable your NuBus card temporarily.
To disable a

NuBus card temporarily, the initialization routine in your PrimaryInit record

should return in the seStatus field of the SEBlock data structure an error code with a value in
the range svTempDisable ($8000) through svDisabled ($8080). The Slot Manager places this
error code i in the silnitStatusV field of the sInfo record that the Slot Manager maintains for
that slot, and it places the fatal error smInitStatVErr (—315) in the silnitStatusA field of the

sInfo record. The card and its sResource data structures are then unavailable for use by the
Operating System.

After the Operating System loads RAM patches, the system software version 7.0 Slot
Manager checks the value of the silnitStatusA field. If this value is greater than or equal
to 0, indicating no error, the Slot Manager executes the SecondaryInit code in the declaration
ROM of the NuBus card. If the value in the silnitStatusA field is smInitStatVErr, the Slot
Manager checks the silnitStatusV field. If the value of the siInitStatusV field is in the range
svTempDisable through svDisabled, the Slot Manager clears the silnitStatusA field to 0
and runs the SecondaryInit code. In other words, the version 7.0 Slot Manager runs the
SecondaryInit code if the PrimaryInit code returns no error or returns an error in the range
svTempDisable through svDisabled. If the PrimaryInit code returns any other result code less

30-6

Using the Slot Manager

The Slot Manager

than 0 (that is, any other fatal error), the NuBus card remains disabled and the Slot Manager
does not run the SecondaryInit code. The sExec parameter block and the sInfo record are
described in the Slot Manager chapter in Volume V.
For examples of PrimaryInit and SecondaryInit records that test for the presence of the
version 7.0 Slot Manager and act accordingly, see Designing Cards and Drivers
for the
Macintosh Family, second edition.

Ge
—)

a

Enabling

and

Disabling

SResource

op<

Data Structures

4pact

Under certain circumstances, you might want to disable an sResource data structure while it
remains listed in the Slot Resource Table. For example, a NuBus card might provide several
modes of operation, only one of which can be active at a given time. Your application might
want to disable the sResource data structures associated with all but the active mode, but still
list all available modes in a menu. When the user selects a new mode, your application can
then disable the currently active sResource data structure and enable the one the user selected.
You use the SetSRsrcState function to enable or disable an sResource data structure. Listing
30-1 disables the sResource data structure in slot $0A with an ID of 128 and enables the
sResource data structure in the same slot with an ID of 131.

Listing 30-1. Disabling and enabling sResource data structures
VAR

mySpBlk:

SpBlock;

myErr:

OSErr;

BEGIN

{Set

required

WITH

values

mySpBlk

in

parameter

block. }

DO

BEGIN

spParamData
spSlot

:=

:=

1;

{disable}

SOA;

{slot

SsplpD s= 126;
SpExtDev
:= 0;

number}

{sResource
ID}
{ID of the external

device}

END;

myErr
:=
IF myErr

WITH

SetSRsrcState(@mySpBlk) ;
<> noErr THEN DoError (myErr)

mySpBlk

;

DO

BEGIN

spParamData
:=
spSlot
:= $0a;
spID
:= 131;
SspExtDev
:= 0;

0;

{enable}
{slot
number}
{sResource
ID}
{ID of the external

device}

END;

myErr
:=
IF myErr

SetSRsrcState(@mySpBlk) ;
<> noErr THEN DoError (myErr)

;

END;

Using the Slot Manager

30-7

pe
i)
mS
jo)
a)
wey

Inside Macintosh,

Searching

Volume VI

for Disabled

SResource

Data

Structures

Whereas the Slot Manager routines described in Volume V act only on enabled sResource
data structures, you can use system software version 7.0 Slot Manager routines to search for
both enabled and disabled sResource data structures. The system software version 7.0 Slot
Manager also allows you to specify whether the search should be for the specified sResource
data structure or the next sResource data structure and whether the search should include
only the specified slot or should include the specified slot plus all slots with higher numbers.
In addition, you can specify the type of the sResource data structure for which you want to
search; then the Slot Manager ignores all sResource data structures that do not match the
specified type.
Table 30-1 summarizes the Slot Manager search routines and the options available for each.
Table 30-1.

Slot Manager search routines

Function

State of
sResources it
searches for

Slots it
searches

Which
Type of
sResource it
sResource it
searches for — searches for

SNextSRsrc

Enabled only

Specified slot
and higher slots

Next sResource
only

Any type

SGetSRsrc*

Your choice of | Yourchoiceof
| Yourchoiceof
enabled only or
oneslotonly or _ specified
both enabled and specified slot and sResource or
disabled
higher slots
next sResource

Any type

SNextTypeSRsre

Enabled only

Specified slot
and higher slots

Next sResource
— only

Specified type
only

SGetTypeSRsrc*

Yourchoice of |
enabled only or
both enabled and _
disabled

Yourchoiceof | NextsResource
_oneslotonly or _ only
specified slot and
higher slots

Specified type
only

* Available only with system software version 7.0 Slot Manager
Listing 30-2 shows how to search all slots for all sResource data structures with a specific
value in the Category and cType fields, whether enabled or disabled. The Slot Manager
ignores the DrvrSW and DrvrHW fields of the resource type.

Restoring

Deleted

SResource

Data

Structures

Some NuBus cards have sResource data structures to support a variety of combinations of
system configurations or modes. The Slot Manager loads all of the sResource data structures
during system initialization, and then the PrimaryInit code in the declaration ROM deletes
from the Slot Resource Table any sResource data structures that are not appropriate for the

30-8

Using the Slot Manager

The Slot Manager

Listing 30-2. Searching for sResource data structures
VAR

mySpBlk:

SpBlock;

myErr:

OSErr;

BEGIN
{Set
required
values
WITH mySpBlk
DO

in

parameter

Lo)

block. }

—

—

2
—
~
—_

BEGIN

os

spParamData

:=

1;

{fAll

spCategory

:=

spCType

typeVideo;

spDrvrSW

:=

spTBMask

catDisplay;

spSlot

{

flag

to

set

0

to

include

}

fOneslot

}

search

entry

in

<2
set
as
me
—

a

as

ge

all

specified

}

@

—

sResource}

{DrvrSw

field

sRsrcType

of

field

{

sResource;

{

being

field

of

sRsrcType
field

spCategory

0;

{start

search

from

here}

128;

{start

search

from

here}

SpExtDev

:=

0;

=

noErr

of

entry

is

this

in

not

not

in

}

in

}

}

entry

is

}

}

matched}

{match only
{ fields}

{ID

entry

sRsrcType

sResource;
this
being matched}

{DrvrHW

3;

of

«=

spiD

<=

to

resources;

{cType
field
{ sResource}

0;

:=

1

{ slot plus higher-numbered
slots}
{Category
field of sRsrcType
}

0;

:=

to

disabled

{
{

spDrvrHW

set

{

{
:=

flag

the

external

and

spcType

}

device}

END;

myErr

z=

0;

WHILE

myErr

DO

{loop

to

search

sResources}

BEGIN
myErr

:=

SGetTypeSRsrc

MysRsrcProc

(mySpBlk)

(@mySpBlk)

;

{your

;
routine

to

process

results}

END;

IF

myErr

<>

smNoMoresRsrcs

THEN

DoError

(myErr)

;

END;

system as configured. The system software version 7.0 Slot Manager gives you the option
of reinstalling a deleted sResource data structure if, for example, the user changes the system configuration or selects a different mode of operation. The SDeleteSRTRec function,
described in the Slot Manager chapter in Volume V, deletes sResource data structures; the
InsertSRTRec function reinstalls them.
Because none of the Slot Manager functions can search for sResource data structures that
have been deleted from the Slot Resource Table, you must keep a record of all sResource
data structures that you have deleted so that you will have the appropriate parameter values
available if you want to reinstall one.

Using the Slot Manager

30-9

.

Inside Macintosh,

Volume VI

When you reinstall an sResource data structure, you can also update the dCtIDevBase field in
the device driver’s Device Control Entry (DCE) data structure. The dCtlDevBase field holds
the address of the sResource data structure that is used by that device driver. For a video
driver, for example, the dCtIDevBase field might contain the address of the frame buffer. Use
the InsertSRTRec function to update the dCtIDevBase field. See the Device Manager chapters
of Volumes II and V for a definition of the DCE data structure.

SLOT

MANAGER

ROUTINES

This section describes the new Slot Manager routines. All Slot Manager routines take one
parameter: a pointer to a Slot Manager parameter block. Each routine description includes a
list of the fields affected by that routine. Each field in the list is preceded by an arrow that
indicates how the field is used.
Arrow

Meaning

—

You provide the value of the parameter as input to the Slot Manager.

_

The Slot Manager returns the value of the parameter after the function has
completed execution.

o

You provide a value for the parameter, and the Slot Manager returns

another value.

For a general description of the parameter block, see the following section, “The Slot
Manager Parameter Block.”
You can use the sVersion function, described in “Determining the Version of the Slot Manager”
to determine the version of the Slot Manager available to your program. The routines described
in “Getting Information About SResource Data Structures” replace or supplement three of the
Slot Manager routines described in the Slot Manager chapter in Volume V. These routines can
be used by applications as well as by device drivers. You can use the routines described in
“Enabling, Disabling, or Restoring SResource Data Structures,” to enable or disable sResource
data structures, or to restore sResource data structures deleted from the Slot Resource Table.
These routines are intended primarily for use by device drivers.

Assembly-language note: You can use an assembly-language macro to
call each of the Slot Manager routines. The assembly-language macro for a
routine has the same name as the Pascal routine, except that the name is
preceded by an underscore. However, these macros do not directly invoke
the trap mechanism. Instead, each of these macros places a routine selector in
the DO register and calls the trap macro _SlotManager. The routine selectors
for the new Slot Manager routines are shown in “Assembly-Language
Information” in the summary at the end of this chapter.
Place a pointer to the Slot Manager parameter block in the AO register when
you call each Slot Manager routine in assembly language. Each routine returns
with the status result in the low-order word of the DO register.
30-10

— Slot Manager Routines

The Slot Manager

The

Slot Manager

Parameter

Block

The spParamData field replaces the spStackPtr field in the parameter block used by all Slot
Manager routines. (The spStackPtr field was not used by any Slot Manager routines.) For
your convenience, the entire parameter block is listed here, with a brief description of each
field. Each Slot Manager routine uses only a subset of these fields. See the routine
descriptions for a list of the fields used with each routine.

S
ce
°

TYPE SpBlock =
PACKED

>

RECORD

oy

spResult:

LongInt;

{result}

spsPointer:

Ptr:

{structure

spSize:

Longint;

{size

spOffsetData:

Longint;

{offset/data
{

=

of

by

pointer}

so

structure}
field

SOffsetData
for

returned

spIOFileName:

Ptr;

{reserved

SpsExecPBlk:

Ptr;

{pointer

spParamData:

Longint;

{flags}

spMisc:

Longint;

{reserved

spReserved:

Longint;

{reserved}

splOReserved:

Integer;

{reserved

spRefNum:

Integer;

{Slot

spCategory:

Integer;

{sRsrc_Type:

Category

spCType:

Integer;

{sRsrc_Type:

cType

spDrvrsw:

Integer;

{sRsrc_Type:

DrvrSW

field}

spDrvrHw:

Integer;

{sRsrc_Type:

DrvrHW

field}

spTBMask:

SignedByte;

{type

bit

spSlot:

SignedByte;

{slot

number}

spID:

SignedByte;

{ID

of

the

sResource}

SpExtDev:

SignedByte;

{ID

of

the

external

device}

spHwDev:

SignedByte;

{ID

of

the

hardware

device}

spByteLanes:

SignedByte;

{byte
lanes
from
block}
{ format

spFlags:

SignedByte;

{reserved

for

Slot

Manager}

spKey:

SignedByte

{reserved

for

Slot

Manager}

to

Slot

Manager}

SEBlock

data

structure}

for

Slot

Manager}

for

Slot

Manager}

Resource

}

function}

Table

ref

number}

field}

field}

mask}

card

ROM

}

END;

Field

descriptions

spResult

A general-purpose field used to contain the results returned by several
different routines.

spsPointer

A pointer to a data structure. This field can point to an sResource data
structure, a data block, or the declaration ROM of a NuBus card,
depending on the routine being executed.

spSize

The size of a data block.

spOffsetData

The contents of the offset/data portion of a field in an sResource data
structure. This parameter is returned by the SOffsetData function.

splOFileName

Reserved for use by Apple Computer, Inc.
Slot Manager Routines

— 30-11

Inside Macintosh,

Volume VI

spsExecPBlk

A pointer to an SEBlock data structure. This field is used only by the
SExec function.

spParamData

A long word that indicates whether an sResource data structure is enabled
or disabled (if 0, the sResource data structure is enabled; if 1, it is
disabled) or that sets the values of one or more of the following flags:
Bit

Flag

Meaning

(0)

fAll

If 1, include disabled sResource data structures

in the search; if 0, ignore disabled sResource

data structures.

l

fOneslot

If 1, restrict search to the slot specified in the
spSlot field of the parameter block; if 0, search
the specified slot plus all slots with higher
numbers than the specified slot.

2

fNext

If 1, search for the sResource data structure that
follows the one specified by the spSlot, spID,
and spExtDev fields of the parameter block; if 0,
search for the sResource data structure specified
by these fields.

3-31

Reserved

Reserved for future use. These bits must be
cleared to 0.

spMisc

Reserved for use by the Slot Manager.

spReserved

Reserved for future use.

splOReserved

Reserved for use by the Slot Manager.

spRefNum

Device-driver reference number assigned by the Device Manager.

spCategory

Same as the Category field of the sRsrcType entry in the sResource data
structure you specify.

spCType

Same as the cType field of the sRsrcType entry in the sResource data
structure you specify.

spDrvrSW

Same as the DrvrSW field of the sRsrcType entry in the sResource data
structure you specify.

spDrvrHW

Same as the DrvrHW field of the sRsrcType entry in the sResource data
structure you specify.

spTBMask

A byte that allows you to specify which fields of the sRsrcType entry in
the sResource data structure should not be used by the SNextTypeSRsre
or SGetTypeSRsrc function. Set a bit to | to mask a field.

30-12

Bit

Field masked

0

DrvrHW

|

DrvrSW

2

cType

3

Category

Slot Manager Routines

The Slot Manager

spSlot

The number of the slot containing the NuBus card you wish to address.

spID

The sResource identification number from the sResource directory.

spExtDev

An external-device identification number. If a NuBus card contains
more than one device, the card can use this number to distinguish
between the devices.

spHwDev

The hardware-device identification number from the sRsrc_ HWDevId
field of the sResource data structure.

spByteLanes

Reserved for use by the Slot Manager.

spKey

Reserved for use by Apple.

Determining

the Version

SVersion

Parameter block
ce
00
ce

04

(spBlkPtr:

=

mh
tj)
@

Lew

of the Slot Manager

SpBlockPtr)

:

OSErr;

spResult

long

Slot Manager version number

spsPointer

long

pointer to additional information

The SVersion function returns the version number of the Slot Manager in the spResult field.
The system software version 7.0 Slot Manager returns version number | for a RAM-based
Slot Manager and version number 2 for a ROM-based Slot Manager. Older versions of
the Slot Manager do not recognize the SVersion function and return the nonfatal error
smSelOOBErr. The SVersion function returns a pointer to additional information, if any, in
the spsPointer field.
Result codes
noErr
smSelOOBErr

Getting

0
-—338

Information

No error
Selector out of bounds; function not implemented

About

SResource

Data

Structures

The Slot Manager routines described in the Slot Manager chapter of Volume V ignore any
disabled sResource data structures. However, there are times when you might want to know
what sResource data structures are available even if they are disabled and cannot be used. The
routines in this section perform the same tasks as routines described in Volume V, except that
the new routines give you the option of including disabled sResource data structures.
Slot Manager Routines

i)
as
ou

You can use the SVersion function to determine which version of the Slot Manager is in use
by the Operating System.
FUNCTION

<2)
<2
a

The NuBus byte lanes the Slot Manager is to use when communicating with the NuBus card’s declaration ROM. You can read the
byte-lane setting for a NuBus card from the card’s format block.
The SReadFHeader function returns a card’s format block.

spFlags

ie)

=

30-13

}

Inside Macintosh, Volume VI

FUNCTION

SGetSRsrce

(spBlkPtr:

SpBlockPtr)

:

OSErr;

Parameter block

-

04

spsPointer

long

pointer to the sResource
input: fAll, fOneslot, fNext flags
output: sResource enabled or disabled
Slot Resource Table reference number

>

24

spParamData

long

<

38
40

spRefNum

word

spCategory

word

Category field of sRsrcType entry
in sResource

ce

42

spCType

word

e

44

spDrvrS W

word

<

46

spDrvrHW

word

oo

49

spSlot

byte

cType field of sRsrcType entry in
sResource
DrvrSW field of sRsreType entry in
sResource
DrvrHW field of sRsrcType entry
in sResource
slot number

oO

50

spID

byte

ID of the sResource

o

51

spExtDev

byte

ID of the external device

on

Se

spHwDev

byte

ID of the hardware device

When you specify an sResource data structure, the SGetSRsrc function returns information
about that sResource data structure, the next sResource data structure in the same slot, or the
next sResource data structure in any higher-numbered slot. It performs the same function as
the SNextSRsrc function described in the Slot Manager chapter of Volume V, except that for
the SGetSRsrc function, you set the fAll, fOneslot, and fNext flags to specify which type of
search the function is to perform.
You specify an sResource data structure with the spSlot, spID, and spExtDev fields. You
must also set bits 0, 1, and 2 of the spParamData field as follows:
m Set the fAll flag (bit 0) to search both enabled and disabled sResource data structures.
w Clear the fAll flag to search only enabled sResource data structures.
m Set the fOneslot flag (bit 1) to search only the specified slot.
m Clear the fOneslot flag to search all slots.
=

Set the fNext flag (bit 2) to search for the sResource data structure that follows the

specified sResource data structure.

= Clear the fNext flag to return data about the sResource data structure that you specified.
The SGetSRsrc function returns new values in the spSlot, spID, and spExtDev fields specifying the sResource data structure that it found, and it returns in the spsPointer field a pointer
to the sResource data structure. If you cleared the fNext flag to 0, then the spSlot, spID, and
spExtDev fields return the same values that you specified when you called the function. The
SGetSRsrc function also returns information about the sResource data structure in the
30-14

— Slot Manager Routines

The Slot Manager

spRefNum, spCategory, spCType, spDrvrSW, spDrvrHW, and spHwDev fields. In
addition, the function returns 0 in the spParamData field if the sResource data structure is
enabled or | if it is disabled.
Result codes

noErr

0

smNoMoresRsrcs
FUNCTION

SGetTypeSRsrc

No error

—344

Specified sResource data structure not found

(spBlkPtr:

SpBlockPtr)

S

2)

: OSErr;

o
a

i

Parameter block
e

04

spsPointer

long

pointer to the sResource

oC

24

spParamData

long

i

38

spRefNum

word

input: fAll, fOneslot flags
output: sResource enabled or disabled
Slot Resource Table reference number

oe

40

spCategory

word

o

42

spCType

word

oO

44

spDrvrSW

word

o

46

spDrvrHW

word

Category field of sRsrcType entry
in sResource
cType field of sRsrcType entry in
sResource
DrvrSW field of sRsrcType entry in
sResource
DrvrHW field of sRsrcType entry
in sResource

~

48

spTBMask

byte

type bit mask

o

49

spSlot

byte

slot number

oC

50

spID

byte

ID of the sResource

oe

51

spExtDev

byte

ID of the external device

on

52

spHwDev

byte

ID of the hardware device

When you specify an sResource data structure and specify which resource-type fields to
match, the SGetTypeSRsrc function returns information either about the next sResource data
structure of the matching type it finds in the same slot or about the next sResource data structure of the matching type it finds in any higher-numbered slot. It performs the same function
as the SNextTypeSRsrc function described in Volume V, except that for the SGetTypeSRsrc
function, you set the fAll and fOneslot flags to specify which type of search the function is
to perform.
You specify an sResource data structure with the spSlot, spID, and spExtDev fields. You
must also use the spTBMask field to specify which fields of the sRsrcType entry in the
sResource data structure should not be included in the search, as follows:
= Set bit 0 to ignore the DrvrHW field.
Set bit | to ignore the DrvrSW field.
w Set bit 2 to ignore the cType field.
m Set bit 3 to ignore the Category field.
Slot Manager Routines

30-15

Inside Macintosh,

Volume

V1

In addition, you must clear the fAll flag of the spParamData field (bit 0) to 0 to search only
enabled sResource data structures or set the fAll flag to | to search both enabled and disabled
sResource data structures. Set the fOneslot flag (bit 1) to 1 to search only the specified slot or
clear it to 0 to search all slots.
The SGetTypeSRsre function returns new values in the spSlot, spID, and spExtDev —
fields specifying the sResource data structure that it found, and it returns in the spsPointer field
a pointer to the sResource data structure. The SGetTypeSRsrc function also returns information
about the sResource data structure in the spRefNum, spCategory, spCType, spDrvrSW,
spDrvrHW, and spHwDev fields. In addition, the function returns 0 in the spParamData field
if the sResource data structure is enabled or | if it is disabled.
Result codes
noErr
smNoMoresRsrcs

Enabling,

0
—344

Disabling,

No error
Specified sResource data structure not found

or Restoring

SResource

Data Structures

The routines in this section are primarily for use by device drivers. The first routine enables

and disables sResource data structures. The second routine restores sResource data structures
that have been deleted from the Slot Resource Table.
FUNCTION

SetSRsrcState

Parameter block
>
24

(spBlkPtr:

spParamData

SpBlockPtr)

__ long

:

OSErr;

enable or disable the sResource

>

49

spSlot

byte

slot number

—

50

spID

byte

ID of the sResource

—>

51

spExtDev

byte

ID of the external device

The SetSRsrcState function enables or disables an sResource data structure. An enabled
sResource data structure ‘can be used by the Operating System and is recognized by all
Slot Manager routines. A disabled sResource data structure is recognized only by the
SGetSRsre and SGetTypeSRsrc functions, and then only if you set the fAll flag of the
spParamData field.
You specify an sResource data structure with the spSlot, spID, and spExtDev fields and use
the spParamData field to specify whether the sResource data structure should be enabled
or disabled. Set spParamData to 0 to enable the sResource data structure or to | to disable the
sResource data structure.
Result codes
noErr

smNoMoresRsrcs

30-16

0

—344

— Slot Manager Routines

No error

Specified sResource data structure not found

The Slot Manager

FUNCTION

InsertSRTRec

(spBlkPtr:

SpBlockPtr)

:

OSErr;

Parameter block
>

04

spsPointer

long

NIL

>

24

spParamData

long

flags

Ss

aaa

38

spRefNum

word

-

49

spSlot

byte

Slot Resource Table reference
number

slot number

me

>

50

spID

byte

ID of the sResource

i

~

51

spExtDev

byte

ID of the external device

i

y

The InsertSRTRec function adds an sResource data structure to the Slot Resource Table.
You can use the function to restore an sResource data structure that was deleted from the
Slot Resource Table with the SDeleteSRTRec function, described in Volume V. For example,
if the user makes a selection in the Monitors control panel that requires your video card to
switch to a new sResource data structure that was deleted by the PrimaryInit code, you can
use the InsertSRTRec function to restore that sResource data structure.
You specify an sResource data structure with the spSlot, spID, and spExtDev fields. You
must set the spsPointer to all zeros. Set the spParamData field to | to disable the restored
sResource data structure or to 0 to enable it.
If you place a valid device-driver reference number in the spRefNum field, then the Slot
Manager updates the dCtlIDevBase field in that device driver’s DCE data structure (that is,
in the DCE that has that device-driver reference number in the dCtlRefNum field). The

dCtlDevBase field contains the base address of the memory buffer for data provided by
the sResource data structure that is used by that device driver. The Slot Manager calculates
this address by using bit 2 (the f32BitMode flag) of the sRsrc_Flags field of the sResource
data structure and the MinorBaseOS or MajorBaseOS field of the sResource data structure.
Table 30-2 shows how the Slot Manager determines what format to use for this address.
The DCE data structure is described in the Device Manager chapters of Volumes II and V.

The sResource data structure is described in Designing Cards and Drivers for the Macintosh

Family, second edition.
Result codes

noErr
memFullErr
smUnExBusErr
smBadRefld
smBadsList

Q
—108
—308
—330
—331

smReservedErr
smSlotOOBErr
smNoMoresRsres
smBadsPtrErr
smByteLanesErr

—332
—337
-344
-—346
-—347

Noerror
Not enough room in heap
| Unexpected bus error
Reference ID not found in list
Bad sResource structure: Id] < Id2 <Id3 ...
format is not followed
Reserved field not 0
Slot number out of bounds
— Specified sResource data structure not found
Bad pointer was passed to sCalcSPointer function
— ByteLanes field in card’s format block was determined
to be 0
Slot Manager Routines

= 30-17

Inside Macintosh,

Table 30-2.

Volume VI

How the Slot Manager determines the base address used by
an sResource data structure

sRsre_Flags

MinorBaseOS

MajorBaseOS

Address
format

Address
type

Field missing

$XXXXX

Any or none

$Fssx XXXX

| MB address
space; can be
used in either
24-bit or 32-bit
mode

Field missing

None

$XXXXXX

$SXXX XXXX

Superslot space

Bit 2 is 0

$XXXXX

Any or none

$SFssx XXXx

| MB slot space

Bit 2 is 0

None

$XXXXXX

$SXXX XXXX

Superslot space

Bit 2 is |

$XXXXXX

Any or none

SFsxxX XXXx

Standard slot
space (32-bit
minor base

address)

Bit 2 is |

None

$XXXXXXX

$SXXX XXXX

Superslot space
(32-bit major

base address)

Note: In a hexadecimal number in this table, x is any value and s is a slot number.

30-18

Slot Manager Routines

The Slot Manager

SUMMARY

OF

THE

SLOT

MANAGER

Constants
:
CONST

»

,

svDisabled

=

$8080;

svTempDisable

=

$8000;

{top of range of error
codes
to disable
{ a NuBus
card}
{start
of range of error
codes
to
{ disable
a NuBus
card}

}

D

S
=<
=

ie
@

m

Data
TYPE

Types
SpBlock
PACKED

=
RECORD

spResult:

LongIint;

{result}

spsPointer:
spSize:

Ptr;
Longint;

spOffsetData:

LongInt;

returned
field
{offset/data
{ by SOffsetData
function}

splOFileName:

Ptr;

{structure pointer}
{size of structure}

}

Per

for Slot Manager}
{reserved
structure}
data
SEBlock
to
{pointer

spParamData:

Longint ;

{flags}

spMisc:
spReserved:

Longint;

{reserved

Longint;

splOReserved:

Integer;

spRefNum:

Integer;

spCategory:

Integer;

spCType:

Integer;

{reserved}
for Slot Manager}
{reserved
ref number}
Table
Resource
{Slot
field}
Category
{sRsrc_Type:
field}
cType
{sRsrc_Type:

spDrvrSw:

Integer;

{sRsrc_Type:

DrvrSW

field}

spDrvrHw:

Integer;

{sRsrc_Type:

DrvrHW

field}

spsExecPBI1k:

bit

Slot

for

Manager}

mask}

spTBMask:

SignedByte;

{type

spSlot:

SignedByte;

spID:

SignedByte;

SpExtDev:
spHwDev:
spByteLanes:

SignedByte;
SignedByte;
SignedByte;

{slot number}
{ID of the sResource}
device}
{ID of the external
device}
{ID of the hardware
}
ROM
card
from
lanes
{byte

spFlags:

SignedByte;

{reserved

spKey:

SignedByte

{

format

block}
for Slot
for Slot
{reserved

Manager}
Manager}

END;

SpBlockPtr

=

“SpBlock;

Summary of the Slot Manager

30-19

Inside Macintosh,

Volume VI

Routines

Determining

the Version

of the Slot Manager

FUNCTION

SVersion

Getting

Information

FUNCTION

SGetSRsrc

(spBlkPtr:

SpBlockPtr)

:

OSErr;

FUNCTION

SGetTypeSRsrc

(spB1lkPtr:

SpBlockPtr)

:

OSErr;

Enabling,

(spBlkPtr:

Disabling,

About

SpBlockPtr)

SResource

or Restoring

:

Data

OSErr;

Structures

SResource

Data

FUNCTION

SetSRsrcState

(spBlkPtr:

SpBlockPtr)

:

OSErr;

FUNCTION

InsertSRTRec

(spBlkPtr:

SpBlockPtr)

:

OSErr;

Result

Codes

noErr
memFullErr
smUnExBusErr
smBadRefld
smBadsList

0
—108
—308
—330
—331

smReservedErr
smSlotOOBErr
smSelOOBErr
smNoMoresRsrcs
smBadsPtrErr
smByteLanesErr

—332
—337
—338
—344
—346
—347

30-20

Structures

No error
Not enough room in heap
Unexpected bus error
Reference [D not found in list
Bad sResource structure: Id1 < Id2 < Id3 ...
format is not followed
Reserved field not 0
Slot number out of bounds
Selector out of bounds; function not implemented
Specified sResource data structure not found
Bad pointer was passed to sCalcSPointer function
ByteLanes field in card’s format block was determined
to be 0

~~ Summary of the Slot Manager

The Slot Manager

Assembly-Language
Slot Manager

Parameter

spResult
spsPointer
spSize
spOffsetData
splOFileName
spsExecPBlIk
spParamData
spMisc
spReserved
splOReserved
spRefNum
spCategory
spCType
spDrvrSW
spDrvrHW
sp BMask
spSlot
spID
spExtDev
spHwDev
spByteLanes
spFlags
spKey

Trap

Macros

Information

long
long
long
long

long
long
long
long
long
word
word
word
word
word
word
byte
byte
byte
byte
byte
byte
byte
byte

Requiring

Block
result
address of structure
size of structure
offset/data field
reserved for Slot Manager
address of SEBlock data structure
flags
reserved for Slot Manager
reserved for future expansion
reserved for Slot Manager
Slot Resource Table reference number
Category field of sRsrcType entry in sResource
cType field of sRsrcType entry in sResource
DrvrSW field of sRsrcType entry in sResource
DrvrHW field of sRsrcType entry in sResource
type bit mask
slot number
ID of the sResource
ID of the external device
ID of the hardware device
byte lanes from card ROM format block
reserved for Slot Manager
reserved for Slot Manager

Routine

Selectors

_SlotManager
Selector

Routine

$08

sVersion

$0B

sGetsRsrc

$09
$OA

$0C

sSetsRsrcState
sInsertSRTRec

sGetTypesRsre

Summary of the Slot Manager

— 30-21

2)

S
_

=

Lael

iy
=
a
go
@

~

Inside Macintosh, Volume VI

30-22

THE

POWER

MANAGER

About This Chapter
About the Power Manager
The Idle State
The Sleep State
The Sleep Queue
Sleep Requests
Sleep Demands
Wakeup Demands
Sleep-Request Revocations
Using the Power Manager
Determining Whether the Power Manager Is Present
Enabling or Disabling the Idle State
Setting, Disabling, and Reading the Wakeup Timer
Placing a Routine in the Sleep Queue
Responding When the Sleep Queue Calls Your Routine
Switching Serial Power On and Off
Power Manager Routines
Controlling the Idle State
Controlling and Reading the Wakeup Timer
Controlling the Sleep Queue
Controlling Serial Power
Reading the Status of the Internal Modem
Reading the Status of the Battery and of the Battery Charger
Summary of the Power Manager

ae

_
ww
i)
<
=<
o
“I

2pene
<j

=
pe)
ve
o
—

a

31-1

|

Inside Macintosh, Volume VI]

31-2

The Power Manager

ABOUT

THIS

CHAPTER

The Power Manager, provided only in the firmware of the Macintosh® Portable computer,
controls power to the internal hardware devices of the Macintosh Portable in order to conserve
power whenever the computer is not in use. The Macintosh Portable operates only with system
software version 6.0.4 and later versions.
The Macintosh Portable computer operates from a built-in battery that can be charged from
a voltage converter plugged into an electric socket. The Macintosh Portable has no power
switch; instead, it contains firmware and hardware that can put the computer into two
low—power-consumption states, the idle state and the sleep state.

—

~

In the idle state, the Power Manager firmware slows the computer from its normal
16-megahertz (MHz) clock speed to a | MHz clock speed. The Power Manager puts
the Macintosh Portable in the idle state when the system has been inactive for 15 seconds.
When the Macintosh Portable has been inactive for an additional period of time (the user
can set the length of this period), the Power Manager and the various device drivers
shut off power or remove clocks from the computer’s various subsystems, including
the CPU, RAM, ROM, and I/O ports. This condition is known as the sleep state.

=a
<

@

er.
2

_
=

=
~

go

oD

Leer |

No data is lost from RAM when the Macintosh Portable is in the sleep state. Most applications can be interrupted by the idle and sleep states without any adverse effects. When the
user resumes use of the computer (by pressing a key, for example), most of the applications
that were running before the Macintosh Portable entered the sleep state are still loaded in
memory and resume running as if nothing had happened. If your application cannot tolerate
the sleep state, you can add an entry to an operating-system queue called the sleep queue. The
Power Manager calls every sleep queue routine before the computer goes into the sleep state.

The user can also use the Battery desk accessory or either of two Finder™ menu items to

cause the Macintosh Portable to go into the sleep state immediately. If the user chooses Sleep
from the Battery desk accessory or from the Special menu in the Finder, the Power Manager
checks to see if any network communications will be interrupted by going into the sleep state.
If network communications will be affected, a built-in sleep queue routine displays a dialog
box giving the user the option of canceling the Sleep command. If the user chooses Shut
Down from the Special menu in the Finder, the Power Manager puts the Macintosh Portable
in the sleep state regardless of whether any network communication routines are running at
the time.

The Power Manager described in this chapter is the firmware that provides an interface to the
50753 microprocessor (the Power Manager Integrated Circuit or Power Manager IC) in the
Macintosh Portable computer. The Power Manager firmware also provides some services
unique to the Macintosh Portable—such as reading the current clock speed—that are not
directly related to power control. The power management circuits and the microcode in the
on-chip ROM of the Power Manager IC are described in the Guide to the Macintosh Family
Hardware, second edition. The Power Manager provides routines that your program can use
to enable and disable the idle state, to control power to some of the subsystems of the
Macintosh Portable computer, and to ensure that your program is not adversely affected when
the Power Manager puts the Macintosh Portable into the sleep state.
This chapter describes the idle and sleep states and explains how your program can use
Power Manager routines. You need the information in this chapter only if you are writing
About This Chapter

Ge

31-3

Inside Macintosh,

Volume

V1

a program—such as a device driver—that must control power to a subsystem of the
Macintosh Portable computer, or if you are writing a program that might be affected by
the idle or sleep state.
Because the Power Manager saves the contents of all of the CPU’s registers, including the
stack pointer, before putting the Macintosh Portable in the sleep state, and because the contents
of RAM are preserved while the Macintosh Portable is in the sleep state, most applications are
not adversely affected by the sleep state. Because the Macintosh Portable does not enter the
idle state when almost any sort of activity is going on or even when the watch cursor is being
displayed, few programs are adversely affected by the idle state. Therefore, it is probable that
your application will not have to make calls to the Power Manager.
This chapter first describes the relationships among the power management hardware, microcode, and firmware in the Macintosh Portable computer. It then discusses the idle and sleep

states and the sleep queue in some detail. The section “Using the Power Manager” describes
how to use Power Manager routines to control the idle and sleep states and how to use the
sleep queue.

ABOUT

THE

POWER

MANAGER

The power management circuits in the Macintosh Portable computer include a battery-voltage
monitor, a voltage regulator and battery-charging circuit, and the Power Manager IC. The
Power Manager IC controls the clocks and power lines to the various internal components
and external ports of the Macintosh Portable computer. The microcode in the Power
Manager IC implements many of the Macintosh Portable computer’s power management
features, such as power and clock control and the wakeup timer. A user or an application can
set the wakeup timer to return the computer from the sleep state to the operating state at a
specific time.
Figure 31-1 illustrates the relationships among your application, the Power Manager firmware,
the Power Manager IC, the power management circuits, and the other subsystems of the
Macintosh Portable computer. The Power Manager firmware in the ROM of the Macintosh
Portable provides an interface that allows your application to control some of the functions of
the Power Manager IC. Under control of the microcode in the Power Manager IC, the power
management hardware charges the battery, provides the voltages needed by the system, and
automatically shuts down all power and clocks to the system if the battery voltage falls below
5.65 volts. The automatic shutdown function helps to prevent possible damage to the battery
resulting from low voltage.
You can use the routines described in this chapter to
m enable, disable, or delay the idle feature
m read the current clock speed
m set or disable the wakeup timer and read its current setting
m place an entry in the sleep queue so that the Power Manager calls your routine before
putting the Macintosh Portable into the sleep state or returning it to the operating state
31-4

About the Power Manager

The Power Manager

J]

Power Manager
firmware

J]

o>)
—

—

J]

Power Manager

i)
<
=
o
ar

IC

<

Power management

—

pe)

circuits

Power

—>

Clock signals

—»

—

—~

ro)
ve
o)
ar

vy

Subsystems and

peripheral devices

Figure 31-1. Relationship of an application to the Power Manager
m= remove an entry from the sleep queue
= control power to the internal modem and serial ports
m read the status of the internal modem
m read the state of the battery charge and the status of the battery charger

THE

IDLE

STATE

When the Macintosh Portable computer is inactive for 15 seconds, the Power Manager
firmware causes the CPU to insert 64 wait states into each RAM or ROM access,

effectively changing the clock speed from 16 MHz to | MHz. This condition is referred
to as the idle state.

Note: The inactivity timeout interval, clock speed, and hardware implementation
of the idle state are subject to change in future portable Macintosh computers.
The Idle State

31-5

Inside Macintosh,

Volume

V1

For the purposes of the idle state, inactivity is defined as the absence of any of the following:
m any execution of the PBRead or PBWrite function by the File Manager or
Device Manager
m acall to the Operating System Event Manager’s PostEvent function
m any events in the event queue
m any access of the Apple® Sound Chip

(ASC)

s completion of an Apple Desktop Bus™ (ADB) transaction
m acall to the QuickDraw™ SetCursor procedure that changes the cursor
m the cursor displayed as the watch cursor
Whenever the Power Manager detects one of these forms of activity, it resets a timer called
the activity timer to 15 seconds and, if the Macintosh Portable is in the idle state, returns the
computer to the operating state.
Neither the user nor your program can change the activity timer to use a period other than
15 seconds. However, the user can disable the activity timer through the Portable control
panel, and your application can reset, disable, and enable the activity timer by using the
IdleUpdate, Enableldle, and Disableldle routines. Your application can also use the
GetCPUSpeed function to determine whether the Macintosh Portable is currently in the
idle state. “Enabling or Disabling the Idle State” later in this chapter discusses these routines.

THE

SLEEP

STATE

The Operating System sends a sleep command to the Power Manager IC when the user
requests it (through the Battery desk accessory or the Finder), when the battery voltage
falls below a preset level, or when the system has remained inactive for an amount of time
that the user sets through the Portable control panel.
The Operating System uses the Power Manager IC to shut down power to the CPU, the
ROM, and some of the control logic. Sufficient power is maintained to the RAM so that
no data is lost. Before the Operating System sends the sleep command to the Power
Manager IC, it performs the following tasks:
m

It pushes the contents of all of the CPU’s internal registers onto the stack.

m

It calls all routines listed in the sleep queue to inform them that the system is about to be
put into the sleep state. These routines include the device drivers for the serial ports and
floppy disk drives, Each device driver must call the Power Manager IC to stop power
or clocks to the peripheral device controlled by that driver. If the device contains any
internal registers, the device driver must save their contents before turning off power to
the device. The sleep queue is described in the following section, “The Sleep Queue.”

31-6

The Sleep State

The Power Manager

a It pushes onto the stack the Reset vector, the contents of the versatile interface adapter
(VIA) chip, and the contents of the Apple Sound Chip (ASC) control registers.
a It saves the stack pointer in memory.

While the Macintosh Portable computer is in the sleep state, the clock to the Power
Manager IC is off so that the chip does no processing. On each rising edge of the 60 Hz
clock signal (from one of the Macintosh Portable computer’s logic chips), a hardware
circuit restores the clock signal to the Power Manager IC. The Power Manager IC
updates the time in the real-time clock and checks the status of the system to determine
whether to return the Macintosh Portable to its operating state. The Power Manager IC
checks for the existence of the following conditions:
os)

m A key on the keyboard has been pressed.

ae

—
—

~~
=

<a
-

m The wakeup timer is enabled and the time to which the wakeup timer is set equals
the time in the real-time clock.

‘<°)

as)
a

neht
—
—
~oO)
oe

a An internal modem is installed, the user has activated the ring-detect feature, and

tj)
ce

the modem has detected a ring (that is, someone has called the modem).

—

Note that use of the mouse or trackball cannot be detected by the Power Manager IC.
If the Power Manager IC does not detect any of these conditions, it deactivates its own clock
until the next rising edge of the 60 Hz clock signal. If the Power Manager IC does detect one
of these conditions, it restores power to the CPU, ROM, and any other hardware that was
running when the computer entered the sleep state. Then the Power Manager’s wakeup procedure reverses the procedure that put the Macintosh Portable into the sleep state, including
calling each routine listed in the sleep queue to allow it to restore power to any subsystems
it controls.

THE

SLEEP

QUEUE

The Power Manager maintains an operating-system queue called the sleep queue. The sleep
queue contains pointers to all of the routines that the Power Manager must call before it puts
the Macintosh Portable into the sleep state or returns it to the operating state. Each device
driver, for example, must place in the sleep queue a pointer to a routine that controls power
to the subsystem that the driver controls. When the Power Manager is ready to put the
Macintosh Portable into the sleep state, it calls each of the routines listed in the sleep queue.
Each routine performs whatever tasks are necessary to prepare for the sleep state, including
calling Power Manager routines, and then returns control to the Power Manager. Similarly,
the Power Manager calls each routine in the sleep queue when it is returning the Macintosh
Portable to the operating state.
If you are writing a device driver or if you want your program to be informed before the
Macintosh Portable enters the sleep state, you must place an entry for your routine in the
sleep queue. If you do place an entry in the sleep queue, remember to remove it before your
device driver or application terminates. You use the SleepQInstall and SleepQRemove
procedures to install and remove sleep queue entries, as described in “Placing a Routine in
the Sleep Queue” later in this chapter.
The Sleep Queue

31-7

$

Inside Macintosh,

Volume VI

The Power Manager can call the routines listed in the sleep queue with a sleep request, a
sleep demand, a wakeup demand, or a sleep-request revocation, as discussed in the
following sections.

Sleep

Requests

A sleep request informs a routine that the Power Manager would like to put the Macintosh
Portable computer into the sleep state. The routine then has the option of denying the sleep
request. If any routine in the sleep queue denies the sleep request, the Power Manager sends
a sleep-request revocation to each routine that it has already called with a sleep request, and
the Macintosh Portable does not enter the sleep state. If every routine in the sleep queue
accepts the sleep request, then the Power Manager sends a sleep demand to each routine in
the sleep queue. After every routine has processed the sleep demand, the Power Manager IC
puts the Macintosh Portable into the sleep state.
Figure 31-2 illustrates the sequence of events that occurs when the Power Manager issues a
sleep request.
Before calling any of the routines in the sleep queue with a sleep request, the Power Manager
calls a built-in sleep queue entry that checks the status of certain network services, as summarized in Table 31-1. Only if all of the network services permit sleep does the Power Manager
continue to send sleep requests to the routines in the sleep queue. The network services in
Table 31-1 are described in the AppleTalk Manager chapter of this volume.
The Power Manager issues a sleep request when a sleep timeout occurs (that is, when the
period of inactivity set by the user in the Portable control panel has expired).
Table 31-1.

Network
in use

Response of network services to sleep requests and demands

service

-.MPP low-level

protocol (DDP, NBP,
RTMP, AEP)

.XPP extended

protocol

(ASP, AFP);

no server volume
mounted

Response to
sleep request
Close driver if
Macintosh Portable is

on battery; else deny
request

Close driver if
Macintosh Portable is

on battery; else deny
request

Response to
conditional
sleep demand

Response to
unconditional
sleep demand

Close driver if user
gives okay; else deny
request

Close driver

Close driver if user

Close driver

gives okay; else deny
request

.XPP; server volume
mounted

Deny request

Close server sessions
and close driver if
user gives okay; else
deny request

Close server sessions

An application is
currently using

Deny request

Close server sessions
and close driver if

Close server sessions
and close driver

AppleTalk®

31-8

The Sleep Queue

user gives okay; else
deny request

and close driver

The Power Manager

Power Manager

{

Denies

|

Network check

y=

If

y

Accepts

|

)

Y

Sleep request

f
Ge

Sleep queue

ome
Power Manager
cancels

sleep request

a

|

am

S~~

Executes first
routine

@

Lew |

bs
=

If

ie
ge
@
ar)

Then
<j.

;
Denies

If
<<

Executes second
Patithe

If

Then
GINES

:

If

Executes third
routine, etc.

All routines

accept sleep
request

Then

Y

Power Manager
sends sleep demand
to each routine in
sleep queue

Figure 31-2.

How the sleep queue handles a sleep request

The Sleep Queue

31-9

Inside Macintosh,

Sleep

Volume VI

Demands

A sleep demand informs a routine that the Power Manager is about to put the Macintosh
Portable into the sleep state. When a routine in the sleep queue receives a sleep demand, it must
prepare for the sleep state as quickly as possible and return control to the Power Manager.
Figure 31-3 illustrates the sequence of events that occurs when the Power Manager issues a
sleep demand.
Power Manager

(

Denies

If

)<——_|

|

Network check

|

Accepts

Y
Power Manager
cancels conditional
sleep demand

Sleep demand
Sleep queue

|

|

Executes first
routine

Executes second
routine

Executes third
routine, etc.

All routines

ane

for sleep

Power _
puts Reais

in sleep state

Figure 31-3.

31-10

~The Sleep Queue

How the sleep queue handles a sleep demand

The Power Manager

From the point of view of the Power Manager, there are two types of sleep demands—
conditional and unconditional. The Power Manager might cancel a conditional sleep
demand if certain network services are in use; an unconditional sleep demand cannot be
canceled. When your sleep queue routine receives a sleep demand, however, your routine
has no way to determine whether it originated as a conditional sleep demand or an unconditional sleep demand. Your device driver or application must prepare for the sleep state
and return control promptly to the Power Manager when it receives a sleep demand.
The Power Manager processes a conditional sleep demand when the user chooses Sleep
from the Battery desk accessory or from the Special menu in the Finder. When the Power
Manager processes a conditional sleep demand, it first sends a sleep request to the network
driver's sleep queue routine (see Table 31-1). Whenever one of the network services is

in use, the sleep queue routine displays a dialog box requesting the user’s permission to put
the Macintosh Portable into the sleep state. The wording of the message in the dialog box
depends on the nature of the network service in use. For example, if an .XPP driver protocol
is in use, has opened a server, and has mounted a volume, then the message warns the user
that the volume will be closed when the Macintosh Portable is put into the sleep state.

<4

a
+S)

i

Demands

After restoring full power to the CPU, RAM, and ROM, the Power Manager’s wakeup
procedure calls each routine in the sleep queue with a wakeup demand. A wakeup demand
informs your routine that it must reverse whatever steps it followed when it prepared for the
sleep state. For example, a database application might reestablish communications with a
remote database.

Revocations

If any routine in the sleep queue denies a sleep request, the Power Manager sends a
sleep-request revocation to every routine that it has already called with a sleep request.
Your routine must reverse whatever steps it followed when it prepared to receive a sleep
demand. A communications application that prevents users from opening new sessions
while it is waiting to receive a sleep demand, for example, might once again allow users
to Open new sessions.

The Sleep Queue

=

@

Lew }

)
va

The Power Manager issues an unconditional sleep demand when the battery voltage falls
below a preset level or when the user chooses Shut Down from the Special menu in the
Finder. In this case, the Power Manager sends a sleep demand to the network driver’s sleep
queue entry, which closes all network drivers. Then the Power Manager sends a sleep
demand to every other routine in the sleep queue. As always for a sleep demand, each routine
must prepare for the sleep state and return control to the Power Manager as quickly as
possible. In this case, the Power Manager does not display any warnings or dialog boxes;
neither the network services, the user, nor any application can deny the sleep demand.

Sleep-Request

—

moe
o
i)

o

If the user denies permission to close the driver, the Power Manager does not send sleep
demands to the routines in the sleep queue. If the user does give permission to close the
driver, the Power Manager sends a sleep demand to the network driver’s sleep queue
routine and then to every other routine in the sleep queue.

Wakeup

Ww

31-11

Inside Macintosh,

Volume VI

USING

POWER

THE

MANAGER

If you are writing an application that is sensitive to the clock speed of the computer, you can
use the Power Manager to disable the idle state when necessary.
Note: Do not disable the idle state except when executing a routine that must run at
full speed. Disabling the idle state shortens the amount of time the user can operate the
Macintosh Portable computer from a battery.
If you want to ensure that the Macintosh Portable is in the operating state at a particular time
in the future, you can use the SetWUTime function to set the wakeup timer. You can use the
wakeup timer in conjunction with the Time Manager, for example, when you want to use the
Macintosh Portable to perform tasks that must be done at a specific time, like printing a large
file in the middle of the night.
If you are writing an application that might be affected by the sleep state of the computer, you
can place in the sleep queue a routine that handles whatever preparations are necessary to
protect your program when the Macintosh Portable enters the sleep state. “Placing a Routine
in the Sleep Queue” and “Responding When the Sleep Queue Calls Your Routine” later in this
chapter describe the sleep queue.
If you are writing a device driver for the Macintosh Portable computer, you might need to
use the Power Manager to control power to the subsystem that your driver controls. See
“Switching Serial Power On and Off” later in this chapter, for a discussion of power
control for the serial communications subsystem. For power control for other devices,
consult Apple Developer Technical Support. The Power Manager cannot control power to
external peripheral devices such as hard disks and CD-ROM drives because such devices
have their own power supplies.
You can also use Power Manager functions to read the status of the internal modem and to
read the state of charge of the battery and the status of the battery charger.

Determining

Whether

the Power

Manager

Is Present

You can use the Gestalt function with the gestaltPowerMgrAttr selector to determine whether
the Power Manager is available and whether certain other devices in the computer can be put
into the sleep state. The Gestalt function returns a 32-bit field that may have some or all of the
following bits set:
CONST

gestaltPMgrExists

=

Q;

{Power

gestalt

=

In

{CPU

can

idle}

=
=

23
3

{can
{can

stop
shut

SCC
off

PMgrCPUIdle

gestaltPMgrSCC
gestalt PMgrSound

Manager

is

present}

clock}
sound circuits}

If the gestaltPMgrExists bit is set, the Power Manager is present. If the gestaltPMgrCPUldle bit
is set, the CPU is capable of going into a low—power-consumption state. If the gestaltPMgrSCC

31-12

Using the Power Manager

The Power Manager

bit is set, it is possible to stop the SCC clock, thus effectively turning off the serial ports. If
the gestaltPMgrSound bit is set, it is possible to turn off power to the sound circuits.

Enabling

or Disabling the Idle State

You can reset the activity timer to 15 seconds, disable and enable the idle state, and read the
current CPU clock speed by using Power Manager routines.
Keep in mind that it is almost always better to design your code so that it is not affected by
the idle state; then the Macintosh Portable can conserve power whenever possible. Note also
that disabling the idle state does not disable the sleep state. To prevent your program from
being adversely affected by the sleep state, place a routine in the sleep queue, as described in
“Placing a Routine in the Sleep Queue” later in this chapter.
To reset the activity timer to count down another 15 seconds before the Power Manager puts
the Macintosh Portable in the idle state, use the Idle Update function. The IdleUpdate function
takes no parameters; it returns the value in the Ticks global variable at the time the function
was called.
If you want to disable the idle state—that is, prevent the Macintosh Portable from entering the
idle state—for more than 15 seconds, use the Disableldle procedure. If your application
cannot tolerate the idle state at all, you can call the Disableldle procedure when your application starts up and then call the EnablelIdle procedure when your application terminates.

Assembly-language note: Although MPW® provides assembly-language
macros to execute the Enableldle, DisableIdle, and GetCPUSpeed routines,
each of these macros calls the _IdleState trap. To call the _IdleState trap
directly, you must first put a longword routine selector in DO, as follows:
DO <0
DO = 0
DO > 0

GetCPUSpeed; speed returned as a single byte in DO
Enableldle
Disableldle

The Enableldle procedure cancels the last call to the Disableldle procedure. Note that canceling
the last call to the DisableIdle procedure is not the same thing as enabling the idle state. For
example, if the user has used the Portable control panel to disable the idle state, then a call to
the Enableldle procedure does not enable the idle state. Similarly, if your routine called the
Disableldle procedure more than once or if another routine has called the Disableldle procedure, then a call to the EnableIdle procedure cancels only the last call to the Disableldle
procedure; it does not enable the idle state.
The Power Manager does not actually reenable the idle state until every call to the Disableldle
procedure has been matched by a call to the Enableldle procedure, and then only if the user
has not disabled the idle state through the Portable control panel. For this reason, you must
be very careful to match each call to the DisablelIdle procedure with a single call to the
Enableldle procedure. Be careful to avoid making extra calls to the EnableIdle procedure
so that you do not inadvertently reenable the idle state while another routine needs it to
remain disabled.

Using the Power Manager

—- 331-13

Gn
—

wv

i)
<A

<
0)
Lae

i
—

mn
=
i)
ge

<)
ar)

Inside Macintosh,

Volume

VI

Calls to the Enableldle procedure are not cumulative; that is, after you make several calls to
the Enableldle procedure, a single call to the Disableldle procedure still disables the idle state.
Disabling the idle state always takes precedence over enabling the idle state. A call to the
Disableldle procedure disables the idle state no matter how many times the Enableldle
procedure has been called and whether or not the user has enabled the idle state through the
Portable control panel.
The following examples might help to clarify these concepts:
a If the application calls the Enableldle routine but the user disables or has disabled the
idle state, the idle state is disabled.
m If the application calls the DisableIdle routine and the user enables or has enabled the
idle state, the idle state is disabled.
= If the application calls the Disableldle routine twice in a row and then calls the
Enableldle routine once, the idle state is disabled.
m If the application calls the Enableldle routine twice in a row and then calls the
Disableldle routine once, the idle state is disabled.

a If the idle state is initially enabled and if the application calls the Disableldle routine
twice in a row and then calls the Enableldle routine twice, the Power Manager first
disables and then reenables the idle state.
To determine whether the Macintosh Portable is currently in the idle state, read the current
clock speed with the GetCPUSpeed function. The only values returned by the GetCPUSpeed
function are | and 16, indicating the effective clock speed in megahertz.

Setting,

Disabling,

and

Reading

the

Wakeup

Timer

When the Macintosh Portable computer is in the sleep state, the Power Manager IC updates
the real-time clock and compares it to the wakeup timer once each second. When the real-time
clock and the wakeup timer have the same setting, the power management circuits return the
Macintosh Portable to the operating state. The Power Manager provides functions that set the
wakeup timer, disable the wakeup timer, and read the wakeup timer’s current setting.
Use the SetWUTime function to set the wakeup timer. You pass one parameter to the
SetWUTime function: an unsigned long word specifying the number of seconds since
midnight, January 1, 1904. Setting the wakeup timer automatically enables it.
To disable the wakeup timer, you can set the wakeup timer to any time earlier than the
current setting of the real-time clock (that is, to some time in the past), or you can use the
DisableWUTime function. To reenable the wakeup timer, you must use the Se\WUTime
function to set the timer to a new time in the future.

To get the current setting of the wakeup timer, use the GetWUTime function. This function
returns two parameters: the time to which the wakeup timer is set (in seconds since midnight,
January 1, 1904) and a flag indicating whether the wakeup timer is enabled.
If the Macintosh Portable is already in the operating state when the real-time clock reaches the
setting in the wakeup timer, nothing happens.
The power management circuits do not return the Macintosh Portable to the operating state
while battery voltage is low, even if the wakeup timer and real-time clock settings coincide.
31-14

Using the Power Manager

The Power Manager

Placing a Routine

in the Sleep Queue

If you want your routine to be notified before the Power Manager puts the Macintosh
Portable into the sleep state or returns it to the operating state, you must put an entry in
the sleep queue. If you do place an entry in the sleep queue, remember to remove it
before your device driver or application terminates.
The sleep queue is a standard operating-system queue, as described in the Operating
System Utilities chapter in Volume II. The SleepQRec data type defines a sleep queue
record as follows:
TYPE

SleepQRec

=

uw
—

RECORD
sleepOLink:

SleepQRecPtr;

{pointer

to

sleepQOType:

Integer;

{queue

sleepQOProc:

ProcPtr;

{pointer

SsleepOFlags:

Integer

{reserved}

type
to

next
=

queue

element}

sleep

routine}

~

—)
A
=
.
ar |

16}

your

<
—
SS

|
ey)
ge

END;

@o

a

The sleepQLink field contains a pointer to the next element in the queue. This pointer is
maintained by the Power Manager; your application should not modify this field.
The sleepQType field indicates the type of the queue, which must be the constant
slpQType (16).
The sleepQProc field contains a pointer to the routine that you provide. The sleepQFlags
field is reserved for use by Apple Computer, Inc.
To add an entry to the sleep queue, fill in the sleepQType and sleepQProc fields of a sleep
queue record and then execute the SleepQInstall procedure. The SleepQInstall procedure
takes one parameter, a pointer to your sleep queue record. Listing 31-1 adds an entry to the
sleep queue.
Listing 31-1. Adding an entry to the sleep queue
VAR
MyRec:

SleepORec;

BEGIN
{set
WITH

up the record
MyRec
DO

before

installing

onto

the

sleep

queue}

BEGIN

sleepOQLink
sleepQType
sleepQProc

:=
:=
:=

sleepOFlags

:=

0;
slpQType;
@MySleepRtn;
0;

{sleep queue
type,
16}
{address
of some
sleep
{reserved

routine}

field}

END;

SleepQInstall

(@MyRec)

;

{install}

END

To remove your routine from the sleep queue, use the SleepQRemove procedure. This
procedure also takes as its one parameter a pointer to your sleep queue record.
Using the Power Manager

31-15

}Y

Inside Macintosh,

Volume

VI

Responding

When

the Sleep Queue

Calls Your

Routine

When you add an entry to the sleep queue, the Power Manager calls your routine when the
Power Manager issues a sleep request, a sleep demand, a wakeup demand, or a sleep-request
revocation. Whenever the Power Manager calls your routine, the AO register contains a
pointer to your sleep queue record and the DO register has a code indicating the reason your
routine is being called, as follows:
Value
in DO
l
2
3
+

Meaning
Sleep request
Sleep demand
Wakeup demand
Sleep-request revocation

When your routine receives a sleep request, it must either allow or deny the request and place
its response in the DO register. To allow the sleep request, clear the DO register to 0 before
returning control to the Power Manager. To deny the sleep request, return a nonzero value in
the DO register. (Note that you cannot deny a sleep demand.)
If your routine or any other routine in the sleep queue denies the sleep request, the Power
Manager sends a sleep-request revocation to each routine that it has already called with a sleep
request. If none of the routines denies sleep, then the Power Manager sends a sleep demand
to each routine in the sleep queue. Because your routine will be called a second time in any
case, it is not necessary to prepare for sleep in response to a sleep request; your routine need
only allow or deny the sleep request and return the result in the DO register.
When your routine receives a sleep demand, it must prepare for the sleep state and return
control to the Power Manager as quickly as possible. Because sleep demands are never sent
by an interrupt handler, your routine can perform whatever tasks are necessary to prepare for
sleep, including making calls to the Memory Manager. You can, for example, display an alert
box to inform the user of potential problems, or you can even display a dialog box that
requires the user to specify the action to be performed. However, if several applications
display alert or dialog boxes, the user might become confused or alarmed. More important, if
the user is not present to answer the alert box or dialog box, control is never returned to the
Power Manager, and the Macintosh Portable does not go to sleep.
A

Warning: If your sleep routine displays an alert box or modal dialog box,
the Macintosh Portable does not enter the sleep state until the user responds.
If the Macintosh Portable remains in the operating state until the battery voltage
drops below a preset value, the Power Manager IC automatically shuts off all
power to the system, without preserving the state of open applications or data
that has not been saved to disk. To prevent this from happening, you should
automatically remove your dialog box after several minutes have elapsed. a

When your routine receives a wakeup demand, it must prepare for the operating state and
return control to the Power Manager as quickly as possible.
When your routine receives a sleep-request revocation, it must reverse any changes it made in
response to the sleep request that preceded it, and return control to the Power Manager.
31-16

Using the Power Manager

The Power Manager

Listing 31-2 checks the contents of the DO register to determine whether your sleep queue
routine is being called with a sleep request, a sleep demand, or a wakeup demand. If the DO
register contains a value of |, indicating a sleep request, the routine clears the register to 0 to
allow sleep. If the DO register contains a 2, 3, or 4, the routine executes its sleep, wakeup, or
request-cancelation procedures and terminates. If the DO register contains any other value, the
procedure just returns to the caller. Because Listing 31-2 reads from and writes to the DO
register, the main routine is written in assembly language rather than Pascal.
Listing 31-2.

A sleep queue routine

MySlpQProc

PROC

StackFrame

RECORD

{A6Link},DECR

;build

a

ParamBegin

EQU
EQU

*

;start

parameters

;size

ParamSize
RetAddr

DS.L

ParamBegin-*
1

A6Link

DS.L

1

LocalSize

EQU

*

stack

of

frame

Ge

record

after

aoe

this

point

all

the

passed

;placeholder
;placeholder

for
for

return address
A6 link

;size

the

local

of

all

parameters

=
as

variables

—
—

~

as

ae

LINK
CMPI.L
BNE
JSR

StackFrame
A6,#LocalSize

;cover

;allocate

our

local

#1, D0
@i

;is

sleep

request?

RequestSleep

;function

it

a

local

stack

sleep

to

get

answer

puts

answer

in

#2,D0
@2

;is

a

demand?

JSR
BRA

SleepDemand

;routine

CMPI.L

#3,D0
@3

;is

BNE
JSR

WakeupDemand

;routine

BRA

Exit

BRA

Exit

CMPI.L
BNE

to

it

sleep

answer

on

stack

DO

;no
to

prepare

for

sleep

Exit

Ct

CMPI.
BNE

frame

request

;place

(SP)+,D0

frame

stack

;SleepRequest
MOVE.1

JSR

Exit

our

;no
;

@3

=
a

=
o

JQ
<)
mm"

WITH

@2

~ ww

inet
;

ENDR

@1

net

#4,D0
Exit
RevokeRequest

it

a

wakeup

demand?

;no

jis
sno,

to

prepare

for

it a sleep-request
revocation?
it's undefined,
just
exit

;routine
to reverse
changes
; made
for sleep
request

A6

;undo

the

link

;pull

off

the

return

ADDA.L

(SP)+,A0
#ParamSize,SP

;strip

all

of

the

JMP

(AO)

;return

to

UNLK
MOVEA.L

wakeup

address

caller's

parameters

caller

ENDP
(Continued)

Using the Power Manager

= 31-17

Inside Macintosh,

Volume VI

Listing 31-2. A sleep queue routine (Continued)
FUNCTION

RequestSleep

:

LonglInt;

BEGIN

{return

a

1

to

deny

sleep

or

return

a

0

to

permit

sleep}

END;
PROCEDURE

SleepDemand;

BEGIN

{prepare

for

sleep}

END;
PROCEDURE

WakeupDemand;

BEGIN
{prepare

to

return

to

operating

state}

END;

PROCEDURE

RevokeRequest;

BEGIN
{reverse

any

changes

made

in

response

to

sleep

request}

END;

Switching

Serial Power On and Off

The serial I/O subsystem of the Macintosh Portable computer includes the following
components:
m the Serial Communications Controller (SCC) chip
m the serial driver chips
m the —5 volt supply
mw the internal modem (if installed)

Because serial drivers always use these components in certain combinations, the Power
Manager provides five serial power procedures that perform the following tasks:
mw The AOn procedure switches on power to serial port A and switches on power to the
internal modem if

it is installed.

a The AOnIgnoreModem procedure switches on power to serial port A (the modem port)
but does not switch on power to the internal modem.
= The BOn procedure switches on power to serial port B.
ma The AOff procedure switches off power to serial port A and to the internal modem if it is
in use.

= The BOff procedure switches off power to serial port B.
31-18

Using the Power Manager

The Power Manager

Assembly-language note:

Although MPW

provides assembly-language

macros to execute these routines, each of these macros calls the _SerialPower

trap macro. To call the _SerialPower trap macro directly, you must first put a
routine selector in the DO register, setting the bits as follows:
Bit
0
2
7

Use
Set to 0 to use internal modem; set to | to ignore modem.
Set to 0 for port B; set to | for port A.
Set to 0 to switch on power; set to | to switch off power.

If no internal modem is installed, then calling any of the power-on routines switches on
power to the SCC, the serial driver chips, and the —5 volt supply.

Ge
—

To switch power on for port B whether or not there is an internal modem installed, use the
BOn procedure. This procedure switches on power to the SCC, the serial driver chips, and
the —5 volt supply.
If the internal modem is installed, then you can use the AOn procedure to switch on the
modem. In this case, this procedure switches on power to the SCC, the —5 volt supply,

and the modem; the internal modem does not use the serial driver chips.

If the internal modem is installed but you do not want to use it (whether or not the user has

used the Portable control panel to disconnect the modem), then use the AOnIgnoreModem
procedure to switch on power to the SCC, the serial driver chips, and the —5 volt supply.

POWER

MANAGER

ROUTINES

This section describes the routines you can use to enable, disable, and read the idle state,
control and read the wakeup timer, add and remove elements from the sleep queue, control
power to the serial ports, read the status of the internal modem, and read the status of the
battery and battery charger.
All Power Manager routines return the same result codes, listed in “Result Codes” in the
summary at the end of this chapter.

Controlling the Idle State
You can use the IdleUpdate function to reset the activity timer, you can use the Enableldle
and Disableldle procedures to enable and disable the idle state, and you can use the
GetCPUSpeed function to read the current CPU clock speed.
FUNCTION

IdleUpdate

:

LongInt;

The IdleUpdate function takes no parameters. It returns the value in the Ticks global variable
at the time the function was called.

Power Manager Routines

= 31-19

=

=

a
©
a)

2

—

sy
~
>
7
iS)
=

Inside Macintosh,

PROCEDURE

Volume VI

Enableldle;

The Enableldle procedure cancels the effect of a call to the Disableldle procedure. A call to the
Enableldle procedure enables the idle state only if the user has not used the Portable control
panel to disable the idle state and if every call to the DisablelIdle procedure has been balanced
by a call to the Enableldle procedure.
PROCEDURE

DisablelIdle;

The Disableldle procedure disables the idle state, even if the user has used the Portable
control panel to enable the idle state. Every call to the DisableIdle procedure must be balanced
by a call to the Enableldle procedure before the idle state is reenabled.
FUNCTION

GetCPUSpeed

Trap macro

On exit

:

LongInt;

_GetCPUSpeed

DO: the CPU clock speed; $1 or $10

The GetCPUSpeed function returns the current effective clock speed of the CPU. The only
values that are returned by this function are | and 16, indicating the clock speed in megahertz.

Controlling and

Reading

the Wakeup

Timer

The Power Manager provides one function to set the wakeup timer, one to disable the wakeup timer, and one to read the current setting of the wakeup timer.
FUNCTION

SetWUTime

(WUTime:

LongInt)

:

OSErr;

The SetWUTime function sets and enables the wakeup timer. When the Macintosh Portable
computer is in the sleep state, the Power Manager IC updates the real-time clock and
compares it to the wakeup timer once each second. When the real-time clock and the wakeup
timer have the same setting, the Power Manager IC returns the Macintosh Portable to the
operating state.
The WUTime parameter specifies the time at which the Power Manager IC will return the
Macintosh Portable to the operating state. You specify the time as the number of seconds
since midnight, January 1, 1904.
If the Macintosh Portable is not in the sleep state when the wakeup timer and the real-time
clock settings coincide, nothing happens. If you set the wakeup timer to a time earlier than the
current setting of the real-time clock, you effectively disable the wakeup timer.
FUNCTION

DisableWUTime

:

OSErr;

The DjsableWUTime function disables the wakeup timer. You must set a new wakeup time to
reenable the wakeup timer.
31-20

Power Manager Routines

The Power Manager

FUNCTION

GetWUTime

(VAR

WUTime:

LongInt;

VAR

WUFlag:

Byte)

:

OSErr;

The GetWUTime function returns the current setting of the wakeup timer and indicates
whether the wakeup timer is enabled.
The value returned by the WUTime parameter is the current setting of the wakeup timer
specified as the number of seconds since midnight, January 1, 1904. If the low-order bit (bit
0) of the WUFlag parameter is set to 1, the wakeup timer is enabled. The other bits in the
WUFlag parameter are reserved.

Controlling

the Sleep

Queue

oe
—

net

~w
“
<=
@

You can use the SleepQInstall procedure to add an entry to the sleep queue, and you can use
the SleepQRemove procedure to remove an entry from the sleep queue.
PROCEDURE

SleepQInstall

(qRecPtr:

a

—

.

met
as

SleepQRecPtr);

tee
—_—

—

as

—_

it

The qRecPtr parameter is a pointer to a sleep queue record that you must provide. The structure of a sleep queue record is shown in “Placing a Routine in the Sleep Queue” earlier in
this chapter.
PROCEDURE

SleepQRemove

(qRecPtr:

SleepQRecPtr);

The qRecPtr parameter is a pointer to the sleep queue record that you provided when you
added your routine to the sleep queue.

Controlling

Serial

Power

The five procedures in this section control power to the serial ports and internal modem.
PROCEDURE

AOn;

The AOn procedure always switches on power to the SCC and the —5 volt supply. If the internal modem is installed and is connected to port A, this procedure also switches on power
to the modem. If either of these conditions is not met, the AOn procedure switches on power
to the serial driver chips.
PROCEDURE

AOnIgnoreModem;

The AOnIgnoreModem procedure switches on power to the SCC, the —5 volt supply, and the
serial driver chips. This procedure does not switch on power to the internal modem, even if
the user has used the Portable control panel to select the modem.
PROCEDURE

BOn;

The BOn procedure always switches on power to the SCC, the —5 volt supply, and the serial
driver chips.
Power Manager Routines

— 31-21

@
ee |

Inside Macintosh,

PROCEDURE

Volume VI

AOff;

The AOff procedure always switches off power to the SCC and the —5 volt supply if serial
port B is not in use. If the internal modem is installed, connected to port A, and switched on,
this procedure switches off power to the modem. If any of these conditions are not met, it
switches off power to the serial driver chips, unless they are being used by port B.
PROCEDURE

BOff;

The BOff procedure switches off power to the SCC and the —5 volt supply if serial port A is
not in use. If the internal modem is installed, connected to port B, and switched on, this

procedure switches off power to the modem. Otherwise, the BOff procedure switches off
power to the serial driver chips, unless they are being used by port A.

Reading

the Status of the Internal Modem

The Power Manager application interface provides a function that allows you to determine the
status of the internal modem.
FUNCTION

ModemStatus

(VAR

Status:

Byte)

:

OSErr;

The ModemStatus function returns information about the internal modem in the Macintosh

Portable computer.

The bits in the Status parameter are defined as follows:
Meaning

d

Reserved.

6
5
4
3

Reserved.
The modem is on or off hook. If 1, the modem is off hook.
The ring-detect state. If 1, the modem has detected an incoming call.
The modem is or is not installed. If 1, an internal modem is installed.
The state of the ring-wakeup feature. If 1, the ring-wakeup feature is enabled.
Reserved; must always be set to 1.
The modem’s power is on or off. If 1, the modem is switched on.

om N

Bit

You can use the constants shown in the summary section of this chapter to check the values
of these bits.
The user can use the Portable control panel to enable or disable the ring-wakeup feature.
When the ring-wakeup feature is enabled and the Macintosh Portable is in the sleep state,
the Power Manager returns the computer to the operating state when the modem receives
an incoming call.
You can use the serial power control functions described in “Switching Serial Power On and
Off” earlier in this chapter to control power to the modem.
The modem indicates that it is off hook whenever it is busy sending or receiving data or
processing commands. The modem cannot receive an incoming call when it is off hook.
31-22.

Power Manager Routines

The Power Manager

Reading

the Status of the Battery and of the Battery Charger

The Power Manager monitors the voltage level of the internal battery and warns the user
when the voltage drops below a threshold value stored in parameter RAM. If the voltage
continues to drop and falls below another, lower value stored in parameter RAM, the Power
Manager puts the computer into the sleep state. The Power Manager provides a function that
allows you to read the state of charge of the battery and the status of the battery charger.
FUNCTION

BatteryStatus

(VAR

Status:

Byte;

VAR

Power:

Byte)

:

OSErr;

The BatteryStatus function returns the status of the battery charger and the voltage level of the
battery. The bits in the Status parameter are defined as follows:

orN
WwW

Bit
7
6
5

Meaning
Reserved.
Reserved.
The charger connection has or has not changed state. If 1, the charger has
been recently connected or disconnected.
The battery warning. If 1, the battery voltage is low.
The dead battery indicator. This bit is always 0.
The hicharge counter overflow. If 1, the hicharge counter has overflowed.
The charge rate. If 1, the battery is charging at the hicharge rate.
The charger is or is not connected. If 1, the charger is connected.

You can use the constants shown in the summary section of this chapter to check the values
of these bits.
Use the following formula to calculate the battery voltage, where Power is the value of the
Power parameter returned by this function:
voltage = ((Power/100) + 5.12) volts

Due to the nature of lead-acid batteries, the battery power remaining is difficult to measure
accurately. Temperature, load, and other factors can alter the measured voltage by 30 percent
or more. The Power Manager takes as many of these factors into account as possible, but the
voltage measurement can still be in error by up to 10 percent. The measurement is most
accurate when the Macintosh Portable has been in the sleep state for at least 30 minutes.
When the battery charger is connected to a Macintosh Portable computer with a low battery,
the battery is charged at the hicharge rate (1.5 amps) until battery voltage reaches 7.2 volts.

The Power Manager has a counter (the hicharge counter) that measures the time required
to raise the battery voltage to this level.
After the 7.2 volt level is reached, the power management circuits maintain the hicharge
connection until the hicharge counter counts down to (). This ensures that the battery is fully
charged. At the end of that time, the power management circuits supply the battery with just
enough current to replace the voltage lost through self-discharge. When the hicharge counter
has overflowed, it indicates that the charging circuit is having trouble charging the battery.
Bit 5 is set when the charger connection is changed—either connected or disconnected. When
this bit is set, the Power Manager IC sends an interrupt to the CPU.
Power Manager Routines

— 31-23

ar
c
s
r<
=
z
&

Inside Macintosh,

Volume VI

The battery warning bit (bit 4) is set whenever battery voltage drops below the value set in
parameter RAM. The Power Manager IC sends an interrupt to the CPU once every second
when battery voltage is low.
If bit 3 were set, it would indicate a dead battery; however, the Power Manager automatically
shuts the system down when the battery voltage drops below a preset level, so this bit is
always 0.

31-24

Power Manager Routines

The Power Manager

SUMMARY

OF

THE

POWER

MANAGER

Constants
slpQType
{Bit

positions

for

sca

hala

modemOnBit

0;

ringWakeUpBit

2
3}
4;

modemInstalledBit
ringDetectBit
modemOnHookBit
{masks

{sleep

16;

for

{1
{1

{1

oh

5 +
‘

{1

Es
if
if
A
if

queue

type}

modem

is

ring

wakeup

on}
is

internal

modem

incoming

call

is

modem

off

hook}

is

is

ringWakeUpMask
modemInstalledMask

ringDetectMask
modemOnHookMask
{bit positions
chargerConnBit

detected}

for

on}

{ring

wakeup

{internal

ee)
ve

modem

installed}

{incoming
call detected}
{modem off hook}

BatteryByte}
{1

if

charger

is

{1

if

charging

at

connected}

{1

if

hicharge

counter

4 i

{l

if

battery

is

connChangedBit

5 Ul

{1

if

charger

connection

a
$2}
$4;
$83

chargeOverFlowMask
batteryDeadMask

S10

batteryLowMask

sleepRevoke

{always

hicharge

rate}

has

overflowed}

0}
low}
has

changed}

BatteryByte}

chargerConnMask
hiChargeMask

{commands
to
sleepRequest
sleepDemand

|

is?)
ee |

enabled}

batteryLowBit

sleepWakeUp

a)

Ler

~

{modem

batteryDeadBit

connChangedMask

ww

=

—

SF
$4;
28}
$10;
=$20;7

oF
i;
23
33

chargeOverFlowBit

_—

co)

to)

hiChargeBit

for

—

installed}

ModemByte}

modemOnMask

{masks

eo)

enabled}

m—<
beset

I

CONST

=$20)7

SLEEDOREC
=
=
=

=

{charger
is connected}
{charging
at hicharge
rate}
{hicharge

is

{battery

is

low}

{connection

has

sleepQProc }
3
{sleep
Zs
{sleep
BE

Ay

counter

{battery

{wakeup

{sleep

has

overflowed}

dead}
changed}

request}
demand}
demand}

request

revocation}

Summary of the Power Manager

= 31-25

Inside Macintosh, Volume VI

Data

Types

TYPE

SleepQRec

=

RECORD
sleepQLink:

SleepQRecPtr;

{pointer

to

sleepQType:

Integer;

{queue

sleepQProc:

ProcPtr;

{pointer

type

SsleepQFlags:

Integer

{reserved}

to

next

=

queue

element}

sleep

routine]

16}

your

END;

SleepORecPtr

=

“SleepQORec;

Routines

Controlling the Idle State
FUNCTION

IdleUpdate

:

PROCEDURE

EnablelIdle;

PROCEDURE

DisabdleIdle;

FUNCTION

GetCPUSpeed

Controlling

and

Longint;

:

Longint;

Reading

the Wakeup

FUNCTION

SetWUTime

(WUTime:

FUNCTION

DisableWUTime

:

FUNCTION

GetWUTime

(VAR

LongInt)

Timer
:

OSErr;

OSErr;
WUTime:

LongInt;

VAR

OSErr;

Controlling

the Sleep

Queue

PROCEDURE

SleepQInstall

(qRecPtr:

SleepQRecPtr) ;

PROCEDURE

SleepQRemove

(qRecPtr:

SleepQRecPtr) ;

Controlling

Serial

Power

PROCEDURE

AOn;

PROCEDURE

AOnIgnoreModem;

PROCEDURE

BOn;

PROCEDURE

AOff;

PROCEDURE

BOff;

31-26

Summary of the Power Manager

WUFlag:

Byte)

The Power Manager

Reading

the Status of the Internal

FUNCTION

ModemStatus

Reading

(VAR

Status:

Modem
Byte)

:

OSErr;

the Status of the Battery and of the Battery Charger

FUNCTION

BatteryStatus

Result

Codes

noErr
pmBusyErr
pmReplyTOErr
pmSendStartErr
pmSendEndErr
pmRecvStartErr
pmRecvEndErr

0)
—13000
—13001
—13002
—13003
—13004
—13005

Sleep

Data

Queue

(VAR

Status:

Byte;

VAR

Power:

:

OSErr;

No error
Power Manager IC stuck busy
Timed out waiting to begin reply handshake
Power Manager IC did not start handshake
During send, Power Manager did not finish handshake
During receive, Power Manager did not start handshake
During receive, Power Manager did not finish handshake

Structure

sleepQLink
sleepQType
sleepQProc
sleepQFlags

long
word
long
word

pointer to next element in the queue
queue type = 16
pointer to your sleep routine
reserved

Trap

Requiring

Routine

Macros

Byte)

Selectors

_IdleState

Selector

Routine

0
Any positive number
Any negative number

Enableldle
Disableldle
GetCPUSpeed

_SerialPower

Selector

Routine

$04

AOn

$84
$80

AOff
BOff

$05
$00

AOnIgnoreModem
BOn

Summary of the Power Manager

31-27

Inside Macintosh,

31-28

Volume VI

oO
NO
LOO
RK — OM
NNR
Ee)

ee

NOK

a
oa
ne

£— Lo WwW WWWwWwWwNNhd! -) t Yh
K TDOMOANNSA
ene ce) NAN
=>

THE

APPLETALK

MANAGER

About This Chapter
About the AppleTalk Manager
Changes to the AppleTalk Manager
AppleTalk Protocols
AppleTalk Device Drivers, AppleTalk Connection Files, and the LAP Manager
Using the AppleTalk Manager
Determining Whether AppleTalk Phase 2 Drivers Are Present
Deciding Which AppleTalk Protocol to Use
The .MPP Driver
Getting Information About the .MPP Driver
A New NBP Wildcard Character
The LAP Manager
The AppleTalk Transition Queue
Adding and Removing AppleTalk Transition Queue Entries
Sending Messages to the AppleTalk Transition Queue
How the AppleTalk Manager Calls Your AppleTalk Transition Queue Entry
Defining Your Own AppleTalk Transition
The LAP Manager 802.2 Protocol
Attaching and Detaching 802.2 Protocol Handlers
The .ATP Driver
Canceling All Calls to the ATPGetRequest Function
Setting the Timeout Value for the ATP Release Timer
The .XPP Driver
Using the .XPP Driver to Obtain Information About Zones
Obtaining Zone Information
AppleTalk Data Stream Protocol (ADSP)
Using ADSP
The ADSP Connection Control Block
The .DSP Parameter Block
Opening and Maintaining an ADSP Connection
Creating and Using a Connection Listener
Writing a User Routine for Connection Events
.DSP Driver Routines
Establishing and Terminating an ADSP Connection
Establishing and Terminating an ADSP Connection Listener
Maintaining an ADSP Connection
The .ENET Driver
Providing Your Own Ethernet Driver
Changing the Ethernet Hardware Address
Opening the .ENET Driver
Using a Write-Data Structure to Transmit Ethernet Data
Using the Default Ethernet Protocol Handler to Read Data
Using Your Own Ethernet Protocol Handler to Read Data
How the .ENET Driver Calls Your Protocol Handler
How Your Protocol Handler Calls the .ENET Driver
.ENET Driver Routines
Attaching and Detaching an Ethernet Protocol Handler
Writing and Reading Ethernet Packets
Adding and Removing Ethernet Multicast Addresses
Summary of the AppleTalk Manager

a)
NS)
>

<

—@

a]
2
Ss
=<

g9
=|
=
ge
iS

—

Leow |

32-]

Inside Macintosh,

32-2

Volume VI

The AppleTalk Manager

ABOUT

THIS

CHAPTER

AppleTalk® is a communications network system including personal computer workstations,
computers acting as file servers and print servers, printers, and a variety of types of communications hardware and software. The AppleTalk Manager provides an interface to this
communications network system for applications running on Macintosh® computers. This
chapter describes changes to the AppleTalk Manager introduced since the publication of
Inside Macintosh, Volume V, and included with system software version 7.0. This chapter
supplements the information in the AppleTalk Manager chapters of /nside Macintosh,
Volumes II and V.
This chapter describes
m new routines for the .MPP, .ATP, and .XPP device drivers
= anew wildcard character for use with the Name-Binding Protocol
ane
nN

m anew operating-system queue, called the AppleTalk Transition Queue

>

i)

m= anew set of operating-system utilities, collectively called the LAP Manager

=

a the application interface routines provided by a new AppleTalk protocol, the AppleTalk
Data Stream Protocol (ADSP)

m

e
rj

=

~~

2

=

is)
—}

the .ENET driver and the routines your application can use to control this driver

$9
iS)
3

it)

Together with the AppleTalk Manager chapters of Volumes II and V, this chapter
describes the routines that your application can use to send and receive information
within an AppleTalk network system. Because the AppleTalk network system includes
both hardware and software—and because the software includes not only the AppleTalk
Manager but also file servers, print servers, internet routers, drivers for circuit cards,

and so forth—the information in Inside Macintosh constitutes only a small part of the
body of literature documenting AppleTalk.
For a detailed description of AppleTalk protocols, see /nside AppleTalk, second edition.
For a complete description of the LAP Manager, EtherTalk®, and alternate AppleTalk
connections, see the Macintosh AppleTalk Connections Programmer’s Guide. To learn
how to install and operate an AppleTalk internet, see the AppleTalk Internet Router
Administrator’s Guide and the AppleTalk Phase 2 Introduction and Upgrade Guide.
For an introduction to the hardware and software of an entire AppleTalk network, see
Understanding Computer Networks and the AppleTalk Network System Overview. For
information on designing circuit cards and device drivers for Macintosh computers, see
Designing Cards and Drivers for the Macintosh Family, second edition.
The changes to AppleTalk other than ADSP and the LAP Manager are collectively referred
to as AppleTalk Phase 2. (When necessary for purposes of differentiation, the previous
version of AppleTalk is referred to in this chapter as AppleTalk Phase 1.) The Phase 2
versions of the AppleTalk drivers are included as part of system software version 7.0 and
can be installed on any Macintosh computer other than the Macintosh 128K, Macintosh
512K, Macintosh 512K enhanced, and Macintosh XL computers. If you want to provide
AppleTalk Phase 2 drivers with your product, you must obtain a license from Apple®
Software Licensing.
About This Chapter

32-3

Inside Macintosh,

Volume VI

ABOUT

APPLETALK

THE

MANAGER

The AppleTalk Manager includes a number of protocols that are implemented in various

device drivers. The AppleTalk Manager also includes the LAP Manager (which interfaces

the AppleTalk link access protocols to the higher-level AppleTalk protocols) and hardware
device drivers for specific data links. Software that supports AppleTalk data links is contained in files of type 'adev', referred to as AppleTalk connection files. This section lists
the new features of AppleTalk, describes the organization of the AppleTalk Manager, and
briefly discusses what each component of the AppleTalk Manager does.

Changes

to the AppleTalk

Manager

The AppleTalk features that are new or improved include
=

anew .MPP driver function that returns information about the .MPP driver (see

“Getting Information About the .MPP Driver” later in this chapter)

m= anew Name-Binding Protocol (NBP) wildcard character that can substitute for one or

more characters in AppleTalk names (see “A New NBP Wildcard Character’’)

m the LAP Manager, a set of operating-system utilities that provide a standard interface
between the AppleTalk protocols and the data links used by AppleTalk, such as
LocalTalk®, EtherTalk, and TokenTalk® (see “The LAP Manager’)

m the AppleTalk Transition Queue, an operating-system queue that can notify your application each time an AppleTalk driver is opened or closed or each time certain other
transitions occur (see “The AppleTalk Transition Queue”’)
= an implementation of parts of the IEEE 802.2 protocol, which allows you to attach and
detach your own protocol handlers for EtherTalk data packets (see “The LAP Manager
802.2 Protocol’’)

m= new .ATP driver functions that allow you to set a value for the .ATP release timer and
to cancel all pending asynchronous calls to the ATPGetRequest function for a specific
socket (see “The .ATP Driver’)

m

new .XPP driver functions that provide information from ZIP about zones (see “The
.XPP Driver’)

= improvements to the AppleTalk protocols that allow a single network, other than
LocalTalk, to contain more than one zone (see “Using the .XPP Driver to Obtain
Information About Zones’’)

m the AppleTalk Data Stream Protocol (ADSP), which provides full-duplex data stream
communications for use by applications (see “AppleTalk Data Stream Protocol (ADSPY’)
m the .ENET driver, an Ethernet driver for the EtherTalk NB card that is manufactured by
Apple Computer, Inc. (see “The .ENET Driver’)

32-4

About the AppleTalk Manager

The AppleTalk Manager

AppleTalk

Protocols

The AppleTalk Manager includes the following protocols:
»

LocalTalk Link Access Protocol (LLAP)

m

EtherTalk Link Access Protocol (ELAP)

mw TokenTalk Link Access Protocol (TLAP)

m Datagram Delivery Protocol (DDP)
=

Routing Table Maintenance Protocol (RTMP)

ms AppleTalk Transaction Protocol (ATP)
= Name-Binding Protocol (NBP)
-)

a AppleTalk Echo Protocol (AEP)

N
>
—

=)

ew Zone Information Protocol (ZIP)

—

as
om

==

= AppleTalk Session Protocol (ASP)

~~
a
—

mw AppleTalk Data Stream Protocol (ADSP)

re)
—

a

x

all

ti

mw AppleTalk Filing Protocol (AFP)

©
a |

The LocalTalk Link Access Protocol, EtherTalk Link Access Protocol, TokenTalk Link
Access Protocol, and other link access protocols provide interfaces between the AppleTalk
Manager and the different types of data link hardware used by AppleTalk.
Note: The LocalTalk Link Access Protocol (LLAP) was originally called the
AppleTalk Link Access Protocol (ALAP). With the addition of the EtherTalk
Link Access Protocol (ELAP) and other link access protocols, this protocol was
renamed to indicate the specific data link it supports.
Figure 32-1 shows the relationships among the various AppleTalk protocols. A connection
between one protocol and another above or below it in the figure indicates that the upper
protocol is a client of the lower protocol; that is, the upper protocol uses services provided
by the lower protocol in order to carry out some functions.
Note: The various AppleTalk protocols are sets of rules, not computer programs,
and so can be implemented in many different ways on many different systems. All
of the AppleTalk protocol functions that you can address or control from a Macintosh
application are implemented as Macintosh device drivers or managers. Many other
features of these protocols are implemented in software located only on internet
routers that are not used to run general applications. Some parts of protocols are
implemented by server software such as file servers and print servers. Therefore,
when this chapter refers to a protocol as “doing” or “controlling” something, you
should understand the statement to mean that some program that implements the
protocol actually carries out the operation.
About the AppleTalk Manager

32-5

Inside Macintosh,

Volume V1

AppleTalk Filing
Protocol

(AFP)

Zone Information
Protocol

(ZIP)

Routing Table
Maintenance Protocol

i

AppleTalk Session
Protocol

AppleTalk Data Stream
Protocol

(ADSP )

(ASP)

1LIt

AppleTalk Transaction
Protocol

a

Name-Binding
Protocol

LEED

AppleTalk
Echo Protocol

|___ (AEP)

Datagram Delivery Protocol

(DDP)

LocalTalk Link Access
Protocol
(LLAP)

EtherTalk Link Access
Protocol
(ELAP)

Figure 32-1.

AppleTalk

Other link access
protocols

protocols

As shown in Figure 32-1, a link access protocol controls the access of the node to the

network hardware and makes it possible for many nodes to share the same communications
hardware. Each link access protocol assigns a node ID to the node and decodes the node
addresses of messages it receives. A link access protocol provides node-to-node delivery of
data packets. Examples of link access protocols include the LocalTalk Link Access Protocol,
the EtherTalk Link Access Protocol, and the TokenTalk Link Access Protocol.
Whereas earlier implementations of AppleTalk were restricted to one 16-bit network number
per network (that is, one network number for all nodes connected with no intervening routers)
and 254 nodes per network number, AppleTalk Phase 2 allows more than one network
number for each network (other than LocalTalk, which is still limited to one network number

per network). A network of a type that allows more than one network number is known as

an extended network. Each node in an extended network must now be specified by both
its 16-bit network number and its 8-bit node ID. In principle, each network (other than
LocalTalk) can now have over 16 million (224) nodes. In any specific implementation, the
hardware or software might limit the network to fewer nodes.

The Datagram Delivery Protocol (DDP) provides socket-to-socket delivery of data
packets within an AppleTalk internet. The address of a DDP packet includes the socket
number, node ID, and network number. Application interface routines for DDP are described
in “Datagram Delivery Protocol” in the AppleTalk Manager chapter of Volume II.
The Routing Table Maintenance Protocol (RTMP) is used by routers on an AppleTalk
internet to determine how to forward a data packet to the network number to which it is
addressed. The RTMP implementation on a router maintains a table, called a routing table,
that specifies the shortest path to each possible destination network number. The AppleTalk

32-6

About the AppleTalk Manager

The AppleTalk Manager

protocol software in a workstation (that is, a node other than a router) contains only a small
part of RTMP, called the RTMP stub, that DDP uses to determine the network number (or
range of network numbers) of the network cable to which the node is connected and to
determine the network number and node ID of one router on that network cable. There is no
application interface to the RTMP stub.
The AppleTalk Transaction Protocol (ATP) provides reliable delivery of data by
retransmitting any data packets that are lost. ATP also ensures that data packets are delivered in
the correct sequence. ATP is a transaction-based protocol, meaning that one socket client
transmits a request for some action and the other socket client carries out the action and
transmits a response. Although—as you can see from Figure 32-1—the AppleTalk Manager
provides high-level protocols that are clients of ATP, many applications use ATP directly to
transmit data over an AppleTalk internet. The application interface to ATP is described in the
AppleTalk Manager chapter of Volume II. There are some enhancements to ATP in AppleTalk
Phase 2, described in “The .ATP Driver” later in this chapter.
The Name-Binding

Protocol (NBP) maintains a table that contains the internet address

and name of each entity in the node that is visible to other entities on the internet (that is, each
entity that has registered a name with NBP). The internet address includes the socket
number, node ID, and network number. The name consists of three fields: the object, type,

and zone. The object and type are assigned by the entity itself and can be anything the user
or application assigns. A zone is a logical grouping of a subset of the nodes on the internet.
The zone field of the name is the zone in which the node resides.
NBP also allows its clients to obtain the internet address of any network-visible entity in the
internet by providing its name. NBP maps this name to an internet address, thus providing
the link between the user-supplied name for an entity and the internet address that is used by
DDP to send and receive data packets. The application interface to NBP is described in the
AppleTalk Manager chapter of Volume II. There is one enhancement to NBP in AppleTalk
Phase 2, described in “A New NBP Wildcard Character” later in this chapter.
The AppleTalk Echo Protocol (AEP) listens for special packets sent by other nodes and,
when it receives such a packet, echoes it back to the sender. AEP is used by some clients of
DDP to determine whether another node (known to have AEP) can be accessed over the inter-

net, and to determine how long it takes a packet to reach another node. There is no application
interface to AEP.

The Zone Information Protocol (ZIP) maintains a table in each router, called the zone

information table, that lists the relationships between zone names and networks. In AppleTalk
Phase 2, a single network number can be associated with more than one zone name, or a
single zone name can be associated with more than one network. You can use .XPP driver
routines to obtain information from ZIP. These routines are discussed in “Using the .XPP
Driver to Obtain Information About Zones” later in this chapter.

The AppleTalk Session Protocol (ASP) sets up and maintains sessions between a workstation and a server. A session consists of a logical (as opposed to physical) connection
between two entities on the internet. ASP is a nonsymmetrical protocol; that is, only one of the
two entities involved in the session (the workstation) can send commands. The other entity
(the server) is restricted to responding to the commands. ASP is used by the AppleTalk Filing
Protocol, for example, to allow a user to manipulate files on a file server. As long as the
session is open, the workstation can request directory information, change filenames, and so
forth. The file server must respond to the workstation’s commands and cannot initiate any
actions on its own. ASP is discussed in the AppleTalk Manager chapter of Volume V.
About the AppleTalk Manager

32-7

oe)
Nm
>

a

—_

<)
@

a
~
~

<2
—
=
=
=

ve

@
er

Inside Macintosh,

Volume V1

The AppleTalk Data Stream Protocol (ADSP) appears to its clients to maintain an
open pipeline between two entities on the internet. Either entity can write a stream of bytes to
the pipeline or read data bytes from the pipeline. ADSP is a symmetrical protocol; that is,
the two clients at either end of the connection are equal and can perform exactly the same
operations. ADSP is especially useful for exchanging information between two equal entities,
as in a telephone communications network, or as required by a terminal emulation program

for sending or receiving a continuous stream of data. Because ADSP, like all other high-level

AppleTalk protocols, is a client of DDP, the data is actually sent as data packets. This allows
ADSP to correct transmission errors in a way that would not be possible for a true data
stream connection. Thus, ADSP retains many of the advantages of a transaction-based
protocol while providing to its clients a full-duplex data stream. ADSP is discussed in the
sections “Using ADSP” and “.DSP Driver Routines” later in this chapter.
The AppleTalk Filing Protocol (AFP) provides an interface between an application
and a file server. AFP is a client of ASP and is used to access AppleShare® file servers on
Macintosh computer workstations. When the user opens a session with an AppleShare file
server Over an internet, it appears to any application running on the workstation that uses
File Manager routines as if the files on the file server were located on a disk drive connected
to the workstation. The application interface to AFP is described in the AppleTalk Manager
chapter of Volume V.

AppleTalk Device Drivers,
and the LAP Manager

AppleTalk

Connection

Files,

A protocol is only a set of rules, not a computer program. The various AppleTalk protocols
are implemented as Macintosh device drivers, including
m the .MPP driver, which implements LLAP, DDP, the RTMP stub, NBP, and AEP
m the .ATP driver, which implements ATP
m the .XPP driver, which implements ASP and the workstation portions of ZIP and AFP
the .DSP driver, which implements ADSP
m

the .ENET driver, which implements an interface to the Ethernet data link

A Macintosh computer on an AppleTalk network can also include one or more AppleTalk
connection files. An AppleTalk connection file has file type 'adev' and contains a
link access protocol implementation for a data link (ELAP for EtherTalk, for example).
The LAP Manager makes it possible for the user to select among AppleTalk connection
files by using the Network control panel to specify which network is to be used for the
node’s AppleTalk connection. The AppleTalk connection file and LAP Manager work
together with the Network control panel (Network 'cdev') file. When the user selects a

connection from the Network control panel, the LAP Manager routes AppleTalk communications through the selected link access protocol and hence through the selected hardware.

32-8

About the AppleTalk Manager

The AppleTalk Manager

The AppleTalk device drivers, LAP Manager, and AppleTalk connection files are shown in
Figure 32-2. As you can see from the figure, each device driver implements one or more
AppleTalk protocols.
Part of AppleTalk
Filing Protocol
(AFP)

LLLLLLA LLLL LLL
Part of Zone

Information Protocol
(ZIP)

4 LLLLLL AL (LLLL
Routing Table

AppleTalk Session

Protocol
(ADSP)

LLL,

.DSP driver

il

AppleTalk Transaction

Maintenance Protocol
(RTMP) stub

AppleTalk Data Stream

Protocol
(ASP)

Name-Binding

Protocol
(ATP)
.ATP driver

AppleTalk

Protocol
(NBP)

w
NS)

Echo Protocol
(AEP)

>

‘|
z
—_
£2
=
©,

Datagram Delivery Protocol
(DDP)

2me

£5
=|
SS
go
@
“

LAP Manager

oS

—)2)
eel

sel ‘iain

-

‘O@

EtherTalk Link Access

rotoco

Protocol

(LLAP)

(ELAP)

P

rotocols

Other ‘adev' file

Ethernet

Other

river

-ENET driver

Other driver

Figure 32-2.

AppleTalk

y
KZLZZZZZZZLLZZZZA XPP driver

PP

Other link access

ELAP ‘adev' file

Ke

ee

|

device drivers

About the AppleTalk Manager

32-9

Inside Macintosh, Volume VI]

Figure 32-3 shows the interfaces between a general application on a Macintosh computer
being used as an AppleTalk workstation and the AppleTalk protocols, the LAP Manager,
and the Ethernet hardware device driver. The lines connecting the application to the various
components of AppleTalk indicate which components have application interfaces. As
discussed in the preceding section, “AppleTalk Protocols,” each application interface is
described, at least in part, in this or another volume of /nside Macintosh.

Part of AppleTalk
Filing Protocol
(AFP)

Vv

Part of Zone

Information Protocol
(ZIP)

|

WAL

Protocol
(ADSP)

v

AppleTalk Transaction

Maintenance Protocol
(RTMP) stub

AppleTalk Data Stream

Protocol
(ASP)

a

Routing Table

v

AppleTalk Session

Name-Binding

Protocol
(ATP)

Protocol
(NBP)

AppleTalk

Echo Protocol
(AEP)

Datagram Delivery Protocol

—

(DDP)

LAP Manager

©

\

©

Link Access
rotocol
(LLAP)

EtherTalk Link Access
Protocol
(ELAP)

‘-

LocalTalk
acelin

32-10

Other

driver

;

Figure 32-3.

protocols

Ethernet

=

aS

Other liek seesss

)

AppleTalk

= About the AppleTalk Manager

Ethernet
hardware

driver

(

application interfaces

aL

sae

o

Other
hardware

The AppleTalk Manager

USING

THE

APPLETALK

MANAGER

This section describes how to determine whether AppleTalk Phase 2 drivers are present and
gives some advice on how to select the AppleTalk protocol that best serves your purposes.
This section also describes how to use the features added to AppleTalk with Phase 2 and
provides programming examples of the use of the .DSP driver and several other new
AppleTalk features.

Determining

Whether

AppleTalk

Phase

2 Drivers Are

Present

Once the .MPP driver has been loaded into memory, you can use the Gestalt function with
the gestaltAppleTalkVersion selector to check the version of AppleTalk. The Gestalt function
returns the version of the .MPP driver. If the version is equal to or greater than 53, then the
.MPP driver supports AppleTalk Phase 2, and you can assume the other Phase 2 drivers
are present.
Alternatively, you can call the SysEnvirons function as described in the Compatibility
Guidelines chapter of Volume V. If the atDrvrVersNum field of the SysEnvRec data
structure returned by this function is equal to or greater than 53, then the .MPP driver
supports AppleTalk Phase 2.

eo)
i)
—

a

—

5

ae)
—
RE
$
~~
a

The ExtendedBit flag returned by the PGetAppleTalkInfo function is TRUE if the node is
connected to an extended AppleTalk network. (The ExtendedBit flag is bit 15 of the configuration parameter returned by this function.) Note that the presence of the AppleTalk Phase 2
drivers does not of itself indicate that the node is connected to an extended network.

Deciding

Which

AppleTalk

Protocol

to Use

AppleTalk offers a variety of communications protocols at a variety of levels. Your choice of
protocol or protocols to use depends primarily on your needs and can be influenced by your
familiarity with network communications in general.
You can write your own protocol handlers and call the low-level AppleTalk device drivers
directly. However, if you are not a communications expert and have no desire to design
your own network protocols, you should probably use one of three AppleTalk protocols
for sending and receiving data over the AppleTalk internet: the AppleTalk Transaction
Protocol (ATP), the AppleTalk Session Protocol (ASP), or the AppleTalk Data Stream
Protocol (ADSP).

ATP is a lower-level protocol than ASP or ADSP. You cannot use ATP to establish a session
and keep it open; rather, you request data from another socket client or send a response (up
to eight packets of data) from your socket to another socket client that has requested data. You
should use ATP if you want only to send a small amount of data and do not need the overhead required to maintain an open connection. ATP is described in the AppleTalk Manager
chapters of Volume II and Volume V.

Using the AppleTalk Manager

— 32-11

—

+)
=
—

i)
Ai)
o
“

Inside Macintosh,

Volume

VI

ASP is designed to support a session between a server and one or more workstations. It is
an asymmetrical protocol: all exchanges are initiated by a workstation and responded to by a
server. The server cannot initiate an exchange of data except to send to a workstation an _
attention message that directs the workstation to request data from the server. An application
running on a workstation must make calls to ASP to communicate with any server that uses
ASP. If you want to develop a new type of asymmetrical, transaction-oriented server, you
should consider using ASP to implement it. ASP is described in the AppleTalk Manager
chapter of Volume V.
ADSP is a symmetrical protocol that you can use to establish and maintain a connection
between two equal entities (a peer-to-peer connection). Either end of an ADSP connection
can send data at any time. Although ADSP is a client of DDP and therefore sends and
receives data in packets (as do ATP and ASP), to an application using ADSP the data appears
to be sent and received as a continuous stream. In addition to the duplex data stream maintained by an ADSP session, ADSP allows either end of a connection to send an attention
message to the other end. You can use ADSP to establish two-way communication between
computers, such as an interoffice party line or a terminal emulation program. If you want to
develop an application that requires two-way communication, you should consider using
ADSP to implement it. ADSP is described in “Using ADSP” later in this chapter.

THE

.MPP

DRIVER

Within the AppleTalk Manager, the .MPP driver implements the LocalTalk Link Access
Protocol (LLAP), the Datagram Delivery Protocol (DDP), the Routing Table Maintenance
Protocol (RTMP) stub, the Name-Binding Protocol (NBP), and the AppleTalk Echo Protocol
(AEP). The AppleTalk Phase 2 version of the .MPP driver includes a new function that returns
information about the .MPP driver, functions that send messages to routines in the AppleTalk
Transition Queue, and a new wildcard character for NBP.

Getting

Information

About

the

.MPP

Driver

You can use the PGetAppleTalkInfo function to obtain information about the .MPP driver.
The PGetAppleTalkInfo function returns
m a pointer to the .MPP global variables
m a pointer to the .MPP driver’s device control entry (DCE) data structure
= configuration flags that indicate the status of certain conditions that are set at startup
m

a value (the selfSend flag) that indicates whether the node can send packets to itself

m the range of network numbers for the network to which the node is attached
m the 8-bit node ID and 16-bit network number of the node
w

the 8-bit node ID and 16-bit network number of the last router from which the node
has heard

m the maximum capacities of the .MPP driver, such as the maximum number of protocol
handlers and the maximum number of static sockets allowed by this driver
32-12

The .MPP Driver

The AppleTalk Manager

m a pointer to the registered names queue
m the address of the node on the underlying data link (for example, the Ethernet
hardware address)

m

the node’s zone name

The data link address (for example, the Ethernet hardware address) and the zone name are
returned only for extended networks—that is, network types that allow more than one
network number per network. You must allocate memory for and provide pointers to the data
buffers into which the PGetAppleTalkInfo function returns the data link address and zone
name. You use the laLength parameter to specify the length of the data link address you want
returned; the function returns the actual length of the data in the laLength parameter and
returns the data in the buffer you provide.
Note: Always use the PGetAppleTalkInfo function to obtain information about the
.MPP driver. You can no longer rely on the validity of the global variables described
in the AppleTalk Manager chapter of Volume II.
td
Nw

FUNCTION

PGetAppleTalkInfo

(thePBptr:

MPPPBPtr;

async:

Boolean)

:

OSErr;

>

<)

gel©

rj

mS

Parameter block

-

-

16

ioResult

word

result code

=

26

csCode

word

always PGetAppleTalkInfo

>

28

version

word

version of function

<

30

varsPtr

long

pointer to .MPP globals

<

34

dcePtr

long

pointer to DCE for .MPP

<—

38

portID

word

port number

-

40

configuration

long

configuration flags

<

tt

selfSend

word

nonzero if self-send is enabled

an

46

netLo

word

low value of the network range

<

48

netHi

word

<
e

50
54

ourAddr

long

high value of the network range
local 24-bit AppleTalk address

routerAddr

long

<<-

58
60

numOfPHs
numOfSkts

word

<—

62

numNBPEs

word

<

64

ntQueue

long

o

68

laLength

word

>

70

link Addr

long

>

74

zoneName

long

word

=£9
x

joe

ge

©
=

24-bit address of router
max number of protocol handlers
max number of static sockets
max concurrent NBP requests
pointer to registered names table
length in bytes of data link address
(extended networks only)
pointer to data link address buffer
(extended networks only)
pointer to zone name buffer

The .MPP Driver

al

= 32-13

Inside Macintosh,

Volume

VI

The PGetAppleTalkInfo function returns information about the .MPP driver. If the node on
which your program is running happens also to be running AppleTalk Internet Router software in the background, more than one set of .MPP global variables may be in RAM. To
make sure you are obtaining information about the .MPP driver that handles application software, always use the PGetAppleTalkInfo function rather than the Device Manager’s
PBControl function. If you are using assembly language or want to use the PBControl
function, you must use a device driver reference number of —10 for the .MPP driver.
Field

descriptions

ioResult

The result of the function. When you execute the function asynchronously, the function sets this parameter to 1 and returns a function
result of noErr as soon as the function begins execution. When the
function completes execution, it sets the ioResult parameter to the
actual result code.

csCode

Routine selector, automatically set by the MPW® interface. Always
equal to PGetAppleTalkInfo for this function.

version

The version number of the PGetAppleTalkInfo function you are
calling. For version number 53 of the .MPP driver, this number is
always |.

varsPtr

A pointer to the .MPP global variables. This parameter is reserved for
the use of Apple Computer, Inc.; you cannot rely on the validity of the
variables pointed to by this parameter.

dcePtr

A pointer to the device control entry (DCE) data structure for the .MPP
driver. The DCE is described in the Device Manager chapters of
Volumes II and V.

portID

The port number for the .MPP driver. The port number is always 0
unless you are requesting information for an .MPP driver being used
by a router.

configuration

A 32-bit long word of configuration flags. The following flags are
currently defined:

32-14.

Bit

Flag

Description

31

SrvAdrBit

TRUE (1) if the routine that opened the

30

RouterBit

~The .MPP Driver

-MPP driver requested a server node
number. Server node numbers are
described in the AppleTalk Manager
chapter of Volume V. This flag
indicates only that the server node
number was requested, not that it was
returned. Some AppleTalk data links,
such as EtherTalk, do not honor a
request for a server node number.
TRUE (1) if an AppleTalk Internet
Router was loaded at system startup
(that is, there’s a router operating on
the same node as your application). A
router can be loaded and not active.

The AppleTalk Manager

Bit

Flag

Description

15

ExtendedBit

TRUE (1) if the node is on an extended

7

BadZoneHintBit

TRUE (1) if the zone name of the node
you are on was not the same as the zone
name stored in parameter RAM (some-

network. Testing this bit is the only
way to determine whether you are on an
extended network.

times referred to as the zone name hint)

when the .MPP driver was opened. If
the zone name hint is invalid, then the
AppleTalk Manager uses the default
zone for the network. The default zone
is defined by the network administrator.
6

selfSend

OneZoneBit

TRUE (1) if only one zone is assigned
to your extended network or if you are
not on an extended network. Use the
ExtendedBit flag to determine whether
you are on an extended network.

The ability of a node to send packets to itself. This feature is enabled
when this parameter is nonzero. Use the PSetSelfSend function,
described in the AppleTalk Manager chapter of Volume V, to enable or
disable this feature.

netLo

The low value of the range of network numbers on the local cable.
Only extended networks can have a range of network numbers. For a
nonextended network, this parameter returns the network number.

netHi

The high value of the range of network numbers on the local cable.
Only extended networks can have a range of network numbers. For a
nonextended network, this parameter returns the network number.

ourAddr

The 24-bit AppleTalk network address of the node you are on. The
least significant byte of the long word is the node ID. The middle
16 bits are the network number. The most significant byte of the
long word is reserved for use by Apple Computer, Inc.

routerAddr

The 24-bit AppleTalk network address of the last router from which
your node heard traffic. The least significant byte of the long word
is the node ID. The middle 16 bits are the network number. The
most significant byte of the long word is reserved for use by Apple
Computer, Inc. You should always use this address when you want
to communicate with a router.

numOfPHs

The maximum number of protocol handlers that this .MPP driver allows.

numOfSkts

The maximum number of statically assigned sockets that this .MPP
driver allows. Statically assigned sockets are described in /nside
AppleTalk, second edition.

numNBPEs

The maximum number of concurrent requests to NBP that this .MPP
driver allows.

The .MPP Driver

32-15

eo)
>)

>

"S

zCs)
=

=

~
2
—
bs)

=

=
ge
@

Lea |

Inside Macintosh,

Volume VI

ntQueue

A pointer to the first entry in the names table for the local node. You
can use NBP routines to look up and register names in the names
table. The names table is described in “Name-Binding Protocol” in
the AppleTalk Manager chapter of Volume II.

laLength

The number of bytes of the data link address that the function should
place in the buffer pointed to by the LinkAddr parameter. You use this
parameter when you call the PGetAppleTalkInfo function on a node on
an extended network. If you request more bytes than the total number of
bytes in the address, then the function returns in the laLength parameter
the actual number of bytes it placed in the buffer. If the address is longer
than the size of the buffer, then the PGetAppleTalkInfo function fills
the buffer and returns in the laLength parameter the actual length of the
address, not the number of bytes returned. The function does not return
an error when the buffer is too large or too small for the address. A
value of 6 bytes for laLength is sufficient for most purposes.

linkAddr

A pointer to a buffer for the data link address returned for extended
networks only. You use the laLength parameter to specify the number
of bytes of the address that you want placed in this buffer. You must
allocate a buffer large enough to hold the number of bytes you specify.
Specify NIL for this parameter if you do not want the function to
provide a data link address.

zoneName

A pointer to a buffer into which the PGetAppleTalkInfo function
places the local node’s zone name. You must allocate a buffer of
at least 33 bytes to hold this data, or you must specify NIL for the
zoneName parameter if you do not want to obtain the zone name.
This field is returned only if the node is on an extended network.

Result codes
noErr

8)

No error

Wildcard

Character

paramErr

A

New

NBP

—50

Version number is too high

The Name-Binding Protocol (NBP) allows the use of certain wildcard characters in

AppleTalk names when you call the PLookupName function. NBP now supports the
following wildcard characters:
NBP

=

wildcard

characters

All possible values. The equal sign (=) can be used alone instead of a name in the

object or type field.

This zone. The asterisk (*) can be used in place of the name of the zone to which this

node belongs.

=

32-16

Any or no characters in this position. The double tilde (~) can be used to obtain
matches for object or type fields. For example, pa~l matches pal, paul, paper ball,
and so forth. You can use only one double tilde in any string. Press Option-x to type
the double tilde character on a Macintosh keyboard. If you use the double tilde alone,
it has the same meaning as the equal sign (=). Note that any node not running
AppleTalk Phase 2 drivers will not recognize this character.
The .MPP Driver

The AppleTalk Manager

THE

LAP

MANAGER

The LAP Manager is a set of operating-system utilities that provide a standard interface
between the AppleTalk protocols and the various link access protocols, such as LocalTalk

(LLAP), EtherTalk (ELAP), and TokenTalk (TLAP). Because the LAP Manager is running

even when the .MPP driver is not open, the LAP Manager also maintains the AppleTalk
Transition Queue. In addition, the LAP Manager contains protocol handlers for certain types
of 802.2 packets.
This section describes the AppleTalk Transition Queue and the LAP Manager 802.2 protocol
handler, tells you how to add or remove an AppleTalk Transition Queue entry, and describes
how to attach or detach your own 802.2 protocol handler. In addition to the LAP Manager
features described here, you can use the LAP Manager to interface new data links to AppleTalk.
For more information about the LAP Manager, see the Macintosh AppleTalk Connections
Programmer’s Guide.

The

AppleTalk

Transition

7)NS

Queue

ea

S

At any given time there might be two or more applications running that use AppleTalk. If
one of these applications opens the AppleTalk drivers, the other AppleTalk applications are
affected. If the Operating System closes the AppleTalk drivers, all AppleTalk applications
are affected. To ensure that your application is not adversely affected by such an event, your
application can place an entry in the AppleTalk Transition Queue. The LAP Manager
sends a message to each entry in the AppleTalk Transition Queue each time the Operating
System or any routine
m opens the .MPP driver
a closes the .MPP driver
m

indicates that it intends to close the .MPP driver

m cancels its intention to close the .MPP driver

= defines its own AppleTalk event and calls the AppleTalk Transition Queue to inform it
that such an event occurred
Each of these events is referred to as an AppleTalk transition.

Because the .MPP driver is not necessarily open when the AppleTalk Transition Queue must
be called, the LAP Manager maintains the queue. Each entry in the AppleTalk Transition
Queue is defined by the ATQentry data type.
TYPE

ATQEntry

=

RECORD

qLink:

ATQOEntryPtr;

{next

qType:

Integer;

CallAddr:

ProcPtr

{reserved}
to
{pointer

queue

entry}
your

routine}

END;

The LAP Manager

= 32-17

nob@

ae

oe
x

S

==
ge@

=“

Inside Macintosh,

Volume VI

When you want to add an entry to the AppleTalk Transition Queue, you must create an
ATQentry data structure and give the LAP Manager a pointer to it. The qLink field is a
pointer to the next queue entry. You should set this field to NIL; the LAP Manager fills
it in when an application adds another entry to the queue. The qType field is reserved to
maintain consistency with other operating-system queues. The CallAddr field is a pointer
to a routine that you provide, as described in “How the AppleTalk Manager Calls Your
AppleTalk Transition Queue Entry” later in this chapter.
Because you provide the memory for the AppleTalk Transition Queue entry, you can add
as many fields to the end of the entry as you wish for your own purposes. Whenever your
routine is called, the caller provides you with a pointer to the queue entry so that you can
have access to the information you stored at the end of your queue entry.
There are four LAP Manager functions you can use that are related to the AppleTalk
Transition Queue:

a The LAPAddATQ function adds an entry to the AppleTalk Transition Queue. This
function is described in the following section, “Adding and Removing AppleTalk
Transition Queue Entries.”
a The LAPRmvATQ function removes an entry from the AppleTalk Transition Queue.
This function is described in the following section, “Adding and Removing AppleTalk
Transition Queue Entries.”
a The ATEvent procedure calls all the entries in the AppleTalk Transition Queue with an
AppleTalk transition event of your own definition. This function is described in the
section “Defining Your Own AppleTalk Transition” later in this chapter.

aw The ATPreFlightEvent function calls all the entries in the AppleTalk Transition Queue

with an AppleTalk transition event of your own definition and gives each entry the
opportunity to respond. This function is described in the section “Defining Your Own
AppleTalk Transition” later in this chapter.

Adding

and

Removing

AppleTalk Transition

Queue

Entries

You can use LAP Manager routines to add an entry to or remove an entry from the AppleTalk
Transition Queue.
FUNCTION

LAPAdGGATO

(theATQEntry:

On entry

ATQOEntryPtr)

:

OSErr;

DO: 23
AO: pointer to AppleTalk Transition Queue entry

On exit

DO: result code

The LAPAddATQ function adds an entry to the AppleTalk Transition Queue. The parameter
theATQEntry is a pointer to an ATQentry data structure. The CallAddr field of the data
structure holds a pointer to the routine that AppleTalk calls for any AppleTalk transition
event. The ATQentry data structure is described in the preceding section, “The AppleTalk
Transition Queue.”
Result code
noErr

32-18

0

|The LAP Manager

No error

The AppleTalk Manager

Assembly-language note: From assembly language, you add and remove
AppleTalk Transition Queue entries by placing a routine selector in the DO
register, placing a pointer to your AppleTalk Transition Queue entry in the AO
register, and executing a JSR instruction to an offset past the start of the LAP
Manager. The start of the LAP Manager is contained in the global variable
LAPMgrPtr ($B 18). The offset to the LAP Manager routines is given by the

constant LAPMerCall (2).

Here is assembly-language code that adds or removes AppleTalk Tranisition
Queue entries:
LAPMgrPtr

EQU

$B18

;entry

LAPMgrCall
ATQEntry

EQU
EQU

2
*

;offset
to LAP Manager
;pointer
to ATQ entry

MOVEQ

#RSel,D0

;place

MOVE. L

point

for

routine

in

DO

;

to

remove

one)

pointer

to

MOVE.L

ATQEntry,A0

;put

JSR

LAPMgrCall(An)

;jump

sput
;

to

ATO

entry

to

start

Manager
routines

selector

;
LAPMgrPtr,An

(23

LAP

add

an

entry,

24
be

LAP

in AO
of

Mgr

LAP

in

An

Mgr

2

va
=

routines

ae)

~
FUNCTION

LAPRmvATQ

(theATQEntry:

ATOEntryPtr)

:

OSErr;

5

se

On entry

DO: 24
AO: pointer to AppleTalk Transition Queue entry

On exit

DO: result code

The LAPRmvATQ function removes an entry from the AppleTalk Transition Queue. The
parameter theATQEntry is a pointer to an ATQentry data structure.
Note: You must not call the LAPRmvATQ function at interrupt time or through a
callback routine. This restriction is to prevent any routine from removing an entry
from the AppleTalk Transition Queue while another routine is in the process of
adding or removing an entry.
Result codes
noErr
qErr

0
—|

No error
Queue element not found

The LAP Manager

—_ 32-19

Inside Macintosh,

Sending

Volume

VI

Messages

to the AppleTalk

Transition

Queue

Whereas it is unlikely that opening the .MPP driver will adversely affect another program, an
application should never close the .MPP driver, because another program might be using it.
Under certain circumstances, however, the system might close the .MPP driver. The system
uses the .MPP driver’s PATalkClosePrep function to send a permission-to-close transition to
each routine in the AppleTalk Transition Queue. This transition indicates that the system
intends to close the .MPP driver so that each routine in the queue has the opportunity to deny
permission to do so.
When the system calls the PATalkClosePrep function, any routine in the AppleTalk Transition
Queue that wishes to deny permission to close the .MPP driver may return a pointer to a Pascal
string. The Pascal string should be the name of the application that placed the entry in the
queue. If any routine in the AppleTalk Transition Queue denies permission to close the .MPP
driver, the PATalkClosePrep function returns the result code closeErr.
If any routine denies permission to close the .MPP driver, the AppleTalk Manager sends a
cancel-close transition to every routine in the AppleTalk Transition Queue that previously
received the permission-to-close transition. The caller of the PATalkClosePrep function may
display a dialog box informing the user that another application is using the .MPP driver and
showing the name (if any) returned by the AppleTalk Transition Queue routine. The dialog
box gives the user the option of canceling the request to close AppleTalk or of closing
AppleTalk anyway.
If the user chooses to close AppleTalk despite the fact that an application is using it, the
system calls the MPPClose function. AppleTalk then calls each application in the AppleTalk
Transition Queue, this time informing each one that AppleTalk is about to close. In this case,
your AppleTalk Transition Queue routine must prepare for the imminent closing of
AppleTalk; it cannot deny permission to the MPPClose function.
FUNCTION

PATalkClosePrep

Parameter block
>
26
-

28

(thePBptr:

MPPPBPtr;

async:

Boolean)

:

OSErr;

csCode

word

always PATalkClosePrep

appName

long

pointer to name of application
that denies request

The PATalkClosePrep function calls each routine listed in the AppleTalk Transition Queue to
request permission to close the .MPP driver.
If a routine in the AppleTalk Transition Queue denies permission to close the .MPP driver, that
routine can return a pointer to a Pascal string. The Pascal string should contain the name of the
application that placed the entry in the AppleTalk Transition Queue. The PATalkClosePrep
function returns that pointer in the appName field. The function also returns the result code
closeErr, indicating that the calling routine has been denied permission to close the .MPP
driver. The routine that called PATalkClosePrep can then display a dialog box telling the user
the name of the application that is currently using AppleTalk and asking whether to close
AppleTalk anyway.

32-20

The LAP Manager

The AppleTalk Manager

The csCode parameter is a routine selector; it is always equal to PATalkClosePrep for
this function.
Result codes
noErr
closeErr

0
—24

No error
Permission to close .MPP driver was denied

How the AppleTalk Manager
Transition Queue Entry

Calls Your AppleTalk

When you have used the LAPAddATQ function to add an entry to the AppleTalk Transition
Queue, the AppleTalk Manager calls your entry when any of the following events occurs:
w A routine opens the .MPP driver.
= A routine closes the .MPP driver.

Cabed
i)

= A routine calls the PATalkClosePrep function.

>

mw One of the routines in the AppleTalk Transition Queue denies permission for the routine
that called the PATalkClosePrep function to close AppleTalk.

SP = | Return address (4 bytes)

Routine selector
Pointer to AppleTalk Transition Queue entry (4 bytes)
Routine-dependent parameter (4 bytes)

Previous contents
The first item on the stack (after the return address) is a routine selector. There is one routine

selector for each type of transition. The open, prepare-to-close, permission-to-close, and
cancel-close transitions each have a single-digit routine selector; all other routine selectors for
AppleTalk transition events are 4-character codes. Codes starting with an uppercase letter
(A through Z) are reserved for use by developers. All other codes are reserved for use by
Apple Computer, Inc.

$00 00 00 00

$00 00 00 02
$00 00 00 03
$00 00 00 04
$41 xx xx xx -$5A xx xx xx
all others

Transition

.MPP driver opened

.MPP driver about to close
PATalkClosePrep function has been called
Closing of .MPP driver has been canceled
Reserved for use by developers
Reserved for use by Apple Computer
The LAP Manager

fo
=
ge
o
=
~~

When the AppleTalk Manager calls your AppleTalk Transition Queue routine, the stack looks
like this:

selector

o
=
9
CS

Kn
—

mw An application calls the ATEvent or ATPreFlightEvent routine to send its own
AppleTalk transition event to the entries in the AppleTalk Transition Queue.

Routine

<)
SS

— 32-21

Inside Macintosh,

Volume V1

=

ATTransCancelClose

a)

=

ATTransClose
ATTransClosePrep

I

ATTransOpen

m

CONST

WN ©

You can use the following constants for the standard AppleTalk transitions:
{open

transition}

{prepare-to-close

transition}

;

{permission-to-close

;

{cancel-close

transition}

transition}

The second item passed to your routine on the stack is a pointer to your routine’s entry in the
AppleTalk Transition Queue. You can use this pointer to get access to any fields at the end of
the queue entry that you allocated for your own use. The last item passed to your routine on
the stack is a parameter whose meaning depends on the type of transition.
The interface between the AppleTalk Transition Queue and your routine follows these conventions: your routine must preserve all registers except DO, D1, D2, AO, and A1; all parameters are passed on the stack as long words. Because your routine might be called at interrupt
time, your routine must not make any direct or indirect calls to the Memory Manager and
can’t depend on handles to unlocked blocks being valid. If you want to use any of your application’s global variables, you must save the contents of the A5 register before using the
variables, and you must restore the A5 register before your routine terminates. These restrictions do not apply to the open transition or the prepare-to-close transition.
Note: It is important that you return a 0 in the DO register whenever you receive
a transition event routine selector that you do not recognize or do not choose to
handle. Returning a nonzero value in the DO register might cause the system to

cancel an attempt to close AppleTalk, for example, or might be misinterpreted in
some other way.

Open

Transition

When an application calls the MPPOpen function, the AppleTalk Manager first attempts to
open the .MPP driver. If the .MPP driver is already open, the AppleTalk Manager does not
call the AppleTalk Transition Queue. If the AppleTalk Manager successfully opens the
-MPP driver, it then calls every routine listed in the AppleTalk Transition Queue with an
open transition.
The third item on the stack for an open transition is a pointer to the start of the Device
Manager extended parameter block used by the routine that opened the .MPP driver. This
pointer is provided for your information only; you must not change any of the fields in
this parameter block.
Your AppleTalk Transition Queue routine can perform any tasks you wish in response to the
notification that the .MPP driver has been opened, such as using the Name-Binding Protocol
(NBP) to register a name on the internet. Return 0 in the DO register to indicate that your
routine executed with no error.
Prepare-to-Close

Transition

When any routine calls the MPPClose function to close the .MPP driver, the AppleTalk
Manager calls every routine listed in the AppleTalk Transition Queue before the .MPP driver
closes. If the .MPP driver is already closed when a routine calls the MPPClose function, the
AppleTalk Manager does not call the routines in the AppleTalk Transition Queue.
32-22

The LAP Manager

The AppleTalk Manager

When the AppleTalk Manager calls your routine for a prepare-to-close transition, the third
item on the stack is a NIL pointer.
Your routine can perform any tasks you wish to prepare for the imminent closing of AppleTalk,
such as ending a session with a remote terminal and informing the user that the connection is
being closed. You must return control to the AppleTalk Manager as quickly as possible. Return
0 in the DO register to indicate that your routine executed with no error.
Note: When the AppleTalk Manager calls your routine with a prepare-to-close
transition (that is, a routine selector of ATTransClose), you cannot prevent the
.MPP driver from closing.
Permission-to-Close

Transition

When a routine calls the PATalkClosePrep function to inform the AppleTalk Manager that
it wants to close the .MPP driver, the AppleTalk Manager calls every routine listed in the
AppleTalk Transition Queue to request permission to close the .MPP driver.
When the AppleTalk Manager calls your routine to request permission to close the .MPP
driver, the third parameter on the stack is a pointer to a 4-byte buffer. If you intend to deny
the request to close AppleTalk, you should place in the buffer a pointer to a Pascal string
containing the name of your application. The PATalkClosePrep function returns this pointer.
The routine that called the PATalkClosePrep function can then display a dialog box telling
the user the name of the application that is currently using AppleTalk.
Your routine can return either a function result of 0 in the DO register, indicating that it accepts
the request to close, or a | in the DO register, indicating that it denies the request to close.
Note that the Operating System might elect to close AppleTalk anyway; for example, if the
user grants permission to close in response to a dialog box.
Because the AppleTalk Manager calls your routine again (with the routine selector set to
ATTransClose) before the .MPP driver actually closes, it is not necessary for your routine to
do anything other than grant or deny permission in response to being called for a permissionto-close transition. However, you might want to prohibit the users from opening new sessions
or establishing new connections while you are waiting for the .MPP driver to close.
Cancel-Close

Transition

When any routine in the AppleTalk Transition Queue denies permission for the .MPP driver
to close, the AppleTalk Manager calls each routine listed in the AppleTalk Transition Queue
that has already received the permission-to-close transition to inform it that the request to
close the .MPP driver has been canceled.
When the AppleTalk Manager calls your AppleTalk Transition Queue routine for a cancelclose transition, the third item on the stack is a NIL pointer.
If your routine performed any tasks to prepare for the closing of AppleTalk, it should reverse

their effects when it is called with the routine selector set to ATTransCancelClose. Return 0 in

the DO register to indicate that your routine executed with no error.

The LAP Manager

—_ 32-23

ta
N
>

<)

sch
a")
=i]
=

2—

£9
=
ey
ie
g

Inside Macintosh, Volume VI

Developer-Defined

Transitions

Any AppleTalk transition event code that begins with an uppercase letter (that is, any value in
the range $41 00 00 00 through $5A FF FF FF) indicates a developer-defined event. You can
use such events to send messages to your own entries in the AppleTalk Transition Queue, or
you can define events and make them public for others to use. Because you cannot tell how
the originator of such an event might interpret a nonzero function result, you must always
return O in the DO register for any AppleTalk transition event code that you do not recognize.
When you return a nonzero result code for certain developer-defined transitions, the
AppleTalk Manager may call your AppleTalk Transition Queue routine a second time
with a cancel transition analogous to the cancel-close transition.

Defining

Your Own

AppleTalk Transition

You can define your own AppleTalk transition to have any meaning you choose. For
example, you might want to call every routine in the AppleTalk Transition Queue each
time you open an AppleTalk Data Stream Protocol (ADSP) connection.
You can use either the ATEvent procedure or the ATPreFlightEvent function to notify all of
the routines in the AppleTalk Transition Queue that your AppleTalk transition has occurred.
Whereas the ATEvent procedure only calls the routines in the queue with a transition event,
the ATPreFlightEvent function also allows each routine in the AppleTalk Transition Queue
to return a result code and other information to your calling routine.
Note: You can call the ATEvent and ATPreFlightEvent routines only at virtualmemory safe time. See the Memory Management chapter in this volume for
information on virtual memory.
PROCEDURE

ATEvent

(event:

LongInt;

infoPtr:

Ptr);

The ATEvent procedure calls all of the routines in the AppleTalk Transition Queue with the
AppleTalk transition event code you specify in the event parameter. The AppleTalk transition
event code can be any 4-character string that starts with an uppercase letter—that is, any value
in the range $41 00 00 00 through $5A FF FF FF. You can use the infoPtr parameter to point
to any information that you want to make available to the AppleTalk Transition Queue routines;
for an ADSP-open transition, for example, you might pass a pointer to the parameter block
used by the dspOpen routine. If you do not want to pass any information to the AppleTalk
Transition Queue routines, set the infoPtr parameter to NIL.
FUNCTION

ATPreFlightEvent

(event,cancel:

LongInt;

infoPtr:

Ptr)

:

OSErr;

The ATPreFlightEvent function calls all of the routines in the AppleTalk Transition Queue
with the AppleTalk transition event code you specify in the event parameter. If any routine in
the AppleTalk Transition Queue returns a nonzero function result, the ATPreFlightEvent
function calls each of the routines that it has already called, this time with the AppleTalk

32-24

The LAP Manager

The AppleTalk Manager

transition event code you specify in the cancel parameter. The AppleTalk transition event
codes can be any 4-character strings that start with an uppercase letter—that is, any values in
the range $41 00 00 00 through $5A FF FF FF. You can use the infoPtr parameter to point to
any information that you want to make available to the AppleTalk Transition Queue routines.
If you do not want to pass any information to the AppleTalk Transition Queue routines, set
the infoPtr parameter to NIL.
Result code
noErr
Note:

The

0

No error, or unrecognized event code

AppleTalk transitions defined by developers might return other result codes.

LAP

Manager

802.2

Protocol

The Institute of Electrical and Electronics Engineers (IEEE) has defined a series of communications protocols for use on a variety of networks. At the physical level, these protocols
include the 802.3 CSMA/CD

protocol, the 802.4 token bus protocol, and the 802.5 token

ring protocol. At the data link level, you access these protocols through another IEEE
protocol, the 802.2 protocol. The AppleTalk LAP Manager includes two routines that allow
you to attach and detach protocol handlers for 802.2 Type | data packets: the L802Attach and
L802Detach routines. You can write an application that reads 802.2 Type | data packets and
use the L802Attach routine to install your application as a client of the LAP Manager. The
ANSI/IEEE standards for the 802 protocols are published by the IEEE.
The first 14 bytes of a packet sent or received by the .ENET driver constitute the header. The
first 12 bytes consist of the destination and source data-link addresses, such as the Ethernet
hardware addresses. If the value of the last 2 bytes in the header is greater than 1500, then the
-ENET driver treats that field as an Ethernet protocol type discriminator. See “The .ENET
Driver” later in this chapter for more information on Ethernet protocols. If the value of the last
2 bytes in the header is less than or equal to 1500, then the packet is an 802.3 protocol packet
and this field indicates the length of the 802.3 data. The .ENET driver passes all 802.3
packets to the LAP Manager.
The LAP Manager receives the entire 802.3 packet from the .ENET driver. The first 3 bytes
of the 802.3 data constitute the header for the 802.2 protocol. The first byte of the 802.2
header is known as the destination service access point (DSAP). If the DSAP field is equal
to $AA, then the first 5 bytes of the 802.2 data constitute a protocol discriminator known
as the subnetwork access protocol (SNAP) type. If the SNAP type field is $00000080F3,
indicating the AppleTalk Address Resolution Protocol (AARP), then the next 4 bytes of the
802.2 data constitute a third type field, the AARP packet type. AARP is discussed in Inside
AppleTalk, second edition.
The first packet header in Figure 32-4, for example, indicates an Ethernet packet containing
AppleTalk Phase | data. The .ENET driver would deliver this packet to the AppleTalk
Phase | protocol handler.

The LAP Manager

— 32-25

uw
NS}
>

<)
—3
@

—_

+=)

~~

io
—

$9

=
re
@

Lene |

Inside Macintosh,

Volume VI

By contrast, the second data packet header in the figure indicates an 802.3 packet containing AppleTalk Phase 2 data. The .ENET driver would deliver this packet to the Phase 2
LAP Manager.
Similarly, the third data packet header in Figure 32-4 indicates an 802.3 packet to be
delivered to the Phase 2 EtherTalk AARP handler.
EtherTalk
Phase 2

EtherTalk

aoe

—

—

was

1.

—

estination |__

a

address | __

Ethernet
hardware
source
address

|—~
| _—
|__
|___

Ethernet
protocol
type }—

dieorirainalor
AppleTalk

Phase 1
data

|

|

——
——
—
—_

802.3

—

—

destination

#—

——

address

}—

802.3
source
address

$80

802.3

destination

uae

+ —_
|——
|_
=

Data |

Phase 2
AARP packet

address

—
a!
—
—s

802.3
source
address

(less than or

9B

e

*
|

°
]]

.

802.2

|—

header

=
|
—
|____

SNAP

type

SAA

SAA

$03

}—

——|

}—
| —
|_
=—_

—
—
—_s!
|

—

=

Data |__(less than or

—

802.2

header

=

=srds«sd$$BDs—=“_s—“”?
_—
it

SNAP

type

$80

$9B

|_—

|-_

|
=
|___

:

|

jl

*

ace

Pee

SAA

$03
$60
#00

ae!
=I
|
a!

=)

SFB

| __-—s—- $00

| Si(iséS

$80

=

2e

AARP
data

SAA

$80

|

AppleTalk *
Phase2 *

——|

length | equal to 1500)

length | equal to 1500)

4.

-—

#—

im

d

(802.3 protocol)
data packet

°

Phase 1
data packet

AARP
EtherTalk

Figure 32-4.

AppleTalk Ethernet packet formats

When you call the L802Attach routine, you provide a pointer to your protocol handler, the
reference number of the .ENET driver, and a pointer to a string containing one or more type
fields. The type fields indicate the DSAP value and any other protocol type fields (such as
the SNAP type and the AARP type). The LAP Manager delivers to your protocol handler
any 802.2 data packets that have the protocol type you specify.

32-26

The LAP Manager

The AppleTalk Manager

Attaching

and

Detaching

802.2

Protocol

Handlers

You can attach to the LAP Manager your own protocol handler for 802.2 protocols. The LAP
Manager has permanent handlers for certain types of EtherTalk packets. You cannot replace
or override the permanent LAP Manager protocol handlers.
There are no high-level interfaces for the LAP Manager 802.2 protocol routines. You call
these routines from assembly language by placing a routine selector in the DO register and
executing a JSR instruction to an offset 2 bytes past the start of the LAP Manager. The
start of the LAP Manager is contained in the global variable LAPMegrPtr ($B 18).
Before you call these routines, you must place the reference number of the .ENET driver in
the D2 register and a pointer to the protocol type specification in the Al register. Before you
call the L802Attach routine, you must also place a pointer to your protocol handler in the AO
register. Both routines return a nonzero value in the DO register if there is an error.
Listing 32-1 shows how to call

a LAP Manager L802.2 routine from assembly language

Listing 32-1. Calling

LAPMgrPtr

LAPMgrCall

L802Entry

EQU

EQU

a LAP Manager L802.2 routine from assembly language.

sentry point

SB18

;offset

2

to

LAP

EQU

*

;L802

routine

MOVEQ

#RSel, DO

;place

routine

MOVEQ

#refNum,

MOVE.L

PHndlrPtr,A0

MOVE.L

PSpecPtr,

MOVE. L
JSR

LAPMgrPtr,An
LAPMgrCall(An)

;

in

Al

;put pointer
> handler
in

;

=

entry

<
=

selector
reference
to
AO

only)

;put pointer
to
> specification

qe
be

number

protocol
(L802Attach
protocol
in Al)

;put pointer to LAP Mgr in
;jump to start of LAP Mgr
;

=

routines

DO

;place driver
: in D2

D2

An

routines

L802Attach

The L802Attach routine attaches to the LAP Manager a protocol handler for a specific IEEE
802.2 protocol type.

On entry

On exit

DO:
D2:
AO:
A1:
DO:

=

<—)

=

for LAP Manager
Manager

U2
NS)

21
reference number of .ENET driver
pointer to your protocol handler
pointer to protocol specification
nonzero if error

The LAP Manager

— 32-27

Inside Macintosh,

Volume VI

Before calling this routine, you must put the value 21 in the DO register and the reference
number of the .ENET driver in the D2 register. The .ENET driver reference number 1s
returned by the OpenSlot function. If you are not using the .ENET driver or a driver that
uses the same interface as the ENET driver, you cannot use the L802Attach routine.
You must put a pointer to your protocol handler in the AO register and a pointer to the
protocol-type specification for this protocol handler in the A1 register. The protocol-type
specification consists of one or more protocol-type fields, each preceded by a length byte.
The LAP Manager reads the protocol-type fields in the 802.2 data packet header to determine
to which protocol handler (if any) to deliver the packet. The first type field in your protocol
specification is the 1-byte DSAP. If the DSAP type field is equal to $AA, then the protocoltype specification must contain a second type field, the 5-byte SNAP type. If the SNAP type
field is $00000080F3, indicating the AppleTalk Address Resolution Protocol (AARP), then
the protocol-type specification must contain a third type field, the 4-byte AARP protocol type.
Terminate the list of protocol-type fields with a byte of zeros.
The following protocol-type specification, for example, is for the permanent LAP Manager
protocol handler for an 802.3 packet containing AppleTalk data. The .ENET driver would
deliver this packet to the AppleTalk Phase 2 LAP Manager. The first byte, $01, is the length

byte for the first protocol-type field (the DSAP type field), $AA. The third byte, $05, is the
length byte for the next protocol-type field, the SNAP. The final byte ($00) terminates the
type specification.
O01

AA

05

08

00

07

80

9B

00

The following protocol-type specification is for the permanent LAP Manager protocol handler
for an 802.3 packet to be delivered to the EtherTalk AARP handler. Notice that the SNAP
field is followed by an additional type field, the AARP protocol type.
01

AA

05

00

00

00

80

F3

04

00

01

80

9B

00

Note: The DSAP value of $AA is reserved for use with protocol-type specifications
that include a SNAP field. The SNAP value of $08 00 07 80 9B is reserved for
AppleTalk data. The SNAP value of $00 00 00 80 F3 is reserved for AARP data. The
AARP protocol type value of $00 01 80 9B is reserved for EtherTalk AARP packets.
See the ANSI/IEEE standard 802.2 for more information about 802.2 protocols, and see
Inside AppleTalk, second edition, for more information about AARP.
L802Detach

The L802Detach routine detaches from the LAP Manager a protocol handler for a specific
IEEE 802.2 protocol type.

On entry
On exit

32-28

DO: 22

D2: reference number of .ENET driver

A|:

pointer to protocol specification

DO: nonzero if error

|= The LAP Manager

The AppleTalk Manager

Before calling this routine, you must put the value 22 in the DO register and the reference
number of the .ENET driver in the D2 register. The .ENET driver reference number is
returned by the OpenSlot function. If you are not using the .ENET driver or a driver that
uses the same interface as the .ENET driver, you cannot use the L802Detach routine.
You must put a pointer to the protocol-type specification for this protocol handler in the
Al register. You must specify exactly the same protocol type as you specified for the
L802Attach routine when you attached the protocol handler.

THE

.ATP

DRIVER

AppleTalk Phase 2 includes two changes to the .ATP driver: you can now cancel all calls to
the ATPGetRequest function that are pending execution, and you can now set the release
timer for AppleTalk Transaction Protocol (ATP) exactly-once (XO) service to one of five

different values.

oe)
nN

>

Canceling

All Calls to the ATPGetRequest

is)

Function

=

The ATPGetRequest function sets a socket to receive a request sent by another socket. If you
call the ATPGetRequest function asynchronously, you can have several calls to the function
simultaneously pending execution. The ATPKillAlIGetReq function cancels all calls to the
ATPGetRequest function pending for a specific socket without closing the socket.
FUNCTION

ATPKillAl1GetReq

Parameter block
>
26
>

28

(thePBptr:

ATPPBPtr;

async:

Boolean)

:

OSErr;

csCode

word

always ATPKillAlIGetReq

atpSocket

byte

socket for which to cancel all calls
to ATPGetRequest

The ATPKillAllGetRegq function cancels all pending asynchronous calls to the ATPGetRequest
function for the socket you specify with the atpSocket parameter. The ATPKillAlIGetReq
function also calls the completion routine for each call to the ATPGetRequest function with the
value reqAborted (—1105) in the DO register.
Unlike the ATPCloseSocket function, the ATPKillAllGetReq function does not close the
socket. You should call the ATPKillAllGetReq function before closing a socket. The csCode
parameter is a routine selector, automatically set by the MPW interface. It is always equal to
ATPKillAllGetReq for this function.
Result codes
noErr
cbNotFound

0
-1102

No error
Control block not found; no pending asynchronous calls

The .ATP Driver

32-29

ae.
fo
~
4
—

n

=
mS

re
‘io
=

Inside Macintosh,

Volume VI

Setting the Timeout

Value for the ATP

Release Timer

The .ATP driver maintains a timer, called the release timer, for each call to the PSendResponse
function that is part of an exactly-once (XO) transaction. If the timer expires before the transaction is complete (that is, before the socket receives the transaction release packet), the driver
completes the PSendResponse function. Before AppleTalk Phase 2, the release timer was always
set to 30 seconds. To set the other connection end’s release timer to another value, set bit 2 of the
atpFlags field in the parameter block for the PSendRequest or the PNSendRequest function and
add a new byte field to the parameter block at offset 5|0—the TRelTime field. (The PSendRequest
and PNSendRequest functions use the SendRequestParm variant of the ATP parameter block.)
Here is the ATP parameter block for the PSendRequest and PNSendRequest functions:
TYPE

ATPParamBlock
PACKED

=

RECORD

{extended
{

for

parameter

PSendRequest

block
and

}

}

qLink:

QElemPtr;

{ PNSendRequest }
{next
queue entry}

qType:
ioTrap:
ioCmdAdadr :

Integer;
Integer;
Ptr;

{queue type}
{routine trap}
{routine address}

ioCompletion:

ProcPtr;

{completion

ioResult:

OSErr;

{result

userData:

LongiInt;

{ATP

reqTID:
ioRefNum:

Integer;
Integer;

{request
transaction
ID}
{driver
reference
number}

routine}

code}

user

bytes}

csCode:

Integer;

{primary

atpSocket:

Byte;

{currBitMap

command

atpFlags:

Byte;

{control

parameter
address}
in

or

code}
socket

information

number}

-

set

bit

2

}

AddrBlock;

{ for extended
{source
socket

reqLength:

Integer;

{request

size

reqPointer:

Ptr;

{pointer

to

request

bdsPointer:

Ptr;

{pointer

to

response

numOfBuffs:

Byte;

structure}
{ data
{number
of responses

expected}

numOfResps:

Byte;

{number

of

responses

}

retryCount:

Byte;

{ actually
{number
of

received}
retries}

intBuff:
TRelTime:

Integer;
Byte

{used internally for PNSendReacuest }
{release timer setting}

addrBlock:

timeOutVal:

Byte;

{timeout

block}

bytes}

interval}

data}
buffer

}

END;

The lower three bits of the TRelTime field indicate the time to which the release timer is to be
set, as follows:

TRelTime
field

_ Setting
release

of

timer

000
001

30 seconds
| minute

32-30

The .ATP Driver

The AppleTalk Manager

TRelTime

Setting

010
Ol]
100

2 minutes
4 minutes
8 minutes

field

release

of

timer

Note: The nodes at both ends of the ATP connection must be running AppleTalk
Phase 2 drivers for this feature to work.
XO service, the release timer, and the SendRequest function are described in the AppleTalk
Manager chapter of Volume II. The ATP parameter block and the PNSendRequest function
are described in the AppleTalk Manager chapter of Volume V.

THE

.XPP

DRIVER

oe)
nN
>

The .XPP driver provides these functions that return information about zones:

—

~
=)
—
fas)

—

a The GetMyZone function returns the AppleTalk zone name of the node on which your
application is running. This function works for both extended and nonextended networks.

ae!

as

—_
—

~
rd
—

}

m The GetLocalZones function returns a list of zone names on the network that includes
the node on which your application is running. This function works for extended
networks only.
a The GetZoneList function returns a complete list of zones on the internet.
Note:

Before the AppleTalk Phase 2 version of the .XPP driver, you had to use the

AppleTalk Transaction Protocol (ATP) to obtain zone information and request it
directly from a router. The Zone Information Protocol (ZIP) functions provided by

the new version of the .XPP driver make it much easier for you to obtain this
information. To ensure compatibility with future versions of AppleTalk, you should
always use the functions described in this section to obtain zone information.

For the GetMyZone, GetLocalZones, and GetZoneList functions, the .XPP driver uses the
xCallParam variant to the XPP parameter block.
TYPE

XPPParamBlock
PACKED

=

RECORD

qLink:

QElemPtr;

{next

qType:

Integer;

{queue

queue

entry}

type}

ioTrap:

Integer;

{routine

L1oCmdAdadr:
ioCompletion:

Ptr;
ProcPtr;

{routine
address}
{completion
routine}

trap}

ioResult:

OSErr;

{result

cmdResult:
ioVRefNum:

LongIint;
Integer;

{command
result}
{volume
reference

code}
number}

ioRefNum:

Integer;

{driver

number}

reference

The .XPP Driver

32-31

_—

a

as

-_

ge
@
Ler |

Inside Macintosh,

Volume VI

csCode:

Integer;

CASE

OF

XPPPrmBlkType

{primary

command

code}

xCallParam
xppSubCode:
xppTimeOut :

Integer;
Byte;

{secondary
command
code}
{ .
timeout
period
for
.XPP}

xppRetry:

Byte;

{retry

filleri:
zipBuffPtr:
zipNumZones:
ZipLastFlag:

Integer;
Ptr;
Integer;
Byte;

{reserved}
{returned
zone names}
{number
of zones
returned}
{nonzero when all
zone
}
{ names
have been returned}

filler2:

Byte;

ZipinfoField:

PACKED

count}

{reserved}
ARRAY[1..70]

OF

{reserved

Byte

for

use

by

.XPP}

END;

XPPParmBlkPtr

=

“XPPParamBlock;

As for all other AppleTalk Manager preferred interface functions, the MPW interface calls the
Device Manager PBControl function to implement these ZIP protocol functions. The qLink,
qType, ioTrap, ioCmdAddr, and ioVRefNum fields are filled in by the Device Manager; your
application should not have to set or read these fields. The ioResult field returns the result of
the function. If you call the function asynchronously, the Device Manager sets this field to |
as soon as you call the function, and it changes the field to the actual result code when the
function completes execution. The ioCompletion field is a pointer to a completion routine that
you can provide; the Device Manager calls your completion routine when it completes execution of the PBControl function. If you are not providing a completion routine, specify NIL
for this field.
The value of the ioRefNum field is returned by the OpenDriver function; you must provide
this value in each call to an .XPP driver routine. The csCode and xppSubCode fields specify
the command to be executed; the MPW

Pascal interface fills in these fields for you.The .XPP

zone information functions do not use the cmdResult field.

Using the .XPP

Driver to Obtain Information About Zones

The Zone Information Protocol (ZIP) obtains the zone information by using the AppleTalk
Transaction Protocol (ATP) to send an information request to a router. The xppTimeOut field
specifies the amount of time, in seconds, that the .ATP driver should wait between attempts

to obtain the data. The xppRetry field specifies the number of times the .ATP driver should
attempt to obtain the data before returning the reqFailed (request failed) result code.

The zipBuffPtr field is a pointer to a data buffer that you must allocate. This buffer must be
578 bytes for the GetZoneList and GetLocalZones functions and 33 bytes for the GetMyZone
function. ZIP returns the zone names (as a packed array of packed Pascal strings) into this
buffer. The zipNumZones field returns the actual number of zone names that ZIP placed
in the buffer. You must set the zipLastFlag field to 0 (FALSE) before you execute the
GetZoneList or GetLocalZones function. If the zipLastFlag parameter is still 0 when the
command has completed execution, then ZIP is waiting to return more zone names. In

32-32

The .XPP Driver

The AppleTalk Manager

this case you must empty the buffer (or allocate a new one) and call the GetZoneList or
GetLocalZones function again immediately. When there are no more zone names to return,
ZIP sets the zipLastFlag field to a nonzero (TRUE) value.
The zipInfoField field is a 70-byte data buffer that you must allocate for use by the .XPP
driver. The first time you call any of these functions, you must set the first word of this field
to 0. You must not change any values in this field subsequently.
Listing 32-2 illustrates the use of the GetZoneList function. The GetLocalZones function
operates in exactly the same fashion.
Listing 32-2.
PROCEDURE

Using the GetZoneList

function

doGetZoneList;

VAR

myXPPPB:
myErr:

XPPParamBlock;
OSErr;?

{.XPP

parameter

block}
u
>
c

BEGIN

WITH

myXPPPB

BEGIN

DO

=

xppTimeOut
:= 3;
xppRetry
:= 4;
zipBuffPtr

:=

zipLastFlag

{timeout period
{retry count}

NewPtr(578);

:=

zipInfoField[1]

0;

zipinfoField[2]

:=

0;

:=

0;

{zone

names

{set

to

{first
{ time

0

for

returned

the

first

word
is 0
through}

=

.XPP}

>
=

here}

time

the

=|

through}

first

re

“t

}

END;

MYErY

{Check
{
{

s=

the

noErr;

zipNumZones

field

to

determine

how

many

zone

names

}

}
to the
the zone names
Append
in the buffer.
returned
have been
}
names.
zone
more
read
to
returning
before
buffer
own
your
end of
{loop
WHILE

to get all of the zone
(myXPPPB.zipLastFlag
=

names}
0)
& (myErr

=

noErr)

DO

BEGIN

myErr
:= GetZoneList (@myXPPPB,
EmptyDataBuf (@myXPPPB) ;
END;
YourZIPProc

(@myXPPPB)

IF

noErr

myErr

<>

;

THEN

DoError

DisposPtr(myXPPPB.zipBuffPtr)

;

FALSE) ;
{your
routine
to
{ data buffer}

empty

{your

process

routine

(myErr);
{there's
{give

an

space

to

}

names}

error}
back}

END;

The .XPP Driver

32-33

Inside Macintosh,

Volume VI

Listing 32-3 illustrates the use of the GetMyZone function.
Listing 32-3.
PROCEDURE

Using the GetMyZone

function

doGetMyZone;

VAR

myXPPPB:

XPPParamBlock;

myZoneName:

ARRAY[1..33]

myErr:

OSErr;

{.XPP
OF

parameter

block}

CHAR;

BEGIN

WITH

myXPPPB

DO

BEGIN

xppTimeOut
xppRetry

:=
:=

zipBuffPtr

3;

{timeout

4;

{retry

:=

@myZoneName;

ZipInfoField[1]
ZipiInfoField[2]

:=
:=

0;
0;

period

for

.XPP}

returned

here}

count}

{zone

name

{first

word

{

through}

time

is

0

the

first

}

END;

myErr
IF

:=

myErr

GetMyZone(@myXPPPB,
<>

noErr

THEN

FALSE);

DoError

(myErr) ;
{there's

an

error}

END;

Obtaining

Zone

Information

The .XPP driver provides three functions that obtain information about zones. All three
functions use the Zone Information Protocol (ZIP) to return the names of zones.

Assembly-language note:

The .XPP driver functions all use the same

value (xCall, which is equal to 246) for the csCode parameter to the XPP

parameter block. The xCall routine uses the value of the xppSubCode
parameter to distinguish between the functions, as follows:
Function

xppSubCode

GetMyZone
GetLocalZones
GetZoneList

zipGetMyZone
zipGetLocalZones
zipGetZoneList

FUNCTION

GetMyZone

Parameter block
—
16
32-34

26

(thePBptr:

XPPParmBlkPtr;

Value
7
5
6
async:

Boolean)

:

OSErr;

ioResult

word

result code

csCode

word

routine selector; always xCall

The .XPP Driver

The AppleTalk Manager

>

28

xppSubCode

word

>

30

xppTimeOut

byte

routine selector; zipGetMyZone
retry interval in seconds

>

31

xppRetry

byte

retry count

>

34

zipBuffPtr

long

pointer to data buffer

>

42

zipInfoField

70 bytes

_‘ for use by ZIP; first word set to 0

The GetMyZone function returns only the AppleTalk zone name of the node on which your
application is running.
The ioResult field returns the result of the function. If you call the function asynchronously,
the function sets this field to 1 as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The csCode and xppSubCode fields are
routine selectors and are automatically set by the MPW interface to xCall and zipGetMyZone
for this function. The xppTimeOut field specifies the amount of time, in seconds, that the
.ATP driver should wait between attempts to obtain the data. A value of 3 or 4 for the
xppTimeOut field generally gives good results. The xppRetry field specifies the number
of times the .ATP driver should attempt to obtain the data before returning the reqFailed
(request failed) result code. A value of 3 or 4 for the xppRetry field usually works well.
The zipBuffPtr field is a pointer to a 33-byte data buffer that you must allocate. ZIP returns
the zone name into this buffer as a Pascal string. The zipInfoField field is a 70-byte data
buffer that you must allocate for use by ZIP. You must set the first word of this buffer to 0
before you call the GetMyZone function.

a)
NS)
>

‘)

2@

bm]
a
=
<
=~
9
re
i

@

er |

Result codes

noErr
noBridgeErr
reqFailed
tooManyReqs
noDataArea

FUNCTION

0
~93
—1096
-1097
—1104

GetLocalZones

Parameter block
<—
16

Noerror
Norouter is available
Request to contact router failed; retry count exceeded
‘Too many concurrent requests
Too many outstanding ATP calls

(thePBptr:

XPPParmBlkPtr;

async:

ioResult

word

result code

Boolean)

:

OSErr;

>

26

csCode

word

routine selector; always xCall

—

28

xppSubCode

word

routine selector; zipGetLocalZones

>

30

xppTimeOut

byte

retry interval in seconds

>

31

xppRetry

byte

retry count

>

34

zipBuffPtr

long

pointer to data buffer

<—

38

zipNumZones

word

number of names returned

-

40

zipLastFlag

byte

nonzero if no more names

>

42

zipInfoField

70 bytes

_—_— for use by ZIP; first word set to 0

The .XPP Driver

32-35

Inside Macintosh, Volume VI

The GetLocalZones function returns a list of all the zone names on the local network—that is,
the network that includes the node on which your application is running.
The ioResult field returns the result of the function. If you call the function asynchronously,
the function sets this field to 1 as soon as it begins execution, and it changes the field to the |
actual result code when it completes execution. The csCode and xppSubCode fields are routine
selectors and are automatically set by the MPW interface to xCall and zipGetLocalZones for
this function. The xppTimeOut field specifies the amount of time, in seconds, that the .ATP
driver should wait between attempts to obtain the data. A value of 3 or 4 for the xppTimeOut

field generally gives good results. The xppRetry field specifies the number of times the .ATP
driver should attempt to obtain the data before returning the reqFailed (request failed) result
code. A value of 3 or 4 for the xppRetry field usually works well.

The zipBuffPtr field is a pointer to a 578-byte data buffer that you must allocate. ZIP returns
the zone names into this buffer as a packed array of Pascal strings. The zipNumZones parameter returns the number of zone names that ZIP placed in the data buffer.
The .XPP driver sets the zipLastFlag field to | if there are no more zone names for your
network. If the zipLastFlag field is still 0 when the GetLocalZones function has completed
execution, you must empty the data buffer pointed to by the zipBuffPtr parameter and
immediately call the GetLocalZones function again without changing the value in the
zipInfoField parameter. The zipInfoField parameter is a 70-byte data buffer that you must
allocate for use by ZIP. You must set the first word of this buffer to 0 before you call the
GetLocalZones function the first time, and you must not change the contents of this field
thereafter.
Result codes

noErr
noBridgeErr
reqFailed

0
—93
—1096

noDataArea

-1104

tooManyRegs

FUNCTION

—-1097

GetZoneList

No error
Norouter is available
Request to contact router failed; retry count exceeded

Too many concurrent requests

Too many outstanding ATP calls

(thePBptr:

XPPParmBlkPtr;

async:

Boolean)

:

OSErr;

Parameter block

32-36

on

16

ioResult

word

result code

>

26

csCode

word

routine selector; always xCall

>

28

xppSubCode

word

routine selector; zipGetZoneList

—

30

xppTimeOut

byte

retry interval in seconds

=>

31

xppRetry

byte

retry count

>

34

zipBuffPtr

long

pointer to data buffer

-

38

zipNumZones

word

number of names returned

<—

40

zipLastFlag

byte

nonzero if no more names

>

42

zipInfoField

70 bytes

The .XPP Driver

_—_— for use by ZIP; first word set to 0

The AppleTalk Manager

The GetZoneList function returns a complete list of all the zone names on the internet. To
obtain a list of only the zone names on the local network, use the GetLocalZones function
instead.
The ioResult field returns the result of the function. If you call the function asynchronously,
the function sets this field to | as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The csCode and xppSubCode fields are
routine selectors and are automatically set by the MPW interface to xCall and zipGetZoneList
for this function. The xppTimeOut field specifies the amount of time, in seconds, that the
-ATP driver should wait between attempts to obtain the data. A value of 3 or 4 for the
xppTimeOut field generally gives good results. The xppRetry field specifies the number
of times the .ATP driver should attempt to obtain the data before returning the reqFailed
(request failed) result code. A value of 3 or 4 for the xppRetry field usually works well.
The zipBuffPtr field is a pointer to a 578-byte data buffer that you must allocate. ZIP returns
the zone names into this buffer as Pascal strings. The zipNumZones parameter returns the
number of zone names that ZIP placed in the data buffer.
The .XPP driver sets the zipLastFlag field to | if there are no more zone names for the
internet. If the zipLastFlag field is still 0 when the GetZoneList function has completed
execution, you must empty the data buffer pointed to by the zipBuffPtr parameter and
immediately call the GetZoneList function again without changing the value in the
zipInfoField parameter. The zipInfoField parameter is a 70-byte data buffer that you must
allocate for use by ZIP. You must set the first word of this buffer to 0 before you call the
GetZoneList function the first time, and not change the contents of this field thereafter.
If you use the GetZoneList function on a nonextended network, it returns the reqFailed
result code.
Result codes

noErr
noBridgeErr
reqFailed
tooManyReqs
noDataArea

APPLETALK

QO
-—93
—1096
-—1097
—1104

DATA

PROTOCOL

(ADSP)

One of the significant new features of AppleTalk included as part of system software
version 7.0 is the AppleTalk Data Stream Protocol (ADSP), which provides a full-duplex
data stream connection between two nodes in an AppleTalk internet. Like the AppleTalk
Session Protocol, Printer Access Protocol, and AppleTalk Transaction Protocol, ADSP
uses the Datagram Delivery Protocol (DDP) to send its data over the internet. Therefore,

even though ADSP appears to its clients to handle data as a stream of bytes, the data is
actually transmitted and received by DDP in packets. ADSP takes advantage of this fact by
including control and status information in the DDP packet header. You can use the .DSP
driver routines described in ‘.DSP Driver Routines” later in this chapter to control an ADSP
connection. The .DSP driver takes care of the implementation of ADSP for you.
AppleTalk Data Stream Protocol (ADSP)

>

S
=@

ae |

ze

=
s
=
=
to)
i=@

oat

Lew

Noerror
Norouter is available
Request to contact router failed; retry count exceeded
Too many concurrent requests
Too many outstanding ATP calls

STREAM

UyNS

— 32-37

|

Inside Macintosh,

Volume VI

Every ADSP connection is between two sockets in an AppleTalk internet. Each socket can
maintain concurrent ADSP connections with several other sockets, but there can be only one
ADSP connection between any two sockets at one time. When a pair of sockets establishes
an ADSP connection, each socket client initializes and maintains a certain amount of control
and state information that it uses for synchronizing communication with the other socket
client and for error checking.
The combination of a socket and the ADSP information maintained by the socket client is
referred to as a connection end. When two connection ends establish communication, the
connection is considered an open connection. When both connection ends terminate the

link and dispose of the connection information each maintains, the connection is considered a

closed connection. If one connection end is established but the other connection end is
unreachable or has disposed of its connection information, the connection is considered a
half-open connection. No communication can occur over a half-open or closed connection. To prevent a half-open connection from tying up resources, ADSP automatically closes
any half-open connection that cannot reestablish communication within 2 minutes.

Using

ADSP

You can use ADSP to implement a data stream connection between any two sockets on an
internet. (Note that although there can be only one ADSP connection between any two
sockets, a single socket can maintain connections with several other sockets.) This section

describes how to open, maintain, and close a connection between two sockets on an internet.

It also describes how to establish and use a connection listener—that is, a connection end
that waits passively to receive a connection request and then passes the connection request
on to its client, the connection server. Finally, this section describes how to write a routine
(referred to as a user routine) that ADSP calls when your connection end receives an
unsolicited connection event.

The

ADSP

Connection

Control

Block

When you establish an ADSP connection end, you must allocate a nonrelocatable block of
memory for, and provide a pointer to, a connection control block (CCB) data structure,
which is used by ADSP to store state information about the connection end. You may read
the fields in the CCB to obtain information about the connection end, but you are not allowed
to write to any of the fields except one, the userFlags field. The CCB requires 242 bytes and
is defined by the TRCCB data type.
TYPE.

TRCCB:
PACKED

=
RECORD

ccbLink:

TPECB?

{link

refNum:
state:

Integer;
Integer;

{reference
number}
{state of the connection

to

userFlags:
localSocket:

Byte;
Byte;

{user
flags
for connection}
{local
socket
number}

remoteAddress:
attnCode:
attnSize:

AddrBlock;
Integer;
Integer;

{remote
end internet
address}
{attention
code received}
{size of attention
data}

attnPtr:
reserved:

Ptr;
PACKED

{pointer
ARRAY[1..220]
OF
{reserved

END;

32-38

| AppleTalk Data Stream Protocol (ADSP)

next

CCB}

to attention
Byte
for

use

by

end}

data}
ADSP}

The AppleTalk Manager

The internet address of the remote connection end is defined in the CCB by the AddrBlock
data type:
TYPE

AddrBlock
PACKED RECORD
aNet:

Integer;

{network

aNode:

Byte;

{node

aSocket:

Byte

{socket

number}

ID}
number}

END;

Field

descriptions

cecbLink

A pointer to the next CCB. This field is for use by ADSP only.

refNum

The reference number of the CCB. This number is assigned by ADSP
when you establish the connection end.

state

The state of the connection end, as follows:

State

Value

uy

Meaning

~~

—

vw

or)
—

—

sListening

userFlags

l

The socket is a connection listening
socket—that is, a socket that accepts ADSP
requests to open connections and passes
them on to a socket client. This state is
ordinarily used only by connection servers.

sPassive

2

The socket client is inactive but capable
of accepting an ADSP request to open a
connection. Unlike a connection listening
socket, which passes the open-connection
request on to a routine that can establish
the connection on any socket, a socket
client in the sPassive state can accept an
open-connection request only to establish
itself as a connection end.

sOpening

3

The socket client has sent an openconnection request and is waiting for
acknowledgment.

sOpen

a

The connection is open.

sClosing

5

The socket client has requested that ADSP
close the connection, and ADSP is sending
data or waiting for acknowledgment of data
it has sent before closing the connection.

sClosed

6

The connection.is closed.

Flags that indicate an unsolicited connection event has occurred. An
unsolicited connection event is an event initiated by ADSP or the
remote connection end that is not in response to any .DSP routine that
you executed.

AppleTalk Data Stream Protocol (ADSP)

32-39

@

as ,
ll
*
—
_

2
—
as
_—
—

—
=
yO
—

(a)

=

Inside Macintosh,

Volume VI

userFlags (continued) Each time an unsolicited connection event occurs, ADSP sets a flag
in the userFlags field of the CCB and calls the routine you specified
in the userRoutine parameter to the dspInit routine (if any). The user
routine must read the userFlags field and then clear the flag to 0.
ADSP cannot notify your routine of future events unless you clear the
flag after each event.
ADSP recognizes four types of unsolicited connection events, one
corresponding to each of the flags in this field. The events and flags
are defined as follows, where bit 7 is the most significant bit:
Event

Flag
bit

eClosed

7

ADSP has been informed by the remote
connection end that the remote connection
end has closed the connection.

eTearDown

6

ADSP has determined that the remote
connection end is not responding and so
has closed the connection.

eAttention

5

ADSP has received an attention message
from the remote connection end.

eFwdReset

4

ADSP has received a forward reset
command from the remote connection end,
has discarded all ADSP data not yet
delivered—including the data in the local
client end’s receive queue—and has
resynchronized the connection.

none

3-0

Reserved.

Meaning

localSocket

The socket number through which DDP transmits and receives the
ADSP packets.

remoteAddress

The internet address of the socket used by the remote connection end.

attnCode

The attention code received by ADSP when the remote connection end
sends an attention message.

attnSize

The size of the attention message received by ADSP when the remote
connection end sends an attention message.

attnPtr

A pointer to a buffer containing the attention message received by
ADSP from the remote connection end.

reserved

A data buffer reserved for use by ADSP.

The

.DSP

Parameter

Block

You execute the .DSP routines by calling the Device Manager’s PBControl function. Each
time you call a .DSP routine, you provide a pointer to a parameter block that includes all of
the parameters needed by that command.

32-40

= AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

The .DSP parameter block, defined by the DSPParamBlock data type, is a variant parameter
:
block for the PBControl function.
TYPE

DSPParamBlock
PACKED

=

RECORD

qLink:

QElemPtr;

{next

qType:

Integer;

{queue

Integer;
Ptr;

{routine
{routine

ioTrap:
ioCmdAdar

:

ioCompletion:

rocPtr;

queue

entry}

type}

trap}
address}

{completion

routine}

ioResult:

OSErr;

{result

code}

ioNamePtr:

StringPtr;

{used

ioVRefNum:

Integer;

{volume

reference

number}

ioCRefNum:

Integer;

{driver

reference

number}

only

for

dspOpen}

csCode:

Integer;

{primary

command

qStatus:

Longint;

{reserved

for

ccbRefNum:

Integer;

{CCB

CASE
Integer
dspIinit,

code}

ADSP}

reference

number}

OF

>
—

dspCLIinit:

(

oy

5

ccbPtr:

TPCCB;

{pointer

to CCB}

userRoutine:

ProcPtr;

{pointer

to

user

routine}

=

sendQueue:

Ptr;

{pointer

to

recvQSize:
recvQueue:

sendQSize:

Integer;

a

{size

of

send

send

queue}

re

Integer;

{size

of

receive

queue}

c

Ptr;

{pointer

attnPtr:

Ptr;

{pointer
to attention{ message
buffer}

localSocket:
fillerl:

Byte;
Byte

{local
socket
number}
{filler
for proper
alignment}

localCID:
remoteCID:
remoteAddress:

Integer;
Integer;
AddrBlock;

{local
connection
ID}
{remote
connection
ID}
{remote
internet
address}

to

queue}

receive

=

queue}
}

)3
dspOpen,
dspCLListen,
dspCLDeny :

(

filterAddress:

AddrBlock;

{address

sendSeq:

Longint ;

{send

sequence

filter}

sendwindow:

Integer;

{size

of

recvSeq:
attnSendSeq:

Longint;
Longint ;

{receive
sequence
number}
{attention
send seq number}

attnRecvSeq:
ocMode:

Longint;
Byte;

{attention
receive
seq num}
{connection-opening
mode}

ociInterval:
ocMaximum:
filler2:

Byte;
Byte;
Byte

{interval
bet open requests}
{retries
of open-conn req}
{filler
for proper
alignment}

remote

number}
buffer}

AppleTalk Data Stream Protocol (ADSP)

32-4]

Inside Macintosh, Volume VI

dspClose,
dspRemove:

(

abort:

Byte;

filler3:

Byte

{abort send
{filler for

requests}
proper alignment}

statusCCB:

TPCCB;

{pointer

CCB}

sendQPending:

Integer;

{bytes

sendQFree:

{available

recvQPending:

Integer;
Integer;

{bytes

in

recvOFree:

Integer

{avail

receive-queue

reqCount:

Integer;

{requested

actCount:

Integer;

dspStatus:

(

to

waiting

in

send

send-queue

receive

queue}
buffer}

queue}
buffer}

3

dspRead,
dspwWrite:
(

number

of

bytes}

dataPtr:

PET

{actual
number of bytes}
{pointer
to data buffer}

eom:

Byte;

{l

if

end

flush:

Byte

{1

to

send

attnCode:

Integer;

attnSize:

Integer;

{client attention code}
{size of attention data}

attnData:

Ptr;

{pointer

attninterval:

Byte;

{reserved}

filler4:

Byte

{filler

sendBlocking:

Integer;

sendTimer:
rtmtTimer:

Byte;

{send-blocking
{reserved}

Byte;

{reserved}

badSeqMax:

Byte;

{retransmit

useCheckSum:

Byte

{DDP

checksum

Integer

{new

connection

of

message}

data

now}

)3
dspAttention:

(

to

attention

for

proper

data}

alignment}

hg

dspOptions:
(
threshold}

advice
for

threshold}
packets}

);
dspNewCID:
(
newCID:
END;

32-42

AppleTalk Data Stream Protocol (ADSP)

ID}

The AppleTalk Manager

The qLink, qType, ioTrap, ioCmdAddr, ioNamePtr, and ioVRefNum fields are filled in by the
Device Manager; your application should not have to set or read these fields. The ioResult field
returns the result of the function. If you call the routine asynchronously, the Device Manager
sets this field to | as soon as you call the routine, and it changes the field to the actual result
code when the routine completes execution. The ioCompletion field is a pointer to a completion
routine that you can provide; the Device Manager calls your completion routine when it completes execution of the PBControl function. If you are not providing a completion routine,
specify NIL for this field.
The ioCRefNum field is returned by the OpenDriver function. You must specify this number
every time you call the .DSP driver.
The csCode field specifies the command to be executed. You must fill in this field before
calling the PBControl function. You can use the following constants as values for the
csCode field:
CONST

{ADSP

routine

selectors}

dspInit

=

255;

{create

dspRemove
dspOpen
dspClose

=
=
=

254;
253;
252;

{remove a connection
{open a connection}
{close a connection}

a

new

end}

=
—
o

dspCLinit

=

251;

{create

a

listener}

85°

dspCLRemove
dspCLListen

=
=

250;
249;

{remove
{post a

a connection
listener}
listener
request}

*
ha

dspCLDeny

=

248;

{deny

an

dspStatus

=

247;

{get

status

of

dspRead

=

246;

{read

data

from

dspWrite

=

245;

{write

connection

open-connection

data
an

connection

end}

request}

=

end}

Te

connection}

Bs

connection

on

the
the

attention

connection}

dspAttention

=

244;

{send

dspOptions
dspReset

=
=

243;
242;

{set
connection
end options}
{forward
reset
the connection}

dspNewCID

=

241;

{generate

a

cid

for

Set

message}

a

connection

end}

The qStatus field is reserved for use by ADSP. The ccbRefNum field is the reference number
of the CCB. The CCB reference number is returned by ADSP in response to the dspInit
routine. You must specify this number as a parameter to every .DSP driver routine you call
subsequently.
The remaining fields are used only for specific routines; each of these fields is described in
“DSP Driver Routines” later in this chapter.

Opening

and

Maintaining

an ADSP

Connection

To use the AppleTalk Data Stream Protocol (ADSP) to establish and maintain a connection
between a socket on your local node and a remote socket, use the following procedure:
|. Use the MPPOpen function to open the .MPP driver, and then use the OpenDriver
function to open the .DSP driver. The OpenDriver function returns the reference
number for the .DSP driver. You must supply this reference number each time you
call the .DSP driver.
AppleTalk Data Stream Protocol (ADSP)

— 32-43

Inside Macintosh,

Volume

VI

2. Allocate nonrelocatable memory for a connection control block (CCB), send and receive
queues, and an attention-message buffer. If you need to allocate the memory dynamically while the program is running, use the NewPtr routine. Otherwise, the way in
which you allocate the memory depends on the compiler you are using. (Listing 32-4 at
the end of this section shows how it’s done in Pascal.) The memory that you allocate
becomes the property of ADSP when you call the dspInit routine to establish a connection end. You cannot write any data to this memory except by calling ADSP, and you
must ensure that the memory remains locked until you call the dspRemove routine to
eliminate the connection end.
The CCB is 242 bytes. The attention-message buffer must be 570 bytes. When you
send bytes to a remote connection end, ADSP stores the bytes in a buffer called the
send queue. Until the remote connection end acknowledges their receipt, ADSP keeps
the bytes you sent in the send queue so that they are available to be retransmitted if
necessary. When the local connection end receives bytes, it stores them in a buffer,
called the receive queue, until you read them. The sizes you need for the send and
receive queues depend on the lengths of the messages being sent.
ADSP does not transmit data from the remote connection end until there is room for it in
your receive queue. If your send or receive queues are too small, they limit the speed
with which you can transmit and receive data. A queue size of 600 bytes should work
well for most applications. If you are using ADSP to send a continuous flow of data, a
larger data buffer improves performance. If your application is sending or receiving the
user’s keystrokes, a smaller buffer should be adequate. The constant minDSPQueueSize
indicates the minimum queue size that you can use.
If you are using a version of the .DSP driver prior to version 1.5, you must allocate
send and receive queues that are 12 percent larger than the actual buffer sizes you need.
You must do this in order to provide some extra space for use by the .DSP driver.
Version 1.5 and later versions of the .DSP driver use a much smaller, and variable,
portion of buffer space for overhead. The .DSP driver version number is stored in
the low byte of the qFlags field, which is the first field in the dCtlQHar field in the
driver’s device control entry (DCE) data structure. Version 1.5 of the .DSP driver
has a version number of 4 in the DCE. The DCE is described in the Device Manager
chapters of Volumes II and V.
3. Use the dspInit routine to establish a connection end. You must provide pointers to the
CCB, send queue, receive queue, and attention-message buffer. You may also provide
a pointer to the user routine that ADSP calls when your connection end receives an
unsolicited connection event. User routines are discussed in “Writing a User Routine
for Connection Events” later in this chapter.
If there is a specific socket that you want to use for the connection end, you can
specify the socket number in the localSocket parameter. If you want ADSP to assign
the socket for you, specify 0 for the localSocket parameter. ADSP returns the socket
number when the dspInit routine completes execution.
4. If you wish, you can use the NBPRegister function to add the name and address of
your connection end to the node’s names table. The
NBPRegister function is described
in the AppleTalk Manager chapter of Volume II.

32-44

= AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

5. You can use the dspOptions routine to set several parameters that control the behavior
of the connection end. Because every parameter has a default value, the use of the
dspOptions routine is optional. You can specify values for the following parameters:
m

The sendBlocking parameter, which sets the maximum number of bytes that may
accumulate in the send queue before ADSP sends a packet to the remote connection
end. You can experiment with different values of the sendBlocking parameter to
determine which provides the best performance. Under most circumstances, the
default value of 16 bytes gives good performance.

a

The badSeqMax parameter, which sets the maximum number of out-of-sequence data
packets that the local connection end can receive before requesting the remote connection end to retransmit the missing data. Under most circumstances, the default value
of 3 provides good performance.

a

The useCheckSum parameter, which determines whether the Datagram Delivery
Protocol (DDP) should compute a checksum and include it in each packet that it
sends to the remote connection end. Using checksums slows communications
slightly. Normally ADSP and DDP perform enough error checking to ensure safe
delivery of all data. Set the useCheckSum parameter to | only if you feel that the
network is highly unreliable.

6. Call the dspOpen routine to open the connection. The dspOpen routine has four
possible modes of operation: ocAccept, ocEstablish, ocRequest, and ocPassive.
Normally you use either the ocRequest or ocPassive mode. You must specify one of
these four modes for the ocMode parameter when you call the dspOpen routine.
The ocAccept mode is used only by connection servers. The ocEstablish mode is used
by routines that determine their connection-opening parameters and establish a
connection independently of ADSP, but use ADSP to transmit and receive data.
Use the ocRequest mode when you want to establish communications with a specific
socket on the internet. When you execute the dspOpen routine in the ocRequest mode,
ADSP sends an open-connection request to the address you specify.
If the socket to which you send the open-connection request is a connection listener,
the connection server that operates that connection listener can choose any socket on
the internet to be the connection end that responds to the open-connection request. To
restrict the socket from which you will accept a response to your open-connection
request, specify a value for the filterAddress parameter to the dspOpen routine. When
your connection end receives a response from a socket that meets the restrictions of the
filterAddress parameter, it acknowledges the response and ADSP completes the
connection.
To use the ocRequest mode, you must know the complete internet address of the remote
socket, and the ADSP client at that address must either be a connection listener or have
executed the dspOpen routine in the ocPassive mode. You can use the PLookupName
function to obtain a list of names of objects on the internet and to determine the internet
address of a socket when you know its name. The PLookupName function is the preferred interface version of the NBPLookup function. The NBPLookup function is described in the AppleTalk Manager chapter of Volume II. The preferred interface is
described in the AppleTalk Manager chapter of Volume V. Enhancements to the wildcard-lookup feature of the Name-Binding Protocol (NBP) are discussed in “A New
NBP Wildcard Character” earlier in this chapter.
AppleTalk Data Stream Protocol (ADSP)

— 32-45

Ge

NS
>

)

z
o

a
—

eS
—
£9
=)
a

ga
iS
4

Inside Macintosh,

Volume

VI

Use the ocPassive mode when you expect to receive an open-connection request from a
remote socket. You can specify a value for the filterAddress parameter to restrict the
network number, node ID, or socket number from which you will accept an openconnection request. When your connection end receives an open-connection request that
meets the restrictions of the filterAddress parameter, it acknowledges the request and
ADSP completes the connection.
You can poll the state field in the CCB to determine when the connection end is waiting
to receive an open-connection request, when the connection end is waiting to receive
an acknowledgment of an open-connection request, and when the connection is open.
(The CCB is described in “The ADSP Connection Control Block” earlier in this

chapter.) Alternatively, you can check the result code for the dspOpen routine when
the routine completes execution. If the routine returns the noErr result code, then the
connection is open.
7. Use the dspRead routine to read data that your connection end has received from
the remote connection end. Use the dspWrite routine to send data to the remote
connection end. Use the dspAttention routine to send attention messages to the
remote connection end.
The dspWrite routine places data in the send queue. ADSP is a full-duplex, symmetric
communications protocol. You can send data at any time, and your connection end can
receive data at any time, even at the same time as you are sending data. ADSP transmits
the data in the send queue when one of the following conditions occurs:
m

You call the dspWrite routine with the flush parameter set to a nonzero number.

a

The number of bytes in the send queue equals or exceeds the blocking factor that
you set with the dspOptions routine.

m

The send timer expires. The send timer sets the maximum amount of time that can
pass before ADSP sends all unsent data in the send queue to the remote connection
end. ADSP calculates the best value to use for this timer and sets it automatically.

=»

A connection event requires that the local connection end send an acknowledgment
packet to the remote connection end.

If you send more data to the send queue than it can hold, the dspWrite routine does not
complete execution until it has written all the data to the send queue. If you execute the
dspWrite routine asynchronously, ADSP returns control to your program and writes the

data to the send queue as quickly as it can. This technique provides the most efficient

use of the send queue by your program and by ADSP. Because ADSP does not remove
data from the send queue until that data has not only been sent but also acknowledged
by the remote connection end, using the flush parameter to the dspWrite routine does
not guarantee that the send queue is empty. You can use the dspStatus routine to

determine how much free buffer space is available in the send queue.

The dspRead routine reads data from the receive queue into your application’s private
data buffer. ADSP does not transmit data until there is space available in the other end’s
receive queue to accept it. Because a full receive queue slows the communications rate,

32-46

= AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

you should read data from the receive queue as often as necessary to keep sufficient
buffer space available for new data. You can use either of two techniques to do this:
a

Allocate a small receive queue (about 600 bytes) and call the dspRead routine
asynchronously. Your completion routine for the dspRead routine should then
call the dspRead routine again.

=

Allocate a large receive queue and call the dspRead routine less frequently.

If there is less data in the receive queue than the amount you specify with the reqCount
parameter to the dspRead command, the command does not complete execution until there
is enough data available to satisfy the request. There are three exceptions to this rule:
m

If the end-of-message bit in the ADSP packet header is set, the dspRead command
reads the data in the receive queue, returns the actual amount of data read in the
actCount parameter, and returns the eom parameter set to 1.

=

If you have closed the connection end before calling the dspRead routine (that is, the
connection is half open), the command reads whatever data is available and returns
the actual amount of data read in the actCount parameter.

m

If ADSP has closed the connection before you call the dspRead routine and there
is no data in the receive queue, the routine returns the noErr result code with the
actCount parameter set to 0 and the eom patameter set to 0.

In addition to the byte-stream data format implemented by the dspRead and dspWrite
routines, ADSP provides a mechanism for sending and receiving control signals or
information separate from the byte stream. You use the dspAttention routine to send
an attention code and an attention message to the remote connection end. When your
connection end receives an attention message, ADSP’s interrupt handler sets the
eAttention flag in the userFlags field of the CCB and calls your user routine. Your
user routine must first clear the userFlags field. Then your routine can read the attention
code and attention message and take whatever action you deem appropriate.
Because ADSP is often used by terminal emulation programs and other applications
that pass the data they receive on to the user without processing it, attention messages
provide a mechanism for the applications that are clients of the connection ends to
communicate with each other. For example, you could use attention messages to
implement a handshaking and data-checking protocol for a program that transfers disk
files between two applications, neither one of which is a file server. Or a database
server on a mainframe computer that uses ADSP to communicate with Macintosh
computer workstations could use the attention mechanism to inform the workstations
when the database is about to be closed down for maintenance.
. When you are ready to close the ADSP connection, you can use the dspClose or
dspRemove routine to close the connection end. Use the dspClose routine if you
intend to use that connection end to open another connection and do not want to
release the memory you allocated for the connection end. Use the dspRemove
routine if you are completely finished with the connection end and want to release
the memory.

AppleTalk Data Stream Protocol(ADSP)

32-47

Inside Macintosh,

Volume V1

You can continue to read data from the receive queue after you have called the dspClose
routine, but not after you have called the dspRemove routine. You can use the dspStatus
routine to determine whether any data is remaining in the receive queue, or you can read

data from the receive queue until both the actCount and eom fields of the dspRead
parameter block return 0.

If you set the abort parameter for the dspClose or dspRemove routine to 0, then ADSP
does not close the connection or the connection end until it has sent—and received
acknowledgment for—all data in the send queue and any pending attention messages.
If you set the abort parameter to 1, then ADSP discards any data in the send queue
and any attention messages that have not already been sent.
After you have executed the dspRemove routine, you can release the memory you
allocated for the CCB and data buffers.
Listing 32-4 illustrates the use of ADSP. This routine opens the .MPP and .DSP drivers

and allocates memory for its internal data buffers, for the CCB, and for the send, receive,

and attention-message buffers. Then the routine uses the dspInit routine to establish a
connection end and uses NBP to register the name of the connection end on the internet.
(The user routine specified by the userRoutine parameter to the dspInit function is shown
in Listing 32-6.) Next, Listing 32-4 uses the dspOptions routine to set the blocking factor
to 24 bytes. The routine uses NBP to determine the address of a socket whose name was
chosen by the user and sends an open-connection request (dspOpen) to that socket. When
the dspOpen routine completes execution, the routine sends data and an attention message
to the remote connection end and reads data from its receive queue. Finally, the routine
closes the connection end with the dspRemove routine and releases the memory it allocated.
Listing 32-4.
PROCEDURE

Using ADSP to establish and use a connection

MyADSP;

CONST

qSize

=

600;

myDataSize

{queue

=

blockFact

=

128;

{size

24;

space}
of

internal

{blocking

factor}

read/write

buffers}

TYPE

{modify
myTRCCB

the
=

connection

control

block

to

add

RECORD

myA5:
u:

LongInt;

TRCCB

END;

VAR

dspSendQPtr:

Ptr;

dspRecvQPtr:
dspAttnBufPtr:
myData2ReadPtr:
myData2WritePtr:

Ptr;
Ptr;
Ptr
Ptr;

myAttnMsgPtr:

PCY?

dspCCB:

my TRCCB;

32-48

= AppleTalk Data Stream Protocol (ADSP)

storage

for

A5}

The AppleTalk Manager

myDSPPBPtr:

DSPPBPtr’:

myMPPPBPtr:

MPPPBPtr;

myNTEName:

NamesTableEntry;

myAddrBlk:

AddrBlock;

drvrRefNum:

Integer;

mppRefNum:

Integer;

connRefNum:

Integer;

gReceivedAnEvent:
myAttnCode:

Boolean;
Integer;

tempFlag:

Byte;

tempCFlag:

Integer;

myErr:

OSErr;

BEGIN

myErr
IF

myErr
IF

:=

OpenDriver('.MPP',

mppRefNum) ;

{open

.MPP

driver}

<>

(myErr)

{check

and

handle

myErr
:=

myErr

noErr

THEN

DoErr

;

OpenDriver('.DSP',

drvrRefNum) ;

{open

.DSP

driver}

<>

(myErr)

{check

and

handle

{allocate

noErr

memory

dspSencQPtr
dspRecvQPtr

dspAttnBufPtr

THEN
for

DoErr

data

;

myDSPPBPtr
myMPPPBPtr
WITH

:=
:=

{ADSP
{ADSP

:= NewPtr(attnBufSize) ;

:=

error}

a)
NSS

tA

buffers}

:= NewPtr(qSize);
:= NewPtr(qSize);

{ADSP

myData2ReadPtr
:= NewPtr(myDataSize);
myData2WritePtr
:= NewPtr(myDataSize) ;

myAttnMsgPtr

error}

use
use

use

beg

only}
only}

=
=

only}

=

Kx
=

NewPtr(myDataSize) ;

fe

DSPPBPtr (NewPtr(SizeOf (DSPParamBlock) ));
MPPPBPtr (NewPtr (SizeOf (MPPParamBlock)
));

myDSPPBPtr~

DO

{set

up

dspInit

{ADSP

driver

S

parameters}

BEGIN

ioCRefNum

:=

esCode

:=

dspInit;

eccbPtr

:=

@dspCCB;

userRoutine
sendQSize

drvrRefNum;

:=

qSize;

sendQueue

:=

dspSendQPtr;

recvQSize

:=

qSize;

recvQueue
:= dspRecvQPtr;
attnPtr
:= dspAttnBufPtr;
:=

to

num}

CCB}

@myConnectionEvtUserRoutine;

:=

localSocket

{pointer

ref

0

{see Listing
32-6}
{size of send queue}
{send-queue
buffer}
{size of receive queue}

{receive-queue

buffer}

{receive-attention

{let

ADSP

assign

buffer}

socket}

END;

gReceivedAnEvent

:= FALSE;
{save A5 for the user routine}
dspCCB.myA5
:= SetCurrentA5;
{establish
a connection
end}
myErr
:= PBControl(ParmBlkPtr(myDSPPBPtr),
FALSE) ;
{check and handle error}
IF myErr <> noErr THEN DoErr (myErr) ;
connRefNum

:=

myDSPPBPtr*.ccbRefNum;

{save

CCB

ref

num

for

later}

(Continued)

AppleTalk Data Stream Protocol (ADSP)

32-49

Inside Macintosh,

Volume V1

Listing 32-4. Using ADSP to establish and use a connection (Continued)
NBPSetNTE(@myNTEName,
'*',

WITH

'The

Object',

'The

|

Type',

myDSPPBPtr®.localSocket) ;

myMPPPBPtr*

{set

DO

up

NBP

names

table

every

7*8=56

{set up PRegisterName
{ parameters}

}

entry}

BEGIN

interval

:=

Count

3%

i=

7;

{retransmit
{and

entityPtr
:= @myNTEName;
verifyFlag
:= 0

retry

3

ticks}

times}

iname to register}
{don't verify this

name}

END;
{register

myErr
IF

this

:=

myErr

WITH

socket}

PRegisterName(myMPPPBPtr,
<>

noErr

THEN

myDSPPBPtr“*

DoErr

FALSE);
{register

(myErr);

{check

DO

{set

this

and

up

socket}

handle

error}

dspOptions

parameters}

BEGIN

ioCRefNum
csCode
:=
ccbRefNum

:= drvrRefNum;
dspOptions;
:= connRefNum;

sendBlocking

:=

{ADSP

blockFact;

driver

ref

num}

{connection

ref

num}

{quantum

badSeqMax
:= 0:
useCheckSum
:= 0

for

data

{use default}
{don't calculate

packet}

checksum}

END;
myErr

:=

PBControl(ParmBlkPtr(myDSPPBPtr),

FALSE);

{set
IF

myErr

<>

noErr

PickASocket
{routine

{
{open
WITH

that
a

THEN

DoErr(myErr);

(myAddrB1lk)

;

using

PLookupName

will

be

the

used

connection

myDSPPBPtr®

with

to

establish

the

chosen

DO

options}

{check

function

an

and

to

open

handle

pick

a

error}

socket

}

connection}

socket}
{set

up

dspOpen

parameters}

BEGIN

ioCRefNum

:=

cesCode
:=
ccbRefNum

dspOpen;
:= connRefNum;

drvrRefNum;

remoteAddress

:=

myAddrBlk;

{ADSP

ocMode

:=

:=

myAddrBlk;

ocRequest;

ociInterval
:= 0;
ocMaximum
:= 0

ref

num}

{connection

ref

{address

remote

{

filterAddress

driver

of

num}

from

PLookupName

{address
{ socket

filter,
address

{open

{use
{use

connection

default
default

socket
specified
only}

mode}

retry
retry

interval}
maximum}

END;

myErr

:=

PBControl

(ParmBlkPtr(myDSPPBPtr),

{open
IF

32-50

myErr

<>

noErr

THEN

DoErr(myErr);{check

AppleTalk Data Stream Protocol (ADSP)

FALSE);

a

connection}
and

handle

}

function}

error}

}

The AppleTalk Manager

{the
{

connection

the

WITH

send

with

queue

the

exactly

myDSPPBPtr®

chosen

socket

myDataSize

is

open,

so

of

bytes}

number

DO

{set

up

now

dspWrite

send

to

}

parameters}

BEGIN

ioCRefNum

:=

csCode
:=
ccbRefNum

dspWrite;
:= connRefNum;

{connection

ref

reqCount

:=

{write

number

GataPtr
eom

:=

:=

flush

drvrRefNum;

{ADSP

myDataSize;

myData2WritePtr;

1;
:=

1

driver

ref

this

{pointer

to

{1

last

means

num}
num}

send

of

byte

{

end-of-message}

{l

means

send

bytes}

queue}
is

logical

data

now}

the

remote

handle

error}

}

END;
myErr

:=

PBControl(ParmBlkPtr(myDSPPBPtr),

FALSE);

{send
{
IF

myErr

<>

noErr

{now

send

WITH

myDSPPBPtr®*

BEGIN

an

THEN

attention

data

DoErr(myErr);{check
message

to

the

DO

ioCRefNum

:=

csCode
:=
ccbRefNum

dspAttention;
:= connRefNum;

drvrRefNum;

to

}

connection}
and

remote

connection

{set

up

{ADSP

driver

dspAttention

{connection

attnCode

:=

0;

{user-defined

attnSize

:=

myDataSize;

{length

attnData

:=

myAttnMsgPtr

{attention

of

ref

Oe

end}

1S

parameters}

num}

ref

©,

num}

attention

attention

J
2

code}

5

message}

=

message}

e

END;

myErr
IF

:=

myErr

PBControl(ParmBlkPtr(myDSPPBPtr),

FALSE);

<>

and

noErr

{Now

read

{ of
WITH

bytes. }
myDSPPBPtr*

from

BEGIN
ioCRefNum
csCode :=
ccbRefNum
reqCount
dataPtr

the

DoErr(myErr);{check

receive

queue

exactly

DO

up

parameters}

dspRead

{ADSP

:=

{connection

connRefNum;

driver

{read

myData2ReadPtr

error}

number

{set

myDataSize;

handle

myDataSize

:= drvrRefNum;
dspRead;
:=

:=

THEN

this

{pointer

ref
ref
number

to

read

}

num}
num}
of

bytes}

buffer}

END;

myErr

IF

:=

myErr

<>

noErr

done

with

the

myDSPPBPtr*

DO

{we're
WITH

PBControl(ParmBlkPtr(myDSPPBPtr),
{read
THEN

FALSE);
data
from

{ connection}
DoErr(myErr);{check
and handle

connection,

so

remove

it}

{set

dspRemove

up

the

remote

}

error}

parameters}

BEGIN

ioCRefNum
csCode
:=

:= drvrRefNum;
dspRemove;

{ADSP

driver

ref

>

=

num}

(Continued)

AppleTalk Data Stream Protocol (ADSP)

— 32-51

Inside Macintosh,

Volume

Listing 32-4.
ccbRefNum

abort

:=

VI

Using ADSP to establish and use a connection (Continued)

:=

{connection
ref num}
{don't
close
until 1 everything
{ is sent
and received}

connRefNum;

0

}

END;

myErr
IF

:=

PBControl(ParmBlkPtr(myDSPPBPtr),

myErr

{close
(myErr)
; {check

{you're

<>

noErr

THEN

DOErr

done

with

this

connection,

so

give

FALSE) ;

and

remove

the

and

handle

error}

connection}

back

the

memory}

DisposPtr(dspSendQPtr) ;
DisposPtr(dsoRecvOPtr) ;
DisposPtr(dspAttnBufFtr) ;
DisposPtr(myData2ReadPtr) ;

DisposPtr(myData2WritePtr);
DisposPtr (myAttnMsgPtr) ;
DisposPtr(Ptr(myDSPPBPtr));
DisposPtr(Ptr(myMPPPBPtr) )
END;

{MyADSP}

Creating

and

Using

a Connection

Listener

A connection listener is a special sort of AppleTalk Data Stream Protocol (ADSP) connection

end that cannot receive or transmit data streams or attention messages. The sole function of a
connection listener is to wait passively to receive an open-connection request and to inform its
client, the connection server, when it receives one. The connection server can then accept or
deny the open-connection request. If it accepts the request, the connection server selects a
socket to use as a connection end, establishes a connection end on that socket, and sends an
acknowledgment and connection request back to the requesting connection end. The connection server can use the same socket as it used for the connection listener or can select a
different socket as the connection end.
Use the following procedure to establish a connection listener and to use that connection
listener to open a connection with a remote connection end:
|. Use the MPPOpen function to open the .MPP driver and then use the OpenDriver
function to open the .DSP driver. The OpenDriver function returns the reference
number for the .DSP driver. You must supply this reference number each time you
call the .DSP driver.
2. Allocate nonrelocatable memory for a connection control block (CCB). (The CCB is
described in “The ADSP Connection Control Block” earlier in this chapter.) A connection listener does not need send and receive queues or an attention-message buffer. The
memory that you allocate becomes the property of ADSP when you call the dspCLInit
routine to establish a connection listener. You cannot write any data to this memory
except by calling ADSP, and you must ensure that the memory remains locked until you
call the dspRemove routine to eliminate the connection end. The CCB is 242 bytes.
3. Call the dspCLInit routine to establish a connection listener. You must provide a pointer
tothe CCB,
32-52.

AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

If there is a specific socket that you want to use for the connection listener, you can
specify the socket number in the localSocket parameter. If you want ADSP to assign
the socket for you, specify 0 for the localSocket parameter. ADSP returns the socket
number when the dspCLInit routine completes execution.
. If you wish, you can use the NBPRegister function to add the name and address of
your connection listener to the node’s names table. The
NBPRegister function is
described in the AppleTalk Manager chapter of Volume II.
. Use the dspCLListen routine to cause the connection listener to wait for an openconnection request. Because the dspCLListen routine does not complete execution
until it receives a connection request, you should call this routine asynchronously.
You can specify a value for the filterAddress parameter to restrict the network number,
node ID, or socket number from which you will accept an open-connection request.
When the dspCLListen routine receives an open-connection request that meets the restrictions of the filterAddress parameter, it returns a noErr result code (if you executed the
routine asynchronously, it places a noErr result code in the ioResult parameter) and
places values in the parameter block for the remoteCID, remoteAddress, sendSeq,
sendWindow, and attnSendSeq parameters.
. If you want to open the connection, call the dspInit routine to establish a connection
end. You can use any available socket on the node for the connection end, including the
socket that you used for the connection listener. Because a single socket can have more
than one CCB connected with it, the socket can function simultaneously as a connection
end and a connection listener.
You can check the address of the remote socket to determine if it meets your criteria for
a connection end. Although the filterAddress parameter to the dspCLListen routine
provides some screening of socket addresses, it cannot check for network number
ranges, for example, or for a specific set of socket numbers. If for some reason you
want to deny the connection request, call the dspDeny routine, specifying the CCB of
the connection listener in the ccbRefNum parameter. Because the dspCLListen routine
completes execution when it receives an open-connection request, you must return to
step 5 to wait for another connection request.
. Call the dspOpen routine to open the connection. Specify the value ocAccept for the
ocMode parameter and specify in the ccbRefNum parameter the reference number of
the CCB for the connection end that you want to use. When you call the dspOpen
routine, you must provide the values returned by the dspCLListen routine for the
remoteCID, remoteAddress, sendSeq, sendWindow, and attnSendSeq parameters.
You can poll the state field in the CCB to determine when the connection is open.
Alternatively, you can check the result code for the dspOpen routine when the routine
completes execution. If the routine returns the noErr result code, then the connection
is open.
. You can now send and receive data and attention messages over the connection, as

described in the preceding section, “Opening and Maintaining an ADSP Connection.”
When you are ready to close the connection, you can use the dspClose or dspRemove
routines, which are also described in the preceding section.

AppleTalk Data Stream Protocol (ADSP)

32-53

a)
N
>

“|
43
—
=
os
©.

<

f

—

re
@

y

Inside Macintosh,

Volume VI

9. When you are finished using the connection listener, you can use the dspCLRemove
routine to eliminate it. Once you have called the dspCLRemove routine, you can release
the memory you allocated for the connection listener’s CCB.
Listing 32-5 illustrates the use of ADSP to establish and use a connection listener. It opens
the .MPP and .DSP drivers and allocates memory for the CCB. Then it uses the dspCLInit
routine to establish a connection listener, uses the Name-Binding Protocol (NBP) to register
the name of the connection end on the internet, and uses the dspCLListen routine to wait for
a connection request. When the routine receives a connection request, it calls the dspOpen
routine to complete the connection.

Listing 32-5. Using ADSP to establish and use a connection listener
VAR
dspCCBPtr:
myDSPPBPtr:

TPCCB?
DSPPBPtr:

myMPPPBPtr:

MPPPBPtr;

myNTEName:

NamesTableEntry;

drvrRefNum:
mopRefNum:

Integer;
Integer;

connRefNum:

Integer;

myErr:

OSErr;

BEGIN
myErr
IF

:=

OpenDriver('.MPP',

mppRefNum) ;

{

open

.MPP

<>

(myErr)

{check

and

myErr

myErr
:=
IF myErr

noErr

THEN

DoErr

;

OpenDriver('.DSP',
drvrRefNum);
<> noErr THEN DoErr (myErr) ;

{allocate

memory

dspCCBPtr

:=

for

data

{open
.DSP
{check and

driver
handle

driver}
handle
error}

buffers}

TPCCB(NewPtr(SizeOf(TRCCB)
));

myDSPPBPtr

:=

DSPPBPtr(NewPtr
(SizeOf (DSPParamBlock) ));

mMyMPPPBPtr

:=

MPPPBPtr(NewPtr(SizeOf

WITH

}
error}

myDSPPBPtr”*

DO

(MPPParamBlock)
{set

up

));

dspCLInit

parameters}

BEGIN

ioCRefNum

:=

csCode

dspCLinit;

:=

drvrRefNum;

{ADSP

ccbPtr
:= dspCCBPtr;
localSocket
:= 0

driver

ref

num}

{pointer to CCB}
{local socket number}

END;

myErr

:=

PBControl(ParmBlkPtr(myDSPPBPtr),
FALSE);
{establish a connection
listener}
IF myErr
<> noErr THEN DoErr(myErr);{check
and handle
error}
connRefNum
:= myDSPPBPtr®.ccbRefNum;
{save CCB ref num for
later}

NBPSetNTE(@myNTEName,
'*')
WITH

32-54

myMPPPBPtr*

'The

Object',

'The

Type',

myDSPPBPtr®.localSocket) ;
DO

{set
{set

AppleTalk Data Stream Protocol (ADSP)

up
up

NBP names
table entry}
PRegisterName
parameters}

The AppleTalk Manager

BEGIN
interval

:=

7;

Gount
<= 3;
entityPtr
:=

verifyFlag

{retransmit

@myNTEname;

:=

every

7*8=56

ticks}

{and retry
3 times}
{mame to register}

0

{don't

verify

this

name}

END;

myErr

:=

PRegisterName(myMPPPBPtr,

FALSE);

{register
IF

myErr

WITH

<>

noErr

THEN

myDSPPBPtr*

DoErr(myErr);{check

DO

{set

this

and

up

name}

handle

error}

dspCLListen

parameters}

BEGIN
ioCRefNum

:=

csCode

dspCLListen;

:=

drvrRefNum;

{ADSP

ccbRefNum
:= connRefNum;
filterAddress
:= AddrBlock(0)

driver

ref

num}

{connection
ref num}
{connect with anybody}

END;
myErr

:=

PBControl(ParmBlkPtr(myDSPPBPtr),

TRUE);

{listen
WHILE

myDSPPBPtr*.ioResult

=

1

for

connection

requests}

DO

oe
—

—_

—

{return
a

control

to

connection

user

while

waiting

for

@

}

=as
ad

—
~

request}

GoDoSomething;

—
—

END;
IF

nN

<)

BEGIN
{

‘ad

pe)
—

myErr

<>

noErr

THEN

DoErr(myErr);{check

and

handle

—

tS)

error}

i=

a")

or |

{You

{ The

received

{

remoteCID,

{

and

WITH

a

connection

dspCLListen

call

has

remoteAddress,

attnSendSeq

fields

myDSPPBPtr*

of

request;

now

returned

values

sendSeq,
the

open

connection.

the

sendWindow,

}

parameter

DO

a

into

{set

}

}

block. }
up

dspOpen

parameters}

BEGIN

ioCRefNum

:=

csCode
:=
ccbRefNum

dspOpen;
:= connRefNum;

drvrRefNum;

{ADSP

driver

{connection

ref
ref

num}
num}

ocMode
:= ocAccept;
ocInterval
:= 0;

{open connection mode}
{use default
retry
interval}

ocMaximum

{use

:=

0

default

retry

maximum}

END;

myErr
IF

:=

myErr

{Listing
END;

PBControl(ParmBlkPtr(myDSPPBPtr),
<>

noErr

32-4

shows

THEN

how

DoErr(myErr)

to

use

ADSP

FALSE);

{open a connection}
{check and handle
error}

to

maintain

a

connection. }

{MyCLADSP}

AppleTalk Data Stream Protocol(ADSP)

— 32-55

Inside Macintosh,

Volume

V1

Writing a User Routine for Connection

Events

When you execute the dspInit routine, you can specify a pointer to a routine that you provide
(referred to as the user routine). Whenever an unsolicited connection event occurs, the

AppleTalk Data Stream Protocol (ADSP) sets a flag in the connection control block (CCB)
and calls the user routine. The user routine must clear the flag to acknowledge that it has read
the flag field, and then can respond to the event in any manner you deem appropriate. The
CCB flags are described in “The ADSP Connection Control Block” earlier in this chapter.
The four following types of unsolicited connection events set flags in the CCB:
= ADSP has been informed by the remote connection end that the remote connection end
is about to close the connection. An appropriate reponse might be to store a flag
indicating that the connection end is about to close. When your application regains
control, it can then display a dialog box informing the user of this event and asking
whether the application should attempt to reconnect later.
a ADSP has determined that the remote connection end is not responding and so has
closed the connection. Your user routine can attempt to open a new connection
immediately. Alternatively, you can store a flag indicating that the connection has
closed, and when your application regains control, it can display a dialog box asking
the user whether to attempt to reconnect.
mw ADSP has received an attention message from the remote connection end. Depending on
what you are using the attention-message mechanism for, you might want to read the
attention code in the attnCode field of the CCB and the attention message pointed to by
the attnPtr field of the CCB.
mw ADSP has received a forward reset command from the remote client end, has discarded
all ADSP data not yet delivered, including the data in the receive queue of the local client
end, and has resynchronized the connection. Your response to this event depends on the
purpose for which you are using the forward reset mechanism. You might want to
resend the last data you have sent or inform the user of the event.
When ADSP calls your user routine, the CPU is in interrupt-processing mode and register A |
contains a pointer to the CCB of the connection end that generated the event. You can examine
the userFlags field of the CCB to determine what event caused the interrupt. and you can
examine the state field of the CCB to determine the current state of the connection.
Because the CPU is set to interrupt-processing mode, your user routine must preserve all
registers other than AO, Al, DO, D1, and D2. Your routine must not make any direct or
indirect calls to the Memory Manager and can’t depend on handles to unlocked blocks being
valid. If you want to use any of your application’s global variables, you must save the
contents of the A5 register before using the variables, and you must restore the A5 register
before your routine terminates. Listings 32-4 and 32-6 illustrate the use of the CCB to store
the pointer to your application’s global variables.
If you want to execute a routine each time an unsolicited connection event occurs but the
interrupt environment is too restrictive, you can specify a NIL pointer to the user routine and
periodically poll the userFlags field of the CCB.
A

32-56

Warning: When an unsolicited connection event occurs, you must clear the bit
in the userFlags field to 0 or the connection will hang. To ensure that you do not
lose any attention messages, you must read any attention messages into an internal
buffer before you clear the bit in the userFlags field. a
AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

Listing 32-6 is the user routine called by Listing 32-4. When this routine is called, it first
checks the CCB to determine the source of the interrupt and then clears the bit in the
userFlags field of the CCB. If the routine has received an attention message, the user
routine reads the message into an internal buffer before it clears the flag bit. The definitions
of procedures PushA5, GetMyTRCCBAS, and PopAS are shown in Listing 32-6 for
your convenience. In a complete application these procedures would be defined in the

calling routine (Listing 32-4).

Listing 32-6.
PROCEDURE

{moves

$2F0D;

{MOVE.L

GetMyTRCCBA5;

{Retrieves

A5

from

{

to

by

INLINE

$2A69,

SFFFC;

current

value

of

A5

onto

stack}

head

of

the

sticks

it

A5,-(SP) }

(pointed

{MOVE.L

-4(Al1),

PROCEDURE

PopA5;

{restores

INLINE

S$2A5F;

{MOVE.L

PROCEDURE

user routine

PushA5;

INLINE

PROCEDURE

An ADSP

A5

the

Al)

and

TRCCB

}

in

A5.}

Find

out

A5}

from

(SP)+,

stack}

A5}

myConnectionEvtUserRoutine;

BEGIN

{The

connection

received

{ what

kind

process

and

an

unexpected

PushaA5;

{save

GetMyTRCCBA5;

{set

{
WITH

dspCCB.u

connection

event.

}

accordingly.}
the
up

global

current

A5

to

A5}

point

to

your

application's

}

variables}

DO

BEGIN
IF

BAND(userFlags,

eClosed)

IF

BAND(userFlags,

eTearDown)

<>

0

THEN

TellUserItsBroken;

IF

BAND(userFlags,

eFwdReset)

<>

0

THEN

TellUserItsReset;

IF

BAND(userFlags,

eAttention)

BEGIN

{the

event

is

<>

an

0

<>

THEN

0

THEN

attention

myAttnCode
:= AttnCode;
CopyAttnMsg(AttnPtr,
AttnSize,

TellUserItsClosed;

message}

{Get the
@myAttnData);

attention

{copy
the
{ message
tempFlag
:= userFlags;
tempCFlag
:= eAttention;
BClr(LongIint (tempFlag),
userFlags
:= tempFlag
{do something with
the

tempCFlag);

{clear

code. }

attention
}
into our buffer}

the

flag}

message}

END;

gReceivedAnEvent

:=

TRUE

END;

PopA5

{restore

the

current

A5}

END;

AppleTalk Data Stream Protocol (ADSP)

— 32-57

Inside Macintosh, Volume VI

.DSP

Driver

Routines

The .DSP driver implements the AppleTalk Data Stream Protocol (ADSP). You send
commands to ADSP and obtain information about ADSP by executing the .DSP driver
routines described in this section. Each routine is implemented as a call to the Device
Manager’s PBControl function, as follows:
FUNCTION

PBControl

(paramBlock:

ParmBlkPtr;

async:

Boolean)

:

OSErr;

The paramBlock parameter is a pointer to the parameter block used by the PBControl function

for .DSP routines, and the async parameter is a Boolean that specifies whether the function is

to execute synchronously or asynchronously. Set the async parameter to TRUE to execute the
function asynchronously.
The parameter block is shown in “The .DSP Parameter Block” earlier in this chapter. The
parameters used with each function are described in this section.
For a general discussion of the use of ADSP, see “Using ADSP” earlier in this chapter.

Establishing

and Terminating

an ADSP

Connection

You can use the routines described in this section to

m establish a connection end
m set the values for parameters that control the behavior of a connection end
m Open a connection
m assign an identification number to a connection end
m= close a connection end

w eliminate a connection end
dspInit
Parameter block
&16

32-58

ioResult

word

result code

—

24

ioCRefNum

word

driver reference number

>

26

csCode

word

always dspInit

—

32

ccbRefNum

word

reference number of CCB

~

34

ccbPtr

long

pointer to CCB

-

38

userRoutine

long

~

42

sendQSize

word

pointer to routine to call on
connection events
size in bytes of the send queue

~

4-4

sendQueue

long

pointer to send queue

AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

>

48

recvQSize

word

size in bytes of the receive queue

—

50

recvQueue

long

pointer to receive queue

>

54

attnPtr

long

pointer to buffer for incoming

o

58

localSocket

byte

attention messages

DDP socket number for this

connection end

The dspInit routine establishes a connection end; that is, it assigns a specific socket for use by
ADSP and initializes the variables that ADSP uses to maintain the connection. The dspInit
routine does not open the connection end or establish a connection with a remote connection
end; you must follow the dspInit routine with the dspOpen routine to perform those tasks.
Use the dspCLInit routine to establish a connection listener. Use the dspRemove routine to
eliminate a connection end.
When you send bytes to a remote connection end, ADSP stores the bytes in a buffer called
the send queue. Until the remote connection end acknowledges their receipt, ADSP keeps
the bytes you sent in the send queue so that they are available to be retransmitted if necessary.
When the local connection end receives bytes, it stores them in a buffer called the receive
queue until you read them.

©

~~

<
A

$9
=

Note: When you call the dspInit routine, the memory that you allocate becomes the
property of ADSP. You cannot write any data to this memory except by calling ADSP
routines, and you must ensure that the memory remains locked until you call the
dspRemove routine to eliminate the connection end.
descriptions

ioResult

The result of the routine. When you execute the routine asynchronously, the routine sets this parameter to | and returns a routine
result of noErr as soon as the routine begins execution. When the
routine completes execution, it sets the ioResult parameter to the
actual result code.

ioCRefNum

The driver reference number. This parameter is returned by the
OpenDriver function. You must specify this number every time
you call the .DSP driver.

csCode

The routine selector, always equal to dspInit for this routine.

ccbRefNum

The CCB reference number. The dspInit routine returns this number.
You must provide this number in all subsequent calls to this
connection end.

ccbPtr

A pointer to the CCB that you allocated. The CCB is 242 bytes in size
and is described in “The ADSP Connection Control Block” earlier in

this chapter.

AppleTalk Data Stream Protocol(ADSP)

>

<—)
SS

es,4

You must allocate memory for the send and receive queues and for a buffer that holds
incoming attention messages. You must also allocate a nonrelocatable block of memory
for the CCB for this connection end.

Field

as)
NS)

— 32-59

EY
re
iS

Inside Macintosh,

Volume VI

userRoutine

A pointer to a routine that is to be called each time the connection end
receives an unsolicited connection event. Specify NIL for this parameter if you do not want to supply a user routine. Connection events
and user routines are discussed in “Writing a User Routine for
Connection Events” earlier in this chapter.

sendQSize

The size in bytes of the send queue. A queue size of 600 bytes should
work well for most applications. If you are using ADSP to send a
continuous flow of data, a larger data buffer improves performance.
If your application is sending the user’s keystrokes, a smaller buffer
should be adequate. The constant minDSPQueueSize indicates the
minimum queue size that you can use.

sendQueue

A pointer to the send queue that you allocated.

recvQSize

The size in bytes of the receive queue. A queue size of 600 bytes
should work well for most applications. If you are using ADSP to
receive a continuous flow of data, a larger data buffer improves
performance. If your application is receiving a user’s keystrokes, a
smaller buffer should be adequate. The constant minDSPQueueSize
indicates the minimum queue size that you can use.

recvQueue

A pointer to the receive queue that you allocated.

attnPtr

A pointer to the attention-message buffer that you allocated. The
attention-message buffer must be the size of the constant attnBufSize.

localSocket

The DDP socket number of the socket that you want ADSP to use for
this connection end. Specify 0 for this parameter to cause ADSP to
assign the socket. In the latter case, ADSP returns the socket number
when the dspInit routine completes execution.

Result codes
noErr
ddpSktErr
errDSPQueueSize

Q

~91
-1274

Noerror
_ Error opening socket
Send or receive queue is too small

dspOptions
Parameter block
e
=>

16

ioResult

word

result code

24

ioCRefNum

word

~
>

26
32

csCode
ccbRefNum

word

driver reference number
always dspOptions

word

=>

34

sendBlocking

word

reference number of CCB
send-blocking threshold

—>

38

badSeqMax

byte

>

39

threshold to send retransmit advice

useCheckSum

byte

DDP checksum flag

The dspOptions routine allows you to set values for several parameters that affect the behavior
of the local connection end. You can set the options for any established connection end,
whether open or not.
32-60

AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

descriptions

ioResult

The result of the routine. When you execute the routine asynchronously, the routine sets this parameter to | and returns a routine
result of noErr as soon as the routine begins execution. When the
routine completes execution, it sets the ioResult parameter to the
actual result code.

ioCRefNum

The driver reference number. This parameter is returned by the
OpenDriver function. You must specify this number every time
you call the .DSP driver.

csCode

The routine selector, always equal to dspOptions for this routine.

ccbRefNum

The CCB reference number that was returned by the dspInit routine.

sendBlocking

The maximum number of bytes that may accumulate in the send queue
before ADSP sends a packet to the remote connection end. ADSP
sends a packet before the maximum number of bytes accumulates if
the period specified by the send timer expires, if you execute the
dspWrite routine with the flush parameter set to 1, or if a connection
event requires that the local connection end send an acknowledgment
packet to the remote connection end.
You can set the sendBlocking parameter to any value from | byte to
the maximum size of a packet (572 bytes). If you set the sendBlocking
parameter to O, the current value for this parameter is not changed. The
default value for the sendBlocking parameter is 16 bytes.

badSeqMax

The maximum number of out-of-sequence data packets that the local
connection end can receive before requesting the remote connection
end to retransmit the missing data. Because a connection end does not
acknowledge the receipt of a data packet received out of sequence, the
retransmit timer of the remote connection end will expire eventually
and the connection end will retransmit the data. The badSeqMax
parameter allows you to cause the data to be retransmitted before the
retransmit timer of the remote connection end has expired.
You can set the badSeqMax parameter to any value from | to 255.
If you set the badSeqMax parameter to 0, the current value for this
parameter is not changed. The default value for the badSeqMax parameter is 3.

useCheckSum

A flag specifying whether DDP should compute a checksum and include
it in each packet that it sends to the remote connection end. Set this
parameter to | if you want DDP to use checksums or to 0 if you do not
want DDP to use checksums. The default value for useCheckSum is 0.
ADSP cannot include a checksum in a packet that has a short DDP
header—that is, a packet being sent over LocalTalk to a remote socket
that is on the same cable as the local socket. Note that the useCheckSum
parameter affects only whether ADSP includes a checksum in a packet
that it is sending. If ADSP receives a packet that includes a checksum,
it validates the checksum regardless of the setting of the useCheckSum
parameter.

AppleTalk Data Stream Protocol(ADSP)

32-61

ce

Field

>
—

Swe

a=)
—
@

a

ts]
—

a
A

re

pe)

=)
+)

ve

oe
“

Inside Macintosh,

Result codes

noErr
errRefNum

Volume VI

0
—1280

No error
Bad connection reference number

dspOpen
Parameter block
on
16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

always dspOpen

>

32

ccbRefNum

word

reference number of CCB

—

34

localCID

word

ID of this connection end

o

36

remoteCID

word

ID of remote connection end

oO

38

remoteAddress

long

remote internet address

~

42

filterAddress

long

filter for open-connection requests

o

46

sendSeq

long

initial send sequence number

oO

50

sendWindow

word

initial size of remote receive queue

aa

52

recvSeq

long

initial receive sequence number

o

56

attnSendSeq

long

attention send sequence number

~

60

attnRecvSeq

long

attention receive sequence number

>

64

ocMode

byte

connection-opening mode

>

65

ocInterval

byte

interval between open requests

>

66

ocMaximum

byte

retries of open-connection request

You use the ocMode field of the parameter block to specify the opening mode that the
dspOpen routine is to use. The dspOpen routine puts a connection end into one of the
four following opening modes:
m The ocRequest mode, in which ADSP attempts to open a connection with the socket at
the internet address you specify with the remoteAddress parameter. If the socket you
specify as a remote address is a connection listener, it is possible that your application
will receive a connection acknowledgment and request from a different address than
the one to which you sent the open-connection request. You can use the filterAddress
parameter to restrict the addresses with which you will accept a connection.
The dspOpen routine completes execution in the ocRequest mode when one of the following occurs: ADSP establishes a connection, your connection end receives a connection
denial from the remote connection end, your connection end denies the connection request
returned by a connection listener, or ADSP cannot complete the connection within the
maximum number of retries that you specified with the ocMaximum parameter.
ms The ocPassive mode, in which the connection end waits to receive an open-connection
request from a remote connection end. You can use the filterAddress parameter to
restrict the addresses from which you will accept a connection request.
The dspOpen routine completes execution in the ocPassive mode when ADSP

establishes a connection or when either connection end receives a connection denial.

32-62

AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

uw The ocAccept mode, used by connection servers to complete an open-connection dialog.
When a connection server is informed by its connection listener that the connection listener
has received an open-connection request, the connection server calls the dspInit routine to
establish a connection end and then calls the dspOpen routine in ocAccept mode to complete the connection. You must obtain the following parameters from the dspCLListen
routine and provide them to the dspOpen routine: remoteAddress, remoteCID, sendSeq,
sendWindow, and attnSendSeq. Connection listeners and connection servers are described
in “Creating and Using a Connection Listener” earlier in this chapter and in “Establishing
and Terminating an ADSP Connection” later in this chapter.
The dspOpen routine completes execution in the ocAccept mode when ADSP establishes
a connection or when either connection end receives a connection denial.

m The ocEstablish mode, in which ADSP considers the connection end established and the
connection state open. This mode is for use by clients that determine their connectionopening parameters without using ADSP or the .DSP driver to do so.
You must first use the dspInit routine to establish a connection end and then execute the

dspNewCID routine to obtain an identification number (ID) for the local connection end.

You must then communicate with the remote connection end to send it the local connection ID and to determine the values of the following parameters: remoteAddress,
remoteCID, sendSeq, sendWindow, recvSeq, attnSendSeq, and attnRecvSeq. Only
then can you execute the dspOpen routine in the ocEstablish mode.

The dspOpen routine completes execution in the ocEstablish mode immediately.

ioCRefNum

—

ioCRefNum

—

csCode

—

csCode

—

ccbRefNum

—

ccbRefNum

<

localCID

<

localCID

localCID

<

remoteCID

<

remoteCID

remoteCID

—

remoteAddress

<< _ remoteAddress

—

filterAddress

—

filterAddress

filterAddress

<

sendSeq

<

sendSeq

sendSeq

<

sendWindow

<

sendWindow

—

recvSeq

—

recvSeq

recvSeq

<

attnSendSeq

<

attnSendSeq

attnSendSeq

—

attnRecvSeq

—

attnRecvSeq

attnRecvSeq

—

ocMode

—

ocMode

ocMode

—

oclnterval

—

oclnterval

—

ocMaximum

—

ocMaximum

Key:

— input

€output

—

csCode
ccbRefNum

remoteAddress

ocInterval
ocMaximum

bbb

sendWindow

| be

Lib?
LT
Lt
L
Lid

ioCRefNum

T

—

ioResult

bob

10Result

Lb

<

ocEstablish

| + J

ioResult

—

ia]
—
S

—
po)
—

a

pa]
ve
is)

ar |

+

<

ocAccept

>,
a
—
—_
—
—_

~~
a

executed, as follows:

ocPassive

nN

—-

The use of parameters by the dspOpen routine depends on the mode in which the routine is
ocRequest

os)

ioResult
ioCRefNum
csCode
ccbRefNum
localCID

remoteCID
remoteAddress
filterAddress
sendSeq
sendWindow
recvSeq
attnSendSeq
attnRecvSeq
ocMode
ocInterval

ocMaximum

not used

AppleTalk Data Stream Protocol (ADSP)

32-63

Inside Macintosh,

Field

Volume VI

descriptions

ioResult

The result of the routine. When you execute the routine asynchronously, the routine sets this parameter to | and returns a routine
result of noErr as soon as the routine begins execution. When the
routine completes execution, it sets the ioResult parameter to the
actual result code.

ioCRefNum

The driver reference number. This parameter is returned by the
OpenDriver function. You must specify this number every time
you call the .DSP driver.

csCode

The routine selector, always equal to dspOpen for this routine.

ccbRefNum

The CCB reference number that was returned by the dspInit routine
for the connection end that you want to use.

localCID

The identification number of the local connection end. This number is
assigned by ADSP when the connection is opened. ADSP includes
this number in every packet sent to a remote connection end. Before
you call the dspOpen routine in ocEstablish mode, you must call the
dspNewCID routine to cause ADSP to assign this value.

remoteCID

The identification number of the remote connection end. This parameter is returned by the dspOpen routine in the ocRequest and ocPassive
modes. A connection server must provide this number to the dspOpen
routine when the server executes the routine in ocAccept mode: in this
case, the connection server obtains the remoteCID value from the
dspCLListen routine. You must provide the remoteCID value to the
dspOpen routine when you use the routine in ocEstablish mode.

remoteAddress

The internet address of the remote socket with which you wish to
establish communications. This address consists of a 2-byte network
number, a |-byte node ID, and a |-byte socket number. You must
provide this parameter when you call the dspOpen routine in the
ocRequest or ocEstablish mode. This parameter is returned by the
dspOpen routine when you call the routine in the ocPassive mode.
When you call the dspOpen routine in the ocAccept mode, you must
use the value for the remoteAddress parameter that was returned by
the dspCLListen routine.

filterAddress

The internet address of the socket from which you will accept a
connection request. The address consists of three fields: a 2-byte
network number, a 1-byte node ID, and a |-byte socket number.
Specify O for any of these fields for which you wish to impose no
restrictions. If you specify a filter address of $00082500, for example,
the connection end accepts a connection request from any socket at
node $25 of network $0008. Set the filterAddress parameter equal to
the remoteAddress parameter to accept a connection only with the
socket to which you sent a connection request.
When you execute the dspOpen routine in the ocPassive mode, you
can receive a connection request from any ADSP connection end on
the internet. When you execute the dspOpen routine in the ocRequest
mode, your connection end can receive a connection request acknowledgment from an address different from the one you specified in the

32-64

= AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

remoteAddress parameter only if the remote address you specified was
that of a connection listener. In either case, you can use the filterAddress
parameter to avoid acknowledging unwanted connection requests.
When you execute the dspOpen routine in the ocAccept mode, your
connection listener has already received and decided to accept the
connection request. You can specify a filter address for a connection
listener with the dspCLListen routine. A connection server can use
the dspCLDeny routine to deny a connection request that was accepted
by its connection listener.
You cannot use the filter address when you execute the dspOpen
routine in ocEstablish mode.
sendSeq

sendWindow

The sequence number of the first byte that the local connection end
will send to the remote connection end. ADSP uses this number to
coordinate communications and to check for errors. ADSP returns
a value for the sendSeq parameter when you execute the dspOpen
routine in the ocRequest or ocPassive mode. When you execute the
dspOpen routine in the ocAccept mode, you must specify the value
for the sendSeq parameter that was returned by the dspCLListen
routine. You must provide the value for this parameter when you
execute the dspOpen routine in the ocEstablish mode.
The sequence number of the last byte that the remote connection end
has buffer space to receive. ADSP uses this number to coordinate
communications and to check for errors. ADSP returns a value for
the sendWindow parameter when you execute the dspOpen routine
in the ocRequest or ocPassive mode. When you execute the dspOpen
routine in the ocAccept mode, you must specify the value for the
sendWindow parameter that was returned by the dspCLListen routine.
You must provide the value for this parameter when you execute the
dspOpen routine in the ocEstablish mode.

recvSeq

The sequence number of the next byte that the local connection end
expects to receive. ADSP uses this number to coordinate communications and to check for errors. You must provide the value for this
parameter when you execute the dspOpen routine in the ocEstablish
mode. The dspOpen routine does not use this parameter when you
execute it in any other mode.

attnSendSeq

The sequence number of the next attention packet that the local
connection end will transmit. ADSP uses this number to coordinate
communications and to check for errors. ADSP returns a value for the
attnSendSeq parameter when you execute the dspOpen routine in the
ocRequest or ocPassive mode. When you execute the dspOpen routine
in the ocAccept mode, you must specify the value for the attnSendSeq
parameter that was returned by the dspCLListen routine. You must
provide the value for this parameter when you execute the dspOpen
routine in the ocEstablish mode.

attnRecvSeq

The sequence number of the next attention packet that the local
connection end expects to receive. ADSP uses this number to
coordinate communications and to check for errors. You must
provide the value for this parameter when you execute the dspOpen
routine in the ocEstablish mode. The dspOpen routine does not use
this parameter when you execute it in any other mode.
AppleTalk Data Stream Protocol (ADSP)

— 32-65

Fe)
NS}
>

<=)

ee
@

|
$9
=

a—

f9
=
fs
re
©
“

Inside Macintosh, Volume VI

The mode in which the dspOpen routine is to operate, as follows:

ocMode

Mode

Value

Meaning

ocRequest

|

ADSP attempts to open a connection with
the socket you specify.

ocPassive

2

The connection end waits to receive a
connection request.

ocAccept

3

The connection server accepts and
acknowledges receipt of a connection
request.

ocEstablish

4

ADSP considers the connection established

and open; you are responsible for setting up
and synchronizing both connection ends.

The period between transmissions of open-connection requests. If
the remote connection end does not acknowledge or deny an openconnection request, ADSP retransmits the request after a time period
specified by this parameter. The time period used by ADSP is

ocInterval

(ocInterval x 10) ticks, or (ocInterval / 6) seconds. For example,

if you set the ocInterval parameter to 3, the time period between

retransmissions is 30 ticks (1/2 second). You can set the ocInterval
parameter to any value from | (1/6 second) to 180 (30 seconds). If

you specify 0 for the ocInterval parameter, ADSP uses the default
value of 6 (1 second).

You must provide a value for the ocInterval parameter when you
execute the dspOpen routine in the ocRequest, ocPassive, or
ocAccept mode. The dspOpen routine does not use this parameter
when you execute it in the ocEstablish mode.
ocMaximum

The maximum number of times to retransmit an open-connection
request before ADSP terminates execution of the dspOpen routine.
If you specify 0 for the ocMaximum parameter, ADSP uses the
default value of 3. If you specify 255 for the oceMaximum parameter,
ADSP retransmits the open-connection request indefinitely until the
remote connection end either acknowledges or denies the request.
You must provide a value for the oceMaximum parameter when you
execute the dspOpen routine in the ocRequest, ocPassive, or ocAccept
mode. The dspOpen routine does not use this parameter when you
execute it in the ocEstablish mode.

Result codes
noErr

errOpenDenied
errOpening
errState
errAborted
errRefNum

32-66

QO
Noerror
—1273
Open request denied by recipient
—1277
Attempt to open connection failed
—1278
Connection end must be closed
—1279 — Request aborted by dspRemove or dspClose routine
—1280
Bad connection reference number

AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

dspNewCID
Parameter block
—
16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

always dspNewCID

->

32

ccbRefNum

word

reference number of CCB

—

34

newCID

word

ID of new connection

The dspNewCID routine causes ADSP to assign an ID to a connection end without opening
the connection end or attempting to establish a connection with a remote connection end. Use
this routine only if you implement your own protocol to establish communication with a
remote connection end. You must first use the dspInit routine to establish a connection end.
Next, you must call the dspNewCID routine to obtain a connection-end ID. Then you must
establish communication with a remote connection end and pass the ID to the remote connection end. Finally, you must call the dspOpen routine in ocEstablish mode to cause ADSP to
open the connection. See the description of the dspOpen routine for more information on
establishing a connection in this fashion.
The ioResult parameter returns the result of the routine. If you call the routine asynchronously,
the routine sets this field to 1 as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The ioCRefNum parameter is the driver
reference number returned by the OpenDriver function. You must specify this number every
time you call the .DSP driver. The csCode parameter is the routine selector; it is always
dspNewCID for this routine. The ccbRefNum parameter is the CCB reference number that
was returned by the dspInit routine. The newCID parameter is the connection-end ID returned
by this routine. You must provide this number to the client of the remote connection end so
that it can use it for the remoteCID parameter when it calls the dspOpen routine.
Result codes
noErr

0)

errState

errRefNum

—1278

—1280

No error

Connection is not closed

Bad connection reference number

dspClose
Parameter block
—

16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

always dspClose

=)

32

ccbRefNum

word

reference number of CCB

>

34

abort

byte

abort send requests if not 0

The dspClose routine closes the connection end. The connection end is still established; that
is, ADSP retains ownership of the CCB, send queue, receive queue, and attention-message
buffer. You can continue to read bytes from the receive queue after you have called the
dspClose routine. Use the dspRemove routine instead of the dspClose routine if you are
AppleTalk Data Stream Protocol(ADSP)

— 32-67

\o*)
No

>

<=)

gos
oe

_

=)

=

=

&
ge
a0)
Ler |

Inside Macintosh,

Volume VI

through reading bytes from the receive queue and want to release the memory associated
with the connection end. The dspClose routine does not return an error if you call it for a
connection end that is already closed.
The ioResult parameter returns the result of the routine. If you call the routine asynchronously,
the routine sets this field to | as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The ioCRefNum parameter is the driver
reference number returned by the OpenDriver function. You must specify this number
every time you call the .DSP driver. The csCode parameter is the routine selector; it is
always dspClose for this routine. The ccbRefNum parameter is the CCB reference number
that was returned by the dspInit routine. If the abort parameter is nonzero, ADSP cancels any
outstanding requests to send data packets (such as the dspAttention routine) and discards all
data in the send queue. If the abort parameter is 0, ADSP does not close the connection end

until all of the data in the send queue and all outstanding attention messages have been sent

and acknowledged.
Result codes
noErr
errRefNum

0
—1280

No error
Bad connection reference number

dspRemove
Parameter block

om

16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

always dspRemove

—

32

ccbRefNum

word

reference number of CCB

>

34

abort

byte

abort connection if not 0

The dspRemove routine closes any open connection and eliminates the connection end; that
is, ADSP no longer retains control of the CCB, send queue, receive queue, and attentionmessage buffer. You cannot continue to read bytes from the receive queue after you have
called the dspRemove routine. After you call the dspRemove routine, you can release all of
the memory you allocated for the connection end if you do not intend to reopen the connection end.
The ioResult parameter returns the result of the routine. If you call the routine asynchronously, the routine sets this field to 1 as soon as it begins execution, and it changes the field
to the actual result code when it completes execution. The ioCRefNum parameter is the
driver reference number returned by the OpenDriver function. You must specify this number
every time you call the .DSP driver. The csCode parameter is the routine selector, always
dspRemove for this routine. The ccbRefNum parameter is the CCB reference number that
was returned by the dspInit routine. If the abort parameter is nonzero, ADSP cancels any
outstanding requests to send data packets (such as the dspAttention routine) and discards all
data in the send queue. If the abort parameter is 0, ADSP does not close the connection end
until all of the data in the send queue has been sent and acknowledged.

32-68

| AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

Result codes
noErr
errRefNum

Establishing

0
—1280

No error
Bad connection reference number

and Terminating

an ADSP

Connection

Listener

A connection listener is a special kind of connection end that listens for open-connection
requests from remote connection ends. Connection listeners are used by connection
servers—that is, programs that assign a socket for the local connection end only after they
receive a connection request from a remote connection end. A single connection listener can
receive connection requests from any number of remote connection ends.
You can use the routines in this section to
m establish a connection listener
m cause the connection listener to wait for a connection request

Ge
NS)

m deny aconnection request
=

=
”.

got

close and eliminate a connection listener

Ss

©.

a

dspCLInit

2

o>
=}
f>
ve
o
=

—

Parameter block

oo

16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

always dspCLInit

—

32

ccbRefNum

word

reference number of CCB

>

34

ccbPtr

long

pointer to CCB

oO

58

localSocket

byte

local DDP socket number

The dspCLInit routine establishes a connection listener; that is, it assigns a specific socket for
use by ADSP and initializes the variables that ADSP uses to maintain a connection listener.
The dspCLInit routine does not cause the connection listener to listen for connection requests;
you must follow the dspCLInit routine with the dspCLListen routine to activate the connection
listener. Use the dspInit routine to establish a connection end that is not a connection listener.
Use the dspCLRemove routine to eliminate a connection listener.
The ioResult parameter returns the result of the routine. If you call the routine asynchronously,
the routine sets this field to 1 as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The ioCRefNum parameter is the driver
reference number returned by the OpenDriver function. You must specify this number every
time you call the .DSP driver. The csCode parameter is the routine selector, always dspCLInit
for this routine. The dspCLInit routine returns the ccbRefNum parameter, which is the CCB
reference number. You must provide this number in all subsequent dspCLListen and
dspCLRemove calls to this connection listener.

AppleTalk Data Stream Protocol(ADSP)

— 32-69

Inside Macintosh,

Volume

VI

You must allocate memory for a CCB before you call the dspCLInit routine. The ecbPtr
parameter is a pointer to the CCB that you allocated. The CCB is 242 bytes in size and is
described in “The ADSP Connection Control Block” earlier in this chapter.
The localSocket parameter is the DDP socket number of the socket that you want ADSP to
use for this connection end. Specify 0 for this parameter to cause ADSP to assign the socket.
In the latter case, ADSP returns the socket number when the dspCLInit routine completes
execution.
Result codes

noErr
ddpSktErr

-9]

0

No error
Error opening socket

dspCLListen
Parameter block
—
16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

=

26

csCode

word

always dspCLListen

>

32

ccbRefNum

word

reference number of CCB

e

36

remoteCID

word

ID of remote connection end

+

38

remoteAddress

long

remote internet address

>

42

filterAddress

long

filter for open-connection requests

on

46

sendSeq

long

initial send sequence number

<-

50

sendWindow

word

initial size of remote receive queue

—

56

attnSendSeq

long

attention send sequence number

The dspCLListen routine causes a connection listener to listen for connection requests. You
must have already used the dspCLInit routine to establish a connection listener before using
the dspCLListen routine. The dspCLListen routine is used only by connection servers.
When ADSP receives an open-connection request from a socket that satisfies the address
requirements of the filterAddress parameter, it returns values for the remoteCID,
remoteAddress, sendSeq, sendWindow, and attnSendSeq parameters and completes
execution of the dspCLListen routine. You must then either accept the open-connection
request by calling the dspOpen routine in the ocAccept mode or deny the request by
calling the dspCLDeny routine.
You can call the dspCLListen routine several times, specifying the same connection listener.
For example, if you wanted to accept connections from any or all of three different addresses,
you could call the dspCLListen routine three times with a different value for the filterAddress
parameter each time. Note that you must execute the dspCLListen routine asynchronously to
take advantage of this feature.

32-70

~~ AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

Field

descriptions

ioResult

The result of the routine. When you execute the routine asynchronously,
the routine sets this parameter to | and returns a routine result of noErr
as soon as the routine begins execution. When the routine completes
execution, it sets the ioResult parameter to the actual result code.

ioCRefNum

The driver reference number. This parameter is returned by the
OpenDriver function. You must specify this number every time
you call the .DSP driver.

csCode

The routine selector, always dspCLListen for this routine.

ccbRefNum

The CCB reference number that was returned by the dspCLInit
routine.

remoteCID

The identification number of the remote connection end. You must
pass this value to the dspOpen routine when you open the connection
or to the dspCLDeny routine when you deny the connection request.

remoteAddress

The internet address of the remote socket that sent a request to open
a connection. This address consists of a 2-byte network number, a
l1-byte node ID, and a |-byte socket number. You must pass this value
to the dspOpen routine when you open the connection or to the
dspCLDeny routine when you deny the connection request.

filterAddress

The internet address of the socket from which you will accept a connection request. The address consists of three fields: a 2-byte network
number, a l-byte node ID, and a |-byte socket number. Specify 0 for
any of these fields for which you wish to impose no restrictions. If you
specify a filter address of $00082500, for example, the connection
listener accepts a connection request from any socket at node $25 of
network $0008.

sendSeq

The sequence number of the first byte that the local connection end
will send to the remote connection end. ADSP uses this number to
coordinate communications and to check for errors. You must pass
this value to the dspOpen routine when you open the connection.

sendWindow

The sequence number of the last byte that the remote connection end
has buffer space to receive. ADSP uses this number to coordinate
communications and to check for errors. You must pass this value to
the dspOpen routine when you open the connection.

attnSendSeq

The sequence number of the next attention packet that the local
connection end will transmit. ADSP uses this number to coordinate
communications and to check for errors. You must pass this value
to the dspOpen routine when you open the connection.

Result codes

noErr
errState

0
—1278

No error
Not a connection listener

errRefNum

—1280

Bad connection reference number

errAborted

—1279

Request aborted by the dspRemove routine

AppleTalk Data Stream Protocol (ADSP)

— 32-71

a)
NS)
>
—

i

ia)

a,

=
~
ra
Z
=
&
go
o

ms

“

Inside Macintosh,

Volume

V1

dspCLDeny
Parameter block
on
16

ioResult

word

result code

=>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

always dspCLDeny

>

32

ccbRefNum

word

reference number of CCB

=

36

remoteCID

word

ID of remote connection end

>

38

remoteAddress

long

remote internet address

The dspCLDeny routine is used by a connection server to inform a remote connection end
that its request to open a connection cannot be honored.
The ioResult parameter returns the result of the routine. If you call the routine asynchronously,
the routine sets this field to 1 as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The ioCRefNum parameter is the driver
reference number returned by the OpenDriver function. You must specify this number
every time you call the .DSP driver. The csCode parameter is the routine selector; it is always
dspCLDeny for this routine. The ccbRefNum parameter is the CCB reference number for
the connection listener that received the connection request. This number is returned
by the dspCLInit routine when you establish a connection listener. The remoteCID and
remoteAddress parameters specify the address and ID of the remote connection end. These
parameters are returned by the dspCLListen routine.
Result codes
noErr
errState

errAborted

errRefNum

0
—1278

No error
Not a connection listener

—1280

Bad connection reference number

—1279

Request aborted by the dspRemove routine

dspCLRemove
Parameter block
e-

16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

=>

26

csCode

word

always dspCLRemove

=>

32

ccbRefNum

word

reference number of CCB

—>

34

abort

byte

abort connection listener if not 0

The dspCLRemove routine closes a connection end used as a connection listener. You
can release the memory you allocated for the CCB if you do not intend to reopen the
connection end.
The ioResult parameter returns the result of the routine. If you call the routine asynchronously,
the routine sets this field to | as soon as it begins execution, and it changes the field to
the actual result code when it completes execution. The ioCRefNum parameter is the
32-72

AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

driver reference number returned by the OpenDriver function. You must specify this number
every time you call the .DSP driver. The csCode parameter is the routine selector, always
dspCLRemove for this routine. The ccbRefNum parameter is the CCB reference number that
was returned by the dspCLInit routine. If the abort parameter is nonzero, ADSP cancels any
outstanding requests to send packets (such as the dspCLDeny routine).
Result codes
noErr
errRefNum

Maintaining

@)
—1280

No error
Bad connection reference number

an ADSP

Connection

Once you have established a connection end and opened a connection, you must be able to
send and receive data over the connection. You can use the routines in this section to

ms determine the status of a connection
a

N

m read bytes from the connection end’s receive queue

>

<~)
i=]—

m write bytes to the connection end’s send queue and transmit them to the remote
connection end

)
a=
—

ps

m send an attention message to the remote connection end

2
$9
=
$s
or)
o
™
—

w discard all data that has been sent but not yet delivered, and reset the connection
dspStatus
Parameter block
—
16

ioResult

word

result code

~

24

ioCRefNum

word

driver reference number

~

26

csCode

word

always dspStatus

=>

32

ccbRefNum

word

reference number of CCB

—

34

statusCCB

long

pointer to CCB

<—

38

sendQPending

word

—

40

sendQFree

word

bytes waiting to be sent or
acknowledged
available send queue in bytes

—

42

recvQPending

word

bytes waiting to be read from queue

eH

44

recvQFree

word

available receive queue in bytes

The dspStatus routine returns the number of bytes waiting to be read and sent and the space
available in the send and receive queues. This routine also returns a pointer to the CCB,
which contains information about the state of the connection end and about connection events
received by the connection end. The CCB is described in “The ADSP Connection Control
Block” earlier in this chapter.

AppleTalk Data Stream Protocol (ADSP)

— 32-73

Inside Macintosh,

Volume VI

The ioResult parameter returns the result of the routine. If you call the routine asynchronously,
the routine sets this field to | as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The ioCRefNum parameter is the driver
reference number returned by the OpenDriver function. You must specify this number every
time you call the .DSP driver. The csCode parameter is the routine selector: it is always
dspStatus for this routine. The ccbRefNum parameter is the CCB reference number that was
returned by the dspInit routine. The statusCCB parameter returns a pointer to the CCB.
The sendQPending parameter indicates the number of bytes of data in the send queue,
including | byte for each end-of-message (EOM) indicator in the send queue. (ADSP
counts | byte for each EOM, even though no actual data corresponds to the EOM indicator.)
The send queue contains all data that has been sent to ADSP for transmission and that
has not yet been acknowledged. Some of the data in the send queue might have already
been transmitted, but ADSP retains it in the send queue until the remote connection end

acknowledges its receipt in case the data has to be retransmitted. The sendQFree parameter
indicates the number of bytes available in the send queue for additional data.
The recvQPending parameter indicates the number of bytes in the receive queue, including
1 byte for each EOM if the EOM bit is set in an ADSP packet header. The receive queue
contains all of the data that has been received by the connection end but not yet read by the
connection end’s client. The reevQFree parameter indicates the number of bytes available
in the receive queue for additional data.
Result codes

noErr
errRefNum

0
—1280

No error
Bad connection reference number

dspRead
Parameter block
on
16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

always dspRead

—

32

ccbRefNum

word

reference number of CCB

>

34

reqCount

word

requested number of bytes

<

36

actCount

word

actual number of bytes read

>

38

dataPtr

long

pointer to data buffer

<—

42

eom

byte

| if end-of-message; 0 otherwise

The dspRead routine reads bytes from the connection end’s receive queue and places them
in a buffer that you specify. You can continue to read bytes as long as data is in the receive
queue, even after you have called the dspClose routine or after the remote connection end has
called the dspClose or dspRemove routine. The dspRead routine completes execution when it
has read the number of bytes you specify or when it encounters an end-of-message (that is,
the last byte of data in an ADSP packet that has the EOM bit set in the packet header).
You can call the dspStatus routine to determine the number of bytes remaining to be read
from the read queue, or you can continue to call the dspRead routine until the actCount
and eom parameters both return 0.
32-74

= AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

The ioResult parameter returns the result of the routine. If you call the routine asynchronously,
the routine sets this field to | as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The ioCRefNum parameter is the driver
reference number returned by the OpenDriver function. You must specify this number every
time you call the .DSP driver. The csCode parameter is the routine selector; it is always
dspRead for this routine. The ccbRefNum parameter is the CCB reference number that was
returned by the dspInit routine.
You specify the number of bytes to read with the reqCount parameter, and you use the dataPtr
parameter to provide a pointer to the buffer into which ADSP should place the data. ADSP
returns the actual number of bytes read in the actCount parameter. If the last byte read
constitutes an EOM, ADSP sets the eom parameter to 1.
If either end closes the connection before you call the dspRead routine, the command reads
whatever data is available and returns the actual amount of data read in the actCount
parameter. If the connection is closed and there is no data in the receive queue, the dspRead
routine returns the noErr result code with the actCount parameter set to 0 and the eom
parameter set to 0.
Result codes
noErr
errFwdReset
errState
errAborted
errRefNum

0
-—1275
—1278
—1279
—1280

4
=
=
aE
<
=I

No error
Read terminated by forward reset
State isn’t open, closing, or closed
Request aborted by dspRemove or dspClose routine
Bad connection reference number

72

dspWrite
Parameter block
16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

always dspWrite

~

32

ccbRefNum

word

reference number of CCB

>

34

reqCount

word

requested number of bytes

-

36

actCount

word

actual number of bytes written

~

38

dataPtr

long

pointer to data buffer

~

42

eom

byte

| if end-of-message; 0 otherwise

>

43

flush

byte

| to send data now; 0 otherwise

The dspWrite routine writes bytes into the connection end’s send queue. The send queue
contains all data that has been sent to ADSP for transmission and that has not yet been
acknowledged. Some of the data in the send queue might have already been transmitted,
but ADSP retains it in the send queue until the remote connection end acknowledges its
receipt in case the data has to be retransmitted. The dspWrite routine completes execution
when it has copied all of the data from the data buffer into the ADSP send queue.

AppleTalk Data Stream Protocol (ADSP)

NS

— 32-75

Inside Macintosh,

Volume VI

ADSP transmits the data in the send queue when the remote connection end has room to
accept the data and one of the following conditions occurs:
m You call the dspWrite routine with the flush parameter set to a nonzero number.
= The number of bytes in the send queue equals or exceeds the blocking factor. (You use
the sendBlocking parameter to the dspOptions routine to set the blocking factor.)
m The send timer expires.
= A connection event requires that the local connection end send an acknowledgment
packet to the remote connection end.
The ioResult parameter returns the result of the routine. If you call the routine asynchronously,
the routine sets this field to | as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The ioCRefNum parameter is the driver

reference number returned by the OpenDriver function. You must specify this number every

time you call the .DSP driver. The csCode parameter is the routine selector; it is always
dspWrite for this routine. The ccbRefNum parameter is the CCB reference number that was
returned by the dspInit routine.

You specify the number of bytes to write with the reqCount parameter, and you use the dataPtr
parameter to provide a pointer to the buffer from which ADSP should read the data. The
dspWrite routine returns the actual number of bytes written in the actCount parameter. If
the last byte written constitutes an EOM, set the eom parameter to 1. You can also set the
reqCount parameter to 0 and the eom parameter to | to indicate that the last byte you sent the
previous time you called the dspWrite routine was the end of the message. The high-order bits
of the eom parameter are reserved for use by ADSP; you must leave these bits equal to 0.
You can set the reqCount parameter to a value larger than the size of the send queue. If you
do so, the dspWrite routine writes as much data as it can into the send queue, sends the data
and waits for acknowledgment, and then writes more data into the send queue until it has
written the amount of data you requested. In this case, the routine does not complete execution until it has finished writing all of the data into the send queue.
Set the flush parameter to | to cause ADSP to immediately transmit any data in the send
queue that has not already been transmitted. Set the flush parameter to 0 to allow data to
accumulate in the send queue until another condition occurs that causes data to be transmitted.
The high-order bits of the flush parameter are reserved for use by ADSP; you must leave
these bits equal to 0.
Result codes
noErr

errState
errAborted

errRefNum

32-76

0

—1278
—-—1279
—1280

No error

Connection is not open
Request aborted by dspRemove or dspClose routine
Bad connection reference number

= AppleTalk Data Stream Protocol (ADSP)

The AppleTalk Manager

dspAttention
Parameter block
—

16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

always dspAttention

=

32

ccbRefNum

word

reference number of CCB

—>

34

attnCode

word

client attention code

=>

36

attnSize

word

size of attention data in bytes

aaa

38

attnData

long

pointer to attention data

The dspAttention routine sends an attention code and an attention message to the remote
connection end. Attention codes and attention messages can have any meaning that your
application and the application at the remote connection end both recognize. The purpose
of attention codes and messages is to allow clients of ADSP to send messages outside the
normal data stream. For example, if a connection end on a mainframe computer is connected
to several connection ends in Macintosh computers being used as remote terminals, the
mainframe computer might wish to inform the remote terminals that all connections will be
terminated in ten minutes. The mainframe application could send an attention message to each
of the remote terminals informing them of this fact, and the terminal emulation programs in
the Macintosh computers could then display an alert message on the screen so that the users
could prepare to shut down.
The ioResult parameter returns the result of the routine. If you call the routine asynchronously,
the routine sets this field to | as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The ioCRefNum parameter is the driver
reference number returned by the OpenDriver function. You must specify this number every
time you call the .DSP driver. The csCode parameter is the routine selector; it is always
dspAttention for this routine. The ccbRefNum parameter is the CCB reference number that
was returned by the dspInit routine.
The attnCode parameter is the attention code that you wish to send to the remote connection
end. You can use any value from $0000 through $EFFF for the attention code. The values
$FO00 through $FFFF are reserved for use by ADSP. The attnSize parameter is the size in
bytes of the attention message you wish to send, and the attnData parameter provides a
pointer to the attention message. The attention message can be any size from 0 through 570
bytes. There are no restrictions on the content of the attention message.
Result codes

noErr
errAttention
errState
errAborted
errRefNum

0
-—1276
—1278
—1279
-—1280

No error
Attention message too long
Connection is not open
Request aborted by dspRemove or dspClose routine
Bad connection reference number

AppleTalk Data Stream Protocol(ADSP)

— 32-77

Ge
i)
>.
~~

—

i

—

—
@

al

=

~~

a

—

Sy)

=

i)
tj)
ic)

os |

Inside Macintosh,

Volume

VI

dspReset
Parameter block
—
16

ioResult

word

result code

—

24

ioCRefNum

word

driver reference number

2

26

csCode

word

always dspReset

>

32

ccbRefNum

word

reference number of CCB

The dspReset routine causes ADSP to discard all data in the send queue, all data in transit to

the remote connection end, and all data in the remote connection end’s receive queue that the

client has not yet read. This process is known as a forward reset. ADSP then resynchronizes
the connection. You can determine that your connection end has received a forward reset and
has discarded all data in the receive queue by checking the eFwdReset flag in the userFlags
field of the CCB. The CCB is described in “The ADSP Connection Control Block” earlier in
this chapter.
The ioResult parameter returns the result of the routine. If you call the routine asynchronously,
the routine sets this field to 1 as soon as it begins execution, and it changes the field to the
actual result code when it completes execution. The ioCRefNum parameter is the driver
reference number returned by the OpenDriver function. You must specify this number every
time you call the .DSP driver. The csCode parameter is the routine selector; it is always
dspReset for this routine. The ccbRefNum parameter is the CCB reference number that was
returned by the dspInit routine.
Result codes

THE

noErr
errState
errAborted
errRefNum

0
—1278
-—1279
—-1280

.ENET

DRIVER

No error
Connection is not open
Request aborted by dspRemove or dspClose routine
Bad connection reference number

The .ENET driver is normally called by the AppleTalk Manager through the AppleTalk
connection file for EtherTalk when the user has selected EtherTalk from the Network
control panel. You can write your own protocol stack or application that uses the .ENET
driver directly, rather than through AppleTalk. This section describes how to open the
-ENET driver, how to send data to it directly for transmission over the Ethernet network,
and how to write a protocol handler to receive data from the network.

The system .ENET driver locates and opens the drivers for installed NuBus™ Ethernet cards.

For each Ethernet NuBus card, the .ENET driver searches the open resource files for a driver
with a resource type of ‘enet' and a resource ID equal to the board ID of the NuBus card. If
it doesn’t find such a driver resource, it then looks for a driver named .ENET in the slot
resources in the ROM of the NuBus card. See Designing Cards and Drivers for the Macintosh
Family, second edition, for discussions of NuBus board IDs and slot resources.

32-78

The .ENET

Driver

The AppleTalk Manager

Providing

Your Own

Ethernet

Driver

If you write an Ethernet driver for use with your own Ethernet NuBus card, you should
provide the features and functions described in this chapter. You can store the driver in the
firmware of the NuBus card as described in Designing Cards and Drivers for the Macintosh
Family, second edition, and in the Device Manager chapter of Inside Macintosh, Volume V, or
you can provide a RAM-based driver as described in the Device Manager chapter of Inside
Macintosh, Volume II. If you place your Ethernet driver in the ROM of the NuBus card, you
must name the driver .ENET. If you provide a RAM-based driver, you must give it a resource
type of 'enet' and a resource ID equal to the board ID of your NuBus card. The 'enet' resource
type is identical to the 'DRVR' resource type described in the Device Manager chapter of
Volume II.
Note: You must vot name a RAM-based driver .ENET, because doing so would
replace the system .ENET driver.
If you write an Ethernet driver for use with a non-NuBus network interface (such as an
Ethernet card for the Macintosh SE/30 or an Ethernet connection through the SCSI port),
you should provide the features and functions described in this chapter for the .ENET
driver and should name your driver .ENETO. If you do so, any software written to use
the .ENET driver should work with your driver.

aN
>

Ss
Ace
©,

Se.

2

ny

Changing

the Ethernet

Hardware

<—

Address

au

Each Ethernet NuBus card or other Ethernet hardware interface device contains a unique
6-byte hardware address assigned by the manufacturer of the device. The .ENET driver
normally uses this address to determine whether to receive a packet. To change the hardware
address for your node, place in the System file a resource of type 'eadr' with a resource ID
equal to the slot number of the Ethernet NuBus card. If the Ethernet device is not a NuBus
card (it might be a slot card in a Macintosh SE/30, for example), use a resource ID of 0.
The ‘eadr' resource consists only of a 6-byte number. Do not use the broadcast address or a
multicast address for this number. (The broadcast address is $FF-FF-FF-FF-FF-FF.

A

multicast address is any Ethernet address in which the low-order bit of the high-order byte is
set to 1.) When you open the .ENET driver, it looks for an 'eadr' resource. If it finds one,

the driver substitutes the number in this resource for the Ethernet hardware address and uses
it until the driver is closed or reset.
Note: To avoid address collisions, you should never arbitrarily change the Ethernet
hardware address. This feature should be used only by a system administrator who
can keep track of all the Ethernet addresses in the system.

Opening

the

.ENET

Driver

Before you use the OpenSlot function to open the .ENET driver, you must determine which
NuBus slots contain EtherTalk cards. The OpenSlot function is described in the Device Manager
chapter of Volume V. Use the SGetTypeSRsrc function described in the Slot Manager chapter
of this volume to determine which NuBus slots contain EtherTalk cards. To find EtherTalk

The .ENET Driver

32-79

=
s

ga
@
“

Inside Macintosh,

Volume VI

NuBus cards, use the value catNetwork in the field spCategory of the GetTypeSRsrc function
parameter block, and use the value typeEtherNet in the field spCType. If you cannot find any
EtherTalk NuBus cards, you should also attempt to open the .ENETO driver in case a nonNuBus EtherTalk card is attached to the system. You should provide a user interface that allows

the user to select a specific EtherTalk card in the case that more than one is present.

Listing 32-7 illustrates the use of the GetTypeSRsrc function and the OpenSlot function to
open the .ENET driver.
Listing 32-7. Finding an EtherTalk card and opening the .ENET driver
VAR
mySBlk:

SpBlock;

my PBRec:

ParamBlockRec;

myErr:

OSErr;

Found:

Integer;

EnetStr:
EnetOStr:

Str15;
Stx15;

myRefNum:

Integer;

BEG IN
Found

:=

-=

EnetOStr

:=

WITH

{assume

0;

EnetStr

no

sResource

found}

'.ENET';
'.ENETO';

mySBlik

DO

BEGIN

spParamData

:=

1;

{include
{
{

spCategory

:=

spCType

typeEtherNet;

:=

spDrvrSwW

:=

0;

spDrvrHwW

:=

0;

spTBMask

:=

3;

spSlot
SpID
:=

:= 0;
0;

SpExtDev

:=

search

of

Start
searching
the slots above

disabled

resources.

from spSlot
and
it as well.}

catNetwork;

0

{match

only

{start
{start

search
search

{ID,

the

of

Category
from
from

and

CType

fields}

here}
here}

external

device}

END;
REPEAT

myErr
IF

:=

myErr

{You

SGetTypeSRsrc
=

found

BEGIN
Found

noErr

an
:=

sResource

Found

(@mySB1k)

32-80

The .ENET

=

+

match;

1;

smNoMoresRsrcs;

Driver

;

THEN

SaveSInfo(@mySB1k)
END;
UNTIL myErr

search

save

it

for

later. }

}
}

The AppleTalk Manager

IF

Found

>

1

THEN

BEGIN

{If

you

{

and

{

found

found

more

than

the

user

choose

let

were

disabled,

DisplaySInfo

one
let

sResource,

one.

If

any

the

user

put

up

of

the

know

they

dialog

box

sResources

a

you

are

not

}
}

available.}

(@mySBLk)

END;

IF

Found

<>

Q

THEN

BEGIN

WITH

myPBRec

DO

BEGIN
ioCompletion

:=

ioNamePtr

@EnetStr;

ioMix

:=

:=

ioFlags
ioSlot

10ID

:=

:=

NIL;

NIL;

{reserved}

:=

{single

0;

device

sResource}

mySBlk.spSlot;

mySBlk.spID

NS

END;

END

myErr

ELSE

END;

IF

>

:=

myErr

myErr

OpenSlot
:=

<>

(@myPBRec,

FALSE)

OpenDriver(EnetOStr,

NoErr

THEN

DoError

{go

open

this}

cS

©.

myRefNum);

J

(myErr)

a

|
@

Using

a Write-Data

Structure to Transmit

Ethernet

ar

Data

When you use the EWrite function to send data to the .ENET driver for transmission over the
Ethernet network, you provide a pointer to a write-data structure (Figure 32-5). A write-data
structure contains a series of pairs of length words and pointers. Each pair indicates the length
and location of a portion of the data that constitutes the packet to be sent over the network.
The first length-pointer pair points to a 14-byte header block, which starts with the destination
node hardware address. Note that this is not the AppleTalk address, but is the hardware
address of the destination node. If you are calling the .ENET driver directly, you must obtain
the Ethernet address of the destination node yourself; AppleTalk cannot provide it.
The next 6 bytes of the header block are reserved for use by the .ENET driver. These bytes
are followed by the 2-byte Ethernet protocol type. Data may follow the header block; all other
length-pointer pairs point to data. The write-data structure terminates with a 0 word.
When you first open the .ENET driver, it allocates a 768-byte buffer that it uses for transmitting data packets. This buffer is large enough to hold the largest EtherTalk packet, which
is 621 bytes in size. If you want to transmit data packets larger than 768 bytes, call the
ESetGeneral function. The .ENET driver then allocates a large enough data buffer to send
packets up to 1514 bytes in size.

The .ENET Driver

32-81

Inside Macintosh,

Volume VI

Length of first entry
(word)
Pointer to first entry
(long)

Destination node ID
(6 bytes)

Length of second
entry (word)

Reserved for use by
driver (6 bytes)

Pointer to second
entry (long)

'- Header
block

Protocol type
(word)

Length of last
entry (word)

Data

Pointer to last

entry (long)

DN

0
(word)

Data

Figure 32-5.

An Ethernet write-data structure

Listing 32-8 defines an Ethernet write-data structure and then calls the EWrite function to
send a data packet over Ethernet.
Listing 32-8.

Sending a data packet over Ethernet

CONST

sizel

=

100%

size2

=

333%

WDS

=

RECORD

TYPE
{write-data
structure}
{length
of nth entry}

length:
Integer;
aptrs
Ptr

{pointer

to

nth

entry}

END;

VAR
myWDS

:

ARRAY[1..4]

my PB:

EParamBlock;

wheader:
stuff 1:
stuff 2:
myErr é

ARRAY[1..14]

32-82

OF

{.ENET
OF

ARRAY[(1..sizel]
ARRAY[1..size2]
OSErr;

The .ENET

Driver

WDS;

Byte;
OF
OF

Byte;
Byte;

parameter

block}

The AppleTalk Manager

BEGIN
{set

up

the

write

header}

wheader[1]
wheader[2]

:=
:=

$02;
$60;

wheader[3]

:=

$8C;

wheader[4]

:=

$04;

wheader[5]

:=

$05;

wheader[6]

:=

$06;

wheader[13]
wheader[14]

:=
:=

{dest

myWDS[1].length
:= 14;
myWDS[1].aptr
:= @wheader;
myWDS[2].aptr

:=
:=

myWDS[3].length
myWDS[3].aptr
myWDS[4].length
myPB.ePointer
myErr

END;

IF

:=

myErr

header

is

always

14

bytes}

sizel;
size2;
0;

@myWDS;

{pointer
FALSE);

<>

DoError

THEN

p
{terminator}

EWrite(@myPB,
NoErr

write

@stuff2;
:=

:=

{the

reserved}

@stuffl1;
:=

:=

ID}

{bytes
7-12
are
{protocol
type}

$08;
$00;

myWDS[2].length

node

Using the Default Ethernet

{send

to

Ns}
write-data

Ls

structure}

3.

something}

=

(myErr)

Protocol

=

=

Handler to Read

=
ie
@

ar

Data

When the EtherTalk NuBus card or other Ethernet hardware receives a data packet, it
generates an interrupt to the CPU. The interrupt handler in ROM determines the source of
the interrupt and calls the .ENET driver. The .ENET driver reads the packet header to
determine the protocol type of the data packet and checks to see if any client has specified
that protocol type in a call to the EAttachPH function. If so, the client either specified a NIL
pointer to a protocol handler, or the client provided its own protocol handler. If the client
specified a NIL pointer, the .ENET driver uses its default protocol handler to read the data.
If no one has specified that protocol type in a call to the EAttachPH function, the .ENET
driver discards the data. The EAttachPH function ts described in “Attaching and Detaching
an Ethernet Protocol Handler” later in this chapter.
The default protocol handler checks for an ERead function pending execution and places the
entire packet— including the packet header—into the buffer specified by that function. The
function returns the number of bytes actually read. If the packet is larger than the data buffer,
the ERead function places as much of the packet as will fit into the buffer and returns the
buf2SmallErr result code.
Call the ERead function asynchronously to await the next data packet. When the .ENET
driver receives the data packet, it completes execution of the ERead function and calls your
completion routine. Your completion routine should call the ERead function again so that an
ERead function is always pending execution. If the .ENET driver receives a data packet with
a protocol type for which you specified the default protocol handler while no ERead function
is pending, the .ENET driver discards the packet.

The .ENET Driver

32-83

Inside Macintosh,

Volume

VI

You can have several asynchronous calls to the ERead function pending execution simultaneously as long as you use different buffers and a different parameter block for each call.
Listing 32-9 calls the EAttachPH function to specify that the .ENET driver should use the
default protocol handler to process protocol type eProtType. The listing includes a completion
routine that processes a received data packet and then makes an asynchronous call to the
ERead function to await the next incoming data packet.
In practice, you should call the EAttachPH function very early, during your program initialization sequence, if possible. As soon as the connection is established and you are expecting
data, you should call the ERead function asynchronously. When the .ENET driver receives
a packet, it then calls your completion routine, which should process the packet and queue
another asynchronous call to the ERead function to await the next packet.
Listing 32-9.

Using the default Ethernet protocol handler to read data

CONST
BigBytes

=

8888;

my PB:

EParamBlock;

EPBPtr:
APtr:

EParamBlkPtr;
Ptr;

myErr:

OSErr’

VAR

PROCEDURE

MyCompRoutine;

VAR
myErr:

OSErr;

BEGIN

{If this gets called,
{ type
is here. }

an

incoming

ProcessData(BigBytes,
APtr);
IF EPBPtr*.ioResult
<> noErr
{call

ERead

again}

WITH

EPBPtr*

DO

packet

THEN

with

the

specified

{do something
DoError (myErr) ;

{set

up

ERead

with

protocol

the

data}

parameters}

BEGIN

ioCompletion

:=

eProtType

77;

{protocol

APtr;

{pointer

ePointer

eBuffSize

:=
:=

:=

@MyCompRoutine;

BigBytes

{pointer

{size

of

to

completion

routine}

type}
to

read-data

read-data

area}

area}

END;

myErr
IF

:=

myErr

ERead(EPBPtr,
<>

noErr

END;

32-84

The .ENET Driver

THEN

TRUE);
DoError

(myErr)

{call

ERead

{

next

the

to

wait

packet}

for

}

}

The AppleTalk Manager

BEGIN

{main}

EPBPtr
WITH

:=

@myPB;

EPBPtr*

DO

{set

up

EAttachPH

parameters}

BEGIN

eProtType
ePointer

:=
:=

77;

{protocol

NIL

type}

{use

default

{tell

.ENET

protocol

handler}

END;
myErr

:=

EAttachPH(EPBPtr,

FALSE);

{
IF

myErr

<>

APtr

:=

WITH

EPBPtr*

NoErr

THEN

DoError

(myErr)

about

protocol

this

}

handler}

;

NewPtr(BigBytes) ;
DO

{set

up

ERead

parameters}

BEGIN

ioCompletion

:=

eProtType

77;

{protocol

APtr;

{pointer

to

{size

of

read-data

{wait

for

your

ePointer
eBuffSize

:=
:=
:=

@MyCompRoutine;

BigBytes

{pointer

to

completion

routine}

type}
read-data

area}

area}

io)
bho

END;

myErr

:=

ERead(EPBPtr,

TRUE);

{
IF

myErr

<>

noErr

THEN

{application-defined

DoError

then

read

packet

and

~

}

~~
—

~
~

it}

—

—

oO

(myErr)

ae

i

~~

tasks}

K<
a
©

END;

=

{main}

pe

ga

oe

or

Using Your Own

Ethernet Protocol

Handler to Read

Data

If a client of the .ENET driver has used the EAttachPH function to provide a pointer to
its own protocol handler, the .ENET driver calls that protocol handler, which must in
turn call the .ENET driver’s ReadPacket and ReadRest routines to read the data. Your
protocol handler calls the .ENET driver’s ReadPacket and ReadRest routines in essentially
the same way as you call the .MPP driver’s ReadPacket and ReadRest routines (see the
AppleTalk Manager chapter of Volume II). The following sections describe how the
.ENET driver calls a custom protocol handler and the ReadPacket and ReadRest routines.
Note: Because an Ethernet protocol handler must read from and write to the
CPU’s registers, you cannot write a protocol handler in Pascal.

How the .ENET

Driver Calls Your Protocol

Handler

You can provide an Ethernet protocol handler for a particular protocol type and use the
EAttachPH function to attach it to the .ENET driver. When the driver receives an Ethernet
packet, it reads the packet header into an internal buffer, reads the protocol type, and calls

The .ENET Driver

32-85

|

Inside Macintosh,

Volume

VI

the protocol handler for that protocol type. The CPU is in interrupt mode, and the registers
are used as follows:
Registers

on call to Ethernet

AO

protocol

handler

Reserved for internal use by the .ENET driver. You must preserve this
register until after the ReadRest routine has completed execution.

Al

Reserved for internal use by the .ENET driver. You must preserve this

register until after the ReadRest routine has completed execution.

A2

Free for your use.

A3

Pointer to first byte past data-link header bytes (the first byte after the 2-byte
protocol-type field).

A4

Pointer to the ReadPacket routine. The ReadRest routine starts 2 bytes after
the start of the ReadPacket routine.

AS

Free for your use until after the ReadRest routine has completed execution.

DO

Free for your use.

DI

Number of bytes in the Ethernet packet left to be read (that is, the number of
bytes following the Ethernet header).

D2

Free for your use.

D3

Free for your use.

If your protocol handler processes more than one protocol type, you can read the
protocol-type field in the data-link header to determine the protocol type of the packet.
The protocol-type field starts 2 bytes before the address pointed to by the A3 register.
Note: The source address starts 8 bytes before the address pointed to by the A3
register, and the destination address starts 14 bytes before the address pointed to by
the A3 register.
If you know that the packet contains pad bytes and you know the actual size of the data, you
can reduce the number in the D1 register by the number of pad bytes so that the ENET driver
can keep accurate track of the number of bytes remaining to be read. In all other
circumstances, you should not change the value in the D1 register.
After you have called the ReadRest routine, you can use registers AO through A3 and DO
through D3 for your own use, but you must preserve all other registers. You cannot depend
on having access to your application global variables.

How

Your

Protocol

Handler

Calls

the

.ENET

Driver

Your protocol handler must call the .ENET driver routines ReadPacket and ReadRest to read
the incoming data packet. You may call the ReadPacket routine as many times as you like to
read the data piece by piece into one or more data buffers, but you must always use the
ReadRest routine to read the final piece of the data packet. The ReadRest routine restores the
machine state (the stack pointers, status register, and so forth) and checks for error conditions.
32-86

The .ENET

Driver

The AppleTalk Manager

Before you call the ReadPacket routine, you must allocate memory for a data buffer and place
a pointer to the buffer in the A3 register. You place the number of bytes you want to read in
the D3 register. You must not request more bytes than remain in the data packet.
To call the ReadPacket routine, execute a JSR instruction to the address in the A4 register.
The ReadPacket routine uses the registers as follows:
Registers

on entry

to the ReadPacket

routine

A3

Pointer to a buffer to hold the data you want to read

D3

Number of bytes to read; must be nonzero

Registers

on exit from

the ReadPacket

routine

AO

Unchanged

Al

Unchanged

So

A2

Unchanged

S

A3

First byte after the last byte read into buffer

2

DO

Changed

5

DI

Number of bytes left to be read

q

D2

Unchanged

ke

D3

Equals 0 if requested number of bytes were read, nonzero if error

The ReadPacket routine indicates an error by clearing to 0 the zero (z) flag in the status
register. If the ReadPacket routine returns an error, you must terminate execution of your
protocol handler with an RTS instruction without calling ReadPacket again or calling
ReadRest at all.
Call the ReadRest routine to read the last portion of the data packet, or call it after you have
read all the data with ReadPacket routines and before you do any other processing or terminate execution. You must provide in the A3 register a pointer to a data buffer and must
indicate in the D3 register the size of the data buffer. If you have already read all of the data
with calls to the ReadPacket routine, you can specify a buffer of size 0.
A

Warning: If you do not call the ReadRest routine after your last call to the
ReadPacket routine, the system will crash. a

To call the ReadRest routine, execute a JSR instruction to an address 2 bytes past the address
in the A4 register. The ReadRest routine uses the registers as follows:
Registers

on entry

to the ReadRest

routine

A3

Pointer to a buffer to hold the data you want to read

D3

Size of the buffer (word length); may be 0
The .ENET Driver

32-87

Inside Macintosh,

Registers

Volume

on exit from

VI

the ReadRest

routine

AO

Unchanged

Al

Unchanged

A2

Unchanged

A3

Pointer to first byte after the last byte read into buffer

DO

Changed

DI

Changed

D2

Unchanged

D3

Equals 0 if requested number of bytes were read; less than 0 if more data was
left than would fit in buffer (extra data equals -D3 bytes); greater than 0 if less
data was left than the size of the buffer (extra buffer space equals D3 bytes)

The ReadRest routine indicates an error by clearing to 0 the zero (z) flag in the status register.
You must terminate execution of your protocol handler with aa RTS instruction whether or
not the ReadRest routine returns an error.

-ENET

Driver

Routines

An application that uses AppleTalk Manager routines for network communication can talk
to whatever AppleTalk network the user has selected through the Network Setup control
panel. However, you can choose to write an application that talks only to Ethernet; in this
case, your application has to address the Ethernet driver directly. This section describes the
functions that you can use to control the .ENET driver, the Ethernet driver provided with
system software version 7.0. Each .ENET driver function is of the following form:
EFunc

(thePBptr:

ParamBlkPtr;

ea

FUNCTION

async:

Boolean)

:

OSErr;

The thePBptr parameter is a pointer to the .ENET parameter block and the asyne parameter is
a Boolean that specifies whether the function is to be executed synchronously or asynchronously. Set the async parameter to TRUE to execute the function asynchronously.
The .ENET parameter block is defined as follows:
TYPE

EParamBlock
PACKED

32-88

=

RECORD

qLink:
qType:
ioTrap:

QElemPtr;
Integer;
Integer;

{next queue
entry}
{queue
type}
{routine
trap}

ioCmdAddr:
ioCompletion:
ioResult:
ioNamePtr:

Ptr;
ProcPtr;
OSErr;
StringPtr;

{routine
address}
{completion
routine
{result
code}
{driver
name}

ioVRefNum:
ioRefNum:

Integer;
Integer;

{volume
{driver

reference
reference

csCode:

Integer;

{primary

command

The .ENET Driver

number}
number}
code}

The AppleTalk Manager

CASE

Integer

OF

ENetWrite,
ENetAttachPH,
ENetDetachPH,

ENetRead,
ENetRdCancel,
ENetGetinfo,
ENetSetGeneral:

(
eProtType:

Integer;

{Ethernet

ePointer:

Ptr;

eBuffSize:

Integer;

{pointer;
use
{ function}
{buffer size}

protocol

eDataSize:

Integer

{number

of

type}

depends

bytes

on

}

read}

7
ENetAddMulti,

ENetDelMulti:
(
eMultiAddr:

Ge

ARRAY[0..5]

of

Char

{multicast

nN
Re
~~

address}

—

)

ee©

END;

oe
as

The qLink, qType, ioTrap, ioCmdAddr, ioNamePtr, and ioVRefNum fields are filled in by
the Device Manager; your application should not have to set or read these fields. The ioResult
field returns the result of the function. If you call the function asynchronously, the function
sets this field to | as soon as it begins execution, and it changes the field to the actual result
code when it completes execution. The ioCompletion field is a pointer to a completion routine
that you can provide; the Device Manager calls your completion routine when it completes
execution of the function. If you are not providing a completion routine, specify NIL for this
field. You must obtain the driver reference number from the OpenDriver function and use it
for the ioRefNum field.
The csCode field specifies the command to be executed; the MPW Pascal interface fills in this
field for you. The .ENET driver accepts the following constants as routine selectors:
CONST

routine

selectors}

ENetSetGeneral
ENetGetInfo

{.ENET

driver

=
=

253;
252;

{set
{get

ENetRdCancel
ENet Read

=
=

251;
250;

{cancel
{read}

read}

ENetDetachPH

=

248;

{detach

protocol

ENetAttachPH
ENetAddMulti
ENetDelMulti

=
=
=

247;
246;
245°

{attach protocol
handler}
{add a multicast
address}
{delete a multicast
address}

ENetWrite

=

249;

"general"
info}

mode}

{write}

handler}

The remaining parameters are used only for specific functions; all of these parameters are
described in the following sections.
For a general discussion of the use of the Ethernet driver, see “The .ENET Driver” earlier in
this chapter.
The .ENET Driver

32-89

=~
io
bums
=
—
—

=
ti)
o&
“

Inside Macintosh,

Attaching

Volume VI

and

Detaching

an Ethernet

Protocol

Handler

The functions in this section allow you to attach a protocol handler to the .ENET driver,
to specify which protocol handler the .ENET driver is to use for each protocol type, and
to detach a protocol handler that you previously attached. The section “Using Your Own
Ethernet Protocol Handler to Read Data” earlier in this chapter describes how to write and
use Ethernet protocol handlers.
FUNCTION

EAttachPH

Parameter block
16
c-

(thePBptr:

EParamBlkPtr;

async:

Boolean)

ioResult

word

result code

:

OSErr;

>

26

csCode

word

always ENetAttachPH

os

28

eProtT ype

word

Ethernet protocol type

-

30

ePointer

long

pointer to protocol handler

The EAttachPH function serves two purposes: you can use it to attach to the .ENET driver
your own protocol handler for a specific protocol type, or you can use it to specify that the
.ENET driver should use the default protocol handler for a particular protocol type. If you
attach your own protocol handler, the .ENET driver calls that protocol handler each time it
receives a packet with the protocol type you specified. If you specify that the .ENET driver
should use the default protocol handler, then you can use the ERead command to read packets
with that protocol type.
The ioResult parameter returns the result of the function. If you call the function asynchronously, the function sets this field to 1 as soon as it begins execution, and it changes the field
to the actual result code when it completes execution. The csCode parameter is a routine
selector; it is always equal to ENetAttachPH for this function.
You specify the protocol type in the eProtType parameter and provide a pointer to the
protocol handler in the ePointer parameter. If you specify NIL for the ePointer parameter,
then the .ENET driver uses the default protocol handler for that protocol type. Specify 0
for the eProtType parameter to attach a protocol handler for the IEEE 802.3 protocol, which

uses protocol types 0 through $5DC.

Note: The LAP Manager calls the EAttachPH function with a protocol type of 0 and
thus receives all 802.3 protocol packets. Instead of using the EAttachPH function to
install a protocol handler for an 802.3 Ethernet protocol type, you should use the
L802Attach routine. In the case of an 802.3 protocol packet, the .ENET driver passes
the packet to the LAP Manager 802.2 protocol handler. If the packet has the protocol
type you specified with the L802Attach routine, the 802.2 protocol handler passes the
packet on to your protocol handler. For more information about IEEE 802.2 and
802.3 protocols, see “The LAP Manager 802.2 Protocol” earlier in this chapter.
Result codes
noErr
LAPProtErr

32-90

0
-94

The .ENET Driver

No error
Protocol handler is already attached or node’s protocol
table is full

The AppleTalk Manager

FUNCTION

EDetachPH

(thePBptr:

EParamBlkPtr;

async:

Boolean)

:

OSErr;

Parameter block
<

16

ioResult

word

result code

>

26

csCode

word

always ENetDetachPH

~

28

eProtType

word

Ethernet protocol type

The EDetachPH function detaches a protocol handler from the .ENET driver. Once you have
removed a protocol type from the node’s protocol table with this function, the .ENET driver
no longer delivers packets with that protocol type. You specify the protocol type in the
eProtType parameter.
The ioResult parameter returns the result of the function. If you call the function asynchronously, the function sets this field to 1 as soon as it begins execution, and it changes the field
to the actual result code when it completes execution. The csCode parameter is a routine
selector that is set automatically for you by the MPW interface; it is always equal to
ENetDetachPH for this function.
When you call the EDetachPH function, any pending calls to the ERead function terminate
with the reqAborted result code.
Result codes
noErr
LAPProtErr

Writing

and

EWrite

Parameter block
—
16

>

‘|
wohia*)

hn]

3
ra
i

D
=
ES
ge

—

0
—94

Reading

No error
No protocol handler is attached

Ethernet

@
a

Packets

The functions in this section send and read Ethernet packets, cancel execution of a read
operation, return information about the .ENET driver, and switch the .ENET driver from
limited-transmission mode to general-transmission mode.
FUNCTION

a)NS)

(thePBptr:

EParamBlkPtr;

async:

Boolean)

ioResult

word

result code

:

OSErr;

>

26

csCode

word

always ENetWrite

>

30

ePointer

long

pointer to write-data structure

The EWrite function uses the .ENET driver to send a data packet over Ethernet. You must
first prepare a write-data structure that specifies the destination address and the protocol type
and contains the data that you want to send. You place a pointer to the write-data structure
in the ePointer parameter. If you want to send a packet larger than 768 bytes, you must first
call the ESetGeneral function to put the .ENET driver in general-transmission mode. If the
size of the packet you provide is less than 60 bytes, the driver adds pad bytes to the packet.
Write-data structures are described in “Using a Write-Data Structure to Transmit Ethernet
Data” earlier in this chapter.
The .ENET Driver

32-91

Inside Macintosh,

Volume

VI

The ioResult parameter returns the result of the function. If you call the function asynchronously, the function sets this field to 1 as soon as it begins execution, and it changes the —
field to the actual result code when it completes execution. The csCode parameter is a routine
selector that is set automatically for you by the MPW interface; it is always equal to ENetWrite
for this function.
Result codes

noErr
eLenErr

0
—92

excessCollsns

—95

FUNCTION

No error
Packet too large or first entry of the write-data structure
did not contain the full 14-byte header
Hardware error

ERead

(thePBptr:

EParamBlkPtr;

async:

Boolean)

Parameter block
—
16

ioResult

word

result code

:

OSErr;

~

26

csCode

word

always ENetRead

>

28

eProtType

word

Ethernet protocol type

oa

30

ePointer

long

pointer to data buffer

~

34

eBuffSize

word

size of data buffer

-

36

eDataSize

word

number of bytes read

The ERead function uses the default protocol handler to read a data packet and place it in a
data buffer. You can use the ERead function to read packets of a particular protocol type only
after you have used the EAttachPH function to specify a NIL pointer to the protocol handler
for that protocol type.
The ioResult parameter returns the result of the function. If you call the function asynchronously, the function sets this field to 1 as soon as it begins execution, and it changes the field
to the actual result code when it completes execution. The csCode parameter is the routine
selector, automatically set by the MPW interface. It is always ENetRead for this function.
The eProtType parameter specifies the protocol type of the packet you want to read. The
ePointer parameter is a pointer to the data buffer into which you want to read data, and the
eBuffSize parameter indicates the size of the data buffer. If you are expecting EtherTalk data
packets, the buffer should be at least 621 bytes in size; if you are expecting general Ethernet
data packets, the buffer should be at least 1514 bytes in size.

The ERead function places the entire packet, including the packet header, into your buffer.
The function returns in the eDataSize parameter the number of bytes actually read. If the
packet is larger than the data buffer, the ERead function places as much of the packet as will
fit into the buffer and returns the buf2SmallErr result code.
Call the ERead function asynchronously to await the next data packet. When the .ENET
driver receives the data packet, it completes execution of the ERead function and calls your
completion routine. If the .ENET driver receives a data packet with a protocol type for which
you specified the default protocol handler while no ERead command is pending, the driver
discards the data packet.
32-92

The .ENET Driver

The AppleTalk Manager

You can have several asynchronous calls to the ERead function pending execution simultaneously, as long as you use a different parameter block for each call.
Result codes

noErr
LAPProtErr
reqAborted
buf2SmallErr

FUNCTION

ERdCancel

0
-94
—1105
-3101

No error
No protocol is attached or protocol handler pointer was not 0
ERdCancel or EDetachPH function called
Packet too large for buffer; partial data returned

(thePBptr:

EParamBlkPtr;

async:

Boolean)

:

OSErr;

Parameter block

on

16

ioResult

word

result code

>

26

csCode

word

always ENetRdCancel

=

30

ePointer

long

pointer to ERead parameter block

The ERdCancel function cancels execution of a specific call to the ERead function. You must
have called the ERead function asynchronously to use the ERdCancel function. You specify
in the ePointer parameter a pointer to the parameter block that you used when you called the
ERead function.

ww

WN

>
—

~~

=
rar)

=

po)
—

~~

io
an
99
as
an

—

The ioResult parameter returns the result of the function. If you call the function asynchronously, the function sets this field to 1 as soon as it begins execution, and it changes the field
to the actual result code when it completes execution. The csCode parameter is the routine
selector, automatically set by the MPW interface. It is always ENetRdCancel for this function.
When you call the ERdCancel function, the pending ERead function that you cancel receives
the reqAborted result code.
Result codes
noErr
cbNotFound
FUNCTION

EGetInfo

0)
—-1102
(thePBptr:

No error
ERead not active
EParamBlkPtr;

async:

Boolean)

:

OSErr;

Parameter block

—

16

ioResult

word

result code

—

26

csCode

word

always ENetGetInfo

>

30

ePointer

long

pointer to buffer

_

34

eBuffSize

word

size of buffer

The EGetInfo function returns information about the .ENET driver. Before calling this
function, you must allocate a data buffer of at least 18 bytes. Put a pointer to the buffer
in the ePointer parameter and the size of the buffer in the eBuffSize parameter.
The .ENET Driver

32-93

—

ss

go

©
ar |

Inside Macintosh,

Volume VI

The EGetInfo function places the following information in the data buffer:
Bytes

Information

l-6
7-10
11-14
15-18

Ethernet address of the node on which the driver is installed
Number of times the receive queue has overflowed
Number of data transmission operations that have timed out
Number of packets received that contain an incorrect address

An incorrect Ethernet address is one that is neither the broadcast address, a multicast address

for which this node is registered, nor the node’s data link address. A node could receive an

incorrect Ethernet address due to a hardware or software error.

The ioResult parameter returns the result of the function. If you call the function asynchronously, the function sets this field to 1 as soon as it begins execution, and it changes the field
to the actual result code when it completes execution. The csCode parameter is the routine
selector, automatically set by the MPW interface. It is always ENetGetInfo for this function.
Result code
noErr
FUNCTION

0

ESetGeneral

No error
(thePBptr:

EParamBlkPtr;

async:

Boolean)

:

OSErr;

Parameter block
—

16

ioResult

word

result code

>

26

csCode

word

always ENetSetGeneral

The ESetGeneral function switches the .ENET driver from limited-transmission mode to
general-transmission mode. In limited-transmission mode, the .ENET driver allocates a
write-data buffer of 768 bytes. This buffer size is more than sufficient to hold an EtherTalk
data packet, which can be no larger than 621 bytes. In general-transmission mode, the
-ENET driver can transmit an Ethernet data packet of up to 1514 bytes.
The ioResult parameter returns the result of the function. If you call the function asynchronously, the function sets this field to 1 as soon as it begins execution, and it changes the field to
the actual result code when it completes execution. The csCode parameter is the routine selector,
automatically set by the MPW interface. It is always ENetSetGeneral for this function.
There is no command to switch the .ENET driver from general-transmission mode to limitedtransmission mode. To switch back to limited-transmission mode, you have to reset the
driver by restarting the computer.
Result codes
noErr
memFullErr

32-94

0
—108

The .ENET Driver

No error
Insufficient memory in heap

The AppleTalk Manager

Adding

and

Removing

Ethernet Multicast Addresses

The functions in this section add or delete Ethernet multicast addresses for a particular node.
A multicast address is an Ethernet address for which the node accepts packets just as it
does for its permanently assigned Ethernet hardware address. In a multicast address, the loworder bit of the high-order byte is set to 1. Each node can have any number of multicast
addresses, and any number of nodes can have the same multicast address. The purpose of a
multicast address is to allow a group of Ethernet nodes to receive the same transmission
simultaneously, in a fashion similar to the AppleTalk broadcast service.
FUNCTION

EAddMulti

Parameter block
e
16

(thePBptr:

EParamBlkPtr;

async:

Boolean)

ioResult

word

result code

:

~

26

csCode

word

always ENetAddMulti

>

28

eMultiAddr

6 bytes

multicast address

OSErr;

Ww

nN

>
—

The EAddMulti function adds a multicast address to the node on which the .ENET driver
is running.

=

—

~

@

—
s
_

You must provide (in the eMultiAddr parameter) the multicast address that you want to use.
Each time a client of the .ENET driver calls the EAddMulti function for a particular multicast
address, the driver increments a counter for that multicast address. Each time a client of the
-ENET driver calls the EDelMulti function, the driver decrements the counter for that address.
As long as the count for a multicast address is equal to or greater than 1, the .ENET driver
accepts packets directed to that multicast address. Therefore, if any client of the .ENET driver
in the node has called the EAddMulti function for a particular multicast address, the driver

receives packets delivered to that address.

The ioResult parameter returns the result of the function. If you call the function asynchronously, the function sets this field to | as soon as it begins execution, and it changes the field to
the actual result code when it completes execution. The csCode parameter is the routine selector,
automatically set by the MPW interface. It is always ENetAddMulti for this function.
Result codes
noErr

eMultiErr

FUNCTION

EDelMulti

—9]

0)

No error

Invalid address or table is full

(thePBptr:

EParamBlkPtr;

async:

Boolean)

:

OSErr;

Parameter block

oo

16

ioResult

word

result code

>

26

csCode

word

always ENetDelMulti

—

28

eMultiAddr

6 bytes

multicast address

The .ENET Driver

32-95

~*~
—

an

—
ae
—

a
~~
t=
fe)
—_

er |

Inside Macintosh,

Volume VI

The EDelMulti function decrements the counter kept by the .ENET driver for a particular
multicast address. Each time a client of the .ENET driver calls the EAddMulti function, the
driver increments a counter for the multicast address specified by the eMultiAddr parameter.

Each time a client of the .ENET driver calls the EDelMulti function, the driver decrements the

counter for the address specified by the eMultiAddr parameter. As long as the count for a
multicast address is equal to or greater than 1, the .ENET driver accepts packets directed to
that multicast address. When the count for an address equals 0, the driver removes that
address from the list of multicast addresses that it accepts.
Note:

Because more than one client of the .ENET driver might be using a particular

multicast address, you should call the EDelMulti function only once for each time you
called the EAddMulti function.
The ioResult parameter returns the result of the function. If you call the function asynchronously, the function sets this field to | as soon as it begins execution, and it changes the field
to the actual result code when it completes execution. The csCode parameter is the routine
selector automatically set by the MPW interface. It is always ENetDelMulti for this function.
Result codes
noErr
eMultiErr

32-96

0)
—-9]

The .ENET Driver

No error
Address not found

The AppleTalk Manager

SUMMARY

OF

THE

APPLETALK

MANAGER

Constants
CONST
{AppleTalk

transitions}

ATTransOpen

=

0;

ATTransClose

=

2
SY

ATTransClosePrep
ATTransCancelClose
{.XPP

driver

4;

{.XPP

246;

—

driver

routine

selector

zipGetLocalZones

=

a

ZipGetZoneList

=

ZipGetMyZone

=

6;
KS

{ADSP

routine

‘

transition}

{prepare-to-close transition}
{permission-to-close transition}
{cancel-close transition}

selector}

routine

xCall

{open

selectors}
= 2553

subcodes}

{create

a

new

dspRemove

=

254

{remove

a

connection

dspOpen

%

2553.3

{open

dspClose

=

252;

{close

dspCLIinit

ra

251;

dspCLRemove
dspCLListen

=
=

250;

{create
{remove

dspCLDeny

=

248;

{post
{deny

a listener
request}
an open-connection
request }

dspStatus

=

247;

{get

status

dspRead

=

246;

dspWrite
dspAttention

=
=

245;
244;

dspOptions

=

243;

dspReset

=

dspNewCID

=

242;
241;

dspinit

{ADSP

249;

connection-opening
1

ocRequest

ocPassive

=

a

connection

end}

end}

connection}
a

connection}
a
a

connection
connection

of

listener}
listener}

connection

end}

{read data from the connection}
{write data on the connection}
{send

an

attention

message}

{set connection
end options}
{forward reset
the connection}

{generate
modes}
{request

2%

{wait

for

a

a

cid

for

a

connection
a

connection

with

connection

remote}

request

ocAccept

=

33

{ remote
connection
end}
{accept
request
as delivered

ocEstablish

=

4;

{consider

{ADSP

connection

sListening

end

=

sPassive

=

sOpening

=

sOpen

=

connection

to

be

states}
1.9
{for connection
listeners}
As
{waiting
for a connection
{

33
4;

connection
end}
a connection
{requesting

end}

from
by

}

listener}

open}

request

from

}

remote

{connection

is

with

remote}

open}

Summary of the AppleTalk Manager

— 32-97

Inside Macintosh, Volume VI

sClosed

{ADSP client
eClosed

event

flags}

$80;
$40;
$20;
$10;

eTearDown

eAttention
eFwdReset
{miscellaneous
ADSP
attnBufSize
minDSPQueueSize
{.ENET driver
catNetwork

100;

{received

attention

{received

forward

of
{minimum

message}

reset

advice}

client attention buffer}
size of receive or send queue}

values}

4;
Ly

{spCatecory

for

{spCType

EtherTalk

LAPMgrCall

2}

LAGGAEQ

23;

{offset
to
{LAPAdGATQ

LAP routines}
routine
selector}

LRmvAEQ

24;

{LAPRmvATQO

routine

{LAP

Manager

{.ENET

for

EtherTalk

NB

NB

card}

card}

values}

driver

routine

ENetSetGeneral

=

253;

{set

"general"

ENetGetInfo

=

252;

{get

info}

ENetRdCancel
ENet Read
ENetWrite

=
=
=

251;
250;
249;

{cancel
{read}
{write}

read}

ENet

TYPE

is being
torn down}
end state
is closed}

{received connection-closed advice}
{closed due to broken connection}

constants}
{size
570;

typeEtherNet

Data

{connection
{connection

55
6%

sClosing

selector}

selectors}
mode}

DetachPH

=

248;

{detach

protocol

handler}

ENetAttachPH

=

247;

{attach

protocol

handler}

ENetAddMulti
ENetDelMulti

=
=

246;
245;

{add a multicast address}
{delete a multicast address}

Types
ATQEntry

=

RECORD

qLink:
qType:

ATQEntryPtr;
Integer;

{next queue
{reserved}

entry}

CallAddr:

ProcPtr

{pointer

your

to

routine}

END;

ATOQentryptr

ATPParamBlock
PACKED

“ATQEntry;

=

RECORD

qLink:
qType:
ioTrap:

32-98

=

{extended

QElemPtr;
Integer;
Integer;

Summary of the AppleTalk Manager

{

parameter

PSendRequest

and

{next queue entry}
{queue type}
{routine trap}

block

for

}

PNSendRequest}

The AppleTalk Manager

ioCmdAddr:

Ptr;

ioCompletion:

ProcPtr;

{routine address}
{completion
routine}
{result
code}

ioResult:

OSErr;

userData:

LongInt;

{ATP

reqTID:

Integer;

ioRefNum:
csCode:

Integer;
Integer;

{request transaction ID}
{driver reference number}

atpSocket:

Byte;

{currBitMap

atpFlags:

Byte;

{control

user

{primary

for

command
or

extended

AddrBlock;

{source

socket

reqLength:

Integer;

{request

size

reqPointer:

Ptr;

bdsPointer:

Ptr;

{pointer
{pointer

to
to

data

{number

numOfResps:

Byte;

}

of

actually

responses

expected}

}

received}

{number of retries}
{used internally for NSendRequest}
{release timer setting}

Byte;

Integer;

}

structure}

{timeout interval}
{number of responses

Byte

2

bytes}

Byte;

intBuff:

bit

block}

request data}
response buffer

Byte;

TRelTime:

set

address}
in

timeOutVal:

retryCount:

-

parameter

numOfBuffs:

{

number}

information

addrBlock:

{

code}
socket

ce

{

bytes}

ig
~~
~—e
—_
—
—s
—
@ MK
a |
as
a
~~
~

END;

as
pe
—a
a
7

Bae

XPPParamBlock

cooadl

=

@

m=

PACKED RECORD
qLink:

QElemPtr;

{next

qType:

Integer;

ioTrap:

Integer;

type}
{queue
{routine
trap}

queue

entry}

ioCmdAddr :

Ptr;

{routine

i1oCompletion:
ioResult:

ProcPtr;
OSErr;

{completion

cmdResult:

LongInt;

{command

result}

ioVRefNum:

Integer;

{volume

reference

ioRefNum:

Integer;

{driver

reference

csCode:

Integer;

{primary

command

xCallParam
xppSubCode:
xppTimeOut :

Integer;
Byte;

{secondary
command code}
{timeout
period
for
.XPP}

xppRetry:
fillerl:

Byte;
Integer;

{retry

zipBuffPtr:

Ptr;

{reserved}
{returned

zipNumZones:

Integer;

{number

zipLastFlag:

Byte;

{nonzero

CASE

XPPPrmBlkType

{result

Byte;

zipInfoField:

XPPParmBlkPtr

=

routine}

code}
number}
number}
code}

OF

{

filler2:

address}

PACKED

ARRAY[1..70]

names

count}
zone

of

when
have

{reserved}
OF Byte
{reserved

names}

zones

for

all
been

use

returned}
zone

}

returned}

by

.XPP}

“XPPParamBlock;

Summary of the AppleTalk Manager

32-99

$

Inside Macintosh, Volume VI

TRCCB:

‘=

PACKED

RECORD

ccbLink:
refNum:

TPCCB;
Integer;

{link

{reference

to

next

number}

CCB}

the

state:

Integer;

{state

of

userFlags:

Byte;

{user

flags

localSocket:
remoteAddress:

Byte;
AddrBlock;

attnCode:
attnSize:

Integer;
Integer;

{local socket number}
{remote end internet address}
{attention code received}

attnPtr:

PCr

reserved:

PACKED

{size

of

connection
for

attention

data}

{pointer to attention
ARRAY[1. -220]
OF Byte
{reserved

for

number}

end}

connection}

use

by

data}
ADSP}

END;
AddrBlock
PACKED

=

RECORD

aNet:

Integer;

{network

aNode:

Byte;

{node

aSocket:

Byte

{socket

qLink:

QElemPtr;

{next

queue

qType:

Integer;

ioTrap:

{queue

type}

Integer;

trap}

ioCmdAddr:

{routine

PEr?

ioCompletion:

{routine

address}

PLrOGPEL >

ioResult:

OSErr;

{completion
routine}
{result
code}

StringPtr;

{reserved}

ioCRefNum:

Integer;
Integer;

{reserved}

csCode:

Integer;

qStatus:

{driver reference number}
{primary command code}

LongIint;

ccbRefNum:

{reserved

Integer;

{CCB

ID}
number}

END;

DSPParamBlock
PACKED

=

RECORD

ioNamePtr:
ioVRefNun:

CASE

Integer

entry}

for

ADSP}

reference

number}

OF

dspInit,

dspCLIinit:
(
ccbPtr:

TPCCB;

userRoutine:
sendQSize:

{pointer

to

ProcPtur;

sendQueue:
recvQSize:

{pointer
{size of

to user routine}
send queue}

Ptr

{pointer
{size of

to send
receive
to

Integer;

Integer;

queue}
queue}

recvQueue:

PES:

{pointer

attnPtr:

PCr?

localSocket:
fillerl:

{pointer
to attention{ message
buffer}

Byte;

{local

socket

Byte;

{filler

for

);

32-100

CCB}

Summary of the AppleTalk Manager

receive

queue}
}

number}
proper

alignment}

The AppleTalk Manager

daspOpen,
dspCLListen,
dspCLDeny :

(
localCID:

Integer;

{local

remoteCID:

Integer;

{remote

connection

remoteAddress:

AddrBlock;

{remote

internet

{address

filter}

connection

ID}

ID}
address}

filterAddress:

AddrBlock;

sendSeq:

LongiInt;

{send

sequence

sendWindow:

Integer;

{size

of

recvSeq:

Longint;

{receive

attnSendSeda:

LongInt;

{attention

send

attnRecvSeq:

LongInt;

{attention

receive

ocMode:

Byte;

ociInterval:

Byte;

{connection-opening mode}
{interval bet open requests}

ocMaximum:
filler2:

Byte;

Byte;

number}

remote

buffer}

sequence

{retries
of
{filler
for

number}

seq

number}
seq

num}

open-conn req}
proper alignment}

3
dspClose,

~~
—

—_

dspRemove:

—
~~
—_—

\a*)

(

7

abort:

Byte;

filler3:

Byte;

{abort

send

{filler

for

requests}

proper

alignment }

ay
~
—_
mr
i
—

3

tS]
—_
_

AS
~

ti)

dspStatus:
(

@

~;

statusCCB:

TPCCB;

{pointer

sendQPending:

Integer;

{bytes

to

sendQFree:

Integer;

{available

recvQPending:

Integer;

recvQOFree:

Integer;

{bytes
{avail

reqCount:

Integer;

{requested

actCount:

Integer;

CCB}

waiting

in

send

send-queue

queue}
buffer}

in receive queue}
receive-queue buffer}

dspRead,
dspWrite:
(

number

of

bytes}

dataPtr:

PUr;

{actual
number of bytes}
{pointer
to data buffer}

eom:
flush:

Byte;
Byte;

{1
{1

attnCode:

Integer;

attnSize:

Integer;

{client attention code}
{size of attention data}

attnData:
attniInterval:
filler4:

Ptr?

{pointer

Byte;

{reserved}

if
to

end of message}
send data now}

)
dspAttention:

(

Byte;

{filler

to

attention

for

proper

data}

alignment }

Summary of the AppleTalk Manager

32-101

Inside Macintosh,

Volume VI

dspOptions:
(
sendBlocking:
sendTimer:
rtmtTimer:
badSeqMax:

Integer;
Byte;
Byte;
Byte;

{send-blocking threshold}
{reserved}
{reserved}
{retransmit advice threshold}

Byte;

{DDP

checksum

Integer

{new

connection

EParamBlock
=
PACKED RECORD
qLink:

QElemPtr;

{next

qType:

Integer;

{queue

useCheckSum:

for

packets}

)
dspNewCID:

(

newCID:

ID}

)
END;

queue

entry}

type}

ioTrap:

Integer;

{routine

ioCmdAddr:
ioCompletion:
ioResult:

Ptr;
ProcPtr;
OSErr;

{routine address}
{completion routine}
{result code}

ioNamePtr:

StringPtr;

{driver

name}

ioVRefNum:
ioRefNum:

Integer;
Integer;

{volume
{driver

reference
reference

csCode:

Integer;

{primary

command

eProtType:

Integer;

{Ethernet

ePointer:

Ptr:

CASE

Integer

trap}

number}
number}

code}

OF

ENetWrite,
ENetAttachPH,

ENetDetachPH,
ENetRead,
ENetRdCancel,
ENetGetInfo,
ENetSetGeneral:

(
protocol

eBuffSize:

Integer;

{pointer;
use
{ function}
{buffer size}

eDataSize:

Integer

{number

of

type}

depends

bytes

read}

3
ENetAddMulti,
ENetDelMulti:

(
eMultiAddr:
END;

EParamBlkPtr

32-102

ARRAY[0..5]

of

)
=

*“EParamBlock;

Summary of the AppleTalk Manager

Char

{multicast

address}

on

}

The AppleTalk Manager

Routines

Getting

Information

About the .MPP

FUNCTION

PGetAppleTalkInfo

(thePBptr:

Adding

and

AppleTalk

FUNCTION

LAPAdGdATQ

(theATQEntry:

ATQOEntryPtr)

:

OSErr;

FUNCTION

LAPRmvATQ

(theATQEntry:

ATQEntryPtr)

:

OSErr;

Removing

Driver

MPPPBPtr;

Transition

Sending

Messages

to the AppleTalk

FUNCTION

PATalkClosePrep

(thePBptr:

Defining

Your Own

AppleTalk

async:

Boolean)

Queue

Transition

MPPPBPtr;

async:

:

OSErr;

Entries

Queue
Boolean)

:

OSErr;

ww

nN

>
<=)

Transition

—

—

@
—_
an

—

PROCEDURE
FUNCTION

ATEvent

(event:

ATPreFlightEvent

LongInt;

(event,cancel:

infoPtr:
LongInt;

x

Ptr);
infoPtr:

Ptr)

:

OSErr;

a
pet
pe)
|
as
—_

Canceling
FUNCTION

ATPKil1A11GetReq

Obtaining
FUNCTION

All Calls to the ATPGetRequest

Zone

(thePBptr:

ATPPBPtr;

itf=)
@
ar |

Function

async:

Boolean)

:

OSErr;

Information

GetMyZone

(thePBptr:

XPPParmBlkPtr;

async:

Boolean)

XPPParmBlkPtr;

async:

Boolean)

XPPParmBlkPtr;

async:

Boolean)

OSErr;
FUNCTION

GetLocalZones

(thePBptr:
OSErr;

FUNCTION

GetZoneList

(thePBptr:
OSErr;

Attaching
FUNCTION

and

EAttachPH

Detaching

an Ethernet

(thePBptr:

Protocol

Handler

EParamBlkPtr;

async:

Boolean)

EParamBlkPtr;

async:

Boolean)

OSErr;
FUNCTION

EDetachPH

(thePBptr:
OSEELT;

Summary of the AppleTalk Manager

32-103

Inside Macintosh, Volume VI

Writing

and

FUNCTION

EWrite

Reading

Ethernet

Packets

(thePBptr:

EParamBlkPtr;

async:

Boolean)

EParamBlkPtr;

async:

Boolean)

OSErr;
FUNCTION

ERead

(thePBptr:
OSErr;

FUNCTION

ERdCancel

(thePBptr:
OSErr;

EParamBlkPtr;

async:

Boolean)

FUNCTION

EGetInfo

(thePBptr:
OSETrr;

EParamBlkPtr;

async:

Boolean)

FUNCTION

ESetGeneral

(thePBptr:

EParamBlkPtr;

async:

Boolean)

OSErr;

Adding

and

Removing

FUNCTION

EAdGMulti

Ethernet

Multicast Addresses

(thePBptr:

EParamBlkPtr;

async:

Boolean)

EParamBlkPtr;

async:

Boolean)

OSErr;

EDelMulti

FUNCTION

(thePBptr:
OSErr;

Global

Variable

LapMerPtr

The start of the LAP Manager

Result

Codes

noErr

qErr

ddpSktErr
eMultiErr
eLenErr

—|
—24
—50
—91
—9]
—92

noBridgeErr
LAPProtErr

—93
—94

excessCollsns

—95
—108

closeErr

paramErr

memFullErr

32-104

No error or unrecognized event code
Queue element not found
Permission to close .MPP driver was denied
Version number is too high
Error opening socket
Invalid address, address not found, or table is full
Packet too large or first entry of the write-data structure
did not contain the full 14-byte header
No router is available
Protocol handler is already attached, node’s protocol
table is full, no protocol handler is attached, or protocol
handler pointer was not 0)
Hardware error
Insufficient memory in heap

Summary of the AppleTalk Manager

The AppleTalk Manager

reqFailed
tooManyReqs
cbNotFound

—1096
—1097
—1102

noDataArea
reqAborted
errOpenDenied
errDSPQueueSize
errFwdReset
errAttention
errOpening
errState
errAborted
errRefNum
buf2SmallErr

—1104
—1105
—1273
-—1274
—1275
—1276
—1277
—1278
—1279
—1280
—3101

Request to contact router failed; retry count exceeded
Too may concurrent requests
Control block not found, no pending asynchronous calls,
or ERead not active
Too may outstanding ATP calls
ERdCancel or EDetachPH function called
Open request denied by recipient
Send or receive queue is too small
Read terminated by forward reset
Attention message too long
Attempt to open connection failed
Bad connection state for this operation
Request aborted by dspRemove or dspClose routine
Bad connection reference number
Packet too large for buffer; partial data returned

Assembly-Language

ue
NS
>
S

Information

i

Constants
;ADSP

queue

o

=
gs
element

equates

&

x

size

csQStatus

EQU

CSParam

;adsp

internal

csCCBRef

EQU

csQStatus+4

s;refnum

of

a—
£9
=
69
gea)

use

ccb

“

AppleTalk

Transition

AeQQLink
AeQQType
AeQCallAddr

long
word
long

ADSP

Connection

cecbLink
refNum
state
userFlags
localSocket
remoteAddress
attnCode
attnSize
attnPtr
reserved

Queue

Entry

Data

Structure

next queue entry
reserved
pointer to your routine

Control

long
word
word
byte
byte
long
word
word
long
220 bytes

Block

Data

Structure

link to next CCB
reference number
state of the connection end
user flags for connection
local socket number
internet address of remote end
attention code received
size of received attention data
pointer to received attention data
__ reserved

Summary of the AppleTalk Manager

32-105

Inside Macintosh,

XPP

Volume VI

Parameter

Block

xCallParam

Variant

-

16

ioResult

word

result code

>

26

csCode

word

routine selector; always xCall

>

28

xppSubCode

word

routine selector subcode

>

30

xpp TimeOut

byte

retry interval in seconds

2

31

xppRetry

byte

retry count

~

34

zipBuffPtr

long

pointer to data buffer

<

38

zipNumZones

word

number of names returned

<-

40

zipLastFlag

byte

nonzero if no more names

=

42

zipInfoField

70 bytes

Parameter

__ for use by ZIP; first word set to 0

Block for dsplinit and dspCLIinit

—

16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

dspInit or dspCLInit

—

32

ccbRefNum

word

reference number of CCB

>

34

ccbPtr

long

pointer to CCB

>

38

userRoutine

long

>

42

sendQSize

word

pointer to routine to call on
connection events
size in bytes of the send queue

~

44

sendQueue

long

pointer to send queue

aa

48

recvQSize

word

size in bytes of the receive queue

>

50

recvQueue

long

pointer to receive queue

—

54

attnPtr

long

pointer to buffer for incoming
attention messages

oO

58

localSocket

byte

DDP socket number for this
connection end

Parameter

Block for dspOptions

e

16

ioResult

word

result code

_

24

ioCRefNum

word

driver reference number

=>

26

csCode

word

always dspOptions

32-106

Summary of the AppleTalk Manager

The AppleTalk Manager

>

32

ccbRefNum

word

reference number of CCB

>

34

sendBlocking

word

send-blocking threshold

>

38

badSeqMax

byte

threshold to send retransmit advice

>

39

useCheckSum

byte

DDP checksum flag

Parameter

Block

for dspOpen,

dspCLListen,

and

dspCLDeny

on

16

ioResult

word

result code

=>

24

ioCRefNum

word

driver reference number

>

26

csCode

word

-

32

ccbRefNum

word

dspOpen, dspCLListen, or
dspCLDeny
reference number of CCB

<-—

34

localCID

word

ID of this connection end

Co

36

remoteCID

word

ID of remote connection end

o

38

remoteAddress

long

remote internet address

>

42

filterAddress

long

filter for open-connection requests

o

46

sendSeq

long

initial send sequence number

o

50

sendWindow

word

initial size of remote receive queue

~

52

recvSeq

long

initial receive sequence number

oe

56

attnSendSeq

long

attention send sequence number

>

60

attnRecvSeq

long

attention receive sequence number

~>

64

ocMode

byte

connection-opening mode

=>

65

ocInterval

byte

interval between open requests

>

66

ocMaximum

byte

retries of open-connection request

Parameter

tad

tr
a

oe
re\

-_

16

ioResult

word

result code

3

24

ioCRefNum

word

driver reference number

—

26

csCode

word

always dspNewCID

~

32

ccbRefNum

word

reference number of CCB

oa

34

newCID

word

ID of new connection

Summary of the AppleTalk Manager

An
oO)
om
~
To)
—

ee

Block for dspNewCID

-

cf
nd
as
pb)
a=
wy

32-107

om
ba

Inside Macintosh,

Parameter

Volume VI

Block

dspCLRemove

dspRemove,

for dspClose,

and

e

16

ioResult

word

result code

>

24

ioCRefNum

word

driver reference number

_

26

csCode

word

dspClose, dspRemove, or
dspCLRemove

=

32

ccbRefNum

word

reference number of CCB

=>

34

abort

byte

abort send requests or connection
listener if not 0

T T i

TT

ltt

T

Parameter
16

ioResult

word

result code

24

ioCRefNum

word

driver reference number

26

csCode

word

always dspStatus

32

ccbRefNum

word

reference number of CCB

34

statusCCB

pointer

pointer to CCB

38

sendQPending

word

sendQFree

word

bytes waiting to be sent or
acknowledged
available send queue in bytes

recvQPending

word

bytes waiting to be read from queue

recvOFree

word

available receive queue in bytes

40
42
44

J Toot

Block for dspRead

and dspWrite

ioResult

word

result code

ioCRefNum

word

driver reference number

csCode

word

dspRead or dspWrite

ccbRefNum

word

reference number of CCB

reqCount

word

requested number of bytes

actCount

word

38

dataPtr

pointer

actual number of bytes read or
written
pointer to data buffer

42

eom

byte

| if end-of-message; 0 otherwise

43

flush

byte

1 to send data now; 0 otherwise

16

S

Thlitiwft

Parameter

32-108

Block for dspStatus

Summary of the AppleTalk Manager

The AppleTalk Manager

ith

oh ak oh ako

Parameter

-ENET

Block

for dspAttention

and

dspReset

16

ioResult

word

result code

24

ioCRefNum

word

driver reference number

26

csCode

word

dspAttention or dspReset

32

ccbRefNum

word

reference number of CCB

34

attnCode

word

client attention code

36

attnSize

word

size of attention data in bytes

38

attnData

pointer

pointer to attention data

Driver

Parameter

Block

bad ba
Tt

T

2
NS)

16

ioResult

word

result code

26

csCode

word

routine selector

28

eMultiAddr

6 bytes

multicast address

28

eProtType

word

Ethernet protocol type

30

ePointer

long

pointer

34

eBuffSize

word

size of buffer

36

eDataSize

word

number of bytes read

Summary of the AppleTalk Manager

-

<~)

=
=
=
-

oO

2

&
=
=
i
S

—

~y

32-109

Inside Macintosh, Volume VI

32-110

APPENDIX

A: RESULT

CODES

This appendix lists the result codes returned by functions described in this volume of /nside
Macintosh. They are ordered by value, for convenience when debugging. The names and
meanings of the result codes are also listed.
Some result codes are returned by more than one manager and therefore have more than one
meaning. This appendix lists each meaning for these result codes.
For a list of result codes returned by each manager, see the summary at the end of the
corresponding chapter.
Table A-1.

Result

codes

Value

Name

Meaning

()

noErr

No error

0

smNotTruncated

No truncation necessary

—]

smTruncErr

Truncation indicator alone is wider than the

—|

qErr

Not in queue

—24

closeErr

Permission to close .MPP driver was denied

—27

abortErr

Publisher has written a new edition

—33

dirFulErr

Directory full

—34

dskFulErr

Disk full

—35

nsvErr

Volume not found

—36

ioErr

I/O etror

—37

bdNamErr

Bad file name

—39

eofErr

No additional data in the format

—42

tmfoErr

Too many files open

—43

fnfErr

File not found; Folder not found; Edition
container not found; Target not found

—4

wPrErr

Volume is locked through hardware

—45

fLekdErr

File locked

—45

flL.ckedErr

Publisher writing to an edition

—46

vLckdErr

Volume is locked through software

—47

fBsyErr

Section doing I/O

—48

dupFNErr

File found instead of folder

—49

opWrErr

File already open for writing

specified width

~~
—
A

—

—_

@
nw

all

=
*
@
~

(Continued)

A-1

Inside Macintosh,

Table A-1.

Volume

VI

Result codes (Continued)

Value

Name

Meaning

—50

paramErr

Error in parameter list

—51

rfNumErr

Reference number invalid

volOfflinErr

Volume is off line

permErr

Not a subscriber; Software lock on file

extFSErr

External file system—file system identifier
is nonzero

-61

wrPermErr

Not a publisher

—9|

ddpSktErr

Error opening socket

—9|

eMultiErr

Invalid address or table is full

—92

eLenErr

Packet too large or first entry of the write-data
structure did not contain the full 14-byte header

noBridgeErr

No router is available

LAPProtErr

Protocol handler is already attached, node’s protocol table is full, protocol not attached, or protocol
handler pointer was not 0

excessCollsns

Hardware error

noTypeErr

Format not available

memFullErr

Ran out of memory

nilHandleErr

GetHandleSize fails on baseText or substitu-

memW7ZErr

Attempt to operate on a free block; GetHandleSize
fails on baseText or substitutionText

—120

dirNFErr

Directory not found

—123

wrgVolTypeErr

Not an HFS volume

—128

userCanceledErr

User canceled an operation

—147

regionTooBigError

Region too big or complex

—148

pixmapTooDeepErr

Pixel map record is deeper than | bit per pixel

—149

mfStackErr

Insufficient stack

—157

cDepthErr

Invalid pixel depth

-188

resourceInMemory

Resource already in memory

—189

writingPastEnd

Writing past end of file

—190

inputOutOfBounds

—192

Offset or count out of bounds

resNotFound

Resource not found

—199

mapReadErr

Map inconsistent with operation

—200

noHardwareErr

Required sound hardware not available

A-2

Table A-1: Result Codes

tionText; NIL master pointer

Result Codes

Value

Name

Meaning

—201

notEnoughHardwareErr

Insufficient hardware available

—203

queueFull

No room in the queue

—204

resProblem

Problem loading the resource

—205

badChannel

Channel is corrupt or unusable

—206

badFormat

Resource is corrupt or unusable

—207

notEnoughBufferSpace

Insufficient memory available

—208

badFileFormat

File is corrupt or unusable, or not AIFF or AIFF-C

—209

channelBusy

Channel is busy

—210

buffersTooSmall

Buffer is too small

—211

channelNotBusy

Channel not currently used

—212

noMoreRealTime

Not enough CPU time available

—213

badParam

A parameter is incorrect

—220

siNoSoundInHardware

No sound input hardware available

—221

siBadSoundInDevice

Invalid sound input device

siNoBufferSpecified

No buffer specified

W

silnvalidCompression

Invalid compression type

&

(Continued)

siHardDiskTooSlow

Hard drive too slow to record

nn

codes

silnvalidSampleRate

Invalid sample rate

Nn

Result

silnvalidSampleSize

Invalid sample size

—

Table A-1.

siDeviceBusyErr

Sound input device is busy

—228

siBadDeviceName

Invalid device name

—229

siBadRefNum

Invalid reference number

—230

silnputDeviceErr

Input device hardware failure

—231

siUnknownInfoType

Unknown type of information

—232

siUnknownQuality

Unknown quality

—299

nmTypErr

Invalid qlype—must be ORD(nmType)

—308

smUnExBusErr

Unexpected bus error

—330

smBadRefld

Reference ID not found in list

—331

smBadsList

Bad sResource structure: ID1

—332

smReservedErr

Reserved field not zero

—338

smSelOOBErr

Selector out of bounds; function not implemented

—344

smNoMoresResources

Specified sResource data structure not found

999
—22
—22
—22
—22
—22

>
‘)
SS
©
=

=
*
©

+ 2)

<ID2<ID3...

(Continued)

Table A-1: Result Codes

A-3

Inside Macintosh, Volume VI

Table A-1.

Result codes (Continued)

Value

Name

Meaning

—346

smBadsPtrErr

Bad pointer was passed to sCaldSPointer function

—347

smByteLanesErr

ByteLanes field in card’s format block was
determined to be zero

—450

editionMerInitErr

Manager not initialized or could not load package

—451

badSectionErr

Not a valid section type

—452

notRegisteredSectionErr

Not registered

—454

badSubPartErr

Bad edition container spec or invalid edition container

—460

multiplePublisherWrn

Already is a publisher

—461

containerNotFoundWrn

Alias was not resolved

—463

notThePublisherWrn

Not the publisher

—500

rgnTooBigErr

Bitmap would convert into a region greater than 64 KB

—600

procNotFound

No eligible process with specified process serial
number

—601

memFragErr

Not enough room to launch application with
special requirements

—602

appModeErr

Memory mode is 32-bit, but application is not
32-bit clean

—605

appMemFullErr

Partition size specified in 'SIZE' resource is not
big enough for launch

—606

appIsDaemon

Application is background-only

—607

bufferlsSmall

Buffer is too small

—608

noOutstandingHLE

No outstanding high-level event

—609

connectionInvalid

Connection is invalid

—610

noUserInteractionAllowed

Attempted PostHighLevelEvent from background
and no session yet established

—620

notEnoughMemoryErr

Insufficient physical memory

621

notHeldErr

Specified range of memory is not held

—622

cannotMakeContiguousErr

Cannot make specified range contiguous

—623

notLockedErr

Specified range of memory is not locked

—624

interruptsMaskedErr

Called with interrupts masked

—625

cannotDeferErr

Unable to defer additional user functions

—800

rcDBNull

The data item was NULL

-801

rcDBValue

Data available or successfully retrieved

—802

rcDBError

Error executing function

—803

rcDBBadType

Next data item not of requested data type

A-4

Table A-1: Result Codes

Result Codes

Table A-1.

Result codes (Continued)

Value

Name

Meaning

—804

rcDBBreak

Function timed out

—805

rcDBExec

Query currently executing

—806

rcDBBadSessID

Session ID is invalid

—807

rcDBBadSessNum

Invalid session number

—808

rcDBBadDDev

Couldn’t find the specified database extension, or
error occurred in opening database extension

—809

rcDBAsyncNotSupp

The database extension does not support
asynchronous calls

-810

rcDBBadAsynchPB

Invalid parameter block specified

-81]

rcDBNoHandler

There is no handler for this data type installed for
the current application

—812

rcDBWrongVersion

Wrong version number

-813

rcDBPackNotInited

The InitDBPack function has not yet been called

—850

hmHelpDisabled

Help balloons are not enabled

-853

hmBalloonAborted

Because of constant cursor movement, the help
balloon wasn’t displayed

—854

hmSameAsLastBalloon

Menu and item are same as previous menu and item

—855

hmHelpManagerNotInited

Help menu not set up

—857

hmSkippedBalloon

No ballon content to fill in

—858

hmWrong Version

Wrong version of Help Manager resource

>

|
—

—_

=
=

a3)

~*~
@

i? 2]

—859

hmUnknownHelpType

Help message record contained a bad type

—86]

hmOperationUnsupported

Bad method parameter

—862

hmNoBalloonUp

No balloon showing

—863

hmCloseViewActive

User using Close View won’t let you remove balloon

—900

notinitErr

PPC Toolbox has not been initialized yet

—902

nameTypeErr

Invalid or inappropriate locationKindSelector in
location name

—903

noPortErr

—904

noGlobalsErr

System unable to allocate memory, critical error

—905

localOnlyErr

Network activity is currently disabled

—906

destPortErr

Port does not exist at destination

—907

sessTableErr

PPC Toolbox is unable to create a session

—908

noSessionErr

Invalid session reference number

Invalid port name; Unable to open port or bad port

reference number

(Continued)

Table A-1: Result Codes

A-5

Inside Macintosh,

Table A-1.

Value

Volume VI

Result codes (Continued)

Name

Meaning

—909

badReqErr

Bad parameter or invalid state for this operation

—910

portNameExistsErr

Another port is already open with this name

—911

noUserNameErr

User name unknown on destination machine

—912

userRejectErr

Destination rejected the session request

-915

noResponseErr

Unable to contact application

—916

portClosedErr

The port was closed

—917

sessClosedErr

The session has closed

-919

badPortNameErr

PPC port record is invalid

—922

noDefaultUserErr

User has not specified owner name in Sharing
Setup control panel

—923

notLoggedInErr

Default user reference number does not yet exist

—924

noUserRefErr

Unable to create a new user reference number

—925

networkErr

An error has occurred in the network

—926

noInformErr

PPCStart failed because target application did not
have an inform pending

—927

authFailErr

User’s password is wrong

—928

noUserRecErr

Invalid user reference number

—930

badServiceMethodErr

Service method is other than ppcServiceRealTime

—-931

badLocNameErr

Location name is invalid

—932

guestNotAllowedErr

Destination port requires authentication

—1027

nbpDuplicate

Duplicate name exists already

—1096

reqFailed

Request to contact router failed; retry count exceeded

—1102

cbNotFound

Control block not found; no pending
asynchronous calls

—1105

reqAborted

ERdCancel function called for this ERead

—1273

errOpenDenied

Open request denied by recipient

—1274

errDSPQueueSize

Send or receive queue is too small

—1275

errFwdReset

Read terminated by forward reset

—1276

errAttention

Attention message too long

—1277

errOpening

Attempt to open connection failed

—1278

errState

Bad connection state for this operation

—1279

errAborted

Request aborted by dspRemove or dspClose function

—1280

errRefNum

Bad connection reference number

—1300

fidNotFoundErr

File ID not found

A-6

Table A-1: Result Codes

Result Codes

Table A-1.

Result codes (Continued)

Value

Name

Meaning

—1302

notAFileErr

Specified file is a directory

—1303

diffVolErr

Files on different volumes

—1304

catalogChangedErr

Catalog has changed and CatPosition may be invalid

—1305

desktopDamagedErr

The desktop database has become corrupted—the
Finder will fix this, but if your application is not
running with the Finder, use DTReset or DTDelete

—1700

errAECoercionFail

Data could not be coerced to the requested
descriptor type

—1701

errAEDescNotFound

Descriptor record was not found

—1702

errAECorruptData

Data in an Apple event could not be read

—1703

errAEWrongDataType

Wrong descriptor type

—1704

errAENotAEDesc

Not a valid descriptor record

—1705

errAEBadListItem

Operation involving a list item failed

—1706

errAENewerVersion

Need a newer version of the Apple Event Manager

—1707

errAENotAppleEvent

Event is not an Apple event

—1708

errAEEventNotHandled

Event wasn’t handled by an Apple event handler

—1709

errAEReplyNotValid

AEResetTimer was passed an invalid reply

-1710

errAEUnknownSendMode

Invalid sending mode was passed

i
S

-1711

errAEWaitCanceled

User canceled out of wait loop for reply or receipt

=

-1712

errAETimeout

Apple event timed out

-1713

errAENoUserInteraction

No user interaction allowed

-1714

errAENotASpecialFunction

Wrong keyword for a special function

—1715

errAEParamMissed

Handler did not get all required parameters

—1716

errAEUnknownAddressType

Unknown Apple event address type

-1717

errAEHandlerNotFound

No handler found for an Apple event or a coercion

-1718

errAEReplyNotArrived

Reply has not yet arrived

-1719

errAEIllegalIndex

Not a valid list index

-3101

buf2SmallErr

Packet too large for buffer; partial data returned

—5012

afpItemNotFound

Information not found

—5030

afpIconTypeError

Size of new icon and one it replaces don’t match

—5550

gestaltUnknownErr

Could not obtain the response

-5551

gestaltUndefSelectorErr

Undefined selector

—5552

gestaltDupSelectorErr

Selector already exists

a

=!

re
wm”
i)
2)

(Continued)

Table A-1: Result Codes

@

A-7

Inside Macintosh,

Table A-1.

Volume VI

Result codes (Continued)

Value

Name

Meaning

—5553

gestaltLocationErr

Function not in system heap

—11000

pictInfoVersionErr

Version number not zero

—11001

pictInfoIDErr

Invalid PictInfo ID

—11002

pictInfoVerbErr

Invalid verb combination specified

—11003

cantLoadPickMethodErr

Custom pick method not in resource chain

—11004

colorsRequestedErr

Number out of range or greater than passed to
NewPictInfo

—11005

pictureDataErr

Invalid picture data

—13000

pmBusyErr

Power Manager IC stuck busy

—13001

pmReplyTOErr

Timed out waiting to begin reply handshake

—13002

pmSendStartErr

Power Manager IC did not start handshake

~13003

pmSendEndErr

During send, Power Manager did not finish
handshake

—13004

pmRecvStartErr

During receive, Power Manager did not start
handshake

—13005

pmRecvEndErr

During receive, Power Manager did not finish

A-8

Table A-1: Result Codes

handshake

APPENDIX B: ROUTINES
MEMORY BEHAVIOR

AND

THEIR

This appendix lists the routines described in this volume of /nside Macintosh according to
their reentrancy and memory behavior.
Table B-1 includes routines that may move or purge memory. You should not call these
routines from within an interrupt, such as in a completion routine or a VBL task.
Table B-2 includes routines that do not move or purge memory, but that for some other
reason you should not call from within an interrupt. For example, these routines may
examine movable memory, or they might not be reentrant.
Table B-3 includes routines that you may call from within an interrupt.
Some routines exhibit different memory behavior when executed synchronously than when
executed asynchronously. These routines are included in more than one list: a single dagger
(+) indicates a synchronous execution of the routine, and a double dagger (+) indicates an
asynchronous execution.
Table B-1.

— Routines that may move or purge memory

AcceptHighLevelEvent
ActivatePalette

AEGetParamDesc

AEGetParamPtr

a

AECoercePtr
AECreateAppleEvent
AECreateDesc
AEGetAttributeDesc
AECreateList
AEDeleteltem
AEDeleteKeyDesc
AEDeleteParam
AEDisposeDesc
AEDuplicateDesc
AEGetArray
AEGetAttributePtr
AEGetCoercionHandler
AEGetEventHandler
AEGetKeyDesc
AEGetKeyPtr
AEGetNthDesc
AEGetNthPtr

AEInstallCoercionHandler
AEInstallEventHandler
AEInstallSpecialHandler
AEInteractWithUser
AEProcessAppleEvent
AEPutArray
AEPutAttributeDesc
AEPutAttributePtr
AEPutDesc
AEPutKeyDesc
AEPutKeyPtr
AEPutParamDesc
AEPutParamPtr
AEPutPtr
AERemoveCoercionHandler
AERemoveEventHandler
AERemoveSpecialHandler
AEResetTimer

=
&

AECoerceDesc

AEGetSpecialHandler

=

(Continued)

B-]

Inside Macintosh,

Table B-1.

Volume

V1

— Routines that may move or purge memory (Continued)

AEResumeTheCurrentEvent

AESend
AESetInteractionAllowed
AESizeOfAttribute
AESizeOfKeyDesc
AESizeOfNthItem

AESizeOfParam
AnimateEntry
AnimatePalette

AppendDITL
AssociateSection
ATPreFlightEvent
BitMapToRegion
CallEditionOpenerProc
CallFormatlOProc

CloseEdition
CMY2RGB
Comp3tol
Comp6to 1
CopyDeepMask
CountDITL

CopyPalette
CreateEditionContainerFile

DBResultsToText
DBSend
DBSendltem

DBStartQuery
DBState
DBUnGetltem
DeleteEditionContainerFile

DeleteUserldentity
DeviceLoop
DisposePalette
EditionHasFormat

Exp|to3
Exp 1to6
FindFolder

FindScriptRun
Fix2SmallFract
FlushFonts

FSpCreateResFile
FSpOpenDF
FSpOpenResFile
FSpOpenRF
GetColor
GetCTable

DBDisposeQuery
DBEnd

GetDefaultUser
GetEditionFormatMark
GetEditionInfo
GetEditionOpenerProc
GetFormatOrder
GetGray

DBExec

GetLastEditionContainerUsed

DBGetConnInfo
DBGetErr
DBGetltem
DBGetNewQuery
DBGetQueryResults

GetNewPalette

DBGetResultHandler

GetSpecificHighLevelEvent

DBGetSessionNum
DBInit

GetStandardFormats
GoToPublisherSection

DBiInstallResultHandler

HasDepth

CTab2Palette

CustomGetFile
CustomPutFile
DBBreak

DBKill
DBRemoveResultHandler

B-2

GetPalette
GetPictInfo
GetPixMapInfo
GetProcessInformation

HCreateResFile
HiliteText

Table B-1: Routines That May Move or Purge Memory

Routines and Their Memory Behavior

Table B-1.

— Routines that may move or purge memory (Continued)

HMBalloonPict
HMBalloonRect

HMExtractHelpMsg
HMGetBalloonWindow

HMGetDialogResID
HMGetFont
HMGetFontSize

HMGetHelpMenuHandle
HMGetIndHelpMsg
HMGetMenuResID
HMIsBalloon
HMRemoveBalloon

HMScanTemplateltems
HMSetBalloons

HMSetDialogResID
HMSetFont
HMSetFontSize
HMSetMenuResID
HMShowBalloon
HMShowMenuBalloon

HOpen
HOpenDF
HOpenResFile
HOpenRF
HSL2RGB
HSV2RGB
InitDateCache
InitDBPack
InitEditionPack
InitGDevice
InitPalettes
InsertSRTRec
IntITokenize

IPCListPorts +
IsOutline

IsRegisteredSection
IsSpecialFont
TUClearCache

1UCompPString
IUEqualPString

[1UGetItITable
[ULangOrder
[ULDateString
IULTimeString
[UMagIDPString
[UMagPString
1UScriptOrder
1UStringOrder
[UTextOrder
LaunchApplication
LaunchDeskAccessory
LowerText
MatchAlias
NChar2Pixel
NDrawJust
NewAlias
NewAliasMinimal
NewAliasMinimalFromFullpath
NewGDevice
NewGestalt
NewGWorld
NewPalette
NewPictInfo
NewPublisherDialog
NewPublisherExpDialog
NewScreenBuffer
NewSection
NewSubscriberDialog
NewSubscriberExpDialog
NewTempScreenBuffer
NFindWord

—
—

~~

o

—~

ose
oe

——
a

m*

9°]
2)

NMeasureJust

NPixel2Char
NPortionText
NSetPalette
OpenCPicture
OpenDF
OpenEdition
OpenNewEdition
OpenWD
(Continued)

Table B-1: Routines That May Move or Purge Memory

B-3

Inside Macintosh, Volume VI

Table B-1.

| Routines that may move or purge memory (Continued)

OutlineMetrics

RGB2HSV

Palette2CTab

SaveBack

PBDTCloseDown

SaveFore

PBDTDelete +
PBDTGetPath
PBDTOpenInform

SectionOptionsDialog
SectionOptionsExpDialog
SetDepth
SetEditionFormatMark
SetEditionOpenerProc

PBDTReset +

PBHOpenDF +
PBOpenDF

SetPalette

PBVolumeMount

SetResourceSize

PmBackColor

SetStylScrap
SGetBlock
SGetCString
SGetDriver
ShortenDITL
SmallFract2Fix

PmForeColor

PostHighLevelEvent
PPCAccept +
PPCBrowser

PPCClose +
PPCEnd 7
PPCInform +

SndAddModifier
SndChannelStatus

PPCOpen +

SndControl

PPCRead +

SndDoCommand

PPCReject +

SndDoImmediate

PPCStart +
PPCWrite +
RawPrinter Values

ReadEdition
ReadPartialResource
RecordColors
RecordPictInfo

RecordPixMapInfo
RegisterSection
ReplaceGestalt
ReplaceText
ResizePalette
ResolveAlias
ResolveAliasFile
RestoreBack
RestoreDeviceClut
RestoreFore

RetrievePictInfo
RGB2CMY
RGB2HSL
B-4

SndNewChannel
SndPlay
SndPlayDoubleBuffer
SndRecord

SndRecordToFile
SndStartFilePlay
SndStopFilePlay
SPBBytesToMilliseconds
SPBCloseDevice
SPBGetDevicelnfo
SPBGetIndexedDevice

SPBMillisecondsToBytes
SPBOpenDevice
SPBRecord
SPBRecordToFile
SPBSetDevicelnfo

SPBSignInDevice
SPBSignOutDevice
StandardGetFile
StandardPutFile

Table B-1: Routines That May Move or Purge Memory

Routines and Their Memory Behavior

Table B-1.

| Routines that may move or purge memory (Continued)

StartSecureSession
Str2Format
String2Date
String2Time
StripText
StripUpperText
StyledLineBreak
SysBeep
TEGetPoint
TEKey
TempMaxMem
TempNewHandle
Table B-2.

TESetStyle
TruncString
TruncText
UnRegisterSection
UpdateAlias
UpdateGWorld
UpperText
VisibleLength
WaitNextEvent
WriteEdition
WritePartialResource

Routines that do not move or purge memory but may not be called
at interrupt time

AECountltems
AEGetInteractionAllowed
AEGetTheCurrentEvent

FSpExchangeFiles
FSpGetFInfo
FSpRename

AESuspendTheCurrentEvent
AllocContig
AllowPurgePixels

FSpSetFInfo
FSpSetFLock
GDeviceChanged

AOn
AOnIgnoreModem
BOff
BOn
CatMove
CloseWD
CTabChanged
DirCreate
DisposeGWorld
DisposPictInfo
DisposeScreenBuffer
DisposGDevice
FSMakeFSSpec
FSpCatMove
FSpCreate
FSpDelete
FSpDirCreate

GetCurrentProcess
GetDeviceList
GetEntryColor
GetEntry Usage
GetGDevice
GetGWorld
GetGWorldDevice
GetLocalZones +
GetMainDevice
GetMaxDevice
GetMyZone +
GetNextDevice
GetOutlinePreferred
GetPixBaseAddr
GetPixelsState
GetPortNameFromProcessSerialNumber
GetPreserveGlyph

AESetTheCurrentEvent

AOff

FSpRstFLock

is
fs

GetAliasInfo

=
y

(Continued)

Table B-2: Routines That Do Not Move or Purge Memory

B-5

Inside Macintosh, Volume VI

Table B-2.

—_ Routines that do not move or purge memory but may not be called
at interrupt time (Continued)

GetProcessSerialNumberFromPortName

PBDTSetComment +

GetZoneList +
HCreate
HDelete
HGetFInfo
HGetVol
HMGetBalloons
HoldMemory
HRename
HRstFLock
HSetFInfo
HSetFLock
HSetVol
LAPAddATQ
LAPRmvATQ
LockPixels
ModemStatus
NoPurgePixels
ParseTable

PBExchangeFiles +
PBHGetVolParms 7
PBMakeFSSpec +
PBResolveFileIDRef +
PBSetForeignPriv 7
PGetAppleTalkInfo +
PixPatChanged
ReadLocation
SetCurrentA5
SetDeviceAttribute
SetEntryColor
SetEntry Usage
SetFrontProcess
SetGDevice
SetGWorld
SetOutlinePreferred
SetPixelsState
SetPreserveGlyph

PBCatSearch 7

TEContinuousStyle

PBCreateFileIDRef +

TECustomHook

PBDeleteFileIDRef +
PBDTAddAPPL +
PBDTAddIcon +
PBDTFlush +
PBDTGetAPPL +
PBDTGetComment +
PBDTGetlcon +
PBDTGetlconInfo +
PBDTGetInfo 7
PBDTRemoveAPPL +
PBDTRemoveComment +

TEFeatureFlag
TempDisposHandle
TempFreeMem
TempHLock
TempHUnlock
TENumStyles
TestDeviceAttribute
ToggleDate
UnlockPixels
ValidDate
WriteLocation

PATalkClosePrep +

B-6

SndDisposeChannel

Table B-2: Routines That Do Not Move or Purge Memory

Routines and Their Memory Behavior

Table B-3.

— Routines that may be called at interrupt time

ATPKillAllGetReq
BatteryStatus
DebuggerEnter
DebuggerExit
DebuggerGetMax
DebuggerLockMemory
DebuggerPoll
DebuggerUnlockMemory
DeferUserFn
Disableldle
DisableWUTime
EAddMulti
EAttachPH
EDelMulti
EDetachPH
EGetInfo
Enableldle
EnterSupervisorMode
ERdCancel
ERead
ESetGeneral
EWrite
Format2Str
FormatStr2X
FormatX2Str
Gestalt
GetCPUSpeed
GetFrontProcess
GetLocalZones *

GetMyZone +
GetNextProcess
GetPageState
GetPaletteUpdates
GetPhysical
GetWDInfo
GetWUTime
GetZoneList +

IdleUpdate
InsTime

InsXTime
IPCListPorts +

LockMemory
LockMemoryContiguous
LongDate2Secs
LongSecs2Date
MACEVersion
NMInstall
NMRemove
OffscreenVersion

PageFaultFatal
PATalkClosePrep +
PBCatSearch +
PBCreateFileIDRef +
PBDeleteFileIDRef +

PBDTAddAPPL +
PBDTAddlIcon ¢
PBDTDelete +

PBDTFlush +
PBDTGetAPPL *

=
Leg

PBDTGetComment +

—_

a

_

PBDTGetlcon +
PBDTGetlconInfo +

Lee)

~

2.=

lon!

wm

PBDTGetlInfo +
PBDTRemoveAPPL

&

PBDTRemoveComment +
PBDTReset +
PBDTSetComment +

PBExchangeFiles +
PBGetForeignPrivs
PBGetVolMountInfo
PBGetVolMountInfoSize
PBHGetVolParms +

PBMakeFSSpec +
PBResolveFileIDRef +

PBSetForeignPriv +
PGetAppleTalkInfo +
PMerVersion
PortChanged
(Continued)

Table B-3: Routines That May Be Called at Interrupt Time

B-7

Inside Macintosh,

Table B-3.

— Routines that may be called at interrupt time (Continued)

PortionText
PPCAccept +
PPCClose +

PPCEnd ¢
PPCInform +
PPCOpen ¢
PPCRead +
PPCReject +
PPCStart +

PPCWrite =
PrimeTime

QDDone
QDError
RmvTime
SameProcess
SCalcSPointer

SCalcStep
SCardChanged
SCkCardStatus
SDeleteSRTRec
SetA5

SetPalette Updates
SetSRsrcState

SetupAIFFHeader
SetupSndHeader
SetWUTime
SExec
SFindDevBase
SFindSInfoRecPtr
SFindSRsrcPtr

SFindStruct
SGetSRsre
SGetTypeSRsrc
SleepQInstall

B-8§

Volume VI

SleepQRemove
SndGetSysBeepState
SndManagerStatus
SndPauseFilePlay
SndSetSysBeepState
SndSoundManagerVersion
SNextRsrc
SNextTypeSRsrc
SOffsetData
SPBGetRecordingStatus
SPBPauseRecording
SPBResumeRecording
SPBStopRecording
SPBVersion
SPtrToSlot
SPutPRAMRec
SReadByte
SReadDrvrName
SReadFHeader
SReadInfo

SReadLong

SReadPBSize
SReadPRAMRec
SReadStruct
SReadWord
SRsrcInfo
SSearchSRT
StripAddress
SVersion
Translate24To32
UnholdMemory
UnlockMemory
WakeUpProcess

Table B-3: Routines That May Be Called at Interrupt Time

APPENDIX

C: SYSTEM

TRAPS

This appendix includes four tables listing the system traps and routines described in this
volume of /nside Macintosh.
The first two tables list all of the system traps. Table C-1 lists them in alphabetical order by
trap name and Table C-2 lists them in numerical order by trap word. If the name of the
equivalent Pascal routine is different from the trap name, these tables list the Pascal name in
parentheses under trap name.
The next two tables list the system traps that take selectors and the routines selected from them.
Table C-3 lists the traps that take selectors in alphabetical order by trap name. For each
system trap, the Routine column lists the routines selected from the trap and the Selector
column lists the corresponding selector. The routines are listed in numerical order by their
selector value.

Table C-4 lists the routines from Table C-3 in alphabetical order by routine name. For each
routine, the Trap name column lists the corresponding trap name and the Selector column lists
the routine’s selector.
Table C-1.

| System traps by trap name

Trap name

Trap
word

Trap name

_ActivatePalette

S$AA94

_FontDispatch

$A854

_AliasDispatch

$A823

_Gestalt

$AIAD

_AllocContig

$A210

_GetCTable

$AA18

_AnimateEntry

$AA99

_GetDeviceList

$AA29

_AnimatePalette

S$AADA

_GetEntryColor

$AA9B

_BitMapToRegion

$A8D7

_GetEntryUsage

$AA9D

_CommToolboxDispatch

$A08B

_GetGDevice

$AA32

_CopyDeepMask

$AAS1

_GetMainDevice

$S$AA2A

_CopyPalette

SAAAI

_GetMaxDevice

$AA27

_CTab2Palette

SAAQF

_GetNewPalette

$AA92

_DebugUtil

$A08D

_GetNextDevice

$AA2B

_DeferUserFn

$SA08F

_GetPalette

$AA96

_DeviceLoop

$ABCA

_HCreate

$A208

_DisposePalette

$AA93

_HCreateResFile

$A81B

_HDelete

$A209

_DisposGDevice

*

— $AA30

Trap
word

>

~~

—e

—_

igo]
oO

~
2.

te

ws
ig?)
n

(Continued)

C-1

Inside Macintosh,

Volume

V1

Table C-1.

| System traps by trap name (Continued)

Trap name

word

Trap name

_HFSDispatch

$A060

_Pack11

$A82D

_HGetVol

$A214

_Pack12

_HighLevelFSDispatch

$AA52

_Pack13

$A82E
$A82F

_HOpen

$A200

_Pack14

$A830

_HOpenResFile

SA8IA

_Pack15

$A831

_HOpenRF

$A20A

_Palette2CTab

$AAAO0

_HRename

$A20B

_PaletteDispatch

$AAA2

_HRstFLock

$A242

_PmBackColor

$AA98

_HSetFLock

$A241

_PmForeColor

$AA97

_HSetVol

$A215

_PPC

_IdleState

$AODD

$A485

_PrimeTime

$A05A

_IdleUpdate

$A285

_QDError

$AA40

_InitGDevice

$AA2E

_QDExtensions

$ABID

_InitPalettes

$AA90

_InsTime
_InsXTime

_ReadXPRam

$A051

$A058
$A458

$A5AD

_LaunchApplication

_ReplaceGestalt
_ResourceDispatch

$A822

$A9F2

_LowerText

_RmvTime

$A056

$A059

_MemoryDispatch

_ScriptUtil

$A0SC

$A8B5

_SerialPower

_MemoryDispatchAOResult

$A685

$A15C

_NewGDevice

_SetDeviceAttribute

$AA2D

$AA2F

_NewGestalt

$A3AD

_SetEntryColor
_SetEntry Usage

_NewPalette

$AA9C
$AA9E

$AA9!

_NMiInstall

_SetGDevice

$A05E

$AA31

_SetPalette

$AA95

_NMRemove

Trap

Trap

word

_NSetPalette

SAA95

$AO5F

_SIpQInstall

_OpenCPicture

$AA20

oa

SAASA

—OSDispatch

SA88F

_SlotManager

$A06E

nies

aSoEA

(SleepQInstall)

_SndAddModifier

$A28A

$A802

= aimee

SASED

_SndControl

Packs

$A806

$A816

_SndDisposeChannel

SA801

aiid
C-2

pe

_SndDoCommand

Table C-1: System Traps by Trap Name

$A803

System Traps

Table C-1.

| System traps by trap name (Continued)

Trap name

Trap
word

Trap name

Trap
word

_SndDoImmediate

$A804

_TEDispatch

$A83D

_SndNewChannel
_SndPlay

$A807
$A805

_TEKey
_TestDeviceAttribute

$A9DC
$AA2C

_SoundDispatch

$A800

_Translate24To032

$A191

_StripAddress

$A055

_UpperText

$A456

_StripText

$A256

_WaitNextEvent

$A860

_StripUpperText

$A656

_WriteXPRam

$A052

_SysBeep

$A9C8

Table C-2.

System traps by trap word

Trap
word

Trap name

Trap
word

Trap name

$A05 1
$A052
$A055
$A056
$A058

_ReadXPRam
_WriteXPRam
_StripAddress
_LowerText
_InsTime

$A209
$A20A
$A20B
$A210
$A214

_HDelete
_HOpenRF
_HRename
_AllocContig
_HGetVol

$A059

_RmvTime

$A215

_HSetVol

$AOS5A

_PrimeTime

$A241

_HSetFLock

$A05C

_MemoryDispatch

$A242

_HRstFLock

$A05E

_NMtInstall

$A256

_StripText

$AO5F

_NMRemove

$A285

_IdleUpdate

$A060

_HFSDispatch

$A28A

_SIpQInstall

$A06E

_SlotManager

$A08B

_CommToolboxDispatch

$A3AD

_NewGestalt

SAO8F
$A0DD

_DeferUserFn
_PPC

$A458
$A485

_InsXTime
_IdleState

SAISC

_MemoryDispatchAOResult

SA48A

Bicep

$A191

_Translate24To32

SA5AD

_ReplaceGestalt

ininuiad
$A200

Gestalt
_HOpen

$A656

_StripUpperText

$A208

_HCreate

$A08D

_DebugUtil

>

a

Ld

ro
~

me
34
o

i 9)

(SleepQInstall)

$A456

—UpperText

Remove)

(Continued)

Table C-2: System Traps by Trap Word

C-3

Inside Macintosh,

Table C-2.

Volume V1

| System traps by trap word (Continued)

Trap
word

Trap name

Trap
word

Trap name

$A685

_SerialPower

$AA2A

_GetMainDevice

$A800

_SoundDispatch

$AA2B

_GetNextDevice

$A801

_SndDisposeChannel

$AA2C

_TestDeviceAttribute

$A802

_SndAddModifier

$AA2D

_SetDeviceAttribute

$A803

_SndDoCommand

$AA2E

_InitGDevice

$A804

_SndDoImmediate

$AA2F

_NewGDevice

$A805

_SndPlay

$AA30

_DisposGDevice

$A806

_SndControl

$AA31

_SetGDevice

$A807

_SndNewChannel

$AA32

_GetGDevice

$A816
$SA81A
$A81B

_Pack8
_HOpenResFile
_HCreateResFile

$AA40
$AAS5I
$AA52

_QDError
_CopyDeepMask
_HighLevelFSDispatch

$A823

_AliasDispatch

$AA90

_InitPalettes

$A82B

_Pack9

$AA91

_NewPalette

$A82D

_Pack11

$AA92

_GetNewPalette

$A82E

_Pack12

$AA93

_DisposePalette

$A82F

_Pack13

$AA94

_ActivatePalette

$A830

_Pack14

$AA95

_NSetPalette

$A83 1

_Pack15

$AA95

_SetPalette

$A83D
$A854

_TEDispatch
_FontDispatch

$AA96
$AA97

_GetPalette
_PmForeColor

$A860

_WaitNextEvent

SAA98

_PmBackColor

$A88F

_OSDispatch

$AA99

_AnimateEntry

$A8B5

_ScriptUtil

SAAIA

_AnimatePalette

$A8D7
$A9C8
$AIDC

_BitMapToRegion
_SysBeep
_TEKey

$A9NEA

_Pack3

$AA9B
$AA9C
$AA9D
$AA9E

_GetEntryColor
_SetEntryColor
_GetEntryUsage
_SetEntryUsage

$A9ED

_Pack6

$AA9F

_CTab2Palette

$A9F2
$AA18

_LaunchApplication
_GetCTable

$AAA0
$AAAI

_Palette2CTab
_CopyPalette

$AA20

_OpenCPicture

$AAA2

_PaletteDispatch

$AA27
$AA29

_GetMaxDevice
_GetDeviceList

SABID
SABCA

_QDExtensions
_DeviceLoop

C-4

Table C-2: System Traps by Trap Word

System Traps

Table C-3.

System

System traps that take selectors

trap

Selector

Routine

$0000
$0002
$0003
$0005
$0006
$0007
$0008
$0009
$000C

FindFolder

_CommToolboxDispatch
$A08B

$0402
$0403
$0404

AppendDITL

_DebugUtil
$A08D

$0000
$0001
$0002
$0003
$0004
$0005
$0006
$0007
$0008

DebuggerGetMax
DebuggerEnter
DebuggerExit
DebuggerPoll
GetPageState
PageFaultFatal
DebuggerLockMemory
DebuggerUnlockMemory
EnterSupervisorMode

$0000
$0001
$0008
$0009
$000A
$000B
$000C

IsOutline

$0001
$0002
$0005
$0006
$0007

OpenWD
CloseWD

_AliasDispatch
$A823

_FontDispatch

$A854

_HFSDispatch
$A060

$0014
$0015

NewAlias
ResolveAlias
MatchAlias

UpdateAlias
GetAliasInfo
NewAliasMinimal

NewAliasMinimalFromFullpath
ResolveAliasFile

CountDITL
ShortenDITL

>

S
—

—_

O
=

=,
Pal

oO
wa

SetOutlinePreferred
OutlineMetrics

GetOutlinePreferred
SetPreserveGlyph
GetPreserveGlyph
FlushFonts

CatMove
DirCreate
GetWDInfo
PBCreateFileIDRef
PBDeleteFileIDRef
(Continued)

Table C-3: System Traps That Take Selectors

C-5

Inside Macintosh,

Table C-3.
System

Volume VI

| System traps that take selectors (Continued)

trap

_HFSDispatch (Continued)

$A060

Selector

Routine

$0016

PBResolveFileIDRef

SOOLA
$OO1A

OpenDF
PBHOpenDF

$0017
$0018

PBExchangeFiles
PBCatSearch

$001A
$001B
$0020
$0021
$0022
$0023
$0024

_HighLevelFSDispatch

$AA52

$0025

PBDTAddAPPL

$0026
$0027

PBDTRemoveAPPL
PBDTGetAPPL

$0028
$0029
$002A
$002B
$002C
$002D
$002E
$002F
$0030
$003F
$0040
$0041
$0060
$0061

PBDTSetComment
PBDTRemoveComment
PBDTGetComment
PBDTFlush
PBDTReset
PBDTGetInfo
PBDTOpenInform
PBDTDelete
PBHGetVolParms
PBGetVolMountInfoSize
PBGetVolMountInfo
PBVolumeMount
PBGetForeignPrivs
PBSetForeignPrivs

$0001

FSMakeFSSpec

$0002

$0003
$0004
$0005
$0006
$0007

$0008

$0009
$OO0A
C-6

PBOpenDF
PBMakeFSSpec
PBDTGetPath
PBDTCloseDown
PBDTAddlIcon
PBDTGetlIcon
PBDTGetlIconInfo

FSpOpenDF

FSpOpenRF
FSpCreate
FSpDirCreate
FSpDelete
FSpGetFInfo

FSpSetFInfo

FSpSetFLock
FSpRstFLock

Table C-3: System Traps That Take Selectors

System Traps

Table C-3.

System

System traps that take selectors (Continued)

trap

Selector

Routine

_HighLevelFSDispatch (Continued)

$000B
$000C
$000D
$000E
$000F

FSpRename
FSpCatMove
FSpOpenResFile
FSpCreateResFile
FSpExchangeFiles

_IdleState

$SFFFF
$0000
$0001

GetCPUSpeed

_MemoryDispatch

$0000
$0001
$0002
$0003
$0004

HoldMemory
UnholdMemory
LockMemory
UnlockMemory
LockMemoryContiguous

_MemoryDispatchAOResult
$AISC

$0005

GetPhysical

_OSDispatch

$0015
$0016

TempMaxMem
TempTopMem
TempFreeMem
TempNewHandle
TempHLock
TempHUnlock
TempDisposeHandle
AcceptHighLevelEvent
PostHighLevelEvent
GetProcessSerialNumberFromPortName
LaunchDeskAccessory
GetCurrentProcess
GetNextProcess
GetFrontProcess
GetProcessInformation
SetFrontProcess
WakeUpProcess
SameProcess
GetSpecificHighLevelEvent
GetPortNameFromProcessSerialNumber

$AA52

$A485

$A05C

$A88F

$0018

$001D
$001E
$O01F
$0020
$0033
$0034
$0035
$0036
$0037
$0038
$0039

$003A
$003B

$003C
$003D
$0045
$0046

Enableldle
Disableldle

(Continued)

Table C-3: System Traps That Take Selectors

C-7

~~
»~
—
_
—
—_

@

=

—_

=m)
—
—

ws

ig?)
N

Inside Macintosh,

Table C-3.
System

_Pack3
$A9EA

trap

Volume VI

| System traps that take selectors (Continued)
Selector

Routine

$0005
$0006

StandardPutFile
StandardGetFile

$0007

CustomPutFile

$0014
$0016

[ULDateString
IULTimeString

$0018

IUClearCache

$0008

_Pack6
$A9ED

CustomGetFile

$001A
$001C
$OOIE
$0020

IUMagPString
[UMagIDPString
IUScriptOrder
IULangOrder

$0024

1UGetItlTable

$SOL1E

AESetInteractionAllowed

$0022
_Pack8

$A816

IUTextOrder

$0204

AEDisposeDesc

$0219
$021A

AEResetTimer
AEGetTheCurrentEvent

$022C

AESetTheCurrentEvent

$021B
$021D
$022B

$0405
$0407
$040E
$0413

AEDuplicateDesc
AECountItems
AEDeleteItem
AEDeleteKeyDesc

$0413
$0500

AEDeleteParam
AEInstallSpecialHandler

$0603

AECoerceDesc

$0609

AEPutDesc

$0501
$052D
$0610

$0610
$061C

$0627
$0706

$0720
$0723

C-§

AEProcessAppleEvent
AEGetInteractionAllowed
AESuspendTheCurrentEvent

AERemoveSpecialHandler
AEGetSpecialHandler
AEPutKeyDesc

AEPutParamDesc
AEInteractWithUser

AEPutAttributeDesc
AECreateList

AERemoveEventHandler
AERemoveCoercionHandler

Table C-3: System Traps That Take Selectors

System Traps

Table C-3.
System

| System traps that take selectors (Continued)

trap

_Pack8 (Continued)
$A816

Selector

Routine

$0812
$0812
$0818
$0825
$0826
$0828
$0829
$0829
$082A
$O091F
$0921
$0A02
$0A08
$0A16
$0A22
$O0A0B
$OAOF

AEGetKeyDesc

$0A0F

_Pack9

AEGetParamDesc
AEResumeTheCurrentEvent
AECreateDesc

AEGetAttributeDesc
AESizeOfAttribute
AESizeOfKeyDesc
AESizeOfParam
AESizeOfNthItem
AEInstallEventHandler

AEGetEventHandler
AECoercePtr
AEPutPtr

AEPutAttributePtr
AEInstallCoercionHandler
AEGetNthDesc

AEPutKeyPtr
AEPutParamPtr

$O0BOD
$0B 14
$0B24
$0D0C
$0D17
$0E11
$0E11
$0E15
$100A

AEPutArray
AECreateAppleEvent

$0D00

PPCBrowser

$0100
$0206
$0208
$0210
$0224
$0226
$022A
$022C

InitEditionPack
UnRegisterSection
IsRegisteredSection
DeleteEditionContainerFile
GoToPublisherSection
GetLastEditionContainerUsed
GetEditionOpenerProc
SetEditionOpenerProc

>
<<)
cS

c)

om)
=
m

AEGetCoercionHandler

AEGetArray

9°]
i)

AESend

AEGetKeyPtr
AEGetParamPtr

AEGetAttributePtr
AEGetNthPtr

$A82B
_Pack11
$A82D

(Continued)

Table C-3: System Traps That Take Selectors

Cc-9

Inside Macintosh,

Table C-3.

Volume VI

| System traps that take selectors (Continued)

System

trap

Selector

Routine

_Pack11

(Continued)

$0232

NewSubscriberDialog
NewPublisherDialog
SectionOptionsDialog
CloseEdition

$A82D

$0236
$023A
$0316
$040C

AssociateSection

OpenEdition
GetEditionInfo
CreateEditionContainerFile
CallEditionOpenerProc
CallFormatlOProc
RegisterSection
EditionHasFormat
GetEditionFormatMark
SetEditionFormatMark
OpenNewEdition
ReadEdition
WriteEdition
NewSection
GetStandardFormats
NewSubscriberExpDialog
NewPublisherExpDialog
SectionOptionsExpDialog

$0412
$0422
$050E
$052E
$0530
$0604
$0618
$061E
$0620
$0814
$O81A
$081C
$OA02
$0A28
$0B34
$0B38
$0B3C

_Pack12
$A82E

$0001
$0002
$0003
$0004
$0005
$0006

Fix2SmallFract
SmallFract2Fix

$0008
$0009

CMY2RGB
RGB2CMY
HSL2RGB
RGB2HSL
HSV2RGB
RGB2HSV
GetColor

_Pack13

$0100

$A82F

$020E
$0210
$0215
$030F
$0403
$0408

InitDBPack

$0007

C-10

DBKill
DBDisposeQuery
DBRemoveResultHandler

DBGetNewQuery
DBEnd
DBExec

Table C-3: System Traps That Take Selectors

System Traps

Table C-3.

| System traps that take selectors (Continued)

System

trap

Selector

Routine

_Pack13

(Continued)

$0409
$040D
$0413
$050B
$0514
$0516
$0605
$0706
$0811
$0A12
$0B07
$0E02
SOEOA
$100C
$1704

DBState

$0002
$0003
$0007
$0104
$0108
$0109
$010C
$0200
$020A
$020B
$020D
$0213
$0215
$0314
$040E
$040F
$0410
$0711
$OBO1
$0E05
$1306

HMRemoveBalloon

$A82F

_Pack14
$A830

DBUnGetltem
DBResultsToText
DBBreak
DBInstallResultHandler

DBGetResultHandler
DBGetSessionNum
DBSend

DBStartQuery
DBGetQueryResults
DBSendItem
DBInit
DBGetErr
DBGetltem
DBGetConnInfo

HMGetBalloons
HMIsBalloon
HMSetBalloons

—
ne

sd

HMSetFont

@
—

—_

a
pute
1

HMSetFontSize
HMSetDialogResID
HMGetHelpMenuHandle

9°]

a

HMGetFont

HMGetFontSize
HMSetMenuResID

HMGetDialogResID
HMGetBalloonWindow
HMGetMenuResID
HMBalloonRect
HMBalloonPict

HMScanTemplateltems
HMExtractHelpMsg
HMShowBalloon
HMShowMenuBalloon

HMGetIndHelpMsg
(Continued)

Table C-3: System Traps That Take Selectors

C-11

Inside Macintosh, Volume V1

Table C-3.
System

| System traps that take selectors (Continued)

trap

_Pack15

$A83 |

_PaletteDispatch
$AAA2

PPC
$A0DD

C-12

Routine

$0206
$0403
$0404
$0505
$0602
$0800
$0801

DisposPictInfo
RecordPictInfo
RecordPixMapInfo
RetrievePictInfo
NewPictInfo
GetPictInfo
GetPixMapInfo

$0002
$0003
$0015
$040D
$040E
$040F
$0410
$0417
$0616
$0A 13
SOA 14
$1219

RestoreDeviceClut

$0000
$0001
$0002
$0003
$0004
$0005
$0006
$0007
$0008
$0009
$OO0A
$000C
$000D
$O00E

_QDExtensions

$ABID

Selector

$0000
$0001
$0002
$0003
$0004

ResizePalette

PMerVersion
SaveFore
SaveBack
RestoreFore
RestoreBack

GetPaletteUpdates
SetPaletteUpdates
SetDepth
HasDepth
GetGray
PPCInit
PPCOpen
PPCStart
PPCInform

PPCAccept
PPCReject
PPCWrite
PPCRead

PPCEnd
PPCClose

IPCListPorts
DeleteUserldentity
GetDefaultUser
StartSecureSession

NewGWorld
LockPixels
UnlockPixels
UpdateGW orld
DisposeGWorld

Table C-3: System Traps That Take Selectors

System Traps

Table C-3.

System

System traps that take selectors (Continued)

trap

_QDExtensions (Continued)
$ABID

_ResourceDispatch
$A822

Selector

Routine

$0005
$0006
$0007
$0008
$0009
$O00A
$000B
$000C
$000D
$000E
$000F
$0010
$0011
$0012
$0013
$0014
$0015

GetGWorld
SetGWorld
CTabChanged
PixPatChanged
PortChanged
GDeviceChanged
AllowPurgePixels
NoPurgePixels
GetPixelsState
SetPixelsState
GetPixBaseAddr
NewScreenBuffer
DisposeScreenBuffer
GetGWorldDevice
QDDone
OffscreenVersion
NewTempScreenBuffer

$0001
$0002
$0003

ReadPartialResource
WritePartialResource

~
—

(=)

—

—_

SetResourceSize

@

_—

a

~
—e
”
®
—

_ScriptUtil
$A8B5

$8008FFFO
$8008 FFF2
$800E001C
$8012FFE2
$8012FFFC
$80160032
$801A0034
$8202002A
$82040022
$8204FFF8
$8204FFFA
$8208FFEO
$820C0026
$820CFFDC
$820CFFDE
$820CFFE4
$820CFFEC

LongSecs2Date
LongDate2Secs

i 2

HiliteText

NFindWord
GetFormatOrder
NDraw/Just
NMeasureJust

IsSpecialFont
ParseTable
InitDateCache
IntITokenize

TruncString
FindScriptRun
ReplaceText
TruncText
ValidDate
Str2Format
(Continued)

Table C-3: System Traps That Take Selectors

C-13

Inside Macintosh,

Table C-3.
System

Volume VI

| System traps that take selectors (Continued)

trap

Selector

Routine

_ScriptUtil (Continued)

$820EFFEE

ToggleDate

$82 1OFFE8
$82 |OFFEA

FormatX2Str
Format2Str

$82 14FFF6

String2Date

$8216002C
$82 1C0030

RawPrinterValues
NChar2Pixel

$8222002E

NPixel2Char

$84080024
$84080028
$84120036

PortionText
VisibleLength
NPortionText

$0000
$0004

BOn
AOn

$0080
$0084

BOff
AOff

$0000
$0001

SReadByte
SReadWord

$0003
$0005
$0006
$0007
$0008
$0009
$O000A
$000B

SGetCString
SGetBlock
SFindStruct
SReadStruct
SVersion
SetSRsrcState
InsertSRTRec
SGetSRsrc

$A8B5

$82 10FFE6

$82 14FFF4

$82 1CFFFE

_SerialPower
$A685

_SlotManager
$A06E

$0005

$0002

$000C

String2Time

StyledLineBreak

AOnIgnoreModem

SReadLong

SGetTypeSRsrc

$0010
$0011

SReadInfo
SReadPRAMRec

$0012

SPutPRAMRec

$0013
$0014

SReadFHeader
SNextRsre

$0016
$0018

SRsrcInfo
SCkCardStatus

$0015

C-14

FormatStr2X

SNextTypeSRsrc

Table C-3: System Traps That Take Selectors

System Traps

Table C-3.

System

| System traps that take selectors (Continued)

trap

Selector

Routine

_SlotManager (Continued)

$0019
$001B
$0022
$0023
$0024
$0026
$0028
$002A
$002B
$002C
$002D
$002E
$002F
$0030
$0031

SReadDrvrName

$00000010
$00000014
$00040010
$00080010
$00 100008
$00100010
$000C0008
$000C0010
$00140008
$00180008
$001C0008
$00200008
$01100014
$02040008
$021C0014
$02280014
$022C0014
$02300014
$03080008
$030C0014
$03200014
$04240014
$04400014

MACE Version
SPBVersion
Comp3tol
Exp|to3
SndChannelStatus
Exp1to6
SndSoundManagerVersion
Comp6tol
SndManagerStatus
SndGetSysBeepState
SndSetSysBeepState
SndPlayDoubleBuffer
SPBSignOutDevice
SndPauseFilePlay
SPBCloseDevice
SPBPauseRecording
SPBResumeRecording
SPBStopRecording
SndStopFilePlay
SPBSignInDevice
SPBRecord
SPBRecordToFile
SPBMillisecondsToBytes

$A06E

_SoundDispatch

$A800

SFindDevBase

SCardChanged
SExec
SOffsetData

SReadPBSize
SCalcStep
SSearchSRT
SUpdateSRT
SCalcsPointer
SGetDriver

SPtrToSlot
SFindSInfoRecPtr
SFindSRsrcPtr
SDeleteSRTRec

4

~~

.)
—
—

<7
=

S.
—wn

@
~”

(Continued)

Table C-3: System Traps That Take Selectors

C-15

Inside Macintosh, Volume VI

| System traps that take selectors (Continued)

Table C-3.
System

trap

_SoundDispatch (Continued)
$A800

Selector

Routine

$044400 14
$05 140014

SPBBytesToMilliseconds
SPBGetIndexedDevice

$06380014

SPBGetDevicelInfo

$05 180014

$063C0014

SPBSetDevicelnfo

$07080014

SndRecordToFile

$08040014

SndRecord

$0D000008

SndStartFilePlay

$0001

TESetStyle

$000C

TECustomHook

$0B4C0014
$0D480014
$0E340014

_TEDispatch

SetupAIFFHeader
SetupSndHeader
SPBGetRecordingStatus

TEGetPoint
TEContinuousStyle
SetStylScrap

$0008
$000A
$000B

$A83D

SPBOpenDevice

TENumStyles

$000D

TEFeatureFlag

$000E

— Routines selected from system traps

Table C-4.

Trap name

Selector

AcceptHighLevelEvent

_OSDispatch

$0033

AECreateAppleEvent

_Pack8

$0B14

Routine

name

AECoerceDesc
AECoercePtr
AECountltems

AECreateDesc
AECreateList
AEDeleteltem
AEDeleteKeyDesc
AEDeleteParam
AEDisposeDesc

AEDuplicateDesc

AEGetArray

AEGetAttributeDesc

AEGetAttributePtr
AEGetCoercionHandler
AEGetEventHandler

C-16

_Pack8
_Pack8
_Pack8

_Pack8
_Pack8
_Pack8
_Pack8

$0603
$OA02
$0407
$0825
$0706
$040E
$0413

_Pack8

$0413

_Pack8

$0204

_Pack8

$0405

_Pack8

$0826

_Pack8
_Pack8

$0E15
$0B24

_Pack8&

$0921

_Pack8

Table C-4:; Routines Selected From System Traps

$ODO0C

System Traps

Table C-4.
Routine

—_ Routines selected from system traps (Continued)

name

Trap name

Selector

_Pack8

$021D

_Pack8
_Pack8

$08 12
$OE11

_Pack8

$OAOB

_Pack8
_Pack8

$100A
$0812

_Pack8
_Pack8
_Pack8

$0E1 I
$052D
$021A

_Pack8
_Pack8
_Pack8
_Pack8
_Pack8

$0A22
$O91F
$0500
$061C
$021B

_Pack8

$OBOD

AEPutAttributePtr

_Pack8
_Pack8

$0627
$0A16

AEPutDesc

_Pack8

$0609

AEPutKeyDesc
AEPutKeyPtr

_Pack8

$0610

_Pack8
_Pack8&

SOAOF
$0610

AEPutParamPtr
AEPutPtr

_Pack8

$OAOF

_Pack8

$OA08

AERemoveCoercionHandler

_Pack8

$0723

AERemoveEventHandler

_Pack8
_Pack8
_Pack8
_Pack8
_Pack8

$0720
$0501
$0219
$0818
$0D17

_Pack8

SOLIE

_Pack8
_Pack8
_Pack8
_Pack8
_Pack8
_Pack8
_QDExtensions

$022C
$0828
$0829
$082A
$0829
$022B
$000B

_SerialPower

$0084

AEGetInteractionAllowed
AEGetKeyDesc
AEGetKeyPtr
AEGetNthDesc
AEGetNthPtr
AEGetParamDesc
AEGetParamPtr

AEGetSpecialHandler
AEGetTheCurrentEvent
AEInstallCoercionHandler
AEInstallEventHandler

AEInstallSpecialHandler
AEInteractWithUser

AEProcessAppleEvent
AEPutArray
AEPutAttributeDesc

AEPutParamDesc

AERemoveSpecialHandler
AEResetTimer
AEResumeTheCurrentEvent
AESend
AESetInteractionAllowed
AESetTheCurrentEvent
AESizeOfAttribute

AESizeOfKeyDesc
AESizeOfNthItem
AESizeOfParam

AESuspendTheCurrentEvent
AllowPurgePixels
AOff

>
—

—

ss
~
@
—
—

eS

—

rT

ww

@
i? 2)

(Continued)

Table C-4: Routines Selected From System Traps

C-17

Inside Macintosh, Volume VI

Table C-4.

— Routines selected from system traps (Continued)
Trap name

Selector

AOn
AOnIgnoreModem
AppendDITL
AssociateSection
BOff

_SerialPower
_SerialPower

BOn

_SerialPower
_Packl 1

$0004
$0005
$0402
$040C
$0080
$0000
$052E
$0530
$0005
$0316
$0002
$0003
$00040010
$000C0010
$0403
$0O50E
$0007
$0008
$0007
$050B
$0210
$0403
$0408
$1704
$OEOA
$100C
$030F
$0A 12
$05 16
$0605
$0E02
$0514
$020E
$0215
$0413
$0706
$0B07
$0811
$0409

Routine

name

CallEditionOpenerProc

_CommToolboxDispatch
_Packl1

_SerialPower

CallFormatlOProc
CatMove
CloseEdition
CloseWD

_Pack11

CMY2RGB
Comp3to!
Comp6to!

_Pack12
_SoundDispatch

CountDITL

_CommToolboxDispatch

CreateEditionContainerFile
CTabChanged

_HFSDispatch
_Pack1 1
_HFSDispatch

_SoundDispatch
_Pack!

|

CustomPutFile

_QDExtensions
_Pack3
_Pack3

DBBreak

_Pack13

DBDisposeQuery
DBEnd

_Pack13

CustomGetFile

DBExec
DBGetConnInfo
DBGetErr
DBGetltem

DBGetNewQuery
DBGetQueryResults
DBGetResultHandler
DBGetSessionNum
DBInit
DBInstallResultHandler

DBKill
DBRemoveResultHandler
DBResultsToText
DBSend
DBSendItem

DBStartQuery
DBState

C-18

_Pack13
_Pack13
_Pack13
_Pack13
_Pack13
_Pack13
_Pack13

_Pack13
_Pack13
_Pack13
_Pack13
_Pack13
_Pack13
_Pack13
_Pack13
_Pack13
_Pack13
_Pack13

Table C-4; Routines Selected From System Traps

System Traps

Table C-4.
Routine

—_ Routines selected from system traps (Continued)
name

DBUnGetltem
DebuggerEnter
DebuggerExit
DebuggerGetMax
DebuggerLockMemory
DebuggerPoll
DebuggerUnlockMemory
DeleteEditionContainerFile
DeleteUserldentity
DirCreate
Disableldle
DisposeG World
DisposPictInfo
DisposeScreenBuffer
EditionHasFormat
Enableldle
EnterSupervisorMode
Exp|to3
Exp1to6
FindFolder
FindScriptRun
Fix2SmallFract
FlushFonts
Format2Str
FormatStr2X
FormatX2Str
FS MakeFSSpec
FSpCatMove
FSpCreate
FSpCreateResFile
FSpDelete
FSpDirCreate
FSpExchangeFiles
FSpGetFInfo
FSpOpenDF
FSpOpenResFile
FSpOpenRF
FSpRename

Trap name

Selector

_Pack13

$040D
$0001
$0002
$0000
$0006
$0003
$0007
$0210
$000C
$0006
$0001
$0004
$0206
$0011
$0618
$0000
$0008
$00080010
$00100010

_DebugUtil
_DebugUtil
_DebugUtil
_DebugUtil

_DebugUtil
_DebugUtil
_Pack11

PEC
_HFSDispatch
_IdleState

_QDExtensions
_Pack15

_QDExtensions
_Pack1 1
_IdleState
_DebugUtil
_SoundDispatch

_SoundDispatch
_AliasDispatch
_ScriptUtl
_Pack12
_FontDispatch
_ScriptUtil

_ScriptUtil
_ScriptUtil
_HighLevelFSDispatch

_HighLevelFSDispatch
_HighLevelFSDispatch
_HighLevelFSDispatch
_HighLevelFSDispatch
_HighLevelFSDispatch
_HighLevelFSDispatch

_HighLevelFSDispatch
_HighLevelFSDispatch
_HighLevelFSDispatch
_HighLevelFSDispatch
_HighLevelFSDispatch

>

—
—@
=
=

$0000

$820C0026
$0001
$000C
$82 10FFEA
$82 1O0FFE6
$82 1OFFE8
$0001
$000C
$0004
$000E
$0006
$0005
$O00F
$0007

ws
is*)

i 2)

$0002

$000D
$0003
$000B
(Continued)

Table C-4: Routines Selected From System Traps

C-19

Inside Macintosh,

Table C-4.

Volume VI

Routines selected from system traps (Continued)
Trap name

Selector

GetColor

_HighLevelFS Dispatch
_HighLevelFS Dispatch
_HighLevelFS Dispatch
_QDExtensions
_AliasDispatch
_Pack12

GetCPUSpeed

_IdleState

GetCurrentProcess
GetDefaultUser

_OSDispatch

GetEditionFormatMark
GetEditionInfo

_Pack11

$000A
$0008
$0009
$000A
$0007
$0009
$FFFF
$0037
$000D
$061E

GetEditionOpenerProc

_Pack11

GetFormatOrder

_ScriptUtil

GetFrontProcess
GetGray
GetGWorld

_OSDispatch

Routine

name

FSpRstFLock
FSpSetFInfo
FSpSetFLock
GDeviceChanged
GetAliasInfo

GetGWorldDevice
GetLastEditionContainerUsed
GetNextProcess

_PPC
_Pack11

_PaletteDispatch
_QDExtensions
_QDExtensions
_Packl1

GetPageState
GetPaletteUpdates
GetPhysical

_OSDispatch
_FontDispatch
_DebugUtil
_PaletteDispatch
_MemoryDispatchAOResult

GetPictInfo

_Pack15

GetPixBaseAddr

_QDExtensions

GetOutlinePreferred

GetPixelsState

GetPixMapInfo
GetPortNameFromProcessSerialNumber

GetPreserveGlyph
GetProcessInformation
GetProcessSerialNumberFromPortName

GetSpecificHighLevelEvent
GetStandardFormats
GetWDInfo
GoToPublisherSection

HasDepth

HiliteText
HMBalloonPict

C-20

_QDExtensions

_Pack15
_OSDispatch
_FontDispatch
_OSDispatch
_OSDispatch

_OSDispatch
_Pack11

_HFSDispatch
_Pack11

_PaletteDispatch
_ScriptUtil
_Pack14

Table C-4: Routines Selected From System Traps

$0422

$022A
$8012FFFC
$0039
$1219
$0005
$0012
$0226
$0038
$0009
$0004

$0417

$0005
$0800
$000F
$000D
$0801
$0046
$000B
$003A
$0035
$0045
$0A28
$0007
$0224
$0A14
$800E001C
$040F

System Traps

Table C-4.
Routine

—_ Routines selected from system traps (Continued)
name

Trap name

Selector

HMBalloonRect

_Pack14

$040E

HMGetBalloons

_Pack14

HMExtractHelpMsg
HMGetBalloonWindow

HMGetDialogResID
HMGetFont
HMGetFontSize
HMGetHelpMenuHandle
HMGetIndHelpMsg

_Pack14

$0711

_Pack14

$0215

_Pack14
_Pack14
_Pack14
_Pack14
_Pack14

$0003
$0213
$020A
$020B
$0200
$1306

HMGetMenuResID

_Pack14

$0314

HMIsBalloon
HMRemoveBalloon

_Pack 14
_Pack14

$0007
$0002

HMSetDialogResID

_Pack14

$010C

HMSetFontSize

_Pack14

$0109

HMScanTemplateltems
HMSetBalloons
HMSetFont

_Pack14
_Pack14
_Pack14

$0410
$0104
$0108

HMSetMenuResID

_Pack14

$020D

HMShowBalloon

_Pack14

$OBO1

HoldMemory

_MemoryDispatch

$0000

HMShowMenuBalloon
HSL2RGB

HSV2RGB

InitDateCache
InitDBPack

InitEditionPack
InsertSRTRec
IntlTokenize
IPCListPorts

IsOutline

IsRegisteredSection
IsSpecialFont

IUClearCache
IUGetItlTable
[ULangOrder

TULDateString
IULTimeString

TUMagIDPString

_Pack14

_Pack 12
_Pack12

_ScriptUtil
_Pack13

_Pack1 1
_SlotManager
_ScriptUul
_PPC

_FontDispatch
_Pack11
_ScriptUtil

_Pack6
_Pack6
_Pack6

_Pack6
_Pack6

_Pack6

>

$0E05

=

$0005

A

5

$0007

$8204FFF8
$0100

$0100
$OO00A

$8204FFFA
$OO0A

$0000

$0208
$8202002A

$0018
$0024
$0020

$0014
$0016

$001C
(Continued)

Table C-4: Routines Selected From System Traps

C-21

Inside Macintosh, Volume V1

Table C-4.
Routine

— Routines selected from system traps (Continued)
name

[UMagPString
TUScriptOrder
TUTextOrder
LaunchDeskAccessory
LockMemory
LockMemoryContiguous
LockPixels
LongDate2Secs
LongSecs2Date
MACEVersion
MatchAlias
NChar2Pixel
NDrawJust
NewAlias
NewAliasMinimal
NewAliasMinimalFromFullpath
NewGWorld
NewPictInfo
NewPublisherDialog
NewPublisherExpDialog
NewScreenBuffer
NewSection
NewSubscriberDialog
NewSubscriberExpDialog
NewTempScreenBuffer
NFindWord
NMeasureJust
NoPurgePixels
NPixel2Char
NPortionText
OffscreenVersion
OpenDF
OpenEdition
OpenNewEdition
OpenWD
OutlineMetrics
PageFaultFatal
ParseTable
PBCatSearch
C-22

Trap name

Selector

_Pack6
_Pack6

SOOLA
$OOIE
$0022
$0036
$0002
$0004
$0001
$8008FFF2
$8008FFFO
$00000010
$0005
$821C0030
$80160032
$0002
$0008
$0009
$0000
$0602
$0236
$0B38
$0010
$0A02
$0232
$0B34
$0015
$80 12FFE2
$801A0034
$000C
$8222002E
$84 120036
$0014
SOOLA
$0412
$0814
$0001
$0008
$0005
$82040022
$0018

_Pack6

_OSDispatch
_MemoryDispatch

_MemoryDispatch
_QDExtensions
_ScriptUtil
_ScriptUtil
_SoundDispatch

_AliasDispatch
_ScriptUtil
_ScriptUtil
_AliasDispatch

_AliasDispatch
_AliasDispatch
_QDExtensions
_Pack15
_Pack11
_Pack11

_QDExtensions
_Pack11
_Pack11
_Pack11

_QDExtensions
_ScriptUtil
_ScriptUtil
_QDExtensions
_ScriptUtil
_ScriptUtil
_QDExtensions

_HFSDispatch
_Pack11

_Pack11
_HFSDispatch
_FontDispatch

_DebugUtil
_ScriptUtil
_HFSDispatch

Table C-4: Routines Selected From System Traps

System Traps

Table C-4.

— Routines selected from system traps (Continued)
Trap name

Selector

_HFSDispatch

PBDeleteFileIDRef

_HFSDispatch

$0014

PBDTAddAPPL
PBDTAddIcon

_HFSDispatch

$0025

_HFSDispatch
_HFSDispatch

$0022
$0021

_HFSDispatch

SO002F

_HFSDispatch
_HFSDispatch
_HFSDispatch

$002B
$0027
$002A

_HFSDispatch

$0023

PBDTOpenInform

_HFSDispatch
_HFSDispatch
_HFSDispatch
_HFSDispatch

$0024
$002D
$0020
S002E

PBDTRemoveAPPL

_HFSDispatch

$0026

PBDTRemoveComment

_HFSDispatch

$0029

PBDTReset

PBGetVolMountInfo

_HFSDispatch
_HFSDispatch
_HFSDispatch
_HFSDispatch
_HFSDispatch

$002C
$0028
$0017
$0060
$0040

PBGetVolMountInfoSize

_HFSDispatch

$003F

PBHGetVolParms

_HFSDispatch

$0030

PBHOpenDF
PBMakeFSSpec
PBOpenDF

_HFSDispatch

SOOLA

_HFSDispatch

SOO1B

_HFSDispatch

SOOLA

PBResolveFileIDRef

_HFSDispatch

S0016

PBSetForeignPrivs

_HFSDispatch

$0061

PBVolumeMount

_HFSDispatch

$0041

PixPatChanged
PMerVersion
PortChanged

_QDExtensions

$0008

_PaletteDispatch

$0015

_QDExtensions

SO009

PortionText

_ScriptUtil

$84080024

PostHighLevelEvent
PPCAccept

_OSDispatch

$0034

IPPC
_Pack9
_PPC
PPC

$0004
$ODO00
$0009
$0008

Routine

name

PBCreateFileIDRef

PBDTCloseDown
PBDTDelete

PBDTFlush
PBDTGetAPPL
PBDTGetComment
PBDTGetlIcon
PBDTGetlconInfo

PBDTGetInfo
PBDTGetPath

PBDTSetComment
PBExchangeFiles
PBGetForeignPrivs

PPCBrowser
PPCClose

PPCEnd

$OO15

>

s
=
O

=|

=
wm

O
wn

(Continued)

Table C-4: Routines Selected From System Traps

C-23

Inside Macintosh,

Table C-4.

Volume VI

— Routines selected from system traps (Continued)
Trap name

Selector

PPCInform
PPCInit

_ PPC

PPCOpen
PPCRead
PPCReject

fe i ee

PPCStart

PPC
_PPC
_QDExtensions

$0003
$0000
$0001
$0007
$0005
$0002
$0006
$0013
$8216002C
$SO81A

Routine

name

UuPPG
_PPC
_PPC

PPCWrite
QDDone
RawPrinterValues
ReadEdition

_ScriptUtil

ReadPartialResource

_ResourceDispatch

RecordPictInfo

_Pack15

RecordPixMapInfo
RegisterSection
ReplaceText

_Pack15
_Pack11

_Packl1

ResizePalette

_ScriptUtil
_PaletteDispatch

ResolveAlias
ResolveAliasFile

_AliasDispatch
_AliasDispatch

RestoreBack

_PaletteDispatch

RestoreDeviceClut

_PaletteDispatch

RestoreFore

_PaletteDispatch
_Pack15

RetrievePictInfo

RGB2CMY
RGB2HSL
RGB2HSV
SameProcess
SaveBack
SaveFore
SCalcsPointer
SCalcStep
SCardChanged
SCkCardStatus
SDeleteSRTRec

SectionOptionsDialog
SectionOptionsExpDialog
SetDepth
SetEditionFormatMark
SetEditionOpenerProc
SetFrontProcess

C-24

_Pack12
_Pack12
_Pack12

_OSDispatch
_PaletteDispatch
_PaletteDispatch

_SlotManager
_SlotManager
_SlotManager
_SlotManager

_SlotManager
_Pack1I1
_Pack11
_PaletteDispatch
_Pack11
_Pack11

_OSDispatch

Table C-4: Routines Selected From System Traps

$0001

$0403
$0404
$0604
$820CFFDC
$0003
$0003
$000C
$0410
$0002
$040F
$0505
$0004
$0006
$0008

$003D

$040E
$040D
$002C
$0028
$0022
$0018
$0031
$023A
$0B3C
SOA 13
$0620
$022C
$003B

System Traps

Routines selected from system traps (Continued)

Table C-4.
Routine

name

SetGWorld
SetOutlinePreferred
SetPaletteUpdates
SetPixelsState
SetPreserveGlyph
SetResourceSize
SetSRsrcState
SetStylScrap
SetupAIFFHeader
SetupSndHeader
SExec
SFindDevBase
SFindSInfoRecPtr
SFindSRsrcPtr
SFindStruct
SGetBlock
SGetCString
SGetDriver
SGetSRsre
SGetTypeSRsrc
ShortenDITL
Small Fract2Fix
SndChannelStatus
SndGetSysBeepState
SndManagerStatus
SndPauseFilePlay
SndPlayDoubleBuffer
SndRecord
SndRecordToFile
SndSetSysBeepState
SndSoundManagerVersion
SndStartFilePlay
SndStopFilePlay
SNextRsrc
SNextTypeSRsrc
SOffsetData
SPBBytesToMilliseconds
SPBCloseDevice

Trap name

Selector

_QDExtensions

$0006
$0001
$0616
$000E
$000A
$0003
$0009
$000B
$0B4C0014
$0D480014
$0023
$001B

_FontDispatch
_PaletteDispatch
_QDExtensions
_FontDispatch

_ResourceDispatch
_SlotManager
_TEDispatch
_SoundDispatch
_SoundDispatch

_SlotManager
_SlotManager
_SlotManager
_SlotManager
_SlotManager
_SlotManager

_SlotManager
_SlotManager
_SlotManager
_SlotManager

_CommToolboxDispatch
_Pack12
_SoundDispatch

_SoundDispatch
_SoundDispatch
_SoundDispatch
_SoundDispatch
_SoundDispatch
_SoundDispatch
_SoundDispatch
_SoundDispatch
_SoundDispatch
_SoundDispatch

_SlotManager
_SlotManager
_SlotManager
_SoundDispatch
_SoundDispatch

$002F

$0030
$0006
$0005
$0003
$002D
$000B
$000C
$0404
$0002
$00 100008
$00180008
$00140008
$02040008
$00200008
$08040014
$07080014
$001C0008
$000C0008
$0D000008
$03080008
$0014
$0015
$0024
$04440014
$021C0014

<=)
eel
_

is}
_

—

Qu
iT
Pa

ig?)

i? 2)

(Continued)

Table C-4: Routines Selected From System Traps

C-25

Inside Macintosh,

Table C-4.
Routine

Volume

VI

— Routines selected from system traps (Continued)
name

SPBGetDevicelnfo

SPBGetIndexedDevice
SPBGetRecordingStatus
SPBMillisecondsToBytes
SPBOpenDevice
SPBPauseRecording
SPBRecord
SPBRecordToFile

SPBResumeRecording
SPBSetDevicelnfo

Trap name

Selector

_SoundDispatch
_SoundDispatch
_SoundDispatch
_SoundDispatch
_SoundDispatch

$06380014
$05 140014
$0E340014
$04400014
$05 180014
$02280014
$03200014
$04240014
$022C0014
$063C0014
$030C0014
$01100014
$02300014
$00000014
$002E
$0012

_SoundDispatch

_SoundDispatch
_SoundDispatch
_SoundDispatch
_SoundDispatch

SPBSignInDevice
SPBSignOutDevice
SPBStopRecording

_SoundDispatch

SPBVersion

_SoundDispatch

SPtrToSlot

_SlotManager

SPutPRAMRec

_SlotManager

SReadByte

_SlotManager

SReadDrvrName

_SlotManager

SReadFHeader
SReadInfo

_SlotManager

_SoundDispatch
_SoundDispatch

SReadPBSize

_SlotManager
_SlotManager
_SlotManager

SReadPRAMRec

_SlotManager

SReadStruct

_SlotManager
_SlotManager
_SlotManager

SReadLong

SReadWord
SRsrcInfo

SSearchSRT

_SlotManager

StandardGetFile

_Pack3

StandardPutFile

_Pack3

StartSecureSession

PPC

Str2Format

_ScriptUtil
_ScriptUtil

String2Date
String2Time
StyledLineBreak
SUpdateSRT
SVersion

TEContinuousStyle
TECustomHook

TEFeatureFlag
C-26

_ScriptUtil
_Scriptuti]

_SlotManager
_SlotManager
_TEDispatch
_TEDispatch
_TEDispatch

Table C-4: Routines Selected From System Traps

$0000

$0019
$0013
$0010
$0002
$0026
$0011
$0007
$0001
$0016
$002A
$0006
$0005
$O00E
$820CFFEC
$82 14FFF6
$82 14FFF4
$82 1CFFFE
$002B
$0008
$O00A
$000C
$OO0E

System Traps

Table C-4.
Routine

—_ Routines selected from system traps (Continued)
name

TEGetPoint
TempDisposeHandle
TempFreeMem
TempHLock
TempHUnlock
TempMaxMem
TempNewHandle
TempTopMem
TENumStyles
TESetStyle
ToggleDate
TruncString
TruncText
UnholdMemory
UnlockMemory
UnlockPixels
UnRegisterSection
UpdateAlias
UpdateGWorld
ValidDate
VisibleLength
WakeUpProcess
WriteEdition
WritePartialResource

Trap name

Selector

_TEDispatch

$0008

_OSDispatch
_OSDispatch
_OSDispatch
_OSDispatch

$0020
$0018
$SOOIE
$OO1F

_OSDispatch
_OSDispatch
_OSDispatch

$0015
$001D
$0016

_ScriptUtil
_MemoryDispatch
_MemoryDispatch

$820CFFDE
$0001
$0003

_AliasDispatch

$0006

_TEDispatch
_TEDispatch
_ScriptUtil
_ScriptUtil

_QDExtensions
_Pack11

$000D
$0001
$820EFFEE
$8208FFEO

$0002
$0206

_QDExtensions

$0003

_ScriptUtil

$820CFFE4

_ScriptUtil
_OSDispatch
_Pack1 1
_ResourceDispatch

>

.)
<=)

©-_

$84080028
$003C
$081C
$0002

Table C-4:; Routines Selected From System Traps

ZeA
@

wn

C-27

Inside Macintosh,

C-28

Volume VI

APPENDIX

D: GLOBAL

VARIABLES

This appendix gives an alphabetical list of all system global variables described in this
volume of /nside Macintosh, along with their locations in memory and a brief description
of their contents.
Table D-1.

Global variables

Name

Location

Contents

DeviceList

$8A8

Handle to the first element in the device list

GrayRgn

$9EE

Size and shape of current desktop

LapMerPtr

$B18

Start of the LAP Manager

MainDevice

$8A4

Handle to the current main device

TEFindWord

$7F8

The low-memory address for TextEdit’s wordbreaking routine

TESysJust

$BAC

The system alignment whose default value is set by
the last installed script

TheGDevice

$CC8

Handle to current active device

WordRedraw

$BA5

Value that indicates how much of a line must be
redrawn after a character is entered

>

—
=7)
=
=
ae

@
~”n

D-1

APPENDIX E: THE
CHARACTER SET

STANDARD

ROMAN

This appendix lists the standard Roman character set in Table E-1. The Glyph column
displays a glyph example or “np” for nonprinting characters. The Hex column lists the
hexadecimal code for the character and the Dec column lists the decimal code. The fourth
column lists the characters’ PostScript® names; characters that do not have PostScript names
are listed in square brackets.
Table E-2 at the end of this appendix lists the standard PostScript characters that are not
encoded in the standard Roman character set but which are in a standard TrueType 'sfnt'
resource. You can access these glyphs using PostScript. See the PostScript Language
Reference Manual for more information.
Table E-1.

The standard Roman character set

Glyph

Hex

Dec

PostScript
name

Glyph

Hex

Dec

PostScript
name

np

0

0)

null

np

12

18

[Device control 2]

np

l

|

[Start of heading]

np

3

19

[Device control 3]

np

2

2

[Start of text]

np

14

20

[Device control 4]

3

[End of text]

np

15

21

[Negative

acknowledge]

=

transmission |

np

16

22

[Synchronous

.

idle)

5

np

op

3

P

4

[End of

np

5

5

[Enquiry]

np

a

7

[Bell]

np

8

8

[Backspace]

np

18

24

[Cancel]

np

9

9

[Horizontal

np

19

25

[End of medium]

np

A

10

[Line feed]

tabulation]

np

lA

26

[Substitute]

“

B

MM

hf ae

np

IC

28

[File separator]

np

C

12

[Form feed]

np

ID

29

[Group separator]

np

D

13

nonmarkingreturn

oP

He

a0

Recta capecatar)

15

[Shiftin]

np

np

6

E

nF

6.

14

[Acknowledge]

[Shift out]

=

=

|

|

>

2.

block]

np

np

IB.

LE

27

31

ak

[Escape]

[Unit separator]

DE

np

10

16

[Data link escape]

!

a

33

senean

np

1]

17

{Device control 1]

;

22

34

quotedbl
(Continued)

E-]

Inside Macintosh,

Table E-1.

Volume

VI

The standard Roman character set (Continued)

Glyph

Hex

Dec

PostScript
name

Glyph

Hex

Dec

PostScript
name

#

23

35

numbersign

B

42

66

B

$

24

36

dollar

C

43

67

0

%

25

ei

percent

D

44

68

D

&

26

38

ampersand

E

45

69

E

27

39

quotesingle

F

46

70

F

(

28

40)

parenleft

G

47

71

G

)

29

4]

parenright

H

48

72

H

-

2A

42

asterisk

It

49

13

I

4

2B

43

plus

J

4A

74

J

‘

2C

44

comma

K

4B

75

K

-

2D

= 3=45

hyphen

L

4C

76

L

2E

46

period

M

4D

77

M

/

2F

47

slash

N

4E

78

N

0

30

48

zero

O

4F

79

O

l

31

49

one

P

50

80

P

2

32

50

two

Q

51

81

Q

3

33

51

three

R

52

82

R

4

34

52

four

S

53

83

S

5

35

33

five

T

54

84

(i

6

36

54

Six

U

55

85

U

7

37

55

seven

Vv

56

86

Vv

8

38

56

eight

W

57

87

W

9

39

57

nine

X

58

88

X

3A

=o 58

colon

Y¥

59

89

Y

;

3B

s«59

semicolon

Zz

5A

-:990

Z

<

3c

60

less

[

5B

9]

bracketleft

=

3D_—Ss«é*OdI

equal

\

a

86

backslash

>

3B:

62

greater

|

5D

93

bracketright

?

3F

63

question

es

oe

94

asclicircum

@

40

64

at

_

oF

95

underscore

A

4]

65

A

E-2

Table E-1; The Standard Roman Character Set

The Standard Roman Character Set

Table E-1.

The standard Roman character set (Continued)

Glyph

Hex

Dec

PostScript
name

Glyph

Hex

Dec

.

60

96

grave

np

7F

127

=‘ [Delete]

a

61

97

a

A

80

128

Adieresis

b

62

98

b

A

81

129

Aring

c

63

99

c

C

82

130

=©Ccedilla

e
f

65
66

101
102

e
f

N
O

84
85

132
133

Ntilde
Odieresis

U

86

134

Udieresis

d

64

100

d

E

83

131

PostScript
name

Eacute

g

67...

108.

h

68

104.

=h

A

87

135

aacute

1

69

105.

i

a

88

136

= agrave

j

6A

106

ij

a

89

137

acircumflex

k

6B

107

k

a

8A

138

— adieresis

l

6C

108s]

a

8B

139

_atilde

m

6D

109

=m

a

8C

140

aring

n

6E

110

on

¢

8D

141

~~ ccedilla

:

0)

6F

7

lll

112

oo

é

8E

142

eacute

J

q

71

113

q

é

90

144

ecircumflex

6

r

72

114

r

é

9]

145 __ edieresis

s

73

Ws.

‘s

f

92

146 _ iacute

t

74

116

¢t

i

93

147

u

75

Ke

wv

7

94

148 _ icircumflex

V

76

118

Ov

i

95

149

— idieresis

w

77

119

w

fi

96

150

__ntilde

X

78

120

x

6

97

151

— oacute

y

79

Zl

¥

0

98

152

ograve

Zz

8A

I22

=

6

99

153

ocircumflex

{

7B

123 _ braceleft

0)

9A

154

odieresis

7C

124

bar

)

9B

155 __ otilde

}

7D

125 _ braceright

ti

9C

156

—_uacute

~

TE

126

a

9D

157

—_—ugrave

p

|

p

__asciitilde

8

8F

143

egrave

2

igrave

(Continued)

Table E-1: The Standard Roman Character Set

E-3

Inside Macintosh,

Table E-1.

The

Volume VI

standard Roman

character set (Continued)

Glyph

Hex

Dec

PostScript
name

Glyph

Hex

Dec

PostScript
name

a

9E

158

— ucircumflex

e

BE

190

ae

ii

OF

159

—_udieresis

od

BF

191 © oslash

t

AO

160

dagger

é

CO

192

questiondown

.

Al

161

degree

Cl

193

exclamdown

¢

A2

162

cent

=

C2

194

—_ logicalnot

£

A3

163 _ sterling

V

C3

195

radical

§

A4

164 — section

f

C4

196

florin

°

AS

165

bullet

=

CS

197

approxequal

||

A6

166

paragraph

A

C6

198

Delta

B

A7

167

~~ germandbls

«

C7

199

— guillemotleft

®

A8

168

registered

»

C8

200

— guillemotright

©

A9

169

copyright

ss

C9

201 —

o

AA

170 _ trademark

CA

202 — [No-break space]

AB

171

A

CB

203

= Agrave

AC

172 . dieresis

A

CC
CD

204

205

Atilde

Otilde

acute

#

AD

173 __ notequal

-fE

AE

174

AE

a 2}

CE

206

OE

@

AF

175

Oslash

oe

CF

207.

oe

o°

BO

176

infinity

_

DO

208

— endash

+

Bl

177

plusminus

—

D1

209

= emdash

<

B2

178

lessequal

i

D2

210

~ quotedbileft

2

B3

179

— greaterequal

”

D3

211

quotedblright

¥

B4

180

yen

‘

D4

212

~ quoteleft

Ll

BS

181

mu

D5

213

~ quoteright

)

B6

182 __ partialdiff

+

D6

214 — divide

2

B7

~=183

summation

0

D7

215

I]

B8

184

product

y

D8

216 — ydieresis

Tt

BO

=185_—sopi

Y

D9

217

Ydieresis

J

BA

186 _

integral

/

DA

218

fraction

.

BB

187 _ ordfeminine

O

DB

219 — currency

°

BC

188

‘

DC

220 _ guilsinglleft

Q

BD

189

>

DD

221 © guilsinglright

E-4

Table E-1: The Standard Roman Character Set

— ordmasculine
Omega

O

ellipsis

lozenge

The Standard Roman Character Set

©

239

= Ocircumflex

FO

240

apple

Fl

241

Ograve

F2

242

Uacute

F3

243

~Ucircumflex

F4

244

+ Ugrave

F5

245

dotlessi

F6

246

circumflex

Oo

wm
ey)
S&S

Ecircumflex

i)
eS)

Aacute

i)
es)
in)

Edieresis
Egrave
lacute

Icircumflex
Idieresis
Igrave

.

FE

254

ogonek

Oacute

.

FF

255

caron

vw

>

_

©

NY

Acircumflex

tO
KY

perthousand

bo
oS)
eS)

mow

EF

&

WK

quotedblbase

PostScript
name

ae

Ww

ON

quotesinglbase

Dec

Croce

WW

WL
Nn

periodcentered

WKY
~]

&

Nw
Db
Nr
i)
eS)

to
awe

daggerdbl

WH

fl

Hex

i)
eS)
&

"
%e
A
E
A
E
E
[
I
[
I
O

fi

Glyph

bd
oS)
Nn

DE
DF
EO
El
E2
E3
E4
E5
E6
E7
E8
E9
EA
EB
EC
ED
EE

ON

fi
fl
‘

PostScript
name

re
WwW

Hex

character set (Continued)

bho
eS)
~]

Glyph

io)

The standard Roman

i)
eS)
(oe)

Table E-1.

.

F7

247

‘tilde

-

F8

248

macron

.

F9

249

breve

FA

250

~~ dotaccent

FB

251

—sring

FC

252

~—cedilila

FD

253

hungarumlaut

°

~
~~
—
es
ee
—_

@
—

ms

Qu
es
ws

$7)
2)

The PostScript characters in Table E-2 do not have character codes in the standard Roman
character set but are found in a standard TrueType 'sfnt' resource.
Table E-2._
Cacute
cacute
Ccaron
ccaron
dmacron
Eth
eth
Gbreve
gbreve
Idot
Lslash

| Unencoded PostScript characters
Islash
Scaron
scaron
Scedilla
scedilla
Thorn
thorn
Yacute
yacute
Zcaron
zcaron

brokenbar
franc
minus
multiply
onesuperior
twosuperior
threesuperior
onequarter
onehalf
threequarters

Table E-2: Unencoded PostScript Characters

E-5

GLOSSARY
activation procedure: A procedure supplied by your application for highlighting
customized dialog box items that can be the target of keyboard input in a standard file
dialog box.
active application: The application currently interacting with the user. Its icon appears
on the right side of the menu bar. See also current process, foreground process.
active field: The target of keyboard input in a dialog box.
additional parameter: A keyword-specified descriptor record that the server application
uses in addition to the data specified in the direct parameter. For example, an Apple event for
arithmetic operations may include additional parameters that specify operands in an equation.
Additional parameters may be required, or they may be optional.
address descriptor record:

or source of an Apple event.
ADSP:

A descriptor record that contains the address of the target

See AppleTalk Data Stream Protocol.

advance width: The full width of a glyph, measured from the glyph origin to the other
side of the glyph, including any white space on either side. See also glyph origin.
AEIMP:
AEP:

See Apple Event Interprocess Messaging Protocol.

See AppleTalk Echo Protocol.

£
x

A5 world: An area of memory in the application’s partition that contains QuickDraw global
variables and the application’s global variables, parameters, and jump table—all of which are
accessed through the A5 register.

y

AE record: A record of data type AERecord that contains a list of parameters for an Apple
event. See also Apple event parameter.
—

>
Nn
a
ne
es

I

AFP:

See AppleTalk Filing Protocol.

AIFF:

See Audio Interchange File Format.

alert sound:

See system alert sound.

alias: An object on the desktop that represents another file, directory, or volume. An alias
looks like the icon of its target, but its name is displayed in a different font style. The style
depends on the system script; for Roman and most other scripts, alias names are displayed
in italic. Aliases give users more flexibility in organizing their desktops and offer a convenient way to store local copies of large or dynamic files that reside on file servers.
alias file: A file that contains a record that points to another file, directory, or volume. An
alias file is displayed by the Finder as an alias.

GL-1

Inside Macintosh,

alias record:
or volume.

Volume VI

A data structure created by the Alias Manager to identify a file, folder,

alignment: The horizontal placement of lines of text with respect to the left and right
edges of the destination rectangle. Alignment can be flush left, flush right, centered, or
justified (that is, flush on both the left and right edges of the destination rectangle). TextEdit
supports text alignment that is flush left, centered, flush right, and flush according to the line
direction of the script. TextEdit does not support fully justified alignment. The Script
Manager supplies routines you can use to provide support for fully justified text in your
applications. See also justification.
alphabetic: Used to describe a type of character representation in which characters
symbolize, more or less, the discrete phonemic elements in the languages represented by
the script. For example, Roman script letters are alphabetic.
alternate rectangle: A rectangle used by the Help Manager (under some circumstances)
for transposing a help balloon’s tip when trying to fit the balloon on screen. For all help
resources except the ‘hdlg' resource, the Help Manager moves the tip to different sides of
the hot rectangle. For 'hdlg' resources, however, the Help Manager allows you to specify
alternate rectangles for transposing balloon tips. You can also specify alternate rectangles
when you use the HMShowBalloon and HMShowMenuBalloon functions. Compare hot
rectangle.
animated color: A usage category for colors in a palette. It specifies that a palette entry is
to be used for color animation effects.
Apple event: A high-level event that adheres to the Apple Event Interprocess
Messaging Protocol. An Apple event consists of attributes (including the event class

and event ID, which identify the event and its task) and, usually, parameters (which contain

data used by the target application of the event). See also Apple event attribute, Apple
event parameter.

Apple event attribute: A keyword-specified descriptor record that identifies the
event class, event ID, target application, or some other characteristic of an Apple event.
Taken together, the attributes of an Apple event identify the event and denote the task to be
performed on the data specified in the Apple event’s parameters. Compared to parameters
(which contain data used only by the target application of the Apple event), attributes contain
information that can be used by both the Apple Event Manager and the target application. See
also Apple event parameter.
Apple event dispatch table: A table that the Apple Event Manager uses to map Apple
events to application-defined functions called Apple event handlers.
Apple event handler: An application-defined function that extracts pertinent data from
an Apple event, performs the action requested by the Apple event, and returns a result.
Apple Event Interprocess Messaging Protocol (AEIMP): A standard defined by
Apple Computer, Inc., for communication and data sharing among applications. High-level
events that adhere to this protocol are called Apple events.
Apple event parameter: A keyword-specified descriptor record that contains data which
the target application of an Apple event must use. Compared to attributes (which contain

GL-2

Glossary

Glossary

information that can be used by both the Apple Event Manager and the target application),
parameters contain data used only by the target application of the Apple event. See also
Apple event attribute, direct parameter, optional parameter, required
parameter.

Apple event record: A record of data type AppleEvent that contains a list of keywordspecified descriptor records. These descriptor records describe—at least—the attributes
necessary for an Apple event; they may also describe parameters for the Apple event. Apple
Event Manager functions are used to add parameters to an Apple event record.
Apple Menu Items folder: A directory located in the System Folder for storing desk
accessories, applications, folders, and aliases that the user wants to display in and access
from the Apple menu.
AppleTalk

connection

file: A file of file type 'adev' that contains a link access

protocol implementation for a data link (ELAP for EtherTalk, for example).

AppleTalk Data Stream Protocol (ADSP): An AppleTalk protocol that appears to
its clients to maintain an open pipeline between two entities on the internet. Either entity can
write a stream of bytes to the pipeline or read data bytes from the pipeline. ADSP is a
symmetrical protocol.
AppleTalk Echo Protocol (AEP): An AppleTalk protocol that listens for special
packets sent by other nodes and that, when it receives such a packet, echoes it back to
the sender.
AppleTalk Filing Protocol (AFP): An AppleTalk protocol that provides an interface
between an application and a file server. AFP is a client of ASP and is used to access
AppleShare file servers on Macintosh computer workstations. See also AppleTalk
Session Protocol.
AppleTalk Phase 2: The changes to AppleTalk, other than ADSP and the LAP Manager,
included as part of system software version 7.0.
AppleTalk Session Protocol (ASP): An AppleTalk protocol that sets up and maintains sessions between a workstation and a server. ASP is a nonsymmetrical protocol—that

is, only one of the two entities involved in the session (the workstation) can send commands.

The other entity (the server) is restricted to responding to the commands.

AppleTalk Transaction Protocol (ATP): An AppleTalk protocol that provides lossfree communications by retransmitting any data packets that are lost. ATP is a transactionbased protocol.
AppleTalk transition: A message sent by the AppleTalk Manager or by an application to
all of the entries in the AppleTalk Transition Queue. AppleTalk transitions indicate such
occurrences as the opening or closing of the .MPP driver.
AppleTalk Transition Queue: An operating-system queue maintained by the LAP
Manager. Each of the entries in the AppleTalk Transition Queue is called each time one of a
set of predefined AppleTalk transitions occurs. An application can also use LAP Manager
routines to call the elements in the AppleTalk Transition Queue.

Glossary

GL-3

Inside Macintosh, Volume VI

application heap:

An area of memory in the application partition that contains the appli-

cation’s 'CODE' segment |, data structures, resources, and other code segments as needed.

application result handler: A result handler that is associated with a particular
application. Compare system result handler.
Arabic calendar:

ascent line:
in a font.

The lunar calendar used in much of the Arabic world.

An imaginary horizontal line that usually marks the tops of the tallest glyphs

ASP:

See AppleTalk Session Protocol.

ATP:

See

AppleTalk Transaction Protocol.

Audio Interchange File Format (AIFF): A sound storage file format designed to
allow easy exchange of audio data among applications.
authentication: The process of establishing the identity of a user. The authentication
mechanism of the PPC Toolbox identifies each user through an assigned name and
password.
A/UX Toolbox: A library that enables a program running under the A/UX operating
system to call Macintosh User Interface Toolbox routines and Macintosh Operating
System routines.
background-only application: An application that does not have a user interface. A
background-only application does not call the InitWindows procedure and is identified by
having the onlyBackground flag set in its 'SIZE' resource.
background process:
foreground process.

A process that isn’t currently interacting with the user. Compare

backing-store file: The file that virtual memory uses to store the contents of unneeded
pages of memory.
backing-store order:
backing volume:

The order in which character codes are stored in memory.
See paging device.

balloon definition function: An implementation of a window definition function that
defines the general appearance of a help balloon.
base line:

An imaginary line on which the glyphs in a line of text appear to sit.

Bézier curve: A curve defined by three outline points: two on-curve points that serve as
endpoints, and one off-curve point that determines the degree of curvature.
bidirectional script system: A script system in which text is generally flush right and
most characters are written from right to left, but some text is written left to right as well.
Arabic and Hebrew are examples of bidirectional script systems. See also script system.
bitmap: A set of bits that represents the positions and states of a corresponding set of
items, such as pixels.
GL-4

Glossary

Glossary

bitmapped font:

A collection of bitmapped glyphs in a particular typeface, size, and style.

bitmapped glyph: A glyph in a bitmapped font that exists in a computer file or in
memory as a bitmap, is drawn as a pixel pattern on the display screen, and is sent to the
printer as graphics data.

bounding box: The smallest rectangle that encloses the bitmap of a glyph.
brightness:

A measurement of the amount of black in a color—the less black, the brighter

the color. Brightness is equivalent to lightness in the HLS color system, and it is equivalent
to value in the HSV color system.

broadcast address: The Ethernet address for which all nodes accept packets just as they
do for their permanently assigned Ethernet hardware addresses. The broadcast address is
$FF-FF-FF-FF-FF-FF. See also multicast address.

bundle bit: A flag in a file’s FInfo record that informs the Finder that a 'BNDL' resource
exists for the file. A file’s FInfo record is stored in a volume’s catalog. The Finder uses the
information in the 'BNDL' resource to associate icons with the file.
canonical number format: A private, internal format that specifies how a number is
written in a way that is independent of country, language, and other cultural considerations.
caret position: A location on the screen corresponding to a leading or trailing edge of a
displayed character. In mixed-directional text, one character offset may correspond to
two character positions, and one caret position may correspond to two character offsets.
catalog: A
CCB:

list of all files and folders stored on a volume.

See connection control block.

character: A symbol standing for a sound, syllable, or concept used in a script; one of the
simple elements of a human language. A character may represent the concept of, for example,
a lowercase “‘b”, the number “2”, or the arithmetic operator “+”. Characters that can be

displayed or printed—such as letters, numbers, and punctuation—are represented by glyphs.
See also glyph.
character code: A hexadecimal number from $00 through $FF that represents the
character that a key or key combination stands for.
character offsets: Byte offsets of the characters in the text buffer. The values of the
character offsets correspond to the backing-store order of characters.
character representation: The ways in which scripts use symbols in relationship to
sounds, concepts, letters, and one another to create words as the basic components of
language. Scripts may use alphabetic, syllabic, or ideographic methods of character
representation.
character set encoding:
in memory.

The numeric codes that represent the characters of a script

client: In AppleTalk, a protocol that uses services of another protocol in order to carry out
some functions.
Glossary

GL-5

~~
—
~

“es

=

yD
as
~
9;
~e

Inside Macintosh,

Volume

VI

client application: An application that uses the Apple Event Interprocess
Messaging Protocol to request a service—for example, printing a list of files, spellchecking a list of words, or performing a numerical calculation—from another application
(called a server application). These applications can reside on the same local computer
or on remote computers connected to a network.

closed connection:

The state of a connection when both connection ends terminate

the link and dispose of the connection information each maintains. Compare half-open
connection, open connection.

coercion handler:

A routine that coerces data from one descriptor type to another.

color grafPort: A data structure that describes a window’s portion of the color graphics
environment, including its pixel map, the graphics pen position, and the foreground and
background colors. It is defined by a record of data type CGrafPort. See also pixel map.
colorizing:

The process of substituting a color for black or white in an image.

color table: A data structure containing a number of RGB color records. Many color
tables are used for color look-up, notably the color look-up table (CLUT) that is associated
with a screen device and describes the colors the device can display.
common parent: The lowest-level directory that appears in the pathnames of multiple
files or directories on the same volume.
compatibility:

The ability of an application program to execute properly in different

operating environments.

connection

control block

(CCB):

A data structure that is used by ADSP

to store state

information about the connection end. See also AppleTalk Data Stream Protocol.

connection end: The combination of an AppleTalk socket and the ADSP information
maintained by the socket client.
connection listener: A connection end that waits passively to receive a connection
request and then passes the connection request on to its client, the connection server.
connection listening socket: A socket that accepts ADSP requests to open connections and passes them on to a socket client. Such sockets are normally used only by
connection servers.
connection server: A routine that accepts an open-connection request passed to it by a
connection listener and selects a socket to respond to the request.
context: The information about a process maintained by the Process Manager. This
information includes the current state of the process, the address and size of its partition,
its type, its creator, a copy of its low-memory globals, information about its 'SIZE' resource,
and a process serial number.
context dependence: In text, when the glyph corresponding to a character may be
modified depending on the preceding and following characters.

GL-6

Glossary

Glossary
contextual script system: A script system in which the displayed glyph for a character
depends on the adjacent characters—for example, Arabic. See also script system.
continuous play from disk:

contour:
points.

See play from disk.

One closed loop in a TrueType outline glyph, defined by a group of outline

control panel: A dialog box defined by a file of file type 'cdev'. A control panel allows
the user to set or control some feature of hardware or software, such as the volume of the
speaker or the number of colors displayed on screen.
control panel file:

A file of file type 'cdev'. See also control panel.

Control Panels folder: A directory located in the System Folder for storing control
panels, which allow users to modify the work environment of their Macintosh computer.
core Apple event: An Apple event that nearly all applications can use to communicate.
The suite of core Apple events is described in the Apple Event Registry; Apple Computer,
Inc., recommends that all applications support the core Apple events.
courteous color: A usage category for colors in a palette. It denotes the color as not
demanding a close match when the color is displayed.
current process: The process that is currently executing and whose A5 world is valid;
this process can be in the background or foreground.
custom Apple event: An Apple event defined by you for use by your own applications.
You should register all of your custom Apple events with Macintosh Developer Technical
Support. You can choose to publish your Apple events in the Apple Event Registry so that
other applications can share them, or you may choose to keep them unpublished for exclusive
use by your own applications.
customized icon: An icon created by the user or by an application and stored with a
resource ID of —16455 in the resource fork of a file. A file with a customized icon has the
hasCustomlIcon bit set in its Finder flags field.
database extension:

Q

—

i]
N
7)

The interface between the Data Access Manager and a data server.

Datagram Delivery Protocol (DDP): A protocol that provides socket-to-socket
delivery of data packets within an AppleTalk internet.
data link: A physical communications connection and the protocol that implements it,
including the cabling and the encoding or modulation of data.
data server: An application that acts as an interface between a database extension on a
Macintosh computer and a data source, which can be on the Macintosh computer or on a
remote host computer. A data server can be a database server program that can provide an
interface to a variety of different databases, or it can be the data source itself, such as a
Macintosh application.
DDP:

See Datagram

Delivery Protocol.

Glossary

GL-7

Sy)
ea|

Inside Macintosh,

Volume VI

dead key: A specially designated key or modifier-and-key combination that usually produces no immediate effect when pressed, but instead affects the character or characters
produced when the next key (called the completer key) is pressed. For example, Option-E
has no effect; however, when you press E after pressing Option-E, “é” appears.
descent line: An imaginary line that usually marks the furthest distance below the base
line of the descenders of glyphs in a particular font.
descriptor list: A record of data type AEDescList that contains a list of descriptor
records.
descriptor record: A record of data type AEDesc that consists of a handle to data and
a descriptor type that identifies the type of the data referred to by the handle. Descriptor
records are the fundamental structures from which Apple events are constructed.
descriptor type: An identifier for the type of data referred to by the handle in
a descriptor record.
desktop database: A database of icons, file types, applications, and comments maintained by the Finder for all volumes over 2 MB.
Desktop Folder: A directory, located at the root level of each volume, used by the Finder
for storing information about the icons that appear on the desktop area of the screen. The
Desktop Folder is invisible to the user. What the user sees on screen is the union of the
contents of Desktop Folders for all mounted volumes.
diacritical mark: A sign that modifies the implicit sound or value of the character with
which it is associated.
dialog hook function:
a dialog box.

A function supplied by your application for handling item hits in

direction run: A contiguous (in memory) sequence of characters all written in the same
direction—for example, left to right or right to left.
directory: A subdivision of a volume, available in the Hierarchical File System (HFS). A
directory can contain files and other directories.
direct parameter: The parameter in an Apple event that contains the data to be used by
the server application. For example, a list of documents to be opened is specified in the direct
parameter of the Open Documents event. See also Apple event parameter.
direct pixel:

A pixel whose value directly specifies an RGB color.

disk cache: A part of RAM that acts as an intermediate buffer when data is read from and
written to file systems on secondary storage devices.
display list: In a standard file dialog box, the list of the files, folders, and volumes at one
level of the display hierarchy, from which the user can select items.
display order: The left-to-right order in which glyphs are drawn on a screen by QuickDraw.
The Script Manager handles differences between backing-store order and QuickDraw
display order. For example, Hebrew characters appear on the screen so that the glyph
corresponding to the first character in the string actually appears on the right of the string.
GL-8

— Glossary

Glossary

dithering:

dpi:

The process of mixing colors to create the effect of additional colors.

Dots-per-inch; used to measure the resolution of a screen or printer.

dual caret: A primary caret and a secondary caret, each measuring half the line’s height.
The high (primary) caret is displayed at the primary caret position for the character offset in
the primary line direction. The low (secondary) caret is displayed at the secondary caret
position for the character offset. When the caret position is unambiguous (for example,
not on a direction boundary), the primary and secondary carets are at the same position,
so the user sees one caret. See also primary caret, primary caret position, secondary
caret, secondary caret position.
dynamic window: A window that may change its title or reposition any of the objects
within its content area.
edition: The data written to an edition container by a publisher. A publisher writes data to
an edition whenever a user saves a document that contains a publisher, and subscribers in
other documents may read the data from the edition whenever it is updated. See also
publisher, subscriber.
edition container: A file that holds edition data, represented on the desktop by an edition
icon. An edition container obtains its data from a publisher within a document. See also
edition, publisher.
environmental selector: A selector code that returns information about the operating
environment that can be used by the requesting application to guide its actions. Compare
informational selector.
event class: An attribute that identifies a group of related Apple events. The event class
appears in the message field of the Apple event’s event record. In conjunction with the event
ID attribute, the event class specifies what action an Apple event performs. See also Apple
event attribute.
event ID: An attribute that identifies a particular Apple event within a group of related
Apple events. The event class appears in the where field of the Apple event’s event record. In
conjunction with the event class attribute, the event ID specifies what action an Apple event
performs. See also Apple event attribute.
explicit color: A usage category for colors in a palette. It specifies that the color table
index corresponding to that palette entry is to determine the color to display.
extended network: A network of a type that allows a range of network numbers. Each
node in an extended network must be specified by both its 16-bit network number and its
8-bit node ID.
Extensions folder: A directory located in the System Folder for storing system extension files such as printer and network drivers and files of types 'INIT’, 'scri', and ‘appe’.
file filter function: A function supplied by your application for determining which files
the user can open through a standard file dialog box.
file ID:

An unchanging number assigned by the File Manager to identify a file on a

volume. When it establishes a file ID, the File Manager records the filename and parent

directory ID of the file. The Alias Manager records a file’s ID to help identify it if it is moved
or renamed.
Glossary

GL-9

Inside Macintosh, Volume V1

file system

specification

(FSSpec)

record:

A record that identifies a stored

file

or directory by volume reference number, parent directory ID, and name. The file system
specification record is the file-identification convention adopted by system software
version 7.0.

Finder flags: Bits in the fdFlags field of a file’s FInfo record; these bits are used by the
Finder and by applications for setting and reading certain information about the file, such as
whether the file is an alias file, whether it has a bundle resource, whether it is a stationery
pad, and whether it has a customized icon.
font: (1) For bitmapped fonts, a complete set of characters in one typeface, size, and style.
(2) For outline fonts, a complete set of characters in one typeface and style. See also
bitmapped font, outline font.
font family: A complete set of glyphs for one typeface, including all available styles and
sizes of the glyphs in that font. A font family may include both bitmapped and outline fonts.
For example, the Geneva font family includes 9-point to 36-point glyphs in italic, bold,
underline, and other styles.
font scaling: The process of changing a glyph from one size or shape to another. The
Font Manager can scale bitmapped and outline fonts in three ways: changing a glyph’s point
size on the same display device, modifying the glyph but keeping the point size constant
when using a different display device, and altering the shape of a glyph.
font script:

The script that corresponds to the font of the current grafPort.

font size: The size of the glyphs in a font in points, measured from the base line of one
line of text to the base line of the next line of single-spaced text.
font style:
underline.

Stylistic variations in the appearance of a typeface, such as italic, bold, and

foreground process: The process currently interacting with the user; it appears to the
user as the active application. The foreground process displays its menu bar, and its windows
are in front of the windows of all other applications. Compare background process.
functional-area Apple event: An Apple event supported by applications with related
features—for example, an Apple event related to text manipulation for word-processing
applications, or an Apple event related to graphics manipulation for drawing applications.
Functional-area Apple events are defined by Apple Computer, Inc., in consultation with
interested developers, and they are published in the Apple Event Registry.
gamma table: A table used by a video card driver to correct for the fact that the intensity
of each color on a video display is not linearly proportional to the intensity of the electron
beam. The gamma table helps the video driver to provide the most accurate colors possible
for a video display. Because the user might prefer a nonstandard color correction, many
developers of video cards provide more than one gamma table for a given card.
Gestalt function:

GL-10

— Glossary

See

selector function.

Glossary

glyph: A distinct visual representation of a character that a display device, such as a
monitor or printer, can display. One glyph can represent a single character, such as a
lowercase “a”; more than one character, such as the “fi” ligature, which is two characters
but only one glyph; or a nonprinting character, such as the space character.
glyph origin: A point on the base line where QuickDraw begins drawing a glyph.
The glyph origin may not represent a visible point on the glyph, since white space to the
left of the glyph may be specified. See also bounding box, left-side bearing.
graphics device record: A data structure that describes the characteristics of a display
device, such as a video card.
graphics environment: The combination of one or more grafPorts, which contain
information about windows, and graphics device records, which contain information about
display devices attached to a computer system.
gray region: The region that defines the desktop, or the display area of all active devices,
excluding the menu bar on the main screen and the rounded corners on the outermost screens.
It is the area in which windows can be moved. See also main screen.
Gregorian calendar: The calendar used in Europe and America. It is not universally
accepted—for example, entirely different calendar systems are often used in Japan, China,
and the Middle East.
half-open connection: The state of a connection when one connection end is established,
but the other connection end is unreachable or has disposed of its connection information. No
communication can occur over a half-open connection. Compare closed connection, open
connection.
help balloon: A rounded-rectangle window that contains explanatory information for the
user. With tips pointing at the objects they annotate, help balloons look like the bubbles used
for dialog in comic strips. Help balloons are turned on by the user from the Help menu; when
Balloon Help assistance is on, a help balloon appears whenever the user moves the cursor
over its hot rectangle. See also alternate rectangle.

~

wi

hicharge counter: A counter in the Macintosh Portable computer that measures the time
required to raise the battery voltage to 7.2 volts.
high-level event: An event that your application can send to another application to transmit some information, to receive from it some information, or to have it perform some action.
hot rectangle: An area defined to display a help balloon whenever the user moves the
cursor over it. Compare alternate rectangle.
hue: An arbitrary assignment of numbers to colors as used in the HLS and HSV
color systems.
icon family: The set of icons that represent an object, such as an application or document, on the desktop. An entire icon family consists of large (32-by-32 pixel) and small
(16-by-16 pixel) icons, each with a mask, and each available in three different versions of
color: black and white, 4 bits of color data per pixel, and 8 bits of color data per pixel.

Glossary

GL-11

—

—)

”
2)
as
aa

“I

ol

Inside Macintosh,

Volume VI

ideographic: Used to describe a type of character representation in which characters do
not represent pronunciation alone, but are also related to the component meanings of words.
For example, Japanese Kanji, Chinese Hanzi, and Korean Hanja are ideographic.

idle state: A state in which the Macintosh Portable computer slows from its normal
16 MHz clock speed to a | MHz clock speed. The Power Manager puts the Macintosh
Portable in the idle state when the system has been inactive for 15 seconds.
informational selector: A selector code that only provides information and should never
be used as an indication of some feature’s existence. Compare environmental selector.
inhibited color: A usage category for colors in a palette. It specifies the devices on which
the color should not be displayed.
inline input: A keyboard input method (often used for double-byte script systems) in
which conversion from a phonetic to an ideographic representation of a character takes
place at the current line position where the text is intended to appear rather than in a
separate window. This allows the user to type text directly in the line instead of in a special
conversion window.
instructions: Commands that a font manufacturer includes with a TrueType font that
instruct the Font Manager how to improve the appearance of outline glyphs under various
conditions, such as low resolution or small point size.
interapplication communication (IAC): A collection of features, provided by the
Edition Manager, Apple Event Manager, Event Manager, and PPC Toolbox, that help
applications work together. You can use these managers to share data, send and receive
events, or exchange low-level message blocks.
international resources: Resources that are used specifically by the Macintosh Script
Management System, including the International Utilities Package. The international
resources contain information specific to language or region, such as date and time formats.
You can use multiple formats for different languages or regions with the same script system
by adding multiple versions of the international resources. Each installed script has one or
more ‘itlO’, ‘itll’, 'itl2', 'itl4', and optional 'itl5' resources, and the resource [Ds are
generally in the range used for that script’s fonts.

internet address:
network number.

An AppleTalk address that includes the socket number, node ID, and

jump table: An area of memory in the application partition that contains one entry for every
externally referenced routine in every code segment of your application. The jump table is the
means by which the loading and unloading of segments is implemented.
justification: A type of alignment that involves the spreading or compressing of printed
text to fit into a given line width—so that it is flush on both the left and right edges of the
destination rectangle. Also called full justification. See also alignment.
keyboard icon: A small icon associated with each keyboard layout (‘'KCHR' resource).
Before system software version 7.0, the keyboard icon was of type 'SICN'; in version 7.0,
the keyboard icon includes an icon family with types 'kes#', 'kcs4', and 'kces8'. These icons
are used in the new Keyboard menu and the Keyboard control panel.

GL-12

— Glossary

Glossary

keyboard resources: A category of files that are stored in a resource file by the Resource
Manager and are used by the Macintosh Script Management System, including the International Utilities Package. The keyboard resources include some localizable information such as

keyboard layouts ('KCHR' resources) as well as hardware-specific information (for example,
the 'KMAP' and 'KCAP' resources).

keyboard script: The script for keyboard input. It determines the character input method
and the keyboard mapping—that is, what character codes are produced when a sequence of
keys is pressed.
keyword: A four-character code used to uniquely identify the descriptor record for
either an attribute or a parameter in an Apple event. In Apple Event Manager functions,
constants are typically used to represent the four-character codes.
keyword-specified descriptor record: A record of data type AEKeyDesc that
consists of a keyword and a descriptor record. Keyword-specified descriptor records
are used to describe the attributes and parameters of an Apple event.
language: On the Macintosh computer, the graphic representation of words and methods
of combining words, as opposed to the spoken representation of words. This has implications for the treatment of languages, including the numeric codes assigned to represent each
language. A spoken language that may be written in more than one script is treated on the
Macintosh as several languages: one for each script in which the language is written. See also
language code, natural language, programming language, script, script code.
language code: A number used to indicate a particular written version of a language on
the Macintosh. In system software version 7.0, constants for these numbers are defined in
the MPW files Language.p, LanguageEqu.a, and Language.h.
LAP Manager: A

set of operating-system utilities that provide a standard interface between

the AppleTalk protocols and the various link access protocols, such as LocalTalk (LLAP),

EtherTalk

(ELAP), and TokenTalk (TLAP).

leading: Pronounced “LED-ing”; the amount of blank vertical space between the descent
line of one line of text and the ascent line of the next line of single-spaced text.
left-side bearing:

The offset from the glyph origin to the left edge of the bounding box.

line spacing: The leading of a font plus the distance from the ascent line to the
descent line.
link access protocol: An AppleTalk protocol that controls the access of a node to the
network hardware. A link access protocol makes it possible for many nodes to share the same
communications hardware.
localization: The process of adapting software to a particular region, language, and
culture. Script and language adaptations are necessary but not sufficient for this process.
Localization also includes date and time formats, keyboard resources, and fonts.

localized system software: Macintosh system software that has been adapted to a
particular region, language, and culture. Japanese system software is the combination of the
U.S. system software (including the Roman Script System, the Macintosh Operating System,

Glossary

GL-13

Inside Macintosh,

Volume

V1

the Toolbox, and so forth) and the Japanese Script System, all of which are adapted for use
in Japan. The French and Turkish versions of the Macintosh system software are examples of
localized variations of the U.S. system software that do not include a second script system.
location name: An identifier for the network location of the computer on which a port
resides. The PPC Toolbox provides the location name. It contains an object string, a type
string, and a zone. An application can specify an alias for its location name by modifying its
type string. See also port.
luminance: The intensity of light in a color. Color QuickDraw uses a color’s luminance to
convert the color to an appropriate gray-scale color.
MACE:

See Macintosh Audio Compression and Expansion.

Macintosh

Audio

Compression

and

Expansion

(MACE):

A

set of Sound

Manager routines that allow your application to compress and expand audio data.
Macintosh Script Management
Macintosh script systems.

System:

The Script Manager and one or more

main screen: The screen on which the menu bar appears. QuickDraw uses it to determine
global coordinates.
major switch: The Process Manager switches the context of the foreground process
with the context of a background process (including the AS worlds and low-memory
globals) and brings the background process to the front, sending the previous foreground
process to the background. See also context.
message block: A byte stream that an open application uses to send data to and receive
data from another open application (which can be located on the same computer or across a
network). The PPC Toolbox delivers message blocks to an application in the same sequence
in which they were sent.
minimum partition size: The actual partition size limit below which your application
cannot run.
minor switch: The Process Manager switches the context of a process to give time to a
background process without bringing the background process to the front.
mixed-directional text: The combination of scripts with left-to-right and right-to-left
directional text—within a single line.
modal-dialog filter function: A function supplied by your application for handling
events received from the Event Manager while a dialog box is displayed.
mouse-down region: The region between the caret position and the middle of an adjacent
character mapped unambiguously to a single character offset.
multibyte script system: A script system that represents exceedingly large character
sets and requires comprehensive procedures for character input. Examples of multibyte script
systems are Japanese, Chinese, and Korean. See also script system.

GL-14

— Glossary

Glossary

multicast address: An Ethernet address for which the node accepts packets just as it does
for its permanently assigned Ethernet hardware address. In a multicast address, the low-order
bit of the high-order byte is set to 1. Each node can have any number of multicast addresses,
and any number of nodes can have the same multicast address. The purpose of a multicast
address is to allow a group of Ethernet nodes to receive the same transmission simultaneously,
in a fashion similar to the AppleTalk broadcast service. See also broadcast address.
name:

In AppleTalk, consists of three fields: the object, type, and zone.

Name-Binding Protocol (NBP): An AppleTalk protocol that maintains a table that
contains the internet address and name of each entity in the node that is visible to other entities
on the internet (that is, each entity that has registered a name with NBP).
natural language: The whole body of words and methods of combining words used by a
particular group of people.
NBP:

See Name-Binding

Protocol.

notification: An audible or visible indication that your application (or other software)
requires the user’s attention.
notification queue:

The Notification Manager’s list of pending notification requests.

notification record: The internal representation of a notification request, through which
you specify how a notification is to occur.
notification request:

A request to the Notification Manager to create a notification.

notification response procedure: A procedure that the Notification Manager can
execute as the final step in a notification.
object: The first field in the name of an AppleTalk entity. The object is assigned by the
entity itself and can be anything the user or application assigns. See also name, type, zone.
offscreen graphics world: A graphics environment created by the offscreen graphics
routines of the Graphics Devices Manager.

2
°
7
wn
te

an

Open Application event: An Apple event that asks an application to perform the tasks—
such as displaying untitled windows—associated with opening itself; one of the four required
Apple events.
open connection: The state of a connection when the two connection ends have
established communication. Compare closed connection, half-open connection.
Open Documents event: An Apple event that requests an application to open one or
more documents specified in a list; one of the four required Apple events.
optional parameter: A supplemental parameter in an Apple event used to specify data that
the server application should use in addition to the data specified in the direct parameter.
Optional parameters are listed in the attribute identified by the keyOptionalKeywordAttr
keyword. Applications use this attribute to specify or determine whether data exists in the form

Glossary

GL-15

a

|

Inside Macintosh,

Volume

VI

of optional parameters. Optional parameters need not be included in an Apple event; default
values for optional parameters are part of the event definition. It is the responsibility of the
server application that handles the event to supply values if optional parameters are omitted.
See also Apple event attribute, Apple event parameter.
outline:

The mathematical description of the Bézier curves that make up an outline glyph.

outline font: A collection of outline glyphs in a particular typeface and style with no
size restriction. The Font Manager can generate thousands of point sizes from the same
TrueType font.
outline glyph: The model of a glyph in an outline font, described mathematically by
lines and arcs between points.
outline point: A point used by the Font Manager to calculate the lines and curves that
constitute an outline glyph. See also Bézier curve.
page:

The basic unit of memory used in virtual memory.

paging:

The process of moving data between physical memory and the backing-store file.

paging

device:

palette:

A collection of color records, each containing an RGB color and its usage category.

The volume that contains the backing-store

file.

partition: A contiguous block of memory that the Process Manager allocates for an application’s use. The partition is divided into specific areas: application heap, A5 world,
and stack.
phonetic order:
pixel:

The order in which characters are pronounced.

Short for picture element; the smallest dot you can draw on the screen.

pixel map: A data structure that contains information about an image’s pixels, including
their arrangement for display, the number of bits per pixel (its depth), and the colors the
image requires.
play from disk: The ability of the Sound Manager to play sampled sounds stored on disk
(either in a file or in a resource) continuously without audible gaps.
point: (1) A unit of measurement for type. Twelve points equal 1 pica, and 6 picas equal
| inch; thus, | point equals approximately / inch. (2) The intersection of a horizontal grid
line and a vertical grid line on the coordinate plane, defined by a horizontal and a vertical
coordinate. See also outline point.
port: (1) A portal through which an open application can exchange information with
another open application using the PPC Toolbox. A port is designated by a port name and a
location name. An application can open as many ports as it requires so long as each port
name is unique within a particular computer. (2) A connection between the CPU and main
memory or a device (such as a terminal) for transferring data. (3) A socket on the back panel
of a computer where you plug in a cable for connection to a network or a peripheral device.

GL-16

Glossary

Glossary

port name: A unique identifier for a particular application within a computer. The port
name contains a name string, a type string, and a script code. An application can specify
any number of port names for a single port so long as each name is unique. See also port.
Power Manager: The firmware that provides an interface to the power management
hardware in the Macintosh Portable computer. The Power Manager also provides some
services unique to the Macintosh Portable—such as reading the current clock speed—that
are not directly related to power control. See also Power Manager IC.
Power Manager IC: The 50753 microprocessor in the Macintosh Portable computer.
The Power Manager IC (along with other circuits) controls power to the various subsystems
of the Macintosh Portable. See also Power Manager.
Preferences folder: A directory located in the System Folder for holding files that record
users’ configuration settings for applications on a particular Macintosh computer.
preferred partition size: The partition size at which your application can run most
effectively and which the Operating System attempts to secure upon launch of the application.
primary caret: The high caret that is displayed at the primary caret position for the
character offset in the primary line direction. See also dual caret.
primary caret position:

The screen location (denoted by a primary caret) associated

with the character that has the same direction as the primary line direction.

PrimaryInit record: A data structure in the declaration ROM of a NuBus card that
contains initialization code. The Slot Manager executes the code in the PrimaryInit record
when it first locates a declaration ROM during system startup. See also SecondaryInit
record.
primary line direction: The dominant line direction of the current script system,
specified by the value of the system alignment global variable, TESysJust.
Print Documents event: An Apple event that requests that an application print a list of
documents; one of the four required Apple events.
PrintMonitor Documents folder: A directory located in the System Folder for storing
spooled documents waiting to be printed.
privilege model:

A set of conventions for controlling access to stored files.

process: An open application or, in some cases, an open desk accessory. (Only desk
accessories that are not opened in the context of another application are considered processes.)
process serial number: A number assigned by the Process Manager to identify a
particular instance of an application during a single boot of the local machine.
programming language: A set of symbols and associated rules or conventions for
writing programs. For example, BASIC, Logo, and Pascal are programming languages.
publish: To make data available to other documents and applications through a publisher.
When a user creates or edits the data in the publisher and then saves it, the current version of
the data is stored in an edition. See also edition, publisher,

subscribe.

Glossary

GL-17

2¢
7
D

m

Law |

<<

Inside Macintosh,

Volume

V1

publisher: A portion of a document that makes its data available to other documents or
applications. A publisher stores its data in an edition whenever a user creates or edits the data
in the publisher and then saves it. See also edition, section, subscriber.

query: A string of commands and data sent to a database or other data source. A query
does not necessarily extract data from a data source; it might only send data or commands to a
database or other application.
query definition function: A function contained in a query document that prompts
the user for information and modifies the query before the Data Access Manager sends it to
the data server.
query document: A file of file type 'gery' containing commands and data in a format
appropriate for a database or other data source. An application uses high-level Data Access
Manager routines to open a query document.
query record: A data structure in memory containing information provided by a ‘qrsc'
resource. The query record includes a pointer to a query.
Quit Application event: An Apple event that requests that an application perform the
tasks—such as releasing memory, asking the user to save documents, and so on—associated
with quitting; one of the four required Apple events. The Finder sends this event to an application immediately after sending it a Print Documents event or if the user chooses Restart or
Shut Down from the Finder’s Special menu.
region:

(1) An arbitrary area or set of areas on the QuickDraw coordinate plane. The outline

of a region should be one or more closed loops. (2) A linguistic or cultural entity that does not
necessarily correspond to a province or nation and is associated with a number, called a
region code, that indicates a specific localized version of Macintosh system software.
region code: A number used to indicate a particular localized version of Macintosh
system software. Constants for region codes are defined in the MPW files PackMacs.a,
Packages.h, and Packages.p.
relative path:

The path through a volume’s hierarchy from one file or directory to another.

required Apple event: One of four core Apple events that the Finder sends to applications. These events are called Open Documents, Open Application, Print Documents, and
Quit Application. They are a subset of the core Apple events.
required parameter: A keyword-specified descriptor record in an Apple event that must
be specified. For example, a list of documents to open is a required parameter for the Open
Documents event. Direct parameters are often required, and other additional parameters
may be required. Optional parameters are never required.
Rescued Items from volume name folder: A directory located in the Trash directory
that is created by the Finder at system startup, restart, or shutdown only when it finds items
in the Temporary Items folder, usually after a system crash. The Rescued Items from volume
name directory is named for the volume on which the Temporary Items folder exists. When a
user empties the Trash, all Rescued Items folders disappear.
result handler: A routine that the Data Access Manager calls to convert a data item to a
character string.
GL-18

— Glossary

Glossary

routing table: A table, maintained by RTMP, that specifies the shortest path to each
possible destination network number. See also Routing Table Maintenance Protocol.
Routing Table Maintenance Protocol (RTMP): A protocol used by routers on an
AppleTalk internet to determine how to forward a data packet to the network number to
which it is addressed. See also routing table, RTMP stub.
RTMP:

See Routing Table Maintenance Protocol.

RTMP stub: The portion of the Routing Table Maintenance Protocol contained in an
AppleTalk node other than a router. DDP uses the RTMP stub to determine the network num-

ber (or range of network numbers) of the network cable to which the node is connected and to

determine the network number and node ID of one router on that network cable. See also
Datagram Delivery Protocol.

run: A sequence of text that is contiguous in memory and that has the same attributes,
such as font, size, style, script, color, and direction. See also direction run, script run,
style run.
sampled sound synthesizer:
or computed sounds.
saturation: A measurement
saturated the color.

A sound

of how

much

synthesizer that generates digitally recorded
white a color contains—the

less white, the more

script: A writing system for a human language, which may include characters that are
alphabetic, syllabic, or ideographic. Scripts may differ in the direction in which their
characters and lines are written sequentially, the size of the character set used to represent the
script, and context dependence. Examples of scripts include Roman, Japanese, Arabic, and
Hebrew. Many scripts—like Japanese, Chinese, and Korean—have more than one subscript.
script code: A number indicating a particular script system on the Macintosh. Constants
for these numbers are defined in the MPW interface files ScriptEqu.a, Script.h, and Script.p.
script run:

A sequence of text that is contiguous in memory and that is all in the same script.

script system: A collection of software facilities that provides for basic differences
between writing systems, such as character sets, fonts, keyboards, text collation, and word
breaks. Examples of script systems are Roman, Japanese, Arabic, Traditional Chinese,
Simplified Chinese, Hebrew, Greek, Thai, and Korean. See also script, subscript.
secondary caret: The low caret that is displayed at the secondary caret position for the
character offset. See also dual caret.
secondary caret position: The screen location (denoted by the secondary caret)
associated with the character that has an opposing direction from the primary line direction.
SecondaryInit record: A data structure in the declaration ROM of a NuBus card that
contains initialization code. The Slot Manager executes the code in the SecondaryInit record
after RAM patches to the Operating System have been loaded from disk during system
startup. See also PrimaryInit record.
secondary script: An auxiliary writing system that can be used in documents but does
not control the default behavior of the script system.
Glossary

GL-19

“~~
wi 4
—_—
~
4
if 2)
2)
as
—
_
r]
a

Inside Macintosh,

Volume

V1

section: A document or portion of a document that shares its contents with other documents. The Edition Manager supports two types of sections: publishers and subscribers. A
publisher makes its data available to share and a subscriber subscribes to available data. See
also publisher, subscriber.
selector:

See

selector

code.

selector code: A parameter passed to the Gestalt function indicating what information
about the operating environment the application currently requires.
selector function: The function called by the Gestalt function when an application has
called Gestalt to determine information about the operating environment.
server application: An application that, using the Apple Event Interprocess
Messaging Protocol, offers a service (for example, printing files, spell-checking words,
or performing numerical calculations) to other applications (called client applications),
Apple event servers and clients can reside on the same local computer or on remote computers
connected to a network.
session: (1) A logical (as opposed to physical) connection between two entities (such as a
Macintosh program and a database server) that facilitates the transmission of information
between the two entities. (2) In the PPC Toolbox, an exchange of information between one
open application with a port and another open application with a port. Sessions can occur
between applications that are located on the same computer or across a network. An application has the option to accept or reject a session request. Authentication of the requesting user
may be required before a session can commence. See also authentication, message
block, port.
session ID:

A number that uniquely identifies a session.

7.0-compatible:
version 7.0.

Said of an application that runs without problems in system software

7.0-dependent: Said of an application that requires the existence of features that are
present only in system software version 7.0.
7.0-friendly: Said of an application that is 7.0-compatible and takes advantage of some
of the special features of system software version 7.0, but is still able to perform all its
principal functions when operating in version 6.0.
signature: A resource whose type is defined by a four-character sequence that uniquely
identifies an application to the Finder. A signature is located in an application’s resource fork.
simple script system: A script system that represents scripts with small character sets,
requires only single-byte characters, has a text direction of left to right, and is not contextdependent. Examples of simple script systems are Roman and Cyrillic. See also script
system.

sleep demand: A message from the Power Manager that informs a sleep queue routine
that the Power Manager is about to put the Macintosh Portable into the sleep state. When a
routine in the sleep queue receives a sleep demand, it must prepare for the sleep state as
quickly as possible and return control to the Power Manager. See also sleep request,
sleep-request revocation, wakeup demand.
GL-20

Glossary

Glossary

sleep queue: An operating-system queue that contains pointers to all of the routines that
the Power Manager must call before it puts the Macintosh Portable computer into the sleep
state or returns it to the operating state.
sleep request: A message from the Power Manager that informs a sleep queue routine
that the Power Manager would like to put the Macintosh Portable computer into the sleep
state. The routine then has the option of denying the sleep request. See also sleep demand,
sleep-request revocation, wakeup demand.
sleep-request revocation: A message from the Power Manager that informs a sleep
queue routine that the Power Manager has canceled a sleep request. The routine then can
reverse any changes it made in response to the sleep request. See also sleep demand,
sleep request, wakeup demand.
sleep state: A low—power-consumption state of the Macintosh Portable computer. In
the sleep state, the Power Manager and the various device drivers shut off power or remove
clocks from the computer’s various subsystems, including the CPU, RAM, ROM, and
I/O ports.
slop value: The difference between the desired width and actual width before justification
of a line of text or of a style run. The Script Manager justification routines assume the slop
value for a line is to be distributed among the style runs on a line and among the words and
characters within a style run.
slot: A connector into which a card can be installed to expand the capabilities of
a computer.
slot resource:

See

sResource

data

structure.

Slot Resource Table: A table maintained by the Slot Manager that lists all of the
sResource data structures currently available to the system.
sound channel: A queue of sound commands created by the Sound Manager and
linked to a sound synthesizer.

OQ

sound-channel initialization parameter: A parameter passed to the SndNewChannel
function indicating the type of sound characteristics the specified sound channel should have.
sound command: An instruction to a synthesizer to produce sound, modify sound, or
otherwise assist in the overall process of sound production.
sound file: A file of file type 'AIFF' or 'AIFC' that can be used to store sound commands
and sound data. See also sound resource.
sound resource: A resource of resource type ‘snd ' that can be used to store sound
commands and sound data. See also sound file.
sound synthesizer: The executable code (stored in a resource of resource type 'snth’)
that is linked to a sound channel and manages all communication between the Sound Manager
and the available sound hardware. See also sampled sound synthesizer, square-wave
synthesizer,

wave-table

synthesizer.

Glossary

GL-2]

i
7
“a
oe)
is
<

Inside Macintosh,

Volume VI

source application: The application that sends a particular Apple event to another application or to itself. Typically, an Apple event client sends an Apple event requesting a service
from an Apple event server; in this case, the client is the source application for the Apple
event. The Apple event server may return a different Apple event as a reply—in which case,
the server is the source for the reply Apple event.
square-wave synthesizer:
square wave.

A sound synthesizer that generates sounds described by a

sResource data structure:

A data structure in the declaration ROM

of a NuBus card that

defines a function or capability of the card. There is one sResource data structure for each

function the card can perform plus one sResource data structure that identifies the card. Sometimes called a slot resource.

stack: An area of memory in the application partition that is used to store temporary
variables.
Startup Items folder: A directory located in the System Folder for storing applications
and desk accessories that the user wants started up every time the Finder starts up.
static window: A window that doesn’t change its title or reposition any of the objects
within its content area.
stationery pad: A document that a user creates to serve as a template for other documents.
The Finder tags a document as a stationery pad by setting the isStationery bit in the Finder
flags field of the file’s FInfo record. An application that is asked to open a stationery pad
should copy the template’s contents into a new document and open the document in an
untitled window.
status routine: A routine provided by a developer that can update windows, check
the results of the low-level calls made by the Data Access Manager’s DBStartQuery and
DBGetQueryResults functions, and cancel execution of these functions when appropriate
to do so.
style run: A sequence of text that is contiguous in memory and in which all the characters
are in the same typeface, size, style, color, and script. Also called format run.
subscribe: To obtain data that a publisher makes available in an edition. A user subscribes
to a publisher by choosing Subscribe To from the Edit menu and selecting the desired edition.
See also edition, publish.
subscriber: A portion of a document that automatically obtains current data from other
documents and applications. A subscriber reads data from an edition. See also edition,
section.
subscript: A distinguishable subset of characters included within a script. For example,
the subscripts of the Japanese Script System include Hiragana and Katakana (syllabic), Kanji
(ideographic), and Romaji (alphabetic).
syllabic: Used to describe a type of character representation in which the characters stand
for syllables in the language—for example, Japanese Katakana.
symmetrical protocol: A communications protocol in which the two clients at either end
of the connection are equal and can perform exactly the same operations.
GL-22

Glossary

Glossary

synthesizer:

See sound synthesizer.

system alert sound: A sound resource stored in the System file that is played whenever
an application or other executable code calls the SysBeep procedure.
system Apple event dispatch table: A table in the system heap that the Apple Event
Manager uses to map Apple events to those Apple event handlers that are available to all
applications and processes running on the same computer.
system coercion table: A table in the system heap that contains coercion
available to all applications and processes running on the same computer.

handlers

System file: A file, located in the System Folder, that contains the basic system software plus some system resources, such as font and sound resources. In system software
version 7.0, the System file behaves like a folder in this regard: although it looks like a
suitcase icon, double-clicking it opens a window that reveals movable resource files (such
as fonts, sounds, keyboard layouts, and script system resource collections) stored in the
System file.
system menu: A menu that is used to provide access to system features such as application switching, Balloon Help, keyboard script systems, and so forth. All system menus use
icons as titles.
system result handler: A result handler that is available to all applications that use the
Operating System. Compare application result handler.
system script: The primary script system specified in the 'itlc' resource that is used by
various parts of the Operating System—in dialog boxes and menu bars, for example. The
system script affects system defaults, such as the default font, line direction, and so forth. All
other scripts are secondary or auxiliary to the system script. Also called primary script.
target:

The file, directory, or volume described by an alias record.

target address: An application signature, a process serial number, a session ID, a target
ID record, or some other application-defined type that identifies the target of an Apple event.
target application: The application addressed to receive an Apple event. Typically,
an Apple event client sends an Apple event requesting a service from an Apple event server;
in this case, the server is the target application of the Apple event. The Apple event server
may return a different Apple event as a reply—in which case, the client is the target of the
reply Apple event.
Temporary Items folder: A directory located at the root level of a volume for storing
temporary buffer files created by applications. The Temporary Items folder is invisible to
the user.
temporary memory: Memory allocated outside of an application’s heap zone that may be
available for occasional short-term use.
text rendering:

The process of displaying characters that are stored in memory.

32-bit addressing:
memory addresses.

The ability to use all 32 bits of a pointer or handle in determining

Glossary

GL-23

7

wd

=
=

A
wn

=)

or |

<<

Inside Macintosh,

Volume VI

32-bit clean: Said of an application that is able to run in an environment where all 32 bits
of a memory address are used for addressing.
tip: For a help balloon, the point at the side of the rounded rectangle that indicates what
object or area is explained in the help balloon. See also help balloon, variation code.
token: An abstract category (represented by sequences of characters) that stands for a
variable name, symbol, or quoted literal. A token may have more than one representation—
for example, less than or equal to can be represented as <= or S.
tolerant color: A usage category for colors in a palette. It specifies how closely the RGB
color needs to be matched when the color is displayed.
transaction: A sequence of Apple events sent back and forth between a client and a server
application, beginning with the client’s initial request for a service. All Apple events that are
part of one transaction must have the same transaction ID.
transaction-based protocol: A communications protocol in which one socket client
transmits a request for some action and the other socket client carries out the action and transmits a response.
Trash folder: A directory at the root level of a volume for storing files that the user has
moved to the Trash icon. After opening the Trash icon, the user sees the collection of all
items that the user has moved to the Trash icon—that is, the union of appropriate Trash
directories from all mounted volumes. A Macintosh set up to share files among users in a
network environment maintains separate Trash subdirectories for remote users within its
shared, network Trash directory. The Finder for system software version 7.0 empties a Trash
directory (or, in the case of a file server, a Trash subdirectory) only when the user of that
directory chooses the Empty Trash command.
type: The second field in the name of an AppleTalk entity. The type is assigned by the entity
itself and can be anything the user or application assigns. See also name, object, zone.
typeface: A distinctly designed collection of glyphs for a particular character set. Each
typeface has its own name, such as New York or Symbol. Compare font.
unsolicited connection event: An event initiated by ADSP or the remote connection
end that is not in response to any .DSP routine that you executed. See also AppleTalk Data
Stream Protocol.
usage category: A specification of how colors in a palette are to be displayed. Categories
are animated, courteous, explicit, inhibited, tolerant, pn White, and pmBlack.
variation code: In the header component of a help resource, an integer that specifies the
preferred position of a help balloon relative to its hot rectangle. The balloon definition
function draws the frame of the help balloon based on its variation code.
verb:

An integer constant that controls the function of a multipurpose routine.

virtual memory:

The part of the Operating System that allows any properly configured

Macintosh computer with an MMU

beyond the limits of physical RAM.

GL-24

Glossary

(or PMMU)

to extend the available amount of memory

Glossary

wakeup demand: A message from the Power Manager that informs a sleep queue routine
that it must reverse whatever steps it followed when it prepared for the sleep state. See also
sleep demand, sleep request, sleep-request revocation.
wakeup timer: A timer that the Power Manager uses to return the Macintosh Portable
computer from the sleep state to the operating state at a specific time.
wave table:

A sequence of wave amplitudes measured at fixed intervals.

wave-table synthesizer:
a wave table.

A sound synthesizer that generates sounds described by

word: (1) In natural languages, a representation of a sound or a combination of sounds
meaning a certain object, feeling, or idea; one of the basic components of language. A word
comprises one or more characters whose visual representations are called glyphs. (2) Prior
to system software version 6.0.4, as defined by TextEdit, any series of printing characters,

excluding spaces (ASCII code $20) and including nonbreaking spaces (ASCII code $CA).

In system software version 7.0, TextEdit also depends on the Script Manager’s FindWord
procedure, so TextEdit’s definition of a word has been extended. The way TextEdit uses the
Script Manager’s FindWord procedure to calculate word breaks has a significant impact on
word selection. For example, in the system software that is localized for the United States,
parentheses and other punctuation marks are no longer included as part of a word selection.
However, this behavior may vary on other localized versions of the U.S. system software.
Furthermore, when a user double-clicks a series of spaces, that series of spaces is selected
as a word.
word wrap: The automatic continuation of text from the end of one line to the beginning
of the next without breaking in the middle of a word.
working directory: A temporary directory reference that the File Manager uses to
specify both a directory and the volume it resides on. The File Manager assigns a reference
number to each working directory.

worldwide system software: The system software that enables you to create versions
of your applications that run in other regions or work with different scripts and languages.
Worldwide software includes the Macintosh Script Management System and related
components, such as the International Utilities Package, the international resources, the
keyboard resources, the Macintosh script systems, and certain keyboard-handling routines.
ZIP:

See

Zone

Information

Protocol.

zone: A logical grouping of a subset of the nodes on the internet. The zone is the third field
in the name of an AppleTalk entity. See also name, object, type.
Zone Information Protocol (ZIP): An AppleTalk protocol that maintains a table in
each router, called the zone information table, that lists the relationships between zone names
and networks.

Glossary

GL-25

~~

wi

—

—)

2)
~D

r)

=“

<

Inside Macintosh,

GL-26

Glossary

Volume VI

INDEX
eee Tile type: 9-15
"ee" (Wildcard) descriptor type
6-29, 6-72
'----' keyword 6-11

4-bit color icons

6-9,

2-18, 2-20

7.0-compatible applications 3-9
7.0-dependent applications 3-9
7.0-friendly applications 3-9, 3-12
8-bit color icons 2-17, 2-18
16-by-16 pixel icons (small) 2-19, 9-9,
9-12
32-bit addressing
compatibility issues 1-20
defined 28-10
and master pointers 28-11
texting for availability 3-35
32-bit clean 3-28, 28-10
32-bit clean ROMs 3-13
32-Bit QuickDraw. See Color QuickDraw
32-by-32 pixel icons (large) 2-18, 9-9, 9-10
802.2 protocol 32-25 to 32-29
attaching a protocol handler 32-27
calling routines from assembly language
32-27
detaching a protocol handler 32-28
packet headers 32-25, 32-28
802.3 protocol 32-25, 32-90
A

AARP packet type 32-25, 32-28
About command for desk accessories 9-32,
9-33
About string for desk accessories 9-33
ABusVars global variable 32-12
accents
acute 14-97
cedilla 14-97
circumflex 14-97
dead keys for 14-97
grave 14-97
hacek 14-97
keyboard entry of 14-105
and Key Caps 14-100
ogonek 14-97
regional differences in 14-7
support for in word break tables 14-90
tilde 14-97

umlaut

14-97

on uppercase characters

14-33, 14-91

AECountltems function

6-45, 6-77 to 6-78

acceptAppDiedEvents flag 5-16
acceptAppDied flag 6-70
AcceptHighLevelEvent function 5-21, 5-27,
5-30
acceptSuspendResumeEvents flag 5-15
access-control conventions 25-11
access privileges in foreign file systems
25-28 to 25-29, 25-50 to 25-52
ActivatePalette procedure 20-20
activation procedures 26-19
active application 2-14
active field 26-19
active keyboard script 14-15
activity timer
resetting 31-13, 31-19
types of activity 31-6
acute accent 14-97
adapting an application. See localization
additional parameters for Apple events 6-8
AddrBlock data type 32-39
AddResource function 22-59
address descriptor records
adding to an Apple event 6-57 to 6-59
defined 6-10
addresses of Apple events 6-57 to 6-59
'addr' keyword 6-10
'adev' file type 32-8
'adrp' alias type 9-30
ADSP. See AppleTalk Data Stream Protocol
advance width of glyphs 12-6, 12-20
AEAddressDesc data type 6-10, 6-57 to
6-59
AEArrayData data type 6-109
AEArrayType data type 6-109
AECoerceDesc function 6-100 to 6-101
AECoercePtr function 6-100
AECreateAppleEvent function 6-55, 6-86 to
6-87
AECreateDesc function 6-58, 6-87
AECreateList function 6-88
AEDeleteltem function 6-98
AEDeleteKeyDesc function 6-99
AEDeleteParam function 6-99
AEDesc data type 6-9 to 6-10
AEDescList data type 6-11 to 6-12
AEDisposeDesc function 6-99
IN-1

Inside Macintosh,

Volume VI

AEDuplicateDesc function 6-87 to 6-88
AEEventClass data type 6-108
AEEventID data type 6-108
AEEventSource data type 6-109
AEGetArray function 6-79 to 6-80
AEGetAttributeDesc function 6-77
AEGetAttributePtr function 6-44, 6-45,
6-76 to 6-77
AEGetCoercionHandler function 6-102
AEGetEventHandler function 6-73
AEGetInteractionAllowed function 6-82 to
6-83
AEGetKeyDesc function 6-81
AEGetKeyPtr function 6-80 to 6-81
AEGetNthDesc function 6-79
AEGetNthPtr function 6-47, 6-78 to 6-79
AEGetParamDesc function 6-43, 6-45,
6-75 to 6-76
AEGetParamPtr function 6-42, 6-75
AEGetSpecialHandler function 6-104
AEGetTheCurrentEvent function 6-86
AEIMP (Apple Event Interprocess
Messaging Protocol) 6-3
AEInstallCoercionHandler function 6-101,
6-102
AEInstallEventHandler function 6-28 to
6-30, 6-71 to 6-73
AEInstallSpecialHandler function 6-103
AEInteractAllowed data type 6-53, 6-108
AEInteractWithUser function 6-54, 6-83
AEKeyDesc data type 6-11
AEKeyword data type 6-10 to 6-11
AEP 32-7
AEProcessAppleEvent function 6-74
AEPutArray function 6-90
AEPutAttributeDesc function 6-93
AEPutAttributePtr function 6-92 to 6-93
AEPutDesc function 6-89
AEPutKeyDesc function 6-91
AEPutKeyPtr function 6-90 to 6-91
AEPutParamDesc function 6-56, 6-92
AEPutParamPtr function 6-56, 6-91 to 6-92
AEPutPtr function 6-89
AEQ. See AppleTalk Transition Queue
AERecord data type 6-12 to 6-14
AE records

adding data to 6-90 to 6-91
adding keyword-specified descriptor
records to 6-91
creating 6-88
defined 6-12 to 6-14
deleting keyword-specified descriptor
records from 6-99

IN-2

Index

getting data out of 6-80 to 6-81 °
getting descriptor records out of 6-81
getting sizes and descriptor types of
keyword-specified descriptor records in
6-97
relationship to other Apple Event Manager
data structures 6-14
AERemoveCoercionHandler function 6-102
to 6-103
AERemoveEventHandler function 6-73 to
6-74
AERemoveSpecialHandler function 6-104
AEResetTimer function 6-83 to 6-84
AEResumeTheCurrentEvent function 6-84
to 6-85
AESend function 6-62, 6-93 to 6-96
AESendMode data type 6-108
AESendPriority data type 6-108
AESetInteractionAllowed function 6-82
AESetTheCurrentEvent function 6-85
AESizeOfAttribute function 6-98
AESizeOfKeyDesc function 6-97
AESizeOfNthItem function 6-96 to 6-97
AESizeOfParam function 6-97 to 6-98
AESuspendTheCurrentEvent function 6-84
‘aevt' descriptor type 6-9
‘aevt' event class 6-7
AS5 register
and A5 world 28-6
and LwrString trap 14-91
restoring 28-14, 28-16
saving

28-14, 28-16

when using Gestalt selector functions
3-45
when using Notification Manager 24-9,
28-14
when using Sound Manager 22-78
setting in Time Manager tasks 23-13
AS world
and context switching 5-13
defined 28-6
how the Process Manager creates 29-5
routines for setting and restoring 28-16
setting, in Notification Manager tasks
24-9
setting, in Time Manager tasks 23-13,
28-6
setting before calling Script Manager
routines 14-38
AFP (AppleTalk Filing Protocol 25-12,
32-8
AIFF files 22-25 to 22-34
creating 22-93, 22-100

Index

AIFF files (Continued)

playing sounds in 22-15, 22-56
storing sounds in 22-10
AIFF-C files 22-25 to 22-34
creating 22-93, 22-100
playing sounds in 22-15, 22-56
storing sounds in 22-10
ALAP. See LocalTalk Link Access Protocol
alert boxes
displayed by Notification Manager 24-4,
24-5, 24-7
help balloons for 11-33 to 11-49
help balloons for areas outside of 11-58 to
11-61
and the Help menu 11-28, 11-63
for multiple publishers in a document
4-19, 4-30, 4-48, 4-51
for new publisher 4-17
position of 2-23
for PPC session termination 7-6
aliases
defined 9-29
resolving 9-29 to 9-32
style of names 14-40, 14-41, 14-85,
14-86
Alias Manager 27-3 to 27-22. See also alias
records
limitations with MFS disks 25-9
routines in 27-12 to 27-19
testing for availability 3-35, 27-8
alias records
contents 27-4, 27-12
creating 27-9, 27-12 to 27-14
customizing 27-12
defined 27-3
getting information about 27-12
private Alias Manager data 27-5
for publishers and subscribers 4-14, 4-18
reading 27-19
relative path in 27-5
resolving 27-6 to 27-8
functions for 27-9 to 27-11, 27-15 to
27-19
resources 9-29
storing and retrieving 27-11
updating 27-11
alias types 9-30
alignment of text
defined 14-33
flush right 15-16
fully justified 14-33 to 14-34
left 15-19
localization issues 2-8

in right-to-left directional scripts 15-19 to
15-20
routines for handling justified text 14-64
to 14-68
system 15-4, 15-14, 15-19
TextEdit constants for 15-20
‘alis' descriptor type 6-9
‘alis' resource type 4-17, 9-29, 27-11
AllocContig function 25-34
AllowPurgePixels function 21-15
alternate rectangles. See also hot rectangles
defined 11-8
specifying in ‘hdlg' resources 11-36 to
11-37
specifying in HMShowBalloon function
11-53 to 11-54

alternating icon in menu bar 2-15, 24-4, 24-7

‘amnu' folder type 9-43
ampCmd command 22-51, 22-83
amplitude of sounds 22-8
animated colors 20-10 to 20-13
allocation of 20-7
defined 20-5
on direct devices 20-11, 20-12
returned to a device 20-11
AnimateEntry procedure 20-23
AnimatePalette procedure 20-23
AOff procedure 31-22
AOnIgnoreModem procedure 31-21
AOn procedure 31-21
‘appa’ descriptor type 6-9
‘appe’ file type, and the Extensions folder
-4]
AppendDITL procedure 3-19, 3-20 to 3-22
Apple Desktop Bus, testing for last
keyboard used 3-37
Apple event attributes
adding to Apple events 6-92 to 6-93
defined 6-6
event classes 6-7, 6-10
event IDs 6-7, 6-10
event sources 6-10
getting data out of 6-44 to 6-45, 6-76 to
6-77
getting descriptor records out of 6-77
getting descriptor types of 6-98
getting sizes of 6-98
interaction level 6-10, 6-44, 6-51
missed keyword 6-10, 6-44, 6-47 to 6-48
optional keyword 6-10
return ID 6-10, 6-55
setting with AECreateAppleEvent function
6-54 to 6-55
Index

IN-3

Inside Macintosh,

Volume VI

Apple event attributes (Continued)
target address 6-10, 6-57 to 6-59
timeout 6-10, 6-64
transaction ID

6-10, 6-55

AppleEvent data type 6-12 to 6-14
Apple event dispatch tables
getting entries from 6-73
installing entries into 6-28 to 6-30, 6-71
to 6-73
removing entries from 6-73 to 6-74
system 6-28
Apple event handlers
adding to dispatch tables 6-28 to 6-30,
6-71 to 6-73
called from the AEProcessAppleEvent
function 6-74
defined 6-15
getting from dispatch tables 6-73
removing from dispatch tables 6-73 to
6-74
writing 6-47 to 6-48
Apple Event Interprocess Messaging
Protocol (AEIMP) 6-3
Apple Event Manager 6-3 to 6-117
and Event Manager 1-7
routines in 6-71 to 6-104
testing for availability 6-25
use of Notification Manager 6-54
user and server application interaction with
6-51 to 6-54, 6-82 to 6-83
Apple event parameters
adding 6-55 to 6-57, 6-91 to 6-92
additional 6-8
checking for missing required 6-47 to
6-48
defined 6-6
deleting 6-99
direct 6-8, 6-11
error number 6-48 to 6-49
error string 6-49 to 6-50
getting data out of 6-42 to 6-43, 6-75
getting descriptor records out of 6-43,
6-75 to 6-76
getting descriptor types of 6-97 to 6-98
getting sizes of 6-97 to 6-98
optional 6-8, 6-10
required 6-8
Apple event protocol 5-10
Apple event records
defined 6-12 to 6-14
disposing of 6-50 to 6-51
getting data out of 6-80 to 6-81
getting descriptor records out of 6-81
IN-4

Index

relationship to other Apple Event Manager
data structures 6-14
Apple events. See also Apple event
attributes; Apple event parameters
accepting 6-26 to 6-27
addresses for 6-57 to 6-59
and application-defined events 5-3
Application Died 6-71, 29-16
categories of 6-6
client applications using 6-5
components of 6-6 to 6-8
create Publisher 6-38
creating 6-54 to 6-59
data structures in 6-8 to 6-14
defined 6-3
determining current 6-86
dispatching 6-74, 6-83 to 6-86
disposing of 6-50 to 6-51
from Edition Manager 4-12 to 4-14
getting data out of 6-40 to 6-47
Open Application 6-7, 6-31, 6-33
Open Documents. See Open Documents
event
Print Documents 6-7, 6-32, 6-35 to 6-36
processing 6-14 to 6-20, 6-74, 6-83 to
6-86
Quit Application 6-7, 6-32, 6-36 to 6-37
relationship to high-level events 6-26 to
6-27
reply. See reply Apple events
replying to 6-48 to 6-50, 6-66 to 6-67
requesting services through 6-19 to 6-24
required 3-11, 6-30 to 6-37
Reset Timer 6-84
responding to 6-14 to 6-19, 6-20, 6-26 to
6-27
resuming handling of 6-84 to 6-85
return IDs in 6-55
Section Cancel 4-12
Section Read. See section Read event
Section Scroll 4-12, 4-43, 4-77, 6-38
Section Write 4-12, 4-19, 6-37
sending 6-59 to 6-63
server applications using 6-5
supporting 1-12
suspending handling of 6-84
testing for availability 3-35, 6-25
transaction IDs in 6-55
Apple menu
alternating icon and 24-4, 24-7
applications in 9-32
help balloons for 11-10 to 11-13

Index

Apple Menu Items folder 10-3
alias type for 9-30
defined 9-4]
finding 9-43
Apple Publications Style Guide 2-13
Apple reserved keyboard equivalents 2-35
AppleShare
local version 25-4
and paging devices 28-18
Apple Sound Chip (ASC)

22-3, 22-6, 22-54

AppleTalk. See also AppleTalk Manager:
protocols, AppleTalk
application interfaces 32-10
connection files 32-8
connection listening sockets 32-39
data links 32-4
device drivers 32-8 to 32-10
getting information about 32-12 to 32-16
internet addresses 32-7
names of entities 32-7
network addresses 32-15
network numbers
determining range 32-12
and Phase 2 32-6
value of 32-15
and Power Manager 31-8
router addresses 32-15
sessions 32-7
wildcard characters in 32-16
zone information table 32-7
zones 32-7
getting information about 32-31 to
32-37
AppleTalk Address Resolution Protocol
(AARP) 32-25, 32-28
AppleTalk Data Stream Protocol (ADSP)
32-37 to 32-78. See also .DSP driver
attention-message buffer 32-44
attention messages
attention codes 32-40
connection event flag 32-40
handling 32-47
sending 32-77
and user routines 32-56
connection control block 32-38 to 32-40
connection ends
closing 32-67
configuring 32-45, 32-60 to 32-62
defined 32-38
establishing 32-58 to 32-60
filterAddress 32-64, 32-71
ID numbers 32-64, 32-67
removing 32-68

resetting 32-78
state of 32-39
connection events
types 32-40
user routines 32-56 to 32-57
connection listeners 32-52 to 32-55
activating 32-70 to 32-71
closing 32-72
defined 32-38, 32-69
establishing 32-52 to 32-53, 32-69 to
32-70
how to use 32-53 to 32-54
routines 32-69 to 32-78
sample code 32-54
connection listening sockets 32-39
connection requests, listening for 32-70 to
32-71
connections
closing 32-47 to 32-48, 32-67 to 32-69
denying an open request 32-72
determining the status of 32-73
establishing 32-58 to 32-67
maintaining 32-46 to 32-47, 32-73 to
32-78
opening 32-43 to 32-46, 32-62 to 32-66
connection servers, defined 32-69
filter address 32-64, 32-71
how to use 32-38 to 32-57
opening modes
descriptions 32-62
summary 32-66
parameter block 32-40 to 32-43
reading data 32-46 to 32-47, 32-74
receive queue
defined 32-44
and dspInit routine 32-59
and dspRead routine 32-46
relationship to other protocols 32-6, 32-8
routines in 32-58 to 32-78
sequence of use 32-43 to 32-54
sample code
connection listeners 32-54
user routine 32-57
using ADSP 32-48
send queue
defined 32-44
and dspInit routine 32-59
and dspWrite routine 32-46
flushing 32-76
sequence numbers 32-65
user flags 32-39
when to use 32-12
writing data 32-46, 32-75
Index

IN-5

Inside Macintosh,

Volume VI

AppleTalk drivers 32-8 to 32-10. See also
AppleTalk Manager
-ATP driver 32-29 to 32-31
-DSP driver. See .DSP driver
-ENET driver. See .ENET driver
-MPP driver 32-12 to 32-16
testing for versions 3-35, 32-11
.XPP driver. See .XPP driver
AppleTalk Echo Protocol (AEP)

32-7

AppleTalk Event Queue. See AppleTalk
Transition Queue
AppleTalk Filing Protocol (AFP) 25-12,
32-8
AppleTalk Link Access Protocol. See
LocalTalk Link Access Protocol
AppleTalk Manager 32-3 to 32-110. See
also AppleTalk; AppleTalk drivers;
protocols, AppleTalk
changes to 32-4
closing
denying permission 32-23
granting permission 32-23
requesting permission 32-20
how touse 32-11 to 32-12
references to other books 32-3
references to other volumes P-16
routines in
AppleTalk Transition Queue 32-18 to
32-21, 32-24 to 32-25
.ATP driver 32-29 to 32-31
-DSP driver 32-58 to 32-78
-ENET driver 32-88 to 32-96
LAP Manager 32-27 to 32-29
-MPP driver 32-12 to 32-16
.XPP driver 32-34 to 32-37
status change (AppleTalk transition). See
AppleTalk Transition Queue
testing for version 32-1]
AppleTalk Phase 2
features 32-4
and Macintosh models 32-3
testing for availability 32-11
AppleTalk Session Protocol (ASP)

described 32-7
when to use 32-11
AppleTalk Transaction Protocol (ATP)
32-29 to 32-31
ATPGetRequest function, canceling calls
to 32-29
described 32-7
release timer, setting 32-30
when to use 32-11

IN-6

Index

AppleTalk Transition Queue (ATQ) 32-17
to 32-24
adding fields 32-18
entries
adding 32-18
how called 32-21 to 32-24
removing 32-19
when called 32-21
sending messages to 32-20 to 32-21
transitions
cancel-close 32-23
defining 32-24
developer-defined 32-24
open 32-22
permission-to-close 32-23
prepare-to-close 32-22
routine selectors 32-21
'APPL' file type 9-8
application creator string 3-42
Application Died event 6-71, 29-16
application heap 29-5
application icons
creating 2-18 to 2-21, 9-9 to 9-13
default 9-10
help balloons for 11-56 to 11-58
application interfaces, AppleTalk 32-10
Application menu
alternating icon in 2-15, 24-4, 24-7
desk accessories in 9-32
diamond-shaped mark in 24-4, 24-7
disabled during modal dialog 3-14
help balloons for 11-10 to 11-13
relationship to other menus 3-15
application partitions 28-5
applications
adding to desktop database 9-56
alias type for 9-30
in Apple menu 9-32
in Apple Menu Items folder 9-41
creating icons for 2-18 to 2-21, 9-9 to
9-13
default icon for 9-10
help balloons for icons 11-56 to 11-58
launching from the Finder 9-24 to 9-26
removing from the desktop database 9-57
application stack 29-5
application-unavailable alert box messages
9-20 to 9-22
application zone 28-4
ApplZone 28-5
arrow keys, actions for selected text 15-14
ascent line of fonts 12-6
ASP. See AppleTalk Session Protocol

Index

assembly-language information
compatibility issues 3-6
conventions for notes P-6
AssociateSection function 4-18, 4-43, 4-65
‘wt’ file type 9-15
‘x’ (Wildcard) descriptor type 6-9, 6-29,
6-72
asynchronous calls, Data Access Manager
8-10, 8-50 to 8-51
asynchronous parameter block record 8-50
to 8-51
ATEvent procedure 32-24
ATP. See AppleTalk Transaction Protocol
.ATP driver 32-29 to 32-31. See also
AppleTalk Transaction Protocol
ATPKillAllGetReg function 32-29
ATPParamBlock data type 32-30
ATPreFlightEvent function 32-24
ATQ. See AppleTalk Transition Queue
ATQentry data type 32-17
attention codes, ADSP 32-40
attention-message buffer 32-44, 32-59
attention messages
attention codes 32-40
connection event flag 32-40
handling 32-47
sending 32-77
and user routines 32-56
attributes of Apple events. See Apple event
attributes
audible notifications 2-15, 24-4
Audio Interchange File Format (AIFF). See

AIFF
Audio Interchange File Format extension for
Compression (AIFF-C). See AIFF-C
AudioSelection data type 22-58
authentication of users 7-8, 7-24
defined 7-7
automatic gain control 22-65
A/UX
accessing hardware under 3-7
running Macintosh applications under
3-6, 3-24 to 3-28
testing for version 3-35
using Sound Manager under 22-3
writing to 'CODE' segments under 23-14
A/UX Release 2.0 3-26
A/UX Toolbox 3-24 to 3-27
availableCmd command 22-41, 22-83,
22-87

background applications
and Extensions folder 9-41

making notification requests

24-3, 24-7

background notification. See Notification
Manager
background-only application 29-4
background processes 29-4
background tasks, making notification
requests 24-3, 24-7
backing-store file 28-10
backing-store order 14-36, 15-5 to 15-6
backing volume 28-18
BackwardTable state table 14-5]
balloon definition function
creating 11-64 to 11-65
standard 11-6
Balloon Help on-line assistance. See also
help balloons
for customized Open and Save dialog
boxes 26-1]
defined 11-3
determining whether enabled 11-65
enabling and disabling 11-3, 11-5, 11-66
for icons 9-34 to 9-35
for Keyboard menu 14-21
user interface guidelines 11-14 to 11-17
base line of fonts 12-6
battery, Macintosh Portable
calculating voltage 31-23
charging 31-23
low voltage 31-4, 31-14, 31-16, 31-24
reading the status of 31-23 to 31-24
BatteryStatus function 31-23
Bézier curves 12-10 to 12-12
BIC transfer mode 17-16
bidirectional script systems 14-16
bidirectional text 14-30
bitmapped fonts
compared to outline 12-8
defined 12-4
bitmapped glyphs. See also bitmapped fonts;

glyphs

defined 12-4
bitmaps
for bitmapped glyphs 12-4
for outline glyphs 12-13 to 12-14
BitMapToRegion function 17-25
BitTst function 3-34
black-and-white icons 2-19
BlockMove procedure 22-77
'BNDL' resource type 9-16 to 9-19
Index

IN-7

Inside Macintosh,

Volume VI

BOff procedure 31-22
BOn procedure 31-21
‘bool’ descriptor type 6-9
borders for publishers and subscribers 4-7
to 4-9, 4-43 to 4-46
in bitmapped graphics 4-50
in compound publishers 4-44
in object-oriented graphics 4-49
Show/Hide Borders command 4-44
in spreadsheets 4-48
in word processors 4-47
bottleneck procedures 17-19
boundaries
character offset 15-8
direction 15-8
script 15-13
bounding box of glyphs 12-6, 12-21
BreakTable data type 14-126
BreakTablePtr data type 14-126
broadcast addresses, Ethernet

32-79

BTst function 3-34
bufferCmd command 22-43, 22-84
buffers
ADSP attention messages 32-44, 32-59
ADSP connection control block
attention message 32-40
data 32-40
for double-byte characters 15-13, 15-23
ADSP receive queue 32-44, 32-59
ADSP send queue 32-44, 32-59
dspRead routine data 32-74
dspWrite routine data 32-75
EGetInfo function data 32-93
-ENET driver data packets 32-81, 32-94
ERead function data 32-92
GetLocalZones function
for ZIP 32-36, 32-37
zone names 32-36
GetMyZone function
for ZIP 32-35
zone names 32-35
GetZoneList function, zone names

32-37

PGetAppleTalkInfo function
data link address 32-16
local node zone name 32-16
ReadPacket routine data 32-87
ReadRest routine data 32-87
for text 15-23
bundle bit 9-37
bundle resources. See also 'itlb' resource
creating 9-16 to 9-19
used in desktop database 9-45
bus error vectors 28-24
IN-8

Index

buttons
names

2-26 to 2-28

placement

2-29

Cc
caching and virtual memory
CalcColorTable function
calendars
codes for 14-114

28-20, 28-28

18-14

extra day and month names for 14-28
formats for 14-28
‘itll’ resource extensions
localization 14-107

multiple

14-87 to 14-89

14-28, 14-87

use in worldwide software 2-5
callBackCmd command 22-84
callback routines. See also status routines
with MatchAlias function 27-20
with SndNewChannel function 22-77 to
22-79, 22-81

with Standard File Package routines
26-11 to 26-19

CallEditionOpenerProc function 4-56, 4-79
CallFormatlOProc function

canBackground flag 5-15

4-60, 4-80

Cancel button 2-27
Cancel Publisher button 4-41
Cancel Subscriber button 4-41

‘card’ resource type 10-7
cards, NuBus. See also Slot Manager;
sResource data structures

enabling and disabling 30-6

EtherTalk 32-79
initialization 30-4
carets
dual 14-109, 15-9 to 15-10
movement across direction boundaries
15-11

position
for highlighting

15-6 to 15-7

at line ends 15-14 to 15-15
vertical movement of 15-14
case conversion routines 14-62 to 14-63
case conversion tables 14-90 to 14-91

catalogs

defined

25-10

effects of FSpExchangeFiles

25-17

Finder information in 9-36 to 9-38

searching

25-20 to 25-25, 25-40 to 25-42

CatMove function 25-35
CCB 32-38 to 32-40

Index

cedilla

10-6 to 10-7

14-90, 14-97

CGrafPort data type 21-4
character codes
avoiding as delimiters 14-104
double-byte 14-34, 14-108
and glyphs 12-5
localizing 14-34, 14-108
mapping from key codes 14-96
in relation to cursor movement 2-6
and script identification 14-23
and scripts 14-109
for standard Roman character set 12-5
storing in memory 14-36
character offsets 15-6, 15-7
boundaries for 15-9
determining the position of 15-31 to 15-32
at line breaks 15-32
in mouse-down positions 15-8
characters. See also accents; character codes;

glyphs

alphabetic representation of 14-30
avoiding special codes as delimiters 14-104
context dependence of 14-32
conversion offsets 14-92
defined 12-3
double-byte 15-13
end-of-line 15-26
ideographic representation of 14-30
ignorable 14-27
input of

14-35, 15-11 to 15-12

leading edge of 14-68
lowercase 14-32
parsing into words 15-56 to 15-58
reordering 14-33
representation of 14-30
Roman in non-Roman fonts 14-108
routines for obtaining information 14-45
syllabic representation of 14-30
tokens for

14-12

trailing edge of 14-68
type offsets 14-92
type tables 14-90
uppercase 14-32
character sets
codes for and script codes 14-8
original Macintosh 14-104
standard Roman 12-5, 14-104
CharByte function 14-45
byte types 14-114

CharByteTable data type 14-124
Char2Pixel function 14-45, 14-64, 15-8,
15-27
CharType function 14-45
constants 14-114 to 14-115
to get language-specific information
14-103
localizing character type tables for 14-90
to 14-9]

modification of tables for, in U.S. system

14-105
relocation of tables for, in 'itl2' resource
14-9]
ChunkHeader data type 22-27
chunks (in AIFF and AIFF-C files)
Common 22-29 to 22-31
data types used to describe 22-27
Form 22-27 to 22-28
Format Version 22-28 to 22-29
list of types 22-26
local 22-28
organization of 22-26 to 22-27
Sound Data 22-31 to 22-32
‘cicn' resource type 10-13
circumflex accent 14-97
client applications for Apple events 6-5,
6-52 to 6-53
clients, of AppleTalk protocols 32-5
Clipboard 5-20
clock speed, reading in Macintosh Portable
31-20
close boxes, help balloon for 11-10 to
11-12, 11-58 to 11-61
Close command 9-32
CloseEdition function 4-25, 4-70 to 4-71
CloseWD function 25-35
CLUT (color look-up table)

16-17. See also

color tables
CmpSoundHeader data type 22-47
CMYColor data type 19-6
CMYK color model 19-6
CMY2RGB procedure 19-10
codes

character. See character codes
key 14-15, 14-24
language. See language codes
number representation 14-85, 14-114
optional calendar 14-28, 14-114
region 14-7, 14-84
script. See script codes
table 14-77
translating from key to character 14-23 to
14-25
Index

IN-9

xapuy

cdev. See control panels
‘cdev' file type 10-3
for Monitors extension
cdev function 10-4

Inside Macintosh,

Volume VI

code, self-modifying 23-14
coercion handlers for descriptor types
6-67 to 6-70, 6-101 to 6-103
color
guidelines for use of 2-16 to 2-20
introduced with Macintosh II 16-3
color banks 18-13
color environment
changing 20-6 to 20-7
restoring 20-7 to 20-8
color grafPort record
direct pixels and 16-18
in graphics environment 21-3
indexed pixels and 16-16
modifying 17-27
offscreen 21-5
overview of 16-12
color icons
defining 9-10 to 9-12
guidelines for designing 2-19 to 2-20
for keyboards 14-20
using with the Notification Manager 24-7
ColorInfo data type 20-5
colorizing in Color QuickDraw 17-16
color look-up tables. See color tables
Color Manager 16-7
color menu 9-12
color models 19-4 to 19-8
CMYK 19-6
converting between 19-9, 19-10
HLS 19-6 to 19-8
HSV 19-6 to 19-8
RGB 19-4 to 19-6
Color Picker dialog box
and color models 19-8
displaying 19-8 to 19-9

example of 19-3

prompt string for 19-10
Color Picker Package 19-3 to 19-13
routines in 19-9 to 19-1]
summarized 16-7
Color QuickDraw 17-3 to 17-30. See also
QuickDraw; version 2 picture format
compatibility of different versions 16-18
to 16-19
completion of drawing, determining
17-20, 17-26
converting bitmaps to regions 17-19,
17-25
copying pixel images 17-12 to 17-17
data structures, modifying 17-10 to 17-11
device-independence of 16-5
image resolution 17-18 to 17-19
IN-10

Index

luminance mapping 17-18
new result codes 17-28
references to other volumes P-12
relationship to rest of graphics package
16-7, 16-17
routines in 17-25 to 17-28
versions of 16-6
colors
guidelines for using 2-16 to 2-21
Label menu commands for 9-12
matching 20-10
color sampling methods
constants for choosing 18-4
creating yourown 18-12 to 18-14
methods of 18-4
specifying for GetPictInfo 18-10
specifying for GetPixMapInfo 18-10
specifying for NewPictInfo 18-11
color tables
for animation 20-10, 20-23
default 17-18, 20-7, 20-8
defined 16-10
palettes and 20-17
and pixel depth 16-8
color usage categories 20-8 to 20-13
combining 20-6, 20-12 to 20-13
defined 16-10
list of 20-8
Command-key equivalents. See keyboard
equivalents
commands, menu. See menu commands
comment information, obtaining from a
picture 18-7
CommentSpec data type 18-7
CommentType data type 14-128
CommonChunk data type 22-29
common parent in alias records 27-5
communication over a network 1-23. See
also AppleTalk; interapplication
communication
Communications Resource Manager, testing
for availability 3-36
Communications Toolbox 1-23, 3-10
testing for version 3-36
compatibility. See also Gestalt Manager
accessing hardware warning 3-7
AppleTalk Phase 2 and Macintosh models
32-3
assembly-language considerations 3-6
A/UX guidelines 3-24 to 3-28
customized standard file dialog boxes
26-20
defined 3-5

Index

compatibility (Continued)
general guidelines 3-5 to 3-9
localizing applications 3-22 to 3-24
low-memory global variables warning 3-7
and memory use 3-6
trap availability 3-7 to 3-9
version 7.0 guidelines 3-9 to 3-22
‘comp’ descriptor type 6-9
completion routines
for .DSP routines 32-43
VO 28-3
in PPC Toolbox 7-13 to 7-14, 7-37 to 7-39
for PPCAccept function 7-30 to 7-31
for PPCInform function 7-29 to 7-30
for PPCRead function 7-32 to 7-33
for PPCReject function 7-31
for PPCWrite function 7-33 to 7-34
in Sound Manager input 22-62
compressed sound header 22-10

compressing picture data 17-22

compressing sounds 22-13 to 22-15, 22-55
Comp3tol procedure 22-55, 22-91
Comp6tol procedure 22-55, 22-9]
computers, determining model in use 13-15
conjunct characters. See ligatures of glyphs

connection control block (CCB)

32-38 to

32-40
connection ends
closing 32-67
configuring 32-45, 32-60 to 32-62
defined 32-38
establishing 32-58 to 32-60
filter address 32-64, 32-71
ID numbers 32-64, 32-67
removing 32-68
resetting 32-78
state of 32-39
connection events
types 32-40
user routines 32-56 to 32-57
connection files 32-8
connection listeners 32-52 to 32-55
activating 32-70 to 32-71
closing 32-72
defined 32-38, 32-69
establishing 32-52 to 32-53, 32-69 to
32-70
how to use 32-53 to 32-54
routines 32-69 to 32-78
sample code 32-54
connection listening sockets 32-39
Connection Manager, testing for availability
3-35

connections, ADSP
closing 32-47 to 32-48, 32-67 to 32-69
denying an open request 32-72
determining the status of 32-73
establishing 32-58 to 32-67
maintaining 32-46 to 32-47, 32-73 to
32-78
opening 32-43 to 32-46, 32-62 to 32-66
connection servers 32-69. See also
connection listeners

connectivity. See AppleTalk
ContainerChunk data type 22-28
content regions of help balloons 11-64
context dependence of characters 14-32
context of a process
defined 29-4
switching 5-13, 29-6
contextual script systems 14-16
contours of glyphs 12-12
control definition functions 28-12
avoiding memory address violations 1-20
Control Manager, messages 28-12
Control Panel. See control panels
control panel files. See control panels
control panels 10-3 to 10-29
and dialog items list 10-4
installing and removing 9-39
Keyboard 14-18, 14-19, 14-98
maintaining compatibility with older
operating systems 10-4
Map 14-19
Memory 28-9, 28-17
and menu items 10-4
Monitors. See Monitors control panel
providing icons for 2-22
script configuration 14-17, 14-19
size of rectangles 10-4
Sound. See Sound control panel
in volumes of Jnside Macintosh P-10
where to store 10-3
worldwide 14-19
writing 10-4
Control Panels folder
alias type for 9-30
defined 9-4]
finding 9-43
controls
alignment of 2-8
help balloons for 11-36
conventions
of a typical chapter P-5
of this volume P-6 to P-7

Index

IN-I11

Inside Macintosh,

Volume

V]

converting
between color models 19-9
case of text 14-62
geographic information 14-13
long dates 14-48
numbers to and from localized formats
14-13
representation of numbers 14-49
text into tokens 14-48
time zones 14-13
worldwide dates and times 14-48

cooperative multitasking 2-14, 5-6

CopyBits procedure 21-5
optimizing for speed 21-13
CopyDeepMask procedure 17-15, 17-25 to
17-26
CopyPalette procedure 20-23
core Apple events 6-6, 6-7
CouldAlert procedure 3-10
CouldDialog procedure 3-10
CountDITL function 3-19
courteous colors 20-5, 20-9
PmBackColor and 20-22
CPUs
monitoring load of 22-53
testing for type 3-39
CreateEditionContainerFile function 4-28,
4-65 to 4-66
Create Publisher command (Edit menu)

2-33, 4-25
Create Publisher event 6-38
creation dates handled by FSpExchangeFiles
25-17
creators
assigning 9-36
defined 9-7 to 9-9
CSParam parameter block type 25-20
CTabChanged procedure 17-11, 17-26
CTab2Palette procedure 20-24
‘ctrl’ folder type 9-43
cultural values 2-5
currency formats 14-28, 14-86
CurrentA5 global variable 28-5
cursors. See also carets
animated watch 2-14
in mixed-directional text 15-9, 15-11
spinning beach ball 2-14
tracking location by Help Manager 11-17,
11-19
custom Apple events 6-6
CustomGetFile procedure 3-40, 26-23
customized icons 2-21, 9-28
CustomPutFile procedure 3-40, 26-21
IN-12

Index

D

DAL (Data Access Language)
DAs. See desk accessories

dashes ('----') keyword

6-11

8-4, 8-56

'dast' resource type 9-33
data. See also queries; query documents
exchanging during PPC session 7-32 to
7-34
retrieving using DBGetltem function 8-34
to 8-35, 8-63 to 8-64
retrieving using DBGetQueryResult
function 8-37 to 8-38, 8-54 to 8-56
sending 8-28
Data Access Language (DAL) 8-4, 8-56
Data Access Manager 8-3 to 8-73. See also
queries; query documents; query
records; result handlers; sessions, data
access
asynchronous calls 8-10, 8-50 to 8-51
canceling a function call 8-59
connection with a database, illustrated 8-5
data types 8-34 to 8-37
disk-space limit 8-11
high-level interface 8-5 to 8-7
compared to low-level 8-9
examples 8-6 to 8-9, 8-15
retrieving data 8-7
sending a query 8-6
high-level routines 8-52 to 8-56
examples 8-7
flowchart 8-13
sequence of use 8-12 to 8-19
uses 8-6
initializing 8-5]
local database and 8-3
low-level interface
compared to high-level 8-9
examples 8-8, 8-30
flowchart 8-27
general description 8-8 to 8-9
retrieving data 8-9
sending a query 8-9
using 8-26 to 8-33
low-level routines 8-56 to 8-65
sequence of use 8-26 to 8-33
uses 8-8
query resources 8-46 to 8-47
results records 8-37 to 8-38
routine selectors 8-73
routines in 8-50 to 8-66

Index

Data Access Manager (Continued)
status routines 8-12, 8-19 to 8-26
function declaration 8-20
sample 8-23
status messages 8-21 to 8-23
suggested uses 8-3
testing for availability 3-36, 8-3
user interface guidelines 8-11 to 8-12
for query documents 8-42
database access. See Data Access Manager
database command strings. See queries
database extensions
asynchronous execution and 8-10
defined 8-4
name of 8-56
database queries. See queries
databases. See Data Access Manager
Datagram Delivery Protocol (DDP) 32-6
data links
addresses of 32-13, 32-16
and AppleTalk connection files 32-4, 32-8
data offset bit in sound commands 22-20
data servers
defined 8-4
status 8-62
data types recognized by Data Access
Manager 8-34 to 8-37
result handlers 8-39
DateCachePtr data type 14-126
date cache record. See DateCacheRecord
data type
DateCacheRecord data type 14-48, 14-126
DateDelta data type 14-125
dates
converting 14-48 to 14-49
formatting 14-28
localizing 14-74, 14-75, 14-107
long formats 14-87
short formats 14-86
date time record. See LongDateRec data type
DBAsyncParamBlockRec data type 8-51
DBBreak function 8-63
DBColInfoRecord data type 8-38
DBDisposeQuery function 8-52
DBEnd function 8-57
DBExec function 8-6]
DBGetConnInfo function 8-57 to 8-59
DBGetErr function 8-62
DBGetltem function 8-63 to 8-64
DBGetNewQuery function 8-52
DBGetQueryResults function
described 8-54 to 8-55
Status routines 8-19 to 8-26

DBGetResultHandler function 8-66
DBGetSessionNum function 8-59
DBInit function 8-56 to 8-57
DBInstallResultHandler function 8-65
DBKill function 8-59
DBRemoveResultHandler function 8-66
DBResultsToText function 8-55
DBSend function 8-60
DBSendlItem function 8-60
DBStartQuery function
described 8-53 to 8-54
status routines 8-19 to 8-26
DBState function 8-62
DBUnGetltem function 8-65
DCE. See device control entries
DCE data structures 30-17
ddev. See database extensions
DDP (Datagram Delivery Protocol) 32-6
dead keys
completers for 14-97 to 14-98
defined 14-23
feedback in Key Caps desk accessory
14-100 to 14-101
DebuggerEnter procedure 28-25, 28-32
DebuggerExit procedure 28-25, 28-32
DebuggerGetMax function 28-30
DebuggerLockMemory function 28-23,
28-25, 28-31
DebuggerPoll function 28-26, 28-33
debuggers, and virtual memory 28-23
DebuggerUnlockMemory function 28-23,
28-25, 28-32
DebugUtil trap 28-24
default color tables 2-17, 20-7, 20-8
default help balloons
defined 11-10to 11-13
overriding 11-56 to 11-61
default help override resources
example of 11-60 to 11-61
format of 11-58 to 11-59
header for 11-59 to 11-60
options for 11-59
default palettes 20-16
default window positions 2-22
DeferUserFn function 28-23, 28-30
Delay function 23-9
DeleteEditionContainerFile function 4-42,
4-66
DeleteUserldentity function 7-35 to 7-36,
7-56
DelimType data type 14-128
descent line of fonts 12-6

Index

IN-13

Inside Macintosh,

Volume

VI

descriptor lists
adding data to 6-89
adding descriptor records to 6-89
counting descriptor records in 6-77 to
6-78
creating 6-88
defined 6-11 to 6-12
deleting descriptor records from 6-98
disposing of 6-50 to 6-51
getting data out of 6-45 to 6-47, 6-78 to
6-79
getting descriptor records out of 6-79
getting sizes and descriptor types of
descriptor records in 6-96 to 6-97
relationship to other Apple Event Manager
data structures 6-14
descriptor records. See also keywordspecified descriptor records
adding as attributes 6-93
adding as parameters 6-92
adding to descriptor lists 6-89
coercing data in 6-100 to 6-101
counting in descriptor lists 6-77 to 6-78
creating 6-87
defined 6-9 to 6-10
deleting from descriptor lists 6-98
disposing of 6-50 to 6-51
duplicating 6-87 to 6-88
getting data out of, in descriptor lists
6-78 to 6-79
getting descriptor types of, in descriptor
lists 6-96 to 6-97
getting from attributes 6-77
getting from descriptor lists 6-79
getting from keyword-specified descriptor
records 6-8]
getting from parameters 6-43, 6-75 to
6-76
getting sizes of, in descriptor lists 6-96 to
6-97
relationship to other Apple Event Manager
data structures 6-14
descriptor types
coercing 6-67 to 6-70, 6-100 to 6-101
defined 6-9
determining in AE records 6-97
determining in Apple events 6-97 to 6-98
determining in descriptor lists 6-96 to
6-97
DescType data type 6-9
design guidelines. See user interface
guidelines

IN-14

Index

desk accessories. See also control panels
in Apple Menu Items folder 9-4]
behavior in version 7.0 1-20, 9-32 to
9-33
default icon for 9-10
Key Caps 14-19, 14-100, 14-101
launching 29-16
making notification requests 24-3, 24-7
suitcases for 9-34
‘desk’ folder type 9-43
desktop database 9-44 to 9-60
adding data to 9-54 to 9-57
closing 9-50
contents of 9-47
deleting data from 9-57 to 9-58
determining parent directory of 9-59
determining reference number of 9-47,
9-49 to 9-50
determining space used by 9-59
locating 9-49 to 9-50
opening 9-50 to 9-5]
removing data from 9-59, 9-60
retrieving data from 9-51 to 9-54
saving to disk 9-58 to 9-59
Desktop file 9-45
Desktop Folder
defined 9-4]
finding 9-43
in standard file dialog boxes 26-6
Desktop Manager 9-44 to 9-60
routines in 9-48 to 9-60
destination service access point 32-25,
32-28
device control entries (DCEs)

.DSP driver 32-44
-MPP driver 32-14
updating the dctIDevBase field 30-17
device drivers
AppleTalk 32-8 to 32-10
.ATP driver 32-29 to 32-31
.DSP driver. See .DSP driver
.ENET driver. See .ENET driver
making notification requests 24-3
-MPP driver 32-12 to 32-16, 32-20,
32-23
.XPP driver. See .XPP driver
DeviceList global variable 21-8, 21-21,
21-22
DeviceLoop procedure 21-23
diacritical marks. See also accents
defined 14-32
expansion 14-27
font considerations 14-25, 14-104

Index

diacritical marks (Continued)

provided for in 'KCHR' resource 14-97
routines for stripping 14-62 to 14-63
sorting 14-26 to 14-27
storage of 14-36
tables for stripping 14-90
treatment of uppercase characters 14-33
dialog boxes
aligning text in 14-109, 15-19
for Color Picker 19-3, 19-8 to 19-10
customizing 4-52-54
effect on Macintosh Portable sleep state
31-16
to enable guest access 7-8
for font size 2-34
guidelines for design 2-23 to 2-31
for invalid user names 7-25
help balloons for 11-33-49
help balloons for areas outside of 11-58 to
11-61
and Help menu 11-28, 11-63
for incorrect passwords 7-25
keyboard navigation in 2-25 to 2-26
layout of 2-29
localizing 1-22, 14-25, 14-103
menu selection during modal 3-10, 3-13
messages in 2-30
movable modal 2-24 to 2-25, 3-10,
3-15, 29-6
positioning 2-23
for program linking 7-19 to 7-26
for publisher creation 4-5, 4-25 to 4-27
for publisher options 4-30, 4-37
for query documents 8-42, 8-43
for saving and opening files 26-5 to 26-20
customizing 26-9 to 26-11, 26-19
item numbers 26-13
standard file 2-31
standard save changes 2-31
for subscriber creation 4-6, 4-22, 4-31
for subscriber options 4-12, 4-38
for user identification 7-24
for users & groups 7-7
worldwide issues 2-30
dialog hook functions 26-12 to 26-18
dialog item help resources
compared to rectangle help resources
11-37, 11-42, 11-46
example of 11-38 to 11-39, 11-48 to
11-49
format of 11-34 to 11-35
header for 11-35 to 11-36
options for 11-35

dialog item list resources 11-33 to 11-34,
11-38
dialog item lists
appending items to 3-19, 3-20 to 3-22
for control panels 10-4
counting items in 3-19
removing items from 3-19, 3-22
dialog items, help balloons for 11-33 to
11-49
Dialog Manager
adding dialog items 3-20 to 3-22
counting dialog items 3-19
enabling menus during modal dialog 3-13
to 3-14
removing dialog items 3-22
testing for features 3-36
unsupported routines 3-10
diamond-shaped mark in Application menu
2-15, 24-4, 24-7
digital-to-analog converter (DAC) 22-6
DirCreate function 25-35
direction boundaries 15-8
direction runs 14-12, 15-5 to 15-6
directories
defined 25-6
described for PBCatSearch 25-20
finding system-related 9-42 to 9-44
specifying in HFS 25-7
specifying with FSSpec records 25-15 to
25-17
working 25-6
directory IDs in resolution of alias records
27-7
direct parameters for Apple events 6-8
direct pixels 16-18, 17-4, 17-11
Disableldle function 31-20
DisableWUTime function 31-20
disk cache 28-9, 28-10
‘disk’ file type 9-15
disks
free space limit for data access 8-11
opening 9-15
dispatch tables for Apple event handlers
6-28 to 6-30, 6-71 to 6-74
display order of characters 14-36, 15-5 to
15-6
displays. See screens
DisposeGDevice function 21-22
DisposeGWorld procedure 21-5, 21-19
DisposePalette procedure 20-19
DisposePictInfo function 18-5, 18-12
DisposeScreenBuffer function 21-20
DisposHandle procedure 28-37
Index

IN-I5

Inside Macintosh,

Volume V1

DitherCopy transfer mode 17-17
dithering, copying using 17-17
'‘DITL' resource type
for custom Open and Save dialog boxes
26-10 to 26-11
and help items 11-33 to 11-34, 11-38
in Monitors control panel extension 10-12
used by control panels 10-4
'DLOG' resource type 26-10
documentation, user terms for 2-13 to 2-14,
4-4, 7-5
documents
creating icons for 9-13, 9-28
creators of 9-7 to 9-9
default icon for 2-21, 9-10
help balloons for icons 11-56 to 11-58
opening from the Finder 9-24 to 9-26
prohibiting users from opening from
Finder 9-22
doesActivateOnFGSwitch flag 5-15
‘'doub' descriptor type 6-9
double buffers, managing 22-72, 22-90
double-acute accent 14-90, 14-97
doubleback procedures 22-34, 22-73,
22-76
double-byte characters
codes for

14-23,

14-34

mapping to classes 14-52
and TextEdit 15-13
double-byte script systems 14-16. See also
inline input
determining if one is installed 14-42
dpi (dots per inch) 12-4
DRAWHook field 15-25, 15-28
DrawingProc defproc 21-24
DrawJust procedure 14-45, 14-64
DrawText procedure 15-28
drift-free, fixed-frequency timing services
23-6
drivers. See device drivers
‘drop’ alias type 9-30
drop folder, alias type for 9-30
drop-sample conversion 22-39
DSAP (destination service access point)

32-25, 32-28
dspAttention routine 32-77
dspCLDeny routine 32-72
dspCLInit routine 32-69 to 32-70
dspCLListen routine 32-70 to 32-71
dspClose routine 32-67
how to use 32-47
dspCLRemove routine 32-72

IN-16

Index

-DSP driver 32-37 to 32-78. See also
AppleTalk Data Stream Protocol
device control entry 32-44
opening modes 32-62, 32-66
parameter block 32-40 to 32-43
routines in 32-58 to 32-78
sequence of use 32-43 to 32-54
dspInit routine 32-58 to 32-60
dspNewCID routine 32-67
dspOpen routine 32-62 to 32-66
how to use 32-45
dspOptions routine 32-60 to 32-62
DSPParamBlock data type 32-41
dspRead routine 32-74
dspRemove routine 32-68
how to use 32-47
dspReset routine 32-78
dspStatus routine 32-73
dspWrite routine 32-75
DTPBRec data type 9-46
dual carets
determining position of 2-7, 15-11
displaying at direction-run boundaries
14-109
mixed directional text and 15-9 to 15-10
specifying use of 14-81
duration of sounds 22-8
DXInfo data type 9-38
dynamic windows, help balloons for 11-41,
11-49 to 11-56
E

EAddMulti function 32-95
‘eadr' resource type 32-79
Easy Access, testing for features 3-36
EAttachPH function 32-90
EDelMulti function 32-95
EDetachPH function 32-91
edition containers
alias record reference to 4-11, 4-14, 4-19
creating 4-28
defined 4-4
deleting 4-42
for the GoToPublisherSection function 4-43
opener verbs 4-56
opening 4-24, 4-30, 4-32, 4-35, 4-59
preview for 4-32
standard opener 4-54
calling 4-56
locating 4-55
setting 4-56

Index

EditionContainerSpec data type 4-33
EditionHasFormat function 4-35, 4-68
Edition Manager 4-3 to 4-88. See also
editions; publishers; subscribers
Apple events sent by 6-7, 6-37 to 6-38
and Event Manager 1-7
limitations with MFS disks 25-9
routines in 4-61 to 4-80
sharing dynamic data 1-7
testing for availability 3-36, 4-11
user interface guidelines 4-4
edition opener functions 4-54 to 4-55, 4-78
EditionOpenerParamBlock data type 4-79
EditionOpenParamBlock data type 4-56
editions
closing 4-25
creating icons for 2-21, 9-13, 9-27
default icons for 2-21, 4-4
defined 4-4
formats for 4-22 to 4-23
opening 4-23 to 4-24
to read data 4-35
to write data 4-30
preview for 4-6
reading from 4-24 to 4-25
relocating 4-52
writing to 4-24 to 4-25
Edit menu
Create Publisher command 2-33, 4-25
Edition Manager commands in 2-33, 4-10
enabled during modal dialog 3-14
Paste command 9-28
Publisher Options command 2-33, 4-37
Show/Hide Borders command 2-32, 4-10
Stop All Editions command 2-32, 4-10
Subscriber Options command 2- 32, 4-37
to 4-38
Subscribe To command 2-33
edit record. See TERec data type
EGetInfo function 32-93
8-bit color icons 2-17, 2-18
802.2 protocol

32-25 to 32-29

attaching a protocol handler 32-27
calling routines from assembly language
32-27
detaching a protocol handler 32-28
packet headers 32-25, 32-28
802.3 protocol 32-25, 32-90
ELAP (EtherTalk Link Access Protrocol)

32-6
elapsed times, computing 23-3, 23-14
‘empt' folder type 9-43
emptyCmd command 22-53

Enableldle function 31-20
end-of-line characters 15-26
-ENET driver 32-78 to 32-96. See also
Ethernet
calling 32-86 to 32-88
general-transmission mode, setting to
32-94
obtaining information about 32-93
opening 32-79 to 32-81
sample code 32-80
packet headers 32-25
parameter block 32-88
protocol handlers for 32-90 to 32-91
routines in 32-88 to 32-96
-ENETO driver 32-80
Entry2Index procedure 20-25
‘enum’ descriptor type 6-9
environment, getting information about. See
Gestalt Manager
Environs procedure 3-4, 3-28, 3-29, 3-30
EOLHook field 15-25, 15-26
EParamBlock data type 32-88
ERdCancel function 32-93
ERead function 32-92
‘errn' keyword 6-11
‘errs’ keyword 6-11
ESetGeneral function 32-94
'esrc' keyword 6-10
Ethernet 32-78 to 32-96. See also .ENET
driver
broadcast address 32-79
ERead function, canceling 32-93
hardware addresses, changing 32-79
multicast addresses 32-79, 32-95 to 32-96
protocol type discriminator 32-25
reading data 32-83 to 32-88, 32-92 to
32-93
write-data structure 32-81
writing data 32-81 to 32-83, 32-91 to
32-92
EtherTalk Link Access Protocol (ELAP)

32-6
EtherTalk NuBus cards, finding 32-79
‘evcl' keyword 6-10
EventAvail function 5-18
event classes 6-7
event IDs 6-7
event loops 5-10
Event Manager 5-3 to 5-35
and Apple Event Manager 1-7
and PPC Toolbox 1-7
routines in 5-29 to 5-32
in volumes of /nside Macintosh P-9
Index

IN-17

Inside Macintosh,

Volume VI

event masks 5-12
event records
event classes in 6-7
event IDs in 6-7
and event loops 5-11
for high-level events 5-21
for mouse-down events 5-16
events. See also Apple events
application-defined 5-5
application-died 5-8
disabling 5-12
masking out 5-12
mouse-down 5-16, 15-6, 15-8, 15-13
mouse-moved 5-8, 5-19
processing while waiting for reply Apple
event 6-64 to 6-67
resume 5-6 to 5-8, 29-6
suspend 5-6 to 5-8, 29-6
‘evid' keyword 6-10
EWrite function 32-9]
expanding sounds 22-14, 22-55
expansion cards. See cards, NuBus
explicit colors 20-6, 20-12
index collisions and 20-13
Explto3 procedure 22-55, 22-91
Exp1to6 procedure 22-55, 22-9]
exported AppleShare folder, alias type for
9-30
exporting pixel map records 17-19
ExtCommonChunk data type 22-29 to 22-30
‘exte' descriptor type 6-9
extended networks 32-6
Extended Protocol. See .XPP driver
extended Roman character set. See standard
Roman character set
extended sound header 22-10, 22-45
extension files. See Monitors control panel
extension files
Extensions folder
alias type for 9-30
defined 9-41
finding 9-43
‘extn’ folder type 9-43
ExtSoundHeader data type 22-46
F

‘faam' alias type 9-30
‘fact’ alias type 9-30
‘fadr' alias type 9-30
‘faet' alias type 9-30
‘faex' alias type 9-30
IN-18

— Index

'‘fals' descriptor type 6-9
‘famn' alias type 9-30
'fapf alias type 9-30
‘fapn' alias type 9-30
‘fash’ alias type 9-30
‘fast’ alias type 9-30
fast search for alias records 27-7
'fasy' alias type 9-30
‘fdrp' alias type 9-30
'ffil' file type 9-34
FIDParam parameter block type 25-44
file attributes
defined 25-22
specifying in PBCatSearch 25-20
file control blocks, effect of
FSpExchangeFiles 25-18
file filter functions
for resolving aliases 27-20
for standard file display list 26-12
file IDs
creating 25-42, 25-45
defined 25-10
deleting 25-46
exchanging 25-31, 25-43
functions for manipulating 25-44 to 25-47
preserving 25-17
in resolution of alias records 27-7
resolving 25-46

tracking files with 25-25 to 25-26

File Manager 25-3 to 25-53
creating FSSpec records 25-16, 25-30
exchanging contents of two files 25-17 to
25-18, 25-31
file sharing 25-4
file system specification records 25-15
functions modified to accept FSSpec
records 25-31 to 25-34
manipulating foreign access-control
information 25-28 to 25-29, 25-50 to
25-52
mounting remote volumes 25-26 to
25-28, 25-48 to 25-50
opening data forks 25-52 to 25-53
reading volume information 25-37 to
25-40)
relation to Finder 9-3
routines in
high-level 25-29 to 25-37
low-level 25-37 to 25-53
searching a catalog 25-20 to 25-25, 25-40
to 25-42
testing for features 25-12 to 25-15
in volumes of Inside Macintosh P-14

Index

Woke she ok ok!

g-

15

assigning 9-7 to 9-9, 9-36

defining in an 'FREF' resource 9-14 to
9-19
‘disk' 9-15
fil’ 9-34
filtering Standard File display list by
26-22

finding those supported by applications
9-52
fold’ 9-15
‘fil’ 9-34
'kfil’ 9-34
for movable resources 9-33 to 9-34
opening documents of particular, from
applications 9-9
opening documents of particular, from the
Finder 9-24 to 9-26
'scri’ 9-41, 14-20
'sfil’ 9-34
for stationery pads 9-15
'TEXT' 9-8
user terms for 2-13

Finder

application interface to 9-3 to 9-68
database for a volume 9-44 to 9-60
defined 9-3 to 9-5
environment provided by 1-4
limitations with MFS disks 25-9
relation to File Manager 9-3
resources used by 9-5 to 9-24
Finder events 6-7, 6-19
Finder flags 9-36 to 9-38
Finder icon help resources
example of 11-58
format of 11-56
header for 11-57
options for 11-57
Finder icons. See system icons
Finder information
files to open or print 29-8
preserving during a file update 25-17
specifying in PBCatSearch 25-20
in the volume catalog 9-36 to 9-38
FindFolder function 9-42 to 9-44

testing for availability 3-36, 9-43

FindScriptRun function
extracting blocks of text with 14-108
formatting text with 14-46
interface to 14-130
use of optional table in ‘itl2' resource
14-37, 14-90
FindScriptTable data type 14-92
FindWord procedure
determining script boundaries for 15-3]
drawing and editing text 14-46
and standard Roman character set
extensions 14-105
TextEdit’s definition of a word and 15-15
used for non-Roman scripts 15-16, 15-30
word break tables for 14-90
Index

IN-19

xopuy

File menu
Close command 9-32
Open command 25-15, 26-4
Open Query command 2-32, 8-12
Quit command 6-32, 6-36, 9-32
Save As command 26-4
Save command 26-4
filenames, specifying in PBCatSearch
25-20
file reference resources 9-14 to 9-19
files. See also applications; documents
access control in foreign file systems
25-11, 25-28 to 25-29, 25-50 to 25-52
containing sounds. See AIFF files;
AIFF-C files
described for PBCatSearch 25-20
exchanging contents of 25-17, 25-31
managing I-18
sharing 1-18
specifying in HFS 25-7 to 25-8
specifying in MFS 25-5
specifying with FSSpec records 25-15 to
25-17
temporary 9-40, 9-4]
tracking with file IDs 25-25 to 25-26
updating 25-9, 25-17 to 25-18
user comments associated with 9-44
user interface for saving and opening
26-3 to 26-28
file system, testing for features 3-36
file system specification 25-4
file system specification (FSSpec) records
13-18, 25-15
creating resource files with 13-19
opening documents with 25-15 to 25-16
opening resource files with 13-20 to
13-21
File Transfer Manager, testing for features
3-37
file types
'adev' 32-8
for alias files 9-30
‘appe’ 9-4]
'APPL' 9-8

Inside Macintosh,

Volume V1

FInfo data type 9-36
fixed values 19-11
Fix2SmallFract function 19-11
'FKEY' resource type 13-16
‘fld#' resource type 9-43
floating-point unit, testing for type 3-36
floppy disks, alias type for 9-30
'flpy' alias type 9-30
flushCmd command 22-40, 22-52, 22-82,
22-84
FlushEvents procedure 5-8
FlushFonts function 12-21
flushing sound channels 22-7
'FNDR' event class 6-7
‘fold’ file type 9-15
'FOND' resource type 13-7
IDs for 14-23
'FONT' resource type 13-7
folder resources 9-43
folders
alias type for 9-30
finding system-related 9-42 to 9-44
in MFS and HFS 25-6
folder types 9-43
‘fold' file type 9-15
Font/DA Mover 9-32
font editors 12-3, 12-21
font families 12-4
and determining scripts 14-23
font family resource IDs
all script systems 13-8 to 13-9
range of resource IDs available 13-7 to
13-9
Roman script system 13-8
FontForce flag 14-44
Font Manager 12-3 to 12-21
choosing TrueType versus bitmapped
fonts 12-16to 12-18
erasing memory caches 12-21
rendering TrueType fonts 12-10 to 12-14
routines in 12-18 to 12-21
scaling fonts 12-8 to 12-9, 12-19 to 12-21
testing for features 3-36, 12-14
in volumes of Inside Macintosh P-11
Font menu 2-34. See also Font Manager
font numbers 12-16
font resources
icon for 9-34
IDs for 14-22, 14-79
installing and removing 9-39
fontruns 14-12, 15-31

IN-20

Index

fonts. See also bitmapped fonts: glyphs:
TrueType fonts
attributes in script systems 14-25
compatibility issues 14-107 to 14-108
defined for bitmapped 12-4
defined for TrueType 12-4
and diacritical marks 14-104
and 'FOND' IDs _ 14-23
force flags 14-81
in help balloons 11-74 to 11-75
information in ‘itlb' resource 14-85 to
14-86
information, obtaining from pictures 18-8
installing 14-19
keyboards, synchronization with 14-109,
15-11 to 15-13
localizing 2-11, 14-107 to 14-108
measurements of 12-6 to 12-7
point size limit of 12-15
removing 14-19
scaling of 12-8 to 12-9, 12-19 to 12-21
and scripts 14-23
single 14-25
size of 12-7, 12-8 to 12-9, 12-15
with the standard Roman character set
14-104
storing names of 12-16
in styled TextEdit 15-13
styles of 12-4
suitcases for 9-34
system 14-104
terminology for 12-3, 12-5
using zero-width characters with 14-25
verbs for retrieving information 14-40 to
14-4]
font scripts 14-37, 14-79, 15-11 to 15-13
font size dialog box 2-34
Font2Script function 14-44
FontScript function 14-38, 14-44
FontSpec data type 18-8
foreground processes 29-4
foreign file systems, access privileges in
25-28 to 25-29, 25-50 to 25-52
ForeignPrivParam parameter block type
25-50
FormatClass data type 14-124
FormatlOParamBlock data type 4-60
FormatOrder data type 14-124
FormatOrderPtr data type 14-124
FormatResultType data type 14-124
format runs 14-46, 15-5

Index

formats
for calendars 14-28
for canonical numbers 14-49
for currency 14-28
for date and time 14-28
for integer format codes 14-114
for long dates 14-28
for measurements 14-28
for numbers 14-29, 14-49
for sections 4-24, 4-60
for short dates 14-28
FormatsAvailable data type 4-23
FormatStatus data type 14-124
format strings 14-49
FormatStr2X function 14-49, 14-92,
14-94, 14-13]
Format2Str function 14-49, 14-92, 14-94,
14-13]
FormatX2Str function 14-49, 14-92,
14-94, 14-131
ForwardTable state table 14-51
4-bit color icons 2-18, 2-20
FPU, testing for type 3-36
frames, sampled sound 22-32
FreeAlert procedure 3-10
FreeDialog procedure 3-10
'FREF' resource type 9-14 to 9-19
freqCmd command 22-42, 22-45, 22-46,
22-84
freqDurationCmd command 22-41, 22-45,
22-46, 22-84
frequency of sounds 22-8
FSMakeFSSpec function 25-16 to 25-17,
25-30
FSpCatMove function 25-34
FSpCreate function 25-32
FSpCreateResFile procedure 13-19
FSpDelete function 25-33
FSpDirCreate function 25-33
FSpExchangeFiles function 25-17 to 25-18,
25-31
FSpGetFInfo function 25-33
FSpOpenDF function 25-32
FSpOpenResFile function 13-20
FSpOpenRF function 25-32
FSpRename function 25-33
FSpRstLock function 25-33
FSpSetFInfo function 25-33
FSpSetFLock function 25-33
‘fss ' descriptor type 6-9
FSSpec data structure 25-15, 25-17
FSSpec record, creating resource files with
13-20

functional-area Apple events 6-6
function key resources 13-16
future execution, scheduling routines for
23-3
FVector data type 14-127
FXInfo data type 9-38
G
gain control (sound) 22-65
‘'gama' resource type 10-13
gamma tables 10-13
GDeviceChanged procedure 17-11, 17-27
GDevice data type 16-18, 21-4
general-transmission mode 32-94
geographic information, reading and storing
14-49
Gestalt function
description 3-46
determining availability of virtual memory
28-3
introduced 3-30
relation to Environs 3-4, 3-29
relation to SysEnvirons 3-4, 3-29
Script Manager selectors 14-36
testing for available features 3-28
testing for features of temporary memory
28-35
testing for sound capabilities 22-3, 22-69
testing for Time Manager version 23-4
use by control panels 10-4
Gestalt Manager 3-28 to 3-53
introduced 3-4
routines in 3-45 to 3-47
testing for availability 3-32
Gestalt response parameter 3-30
Gestalt selector codes
adding 3-42
application-defined 3-30
defined 3-30
environmental 3-31, 3-32, 3-35 to 3-41
informational 3-31, 3-32, 3-41 to 3-42
predefined 3-30
Gestalt selector functions 3-42 to 3-45
adding 3-29, 3-42
defining 3-45
replacing 3-29, 3-44
GetAliasInfo function 27-19
getAmpCmd command 22-51, 22-84
GetAppFont function 14-43
GetCatInfo function 9-36

Index

IN-2]

Inside Macintosh,

Volume VI

GetColor function 19-3, 19-8, 19-10
on black-and-white hardware 19-9
on variable CLUT hardware 19-9

GetCPUSpeed function

31-20

GetDateTime procedure

14-75

GetCTable function 17-18
GetCurrentProcess function 29-17
GetCVariant function 28-12
GetDefaultUser function 7-27, 7-56
GetDefFontSize function 14-43
GetDeviceList function 21-21

GetDItem procedure

10-12

GetEditionFormatMark function 4-24, 4-67
GetEditionInfo function 4-42, 4-76 to 4-77

GetEditionOpenerProc function 4-55, 4-78
GetEntryColor procedure 20-25
GetEntryUsage procedure 20-25
GetEnvirons function 14-40
verbs for 14-42
GetFInfo function 9-36

GetFormatOrder procedure
15-6

14-46, 14-130,

getFrontClicks flag 5-16, 5-17

GetFrontProcess function 29-19
GetGDevice function 21-21
GetGWorldDevice function 21-18

GetGWorldPixMap function 21-19
GetGWorld procedure 21-18

Get Info box. See information windows
GetLastEditionContainerUsed function
4-32, 4-33, 4-71
GetLocalZones function 32-35
GetMainDevice function 21-22
GetMaxDevice function 21-22

GetMBarHeight function 14-43
GetMyZone function 32-34

GetNewPalette function 20-19
GetNextDevice function 21-22
GetNextEvent function 3-11, 5-18
GetNextProcess function 5-3, 29-11, 29-17
GetOutlinePreferred function 12-18

GetPageState function
GetPalette function

28-26, 28-33

20-20

GetPaletteUpdates procedure 19-21
GetPhysical function 28-21, 28-29
GetPictInfo function 18-10
GetPixBaseAddr function 21-16
GetPixelsState function 21-15

GetPixMapInfo function

18-9

GetPortNameFromProcessSerial
Number
function 5-32

GetPreserveGlyph function

IN-22

Index

12-21

GetProcessInformation function 5-22,
29-10, 29-11, 29-18
limitations with MFS disks 25-9
GetProcessSerialNumberFromPortName
function 5-22, 5-32
getRateCmd command 22-50, 22-85
GetScript function 14-39 to 14-40
verbs for 14-40 to 14-41
GetSpecificHighLevelEvent function 5-28,
5-31
GetStandardFormats function 4-78
GetSysFont function 14-43
GetSysJust function 14-43
GetWDInfo function 25-35
GetWUTime function 31-21
GetWVariant function 28-12
GetZoneList function 32-36
global variables. See also A5 world
list of D-1
in Time Manager tasks 23-12 to 23-14
glyph origin 12-6
glyphs. See also bitmapped glyphs;
characters; fonts; outline glyphs
contextual dependence of 14-31
defined 12-3
display order of 15-5
double-byte 15-13
measurements of 12-6-7
for missing characters in set 12-5
preserving shape of 15-17
scaling of 12-8 to 12-9, 12-19 to 12-21
GoToPublisherSection function 4-43, 4-77
grafPorts 14-37, 14-44
graphics
features provided by the system software
1-17
overview of 16-3 to 16-22
graphics cards (video cards) 16-8
declaration ROM of 16-17
graphics device record
definition 21-8
device types of 21-7
direct pixels and 16-18
drivers and 21-8
in graphics environment 21-3
indexed pixels and 16-16
managing 21-20 to 21-24
modifying 17-27
overview 16-13
use of 21-5
Graphics Devices Manager 21-3 to 21-30
routines in 2]-12 to 21-24
graphics devices, modes of 21-21

Index

graphics managers summarized 16-5, 16-6
to 16-8
graphics world
creating 21-12to 21-14
disposing of 21-19
retrieving 21-18to 21-19
setting 21-18
updating 21-16to 21-18
grave accent 14-97
GrayRgn global variable 16-16
gray-scale devices 17-18, 20-13
GWorldFlags flags set 21-5, 21-17
H

hacek 14-90, 14-97
handlers for Apple events. See Apple event
handlers
handles
to application-provided resources 14-76
empty 3-6
fake 3-6
purged 3-6
specifying handles to resources explicitly
14-77
hard disks, alias type for 9-30
hardware address, Ethernet, changing
32-79
hardware environment
testing for computer model 13-15
testing for features 3-37
hardware interfaces 1-23
hasBundle bit 9-37
hasCustomlIcon bit 9-28, 9-38
HasDepth function 21-12, 21-23
HCreate function 25-35
HCreateResFile procedure 13-20
HDelete function 25-36
‘hdlg' resource type 11-33 to 11-49
compared to ‘hrct' resource type 11-37,
11-42, 11-46
example of 11-38 to 11-39, 11-48 to
11-49
format of 11-34 to 11-35
header for 11-35 to 11-36
options for 11-35
'hdsk' alias type 9-30
header record for version 2 picture format
17-25
help balloons
content of
extracting 11-79 to 11-82

font name and size for 11-74 to 11-75
format of, in help resources 11-17 to
11-18
in a help message record 11-50
user interface guidelines 11-14 to 11-17
content region of 11-64
default 11-10to 11-13, 11-56 to 11-61
defined 11-3
determining whether enabled 11-65
determining whether showing 11-66
for dialog items 11-33 to 11-49
displaying 11-5 to 11-10, 11-67 to 11-69
enabling and disabling 11-3, 11-5, 11-66
getting dimensions of 11-78 to 11-79
for icons 9-34 to 9-35
for menus 11-21 to 11-33, 11-69 to 11-71
overriding default
for application icons 11-56 to 11-58
for inactive windows 11-58 to 11-61
for window frames 11-58
positioning 11-7 to 11-8, 11-17
removing 11-50, 11-54, 11-70, 11-71
routines for 11-65 to 11-82
structure region of 11-64
user interface guidelines 11-14 to 11-17
for windows
dynamic windows 11-41, 11-49 to
11-56
static windows 11-41 to 11-49
help balloon tips. See tips of help balloons
helplItem item type 11-40
Help Manager | 1-3 to 11-88. See also help
balloons
methods for displaying help balloons
11-5 to 11-10
routines in 11-65 to 11-82
testing for availability 3-37, 11-14
Help menu
adding items to 11-61 to 11-63
enabled during modal dialog 3-14, 11-28
help balloons for 11-10 to 11-13
Hide Balloons command 11-5
place in menu bar 3-15, 11-14
Show Balloons command 11-4
user interface guidelines 2-34
help messages. See help balloons
help resources. See also default help
override resources; dialog item help
resources; Finder icon help resources;
menu help resources; rectangle help
resources; window help resources
getting and setting 11-75 to 11-77
options for 11-18 to 11-20
Index

IN-23

Inside Macintosh,

Volume VI

‘hfdr' resource type
example of 11-58
format of 11-56
header for 11-57
options for 11-57

HFS (Hierarchical File System)

HFS RAM Cache control 28-10
HGetFlInfo function 25-36
HGetVol function 25-37
hicharge counter

HMGetDialogResID function 11-76
HMGetFont function 11-74
HMGetFontSize function 11-74
HMGetHelpMenuHandle function 11-61 to
11-62, 11-73
HMGetIndHelpMsg function 11-81
HMGetMenuResID function 11-77
HMIsBalloon function 11-66
HMMessageRecord data type 11-50

25-6

31-23

Hide Balloons command (Help menu)
Hide Borders command (Edit menu)

11-5

2-32

Hierarchical File System (HFS) 25-6
high caret. See primary caret
HighLevelEventMsg data type 5-28
high-level events 5-8 to 5-10. See also
Apple events
accepting 5-21, 5-27
defined 5-8
handling when accepting Apple events
6-26 to 6-27
introduced 5-3
masking out 5-12
posting options 5-24
processing while waiting for reply Apple
event 6-66 to 6-67
receiving 5-30
replying to 5-22
searching for specific 5-28, 5-31
sending 5-22, 5-23, 5-24, 5-30
supporting 5-11
testing for availability 5-3
highlighting
boundaries for 15-8
of characters in mixed-directional text
15-6
localizing 14-109
of mixed-directional text 15-8
in non-Roman script systems 15-6
outline 15-23
HiliteText procedure 14-46, 15-6
histograms, storing colors in 18-13
HITTESTHook field 15-25, 15-29
HLock procedure 28-37
HLS color model 19-6, 19-7, 19-8
HLS2RGB procedure 19-10
HMBalloonPict function 11-78
HMBalloonRect function 11-78
HMCompareltem identifier 11-30 to 11-32,
11-80
HMExtractHelpMsg function 11-79
HMGetBalloons function 11-50, 11-65
HMGetBalloonWindow function 11-79
IN-24

= Index

HMNamedResourceltem identifier

11-32 to

11-33
‘hmnu' resource type 11-21 to 11-33
example of 11-23 to 11-24
format of 11-22, 11-31
header for 11-24 to 11-25
options for 11-24
HMPicltem identifier 11-18
HMRemoveBalloon function 11-50, 11-54,
11-71
HMScanhdlg procedure 11-40
HMScanhret procedure 11-40
HMScanTemplateltems function ID 11-77
HMSetBalloons function 11-66
HMSetDialogResID function 11-76
HMSetFont function 11-74
HMSetFontSize function 11-75
HMSetMenuResID function 11-76
HMShowBalloon function 11-49-56, 11-67
to 11-69
HMShowMenuBalloon function 11-69,
11-71
HMSkipltem identifier 11-18
HMStringItem identifier 11-18
HMStringResltem identifier 11-18
HMSTRReslItem identifier 11-18
HMTEReslItem identifier 11-18
holding memory 28-18, 28-19
HoldMemory function 28-19, 28-26
HOpenDF function 25-34
HOpen function 25-36
HOpenResFile function 13-21
HOpenRF function 25-36
hot rectangles. See also alternate rectangles
defined 11-6
in 'DITL' resources 11-37
in menus | 1-22
specifying in dynamic windows 11-49 to
11-50, 11-54
specifying in static windows 11-43,
11-44
‘hovr' resource type
example of 11-60 to 11-61
format of 11-58 to 11-59

Index

‘hovr' resource type (Continued)
header for 11-59 to 11-60
options for 11-59
‘hrct' resource type
compared to 'hdlg' resource type 11-37,
11-42, 11-46
example of 11-46 to 11-47
format of 11-43
header for 11-43
options for 11-43 to 11-44
HRename function 25-36
HRstFLock function 25-36
HSetFlInfo function 25-36
HSetFLock function 25-36
HSLColor data type 19-7
HSL color model See HLS color model
HSVColor data type 19-7
HSV color model 19-6, 19-7, 19-8
HSV2RGB procedure 19-10
human interface design. See user interface
guidelines
HUnlock procedure 28-37
‘hwin' resource type
compared to using helpItem item 11-40 to
11-4]
example of 11-46 to 11-47, 11-48 to
11-49
format of 11-44 to 11-45
header for 11-45 to 11-46
options for 11-45 to 11-46
HyperCard, and format 2 'snd ' resource
22-19

'ICN#' resource type
icon families

2-18

for keyboards

9-10 to 9-12, 9-16

14-98

resources for 9-9
icon list resources 9-10
icon masks 2-20, 9-10, 9-12
icon resources 9-9 to 9-13

for applications 9-9 to 9-13
for keyboards 14-98
'ICON' resource type 10-13

icons. See also icon families; icon resources

alternating in Application menu title 2-15,
24-4, 24-7
black-and-white 2-18 to 2-19, 9-10, 9-12
color 2-19 to 2-20, 9-12

for control panels 2-22
customizing 2-21, 9-28

defaults used by Finder 2-21, 9-10, 9-34,
13-10to 13-15
design guidelines for 2-10 to 2-11, 2-18
to 2-22
for desk accessories 9-32
in desktop database 9-60
adding to 9-54 to 9-55
getting icon definitions from 9-5]
removing from 9-60
diamond in Application menu 2-15, 24-4,
24-7
for documents 9-13, 9-28
for editions 9-13, 9-27
for font resources 9-33 to 9-34, 14-19
help balloons for 11-10, 11-13, 11-56 to
11-58
for keyboard layout resources 9-33 to
9-34
for keyboards
examples of 2-10
pattern substitutions for colors 2-11
relationship to dual caret 15-10
specifying in ‘itlc’ resource 14-8]
keyboard script 15-10
large 2-18, 9-9, 9-10
for query documents 9-13
for script system resource collections 9-33
to 9-34, 14-19
selection mechanisms for 2-20
sizes of 2-18
small 2-19, 9-9, 9-12
for sound resources 9-33 to 9-34
for stationery pads 9-13, 9-15, 9-27
system 2-21, 9-10, 9-34, 13-10 to 13-15
for TrueType font resources 9-33 to 9-34
‘ics#' resource type 9-12
ideographic character representation 14-30
idle functions for Apple Event Manager
functions 6-64 to 6-66
idle state of Macintosh Portable
controlling 31-19
defined 31-5
disabling 31-13, 31-20
enabling 31-13, 31-20
IdleUpdate function 31-19
‘ifil' file type 9-34
ignorable characters in sorting 14-27
images, resolution of 17-18
implicit script codes 14-40
importing pixel map records 17-19
inactive windows, help balloons for 11-58
to 11-61
inactivity, Macintosh Portable 31-5
Index

IN-25

Inside Macintosh,

Volume VI

index collisions (color)

20-13

indexed pixels 16-16 to 16-17, 16-18
Info box. See information windows
informational selectors 13-15
information windows
using the stationery check box in 9-26
using to customize icon 9-28
version information in 9-7, 9-24
informing user about background activities.
See Notification Manager
inhibited colors 20-6, 20-12, 20-13, 20-14
InitDateCache function 14-130
InitDBPack function 8-51
InitEditionPack function 4-11, 4-62
INIT" file type, and the Extensions folder
9-4]
InitGDevice procedure 21-21
initialization parameters, sound channel
22-38
initialization, graphics 16-15 to 16-16
InitPalettes procedure 20-18
InitPickMethod function 18-13
INIT" resource type
making notification requests 24-10
in Monitors control panel extensions
10-14
InitSDeclMegr function 30-3
inline input 15-18, 15-24
InsertSRTRec function 30-17
installing
fonts 14-19 to 14-20
keyboards 14-19 to 14-20
multiple script systems 14-19 to 14-20
ordering of script and language codes
14-73
updating the Keyboard menu 14-43 to
14-44
voices into channels 22-10
InsTime function 3-7
InsTime procedure 23-5, 23-6, 23-10,
23-16
InsXTime procedure 3-7, 23-8, 23-10,
23-16
‘inte’ keyword 6-10
interapplication communication (IAC) 1-7 to
1-9
defined 1-4
role of Apple events 6-3
intercharacter spacing. See also justification
modifying 14-33 to 14-34
and multiple style runs 14-65 to 14-68
in Roman text 14-69
routines for formatting text

IN-26

Index

14-46 to 14-47

interface design. See user interface
guidelines
interlanguage sorting order 14-78
internal modem. See modem, Macintosh
Portable
international resources 14-14 to 14-15,
14-79 to 14-95
'1tl0' resource type 14-14, 14-86
‘itll’ resource type 14-14, 14-81, 14-87
to 14-89
'itl2' resource type. See 'itl2' resource
type
'1tl4' resource type. See ‘itl4' resource
type
'1tI5' resource type 14-14, 14-81
‘itIb' resource type. See ‘itlb' resource
type
‘itIc' resource type 14-14, 14-81 to 14-82
'i1tIk' resource type. See ‘itlk' resource

type

‘itIm' resource type 14-14, 14-80, 14-82
numbers of 14-79
using 14-79, 14-99
in U.S. system software 14-80
version 7.0 enhancements 14-14, 14-80
international software. See worldwide
software
International Utilities Package 14-71 to
14-79. See also international resources;
Script Manager
case conversion tables 14-90
character type tables 14-90
comparing strings 14-72
determining interscript sorting order
14-73, 14-78 to 14-79
diacritical mark stripping tables 14-90
interaction with related components 14-17
language codes in 14-75 to 14-76
localizing dates, times, and metric

information 14-74 to 14-75
modifying standard string comparison
14-73
overview of package 14-13, 14-71
overview of routines 14-72 to 14-75
routines in 14-75 to 14-79
script bundles 14-85
script codes in 14-75 to 14-76
sorting hooks 14-90
specifying resource handles explicitly
14-77 to 14-78
word break tables for 14-58, 14-90

Index

internet addresses 32-7
interrupt latency 23-6
interrupt routines, of Sound Manager 22-63
interrupts
nonmaskable 28-25
VBL 23-9
interrupt time
calling Gestalt at 3-30
deferring code execution under virtual
memory 28-23
routines that may be called at B-7 to B-8
routines that may not be called at B-1 to
B-6
Sound Manager callback routine at 22-78
Sound Manager doubleback routine at
22-77
interscript sorting order 14-73, 14-78
interword spacing 14-69 to 14-70. See also
justification
routines for formatting text 14-46 to
14-47
IntlForce flag 14-44, 14-76, 14-79
IntlScript function 14-44, 14-78
IntITokenize function 14-48, 14-130
character set extensions and 14-105
‘itl4’ resource and 14-92
localizable tables and code for 14-14
TokenBlock data type and 14-127
token recognition and 14-12
invalidating users 7-35
I/O completion routines 28-3
I/O functions 4-59, 4-79 to 4-80
IPCListPorts function
description 7-41 to 7-42
use of by PCCBrowser function 7-20 to
7-22
IPCListPortsPBRec data type 7-12, 7-37
isAlias flag 9-29
isHighLevelEventAware flag 5-16, 6-26
isInvisible flag 9-37
IsOutline function 12-19
IsRegisteredSection function 4-13, 4-65
isStationeryAware flag 5-16
isStationery bit 9-26, 9-37
is32BitCompatible flag 5-16
‘1t10' resource type 14-86
version 7.0 enhancements 14-14
‘itll’ resource type 14-87 to 14-89
version 7.0 enhancements 14-14, 14-81
‘itl2' resource type 14-90 to 14-93
accessing the tables of 14-74, 14-77
case conversion tables in 14-62
changing the tables of 14-74

custom 14-73, 14-74
explicitly specifying handles to 14-72,
14-77 to 14-78
handle caching for 14-74
header 14-91 to 14-93
manipulating 14-76 to 14-77
sorting procedures and tables 14-79,
14-136
version 7.0 enhancements 14-14, 14-81
word break tables in 14-50
retrieving 14-77
word definitions in Roman Script System
14-55
word wrap break tables in, retrieving
14-77
Itl4Handle data type 14-138
Itl4Ptr data type 14-138
Itl4Rec data type 14-138
‘itl4’ resource type 14-92 to 14-95
accessing the fields of 14-74
changing the fields of 14-74
handle caching for 14-74
manipulating 14-76 to 14-77
retrieving tables in 14-77
supplying your own 14-74
and tokens 14-12 to 14-13
version 7.0 enhancements 14-14
‘itI5' resource type 14-14, 14-81
ItlbExtRecord data type 14-86
ItlbRecord data type 14-85
‘itIb' resource type 14-85 to 14-86
creating simple script systems 14-37
GetScript and SetScript verbs for 14-41
version 7.0 enhancements

14-14, 14-81

ItlcRecord data type 14-82
‘itIc' resource type 14-81 to 14-82
version 7.0 enhancements 14-14, 14-80
‘itIk' resource type 14-99
keyboard character tables 14-23
remapping key combinations 14-24
version 7.0 enhancement 14-15
‘itm’ resource type 14-82
version 7.0 enhancements 14-14, 14-80
[UClearCache procedure 14-74, 14-76
IUCompPString function 14-72, 14-78
1UCompString function 14-72
for language-specific comparison and
sorting 14-103
[UDatePString procedure 14-75
IUDateString procedure 14-75
IUEqualPString function 14-72, 14-78
[UEqualString function 14-72
[UGetIntl function 14-74
Index

IN-27

Inside Macintosh,

Volume VI

TUGetItlTable procedure 14-58, 14-59,
14-74, 14-77
TULangOrder function 14-73, 14-78
[ULDateString procedure 14-75, 14-135
IULTimeString procedure 14-75, 14-135
IUMagIDPString function 14-72, 14-78
IUMagIDString function 14-72
IUMagPString function 14-72, 14-78
TUMagString function 14-72
IUMetric function 14-75
IUNSortFrame data type 14-73, 14-137
IUScriptOrder function 14-73, 14-78
[USetIntl procedure 14-74
TUSortFrame data type 14-73, 14-136
TUStringOrder function 14-73, 14-78
IUTextOrder function 14-73
T1UTimePString procedure 14-75
I[UTimeString procedure 14-75
J

jump tables 28-5, 29-5
justification 14-64 to 14-70. See also
alignment of text
defined 14-34
differences in script systems 14-34
in Roman script systems 14-68 to 14-70
routine for measuring text 14-67
version 7.0 improvements 14-64
K

kAEAIwaysInteract flag 6-52 to 6-53
kAEAnswer event ID 6-48
kAEApplicationDied event ID 6-71
kAECanInteract flag 6-52 to 6-53
kAECanSwitchLayer flag 6-52
kAECreatePublisher event ID 6-38
kAEDirectCall flag 6-109
kAEDontReconnect flag 6-60
kAEFinderEvents event class 6-7
kAEHighPriority flag 6-94
kAEInteractWithAll flag 6-53
kAEInteractWithLocal flag 6-53
kAEInteractWithSelf flag 6-53
kAELocalProcess flag 6-109
kAEMiscStdSuite event class 6-38
kAENeverlnteract flag 6-52 to 6-53
kAENoReply flag 6-49, 6-59 to 6-60
kAENorma!Priority flag 6-94
kAEOpenApplication event ID 6-7
kAEPrintDocuments event ID 6-7
IN-28

Index

kAEQueueReply flag 6-49, 6-59 to 6-60
kKAEQuitApplication event ID 6-7
kAESameProcess flag 6-109
kAEUnknownSource flag 6-109
kAEWaitReply flag 6-49, 6-59 to 6-60
kAEWantReceipt flag 6-61
kAutoGenerateReturnID flag 6-55
'KCAP' resource type 14-101
'KCHR' resource type 14-96 to 14-98
keyboard character tables 14-23
keyboard translation with 14-24
obtaining a pointer to current 14-42
version 7.0 enhancements 14-15, 14-97
kCoreEventClass event class 6-7
'kcs#' resource type 14-15, 14-98
'kcs4' resource type 14-15, 14-98
‘kcs8' resource type 14-15, 14-98
keyAddressAttr keyword 6-10, 6-57 to 6-59
keyAEEditionFileLoc keyword 6-38 to 6-39
Keyboard control panel 14-19, 14-98
keyboard equivalents 2-34 to 2-36
Apple reserved 2-35
commonly used 2-35
localizing 14-105
in standard file dialog boxes 26-9
keyboard icons
design guidelines 2-10 to 2-1]
indicating location of 14-81
Keyboard menu and 2-9, 14-20
relationship to dual caret 15-10
resource types for 14-98
specifying appearance of 14-15
Keyboard Layout file 14-100
keyboard layouts 2-8, 14-20
selecting 14-21
Keyboard menu 2-8 to 2-11, 14-20 to 14-21
enabled during modal dialog 3-14
icons for 3-15, 14-15
keyboard resources 14-14 to 14-15, 14-95
to 14-99
icon for 9-34
‘itlk' resource type. See ‘itlk' resource
type
'KCAP' resource type 14-101
'KCHR' resource type. See 'KCHR'
resource type
‘kcs#' resource type 14-15, 14-98
‘kcs4' resource type 14-15, 14-98
‘kes8' resource type 14-15, 14-98
‘KMAP' resource type 14-15, 14-20
'KSWP' resource type 14-15, 14-25,
14-98 to 14-99
in U.S. system software 14-80

Index

keyboards
cache size 14-81
character tables 14-23
control panel 14-98
fonts, synchronization with 14-109,
15-11 to 15-13
icons 14-81, 14-98
installing 14-19
layouts 14-14
changing 14-43 to 14-44
coordinating on keyboard models 14-99
mapping 15-1]
modifier bits 14-95
physical layout of 14-101
remapping 14-24
removing 14-19
testing for type 3-37
translation of codes 14-24 to 14-25
types of 14-95
keyboard scripts
changing 14-98
defined 15-9
effect on dual caret 15-10
and font scripts 15-13
setting the active 14-43 to 14-44
synchronizing with fonts 14-109, 15-11
to 15-13
Key Caps desk accessory 14-19, 14-100
'KCAP' resource type 14-101
key codes 14-15, 14-24
keyDirectObject keyword 6-11
keyErrorNumber keyword 6-11, 6-48 to
6-49
keyErrorString keyword 6-11, 6-49
keyEventClassAttr keyword 6-7, 6-10
keyEventIDAttr keyword 6-7, 6-10
keyEventSourceAttr keyword 6-10
keyInteractLevelAttr keyword 6-10, 6-44,
6-51
keyMissedKeywordAttr keyword 6-10,
6-44, 6-47 to 6-48
keyOptionalKeywordAttr keyword 6-10
keyProcessSerialNumber keyword 6-11,
6-71
keyReturnIDAttr keyword 6-10, 6-55
KeyScript procedure 14-43 to 14-44
verbs for 14-43
keyTimeoutAttr keyword 6-10, 6-64
keyTransactionIDAttr keyword 6-10, 6-55
KeyTrans function 14-24, 14-99
'keyw' descriptor type 6-9
keywords for Apple events 6-10

keyword-specified descriptor records. See
also descriptor records
adding to AE records 6-91
defined 6-11
deleting from AE records 6-99
disposing of 6-50 to 6-51
getting data out of 6-80 to 6-81
getting descriptor records out of 6-81
getting descriptor types of 6-97
getting sizes of 6-97
'kfil' file type 9-34
kHighLevelEvent message class 6-26
KillColorPickMethod function 18-14
"KMAP' resource type
keyboard translation with 14-24
version 7.0 enhancements 14-15
kSectionEventMsgClass event class 6-7
"KSWP' resource type

14-15, 14-25,

14-98

to 14-99
specifying modifier-plus-key combinations
14-25
version 7.0 enhancements 14-15

L

Label menu commands 9-12
labels of buttons 2-26 to 2-28
LangCode data type 14-71, 14-75
language codes
and character codes 14-34
defined 14-7
hierarchical arrangement of 14-80
for International Utilities Package 14-75
in 'itlb' resource 14-85
listed in relation to script and region 14-84
list of 14-112
list of constants for International Utilities
Package 14-76
location of 14-14
ordering information for 14-73
preferred sorting order for 14-14, 14-82
routines that accept 14-73
for sorting text between scripts and
languages 14-71, 14-78
specification of 14-79
languages. See also scripts
bidirectional 14-30
and case conventions 14-33
default 14-14
defined 14-5
identifying 14-8
and keyboard layout 14-24
Index

IN-29

Inside Macintosh,

Volume VI

languages (Continued)
and number formats 14-49
and regions 14-8
representing on the Macintosh 14-7
and scripts 14-8, 14-29
and sorting 14-26 to 14-27, 14-78
and text manipulation 14-35, 14-103
translation considerations 2-6, 14-102 to
14-103
version 7.0 enhancements for sorting
strings 14-26
and word breaks 14-35
LANs. See AppleTalk
LAPAddATQ function 32-18
LAP Manager 32-17 to 32-29
calling from assembly language 32-27
802.2 protocol 32-25 to 32-29
packet headers 32-25, 32-28
protocol handlers, attaching 32-27
protocol handlers, detaching 32-28
802.3 protocol 32-25, 32-90
relationship to AppleTalk connection files
32-8 to 32-9
LAPMegrPtr global variable 32-19, 32-27
LAPRmvATQ function 32-19
large icons (32-by-32 pixel)

2-18, 9-9, 9-10

Larger (point sizes) command 12-15
LaunchApplication function 29-12, 29-14,
29-21 to 29-22
LaunchDeskAccessory function 29-16,
29-23
launching
applications 29-12 to 29-15, 29-21 to
29-23
from the Finder 9-24 to 9-26
desk accessories 29-16, 29-23
example code 29-14
launch options 29-15
LaunchParamBlockRec data type 29-12
launch parameter block 29-12
leading of text 12-7
left-side bearing of glyphs 12-6, 12-20
L802Attach routine 32-27
L802Detach routine 32-28
LHElement data type 15-31, 15-38
LHHandle data type 15-38
LHTable data type 15-37, 15-38
ligatures of glyphs 12-3, 14-32
light source on Macintosh screen 2-18
limited-transmission mode 32-94
linear interpolation 22-39
line breaks 15-15 to 15-16
character offsets at 15-32
IN-30

Index

defining 14-51
localizing tables 14-50
which routine used for 15-30
line direction 15-9
primary 15-7
line-height table. See LHElement data type
lines of text. See also line breaks
alignment 15-14, 15-19
calculating width of components 15-26 to
15-28
determining lengths with lineStarts array
15-20 to 15-21
direction 14-43, 15-4, 15-14
drawing 15-28
line start positions 15-25
measuring accurately 15-16
using WordRedraw for calculations 15-20
line spacing of a font 12-7
altering for glyphs 12-17
lineStarts array 15-20

link access protocols 32-5, 32-8. See also

LAP Manager
defined 32-6
linking programs. See program linking
‘list’ descriptor type 6-9
LLAP 32-6
loadCmd command 22-85
localAndRemoteHLEvents flag 5-16, 6-26
local area networks. See AppleTalk
local IDs
in 'BNDL' and 'FREF' resources 9-14,
9-17, 9-18
for mapping resources 9-14 to 9-19
localization
application guidelines 14-102 to 14-107
calendars 14-28
conversion of upper and lowercase text
14-62
currency formats 14-28
date formats 14-28, 14-74, 14-107
defining a word 14-55
fonts 14-107
International Utilities Package routines for
14-75 to 14-79
measurement formats 14-28
menus 1-22, 14-25, 14-102, 14-107
metric information 14-74
numbers 14-29, 14-107
overview 3-22 to 3-24, 14-7 to 14-8
printing 14-110
Script Manager routines for 14-50 to
14-70
sorting 14-26 to 14-27

Index

localization (Continued)

stripping diacritical marks 14-62
tasks 14-24 to 14-25
text operations 2-6 to 2-8, 14-103
times 14-28, 14-74, 14-107
translating text 14-102 to 14-103
truncated text 14-59 to 14-60
using resources in 14-102
LocalTalk Link Access Protocol (LLAP)
32-6
LocationNameRec data type 7-16
locking memory 28-18, 28-20
LockMemoryContiguous function 28-20,
28-28
LockMemory function 28-20, 28-28
LockPixels function 21-5, 21-15
logical RAM, testing for size 3-37
LogicalToPhysicalTable data type 28-22
LongDateCvt data type 14-125
LongDatefield data type 14-123
LongDateRec data type 14-48, 14-125
LongDateTime data type 14-48, 14-75,
14-125
LongDate2Secs procedure 14-48, 14-131
‘long’ descriptor type 6-9
LongSecs2Date procedure 14-48, 14-131
low caret. See secondary caret
lowercase characters 14-32, 14-47, 14-62
to 14-63
LowerText procedure 14-47, 62
low-level events 5-5
receiving 5-18

low-memory global variables 3-7, 3-28

testing for size 3-37
luminance mapping 17-18
LwrText procedure. See LowerText
procedure

MACE 22-13, 22-55
MACEVersion function

22-70, 22-88

machine icon, testing for 3-41

MachineLocation data type 14-125
machine type, testing for 3-41
‘mach’ resource type, in control panel file
10-4
Macintosh Audio Compression and
Expansion 22-13, 22-55
Macintosh character set, original 14-104
Macintosh computers, determining model in
use 13-15

Macintosh File System (MFS)

25-5

Macintosh Portable. See also Power
Manager
activity timer, resetting 31-6, 31-13,
31-19
battery
calculating voltage 31-23
charging 31-23
low voltage 31-4, 31-14, 31-16, 31-24
reading the status of 31-23 to 31-24
controlling serial power 31-18 to 31-19,
31-21 to 31-22
hicharge counter 31-23
idle state
controlling 31-19
defined 31-5
disabling

31-13, 31-20

enabling 31-13, 31-20
inactivity 31-5
internal modem
controlling power to 31-18 to 31-19,
31-21 to 31-22
reading status of 31-22
ring-wakeup feature 31-22
power management circuits 31-4
Power Manager IC 31-3, 31-7
reading clock speed 31-20
sleep state 31-6 to 31-7
Macintosh Portable Power Manager. See
Power Manager
Macintosh Programmer’s Workshop (MPW)
P-4
Macintosh Protocol Package. See .MPP
Driver
Macintosh Script Management System. See
Script Management System
‘macs’ folder type 9-43
‘magn’ descriptor type 6-9
MainDevice global variable 21-22
main screen 16-15
major switches 5-13, 29-6
Map control panel 14-19

masks, icon 2-20, 9-10, 9-12
master pointers 3-6, 28-11
MatchAlias function 27-11, 27-16
MeasureJust procedure 14-46, 14-64
measurement formats 14-28
MeasureText procedure 14-25
memory. See also virtual memory
finding the size allocated to a process
29-10
holding 28-18 to 28-19
locking 28-18
Index

IN-31

Inside Macintosh,

Volume VI

memory (Continued)

routines that may move or purge B-1 to
B-5
temporary 28-34
memory addresses 1-20
MemoryBlock data type 28-21
memory configuration, obtaining
information about 28-21
Memory control panel 28-9, 28-17
memory management 3-6, 28-3 to 28-44
in volumes of Inside Macintosh P-15
memory management unit (MMU)

3-13

testing for type 3-38
Memory Manager 3-6, 28-13
data structures 3-6
routines in 28-16
menu bar
access to from modal dialog boxes 2-24
alternating icon in 2-15, 24-4, 24-7
determining height of 14-43, 14-107
menu commands 2-32 to 2-36. See also
menu items, help balloons for
About (Apple menu), for desk accessories
9-32, 9-33
for changing colors in the Finder 9-12
Close (File menu)

9-32

Create Publisher (Edit menu) 2-33, 4-25
during modal dialogs 3-10, 3-13
for font size 2-34
Hide Balloons (Help menu) 11-5
Hide Borders (Edit menu)

Larger (point sizes)

2-32

12-15

None (Color menu) 9-12
Open (File menu) 25-15, 26-4

Open Query (File menu)

2-32, 8-12

Paste (Edit menu) 9-28
Publisher Options (Edit menu)

Quit (File menu)

2-33, 4-37

6-32, 6-36, 9-32

Save (File menu) 26-4
Save As (File menu) 26-4

Show Balloons (Help menu)
Show Borders (Edit menu)

11-4

2-32

Smaller (point sizes) 12-15
Stop All Editions (Edit menu)

Subscriber Options (Edit menu)

4-37 to 4-38

Subscribe To (Edit menu)

menu help resources
example of 11-23 to 11-24
format of 11-22, 11-31
header for 11-24 to 11-25
options for 11-24

IN-32

Index

2-33

2-32, 4-10
2-32,

menu items, help balloons for 11-28 to
11-33. See also menu commands
menus
changes to in version 7.0 2-32 to 2-37
determining menu bar height 14-43,
14-107
Edit. See Edit menu
File. See File menu
Font 2-34
Help. See Help menu
help balloons for 11-21 to 11-33, 11-69
to 11-71
justifying textin 14-109
Keyboard. See Keyboard menu
localizing 1-22, 14-25, 14-102, 14-107
pop-up. See pop-up menus
special script codes for symbols 14-108
Style, marking items based on current
selection 15-34
system 3-15
menu string list resources 9-25
menu string resources 9-25
menu titles, help balloons for 11-28
message blocks
defined 7-5
reading data using 7-32
writing data using 7-33 to 7-34
messages in dialog boxes 2-30
message string resources 9-2] to 9-22
meta-characters (wildcard characters) in

AppleTalk names 32-15
metric information, localizing 14-74
MFS (Macintosh File System) 25-5
limitations in version 7.0 25-9
MHStringResType data type 11-52 to 11-53
minor switches 5-13, 29-6
missing character glyphs 12-5
missing items, help balloons for
in default help override resources 11-60
in dialog item help resources 11-36 to
11-37
in menu help resources 11-25 to 11-26
‘miss’ keyword 6-10
mixed-directional text 15-4 to 15-11
caret movement 15-11
dual carets in 15-9
highlighting of 15-6 to 15-8
mouse-down positions in 15-8
pasting of 15-9
TextEdit’s handling of 15-4
MMU. See memory management unit
(MMU)
‘mntr’ resource type 10-8 to 10-11

Index

modal-dialog filter functions 26-18
ModalDialog procedure 3-15
modem, Macintosh Portable
controlling power to 31-18 to 31-19,
31-21 to 31-22
reading status of 31-22
ring-wakeup feature 31-22
ModemStatus function 31-22
modification dates, handled by
FSpExchangeFiles 25-17
modifier keys 14-24, 14-95
monitor function 10-8 to 10-11
error handling 10-9
messages 10-10 to 10-11
Monitors control panel 10-5 to 10-28.
See also Monitors control panel
extension files
example 10-5
functions 10-5
Options dialog box, example 10-6, 10-12
as part of graphics interface 16-6
for setting pixel depth 21-12
superusers, showing controls for 10-8,
10-11, 10-12
Monitors control panel extension files 10-6
to 10-28
appearance on desktop 10-14
canceling 10-10
contents 10-7 to 10-14
controls, location of 10-12
detecting events 10-11
dialog items, location of 10-12
gamma tables 10-13
icons 10-13
including another control panel 10-28
including a system extension 10-14
initialization 10-10
names of video cards, displaying 10-13
sample 10-14 to 10-21
superusers, showing controls for
10-8, 10-11, 10-12
version information 10-13
mounted folder, alias type for 9-30
mouse-down events 5-16
mouse-down regions, in mixed-directional
text 15-8
mouse-moved events 5-19, 29
movable modal dialog boxes 2-24 to 2-25
movable resources 9-33 to 9-34
-MPP driver 32-12 to 32-16
closing 32-20, 32-23
configuration flags 32-14
data link addresses 32-13

device control entry 32-14
getting information about 32-12 to 32-16
maximum capacities 32-12
names table pointer 32-16
NBP requests, limit of 32-15
port number 32-14
protocol handlers, number of 32-15
registered names queue 32-13
statically assigned sockets, number of
32-15
status changes (AppleTalk transitions).
See AppleTalk Transition Queue
version number of, determining 3-35,
32-11
zone names 32-13
'mst#' resource type 9-25
‘mstr' resource type 9-25
multibyte script systems 14-16
multicast addresses, Ethernet 32-79, 32-95
to 32-96
MultiFinder. See also multitasking
environment
launching applications 29-3
and memory management 28-6 to 28-7
support under A/UX 3-2
and system software version 7.0 5-3, 9-5
multiple monitors
controls for 10-5
in graphic environment 16-3
and window placement 2-22
and zooming 2-23
multitasking environment 1-4 to 1-6, 3-10
A/UX as 3-24
multi-user operating systems 3-24
N

Name-Binding Protocol (NBP)
defined 32-7
names table pointer 32-16
requests, maximum number 32-15
wildcard characters 32-16
nameLocked bit 9-28, 9-37
names of AppleTalk entities 32-7
name string resources for applications 9-21
to 9-22
NBP. See Name-Binding Protocol
NBPLookup function. See PLlookupName
function
NBreakTable data type 14-126
NBreakTablePtr data type 14-126
NChar2Pixel function 14-45, 14-67, 14-68
Index

IN-33

Inside Macintosh,

Volume VI

‘nert’ resource type 10-4
NDrawJust procedure 14-46, 14-67
network addresses 32-15
network numbers
AppleTalk Phase 2 32-6
determining range 32-12
value of 32-15
networks. See also AppleTalk
using shared Trash directories on 9-42
NewAlias function 27-9, 27-12
NewAliasMinimalFromFullpath function
27-14
NewAliasMinimal function 27-13
NewControl function 3-16
New Folder dialog box 26-5, 26-7
NewGDevice function 21-20
NewGestalt function 3-30, 3-42, 3-46
NewGWorld function 21-12, 21-13
NewPalette function 20-19
NewPictInfo function 18-11
NewPublisherDialog function 4-25 to 4-27,
4-73
NewPublisherExpDialog function 4-52,
4-74 to 4-75
NewPublisherReply data type 4-26 to 4-27
new publisher reply record 4-26, 4-27,
4-66, 4-73
NewScreenBuffer function 21-20
NewSection function 4-16 to 4-17, 4-62 to
4-63
NewSubscriberDialog function 4-32, 4-33,
4-72
NewSubscriberExpDialog function 4-53,
4-74 to 4-75
NewSubscriberReply data type 4-32
new subscriber reply record 4-32, 4-33,
4-72
NewTempScreenBuffer function 21-20
NFindWord procedure

14-46, 14-50, 14-58

to 14-59
action code format 14-54
new break table 14-52
State table 14-54
word selection table for Roman Script
System 14-55
'NFNT' resource type 13-7
NItl4Handle data type 14-94, 14-138
Nitl4Ptr data type 14-138
NItl4Rec data type 14-92, 14-94 to 14-95,
14-138
NMeasureJust procedure 14-46, 14-67
NMInstall function 24-9, 24-10
NMRec data type 24-6
IN-34

Index

NMRemove function 24-10, 24-11
node IDs 32-6
nonmaskable interrupts 28-25
non-Roman script systems
checking whether enabled 15-30
line breaking for 15-29
word selection in 15-29
writing software for 14-107 to 14-110
NoPurgePixels function 21-15
Notification Manager 24-3 to 24-11, 28-14
and A5 world 28-14
multiple requests 24-6
and operating-system events 5-7

response procedures

24-4, 8, 9

NSetPalette procedure

20-18, 20-20

routines in 24-10
suggested notification strategy 2-15, 24-5
testing for availability 3-38, 24-3
types of notifications 24-4 to 24-5
use by foreground applications 24-5
used by Apple Event Manager 6-54
notification queue
defined 24-6
installing entries 24-9 to 24-10
removing entries 24-10
notification records
defined 24-6
setting up 24-8
notification requests
creating 24-6 to 24-8
installing 24-9 to 24-10
removing 24-10
types of 24-5
notification response procedures 24-4,
24-8, 24-9
notifications 24-3
types of 2-15, 24-4
notifying users of background activities. See
Notification Manager
NPixel2Char function 14-46, 14-65, 14-68
NPortionText function 14-46, 14-67
NuBus cards. See cards, NuBus
NuBus connectors, testing for locations
3-38
nullCmd command 22-85
‘null’ descriptor type 6-9
null events 5-5, 5-12
NullStRec data type 15-37, 15-38
null style record 15-37, 15-38
nullSTHandle data type 15-38
NumberParts data type 14-127
indexes for 14-119

Index

NumberPartsPtr data type 14-126
numbers
localization issues 14-13, 14-29, 14-107
routines for converting to and from
canonical formats 15-49
Script Manager number utilities 14-49
NumFormatString data type 14-124
nWIDTHHook field 15-25, 15-26 to 15-27
testing for availability 15-18
O
‘oapp' event ID 6-7
‘odoc’ event ID 6-7
OffPair data type 14-126
offscreen buffer
size of 21-14
state of 21-15
offscreen graphics
flags 21-5, 21-17
reasons for 21-4
routines 21-12 to 21-20
OffsetTable data type 14-46, 14-126
ogonek 14-90, 14-97
OK button 2-27 to 2-28
onlyBackground flag 5-15, 29-4
opcodes, version 2 picture format 17-20 to
17-22
Open Application event
defined 6-31
event ID for 6-7
handling 6-33
Open command (File menu)

25-15, 26-4

OpenCPicture function 17-23, 17-25
OpenDeskAcc function 29-16
OpenDF function 25-34
Open Documents event
and alias records 9-15
defined 6-32
event ID for 6-7
handling 6-33 to 6-35
illustration of data structures in 6-13
OpenEdition function 4-23, 4-35, 4-67 to
4-68
opening
applications
from the Finder 9-24 to 9-26
from within an application 29-12
desk accessories 9-32
from an application 29-16
disks 9-15

documents 9-24 to 9-26
files 25-32
folders 9-15
OpenNewEdition function 4-23, 4-30, 4-69
to 4-70
Open Query command (File menu) 2-32,
8-12. See also Data Access Manager
OpenWD function 25-35
operating environment, user interface
guidelines 2-14 to 2-15
Operating System, testing for features 3-38
operating-system events 5-3, 5-5, 5-6, 5-19
operating-system queues 23-3
optional parameters for Apple events 6-8,
6-10
‘optk' keyword 6-10
OR transfer mode 17-16
outline fonts 3-12. See also TrueType fonts
defined 12-4
testing for availability 3-36, 12-14
outline glyphs. See also TrueType fonts
defined 12-4
instructions for modifying 12-14
preserving shape of 12-17 to 12-18,
12-21
outline highlighting
enabling 15-23
testing for availability 15-18
OutlineMetrics function 12-17, 12-19 to
12-21
outline points 12-10
outlines, defined 12-4
P

package resources 13-16
packing of picture data 17-22
'PACK' resource type 13-16
packType pixel map field 17-22
PageFaultFatal function 28-25, 28-31
page faults 28-23, 28-24
pages (memory)

holding 28-19, 28-26
locking 28-20, 28-28
locking contiguously 28-20, 28-28
releasing 28-19, 28-27
testing for size 3-37
unlocking 28-20, 28-29
PageState data type 28-26
paging 28-17
paging device 28-18
Palette data type 20-4
Index

IN-35

Inside Macintosh,

Volume V1

Palette Manager 20-3 to 20-28. See also
palettes
allocation of colors 20-6 to 20-7
color categories of 20-5 to 20-6, 20-8 to
20-13
initializing 20-18
interactions with Window Manager 20-19
to 20-21
restoring the color environment 20-7 to
20-8
routines in 20-18 to 20-25
summarized 16-7, 16-10
palette resources 20-4, 20-6
palettes 20-4 to 20-6
allocating 20-19
assigning a default 20-16
associating with ports 20-18
color tables and 20-17
copying entries 20-23 to 20-24
creating 20-14 to 20-16, 20-19
default 20-5, 20-16
drawing with 20-21 to 20-22
manipulating entries 20-24 to 20-25
resizing 20-24
resources for 20-6
palette symbols, special script codes for
14-108
Palette2CTab procedure 20-24
parameter block descriptions, formats for
P-7
parameters for Apple events. See Apple
event parameters
parity RAM 3-38
ParseTable function 14-45, 14-130
partial resources 13-17 to 13-18, 13-21 to
13-24
partitions
created by Process Manager 29-5
defined 29-5
finding the available free memory in 29-11
finding the size allocated to a process 29-10
sizes of 5-14, 28-33 to 28-34
Paste command, and information windows
9-28
PATalkClosePrep function 32-20
pathnames 25-7
pauseCmd command 22-52, 22-85
PBCatMove function 25-47
PBCatSearch function 25-10, 25-20 to
25-25, 25-40
PBControl function
completion routine 32-43
and .DSP driver routines 32-58
IN-36

Index

PBCreateFileIDRef function 25-45
PBDeleteFileIDRef function 25-46
PBDTAddAPPL function 9-56
PBDTAddlcon function 9-54 to 9-55
PBDTCloseDown function 9-50
PBDTDelete function 9-60
PBDTFlush function 9-58 to 9-59
PBDTGetAPPL function 9-53
PBDTGetComment function 9-54
PBDTGetlcon function 9-51 to 9-52
PBDTGetlconInfo function 9-52
PBDTGetInfo function 9-59
PBDTGetPath function 9-49 to 9-50

PBDTOpenInform function 9-50

PBDTRemoveAPPL function 9-57
PBDTRemoveComment function 9-58
PBDTReset function 9-59
PBDTSetComment function 9-56 to 9-57

PBExchangeFiles function

25-43

PBGetCatInfo function 25-47
PBGetFCBInfo function. limitations with
MEFS disks 25-9
PBGetFlInfo function 25-10

PBGetForeignPrivs function

25-50

PBGetVolMountInfo function 25-48
PBGetVolMountInfoSize function 25-48
PBHDelete function 25-47
PBHGetFInfo function 25-10
PBHGetVolParms function 25-13 to 25-15,
25-37 to 25-40

PBHOpenDF function
PBHRename

function

25-53

25-47

PBMakeFSSpec function 25-42
PBOpenDF function 25-52
PBResolveFileIDRef function

PBSetForeignPrivs function

PBVolumeMount function

25-46

25-5]

25-49

‘pdoc' event ID 6-7
performance, measuring 23-14 to 23-16
periodic execution, scheduling routines for
23-3, 23-14

PGetAppleTalkInfo function
to 32-16

32-12, 32-13

phonetic order of characters 14-33, 14-36
physical RAM, testing for size 3-39
‘PICT’ file, in producing screen shot 13-16
PictInfo data type 18-5
PICT2Header record

17-25

Picture Utilities Package

data structures 18-5
routines in 18-9 to 18-14

18-3 to 18-18

pictures, surveying 18-5. See also version 2
picture format

Index

pitch of sounds 22-8, 22-10
pixel depths
Color QuickDraw’s handling of 16-5, 16-8
converting between 17-7, 17-8, 17-9
default color tables for 17-18, 20-7 to
20-8
graphics device record and 16-14
maximum 16-16
palettes for various depths 20-4
in pixel maps 16-8, 16-11
setting 21-12
pixel maps
colorizing 17-16
copying 17-12 to 17-17, 17-25 to 17-26
direct 17-4
dithering, using when copying 17-17
field extensions 17-4, 17-6, 17-7
indexed 17-4
resizing 17-17
resolutions of 17-18
surveying 18-5
transfer modes for 17-16 to 17-17
pixels, and glyphs 12-4, 12-13
Pixel2Char function 14-38, 14-46, 14-64,
15-29
PixMap32Bit function 21-16
PixPatChanged procedure 17-11, 17-27
playback synthesizers 22-11, 22-37
playing audio selections 22-58
playing sounds 22-41, 22-79
as notifications 22-7, 24-4
PLookupName function, wildcard characters
32-16
PlotCIcon procedure 9-13
Plotlcon procedure 9-13
‘pltt' resource type 20-4, 20-6
PmBackColor procedure 20-21, 20-22
pmBlack colors 20-6
PmForeColor procedure 20-21, 20-22
PMerVersion function 20-18
pmWhite colors 20-6
point size

changing by scaling 12-8 to 12-9
choice of, by user 12-15
defined 12-7
limit of 12-15
points, outline 12-10 to 12-12
polite notification by Notification Manager
24-4
pop-up control definition, testing for
availability 3-39
pop-up menus 2-36 to 2-37, 3-39
creating 3-16 to 3-19

PopUpMenuSelect function 3-16
popupPrivateData data type 3-19
PortChanged procedure 17-11, 17-27
port filter function 7-20
PortInfoRec data type 7-20
PortionText function 14-46, 14-64, 14-130
port number, .MPP driver 32-14
ports, palettes and 20-18
PostEvent function 5-5
PostHighLevelEvent function 5-23, 5-30
PostScript characters
in standard Roman character set E-1 to
E-5
not in standard Roman character set E-5
power management circuits, Macintosh
Portable 31-4
Power Manager 31-3 to 31-27. See also
Macintosh Portable
activity timer
resetting 31-13, 31-19
types of activity 31-6
controlling serial power 31-18 to 31-19,
31-21 to 31-22
how to use 31-12 to 31-19
routines in 31-19 to 31-24
sleep queue. See sleep queue
testing for availability 3-39, 31-12
testing for features 3-39, 31-12
wakeup timer
controlling 31-14
setting and reading 31-20 to 31-21
use of 31-12
Power Manager IC 31-3, 31-7
PPCAccept function 7-30, 7-49, 7-51 to
7-52
PPCAcceptPBRec data type 7-12, 7-37
PPCBrowser function 7-18 to 7-22, 7-41 to
7-42
filling ina target ID record 5-26
finding a specific port 5-24
use with Apple events 6-57, 6-58 to 6-59
PPCClose function 7-35, 7-42 to 7-45
PPCClosePBRec data type 7-12, 7-37
PPCEnd function 7-34 to 7-35, 7-48 to
7-49
PPCEndPBRec data type 7-12, 7-37
PPCInform function 7-28 to 7-29, 7-49 to
7-51
PPCInformPBRec data type 7-12, 7-37
PPCInit function 7-10, 7-39
PPCOpen function 7-16 to 7-18, 7-42 to
7-44
PPCOpenPBRec data type 7-12, 7-37
Index

IN-37

Inside Macintosh,

Volume VI

PPCParamBlockRec data type 7-12
PPC parameter block 7-12, 7-14, 7-34,
7-37
PPCPortRec data type 7-15
PPC ports
closing 7-35
defined 7-4
listing available 7-18 to 7-22
opening 7-14, 7-16 to 7-18
specifying locations 7-4, 7-15
specifying names 7-4, 7-14
PPCRead function

7-32, 7-53 to 7-54

PPCReadPBRec data type 7-12, 7-37
PPCReject function 7-31, 7-49, 7-52
PPCRejectPBRec data type 7-12, 7-37
PPC sessions
accepting 7-30 to 7-31
defined 7-5
ending 7-34 to 7-35
exchanging message blocks during 7-32
to 7-34
initiating 7-23, 7-24 to 7-28, 7-31
receiving requests for 7-28 to 7-29
rejecting 7-30 to 7-31
PPCStart function 7-24, 7-27 to 7-28, 7-45
to 7-46
PPCStartPBRec data type 7-12, 7-37
PPC Toolbox 7-3 to 7-65
calling conventions 7-12 to 7-14
and Event Manager 1-7
high-level events 5-3
routines in 7-36 to 7-56
testing for availability 3-39, 7-10
user interface guidelines 7-5
PPCWrite function 7-33 to 7-34, 7-53 to
7-55
PPCWritePBRec data type 7-12, 7-37
preferences files 9-40
Preferences folder
alias type for 9-30
defined 9-40
finding 9-43
storing files in 9-40
‘pref’ folder type 9-43
primary caret 15-7, 15-8, 15-9
PrimarylInit records 30-4
primary line direction 15-4
primary script 14-8
primary sorting order 15-26
PrimeTime procedure 23-5, 23-6, 23-17
Print Documents event
defined 6-32
event ID for 6-7
IN-38

Index

handling 6-35 to 6-36
printer drivers, localization issues 14-110
printers, determining type in use 13-16
printing, localization issues 14-110
PrintMonitor application, making
notification requests 24-5
PrintMonitor Documents folder
alias type for 9-30
defined 9-41
finding 9-43
privilege models 25-11
‘prnt’ folder type 9-43
processes
background 29-4
context of 5-13, 29-4, 29-6
creating 29-5
foreground 29-4
getting information about 29-8 to 29-11,
29-17 to 29-20
scheduling 29-6 to 29-7
ProcessInfoRec data type 29-9
process information record 29-9
process management 1-20, 29-3 to 29-23
Process Manager 3-27, 29-3 to 29-23
routines in 29-16 to 29-23
testing for availability 29-16
process serial numbers 29-4, 29-8
program linking
defined 7-5
to server applications for Apple events
6-26
program linking dialog box 7-18 to 7-22
Program-to-Program Communications
(PPC) Toolbox

7-3 to 7-65. See also

sessions
calling conventions 7-12
and Event Manager 1-7
high-level events 5-3
routines in 7-36 to 7-56
testing for availability 3-39, 7-10
user interface guidelines 7-5
‘prop’ descriptor type 6-9
protocol handlers
802.2 32-27 to 32-28
Ethernet
attaching 32-90
default 32-83 to 32-85, 32-92 to 32-93
detatching 32-9]
how called 32-85
how to call .ENET driver 32-86 to
32-88
using your own 32-85 to 32-88
-MPP driver limit 32-15

protocols, AppleTalk. See also protocol
handlers
AppleTalk Data Stream Protocol. See
AppleTalk Data Stream Protocol
AppleTalk Echo Protocol 32-7
AppleTalk Filing Protocol 32-8
AppleTalk Session Protocol 32-7, 32-11
AppleTalk Transaction Protocol. See
AppleTalk Transaction Protocol
Datagram Delivery Protocol 32-6
deciding which to use 32-11 to 32-12
clients 32-5
802.2 protocol 32-25 to 32-29
802.3 protocol 32-25, 32-90
implementation of 32-5
link access protocols 32-5, 32-6, 32-8.
See also LAP Manager
LocalTalk Link Access Protocol 32-6
Name-Binding Protocol 32-7, 32-15,
32-16
packet headers 32-25
relationships among 32-6
Routing Table Maintenance Protocol
32-6, 32-7
summary 32-5 to 32-8
type discriminator 32-25
Zone Information Protocol 32-7, 32-32 to
32-37
pseudo-items 26-15 to 26-18
pseudo-scripts 13-9
‘psn' descriptor type 6-9
‘psn' keyword 6-11
publishing data 4-4, 4-40. See also Edition
Manager; publishers
Publisher Options command (Edit menu)
2-33, 4-37
publishers
borders 4-7 to 4-9, 4-43 to 4-46
canceling 4-41
creating 4-14 to 4-17, 4-25 to 4-27, 4-62
to 4-65
defined 4-4
locating 4-42 to 4-43
multiple 4-16, 4-50 to 4-51
options for 4-37 to 4-43
section records for 4-14 to 4-17, 4-62 to
4-65
update modes 4-40 to 4-41
Q
QDDone function
QDError function

17-26

17-28

‘gery’ file type 8-41
‘qrsc' resource type 8-46 to 8-47
queries. See also data, retrieving
converting results to text 8-38 to 8-41, 8-55
defined 8-6
executing 8-61
halting execution 8-63
processing results 8-34 to 8-41
retrieving error messages 8-62
sample 8-29
sending 8-28, 8-60
sending a data item 8-60
starting 8-53 to 8-54
query definition functions 8-47 to 8-49
example 8-48
function declaration 8-47
query documents 8-41 to 8-49
contents 8-42 to 8-43
creating icons for 2-21, 9-13, 9-28
default icon for 9-10
dialog boxes 8-42
query resources 8-46 to 8-47
user interface guidelines 8-42
QueryRecord data type 8-44
query records 8-44 to 8-45
creating 8-52
defined 8-41
disposing of 8-52
query resources 8-46 to 8-47
queues
AppleTalk Transition Queue. See
AppleTalk Transition Queue
notification 24-6, 24-9 to 24-10
operating-system 23-3
sleep. See sleep queue
Time Manager 23-5
QuickDraw. See also Color QuickDraw
compatibility of different versions 16-6,
16-18, 16-19
and font scaling 12-8 to 12-9
and font styles 12-4
original color system of 16-6
and printer drivers 14-110
testing for version 3-39
versions of 16-6
quietCmd command 22-85
defined 22-53
sent by SndDisposeChannel 22-41, 22-84
using with freqDurationCmd 22-43
Quit Application event
defined 6-32
event ID for 6-7
handling 6-36 to 6-37
Index

IN-39

xapuy

Index

Inside Macintosh,

Volume VI

Quit command
and desk accessories

9-32

and Quit Application Apple event 6-32,
6-36
‘quit’ event ID 6-7
R

RAM
checking size of 3-39
parity 3-38
rateCmd command 22-34, 22-50, 22-85
ReadEdition function 4-24 to 4-25, 4-68 to
4-69
ReadLocation procedure 14-49, 14-131
ReadPartialResource procedure 13-22
receive buffer. See receive queue
receive queue
defined 32-44
and dspInit routine 32-59
and dspRead routine 32-46
‘reco’ descriptor type 6-9
RecordColors function 18-14
recording sounds 22-16 to 22-18
RecordPictinfo function 18-11
RecordPixMapInfo function 18-11
records, alias. See alias records
rectangle for selected scrolling list 2-26
rectangle help resources
compared to dialog item help resources
11-37, 11-42, 11-46
example of 11-46 to 11-47
format of 11-43
header for 11-43
"RECT' resource type 10-12
refCon field 26-18
reference number, determining for desktop
database 9-47, 9-49 to 9-50
region codes
defined 14-7
determining current 14-10, 14-42
list of 14-84
preferred 14-81
preferred sorting order for 14-14, 14-82
specifying for system 14-14
in version resources 9-23
regions
compared with scripts and languages
14-7, 14-8 to 14-9
defined 14-5
specific feature differences 14-6

IN-40

— Index

registered names queue, getting pointer to
32-13
RegisterSection function 4-19, 4-63 to 4-64
reInitCmd command 22-39, 22-85
relative search for an alias record 27-6, 27-7
removable disks 28-18
ReplaceGestalt function 3-30, 3-44, 3-47
ReplaceText function 14-47, 14-60 to
14-61, 14-62
reply Apple events 6-48 to 6-50
disposing of 6-50 to 6-51
filter functions while waiting for 6-66 to
6-67
timeouts for 6-63 to 6-64, 6-83 to 6-84
required Apple events 6-30 to 6-37
required parameters for Apple events 6-8,
6-47 to 6-48
Rescued Items from volume name folders
9-4]
Reset Timer event 6-84
ResizePalette procedure 20-24
resizing images 17-17
ResListElem record 8-45
resolution of images 17-18 to 17-19
resolution of screens when displaying
glyphs 12-13
ResolveAliasFile function 9-30
ResolveAlias function 27-10, 27-15
resource IDs _ 13-6 to 13-9
of application font 13-9
defined 13-3
of definition procedures 13-7
of font families 13-7 to 13-9
of function key resources 13-16
of packages 13-16
of pseudo-scripts 13-9
reserved for Apple Computer 13-6, 13-7
for Roman script system 13-8
of script systems 13-7 to 13-9
of system font 13-9
of system resources 13-6
Resource Manager 13-3 to 13-24
routines in 13-19 to 13-24
testing for features 3-40, 13-17
resources
About string for desk accessories 9-33
alias record 9-29
bundle 9-16 to 9-19
default help override 11-58 to 11-61
defined 13-3
for dialog item help 11-33 to 11-49
dialog item list 11-33 to 11-34, 11-38
file reference 9-14 to 9-19

Index

resources (Continued)

Finder icon help 11-56 to 11-58
folder 9-43
function key 13-16
icon list 9-10
icon 9-9 to 9-13
ID numbers 14-22
international 14-14 to 14-15
keyboard 14-14, 14-15
manipulating 14-76
menu help 11-21 to 11-33
menu string 9-25
menu string list 9-25
movable 9-33 to 9-34
for packages 13-16
palette 20-4, 20-6
partial 13-17 to 13-18, 13-21 to 13-24
providing fonts for users 13-18 to 13-19
query 8-46 to 8-47
reading a portion into memory 13-17 to
13-18, 13-22
rectangle help 11-42 to 11-49
setting size of 13-23 to 13-24
signature 9-6 to 9-9
size 9-20
sound 9-33 to 9-34
specifying handles for 14-77
system icon 13-10 to 13-15
used by Finder 9-5 to 9-24
use in worldwide software 2-5
user information 13-15 to 13-16
using 14-102
version 9-23 to 9-24, 22-69
window help 11-44 to 11-49
writing a portion to disk 13-17 to 13-18,
13-23
resource types
'alis’ 4-17, 9-29, 27-11
available character combinations 13-3
available for application’s use 13-4 to 13-5
'BNDL' 9-16 to 9-19
‘card’ 10-7
‘cicn’ 10-13
‘dast' 9-33
defined 13-3
'DITL' 11-33 to 11-34, 11-38, 26-10
in Monitors control panel extension
10-12
used by control panels 10-4
‘DLOG' 26-10
‘eadr’ 32-79
'FKEY' 13-16
'fld#' 9-43

'FOND' 13-7
"FONT" 13-7
'FREF' 9-14 to 9-19
‘gama’ 10-13
‘hdlg'. See 'hdlg' resource type
‘hfdr’ 11-56 to 11-58
‘hmnu' 11-21 to 11-33
‘hovr' 11-58 to 11-61
‘hret'. See ‘hret' resource type

‘hwin'. See 'hwin' resource type

‘ICN#' 9-10 to 9-12, 9-16
'ICON' 10-13
‘ics#' 9-12
INIT’ 10-14, 24-10
‘1t10' 14-14, 14-86
‘itll’ 14-14, 14-81, 14-87 to 14-89
'itl2'. See 'itl2' resource type
'itl4'. See 'itl4' resource type
‘itls' 14-14, 14-81
‘itlb'. See 'itlb' resource type
‘itlc' 14-14, 14-81 to 14-82
‘itlk'. See 'itlk' resource type
‘itm’ 14-14, 14-80, 14-82
'KCAP' 14-101
'KCHR'. See 'KCHR' resource type
‘kcs#’ 14-15, 14-98
‘kes4 14-15, 14-98
‘kes8' 14-15, 14-98
'KMAP' 14-15, 14-20
'KSWP' 14-15, 14-25, 14-98 to 14-99
‘mach’ 10-4
‘mntr’ 10-8 to 10-11
‘mst#' 9-25
‘mstr’ 9-25
‘nert’ 10-4
'NFNT'
13-7
'PACK' 13-16
‘pitt’ 20-4, 20-6
‘qrsc' 8-46 to 8-47
"RECT' 10-12
reserved for Operating System’s use 13-5
to 13-6
'scrn’ 10-9, 10-14
‘sect’ 4-17
'sfnt' 12-4, 12-14, 13-7
‘'SICN' 13-10
'SIZE'. See 'SIZE' resource type
'snd '. See 'snd ' resource type
‘snth' 22-8
'STR ' 9-20 to 9-22
'STR#' 10-13
‘vers’ 9-23 to 9-24, 10-13, 22-69
‘wstr’ 8-42
Index

IN-4]1

Inside Macintosh,

Volume VI

response procedures of Notification
Manager 24-4, 24-8 to 24-9
restCmd command 22-85
RestoreAS5 procedure 28-13
RestoreBack procedure 20-22
RestoreDeviceClut procedure 20-24
RestoreFore procedure 20-22
restoring the color environment 20-7
restoring window positions 2-22
result codes A-1 to A-8
result handlers 8-38 to 8-41
application 8-39
function declaration 8-40
getting pointers to 8-66
installing 8-65
provided by Apple Computer 8-39
removing 8-66
sample 8-41
system 8-39
ResultsRecord data type 8-37
results records 8-37 to 8-38
resumeCmd command 22-52, 22-85
resume events 5-6 to 5-8, 29-6
RetrievePictInfo function 18-12
return IDs of Apple events 6-55
return receipts 5-24, 5-26
RGBBackColor procedure 20-21
RGBColor data type, color cube and 19-4
RGB color model 19-5, 19-6, 19-7, 19-8
RGB color record 16-9, 16-16
RGBForeColor procedure 20-21
RGB (red, green, blue) values 16-3, 16-9,
16-10
RGB2CMY procedure 19-10
RGB2HSL procedure 19-10
RGB2HSV procedure 19-11
right-to-left script systems 14-16
ring-detect feature, modem 31-22
ring-wakeup feature, modem 31-22
RmvTime procedure
introduced 23-5
defined 23-17
using to compute elapsed time 23-14
road map to Volume VI P-17
ROM
testing for size 3-42
testing for version 3-30, 3-42
Roman character set. See standard Roman
character set
Roman Script System 14-8, 14-10, 14-15,
14-37
root directory 25-6
router address, AppleTalk 32-15
IN-42

Index

routines
list of, that may be called at interrupt time
B-7 to B-8
list of, that may not be called at interrupt
time B-1 to B-6
list of, that move or purge memory B-1 to
B-5
scheduling 23-3
routing table 32-6
Routing Table Maintenance Protocol 32-6
'rtid' keyword 6-10
RTMP 32-6
RTMP stub 32-7
runs of text 14-12, 15-5, 15-6
S
safe save of a file 25-9, 25-17 to 25-18
SameProcess function 29-19
sampled sound header 22-10, 22-99
sampled sounds
frames 22-32
multiple channels of 22-8, 22-12
playing 22-43
from disk 22-15, 22-56 to 22-57
points 22-32
recording qualities 22-59
storing 22-10
used as a voice 22-10
sampled sound synthesizer 22-10
Save As command (File menu) 26-4
SaveBack procedure 20-22
save changes dialog box 2-31
Save command (File menu) 26-4
SaveFore procedure 20-22
scaling fonts 12-8 to 12-9, 12-19 to 12-21
SCC, controlling power to in Macintosh
Portable 31-18 to 31-19, 31-21 to
31-22
scheduling
of processes by the Process Manager 29-6
routines 23-3
setting options 29-7
switching contexts 29-6
scrap coercion 5-19
scrap style element record 15-36, 15-39
scrap style table 15-37, 15-39
screens
configuration information 21-10, 21-11
depth 21-10
main 16-15
pixel depths of 16-8

Index

screens (Continued)

RAM for 16-5
and startup 16-15
variation among 16-3
screen shots 13-16
'‘scri’ file type 9-41, 14-20
ScriptCode data type 14-71, 14-75
script codes
and character set encodings 14-34
distinguishing scripts with 14-22
and hierarchy of scripts, codes, and
regions 14-8
implicit 14-40
for International Utilities Package 14-75
list of 14-84
preferred sorting order for 14-82
sorting text among scripts with 14-75
script icons. See keyboard icons
Script Management System 14-6 to 14-25
date and time formats 14-28
formats of numbers in 14-28 to 14-29
overview 14-10
related worldwide components 14-16 to
14-19
sorting in 14-26 to 14-27
Script Manager 3-23 to 3-24, 14-10 to
14-49. See also International Utilities
Package; TextEdit
calling 14-37, 14-38
calling a script system 14-38
checking and modifying global and local
variables 14-40
checking system variables 14-43
converting
dates 14-13
long dates 14-48
number formats 14-49

upper and lowercase text 14-62

worldwide dates and times 14-48
date utilities 14-48 to 14-49
defining line breaks 14-51 to 14-54
defining word boundaries 14-51 to 14-54
determining the features of 14-36
distinguishing scripts 14-22 to 14-23
drawing text 14-45 to 14-46
editing text 14-45, 14-46
formatting text 14-46 to 14-47
geographic information 14-13
global variables 14-12
handling justified text in 14-64 to 14-68
initializing 14-37
and the International Utilities Package
14-10

interpreting different scripts lexically
14-48
justifying text on the Roman Script System
14-68 to 14-70
localizing line break tables 14-50
localizing word selection tables 14-50
local variables 14-12
manipulating text 14-45 to 14-47
modifying date and time records 14-48
modifying text 14-47
number conversion 14-13
number parts and parsing 14-79
number utilities 14-49
obtaining character information 14-45
obtaining script information 14-44 to
14-45
optimizing word break tables 14-58
reading and storing geographic locations
14-49
routines, new to version 7.0 14-50 to
14-68
routines in, overview of 14-39 to 14-49
setting system variables 14-43
setting the active keyboard script 14-43 to
14-44
stripping diacritical marks 14-62
substituting and truncating text 14-61 to
14-62
substituting text 14-47, 14-60 to 14-61
testing for availablility 14-36
testing for number of active script systems
14-37
testing for version 3-40, 14-36
TextEdit’s use of 15-3 to 15-4
text organization 14-12
time utilities 14-48 to 14-49
truncating text 14-47, 14-59 to 14-60
using 14-36 to 14-38, 14-70
verifying date and time records 14-48
version 7.0 enhancements 14-10
working with formatted numbers 14-49
and worldwide software 14-10
script numbers. See script codes
script runs
and dual carets 15-9
and style runs 15-6
text hierarchy and 14-12, 15-5
ScriptRunStatus data type 14-124
scripts. See also languages; script codes;
script systems
automatic initialization 14-85
bit flags 14-85
character encoding in 14-34
Index

IN-43

Inside Macintosh,

Volume V1

scripts (Continued)
character input in 14-35
character reordering in 14-33
character representation in 14-30
composition rules 14-35
conjunct characters in 14-32
contextual forms in 14-31
default resources for 14-85
defined 14-5
diacritical marks in 14-32
distinguishing 14-22
font 14-37, 14-79, 15-11 to 15-13
identifying 14-8
interpreting lexically 14-48
keyboard 15-9, 15-11
and languages 14-8
ligatures 14-32
manipulating text in 14-35
overview of 14-29 to 14-34
primary 14-8
rendering text 14-36
representing on the Macintosh 14-34
resource numbers 14-79
routines for obtaining information 14-44
secondary 14-8
size limitations 14-34
sorting strings between 14-78
specifying when creating a file 25-32
system 14-8, 14-25, 14-79
text direction in 14-30
uppercase and lowercase characters in
14-32
word demarcation in 14-33
script system resource collections, icon for
9-34
script systems
automatic initialization of 14-86
bidirectional 14-16, 14-30
codes for 13-8 to 13-9
components of 14-16
configuring 14-19
contextual 14-16, 14-32
contrasted with scripts 15-4
creating simple 14-37
defined 14-5
determining if a double-byte system is
installed 14-42
determining the number of active 14-37
enabling 14-37
font attributes in 14-25
font family IDs for 13-8 to 13-9
fonts in 14-23
fully justified alignment in 14-33 to 14-34
IN-44

Index

how Script Manager calls 14-38
icons for 2-8, 2-11
initializing 14-37
installing 14-19
introduction to 14-15 to 14-16
keyboard handling 2-8, 14-23
localized versions of 15-4
mixed-directional text in 14-30
multibyte 14-16
multiple 14-8
non-Roman 14-15, 14-23
printing problems 14-110
pseudo-scripts 13-9
range of resource IDs available 13-7 to
13-9
removing 14-19
Roman 13-8, 14-10, 14-23
simple 14-15
testing for number 3-40
and TextEdit 15-3 to 15-4
text rendering in 14-36
types of 14-16
and worldwide software 14-10
'scrn' resource type 10-14, 21-10 to 21-11
modifying 10-9
scroll bars, help balloon for 11-10 to 11-12,
11-58 to 11-61
scrolling 15-21
scrolling throttle 3-38
ScrpSTElement data type 15-38, 15-39
ScrpStyleTab data type 15-37, 15-38,
15-39
SCStatus data type 22-70
SearchProc function 17-28
secondary caret 15-9
position 15-7 to 15-11
SecondaryInit records 30-5
secondary script 14-8
secondary sorting order 14-26
‘sect’ descriptor type 6-9
‘sect’ event class 6-7
Section Cancel event 4-12
SectionEventMsgClass event class 6-37 to
6-38
SectionOptionsDialog function 4-37 to 4-74
SectionOptionsExpDialog function 4-53 to
4-54, 4-74 to 4-76
SectionOptionsReply data type 4-38 to 4-39
Section Read event 4-12
components of 6-37
for new editions 4-16, 14-33 to 14-35,
14-4]
preventing initial 4-63

Index

Section Read event (Continued)
not sent after unsuccessful writing 4-71
sent after CloseEdition function 4-25
SectionReadMsgID event ID 6-37
SectionRecord data type 4-14
section records for publishers and
subscribers 4-14 to 14-17, 14-18,
14-19to 14-20
sections. See also publishers; subscribers
canceling 4-41 to 4-42
control blocks for 4-64
defined 4-4
reading and writing 4-2]
registering 4-12 to 4-13
renaming documents that contain 4-43
saving data in 4-14
saving files that contain 4-18
Section Scroll event 4-12, 4-43, 4-77, 6-38
Section Write events 4-12, 4-19, 6-37
SectionWriteMsgID event ID 6-37
‘sect’ resource type 4-17
Segment Loader 29-3. See also Process
Manager
selected scrolling list rectangle 2-26
selector codes. See Gestalt selector codes
selectors. See Gestalt selector codes
self-modifying code 23-14
send buffer. See send queue
send queue
defined 32-44
and dspInit routine 32-59
and dspWrite routine 32-46
flushing 32-76
Serial Communications Controller (SCC),

controlling power to in Macintosh
Portable 31-18 to 31-19, 31-21 to
31-22
serial power, controlling in Macintosh
Portable 31-18 to 31-19, 31-21 to
31-22
server applications for Apple events 6-5,
6-51 to 6-54
servers, alias type for 9-30
servers, connection 32-69. See also
connection listeners
session ID, data access
defined 8-14
getting 8-26, 8-53, 8-56
session numbers, data access
getting 8-59
use of 8-33
sessions, AppleTalk 32-7

sessions, data access
controlling 8-56 to 8-59
examples 8-15, 8-30
getting information about 8-33, 8-57 to
8-59
initiating 8-14, 8-26, 8-56
terminating 8-15, 8-30, 8-57, 8-63
sessions, PPC. See PPC sessions
SetA5 function 22-78, 23-12, 28-6, 28-13,
28-16
SetCurrentA5 function 22-78, 23-12, 28-6,
28-13, 28-16
SetDepth function 21-12, 21-23
SetDeviceAttribute function 21-22
SetEditionFormatMark function 4-24, 4-67
SetEditionOpenerProc function 4-56, 4-79
SetEntryColor procedure 20-25
SetEntryUsage procedure 20-25
SetEnvirons function 14-39-40, 14-64,
14-68
verbs for 14-42
SetFInfo function 9-36
SetFrontProcess function 29-19
SetGDevice function 21-22
SetGWorld procedure 21-18
SetOutlinePreferred procedure

12-17, 12-18

SetPalette procedure 20-18, 20-20
SetPaletteUpdates procedure 19-2]
SetPixelsState function 21-15
SetPreserveGlyph procedure 12-18, 12-21,
15-17, 15-28
SetResourceSize procedure 13-23
SetScript function 14-39 to 14-40
verbs for 14-40 to 14-41
SetSRsrcState function 30-7, 30-16
SetStylScrap procedure 15-36
SetSysJust procedure 2-8, 14-43
SetupA5 procedure 28-13
SetupAIFFHeader function 22-25, 22-99,
22-100
SetupSndHeader function 22-62, 22-99
SetWUTime function 31-20
7.0-compatible applications 3-9
7.0-dependent applications 3-9
7.0-friendly applications 3-9, 3-12
'sfil' file type 9-34
'sfnt' resource type 12-4, 12-14, 13-7
SGetCString function 10-7
SGetSRsre function 30-14
SGetTypeSRsre function 30-15
shared folder, alias type for 9-30
sharing files 1-18
Sharing Setup control panel 7-6
Index

IN-45

Inside Macintosh, Volume VI

Sharing Setup icon 7-6
‘shor’ descriptor type 6-9
ShortenDITL procedure 3-19, 3-22
Show Balloons command (Help menu)
11-4
Show Borders command (Edit menu)

‘SICN' resource type

13-10

2-33

signature resources 9-6 to 9-9
signatures of applications
in bundle resources 9-16
as creators 9-7
finding applications with specific 9-53
registering 9-6 to 9-9
'sign' descriptor type 6-9
Simple Beep 22-20, 22-21, 22-80
simple script systems
case conversion tables for 14-90
character type tables for 14-90
defined 14-15
tables for stripping diacritical marks 14-90
‘sing’ descriptor type 6-9
single-byte script systems. See simple script
systems
SInitPRAMRecs function 30-3
SInitSRsrcTable function 30-3
16-by-16 pixel icons (small) 2-19, 9-9,
9-12
size boxes, help balloon for 11-10 to 11-12
size resources 9-20
‘SIZE’ resource type
creating 9-20
defined 5-13 to 5-18
required for A/UX compatibility 3-27
required for 7.0 compatibility 3-11
specifying partition size 28-7, 28-33,
29-5
use by Apple events 6-26, 6-70
useTextEditServices flag 15-24
sleep demands 31-10 to 31-11
conditional 31-11
and network services 31-8
responding to 31-16
sequence of events 31-11
unconditional 31-11
sleep now 31-11
SleepQInstall procedure 31-21
SleepQRec data type 31-15
SleepQRemove procedure 31-21
sleep queue 31-7 to 31-11
adding an entry 31-15, 31-21
and network services 31-8
removing an entry 31-21
responding to calls 31-16
IN-46

Index

sample routine 31-17 to 31-18
sleep demands 31-10 to 31-11
sleep request revocations 31-1]
sleep requests 31-8-9
wakeup demands 31-11
sleep queue record 31-15
sleep request revocations 31-11, 31-16
sleep requests 31-8 to 31-9
and network services 31-8
responding to 31-16
revoking 31-11
sequence of events 31-8
sleep state 31-6 to 31-7
slop value
defined 14-64
distributing among style runs 14-67,
14-70
measuring justified text 14-67
slot cards. See cards, NuBus
Slot Manager 30-3 to 30-21. See also
sResource data structures
assembly-language routine selectors
30-10
initialization 30-4
parameter block 30-11 to 30-13
PrimaryInit records, executing 30-4
relationship to graphics managers 16-8
routines in 30-10 to 30-18
search routines, summary 30-8
SecondarylInit records 30-5
testing for version 30-13
32-bit addressing 30-5
version | and version 2 30-3, 30-13
in volumes of Inside Macintosh P-15
slot resources. See sResource data structure
Slot Resource Table
adding an sResource data structure 30-17
creation of 30-4
slots
and graphics capabilities 16-3
testing for locations 3-38
slotV Install function 23-9

Smaller (point sizes) command

12-15

SmallFract2Fix function 19-27, 19-11
SmallFract values 19-9, 19-11
small icons (16-by-16 pixel)
design guidelines 2-19
resource [Ds for 9-12
resources for 9-9
smRSymbol pseudo-script 13-9
SMStatus data type 22-71
smTransGana2 constant 14-116
smUninterp pseudo-script 13-9

Index

SNAP (subnetwork access protocol) 32-25,
32-28
SndAddModifier function 22-82
SndChannel data type 22-12
SndChannelStatus function 22-44, 22-70,
22-87
SndCommand data type 22-11
SndControl function 22-34, 22-40, 22-41,
22-87
SndDisposeChannel function 22-35, 22-40,
22-52, 22-82
SndDoCommand function
introduced 22-11
and other low-level routines 22-34, 22-35
routine description 22-83
SndDoImmediate function
introduced 22-11
issuing quietCmd with 22-52
and other low-level routines 22-34, 22-35
routine description 22-83
SndDoubleBuffer data type 22-74
SndDoubleBufferHeader data type 22-73
SndGetSysBeepState procedure 22-55,
22-80
SndManagerStatus function 22-71, 22-87
SndNewChannel function
callback parameter 22-78
illustrated 22-36
initialization parameter 22-38
introduced 22-12
and other low-level routines 22-35
routine description 22-81
SndPauseFilePlay function 22-56, 22-89
SndPlayDoubleBuffer function 22-72,
22-90
SndPlay function
illustrated 22-35
playing compressed resources with 22-55
playing recorded sounds with 22-62,
22-100
playing sampled sounds with 22-43
playing sound resources with 2-10, 2-15
relationship to other functions 22-11,
22-34
routine description 22-80

SndRecord function

22-17, 22-58, 22-92

SndRecordToFile function
description 22-93
introduced 22-17
using to create sound files 22-25, 22-59
'snd ' resource type. See also sound
resources
creating 22-59

playing 22-35 to 22-36
storing sounds in 22-10

SndSetSysBeepState function 22-55, 22-81
SndSoundManagerVersion function

22-69,

22-88
SndStartFilePlay function
description 22-88
introduced 22-10
using to play sound files 22-15, 22-25,
22-59, 22-101
using to play sound resources 22-56,
22-57
SndStopFilePlay function 22-56, 22-90
‘snth' resource type 22-8
sockets
addresses of
and dspCLListen routine 32-71
and dspOpen routine 32-64
connection listening 32-39
statically assigned 32-15
Sony sound chip 22-6
sorting strings 14-26 to 14-27
contraction 14-27
exceptional words 14-27
expansion 14-27
ignorable characters 14-27
order 14-26, 14-103
primary order 14-26
routines for 14-72, 14-78 to 14-79
secondary order 14-26
special cases 14-78
version 7.0 enhancements 14-26
sound channels
allocating

22-36, 22-81

bypassing 22-6
defined 22-12
flushing 22-7
initializing 22-38
installing voices into 22-50
linking synthesizers to 22-37, 22-82
reinitializing 22-39
releasing 22-40, 22-82
specifying length of 22-37
soundCmd command 22-50, 22-86
sound commands
data offset bit 22-20
issuing 22-11, 22-82
list of available 22-83
list of constants 22-12
overview of 22-10
place in sound production system 22-6 to
22-8
structure of 22-11
Index

IN-47

Inside Macintosh,

Volume VI

Sound control panel
illustration 22-16
and SysBeep procedure 22-54, 22-80
sound data 22-55
SoundDataChunk data type 22-31
Sound Driver 22-3, 22-8
sound files 22-4, 22-25. See also AIFF
files; AIFF-C files
SoundHeader data type 22-44
sound headers 22-44 to 22-50
compressed 22-10, 22-47, 22-99
extended

22-10, 22-45, 22-99

standard 22-10, 22-44, 22-99
sound input, dialog box 22-17
sound input devices
closing 22-17, 22-94
connection state 22-66
getting information about 22-18
opening 22-17, 22-62, 22-94
setting information about 22-18
sound input parameter blocks 22-59
setting up 22-60 to 22-61
Sound Manager 22-3 to 22-113
enhanced 22-3
input 22-16
input completion routines 22-62
interrupt routines 22-63
routines in 22-79 to 22-102
testing for features 3-40, 22-69
testing for version 22-69
sound resources 22-18 to 22-24
icon for 9-34
installing and removing 9-39
sounds
compressing 22-55
computed 22-10
digitally recorded 22-10
expanding 22-55
as notification 24-4, 24-7
playing 22-41, 22-79
recording 22-16 to 22-18
storing 22-25
volume of 22-8
sound synthesizers. See synthesizers
source applications of Apple events 6-5
spacing in text. See justification
SPBBytesToMilliSeconds function 22-102
SPBCloseDevice function 22-17, 22-94
SPB data type 22-59, 22-60
SPBGetDevicelnfo function 22-18, 22-62,
22-63, 22-98
SPBGetIndexedDevice function 22-94,
22-102
IN-48

Index

SPBGetRecordingStatus function 22-97
SpBlock data type 30-11
SPBMilliSecondsToBytes function 22-102

SPBOpenDevice function 22-17, 22-60,

22-62, 22-94
SPBPauseRecording function 22-17, 22-97
SPBRecord function 22-17, 22-60, 22-62,
22-63, 22-95
SPBRecordToFile function

22-17, 22-25,

22-96
SPBResumeRecording function 22-17,
22-97
SPBSetDevicelnfo function 22-18, 22-63,
22-98
SPBSignInDevice function 22-17, 22-101
SPBSignOutDevice function 22-17, 22-101

SPBStopRecording function 22-17, 22-60,

22-62, 22-97
SPBVersion function 22-70, 22-88
special folders, testing for availability 3-36
split carets. See dual carets
SPrimaryInit function 30-3
square waves 22-8
square-wave synthesizer 22-54
sResource data structures. See also cards,
NuBus; Slot Manager
adding to Slot Resource Table 30-17
determining base address 30-18
enabling and disabling 30-7, 30-16
getting information about 30-13 to 30-16
next 30-14 to 30-15
particular type 30-15 to 30-16
specific one 30-14 to 30-15
restoring 30-8 to 30-10, 30-17
searching for 30-8 to 30-9
'srvr' alias type 9-30
'ssid' descriptor type 6-9
stack, application 29-5
standard file dialog boxes
help balloons for 11-10, 11-13
7.0 version of 2-30 to 2-31
Standard File Package 26-3 to 26-28
activation procedures 26-19
compatibility with earlier procedures 26-20
dialog hook functions 26-12 to 26-18
file filter functions 26-12
modal-dialog filter functions 26-18
opening files 26-6 to 26-8, 26-22 to 26-24
reply record 26-4 to 26-5
routines in 26-20 to 26-24
saving files 26-6 to 26-8, 26-20 to 26-22
testing for features 3-40, 26-4
in volumes of /nside Macintosh P-14

Index

StandardFileReply data type 26-4

StandardGetFile procedure 3-40, 26-6,

26-22
StandardNBP routine 3-40
StandardPutFile procedure 3-40, 26-6,
26-20
standard Roman character set
differences from original set 14-104 to
14-105
table of 12-5, E-1 to E-5
tokens and 14-12
standard save changes dialog box 2-31
standard sound header 22-10, 22-44, 22-99
StartSecureSession function 7-24 to 7-25,
7-45, 7-48
Startup Items folder
alias type for 9-30
defined 9-4]
finding 9-43
startup screen 16-15
static windows, help balloons for 11-41 to
11-49
stationery pads
creating icons for 2-21, 9-13, 9-15
default icon for 2-21, 9-10
defined 9-26 to 9-27
handled by Standard File Package 26-5
recognition of 5-16
status routines, Data Access Manager 8-19
to 8-26
defined 8-12
function declaration 8-20
sample 8-23
status messages 8-21 to 8-23
STElement data type 15-37, 15-38
STHandle data type 15-37, 15-38
Stop All Editions command (Edit menu)

2-33, 4-10
Stop button 2-28
strings
comparing 14-26, 14-72
format of 14-13
modifying standard comparison 14-73
replacing 14-47
sorting 14-26 to 14-27, 14-73
truncating 14-47
String2Date function 14-48, 14-88, 14-130
status value constants for 14-122
String2DateStatus data type 14-126
String2Time function 14-48, 14-131
StripAddress function 15-18, 28-12, 28-16
StripText procedure 14-47, 14-63

StripUpperText procedure 14-47, 14-62,
14-63
‘STR ' resource type, use in applicationunavailable messages 9-20 to 9-22
'STR#' resource type 10-13
'strt' folder type 9-43
Str2Format function

14-49,

14-92, 14-94,

14-13]
structure regions of help balloons 11-64
STScrpHandle data type 15-37
StScrpRec data type 15-37, 15-38
and font script 15-13
SetStylScrap procedure and 15-36
TENumStyles function and 15-36
StyledLineBreakCode data type 14-127
StyledLineBreak function 14-47, 14-130,
15-15, 15-16
Style menu, marking items based on current
selection 15-34
style record. See TEStyleRec data type
StyleRun data type 15-37, 15-38
keyboard font synchronization with 15-13
setting styles in TextEdit’s scrap record
15-36
style runs 14-12, 15-5 to 15-6
multiple 14-65, 14-67
number of intercharacter spaces in 14-69
and script runs 15-6
specifying the position of 14-68
style run table. See StyleRun data type
styles
backspacing to beginning of 15-31
defined 12-4
determining, across a selection 15-34 to
15-35
determining number of changes 15-36

setting in TextEdit’s scrap record

15-36

toggling 15-32 to 15-33
verbs for retrieving information 14-40
style scrap record. See StScrpRec data type

subnetwork access protocol (SNAP)

32-28

32-25,

Subscriber Options command (Edit menu)

2-33, 4-37 to 4-38
subscribers
borders 4-7 to 4-9, 4-43, 4-46
canceling 4-4]
creating 4-14 to 4-17, 4-31 to 4-33, 4-62
to 4-65
defined 4-4
modifying the contents of 4-52
to non-edition files 4-54 to 4-61
options 4-37 to 4-43
Index

IN-49

Inside Macintosh,

Volume

VI

subscribers (Continued)

section records for 4-14 to 4-17, 4-62 to
4-65
update modes 4-41

Subscribe To command (Edit menu)

2-33

subscribing. See also Edition Manager;
subscribers
to non-edition files 4-54 to 4-61
options for 4-38, 4-41
subscripts 14-29, 14-46, 14-108
suitcases for fonts and desk accessories
9-34
summaries of managers P-6
supervisor mode 28-25
surveying pictures and pixel maps 18-5
suspend events 5-6 to 5-8, 29-6
SVersion function 30-13
switching, context 5-13
syncCmd command 22-53, 22-86
synchronization, keyboard and font 2-8,
15-11
synthesizers
sampled sound 22-10
square-wave 22-8, 22-54
specifying sound channels for 22-36 to
22-37
testing for capabilities 22-40
wave-table 22-9
SysBeep procedure 22-3, 22-54, 22-80
SysEnvirons function 3-4, 3-28, 3-29, 3-30
system alarm, making notification requests
24-5
system alert sounds 24-4
disabling 22-55
enabling 22-55
playing 22-54, 22-80
Simple Beep 22-80
in version 7.0 22-3
system Apple event dispatch table 6-28
system coercion table 6-67
system extensions
and Extensions folder 9-41
installing and removing 9-39
System file
defined 9-42
testing for version 3-42
System file resources
for application icons 13-11
available for application’s use 13-4 to
13-5
for desktop icons 13-13 to 13-14
for document icons 13-11
for folder icons 13-12
IN-SO

Index

reserved for Operating System’s use
13-5 to 13-6
for Standard File Package icons 13-14 to
13-15
for System Folder icons 13-12
for user information 13-15 to 13-16
System Folder
alias type for 9-30
finding 9-43
organization of 9-39 to 9-42
system global variables 28-4
routines for setting and checking 14-40
system heap 3-42, 28-4
system icons 2-21 to 2-22, 13-10 to 13-15
for the desktop 13-13 to 13-14
for documents and applications 13-11
for folders 13-12
for the Standard File Package 13-14 to
13-15
for the System Folder 13-12
system menus 3-15
system script
defined 14-25
and IntlForce flag 14-79
relation to other scripts 14-8
system script code 14-81
system software version 6.0 1-3
SystemTask procedure 5-19
system traps
listed by routine name C-3 to C-4
listed by trap name C-1 to C-3
lists of those that take selectors C-5 to
C-16
testing for availability 3-7 to 3-9
system variables, routines for checking and
setting 14-43
system zone 28-4
T

'‘targ' descriptor type 6-9
target addresses of Apple events 6-57 to
6-59
target applications of Apple events 6-5
TargetID data type 5-22
target of an alias record 27-3
TAS instruction 3-6
tasks, background, making notification
requests 24-3
TEClick procedure 15-12, 15-21
TEContinuousStyle function 15-34 to 15-35
TECustomHook procedure 15-25 to 15-26

Index

TEDispatchRec data type 15-25, 15-38,
15-39
TEDispatch trap 15-21, 15-43
TEFeatureFlag function 15-22 to 15-23
TEFindWord global variable 15-29 to 15-31
TEGetPoint function 15-31 to 15-32
TEIntHook data type 15-25
TEKey procedure
handling double-byte characters 15-13
keyboard font synchronization with 15-13
modification to 15-31
text buffering 15-23
and vertical caret movement 15-14
TempDisposHandle procedure 28-37, 28-40
‘temp’ folder type 9-43
TempFreeMem function 28-36, 28-38

TempHLock procedure 28-37, 28-39
TempHUnlock procedure
TempMaxMem

function

28-37, 28-39

28-36, 28-39

TempNewHandle function 28-36, 28-39
temporary files 9-40, 9-41
Temporary Items folder
defined 9-40
finding 9-43
temporary memory 28-34 to 28-40
allocating 28-36
defined 28-7
locking 28-37
manipulating 28-35
releasing 28-37
routines 3-11, 28-34, 28-36, 28-38 to
28-40
testing for features 3-38, 28-37
testing for size 28-36
tracking 28-34
unlocking 28-37
TempTopMem function 28-37
TENumStyles function 15-36
TERec data type
accessing TextEdit hooks 15-25
caret, determining vertical movement of
15-14
caret position at line ends, determining
15-14to 15-15
clikStuff field 15-31
determining line length 15-20
and FindWord procedure 15-31
line-height element array 15-31
lineHeight field 15-31
relationship to other data structures 15-37,
15-38
synchronizing keyboards and fonts 15-13
wordBreak field 15-29 to 15-31

TEReplaceStyle procedure 15-33
Terminal Manager, testing for availability
3-40
terminology in applications, recommended
2-13 to 2-14, 4-4, 7-5
TESetJust procedure 15-19
TESetSelect procedure 15-12
TESetStyle procedure 15-12
modification 15-32 to 15-33
TestDeviceAttribute function 21-22
TEStyleHandle data type 15-37, 15-38
TEStyleRec data type 15-37, 15-38
TEContinuousStyle function and 15-35
TESysJust global variable
alignment of dialog box text and 2-8,
14-109
checking with GetSysJust function, 14-43
mixed-directional text and 15-4
setting with SetSysJust procedure 14-43
TEGetPoint function and 15-31
TESetJust procedure and 15-19
text. See also characters; fonts; glyphs; lines
of text; scripts; styles
alignment 14-33 to 14-34
bidirectional 14-30
composition rules 14-35
computing spacing factors for Roman
14-69
converting lower and uppercase 14-47,
14-62 to 14-63
diacritics, stripping 14-47, 14-62 to 14-63
direction 14-30, 14-109
drawing 14-45 to 14-46, 15-28
dual carets in 15-9 to 15-10
editing 2-6 to 2-7, 14-45 to 14-46
formatting 14-46 to 14-47
fully justified, handling 14-64 to 14-68
ideographic 14-30
justification 14-33 to 14-34, 14-68 to
14-70
localizing 2-6 to 2-8, 14-102 tol4-107
manipulating 14-35, 14-45 to 14-47
mixed-directional 15-4 to 15-11
mouse-down regions in 15-8
organizing 14-12, 15-5
rendering 14-36
scaling 14-64
searching and replacing 14-47
substituting 14-47, 14-60 to 14-62
tokens for 14-12, 14-48
translating 14-102
truncating 14-47, 14-59 to 14-60
TextBox procedure 15-26, 15-28
Index

IN-SI1

Inside Macintosh,

Volume V1

text buffering 15-18, 15-23
'TEXT' descriptor type 6-9
TextEdit 15-3 to 15-43. See also Script
Manager; text

customizing features of 15-18, 15-25 to
15-31
data structures 15-37 to 15-39
routines in 15-21 to 15-36
Script Manager-compatibility 15-3 to
15-4, 15-18
testing
for features 3-41, 15-17 to 15-18
for Script Manager—compatibility 15-18
for version 15-17 to 15-18
using 15-17 to 15-21
in volumes of /nside Macintosh P-12
worldwide support provided by 1-22
TextEdit dispatch record. See
TEDispatchRec data type
'TEXT' file type 9-8
TextStyle data type 15-38, 15-39
determining styles across a selection 15-35
toggling a style 15-33
text style record. See TextStyle data type
TextWidth function
and HITTESTHook 15-29
and TextWidthHook 15-27 to 15-28
TextWidthHook field 15-18, 15-25, 15-26
to 15-28
theGDevice global variable 21-8, 21-21
32-bit addressing
compatibility issues 1-20
defined 28-10
and master pointers 28-11
testing for availability 3-35
32-bit clean 3-28, 28-10
32-bit clean ROMs 3-13
32-Bit QuickDraw. See Color QuickDraw
32-by-32 pixel icons (large) 2-18, 9-9, 9-10
TickCount function 23-9
ticks 23-9
Ticks global variable 23-9, 31-13
tilde 14-97, 14-98
timbreCmd command 22-51, 22-86
time
converting 14-48
formats 14-14, 14-16, 14-86
localizing 14-13, 14-74
modifying records 14-48
TimeDBRA global variable 23-15
time delays
microseconds 23-5, 23-6
milliseconds 23-4
IN-52

Index

Time Manager 23-3 to 23-19. See also Time
Manager tasks
delays 23-4, 23-5
extended 23-6
original 23-4
revised 23-5
routines in 23-16-17
and synchronizing sounds 22-53
testing for version 3-33, 3-41, 23-3, 23-4
Time Manager queues 23-5
Time Manager task records 23-4
Time Manager tasks
activating 23-5, 23-11, 23-17
installing 23-5, 23-8, 23-11, 23-16
making notification requests 24-3, 24-9
periodic 23-14
reactivating 23-5
removing 23-5, 23-17
scheduling 23-9 to 23-10
structure of records 23-4
using global variables in 23-13
timeouts for reply Apple events 6-63 to
6-64, 6-83 to 6-84
timer, wakeup. See wakeup timer
‘timo’ keyword 6-10
tip function, creating 11-72 to 11-73
tips of help balloons
defined 11-6
for help balloons in menus _ | 1-22
specifying in dynamic windows 11-53
specifying in ‘hdlg' resources | 1-37
specifying in ‘hret' resources 11-44
TMTask data type 23-4, 23-7
ToggleDate function
error codes for 14-123
interface for 14-131
modifying date and time records with
14-48
related constants 14-122
TogglePB data type 14-127
ToggleResults data type 14-124
TokenBlock data type 14-127
TokenBlockPtr data type 14-127
tokenizer 14-12
TokenRec data type 14-128
TokenRecPtr data type 14-128
TokenResults data type 14-123
tokens 14-12, 14-48, 14-79, 14-92
TokenTalk Link Access Protocol 32-6
TokenType data type 14-128
tolerance, for color matching 20-10
tolerant colors 20-5, 20-7, 20-10, 20-13
Toolbox Event Manager. See Event Manager

Index

totalLoadCmd command 22-54, 22-86
‘tran’ keyword 6-10
transaction IDs of Apple events 6-55
transactions, Apple event 6-55
transfer modes, in Color QuickDraw 17-16
Translate24To32 function 28-13, 28-16
translation. See localization
Transliterate function
modification of tables for 14-105
modifying text with 14-47
optional tables for in 'itl2' resource 14-90
source masks 14-116
target modifier constants 14-116
target types 14-115 to 14-116
TrapAvailable function, defined 3-9
trap dispatch table, testing for the base
address 3-36, 3-38, 3-41
trap macro notes P-6
trap macros. See system traps
traps. See system traps
trap table, testing for the base address 3-36,
3-38, 3-41
Trash, alias type for 9-30
Trash directories
appearance to users 9-40)
defined

9-42

finding 9-43
TRCCB data type 32-38
triangles in pop-up menus 2-36
TripleInt data type 14-127
‘trsh' alias type 9-30
'trsh' folder type 9-43
‘true’ descriptor type 6-9
TrueType fonts 3-36. See also fonts; outline

glyphs

Bézier curves of 12-10
choosing 12-16
compared to bitmapped fonts 1-16, 12-8
icon resources for 9-34
mathematical basis of 12-10
rendering of 12-10 to 12-14
scaling 12-8 to 12-9, 12-19 to 12-21
testing for 3-12, 3-36
user interface guidelines for 2-34, 3-12
truncating text 14-47, 14-59 to 14-60
truncCode data type 14-59
TruncString function 14-13, 14-47, 14-59
to 14-60
TruncText function 14-13, 14-47, 14-59 to
14-60, 14-61 to 14-62
24-bit addressing 1-20, 28-10, 28-11
2-byte character codes 14-23, 14-34
typeAEList descriptor type 6-9

typeAERecord descriptor type 6-9
typeAlias descriptor type 6-9
typeAppleEvent descriptor type 6-9
typeAppISignature descriptor type 6-9
typeAppParameters descriptor type 6-9
typeBoolean descriptor type 6-9
typeChar descriptor type 6-9
typeComp descriptor type 6-9
‘type’ descriptor type 6-9
typeEnumerated descriptor type 6-9
typeExtended descriptor type 6-9
typeFalse descriptor type 6-9
typeFloat descriptor type 6-9
typeFSS descriptor type 6-9
type-in pop-up menus 2-37
typeInteger descriptor type 6-9
typefaces 12-4. See also fonts
typeKeyword descriptor type 6-9
typeLongFloat descriptor type 6-9
typeLongInteger descriptor type 6-9
typeMagnitude descriptor type 6-9
typeNull descriptor type 6-9
typeObjectSpecifier descriptor type 6-38
typeProcessSerialNumber descriptor type
6-9, 6-57
typeProperty descriptor type 6-9
typeSectionH descriptor type 6-9
typeSessionID descriptor type 6-9, 6-57
typeShortFloat descriptor type 6-9
typeShortInteger descriptor type 6-9
typeSMFloat descriptor type 6-9
typeSMInt descriptor type 6-9
typeTargetID descriptor type 6-9, 6-57
typeTrue descriptor type 6-9
typeType descriptor type 6-9
typeWildCard descriptor type 6-9, 6-29,
6-72
U

umlaut 14-97, 14-98
UnholdMemory function 28-19, 28-27
UNIX operating system 3-24
unlocking physical memory 28-20
UnlockMemory function 28-20, 28-29
UnlockPixels function 21-5, 21-15
UnRegisterSection function 4-20, 4-41,
4-64
UnTokenTable data type 14-128
UnTokenTableHandle data type 14-128
UntokenTablePtr data type 14-128
UpdateAlias function 27-11, 27-14
Index

IN-53

Inside Macintosh,

Volume VI

update events, as handled by the Help
Manager 11-20, 11-33, 11-54, 11-68
UpdateGWorld function 21-5, 21-16
uppercase characters
converting to lowercase 14-47, 14-62 to
14-63
diacritical marks on 14-32
UpperText procedure 14-47, 14-63
usage categories for colors. See color usage
categories
user comments
removing 9-58
retrieving from desktop database 9-54
setting 9-56 to 9-57
user interface guidelines 2-3 to 2-38
for Data Access Manager 8-11 to 8-12
for dialog boxes 2-23 to 2-32
for documentation 2-12 to 2-14
for Edition Manager 4-4
for Help Manager 11-14 to 11-17
for icons 2-10 to 2-11, 2-18 to 2-22,
9-10, 9-12
for menus 2-32 to 2-37
for PPC Toolbox 7-5
for providing feedback 2-14 to 2-15, 8-11
to 8-12
query documents 8-42
recommended terminology 2-13 to 2-14,
4-4, 7-5
summary of design principles 2-3 to 2-4
in volumes of Inside Macintosh P-8
for windows 2-22 to 2-23
for worldwide software 2-4 to 2-12
User Interface Toolbox 1-4
user routines, ADSP 32-56
sample code 32-57
users
documentation for 2-12
help for. See help balloons
information about, determining 13-15 to
13-16
interaction with server applications 6-51
to 6-54, 6-82 to 6-83
providing feedback for 2-14, 8-11 to 8-12
users & groups control panel 7-7
users & groups icon 7-7
useTextEditServices flag 5-16
V

ValidDate function 14-48, 14-131
related constants 14-122
IN-54

— Index

variation code for help balloons 11-7 to
11-8, 11-9
VBL interrupts 23-9
VBL tasks
making notification requests 24-3, 24-7,
24-9
and memory management 28-3
scheduling 29-7
verbs
for GetEnvirons and SetEnvirons 14-4]
to 14-42
for GetScript and SetScript 14-40 to
14-4]
for KeyScript 14-43 to 14-44
versionCmd command 22-86, 22-87
version information for applications
in 'vers' resource 9-23 to 9-24
in Finder windows 9-23
in information windows 9-24
in signature resource 9-7
version resources 9-23 to 9-24

version 2 picture format

17-20 to 17-24

creating 17-25
direct pixels in 17-21
font name information 17-21, 18-8
header 17-23
line justification information 17-21
opcodes 17-20
packing of data 17-22
sample 17-23 to 17-24
'vers' resource type 9-23 to 9-24, 10-13,
22-69
Vertical Retrace Manager 23-3, 23-9
video cards. See also Monitors control panel
declaration ROM of 16-17
gamma tables 10-13
name 10-13
and screen displays 16-8
VInstall procedure 23-9
virtual memory 28-17 to 28-33
and AppleShare volumes 28-18
backing-store file 28-10
bus error vectors under 28-24
CPU data caching 28-20, 28-28
debugger support 28-23 to 28-26
deferring interrupt code execution 28-23
defined 28-9
mapping information, getting 28-21 to
28-23
overview I-19
preventing paging out to 28-18 to 28-20
and removable disks 28-18

Index

virtual memory (Continued)
routines for 28-26 to 28-33
testing for availability

3-13, 3-41, 28-21

and user interrupts 28-23
VisibleLength function 14-47, 14-68,
14-130
TextEdit’s use of 15-16
voices
installing into sound channels 22-50
using sampled sounds as 22-10
volume catalog, Finder information in 9-36
to 9-38
volume of sounds 22-8
volumes
Finder’s desktop database for 9-44 to
9-60
identified in FSSpec records 25-15
identifying in an alias resolution 27-6
mounting programmatically 25-26 to
25-28
searching the catalog 25-20 to 25-25
specifying 25-7
W

waitCmd command 22-52, 22-86
WaitNextEvent function
introduced 5-18
routine description 5-29
scheduling processes 29-5, 29-6, 29-7
sleep parameter 5-19
use by the Apple Event Manager 6-60
using instead of GetNextEvent 3-11
wakeup demands 31-11
WakeUpProcess function 29-20
wakeup timer
controlling 31-14
setting and reading 31-20 to 31-21
use of 31-12
waveTableCmd command 22-50, 22-86
wave tables 22-9
wave-table synthesizer 22-9
WideCharArr data type 14-124
WideChar data type 14-124
WIDTHHook field 15-25, 15-26 to 15-28
wildcard characters in AppleTalk names
32-16
wildcard descriptor type ('****') 6-9, 6-29,
window definition functions
avoiding memory address violations
28-12
.

6-72

.

.

.

.

for color dialog boxes 2-16
for color windows 2-16
window frames, help balloons for 11-10 to
11-12, 11-58 to 11-61
window help resources
compared to using helpItem item 11-40 to
11-41
example of 11-46 to 11-47, 11-48 to
11-49
format of

11-44 to 11-45

header for 11-45 to 11-46
options for 11-45 to 11-46
Window Manager 5-5
interactions with Palette Manager 20-19 to
20-21
new features of 3-15
windows
calculating size 14-43
color design for 2-16 to 2-18
help balloons for 11-10 to 11-12, 11-41
to 11-56, 11-58 to 11-61
inactive 15-23
localizing 14-102
outline highlighting in 15-23
positions on multiple monitors 2-22
standard state position 2-23
standard state size 2-23
user interface guidelines for 2-22 to 2-23
zoom box effect 2-23
word boundaries
defining 14-51
searching for 15-31
word break tables 14-55 to 14-58
offsets to 14-92, 14-93
WordRedraw global variable 15-20
words. See also text
breaking 14-58, 15-29
selection of 15-15 to 15-16
working directories 25-6
worldwide software 14-5 to 14-110. See
also International Utilities Package;
localization; Script Manager; TextEdit
control panels examples 14-18, 14-19
components of worldwide system
software 14-16to 14-19
desk accessory example 14-18
font considerations 14-25
fonts, installing 14-19 to 14-20
international resources 14-14 to 14-15,
14-79 to 14-95
keyboard resources 14-14 to 14-15,
14-79 to 14-80

Index

IN-55

Inside Macintosh,

Volume VI

worldwide software (Continued)

keyboards, installing 14-19 to 14-20
keyboard translation 14-23 to 14-25
languages 14-7, 14-8 to 14-9
regions 14-8 to 14-9
scripts 14-8 to 14-9, 14-22 to 14-23
script systems and 14-15 to 14-16
currently available 14-10
installing 14-19 to 14-20
system software, localized versions
14-7
text manipulation in 14-35
user interface guidelines for 2-4 to 2-12
calendar differences 2-5, 14-28
cultural values 2-5
cursor movement 2-7
dialog box layout 2-8
font considerations 2-11
keyboard handling 2-8
language differences 2-6
resources, use of 2-5
text display 2-6 to 2-8
in volumes of /nside Macintosh
P-1]
worldwide system software. See worldwide
software

write-data structure 32-81
WriteEdition function 4-24, 4-70
WriteLocation procedure 14-49, 14-131
WritePartialResource procedure 13-23
writing order 14-36
writing systems. See scripts
‘wstr' resource type 8-42

IN-56

— Index

X, Y

XOR transfer mode 17-16
.XPP driver 32-31 to 32-37
getting zone name of your application
32-34 to 32-35
getting zone names on extended network
32-33, 32-36 to 32-37
getting zone names on local network
32-33, 32-35 to 32-36
parameter block 32-31
XPPParamBlock data type 32-31, 32-99
Z
ZIP (Zone Information Protocol)
32-32 to 32-37
zone information 32-31 to 32-37
all zones 32-37
local zone name 32-35

obtaining

32-7,

32-32 to 32-37

zones on local network 32-36
Zone Information Protocol 32-7, 32-32 to
32-37
zone information table 32-7

zone names, AppleTalk
zones, AppleTalk 32-7
zoom boxes
help balloon for
11-61

multiple monitors

window behavior

32-13, 32-16

11-10to 11-12, 11-58 to

2-23

2-23

THE APPLE PUBLISHING

SYSTEM

This Apple manual was written, edited, and composed on a desktop publishing system
using Apple Macintosh® computers and Microsoft Word software. Proof pages were
created on an Apple LaserWriter® IINTX printer. Final page negatives were output directly
from text files on an Agfa ProSet 9800 imagesetter. Line art was created using Adobe
Illustrator. PostScript®, the page-description language for the LaserWriter, was
developed by Adobe Systems Incorporated.
Text type is Times and display type is Helvetica Bold. Bullets are ITC Zapf Dingbats®.
Some elements, such as program listings, are set in Apple Courier.
Lead Writer: Sharon Everson
Writers: Paul Black, Patria Brown, Rob Dearborn, Tony Francis, Mitchell Gass,

Lori E. Kaplan, Marq Laube, Sue Luttner, Tim Monroe, Diane Patterson, Laine Rapin
Lead Developmental Editor: Sue Factor
Developmental Editors: Stella Hackell, Antonio Padial, Anne Szabla, George Truett
Indexing Specialist: Laurel Rezeau
Editorial Advisor: Lorraine Aochi
Lead Illustrator: Deb Dennis
Art staff: Tim Hughan, Sandee Karr, Peggy Kunz, Dave Olmos
Programmer: Ray Chiang
Technical Advisor: Sharon Everson
Production: Rex Wolf, Gerri Gray
Formatter: Roy Zitting
Proofreaders: Beverly Zegarski, Wendy Krafft
Inside Macintosh Manager: Trish Eastman
Special thanks to the Macintosh system software engineering team, for creating the system
software of the 1990s, and Macintosh Developer Technical Support, for being there.

>
>

me

The Official
Publication from

Apple Computer, Inc.

$44.95
$57.95

USA
CANAD

Inside Macintosh, Volume VI
Inside Macintosh is a six-volume set of books that describe how to write an application for
the Apple® Macintosh® family of computers. /nside Macintosh is the definitive guide and

reference for anyone writing software for the Macintosh computer.

Written by the people at Apple Computer, /nside Macintosh provides the essential

Volume VI is a significant addition to /nside Macintosh. It provides new information that

describes system software version 7.0 and also contains updated information on a number
of managers previously described in earlier volumes. This volume of /nside Macintosh
describes how your application can use the new routines in system software version 7.0 to

‘

else
gr

information you'll need to write software for the entire family of Macintosh computers.

| y sail &

*,)
~~
t

7

oe

ON

-

woo’ ”

els

eng

ae.

a share data with other applications
= provide automated copy and paste functions

= communicate with other applications
= provide on-line assistance for users using Balloon Help™
= draw TrueType™ fonts
= access data from remote sources, including databases
Volume VI also provides

= aroad map that shows each manager discussed in the volume and illustrates a pathway
through related information in previous volumes of /nside Macintosh
= code samples that show how to use specific routines to perform a particular task
= user interface guidelines that can help you develop your application to take advantage of
the Macintosh user interface in version 7.0
= compatibility guidelines that can help you develop your application so that it is
compatible across the Macintosh family of computers
« information on developing your application for worldwide markets

9" - PCR

The first two volumes of /nside Macintosh describe the routines in the Macintosh User
Interface Toolbox and the Macintosh Operating System. The third volume is a summary of
the Pascal interfaces for all routines described in Volumes I and II. The fourth and fifth
volumes describe features and routines introduced in the Macintosh Plus, Macintosh SE,

—-

and Macintosh II computers.

tas

Printed in U.S.A.
54495

Apple Computer, Inc.

20525 Mariani Avenue
Cupertino, California 95014

408-996-1010

ue

4

"Cea?

Addison-Wesley Publishing Company

9 "780201577556
ISBN

O-cO1-S? oF

